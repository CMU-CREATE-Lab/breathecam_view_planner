/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/photo-sphere-viewer/dist/photo-sphere-viewer.js":
/*!**********************************************************************!*\
  !*** ./node_modules/photo-sphere-viewer/dist/photo-sphere-viewer.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

/*!
* Photo Sphere Viewer 4.8.0
* @copyright 2014-2015 Jérémy Heleine
* @copyright 2015-2022 Damien "Mistic" Sorel
* @licence MIT (https://opensource.org/licenses/MIT)
*/
(function (global, factory) {
   true ? factory(exports, __webpack_require__(/*! three */ "./node_modules/three/build/three.cjs"), __webpack_require__(/*! uevent */ "./node_modules/uevent/browser.js")) :
  0;
})(this, (function (exports, three, uevent) { 'use strict';

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };
    return _extends.apply(this, arguments);
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;

    _setPrototypeOf(subClass, superClass);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  /**
   * @summary Custom error used in the lib
   * @param {string} message
   * @constructor
   * @memberOf PSV
   */
  function PSVError(message) {
    this.message = message; // Use V8's native method if available, otherwise fallback

    if ('captureStackTrace' in Error) {
      Error.captureStackTrace(this, PSVError);
    } else {
      this.stack = new Error().stack;
    }
  }

  PSVError.prototype = Object.create(Error.prototype);
  PSVError.prototype.name = 'PSVError';
  PSVError.prototype.constructor = PSVError;

  /**
   * @namespace PSV.adapters
   */

  /**
   * @summary Base adapters class
   * @memberof PSV.adapters
   * @abstract
   */

  var AbstractAdapter = /*#__PURE__*/function () {
    /**
     * @summary Unique identifier of the adapter
     * @member {string}
     * @readonly
     * @static
     */

    /**
     * @summary Indicates if the adapter supports panorama download natively
     * @type {boolean}
     * @readonly
     * @static
     */

    /**
     * @summary Indicated if the adapter can display an additional transparent image above the panorama
     * @type {boolean}
     */

    /**
     * @param {PSV.Viewer} psv
     */
    function AbstractAdapter(psv) {
      /**
       * @summary Reference to main controller
       * @type {PSV.Viewer}
       * @readonly
       */
      this.psv = psv;
    }
    /**
     * @summary Destroys the adapter
     */


    var _proto = AbstractAdapter.prototype;

    _proto.destroy = function destroy() {
      delete this.psv;
    }
    /**
     * @summary Indicates if the adapter supports transitions between panoramas
     * @param {*} panorama
     * @return {boolean}
     */
    ;

    _proto.supportsTransition = function supportsTransition(panorama) {
      // eslint-disable-line no-unused-vars
      return false;
    }
    /**
     * @summary Indicates if the adapter supports preload of a panorama
     * @param {*} panorama
     * @return {boolean}
     */
    ;

    _proto.supportsPreload = function supportsPreload(panorama) {
      // eslint-disable-line no-unused-vars
      return false;
    }
    /**
     * @abstract
     * @summary Loads the panorama texture(s)
     * @param {*} panorama
     * @param {PSV.PanoData | PSV.PanoDataProvider} [newPanoData]
     * @param {boolean} [useXmpPanoData]
     * @returns {Promise.<PSV.TextureData>}
     */
    ;

    _proto.loadTexture = function loadTexture(panorama, newPanoData, useXmpPanoData) {
      // eslint-disable-line no-unused-vars
      throw new PSVError('loadTexture not implemented');
    }
    /**
     * @abstract
     * @summary Creates the cube mesh
     * @param {number} [scale=1]
     * @returns {external:THREE.Mesh}
     */
    ;

    _proto.createMesh = function createMesh(scale) {

      // eslint-disable-line no-unused-vars
      throw new PSVError('createMesh not implemented');
    }
    /**
     * @abstract
     * @summary Applies the texture to the mesh
     * @param {external:THREE.Mesh} mesh
     * @param {PSV.TextureData} textureData
     * @param {boolean} [transition=false]
     */
    ;

    _proto.setTexture = function setTexture(mesh, textureData, transition) {

      // eslint-disable-line no-unused-vars
      throw new PSVError('setTexture not implemented');
    }
    /**
     * @abstract
     * @summary Changes the opacity of the mesh
     * @param {external:THREE.Mesh} mesh
     * @param {number} opacity
     */
    ;

    _proto.setTextureOpacity = function setTextureOpacity(mesh, opacity) {
      // eslint-disable-line no-unused-vars
      throw new PSVError('setTextureOpacity not implemented');
    }
    /**
     * @abstract
     * @summary Clear a loaded texture from memory
     * @param {PSV.TextureData} textureData
     */
    ;

    _proto.disposeTexture = function disposeTexture(textureData) {
      // eslint-disable-line no-unused-vars
      throw new PSVError('disposeTexture not implemented');
    }
    /**
     * @abstract
     * @summary Applies the overlay to the mesh
     * @param {external:THREE.Mesh} mesh
     * @param {PSV.TextureData} textureData
     * @param {number} opacity
     */
    ;

    _proto.setOverlay = function setOverlay(mesh, textureData, opacity) {
      // eslint-disable-line no-unused-vars
      throw new PSVError('setOverlay not implemented');
    }
    /**
     * @internal
     */
    ;

    /**
     * @internal
     */
    AbstractAdapter.createOverlayMaterial = function createOverlayMaterial(_temp) {
      var _extends2;

      var _ref = _temp === void 0 ? {} : _temp,
          additionalUniforms = _ref.additionalUniforms,
          overrideVertexShader = _ref.overrideVertexShader;

      return new three.ShaderMaterial({
        uniforms: _extends({}, additionalUniforms, (_extends2 = {}, _extends2[AbstractAdapter.OVERLAY_UNIFORMS.panorama] = {
          value: new three.Texture()
        }, _extends2[AbstractAdapter.OVERLAY_UNIFORMS.overlay] = {
          value: new three.Texture()
        }, _extends2[AbstractAdapter.OVERLAY_UNIFORMS.globalOpacity] = {
          value: 1.0
        }, _extends2[AbstractAdapter.OVERLAY_UNIFORMS.overlayOpacity] = {
          value: 1.0
        }, _extends2)),
        vertexShader: overrideVertexShader || "\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix *  modelViewMatrix * vec4( position, 1.0 );\n}",
        fragmentShader: "\nuniform sampler2D " + AbstractAdapter.OVERLAY_UNIFORMS.panorama + ";\nuniform sampler2D " + AbstractAdapter.OVERLAY_UNIFORMS.overlay + ";\nuniform float " + AbstractAdapter.OVERLAY_UNIFORMS.globalOpacity + ";\nuniform float " + AbstractAdapter.OVERLAY_UNIFORMS.overlayOpacity + ";\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec4 tColor1 = texture2D( " + AbstractAdapter.OVERLAY_UNIFORMS.panorama + ", vUv );\n  vec4 tColor2 = texture2D( " + AbstractAdapter.OVERLAY_UNIFORMS.overlay + ", vUv );\n  gl_FragColor = vec4(\n    mix( tColor1.rgb, tColor2.rgb, tColor2.a * " + AbstractAdapter.OVERLAY_UNIFORMS.overlayOpacity + " ),\n    " + AbstractAdapter.OVERLAY_UNIFORMS.globalOpacity + "\n  );\n}"
      });
    };

    return AbstractAdapter;
  }();
  AbstractAdapter.id = null;
  AbstractAdapter.supportsDownload = false;
  AbstractAdapter.supportsOverlay = false;
  AbstractAdapter.OVERLAY_UNIFORMS = {
    panorama: 'panorama',
    overlay: 'overlay',
    globalOpacity: 'globalOpacity',
    overlayOpacity: 'overlayOpacity'
  };

  /**
   * @namespace PSV.constants
   */

  /**
   * @summary Default duration of the transition between panoramas
   * @memberOf PSV.constants
   * @type {number}
   * @constant
   */
  var DEFAULT_TRANSITION = 1500;
  /**
   * @summary Number of pixels bellow which a mouse move will be considered as a click
   * @memberOf PSV.constants
   * @type {number}
   * @constant
   */

  var MOVE_THRESHOLD = 4;
  /**
   * @summary Delay in milliseconds between two clicks to consider a double click
   * @memberOf PSV.constants
   * @type {number}
   * @constant
   */

  var DBLCLICK_DELAY = 300;
  /**
   * @summary Delay in milliseconds to emulate a long touch
   * @memberOf PSV.constants
   * @type {number}
   * @constant
   */

  var LONGTOUCH_DELAY = 500;
  /**
   * @summary Delay in milliseconds to for the two fingers overlay to appear
   * @memberOf PSV.constants
   * @type {number}
   * @constant
   */

  var TWOFINGERSOVERLAY_DELAY = 100;
  /**
   * @summary Duration in milliseconds of the "ctrl zoom" overlay
   * @memberOf PSV.constants
   * @type {number}
   * @constant
   */

  var CTRLZOOM_TIMEOUT = 2000;
  /**
   * @summary Time size of the mouse position history used to compute inertia
   * @memberOf PSV.constants
   * @type {number}
   * @constant
   */

  var INERTIA_WINDOW = 300;
  /**
   * @summary Radius of the THREE.SphereGeometry, Half-length of the THREE.BoxGeometry
   * @memberOf PSV.constants
   * @type {number}
   * @constant
   */

  var SPHERE_RADIUS = 10;
  /**
   * @summary Property name added to viewer element
   * @memberOf PSV.constants
   * @type {string}
   * @constant
   */

  var VIEWER_DATA = 'photoSphereViewer';
  /**
   * @summary Property added the the main Mesh object
   * @memberOf PSV.constants
   * @type {string}
   * @constant
   */

  var MESH_USER_DATA = 'psvSphere';
  /**
   * @summary Available actions
   * @memberOf PSV.constants
   * @enum {string}
   * @constant
   */

  var ACTIONS = {
    ROTATE_LAT_UP: 'rotateLatitudeUp',
    ROTATE_LAT_DOWN: 'rotateLatitudeDown',
    ROTATE_LONG_RIGHT: 'rotateLongitudeRight',
    ROTATE_LONG_LEFT: 'rotateLongitudeLeft',
    ZOOM_IN: 'zoomIn',
    ZOOM_OUT: 'zoomOut',
    TOGGLE_AUTOROTATE: 'toggleAutorotate'
  };
  /**
   * @summary Available events names
   * @memberOf PSV.constants
   * @enum {string}
   * @constant
   */

  var EVENTS = {
    /**
     * @event autorotate
     * @memberof PSV
     * @summary Triggered when the automatic rotation is enabled/disabled
     * @param {boolean} enabled
     */
    AUTOROTATE: 'autorotate',

    /**
     * @event before-render
     * @memberof PSV
     * @summary Triggered before a render, used to modify the view
     * @param {number} timestamp - time provided by requestAnimationFrame
     * @param {number} elapsed - time elapsed from the previous frame
     */
    BEFORE_RENDER: 'before-render',

    /**
     * @event before-rotate
     * @memberOf PSV
     * @summary Triggered before a rotate operation, can be cancelled
     * @param {PSV.ExtendedPosition}
     */
    BEFORE_ROTATE: 'before-rotate',

    /**
     * @event click
     * @memberof PSV
     * @summary Triggered when the user clicks on the viewer (everywhere excluding the navbar and the side panel)
     * @param {PSV.ClickData} data
     */
    CLICK: 'click',

    /**
     * @event close-panel
     * @memberof PSV
     * @summary Triggered when the panel is closed
     * @param {string} [id]
     */
    CLOSE_PANEL: 'close-panel',

    /**
     * @event config-changed
     * @memberOf PSV
     * @summary Triggered after a call to setOption/setOptions
     * @param {string[]} name of changed options
     */
    CONFIG_CHANGED: 'config-changed',

    /**
     * @event dblclick
     * @memberof PSV
     * @summary Triggered when the user double clicks on the viewer. The simple `click` event is always fired before `dblclick`
     * @param {PSV.ClickData} data
     */
    DOUBLE_CLICK: 'dblclick',

    /**
     * @event fullscreen-updated
     * @memberof PSV
     * @summary Triggered when the fullscreen mode is enabled/disabled
     * @param {boolean} enabled
     */
    FULLSCREEN_UPDATED: 'fullscreen-updated',

    /**
     * @event hide-notification
     * @memberof PSV
     * @summary Triggered when the notification is hidden
     * @param {string} [id]
     */
    HIDE_NOTIFICATION: 'hide-notification',

    /**
     * @event hide-overlay
     * @memberof PSV
     * @summary Triggered when the overlay is hidden
     * @param {string} [id]
     */
    HIDE_OVERLAY: 'hide-overlay',

    /**
     * @event hide-tooltip
     * @memberof PSV
     * @summary Triggered when the tooltip is hidden
     * @param {*} Data associated to this tooltip
     */
    HIDE_TOOLTIP: 'hide-tooltip',

    /**
     * @event key-press
     * @memberof PSV
     * @summary Triggered when a key is pressed, can be cancelled
     * @param {string} key
     */
    KEY_PRESS: 'key-press',

    /**
     * @event load-progress
     * @memberof PSV
     * @summary Triggered when the loader value changes
     * @param {number} value from 0 to 100
     */
    LOAD_PROGRESS: 'load-progress',

    /**
     * @event open-panel
     * @memberof PSV
     * @summary Triggered when the panel is opened
     * @param {string} [id]
     */
    OPEN_PANEL: 'open-panel',

    /**
     * @event panorama-loaded
     * @memberof PSV
     * @summary Triggered when a panorama image has been loaded
     * @param {PSV.TextureData} textureData
     */
    PANORAMA_LOADED: 'panorama-loaded',

    /**
     * @event position-updated
     * @memberof PSV
     * @summary Triggered when the view longitude and/or latitude changes
     * @param {PSV.Position} position
     */
    POSITION_UPDATED: 'position-updated',

    /**
     * @event ready
     * @memberof PSV
     * @summary Triggered when the panorama image has been loaded and the viewer is ready to perform the first render
     */
    READY: 'ready',

    /**
     * @event render
     * @memberof PSV
     * @summary Triggered on each viewer render, **this event is triggered very often**
     */
    RENDER: 'render',

    /**
     * @event show-notification
     * @memberof PSV
     * @summary Triggered when the notification is shown
     * @param {string} [id]
     */
    SHOW_NOTIFICATION: 'show-notification',

    /**
     * @event show-overlay
     * @memberof PSV
     * @summary Triggered when the overlay is shown
     * @param {string} [id]
     */
    SHOW_OVERLAY: 'show-overlay',

    /**
     * @event show-tooltip
     * @memberof PSV
     * @summary Triggered when the tooltip is shown
     * @param {*} Data associated to this tooltip
     * @param {PSV.components.Tooltip} Instance of the tooltip
     */
    SHOW_TOOLTIP: 'show-tooltip',

    /**
     * @event size-updated
     * @memberof PSV
     * @summary Triggered when the viewer size changes
     * @param {PSV.Size} size
     */
    SIZE_UPDATED: 'size-updated',

    /**
     * @event stop-all
     * @memberof PSV
     * @summary Triggered when all current animations are stopped
     */
    STOP_ALL: 'stop-all',

    /**
     * @event zoom-updated
     * @memberof PSV
     * @summary Triggered when the zoom level changes
     * @param {number} zoomLevel
     */
    ZOOM_UPDATED: 'zoom-updated'
  };
  /**
   * @summary Available change events names
   * @memberOf PSV.constants
   * @enum {string}
   * @constant
   */

  var CHANGE_EVENTS = {
    /**
     * @event get-animate-position
     * @memberof PSV
     * @param {Position} position
     * @returns {Position}
     * @summary Called to alter the target position of an animation
     */
    GET_ANIMATE_POSITION: 'get-animate-position',

    /**
     * @event get-rotate-position
     * @memberof PSV
     * @param {Position} position
     * @returns {Position}
     * @summary Called to alter the target position of a rotation
     */
    GET_ROTATE_POSITION: 'get-rotate-position'
  };
  /**
   * @summary Special events emitted to listener using {@link Viewer#observeObjects}
   * @memberOf PSV.constants
   * @constant
   * @package
   */

  var OBJECT_EVENTS = {
    ENTER_OBJECT: 'enter-object',
    HOVER_OBJECT: 'hover-object',
    LEAVE_OBJECT: 'leave-object'
  };
  /**
   * @summary Internal identifiers for various stuff
   * @memberOf PSV.constants
   * @enum {string}
   * @constant
   */

  var IDS = {
    MENU: 'menu',
    TWO_FINGERS: 'twoFingers',
    CTRL_ZOOM: 'ctrlZoom',
    ERROR: 'error',
    DESCRIPTION: 'description'
  };
  /* eslint-disable */
  // @formatter:off

  /**
   * @summary Collection of easing functions
   * @memberOf PSV.constants
   * @see {@link https://gist.github.com/frederickk/6165768}
   * @type {Object<string, Function>}
   * @constant
   */

  var EASINGS = {
    linear: function linear(t) {
      return t;
    },
    inQuad: function inQuad(t) {
      return t * t;
    },
    outQuad: function outQuad(t) {
      return t * (2 - t);
    },
    inOutQuad: function inOutQuad(t) {
      return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
    },
    inCubic: function inCubic(t) {
      return t * t * t;
    },
    outCubic: function outCubic(t) {
      return --t * t * t + 1;
    },
    inOutCubic: function inOutCubic(t) {
      return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
    },
    inQuart: function inQuart(t) {
      return t * t * t * t;
    },
    outQuart: function outQuart(t) {
      return 1 - --t * t * t * t;
    },
    inOutQuart: function inOutQuart(t) {
      return t < .5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
    },
    inQuint: function inQuint(t) {
      return t * t * t * t * t;
    },
    outQuint: function outQuint(t) {
      return 1 + --t * t * t * t * t;
    },
    inOutQuint: function inOutQuint(t) {
      return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
    },
    inSine: function inSine(t) {
      return 1 - Math.cos(t * (Math.PI / 2));
    },
    outSine: function outSine(t) {
      return Math.sin(t * (Math.PI / 2));
    },
    inOutSine: function inOutSine(t) {
      return .5 - .5 * Math.cos(Math.PI * t);
    },
    inExpo: function inExpo(t) {
      return Math.pow(2, 10 * (t - 1));
    },
    outExpo: function outExpo(t) {
      return 1 - Math.pow(2, -10 * t);
    },
    inOutExpo: function inOutExpo(t) {
      return (t = t * 2 - 1) < 0 ? .5 * Math.pow(2, 10 * t) : 1 - .5 * Math.pow(2, -10 * t);
    },
    inCirc: function inCirc(t) {
      return 1 - Math.sqrt(1 - t * t);
    },
    outCirc: function outCirc(t) {
      return Math.sqrt(1 - (t - 1) * (t - 1));
    },
    inOutCirc: function inOutCirc(t) {
      return (t *= 2) < 1 ? .5 - .5 * Math.sqrt(1 - t * t) : .5 + .5 * Math.sqrt(1 - (t -= 2) * t);
    }
  }; // @formatter:on

  /* eslint-enable */

  /**
   * @summary Subset of key codes
   * @memberOf PSV.constants
   * @type {Object<string, string>}
   * @constant
   */

  var KEY_CODES = {
    Enter: 'Enter',
    Control: 'Control',
    Escape: 'Escape',
    Space: ' ',
    PageUp: 'PageUp',
    PageDown: 'PageDown',
    ArrowLeft: 'ArrowLeft',
    ArrowUp: 'ArrowUp',
    ArrowRight: 'ArrowRight',
    ArrowDown: 'ArrowDown',
    Delete: 'Delete',
    Plus: '+',
    Minus: '-'
  };

  var constants = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DEFAULT_TRANSITION: DEFAULT_TRANSITION,
    MOVE_THRESHOLD: MOVE_THRESHOLD,
    DBLCLICK_DELAY: DBLCLICK_DELAY,
    LONGTOUCH_DELAY: LONGTOUCH_DELAY,
    TWOFINGERSOVERLAY_DELAY: TWOFINGERSOVERLAY_DELAY,
    CTRLZOOM_TIMEOUT: CTRLZOOM_TIMEOUT,
    INERTIA_WINDOW: INERTIA_WINDOW,
    SPHERE_RADIUS: SPHERE_RADIUS,
    VIEWER_DATA: VIEWER_DATA,
    MESH_USER_DATA: MESH_USER_DATA,
    ACTIONS: ACTIONS,
    EVENTS: EVENTS,
    CHANGE_EVENTS: CHANGE_EVENTS,
    OBJECT_EVENTS: OBJECT_EVENTS,
    IDS: IDS,
    EASINGS: EASINGS,
    KEY_CODES: KEY_CODES
  });

  var LOCALSTORAGE_TOUCH_SUPPORT = VIEWER_DATA + "_touchSupport";
  /**
   * @summary General information about the system
   * @constant
   * @memberOf PSV
   * @property {boolean} loaded - Indicates if the system data has been loaded
   * @property {Function} load - Loads the system if not already loaded
   * @property {number} pixelRatio
   * @property {boolean} isWebGLSupported
   * @property {number} maxCanvasWidth
   * @property {string} mouseWheelEvent
   * @property {string} fullscreenEvent
   * @property {Function} getMaxCanvasWidth - Returns the max width of a canvas allowed by the browser
   * @property {{initial: boolean, promise: Promise<boolean>}} isTouchEnabled
   */

  var SYSTEM = {
    loaded: false,
    pixelRatio: 1,
    isWebGLSupported: false,
    isTouchEnabled: null,
    maxTextureWidth: 0,
    mouseWheelEvent: null,
    fullscreenEvent: null
  };
  /**
   * @summary Loads the system if not already loaded
   */

  SYSTEM.load = function () {
    if (!SYSTEM.loaded) {
      var ctx = getWebGLCtx();
      SYSTEM.loaded = true;
      SYSTEM.pixelRatio = window.devicePixelRatio || 1;
      SYSTEM.isWebGLSupported = ctx != null;
      SYSTEM.isTouchEnabled = isTouchEnabled();
      SYSTEM.maxTextureWidth = getMaxTextureWidth(ctx);
      SYSTEM.mouseWheelEvent = getMouseWheelEvent();
      SYSTEM.fullscreenEvent = getFullscreenEvent();
    }
  };

  var maxCanvasWidth = null;

  SYSTEM.getMaxCanvasWidth = function () {
    if (maxCanvasWidth === null) {
      maxCanvasWidth = getMaxCanvasWidth(SYSTEM.maxTextureWidth);
    }

    return maxCanvasWidth;
  };
  /**
   * @summary Tries to return a canvas webgl context
   * @returns {WebGLRenderingContext}
   * @private
   */


  function getWebGLCtx() {
    var canvas = document.createElement('canvas');
    var names = ['webgl', 'experimental-webgl', 'moz-webgl', 'webkit-3d'];
    var context = null;

    if (!canvas.getContext) {
      return null;
    }

    if (names.some(function (name) {
      try {
        context = canvas.getContext(name);
        return context !== null;
      } catch (e) {
        return false;
      }
    })) {
      return context;
    } else {
      return null;
    }
  }
  /**
   * @summary Detects if the user is using a touch screen
   * @returns {{initial: boolean, promise: Promise<boolean>}}
   * @private
   */


  function isTouchEnabled() {
    var initial = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

    if (LOCALSTORAGE_TOUCH_SUPPORT in localStorage) {
      initial = localStorage[LOCALSTORAGE_TOUCH_SUPPORT] === 'true';
    }

    var promise = new Promise(function (resolve) {
      var clear;

      var listenerMouse = function listenerMouse() {
        clear();
        localStorage[LOCALSTORAGE_TOUCH_SUPPORT] = false;
        resolve(false);
      };

      var listenerTouch = function listenerTouch() {
        clear();
        localStorage[LOCALSTORAGE_TOUCH_SUPPORT] = true;
        resolve(true);
      };

      var listenerTimeout = function listenerTimeout() {
        clear();
        localStorage[LOCALSTORAGE_TOUCH_SUPPORT] = initial;
        resolve(initial);
      };

      window.addEventListener('mousedown', listenerMouse, false);
      window.addEventListener('touchstart', listenerTouch, false);
      var listenerTimeoutId = setTimeout(listenerTimeout, 10000);

      clear = function clear() {
        window.removeEventListener('mousedown', listenerMouse);
        window.removeEventListener('touchstart', listenerTouch);
        clearTimeout(listenerTimeoutId);
      };
    });
    return {
      initial: initial,
      promise: promise
    };
  }
  /**
   * @summary Gets max texture width in WebGL context
   * @returns {number}
   * @private
   */


  function getMaxTextureWidth(ctx) {
    if (ctx !== null) {
      return ctx.getParameter(ctx.MAX_TEXTURE_SIZE);
    } else {
      return 0;
    }
  }
  /**
   * @summary Gets max canvas width supported by the browser.
   * We only test powers of 2 and height = width / 2 because that's what we need to generate WebGL textures
   * @param maxWidth
   * @return {number}
   * @private
   */


  function getMaxCanvasWidth(maxWidth) {
    var canvas = document.createElement('canvas');
    var ctx = canvas.getContext('2d');
    canvas.width = maxWidth;
    canvas.height = maxWidth / 2;

    while (canvas.width > 1024) {
      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, 1, 1);

      try {
        if (ctx.getImageData(0, 0, 1, 1).data[0] > 0) {
          return canvas.width;
        }
      } catch (e) {// continue
      }

      canvas.width /= 2;
      canvas.height /= 2;
    }

    throw new PSVError('Unable to detect system capabilities');
  }
  /**
   * @summary Gets the event name for mouse wheel
   * @returns {string}
   * @private
   */


  function getMouseWheelEvent() {
    if ('onwheel' in document.createElement('div')) {
      // Modern browsers support "wheel"
      return 'wheel';
    } else if (document.onmousewheel !== undefined) {
      // Webkit and IE support at least "mousewheel"
      return 'mousewheel';
    } else {
      // let's assume that remaining browsers are older Firefox
      return 'DOMMouseScroll';
    }
  }
  /**
   * @summary Map between fullsceen method and fullscreen event name
   * @type {Object<string, string>}
   * @readonly
   * @private
   */


  var FULLSCREEN_EVT_MAP = {
    exitFullscreen: 'fullscreenchange',
    webkitExitFullscreen: 'webkitfullscreenchange',
    mozCancelFullScreen: 'mozfullscreenchange',
    msExitFullscreen: 'MSFullscreenChange'
  };
  /**
   * @summary  Gets the event name for fullscreen
   * @returns {string}
   * @private
   */

  function getFullscreenEvent() {
    var validExits = Object.keys(FULLSCREEN_EVT_MAP).filter(function (exit) {
      return exit in document;
    });

    if (validExits.length) {
      return FULLSCREEN_EVT_MAP[validExits[0]];
    } else {
      return null;
    }
  }

  /**
   * @summary Toggles a CSS class
   * @memberOf PSV.utils
   * @param {HTMLElement|SVGElement} element
   * @param {string} className
   * @param {boolean} [active] - forced state
   */
  function toggleClass(element, className, active) {
    if (active === undefined) {
      element.classList.toggle(className);
    } else if (active) {
      element.classList.add(className);
    } else if (!active) {
      element.classList.remove(className);
    }
  }
  /**
   * @summary Adds one or several CSS classes to an element
   * @memberOf PSV.utils
   * @param {HTMLElement} element
   * @param {string} className
   */

  function addClasses(element, className) {
    var _element$classList;

    (_element$classList = element.classList).add.apply(_element$classList, className.split(' '));
  }
  /**
   * @summary Removes one or several CSS classes to an element
   * @memberOf PSV.utils
   * @param {HTMLElement} element
   * @param {string} className
   */

  function removeClasses(element, className) {
    var _element$classList2;

    (_element$classList2 = element.classList).remove.apply(_element$classList2, className.split(' '));
  }
  /**
   * @summary Searches if an element has a particular parent at any level including itself
   * @memberOf PSV.utils
   * @param {HTMLElement} el
   * @param {HTMLElement} parent
   * @returns {boolean}
   */

  function hasParent(el, parent) {
    var test = el;

    do {
      if (test === parent) {
        return true;
      }

      test = test.parentNode;
    } while (test);

    return false;
  }
  /**
   * @summary Gets the closest parent (can by itself)
   * @memberOf PSV.utils
   * @param {HTMLElement|SVGElement} el
   * @param {string} selector
   * @returns {HTMLElement}
   */

  function getClosest(el, selector) {
    // When el is document or window, the matches does not exist
    if (!(el != null && el.matches)) {
      return null;
    }

    var test = el;

    do {
      if (test.matches(selector)) {
        return test;
      }

      test = test instanceof SVGElement ? test.parentNode : test.parentElement;
    } while (test);

    return null;
  }
  /**
   * @summary Gets the position of an element in the viewer without reflow
   * @description Will gives the same result as getBoundingClientRect() as soon as there are no CSS transforms
   * @memberOf PSV.utils
   * @param {HTMLElement} el
   * @return {{left: number, top: number}}
   */

  function getPosition(el) {
    var left = 0;
    var top = 0;
    var test = el;

    while (test) {
      left += test.offsetLeft - test.scrollLeft + test.clientLeft;
      top += test.offsetTop - test.scrollTop + test.clientTop;
      test = test.offsetParent;
    }

    return {
      left: left,
      top: top
    };
  }
  /**
   * @summary Detects if fullscreen is enabled
   * @memberOf PSV.utils
   * @param {HTMLElement} elt
   * @returns {boolean}
   */

  function isFullscreenEnabled(elt) {
    return (document.fullscreenElement || document.webkitFullscreenElement) === elt;
  }
  /**
   * @summary Enters fullscreen mode
   * @memberOf PSV.utils
   * @param {HTMLElement} elt
   */

  function requestFullscreen(elt) {
    (elt.requestFullscreen || elt.webkitRequestFullscreen).call(elt);
  }
  /**
   * @summary Exits fullscreen mode
   * @memberOf PSV.utils
   */

  function exitFullscreen() {
    (document.exitFullscreen || document.webkitExitFullscreen).call(document);
  }
  /**
   * @summary Gets an element style
   * @memberOf PSV.utils
   * @param {HTMLElement} elt
   * @param {string} prop
   * @returns {*}
   */

  function getStyle(elt, prop) {
    return window.getComputedStyle(elt, null)[prop];
  }
  /**
   * @summary Normalize mousewheel values accross browsers
   * @memberOf PSV.utils
   * @description From Facebook's Fixed Data Table
   * {@link https://github.com/facebookarchive/fixed-data-table/blob/master/src/vendor_upstream/dom/normalizeWheel.js}
   * @copyright Facebook
   * @param {WheelEvent} event
   * @returns {{spinX: number, spinY: number, pixelX: number, pixelY: number}}
   */

  function normalizeWheel(event) {
    var PIXEL_STEP = 10;
    var LINE_HEIGHT = 40;
    var PAGE_HEIGHT = 800;
    var spinX = 0;
    var spinY = 0;
    var pixelX = 0;
    var pixelY = 0; // Legacy

    if ('detail' in event) {
      spinY = event.detail;
    }

    if ('wheelDelta' in event) {
      spinY = -event.wheelDelta / 120;
    }

    if ('wheelDeltaY' in event) {
      spinY = -event.wheelDeltaY / 120;
    }

    if ('wheelDeltaX' in event) {
      spinX = -event.wheelDeltaX / 120;
    } // side scrolling on FF with DOMMouseScroll


    if ('axis' in event && event.axis === event.HORIZONTAL_AXIS) {
      spinX = spinY;
      spinY = 0;
    }

    pixelX = spinX * PIXEL_STEP;
    pixelY = spinY * PIXEL_STEP;

    if ('deltaY' in event) {
      pixelY = event.deltaY;
    }

    if ('deltaX' in event) {
      pixelX = event.deltaX;
    }

    if ((pixelX || pixelY) && event.deltaMode) {
      // delta in LINE units
      if (event.deltaMode === 1) {
        pixelX *= LINE_HEIGHT;
        pixelY *= LINE_HEIGHT;
      } // delta in PAGE units
      else {
        pixelX *= PAGE_HEIGHT;
        pixelY *= PAGE_HEIGHT;
      }
    } // Fall-back if spin cannot be determined


    if (pixelX && !spinX) {
      spinX = pixelX < 1 ? -1 : 1;
    }

    if (pixelY && !spinY) {
      spinY = pixelY < 1 ? -1 : 1;
    }

    return {
      spinX: spinX,
      spinY: spinY,
      pixelX: pixelX,
      pixelY: pixelY
    };
  }

  /**
   * @deprecated use THREE.MathUtils.clamp
   */

  function bound(x, min, max) {
    return three.MathUtils.clamp(x, min, max);
  }
  /**
   * @summary Ensure a value is within 0 and `max`
   * @param {number} value
   * @param {number} max
   * @return {number}
   */

  function loop(value, max) {
    var result = value % max;

    if (result < 0) {
      result += max;
    }

    return result;
  }
  /**
   * @deprecated Use THREE.MathUtils.isPowerOfTwo
   */

  function isPowerOfTwo(x) {
    return three.MathUtils.isPowerOfTwo(x);
  }
  /**
   * @summary Computes the sum of an array
   * @memberOf PSV.utils
   * @param {number[]} array
   * @returns {number}
   */

  function sum(array) {
    return array.reduce(function (a, b) {
      return a + b;
    }, 0);
  }
  /**
   * @summary Computes the distance between two points
   * @memberOf PSV.utils
   * @param {PSV.Point} p1
   * @param {PSV.Point} p2
   * @returns {number}
   */

  function distance(p1, p2) {
    return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
  }
  /**
   * @summary Compute the shortest offset between two longitudes
   * @memberOf PSV.utils
   * @param {number} from
   * @param {number} to
   * @returns {number}
   */

  function getShortestArc(from, to) {
    var tCandidates = [0, // direct
    Math.PI * 2, // clock-wise cross zero
    -Math.PI * 2 // counter-clock-wise cross zero
    ];
    return tCandidates.reduce(function (value, candidate) {
      var newCandidate = to - from + candidate;
      return Math.abs(newCandidate) < Math.abs(value) ? newCandidate : value;
    }, Infinity);
  }
  /**
   * @summary Computes the angle between the current position and a target position
   * @memberOf PSV.utils
   * @param {PSV.Position} position1
   * @param {PSV.Position} position2
   * @returns {number}
   */

  function getAngle(position1, position2) {
    return Math.acos(Math.cos(position1.latitude) * Math.cos(position2.latitude) * Math.cos(position1.longitude - position2.longitude) + Math.sin(position1.latitude) * Math.sin(position2.latitude));
  }
  /**
   * @summary Returns the distance between two points on a sphere of radius one
   * {@link http://www.movable-type.co.uk/scripts/latlong.html}
   * @memberOf PSV.utils
   * @param {number[]} p1
   * @param {number[]} p2
   * @returns {number}
   */

  function greatArcDistance(p1, p2) {
    var λ1 = p1[0],
        φ1 = p1[1];
    var λ2 = p2[0],
        φ2 = p2[1];
    var x = (λ2 - λ1) * Math.cos((φ1 + φ2) / 2);
    var y = φ2 - φ1;
    return Math.sqrt(x * x + y * y);
  }

  /**
   * @summary Transforms a string to dash-case {@link https://github.com/shahata/dasherize}
   * @memberOf PSV.utils
   * @param {string} str
   * @returns {string}
   */
  function dasherize(str) {
    return str.replace(/[A-Z](?:(?=[^A-Z])|[A-Z]*(?=[A-Z][^A-Z]|$))/g, function (s, i) {
      return (i > 0 ? '-' : '') + s.toLowerCase();
    });
  }
  /**
   * @summary Returns a function, that, when invoked, will only be triggered at most once during a given window of time.
   * @memberOf PSV.utils
   * @copyright underscore.js - modified by Clément Prévost {@link http://stackoverflow.com/a/27078401}
   * @param {Function} func
   * @param {number} wait
   * @returns {Function}
   */

  function throttle(func, wait) {
    /* eslint-disable */
    var self, args, result;
    var timeout;
    var previous = 0;

    var later = function later() {
      previous = Date.now();
      timeout = undefined;
      result = func.apply(self, args);

      if (!timeout) {
        self = args = null;
      }
    };

    return function () {
      var now = Date.now();

      if (!previous) {
        previous = now;
      }

      var remaining = wait - (now - previous);
      self = this;
      args = arguments;

      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = undefined;
        }

        previous = now;
        result = func.apply(self, args);

        if (!timeout) {
          self = args = null;
        }
      } else if (!timeout) {
        timeout = setTimeout(later, remaining);
      }

      return result;
    };
    /* eslint-enable */
  }
  /**
   * @summary Test if an object is a plain object
   * @memberOf PSV.utils
   * @description Test if an object is a plain object, i.e. is constructed
   * by the built-in Object constructor and inherits directly from Object.prototype
   * or null. Some built-in objects pass the test, e.g. Math which is a plain object
   * and some host or exotic objects may pass also.
   * {@link http://stackoverflow.com/a/5878101/1207670}
   * @param {*} obj
   * @returns {boolean}
   */

  function isPlainObject(obj) {
    // Basic check for Type object that's not null
    if (typeof obj === 'object' && obj !== null) {
      // If Object.getPrototypeOf supported, use it
      if (typeof Object.getPrototypeOf === 'function') {
        var proto = Object.getPrototypeOf(obj);
        return proto === Object.prototype || proto === null;
      } // Otherwise, use internal class
      // This should be reliable as if getPrototypeOf not supported, is pre-ES5


      return Object.prototype.toString.call(obj) === '[object Object]';
    } // Not an object


    return false;
  }
  /**
   * @summary Merges the enumerable attributes of two objects
   * @memberOf PSV.utils
   * @description Replaces arrays and alters the target object.
   * @copyright Nicholas Fisher <nfisher110@gmail.com>
   * @param {Object} target
   * @param {Object} src
   * @returns {Object} target
   */

  function deepmerge(target, src) {
    /* eslint-disable */
    var first = src;
    return function merge(target, src) {
      if (Array.isArray(src)) {
        if (!target || !Array.isArray(target)) {
          target = [];
        } else {
          target.length = 0;
        }

        src.forEach(function (e, i) {
          target[i] = merge(null, e);
        });
      } else if (typeof src === 'object') {
        if (!target || Array.isArray(target)) {
          target = {};
        }

        Object.keys(src).forEach(function (key) {
          if (typeof src[key] !== 'object' || !src[key] || !isPlainObject(src[key])) {
            target[key] = src[key];
          } else if (src[key] != first) {
            if (!target[key]) {
              target[key] = merge(null, src[key]);
            } else {
              merge(target[key], src[key]);
            }
          }
        });
      } else {
        target = src;
      }

      return target;
    }(target, src);
    /* eslint-enable */
  }
  /**
   * @summary Deeply clones an object
   * @memberOf PSV.utils
   * @param {Object} src
   * @returns {Object}
   */

  function clone(src) {
    return deepmerge(null, src);
  }
  /**
   * @summery Test of an object is empty
   * @memberOf PSV.utils
   * @param {object} obj
   * @returns {boolean}
   */

  function isEmpty(obj) {
    return !obj || Object.keys(obj).length === 0 && obj.constructor === Object;
  }
  /**
   * @summary Loops over enumerable properties of an object
   * @memberOf PSV.utils
   * @param {Object} object
   * @param {Function} callback
   */

  function each(object, callback) {
    Object.keys(object).forEach(function (key) {
      callback(object[key], key);
    });
  }
  /**
   * @summary Returns if a valu is null or undefined
   * @memberOf PSV.utils
   * @param {*} val
   * @return {boolean}
   */

  function isNil(val) {
    return val === null || val === undefined;
  }
  /**
   * @summary Returns the first non null non undefined parameter
   * @memberOf PSV.utils
   * @param {*} values
   * @return {*}
   */

  function firstNonNull() {
    for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
      values[_key] = arguments[_key];
    }

    for (var _i = 0, _values = values; _i < _values.length; _i++) {
      var val = _values[_i];

      if (!isNil(val)) {
        return val;
      }
    }

    return undefined;
  }
  /**
   * @summary Returns deep equality between objects
   * {@link https://gist.github.com/egardner/efd34f270cc33db67c0246e837689cb9}
   * @param obj1
   * @param obj2
   * @return {boolean}
   * @private
   */

  function deepEqual(obj1, obj2) {
    if (obj1 === obj2) {
      return true;
    } else if (isObject(obj1) && isObject(obj2)) {
      if (Object.keys(obj1).length !== Object.keys(obj2).length) {
        return false;
      }

      for (var _i2 = 0, _Object$keys = Object.keys(obj1); _i2 < _Object$keys.length; _i2++) {
        var prop = _Object$keys[_i2];

        if (!deepEqual(obj1[prop], obj2[prop])) {
          return false;
        }
      }

      return true;
    } else {
      return false;
    }
  }

  function isObject(obj) {
    return typeof obj === 'object' && obj != null;
  }

  /**
   * @summary Returns the plugin constructor from the imported object
   * For retrocompatibility with previous default exports
   * @memberOf PSV.utils
   * @package
   */

  function pluginInterop(plugin, target) {
    if (plugin) {
      for (var _i = 0, _arr = [['_', plugin]].concat(Object.entries(plugin)); _i < _arr.length; _i++) {
        var _arr$_i = _arr[_i],
            p = _arr$_i[1];

        if (p.prototype instanceof target) {
          return p;
        }
      }
    }

    return null;
  }
  /**
   * @summary Builds an Error with name 'AbortError'
   * @memberOf PSV.utils
   * @return {Error}
   */

  function getAbortError() {
    var error = new Error('Loading was aborted.');
    error.name = 'AbortError';
    return error;
  }
  /**
   * @summary Tests if an Error has name 'AbortError'
   * @memberOf PSV.utils
   * @param {Error} err
   * @return {boolean}
   */

  function isAbortError(err) {
    return (err == null ? void 0 : err.name) === 'AbortError';
  }
  /**
   * @summary Displays a warning in the console
   * @memberOf PSV.utils
   * @param {string} message
   */

  function logWarn(message) {
    console.warn("PhotoSphereViewer: " + message);
  }
  /**
   * @summary Checks if an object is a {PSV.ExtendedPosition}, ie has x/y or longitude/latitude
   * @memberOf PSV.utils
   * @param {object} object
   * @returns {boolean}
   */

  function isExtendedPosition(object) {
    return [['x', 'y'], ['longitude', 'latitude']].some(function (_ref) {
      var key1 = _ref[0],
          key2 = _ref[1];
      return object[key1] !== undefined && object[key2] !== undefined;
    });
  }
  /**
   * @summary Returns the value of a given attribute in the panorama metadata
   * @memberOf PSV.utils
   * @param {string} data
   * @param {string} attr
   * @returns (number)
   */

  function getXMPValue(data, attr) {
    // XMP data are stored in children
    var result = data.match('<GPano:' + attr + '>(.*)</GPano:' + attr + '>');

    if (result !== null) {
      var val = parseInt(result[1], 10);
      return isNaN(val) ? null : val;
    } // XMP data are stored in attributes


    result = data.match('GPano:' + attr + '="(.*?)"');

    if (result !== null) {
      var _val = parseInt(result[1], 10);

      return isNaN(_val) ? null : _val;
    }

    return null;
  }
  /**
   * @readonly
   * @private
   * @type {{top: string, left: string, bottom: string, center: string, right: string}}
   */

  var CSS_POSITIONS = {
    top: '0%',
    bottom: '100%',
    left: '0%',
    right: '100%',
    center: '50%'
  };
  /**
   * @summary Translate CSS values like "top center" or "10% 50%" as top and left positions
   * @memberOf PSV.utils
   * @description The implementation is as close as possible to the "background-position" specification
   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-position}
   * @param {string|PSV.Point} value
   * @returns {PSV.Point}
   */

  function parsePosition(value) {
    if (!value) {
      return {
        x: 0.5,
        y: 0.5
      };
    }

    if (typeof value === 'object') {
      return value;
    }

    var tokens = value.toLocaleLowerCase().split(' ').slice(0, 2);

    if (tokens.length === 1) {
      if (CSS_POSITIONS[tokens[0]] !== undefined) {
        tokens = [tokens[0], 'center'];
      } else {
        tokens = [tokens[0], tokens[0]];
      }
    }

    var xFirst = tokens[1] !== 'left' && tokens[1] !== 'right' && tokens[0] !== 'top' && tokens[0] !== 'bottom';
    tokens = tokens.map(function (token) {
      return CSS_POSITIONS[token] || token;
    });

    if (!xFirst) {
      tokens.reverse();
    }

    var parsed = tokens.join(' ').match(/^([0-9.]+)% ([0-9.]+)%$/);

    if (parsed) {
      return {
        x: parseFloat(parsed[1]) / 100,
        y: parseFloat(parsed[2]) / 100
      };
    } else {
      return {
        x: 0.5,
        y: 0.5
      };
    }
  }
  /**
   * @readonly
   * @private
   */

  var X_VALUES = ['left', 'center', 'right'];
  /**
   * @readonly
   * @private
   */

  var Y_VALUES = ['top', 'center', 'bottom'];
  /**
   * @readonly
   * @private
   */

  var POS_VALUES = [].concat(X_VALUES, Y_VALUES);
  /**
   * @readonly
   * @private
   */

  var CENTER = 'center';
  /**
   * @summary Parse a CSS-like position into an array of position keywords among top, bottom, left, right and center
   * @memberOf PSV.utils
   * @param {string | string[]} value
   * @param {object} [options]
   * @param {boolean} [options.allowCenter=true] allow "center center"
   * @param {boolean} [options.cssOrder=true] force CSS order (y axis then x axis)
   * @return {string[]}
   */

  function cleanPosition(value, _temp) {
    var _ref2 = _temp === void 0 ? {
      allowCenter: true,
      cssOrder: true
    } : _temp,
        allowCenter = _ref2.allowCenter,
        cssOrder = _ref2.cssOrder;

    if (!value) {
      return null;
    }

    if (typeof value === 'string') {
      value = value.split(' ');
    }

    if (value.length === 1) {
      if (value[0] === CENTER) {
        value = [CENTER, CENTER];
      } else if (X_VALUES.indexOf(value[0]) !== -1) {
        value = [CENTER, value[0]];
      } else if (Y_VALUES.indexOf(value[0]) !== -1) {
        value = [value[0], CENTER];
      }
    }

    if (value.length !== 2 || POS_VALUES.indexOf(value[0]) === -1 || POS_VALUES.indexOf(value[1]) === -1) {
      logWarn("Unparsable position " + value);
      return null;
    }

    if (!allowCenter && value[0] === CENTER && value[1] === CENTER) {
      logWarn("Invalid position center center");
      return null;
    }

    if (cssOrder && !positionIsOrdered(value)) {
      value = [value[1], value[0]];
    }

    if (value[1] === CENTER && X_VALUES.indexOf(value[0]) !== -1) {
      value = [CENTER, value[0]];
    }

    if (value[0] === CENTER && Y_VALUES.indexOf(value[1]) !== -1) {
      value = [value[1], CENTER];
    }

    return value;
  }
  /**
   * @summary Checks if an array of two positions is ordered (y axis then x axis)
   * @param {string[]} value
   * @return {boolean}
   */

  function positionIsOrdered(value) {
    return Y_VALUES.indexOf(value[0]) !== -1 && X_VALUES.indexOf(value[1]) !== -1;
  }
  /**
   * @summary Parses an speed
   * @memberOf PSV.utils
   * @param {string|number} speed - The speed, in radians/degrees/revolutions per second/minute
   * @returns {number} radians per second
   * @throws {PSV.PSVError} when the speed cannot be parsed
   */

  function parseSpeed(speed) {
    var parsed;

    if (typeof speed === 'string') {
      var speedStr = speed.toString().trim(); // Speed extraction

      var speedValue = parseFloat(speedStr.replace(/^(-?[0-9]+(?:\.[0-9]*)?).*$/, '$1'));
      var speedUnit = speedStr.replace(/^-?[0-9]+(?:\.[0-9]*)?(.*)$/, '$1').trim(); // "per minute" -> "per second"

      if (speedUnit.match(/(pm|per minute)$/)) {
        speedValue /= 60;
      } // Which unit?


      switch (speedUnit) {
        // Degrees per minute / second
        case 'dpm':
        case 'degrees per minute':
        case 'dps':
        case 'degrees per second':
          parsed = three.MathUtils.degToRad(speedValue);
          break;
        // Radians per minute / second

        case 'rdpm':
        case 'radians per minute':
        case 'rdps':
        case 'radians per second':
          parsed = speedValue;
          break;
        // Revolutions per minute / second

        case 'rpm':
        case 'revolutions per minute':
        case 'rps':
        case 'revolutions per second':
          parsed = speedValue * Math.PI * 2;
          break;
        // Unknown unit

        default:
          throw new PSVError('Unknown speed unit "' + speedUnit + '"');
      }
    } else {
      parsed = speed;
    }

    return parsed;
  }
  /**
   * @summary Parses an angle value in radians or degrees and returns a normalized value in radians
   * @memberOf PSV.utils
   * @param {string|number} angle - eg: 3.14, 3.14rad, 180deg
   * @param {boolean} [zeroCenter=false] - normalize between -Pi - Pi instead of 0 - 2*Pi
   * @param {boolean} [halfCircle=zeroCenter] - normalize between -Pi/2 - Pi/2 instead of -Pi - Pi
   * @returns {number}
   * @throws {PSV.PSVError} when the angle cannot be parsed
   */

  function parseAngle(angle, zeroCenter, halfCircle) {
    if (zeroCenter === void 0) {
      zeroCenter = false;
    }

    if (halfCircle === void 0) {
      halfCircle = zeroCenter;
    }

    var parsed;

    if (typeof angle === 'string') {
      var match = angle.toLowerCase().trim().match(/^(-?[0-9]+(?:\.[0-9]*)?)(.*)$/);

      if (!match) {
        throw new PSVError('Unknown angle "' + angle + '"');
      }

      var value = parseFloat(match[1]);
      var unit = match[2];

      if (unit) {
        switch (unit) {
          case 'deg':
          case 'degs':
            parsed = three.MathUtils.degToRad(value);
            break;

          case 'rad':
          case 'rads':
            parsed = value;
            break;

          default:
            throw new PSVError('Unknown angle unit "' + unit + '"');
        }
      } else {
        parsed = value;
      }
    } else if (typeof angle === 'number' && !isNaN(angle)) {
      parsed = angle;
    } else {
      throw new PSVError('Unknown angle "' + angle + '"');
    }

    parsed = loop(zeroCenter ? parsed + Math.PI : parsed, Math.PI * 2);
    return zeroCenter ? three.MathUtils.clamp(parsed - Math.PI, -Math.PI / (halfCircle ? 2 : 1), Math.PI / (halfCircle ? 2 : 1)) : parsed;
  }
  /**
   * @summary Creates a THREE texture from an image
   * @memberOf PSV.utils
   * @param {HTMLImageElement | HTMLCanvasElement} img
   * @return {external:THREE.Texture}
   */

  function createTexture(img) {
    var texture = new three.Texture(img);
    texture.needsUpdate = true;
    texture.minFilter = three.LinearFilter;
    texture.generateMipmaps = false;
    return texture;
  }
  var quaternion = new three.Quaternion();
  /**
   * @summary Applies the inverse of Euler angles to a vector
   * @memberOf PSV.utils
   * @param {external:THREE.Vector3} vector
   * @param {external:THREE.Euler} euler
   */

  function applyEulerInverse(vector, euler) {
    quaternion.setFromEuler(euler).invert();
    vector.applyQuaternion(quaternion);
  }

  /**
   * @callback OnTick
   * @summary Function called for each animation frame with computed properties
   * @memberOf PSV.utils.Animation
   * @param {Object.<string, number>} properties - current values
   * @param {float} progress - 0 to 1
   */

  /**
   * @summary Interpolation helper for animations
   * @memberOf PSV.utils
   * @description
   * Implements the Promise API with an additional "cancel" method.
   * The promise is resolved with `true` when the animation is completed and `false` if the animation is cancelled.
   * @example
   * const anim = new Animation({
   *     properties: {
   *         width: {start: 100, end: 200}
   *     },
   *     duration: 5000,
   *     onTick: (properties) => element.style.width = `${properties.width}px`;
   * });
   *
   * anim.then((completed) => ...);
   *
   * anim.cancel()
   */

  var Animation = /*#__PURE__*/function () {
    /**
     * @param {Object} options
     * @param {Object.<string, Object>} options.properties
     * @param {number} options.properties[].start
     * @param {number} options.properties[].end
     * @param {number} options.duration
     * @param {number} [options.delay=0]
     * @param {string} [options.easing='linear']
     * @param {PSV.utils.Animation.OnTick} options.onTick - called on each frame
     */
    function Animation(options) {
      var _this = this;

      this.__callbacks = [];

      if (options) {
        if (!options.easing || typeof options.easing === 'string') {
          options.easing = EASINGS[options.easing || 'linear'];
        }

        this.__start = null;
        this.options = options;

        if (options.delay) {
          this.__delayTimeout = setTimeout(function () {
            _this.__delayTimeout = null;
            _this.__animationFrame = window.requestAnimationFrame(function (t) {
              return _this.__run(t);
            });
          }, options.delay);
        } else {
          this.__animationFrame = window.requestAnimationFrame(function (t) {
            return _this.__run(t);
          });
        }
      } else {
        this.__resolved = true;
      }
    }
    /**
     * @summary Main loop for the animation
     * @param {number} timestamp
     * @private
     */


    var _proto = Animation.prototype;

    _proto.__run = function __run(timestamp) {
      var _this2 = this;

      if (this.__cancelled) {
        return;
      } // first iteration


      if (this.__start === null) {
        this.__start = timestamp;
      } // compute progress


      var progress = (timestamp - this.__start) / this.options.duration;
      var current = {};

      if (progress < 1.0) {
        // interpolate properties
        each(this.options.properties, function (prop, name) {
          if (prop) {
            current[name] = prop.start + (prop.end - prop.start) * _this2.options.easing(progress);
          }
        });
        this.options.onTick(current, progress);
        this.__animationFrame = window.requestAnimationFrame(function (t) {
          return _this2.__run(t);
        });
      } else {
        // call onTick one last time with final values
        each(this.options.properties, function (prop, name) {
          if (prop) {
            current[name] = prop.end;
          }
        });
        this.options.onTick(current, 1.0);
        this.__animationFrame = window.requestAnimationFrame(function () {
          _this2.__resolved = true;

          _this2.__resolve(true);
        });
      }
    }
    /**
     * @private
     */
    ;

    _proto.__resolve = function __resolve(value) {
      this.__callbacks.forEach(function (cb) {
        return cb(value);
      });

      this.__callbacks.length = 0;
    }
    /**
     * @summary Promise chaining
     * @param {Function} [onFulfilled] - Called when the animation is complete (true) or cancelled (false)
     * @returns {Promise}
     */
    ;

    _proto.then = function then(onFulfilled) {
      var _this3 = this;

      if (this.__resolved || this.__cancelled) {
        return Promise.resolve(this.__resolved).then(onFulfilled);
      }

      return new Promise(function (resolve) {
        _this3.__callbacks.push(resolve);
      }).then(onFulfilled);
    }
    /**
     * @summary Cancels the animation
     */
    ;

    _proto.cancel = function cancel() {
      if (!this.__cancelled && !this.__resolved) {
        this.__cancelled = true;

        this.__resolve(false);

        if (this.__delayTimeout) {
          window.clearTimeout(this.__delayTimeout);
          this.__delayTimeout = null;
        }

        if (this.__animationFrame) {
          window.cancelAnimationFrame(this.__animationFrame);
          this.__animationFrame = null;
        }
      }
    };

    return Animation;
  }();

  /**
   * @summary Represents a variable that can dynamically change with time (using requestAnimationFrame)
   * @memberOf PSV.utils
   */

  var Dynamic = /*#__PURE__*/function () {
    /**
     * @param {Function} [fn] Callback function
     * @param {number} [defaultValue] Default position
     * @param {number} [min] Minimum position
     * @param {number} [max] Maximum position
     * @param {boolean} [loopValue] Loop value between min and max
     */
    function Dynamic(fn, defaultValue, min, max, loopValue) {
      if (defaultValue === void 0) {
        defaultValue = 0;
      }

      if (min === void 0) {
        min = -Infinity;
      }

      if (max === void 0) {
        max = Infinity;
      }

      if (loopValue === void 0) {
        loopValue = false;
      }

      /**
       * @type {Function}
       * @private
       * @readonly
       */
      this.fn = fn;
      /**
       * @type {number}
       * @private
       */

      this.mode = Dynamic.STOP;
      /**
       * @type {number}
       * @private
       */

      this.speed = 0;
      /**
       * @type {number}
       * @private
       */

      this.speedMult = 1;
      /**
       * @type {number}
       * @private
       */

      this.currentSpeed = 0;
      /**
       * @type {number}
       * @private
       */

      this.target = 0;
      /**
       * @type {number}
       * @readonly
       */

      this.current = defaultValue;
      /**
       * @type {number}
       * @private
       */

      this.min = min;
      /**
       * @type {number}
       * @private
       */

      this.max = max;
      /**
       * @type {boolean}
       * @private
       */

      this.loopValue = loopValue;

      if (loopValue && min !== 0) {
        throw new PSVError('invalid config');
      }

      if (this.fn) {
        this.fn(defaultValue);
      }
    }
    /**
     * Changes base speed
     * @param {number} speed
     */


    var _proto = Dynamic.prototype;

    _proto.setSpeed = function setSpeed(speed) {
      this.speed = speed;
    }
    /**
     * Defines the target position
     * @param {number} position
     * @param {number} [speedMult=1]
     */
    ;

    _proto.goto = function goto(position, speedMult) {
      if (speedMult === void 0) {
        speedMult = 1;
      }

      this.mode = Dynamic.POSITION;
      this.target = this.loopValue ? loop(position, this.max) : three.MathUtils.clamp(position, this.min, this.max);
      this.speedMult = speedMult;
    }
    /**
     * Increase/decrease the target position
     * @param {number} step
     * @param {number} [speedMult=1]
     */
    ;

    _proto.step = function step(_step, speedMult) {
      if (speedMult === void 0) {
        speedMult = 1;
      }

      if (this.mode !== Dynamic.POSITION) {
        this.target = this.current;
      }

      this.goto(this.target + _step, speedMult);
    }
    /**
     * Starts infinite movement
     * @param {boolean} [invert=false]
     * @param {number} [speedMult=1]
     */
    ;

    _proto.roll = function roll(invert, speedMult) {
      if (invert === void 0) {
        invert = false;
      }

      if (speedMult === void 0) {
        speedMult = 1;
      }

      this.mode = Dynamic.INFINITE;
      this.target = invert ? -Infinity : Infinity;
      this.speedMult = speedMult;
    }
    /**
     * Stops movement
     */
    ;

    _proto.stop = function stop() {
      this.mode = Dynamic.STOP;
    }
    /**
     * Defines the current position and immediately stops movement
     * @param {number} value
     */
    ;

    _proto.setValue = function setValue(value) {
      this.target = this.loopValue ? loop(value, this.max) : three.MathUtils.clamp(value, this.min, this.max);
      this.mode = Dynamic.STOP;

      if (this.target !== this.current) {
        this.current = this.target;

        if (this.fn) {
          this.fn(this.current);
        }

        return true;
      }

      return false;
    }
    /**
     * @package
     */
    ;

    _proto.update = function update(elapsed) {
      // in position mode switch to stop mode when in the decceleration window
      if (this.mode === Dynamic.POSITION) {
        // in loop mode, alter "current" to avoid crossing the origin
        if (this.loopValue && Math.abs(this.target - this.current) > this.max / 2) {
          this.current = this.current < this.target ? this.current + this.max : this.current - this.max;
        }

        var dstStop = this.currentSpeed * this.currentSpeed / (this.speed * this.speedMult * 4);

        if (Math.abs(this.target - this.current) <= dstStop) {
          this.mode = Dynamic.STOP;
        }
      } // compute speed


      var targetSpeed = this.mode === Dynamic.STOP ? 0 : this.speed * this.speedMult;

      if (this.target < this.current) {
        targetSpeed = -targetSpeed;
      }

      if (this.currentSpeed < targetSpeed) {
        this.currentSpeed = Math.min(targetSpeed, this.currentSpeed + elapsed / 1000 * this.speed * this.speedMult * 2);
      } else if (this.currentSpeed > targetSpeed) {
        this.currentSpeed = Math.max(targetSpeed, this.currentSpeed - elapsed / 1000 * this.speed * this.speedMult * 2);
      } // compute new position


      var next = null;

      if (this.current > this.target && this.currentSpeed) {
        next = Math.max(this.target, this.current + this.currentSpeed * elapsed / 1000);
      } else if (this.current < this.target && this.currentSpeed) {
        next = Math.min(this.target, this.current + this.currentSpeed * elapsed / 1000);
      } // apply value


      if (next !== null) {
        next = this.loopValue ? loop(next, this.max) : three.MathUtils.clamp(next, this.min, this.max);

        if (next !== this.current) {
          this.current = next;

          if (this.fn) {
            this.fn(this.current);
          }

          return true;
        }
      }

      return false;
    };

    return Dynamic;
  }();
  Dynamic.STOP = 0;
  Dynamic.INFINITE = 1;
  Dynamic.POSITION = 2;

  /**
   * @summary Wrapper for multiple {@link PSV.utils.Dynamic} evolving together
   * @memberOf PSV.utils
   */

  var MultiDynamic = /*#__PURE__*/function () {
    /**
     * @param {Record<string, PSV.utils.Dynamic>} dynamics
     * @param {Function} [fn] Callback function
     */
    function MultiDynamic(dynamics, fn) {
      /**
       * @type {Function}
       * @private
       * @readonly
       */
      this.fn = fn;
      /**
       * @type {Record<string, PSV.utils.Dynamic>}
       * @private
       * @readonly
       */

      this.dynamics = dynamics;

      if (this.fn) {
        this.fn(this.current);
      }
    }
    /**
     * Changes base speed
     * @param {number} speed
     */


    var _proto = MultiDynamic.prototype;

    _proto.setSpeed = function setSpeed(speed) {
      each(this.dynamics, function (d) {
        d.setSpeed(speed);
      });
    }
    /**
     * Defines the target positions
     * @param {Record<string, number>} positions
     * @param {number} [speedMult=1]
     */
    ;

    _proto.goto = function goto(positions, speedMult) {
      var _this = this;

      if (speedMult === void 0) {
        speedMult = 1;
      }

      each(positions, function (position, name) {
        _this.dynamics[name].goto(position, speedMult);
      });
    }
    /**
     * Increase/decrease the target positions
     * @param {Record<string, number>} steps
     * @param {number} [speedMult=1]
     */
    ;

    _proto.step = function step(steps, speedMult) {
      var _this2 = this;

      if (speedMult === void 0) {
        speedMult = 1;
      }

      each(steps, function (step, name) {
        _this2.dynamics[name].step(step, speedMult);
      });
    }
    /**
     * Starts infinite movements
     * @param {Record<string, boolean>} rolls
     * @param {number} [speedMult=1]
     */
    ;

    _proto.roll = function roll(rolls, speedMult) {
      var _this3 = this;

      if (speedMult === void 0) {
        speedMult = 1;
      }

      each(rolls, function (roll, name) {
        _this3.dynamics[name].roll(roll, speedMult);
      });
    }
    /**
     * Stops movements
     */
    ;

    _proto.stop = function stop() {
      each(this.dynamics, function (d) {
        return d.stop();
      });
    }
    /**
     * Defines the current positions and immediately stops movements
     * @param {Record<string, number>} values
     */
    ;

    _proto.setValue = function setValue(values) {
      var _this4 = this;

      var hasUpdates = false;
      each(values, function (value, name) {
        hasUpdates |= _this4.dynamics[name].setValue(value);
      });

      if (hasUpdates && this.fn) {
        this.fn(this.current);
      }

      return hasUpdates;
    }
    /**
     * @package
     */
    ;

    _proto.update = function update(elapsed) {
      var hasUpdates = false;
      each(this.dynamics, function (dynamic) {
        hasUpdates |= dynamic.update(elapsed);
      });

      if (hasUpdates && this.fn) {
        this.fn(this.current);
      }

      return hasUpdates;
    };

    _createClass(MultiDynamic, [{
      key: "current",
      get:
      /**
       * @type {Object<string, number>}
       * @readonly
       */
      function get() {
        var values = {};
        each(this.dynamics, function (dynamic, name) {
          values[name] = dynamic.current;
        });
        return values;
      }
    }]);

    return MultiDynamic;
  }();

  /**
   * @summary Helper to make sliders elements
   * @memberOf PSV.utils
   */

  var Slider = /*#__PURE__*/function (_EventEmitter) {
    _inheritsLoose(Slider, _EventEmitter);

    function Slider(_ref) {
      var _this;

      var psv = _ref.psv,
          container = _ref.container,
          direction = _ref.direction,
          onUpdate = _ref.onUpdate;
      _this = _EventEmitter.call(this) || this;
      /**
       * @summary Reference to main controller
       * @type {PSV.Viewer}
       * @readonly
       */

      _this.psv = psv;
      /**
       * @member {HTMLElement}
       * @readonly
       */

      _this.container = container;
      /**
       * @summary Internal properties
       * @member {Object}
       * @protected
       * @property {boolean} mousedown
       * @property {number} mediaMinWidth
       */

      _this.prop = {
        onUpdate: onUpdate,
        direction: direction,
        mousedown: false,
        mouseover: false
      };

      _this.container.addEventListener('click', _assertThisInitialized(_this));

      _this.container.addEventListener('mousedown', _assertThisInitialized(_this));

      _this.container.addEventListener('mouseenter', _assertThisInitialized(_this));

      _this.container.addEventListener('mouseleave', _assertThisInitialized(_this));

      _this.container.addEventListener('touchstart', _assertThisInitialized(_this));

      _this.container.addEventListener('mousemove', _assertThisInitialized(_this), true);

      _this.container.addEventListener('touchmove', _assertThisInitialized(_this), true);

      window.addEventListener('mouseup', _assertThisInitialized(_this));
      window.addEventListener('touchend', _assertThisInitialized(_this));
      return _this;
    }
    /**
     * @protected
     */


    var _proto = Slider.prototype;

    _proto.destroy = function destroy() {
      window.removeEventListener('mouseup', this);
      window.removeEventListener('touchend', this);
    }
    /**
     * @summary Handles events
     * @param {Event} e
     * @private
     */
    ;

    _proto.handleEvent = function handleEvent(e) {
      /* eslint-disable */
      switch (e.type) {
        // @formatter:off
        case 'click':
          e.stopPropagation();
          break;

        case 'mousedown':
          this.__onMouseDown(e);

          break;

        case 'mouseenter':
          this.__onMouseEnter(e);

          break;

        case 'mouseleave':
          this.__onMouseLeave(e);

          break;

        case 'touchstart':
          this.__onTouchStart(e);

          break;

        case 'mousemove':
          this.__onMouseMove(e);

          break;

        case 'touchmove':
          this.__onTouchMove(e);

          break;

        case 'mouseup':
          this.__onMouseUp(e);

          break;

        case 'touchend':
          this.__onTouchEnd(e);

          break;
        // @formatter:on
      }
      /* eslint-enable */

    }
    /**
     * @private
     */
    ;

    _proto.__onMouseDown = function __onMouseDown(evt) {
      this.prop.mousedown = true;

      this.__update(evt, true);
    }
    /**
     * @private
     */
    ;

    _proto.__onMouseEnter = function __onMouseEnter(evt) {
      this.prop.mouseover = true;

      this.__update(evt, true);
    }
    /**
     * @private
     */
    ;

    _proto.__onTouchStart = function __onTouchStart(evt) {
      this.prop.mouseover = true;
      this.prop.mousedown = true;

      this.__update(evt.changedTouches[0], true);
    }
    /**
     * @private
     */
    ;

    _proto.__onMouseMove = function __onMouseMove(evt) {
      if (this.prop.mousedown || this.prop.mouseover) {
        evt.stopPropagation();

        this.__update(evt, true);
      }
    }
    /**
     * @private
     */
    ;

    _proto.__onTouchMove = function __onTouchMove(evt) {
      if (this.prop.mousedown || this.prop.mouseover) {
        evt.stopPropagation();

        this.__update(evt.changedTouches[0], true);
      }
    }
    /**
     * @private
     */
    ;

    _proto.__onMouseUp = function __onMouseUp(evt) {
      if (this.prop.mousedown) {
        this.prop.mousedown = false;

        this.__update(evt, false);
      }
    }
    /**
     * @private
     */
    ;

    _proto.__onMouseLeave = function __onMouseLeave(evt) {
      if (this.prop.mouseover) {
        this.prop.mouseover = false;

        this.__update(evt, true);
      }
    }
    /**
     * @private
     */
    ;

    _proto.__onTouchEnd = function __onTouchEnd(evt) {
      if (this.prop.mousedown) {
        this.prop.mouseover = false;
        this.prop.mousedown = false;

        this.__update(evt.changedTouches[0], false);
      }
    }
    /**
     * @private
     */
    ;

    _proto.__update = function __update(evt, moving) {
      var boundingClientRect = this.container.getBoundingClientRect();
      var cursor = evt[this.vertical ? 'clientY' : 'clientX'];
      var pos = boundingClientRect[this.vertical ? 'bottom' : 'left'];
      var size = boundingClientRect[this.vertical ? 'height' : 'width'];
      var val = Math.abs((pos - cursor) / size);
      this.prop.onUpdate({
        value: val,
        click: !moving,
        mousedown: this.prop.mousedown,
        mouseover: this.prop.mouseover,
        cursor: evt
      });
    };

    _createClass(Slider, [{
      key: "vertical",
      get:
      /**
       * @type {boolean}
       * @readonly
       */
      function get() {
        return this.prop.direction === Slider.VERTICAL;
      }
    }]);

    return Slider;
  }(uevent.EventEmitter);
  Slider.VERTICAL = 1;
  Slider.HORIZONTAL = 2;

  /**
   * @namespace PSV.utils
   */

  var index = /*#__PURE__*/Object.freeze({
    __proto__: null,
    toggleClass: toggleClass,
    addClasses: addClasses,
    removeClasses: removeClasses,
    hasParent: hasParent,
    getClosest: getClosest,
    getPosition: getPosition,
    isFullscreenEnabled: isFullscreenEnabled,
    requestFullscreen: requestFullscreen,
    exitFullscreen: exitFullscreen,
    getStyle: getStyle,
    normalizeWheel: normalizeWheel,
    bound: bound,
    loop: loop,
    isPowerOfTwo: isPowerOfTwo,
    sum: sum,
    distance: distance,
    getShortestArc: getShortestArc,
    getAngle: getAngle,
    greatArcDistance: greatArcDistance,
    dasherize: dasherize,
    throttle: throttle,
    isPlainObject: isPlainObject,
    deepmerge: deepmerge,
    clone: clone,
    isEmpty: isEmpty,
    each: each,
    isNil: isNil,
    firstNonNull: firstNonNull,
    deepEqual: deepEqual,
    pluginInterop: pluginInterop,
    getAbortError: getAbortError,
    isAbortError: isAbortError,
    logWarn: logWarn,
    isExtendedPosition: isExtendedPosition,
    getXMPValue: getXMPValue,
    parsePosition: parsePosition,
    cleanPosition: cleanPosition,
    positionIsOrdered: positionIsOrdered,
    parseSpeed: parseSpeed,
    parseAngle: parseAngle,
    createTexture: createTexture,
    applyEulerInverse: applyEulerInverse,
    Animation: Animation,
    Dynamic: Dynamic,
    MultiDynamic: MultiDynamic,
    Slider: Slider
  });

  /**
   * @typedef {Object} PSV.adapters.EquirectangularAdapter.Options
   * @property {number} [resolution=64] - number of faces of the sphere geometry, higher values may decrease performances
   */

  /**
   * @summary Adapter for equirectangular panoramas
   * @memberof PSV.adapters
   * @extends PSV.adapters.AbstractAdapter
   */

  var EquirectangularAdapter = /*#__PURE__*/function (_AbstractAdapter) {
    _inheritsLoose(EquirectangularAdapter, _AbstractAdapter);

    /**
     * @param {PSV.Viewer} psv
     * @param {PSV.adapters.EquirectangularAdapter.Options} options
     */
    function EquirectangularAdapter(psv, options) {
      var _this;

      _this = _AbstractAdapter.call(this, psv) || this;
      /**
       * @member {PSV.adapters.EquirectangularAdapter.Options}
       * @private
       */

      _this.config = _extends({
        resolution: 64
      }, options);

      if (!three.MathUtils.isPowerOfTwo(_this.config.resolution)) {
        throw new PSVError('EquirectangularAdapter resolution must be power of two');
      }

      _this.SPHERE_SEGMENTS = _this.config.resolution;
      _this.SPHERE_HORIZONTAL_SEGMENTS = _this.SPHERE_SEGMENTS / 2;
      return _this;
    }
    /**
     * @override
     */


    var _proto = EquirectangularAdapter.prototype;

    _proto.supportsTransition = function supportsTransition() {
      return true;
    }
    /**
     * @override
     */
    ;

    _proto.supportsPreload = function supportsPreload() {
      return true;
    }
    /**
     * @override
     * @param {string} panorama
     * @param {PSV.PanoData | PSV.PanoDataProvider} [newPanoData]
     * @param {boolean} [useXmpPanoData]
     * @returns {Promise.<PSV.TextureData>}
     */
    ;

    _proto.loadTexture = function loadTexture(panorama, newPanoData, useXmpPanoData) {
      var _this2 = this;

      if (useXmpPanoData === void 0) {
        useXmpPanoData = this.psv.config.useXmpData;
      }

      if (typeof panorama !== 'string') {
        if (Array.isArray(panorama) || typeof panorama === 'object' && !!panorama.left) {
          logWarn('Cubemap support now requires an additional adapter, see https://photo-sphere-viewer.js.org/guide/adapters');
        }

        return Promise.reject(new PSVError('Invalid panorama url, are you using the right adapter?'));
      }

      return (useXmpPanoData ? this.__loadXMP(panorama, function (p) {
        return _this2.psv.loader.setProgress(p);
      }).then(function (xmpPanoData) {
        return _this2.psv.textureLoader.loadImage(panorama).then(function (img) {
          return {
            img: img,
            xmpPanoData: xmpPanoData
          };
        });
      }) : this.psv.textureLoader.loadImage(panorama, function (p) {
        return _this2.psv.loader.setProgress(p);
      }).then(function (img) {
        return {
          img: img,
          xmpPanoData: null
        };
      })).then(function (_ref) {
        var _newPanoData, _newPanoData2, _newPanoData3, _newPanoData4, _newPanoData5, _newPanoData6, _newPanoData7, _newPanoData8, _newPanoData9;

        var img = _ref.img,
            xmpPanoData = _ref.xmpPanoData;

        if (typeof newPanoData === 'function') {
          newPanoData = newPanoData(img);
        }

        var panoData = {
          fullWidth: firstNonNull((_newPanoData = newPanoData) == null ? void 0 : _newPanoData.fullWidth, xmpPanoData == null ? void 0 : xmpPanoData.fullWidth, img.width),
          fullHeight: firstNonNull((_newPanoData2 = newPanoData) == null ? void 0 : _newPanoData2.fullHeight, xmpPanoData == null ? void 0 : xmpPanoData.fullHeight, img.height),
          croppedWidth: firstNonNull((_newPanoData3 = newPanoData) == null ? void 0 : _newPanoData3.croppedWidth, xmpPanoData == null ? void 0 : xmpPanoData.croppedWidth, img.width),
          croppedHeight: firstNonNull((_newPanoData4 = newPanoData) == null ? void 0 : _newPanoData4.croppedHeight, xmpPanoData == null ? void 0 : xmpPanoData.croppedHeight, img.height),
          croppedX: firstNonNull((_newPanoData5 = newPanoData) == null ? void 0 : _newPanoData5.croppedX, xmpPanoData == null ? void 0 : xmpPanoData.croppedX, 0),
          croppedY: firstNonNull((_newPanoData6 = newPanoData) == null ? void 0 : _newPanoData6.croppedY, xmpPanoData == null ? void 0 : xmpPanoData.croppedY, 0),
          poseHeading: firstNonNull((_newPanoData7 = newPanoData) == null ? void 0 : _newPanoData7.poseHeading, xmpPanoData == null ? void 0 : xmpPanoData.poseHeading, 0),
          posePitch: firstNonNull((_newPanoData8 = newPanoData) == null ? void 0 : _newPanoData8.posePitch, xmpPanoData == null ? void 0 : xmpPanoData.posePitch, 0),
          poseRoll: firstNonNull((_newPanoData9 = newPanoData) == null ? void 0 : _newPanoData9.poseRoll, xmpPanoData == null ? void 0 : xmpPanoData.poseRoll, 0)
        };

        if (panoData.croppedWidth !== img.width || panoData.croppedHeight !== img.height) {
          logWarn("Invalid panoData, croppedWidth and/or croppedHeight is not coherent with loaded image.\n    panoData: " + panoData.croppedWidth + "x" + panoData.croppedHeight + ", image: " + img.width + "x" + img.height);
        }

        if ((newPanoData || xmpPanoData) && panoData.fullWidth !== panoData.fullHeight * 2) {
          logWarn('Invalid panoData, fullWidth should be twice fullHeight');
        }

        var texture = _this2.__createEquirectangularTexture(img, panoData);

        return {
          panorama: panorama,
          texture: texture,
          panoData: panoData
        };
      });
    }
    /**
     * @summary Loads the XMP data of an image
     * @param {string} panorama
     * @param {function(number)} [onProgress]
     * @returns {Promise<PSV.PanoData>}
     * @throws {PSV.PSVError} when the image cannot be loaded
     * @private
     */
    ;

    _proto.__loadXMP = function __loadXMP(panorama, onProgress) {
      var _this3 = this;

      return this.psv.textureLoader.loadFile(panorama, onProgress).then(function (blob) {
        return _this3.__loadBlobAsString(blob);
      }).then(function (binary) {
        var a = binary.indexOf('<x:xmpmeta');
        var b = binary.indexOf('</x:xmpmeta>');
        var data = binary.substring(a, b);

        if (a !== -1 && b !== -1 && data.includes('GPano:')) {
          return {
            fullWidth: getXMPValue(data, 'FullPanoWidthPixels'),
            fullHeight: getXMPValue(data, 'FullPanoHeightPixels'),
            croppedWidth: getXMPValue(data, 'CroppedAreaImageWidthPixels'),
            croppedHeight: getXMPValue(data, 'CroppedAreaImageHeightPixels'),
            croppedX: getXMPValue(data, 'CroppedAreaLeftPixels'),
            croppedY: getXMPValue(data, 'CroppedAreaTopPixels'),
            poseHeading: getXMPValue(data, 'PoseHeadingDegrees'),
            posePitch: getXMPValue(data, 'PosePitchDegrees'),
            poseRoll: getXMPValue(data, 'PoseRollDegrees')
          };
        }

        return null;
      });
    }
    /**
     * @summmary read a Blob as string
     * @param {Blob} blob
     * @returns {Promise<string>}
     * @private
     */
    ;

    _proto.__loadBlobAsString = function __loadBlobAsString(blob) {
      return new Promise(function (resolve, reject) {
        var reader = new FileReader();

        reader.onload = function () {
          return resolve(reader.result);
        };

        reader.onerror = reject;
        reader.readAsText(blob);
      });
    }
    /**
     * @summary Creates the final texture from image and panorama data
     * @param {Image} img
     * @param {PSV.PanoData} panoData
     * @returns {external:THREE.Texture}
     * @private
     */
    ;

    _proto.__createEquirectangularTexture = function __createEquirectangularTexture(img, panoData) {
      // resize image / fill cropped parts with black
      if (panoData.fullWidth > SYSTEM.maxTextureWidth || panoData.croppedWidth !== panoData.fullWidth || panoData.croppedHeight !== panoData.fullHeight) {
        var ratio = SYSTEM.getMaxCanvasWidth() / panoData.fullWidth;

        var resizedPanoData = _extends({}, panoData);

        if (ratio < 1) {
          resizedPanoData.fullWidth *= ratio;
          resizedPanoData.fullHeight *= ratio;
          resizedPanoData.croppedWidth *= ratio;
          resizedPanoData.croppedHeight *= ratio;
          resizedPanoData.croppedX *= ratio;
          resizedPanoData.croppedY *= ratio;
        }

        var buffer = document.createElement('canvas');
        buffer.width = resizedPanoData.fullWidth;
        buffer.height = resizedPanoData.fullHeight;
        var ctx = buffer.getContext('2d');
        ctx.drawImage(img, resizedPanoData.croppedX, resizedPanoData.croppedY, resizedPanoData.croppedWidth, resizedPanoData.croppedHeight);
        return createTexture(buffer);
      }

      return createTexture(img);
    }
    /**
     * @override
     */
    ;

    _proto.createMesh = function createMesh(scale) {
      if (scale === void 0) {
        scale = 1;
      }

      // The middle of the panorama is placed at longitude=0
      var geometry = new three.SphereGeometry(SPHERE_RADIUS * scale, this.SPHERE_SEGMENTS, this.SPHERE_HORIZONTAL_SEGMENTS, -Math.PI / 2).scale(-1, 1, 1);
      var material = AbstractAdapter.createOverlayMaterial();
      return new three.Mesh(geometry, material);
    }
    /**
     * @override
     */
    ;

    _proto.setTexture = function setTexture(mesh, textureData) {
      this.__setUniform(mesh, AbstractAdapter.OVERLAY_UNIFORMS.panorama, textureData.texture);

      this.setOverlay(mesh, null);
    }
    /**
     * @override
     */
    ;

    _proto.setOverlay = function setOverlay(mesh, textureData, opacity) {
      this.__setUniform(mesh, AbstractAdapter.OVERLAY_UNIFORMS.overlayOpacity, opacity);

      if (!textureData) {
        this.__setUniform(mesh, AbstractAdapter.OVERLAY_UNIFORMS.overlay, new three.Texture());
      } else {
        this.__setUniform(mesh, AbstractAdapter.OVERLAY_UNIFORMS.overlay, textureData.texture);
      }
    }
    /**
     * @override
     */
    ;

    _proto.setTextureOpacity = function setTextureOpacity(mesh, opacity) {
      this.__setUniform(mesh, AbstractAdapter.OVERLAY_UNIFORMS.globalOpacity, opacity);

      mesh.material.transparent = opacity < 1;
    }
    /**
     * @override
     */
    ;

    _proto.disposeTexture = function disposeTexture(textureData) {
      var _textureData$texture;

      (_textureData$texture = textureData.texture) == null ? void 0 : _textureData$texture.dispose();
    }
    /**
     * @param {external:THREE.Mesh} mesh
     * @param {string} uniform
     * @param {*} value
     * @private
     */
    ;

    _proto.__setUniform = function __setUniform(mesh, uniform, value) {
      if (mesh.material.uniforms[uniform].value instanceof three.Texture) {
        mesh.material.uniforms[uniform].value.dispose();
      }

      mesh.material.uniforms[uniform].value = value;
    };

    return EquirectangularAdapter;
  }(AbstractAdapter);
  EquirectangularAdapter.id = 'equirectangular';
  EquirectangularAdapter.supportsDownload = true;
  EquirectangularAdapter.supportsOverlay = true;

  /**
   * @namespace PSV.components
   */

  /**
   * @summary Base component class
   * @memberof PSV.components
   * @abstract
   */
  var AbstractComponent = /*#__PURE__*/function () {
    /**
     * @param {PSV.Viewer | PSV.components.AbstractComponent} parent
     * @param {string} className - CSS class added to the component's container
     */
    function AbstractComponent(parent, className) {
      /**
       * @summary Reference to main controller
       * @type {PSV.Viewer}
       * @readonly
       */
      this.psv = parent.psv || parent;
      /**
       * @member {PSV.Viewer|PSV.components.AbstractComponent}
       * @readonly
       */

      this.parent = parent;
      this.parent.children.push(this);
      /**
       * @summary All child components
       * @type {PSV.components.AbstractComponent[]}
       * @readonly
       * @package
       */

      this.children = [];
      /**
       * @summary Internal properties
       * @member {Object}
       * @protected
       * @property {boolean} visible - Visibility of the component
       */

      this.prop = {
        visible: true
      };
      /**
       * @member {HTMLElement}
       * @readonly
       */

      this.container = document.createElement('div');
      this.container.className = className;
      this.parent.container.appendChild(this.container);
    }
    /**
     * @summary Destroys the component
     * @protected
     */


    var _proto = AbstractComponent.prototype;

    _proto.destroy = function destroy() {
      this.parent.container.removeChild(this.container);
      var childIdx = this.parent.children.indexOf(this);

      if (childIdx !== -1) {
        this.parent.children.splice(childIdx, 1);
      }

      this.children.slice().forEach(function (child) {
        return child.destroy();
      });
      this.children.length = 0;
      delete this.container;
      delete this.parent;
      delete this.psv;
      delete this.prop;
    }
    /**
     * @summary Refresh UI
     * @description Must be be a very lightweight operation
     * @package
     */
    ;

    _proto.refreshUi = function refreshUi() {
      var _this = this;

      this.children.every(function (child) {
        child.refreshUi();
        return _this.psv.prop.uiRefresh === true;
      });
    }
    /**
     * @summary Displays or hides the component
     * @param {boolean} [visible] - forced state
     */
    ;

    _proto.toggle = function toggle(visible) {
      if (visible === false || visible === undefined && this.isVisible()) {
        this.hide();
      } else if (visible === true || visible === undefined && !this.isVisible()) {
        this.show();
      }
    }
    /**
     * @summary Hides the component
     */
    ;

    _proto.hide = function hide() {
      this.container.style.display = 'none';
      this.prop.visible = false;
    }
    /**
     * @summary Displays the component
     */
    ;

    _proto.show = function show() {
      this.container.style.display = '';
      this.prop.visible = true;
    }
    /**
     * @summary Checks if the component is visible
     * @returns {boolean}
     */
    ;

    _proto.isVisible = function isVisible() {
      return this.prop.visible;
    };

    return AbstractComponent;
  }();

  /**
   * @namespace PSV.buttons
   */

  /**
   * @summary Base navbar button class
   * @extends PSV.components.AbstractComponent
   * @memberof PSV.buttons
   * @abstract
   */

  var AbstractButton = /*#__PURE__*/function (_AbstractComponent) {
    _inheritsLoose(AbstractButton, _AbstractComponent);

    /**
     * @summary Unique identifier of the button
     * @member {string}
     * @readonly
     * @static
     */

    /**
     * @summary Identifier to declare a group of buttons
     * @member {string}
     * @readonly
     * @static
     */

    /**
     * @summary SVG icon name injected in the button
     * @member {string}
     * @readonly
     * @static
     */

    /**
     * @summary SVG icon name injected in the button when it is active
     * @member {string}
     * @readonly
     * @static
     */

    /**
     * @param {PSV.components.Navbar} navbar
     * @param {string} [className] - Additional CSS classes
     * @param {boolean} [collapsable=false] - `true` if the button can be moved to menu when the navbar is too small
     * @param {boolean} [tabbable=true] - `true` if the button is accessible with the keyboard
     */
    function AbstractButton(navbar, className, collapsable, tabbable) {
      var _this;

      if (className === void 0) {
        className = '';
      }

      if (collapsable === void 0) {
        collapsable = false;
      }

      if (tabbable === void 0) {
        tabbable = true;
      }

      _this = _AbstractComponent.call(this, navbar, 'psv-button ' + className) || this;
      /**
       * @override
       * @property {string} id - Unique identifier of the button
       * @property {boolean} enabled
       * @property {boolean} supported
       * @property {boolean} collapsed
       * @property {boolean} active
       * @property {number} width
       */

      _this.prop = _extends({}, _this.prop, {
        id: _this.constructor.id,
        collapsable: collapsable,
        enabled: true,
        supported: true,
        collapsed: false,
        active: false,
        width: _this.container.offsetWidth
      });

      if (_this.constructor.icon) {
        _this.__setIcon(_this.constructor.icon);
      }

      if (_this.prop.id && _this.psv.config.lang[_this.prop.id]) {
        _this.container.title = _this.psv.config.lang[_this.prop.id];
      }

      if (tabbable) {
        _this.container.tabIndex = 0;
      }

      _this.container.addEventListener('click', function (e) {
        if (_this.prop.enabled) {
          _this.onClick();
        }

        e.stopPropagation();
      });

      _this.container.addEventListener('keydown', function (e) {
        if (e.key === KEY_CODES.Enter && _this.prop.enabled) {
          _this.onClick();

          e.stopPropagation();
        }
      });

      return _this;
    }
    /**
     * @package
     */


    var _proto = AbstractButton.prototype;

    _proto.checkSupported = function checkSupported() {
      var _this2 = this;

      var supportedOrObject = this.isSupported();

      if (isPlainObject(supportedOrObject)) {
        if (supportedOrObject.initial === false) {
          this.hide();
          this.prop.supported = false;
        }

        supportedOrObject.promise.then(function (supported) {
          if (!_this2.prop) {
            return; // the component has been destroyed
          }

          _this2.prop.supported = supported;

          _this2.toggle(supported);
        });
      } else {
        this.prop.supported = supportedOrObject;

        if (!supportedOrObject) {
          this.hide();
        }
      }
    }
    /**
     * @summary Checks if the button can be displayed
     * @returns {boolean|{initial: boolean, promise: Promise<boolean>}}
     */
    ;

    _proto.isSupported = function isSupported() {
      return true;
    }
    /**
     * @summary Changes the active state of the button
     * @param {boolean} [active] - forced state
     */
    ;

    _proto.toggleActive = function toggleActive(active) {
      this.prop.active = active !== undefined ? active : !this.prop.active;
      toggleClass(this.container, 'psv-button--active', this.prop.active);

      if (this.constructor.iconActive) {
        this.__setIcon(this.prop.active ? this.constructor.iconActive : this.constructor.icon);
      }
    }
    /**
     * @override
     */
    ;

    _proto.show = function show(refresh) {
      if (refresh === void 0) {
        refresh = true;
      }

      if (!this.isVisible()) {
        this.prop.visible = true;

        if (!this.prop.collapsed) {
          this.container.style.display = '';
        }

        if (refresh) {
          this.psv.refreshUi("show button " + this.prop.id);
        }
      }
    }
    /**
     * @override
     */
    ;

    _proto.hide = function hide(refresh) {
      if (refresh === void 0) {
        refresh = true;
      }

      if (this.isVisible()) {
        this.prop.visible = false;
        this.container.style.display = 'none';

        if (refresh) {
          this.psv.refreshUi("hide button " + this.prop.id);
        }
      }
    }
    /**
     * @summary Disables the button
     */
    ;

    _proto.disable = function disable() {
      this.container.classList.add('psv-button--disabled');
      this.prop.enabled = false;
    }
    /**
     * @summary Enables the button
     */
    ;

    _proto.enable = function enable() {
      this.container.classList.remove('psv-button--disabled');
      this.prop.enabled = true;
    }
    /**
     * @summary Collapses the button in the navbar menu
     */
    ;

    _proto.collapse = function collapse() {
      this.prop.collapsed = true;
      this.container.style.display = 'none';
    }
    /**
     * @summary Uncollapses the button from the navbar menu
     */
    ;

    _proto.uncollapse = function uncollapse() {
      this.prop.collapsed = false;

      if (this.prop.visible) {
        this.container.style.display = '';
      }
    }
    /**
     * @summary Set the button icon
     * @param {string} icon SVG
     * @param {HTMLElement} [container] - default is the main button container
     * @private
     */
    ;

    _proto.__setIcon = function __setIcon(icon, container) {
      if (container === void 0) {
        container = this.container;
      }

      if (icon) {
        container.innerHTML = icon; // className is read-only on SVGElement

        container.querySelector('svg').classList.add('psv-button-svg');
      } else {
        container.innerHTML = '';
      }
    }
    /**
     * @summary Action when the button is clicked
     * @private
     * @abstract
     */
    ;

    _proto.onClick = function onClick() {
      throw new PSVError("onClick not implemented for button \"" + this.prop.id + "\".");
    };

    return AbstractButton;
  }(AbstractComponent);
  AbstractButton.id = null;
  AbstractButton.groupId = null;
  AbstractButton.icon = null;
  AbstractButton.iconActive = null;

  var playActive = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 41 41\"><path fill=\"currentColor\" d=\"M40.5 14.1c-.1-.1-1.2-.5-2.898-1-.102 0-.202-.1-.202-.2C34.5 6.5 28 2 20.5 2S6.6 6.5 3.7 12.9c0 .1-.1.1-.2.2-1.7.6-2.8 1-2.9 1l-.6.3v12.1l.6.2c.1 0 1.1.399 2.7.899.1 0 .2.101.2.199C6.3 34.4 12.9 39 20.5 39c7.602 0 14.102-4.6 16.9-11.1 0-.102.1-.102.199-.2 1.699-.601 2.699-1 2.801-1l.6-.3V14.3l-.5-.2zM6.701 11.5C9.7 7 14.8 4 20.5 4c5.8 0 10.9 3 13.8 7.5.2.3-.1.6-.399.5-3.799-1-8.799-2-13.6-2-4.7 0-9.5 1-13.2 2-.3.1-.5-.2-.4-.5zM25.1 20.3L18.7 24c-.3.2-.7 0-.7-.5v-7.4c0-.4.4-.6.7-.4l6.399 3.8c.301.1.301.6.001.8zm9.4 8.901A16.421 16.421 0 0 1 20.5 37c-5.9 0-11.1-3.1-14-7.898-.2-.302.1-.602.4-.5 3.9 1 8.9 2.1 13.6 2.1 5 0 9.9-1 13.602-2 .298-.1.5.198.398.499z\"/><!--Created by Nick Bluth from the Noun Project--></svg>\n";

  var play = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 41 41\"><path fill=\"currentColor\" d=\"M40.5 14.1c-.1-.1-1.2-.5-2.899-1-.101 0-.2-.1-.2-.2C34.5 6.5 28 2 20.5 2S6.6 6.5 3.7 12.9c0 .1-.1.1-.2.2-1.7.6-2.8 1-2.9 1l-.6.3v12.1l.6.2c.1 0 1.1.4 2.7.9.1 0 .2.1.2.199C6.3 34.4 12.9 39 20.5 39c7.601 0 14.101-4.6 16.9-11.1 0-.101.1-.101.2-.2 1.699-.6 2.699-1 2.8-1l.6-.3V14.3l-.5-.2zM20.5 4c5.8 0 10.9 3 13.8 7.5.2.3-.1.6-.399.5-3.8-1-8.8-2-13.6-2-4.7 0-9.5 1-13.2 2-.3.1-.5-.2-.4-.5C9.7 7 14.8 4 20.5 4zm0 33c-5.9 0-11.1-3.1-14-7.899-.2-.301.1-.601.4-.5 3.9 1 8.9 2.1 13.6 2.1 5 0 9.9-1 13.601-2 .3-.1.5.2.399.5A16.422 16.422 0 0 1 20.5 37zm18.601-12.1c0 .1-.101.3-.2.3-2.5.9-10.4 3.6-18.4 3.6-7.1 0-15.6-2.699-18.3-3.6C2.1 25.2 2 25 2 24.9V16c0-.1.1-.3.2-.3 2.6-.9 10.6-3.6 18.2-3.6 7.5 0 15.899 2.7 18.5 3.6.1 0 .2.2.2.3v8.9z\"/><path fill=\"currentColor\" d=\"M18.7 24l6.4-3.7c.3-.2.3-.7 0-.8l-6.4-3.8c-.3-.2-.7 0-.7.4v7.4c0 .5.4.7.7.5z\"/><!--Created by Nick Bluth from the Noun Project--></svg>\n";

  /**
   * @summary Navigation bar autorotate button class
   * @extends PSV.buttons.AbstractButton
   * @memberof PSV.buttons
   */

  var AutorotateButton = /*#__PURE__*/function (_AbstractButton) {
    _inheritsLoose(AutorotateButton, _AbstractButton);

    /**
     * @param {PSV.components.Navbar} navbar
     */
    function AutorotateButton(navbar) {
      var _this;

      _this = _AbstractButton.call(this, navbar, 'psv-button--hover-scale psv-autorotate-button', true) || this;

      _this.psv.on(EVENTS.AUTOROTATE, _assertThisInitialized(_this));

      return _this;
    }
    /**
     * @override
     */


    var _proto = AutorotateButton.prototype;

    _proto.destroy = function destroy() {
      this.psv.off(EVENTS.AUTOROTATE, this);

      _AbstractButton.prototype.destroy.call(this);
    }
    /**
     * @summary Handles events
     * @param {Event} e
     * @private
     */
    ;

    _proto.handleEvent = function handleEvent(e) {
      /* eslint-disable */
      switch (e.type) {
        // @formatter:off
        case EVENTS.AUTOROTATE:
          this.toggleActive(e.args[0]);
          break;
        // @formatter:on
      }
      /* eslint-enable */

    }
    /**
     * @override
     * @description Toggles autorotate
     */
    ;

    _proto.onClick = function onClick() {
      if (this.psv.isAutorotateEnabled()) {
        this.psv.config.autorotateIdle = false;
        this.psv.resetIdleTimer();
      }

      this.psv.toggleAutorotate();
    };

    return AutorotateButton;
  }(AbstractButton);
  AutorotateButton.id = 'autorotate';
  AutorotateButton.icon = play;
  AutorotateButton.iconActive = playActive;

  /**
   * @summary Navigation bar custom button class
   * @extends PSV.buttons.AbstractButton
   * @memberof PSV.buttons
   */

  var CustomButton = /*#__PURE__*/function (_AbstractButton) {
    _inheritsLoose(CustomButton, _AbstractButton);

    /**
     * @param {PSV.components.Navbar} navbar
     * @param {PSV.NavbarCustomButton} config
     */
    function CustomButton(navbar, config) {
      var _this;

      _this = _AbstractButton.call(this, navbar, 'psv-custom-button', config.collapsable !== false, config.tabbable !== false) || this;
      /**
       * @member {Object}
       * @readonly
       * @private
       */

      _this.config = config;

      if (_this.config.id) {
        _this.prop.id = _this.config.id;
      } else {
        _this.prop.id = 'psvButton-' + Math.random().toString(36).substr(2, 9);
      }

      if (_this.config.className) {
        addClasses(_this.container, _this.config.className);
      }

      if (_this.config.title) {
        _this.container.title = _this.config.title;
      }

      if (_this.config.content) {
        _this.container.innerHTML = _this.config.content;
      }

      _this.prop.width = _this.container.offsetWidth;

      if (_this.config.enabled === false) {
        _this.disable();
      }

      if (_this.config.visible === false) {
        _this.hide();
      }

      return _this;
    }
    /**
     * @override
     */


    var _proto = CustomButton.prototype;

    _proto.destroy = function destroy() {
      delete this.config;

      _AbstractButton.prototype.destroy.call(this);
    }
    /**
     * @override
     * @description Calls user method
     */
    ;

    _proto.onClick = function onClick() {
      if (this.config.onClick) {
        this.config.onClick.call(this.psv, this.psv);
      }
    };

    return CustomButton;
  }(AbstractButton);

  var info = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 64 64\"><path fill=\"currentColor\" d=\"M28.3 26.1c-1 2.6-1.9 4.8-2.6 7-2.5 7.4-5 14.7-7.2 22-1.3 4.4.5 7.2 4.3 7.8 1.3.2 2.8.2 4.2-.1 8.2-2 11.9-8.6 15.7-15.2l-2.2 2a18.8 18.8 0 0 1-7.4 5.2 2 2 0 0 1-1.6-.2c-.2-.1 0-1 0-1.4l.8-1.8L41.9 28c.5-1.4.9-3 .7-4.4-.2-2.6-3-4.4-6.3-4.4-8.8.2-15 4.5-19.5 11.8-.2.3-.2.6-.3 1.3 3.7-2.8 6.8-6.1 11.8-6.2z\"/><circle fill=\"currentColor\" cx=\"39.3\" cy=\"9.2\" r=\"8.2\"/><!--Created by Arafat Uddin from the Noun Project--></svg>\n";

  var MODE_NOTIF = 1;
  var MODE_PANEL = 2;
  /**
   * @summary Navigation bar description button class
   * @extends PSV.buttons.AbstractButton
   * @memberof PSV.buttons
   */

  var DescriptionButton = /*#__PURE__*/function (_AbstractButton) {
    _inheritsLoose(DescriptionButton, _AbstractButton);

    /**
     * @param {PSV.components.Navbar} navbar
     */
    function DescriptionButton(navbar) {
      var _this;

      _this = _AbstractButton.call(this, navbar, 'psv-button--hover-scale psv-description-button') || this;
      /**
       * @override
       * @property {string} mode - notification or panel
       */

      _this.prop = _extends({}, _this.prop, {
        mode: null
      });

      _this.psv.on(EVENTS.HIDE_NOTIFICATION, _assertThisInitialized(_this));

      _this.psv.on(EVENTS.SHOW_NOTIFICATION, _assertThisInitialized(_this));

      _this.psv.on(EVENTS.CLOSE_PANEL, _assertThisInitialized(_this));

      _this.psv.on(EVENTS.OPEN_PANEL, _assertThisInitialized(_this));

      return _this;
    }
    /**
     * @override
     */


    var _proto = DescriptionButton.prototype;

    _proto.destroy = function destroy() {
      this.psv.off(EVENTS.HIDE_NOTIFICATION, this);
      this.psv.off(EVENTS.SHOW_NOTIFICATION, this);
      this.psv.off(EVENTS.CLOSE_PANEL, this);
      this.psv.off(EVENTS.OPEN_PANEL, this);

      _AbstractButton.prototype.destroy.call(this);
    }
    /**
     * @summary Handles events
     * @param {Event} e
     * @private
     */
    ;

    _proto.handleEvent = function handleEvent(e) {
      if (!this.prop.mode) {
        return;
      }

      var closed = false;

      switch (e.type) {
        case EVENTS.HIDE_NOTIFICATION:
          closed = this.prop.mode === MODE_NOTIF;
          break;

        case EVENTS.SHOW_NOTIFICATION:
          closed = this.prop.mode === MODE_NOTIF && e.args[0] !== IDS.DESCRIPTION;
          break;

        case EVENTS.CLOSE_PANEL:
          closed = this.prop.mode === MODE_PANEL;
          break;

        case EVENTS.OPEN_PANEL:
          closed = this.prop.mode === MODE_PANEL && e.args[0] !== IDS.DESCRIPTION;
          break;
      }

      if (closed) {
        this.toggleActive(false);
        this.prop.mode = null;
      }
    }
    /**
     * @override
     */
    ;

    _proto.hide = function hide(refresh) {
      _AbstractButton.prototype.hide.call(this, refresh);

      if (this.prop.mode) {
        this.__close();
      }
    }
    /**
     * This button can only be refresh from NavbarCaption
     * @override
     */
    ;

    _proto.refreshUi = function refreshUi(refresh) {
      if (refresh === void 0) {
        refresh = false;
      }

      if (refresh) {
        var caption = this.psv.navbar.getButton('caption', false);
        var captionHidden = caption && !caption.isVisible();
        var hasDescription = !!this.psv.config.description;

        if (captionHidden || hasDescription) {
          this.show(false);
        } else {
          this.hide(false);
        }
      }
    }
    /**
     * @override
     * @description Toggles caption
     */
    ;

    _proto.onClick = function onClick() {
      if (this.prop.mode) {
        this.__close();
      } else {
        this.__open();
      }
    }
    /**
     * @private
     */
    ;

    _proto.__close = function __close() {
      switch (this.prop.mode) {
        case MODE_NOTIF:
          this.psv.notification.hide(IDS.DESCRIPTION);
          break;

        case MODE_PANEL:
          this.psv.panel.hide(IDS.DESCRIPTION);
          break;
      }
    }
    /**
     * @private
     */
    ;

    _proto.__open = function __open() {
      this.toggleActive(true);

      if (this.psv.config.description) {
        this.prop.mode = MODE_PANEL;
        this.psv.panel.show({
          id: IDS.DESCRIPTION,
          content: "" + (this.psv.config.caption ? "<p>" + this.psv.config.caption + "</p>" : '') + this.psv.config.description
        });
      } else {
        this.prop.mode = MODE_NOTIF;
        this.psv.notification.show({
          id: IDS.DESCRIPTION,
          content: this.psv.config.caption
        });
      }
    };

    return DescriptionButton;
  }(AbstractButton);
  DescriptionButton.id = 'description';
  DescriptionButton.icon = info;

  var download = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 100 100\"><path fill=\"currentColor\" d=\"M83.3 35.6h-17V3H32.2v32.6H16.6l33.6 32.7 33-32.7z\"/><path fill=\"currentColor\" d=\"M83.3 64.2v16.3H16.6V64.2H-.1v32.6H100V64.2H83.3z\"/><!--Created by Michael Zenaty from the Noun Project--></svg>\n";

  /**
   * @summary Navigation bar download button class
   * @extends PSV.buttons.AbstractButton
   * @memberof PSV.buttons
   */

  var DownloadButton = /*#__PURE__*/function (_AbstractButton) {
    _inheritsLoose(DownloadButton, _AbstractButton);

    /**
     * @param {PSV.components.Navbar} navbar
     */
    function DownloadButton(navbar) {
      return _AbstractButton.call(this, navbar, 'psv-button--hover-scale psv-download-button', true) || this;
    }
    /**
     * @override
     * @description Asks the browser to download the panorama source file
     */


    var _proto = DownloadButton.prototype;

    _proto.onClick = function onClick() {
      var _this = this;

      var link = document.createElement('a');
      link.href = this.psv.config.downloadUrl || this.psv.config.panorama;
      link.download = link.href.split('/').pop();
      this.psv.container.appendChild(link);
      link.click();
      setTimeout(function () {
        _this.psv.container.removeChild(link);
      }, 100);
    }
    /**
     * @override
     */
    ;

    _proto.refreshUi = function refreshUi() {
      var supported = this.psv.adapter.constructor.supportsDownload || this.psv.config.downloadUrl;

      if (supported && !this.prop.visible) {
        this.show();
      } else if (!supported && this.prop.visible) {
        this.hide();
      }
    };

    return DownloadButton;
  }(AbstractButton);
  DownloadButton.id = 'download';
  DownloadButton.icon = download;

  var fullscreenIn = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 100 100\"><path fill=\"currentColor\" d=\"M100 40H87.1V18.8h-21V6H100zM100 93.2H66V80.3h21.1v-21H100zM34 93.2H0v-34h12.9v21.1h21zM12.9 40H0V6h34v12.9H12.8z\"/><!--Created by Garrett Knoll from the Noun Project--></svg>\n";

  var fullscreenOut = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 100 100\"><path fill=\"currentColor\" d=\"M66 7h13v21h21v13H66zM66 60.3h34v12.9H79v21H66zM0 60.3h34v34H21V73.1H0zM21 7h13v34H0V28h21z\"/><!--Created by Garrett Knoll from the Noun Project--></svg>\n";

  /**
   * @summary Navigation bar fullscreen button class
   * @extends PSV.buttons.AbstractButton
   * @memberof PSV.buttons
   */

  var FullscreenButton = /*#__PURE__*/function (_AbstractButton) {
    _inheritsLoose(FullscreenButton, _AbstractButton);

    /**
     * @param {PSV.components.Navbar} navbar
     */
    function FullscreenButton(navbar) {
      var _this;

      _this = _AbstractButton.call(this, navbar, 'psv-button--hover-scale psv-fullscreen-button') || this;

      _this.psv.on(EVENTS.FULLSCREEN_UPDATED, _assertThisInitialized(_this));

      return _this;
    }
    /**
     * @override
     */


    var _proto = FullscreenButton.prototype;

    _proto.destroy = function destroy() {
      this.psv.off(EVENTS.FULLSCREEN_UPDATED, this);

      _AbstractButton.prototype.destroy.call(this);
    }
    /**
     * Handle events
     * @param {Event} e
     * @private
     */
    ;

    _proto.handleEvent = function handleEvent(e) {
      /* eslint-disable */
      switch (e.type) {
        // @formatter:off
        case EVENTS.FULLSCREEN_UPDATED:
          this.toggleActive(e.args[0]);
          break;
        // @formatter:on
      }
      /* eslint-enable */

    }
    /**
     * @override
     * @description Toggles fullscreen
     */
    ;

    _proto.onClick = function onClick() {
      this.psv.toggleFullscreen();
    };

    return FullscreenButton;
  }(AbstractButton);
  FullscreenButton.id = 'fullscreen';
  FullscreenButton.icon = fullscreenIn;
  FullscreenButton.iconActive = fullscreenOut;

  var menuIcon = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"10 10 80 80\"><g fill=\"currentColor\"><circle r=\"10\" cx=\"20\" cy=\"20\"/><circle r=\"10\" cx=\"50\" cy=\"20\"/><circle r=\"10\" cx=\"80\" cy=\"20\"/><circle r=\"10\" cx=\"20\" cy=\"50\"/><circle r=\"10\" cx=\"50\" cy=\"50\"/><circle r=\"10\" cx=\"80\" cy=\"50\"/><circle r=\"10\" cx=\"20\" cy=\"80\"/><circle r=\"10\" cx=\"50\" cy=\"80\"/><circle r=\"10\" cx=\"80\" cy=\"80\"/></g><!-- Created by Richard Kunák from the Noun Project--></svg>\n";

  /**
   * @summary Navigation bar menu button class
   * @extends PSV.buttons.AbstractButton
   * @memberof PSV.buttons
   */

  var MenuButton = /*#__PURE__*/function (_AbstractButton) {
    _inheritsLoose(MenuButton, _AbstractButton);

    /**
     * @summary Property name added to buttons list
     * @type {string}
     * @constant
     */

    /**
     * @summary Menu template
     * @param {AbstractButton[]} buttons
     * @param {PSV.Viewer} psv
     * @param {string} dataKey
     * @returns {string}
     */

    /**
     * @param {PSV.components.Navbar} navbar
     */
    function MenuButton(navbar) {
      var _this;

      _this = _AbstractButton.call(this, navbar, 'psv-button--hover-scale psv-menu-button') || this;

      _this.psv.on(EVENTS.OPEN_PANEL, _assertThisInitialized(_this));

      _this.psv.on(EVENTS.CLOSE_PANEL, _assertThisInitialized(_this));

      _AbstractButton.prototype.hide.call(_assertThisInitialized(_this));

      return _this;
    }
    /**
     * @override
     */


    var _proto = MenuButton.prototype;

    _proto.destroy = function destroy() {
      this.psv.off(EVENTS.OPEN_PANEL, this);
      this.psv.off(EVENTS.CLOSE_PANEL, this);

      _AbstractButton.prototype.destroy.call(this);
    }
    /**
     * @summary Handles events
     * @param {Event} e
     * @private
     */
    ;

    _proto.handleEvent = function handleEvent(e) {
      /* eslint-disable */
      switch (e.type) {
        // @formatter:off
        case EVENTS.OPEN_PANEL:
          this.toggleActive(e.args[0] === IDS.MENU);
          break;

        case EVENTS.CLOSE_PANEL:
          this.toggleActive(false);
          break;
        // @formatter:on
      }
      /* eslint-enable */

    }
    /**
     * @override
     */
    ;

    _proto.hide = function hide(refresh) {
      _AbstractButton.prototype.hide.call(this, refresh);

      this.__hideMenu();
    }
    /**
     * @override
     */
    ;

    _proto.show = function show(refresh) {
      _AbstractButton.prototype.show.call(this, refresh);

      if (this.prop.active) {
        this.__showMenu();
      }
    }
    /**
     * @override
     * @description Toggles menu
     */
    ;

    _proto.onClick = function onClick() {
      if (this.prop.active) {
        this.__hideMenu();
      } else {
        this.__showMenu();
      }
    };

    _proto.__showMenu = function __showMenu() {
      var _this2 = this;

      this.psv.panel.show({
        id: IDS.MENU,
        content: MenuButton.MENU_TEMPLATE(this.parent.collapsed, this.psv, dasherize(MenuButton.BUTTON_DATA)),
        noMargin: true,
        clickHandler: function clickHandler(e) {
          var li = e.target ? getClosest(e.target, 'li') : undefined;
          var buttonId = li ? li.dataset[MenuButton.BUTTON_DATA] : undefined;

          if (buttonId) {
            _this2.parent.getButton(buttonId).onClick();

            _this2.__hideMenu();
          }
        }
      });
    };

    _proto.__hideMenu = function __hideMenu() {
      this.psv.panel.hide(IDS.MENU);
    };

    return MenuButton;
  }(AbstractButton);
  MenuButton.id = 'menu';
  MenuButton.icon = menuIcon;
  MenuButton.BUTTON_DATA = 'psvButton';

  MenuButton.MENU_TEMPLATE = function (buttons, psv, dataKey) {
    return "\n<div class=\"psv-panel-menu psv-panel-menu--stripped\">\n  <h1 class=\"psv-panel-menu-title\">" + menuIcon + " " + psv.config.lang.menu + "</h1>\n  <ul class=\"psv-panel-menu-list\">\n    " + buttons.map(function (button) {
      return "\n    <li data-" + dataKey + "=\"" + button.prop.id + "\" class=\"psv-panel-menu-item\" tabindex=\"0\">\n      <span class=\"psv-panel-menu-item-icon\">" + button.container.innerHTML + "</span>\n      <span class=\"psv-panel-menu-item-label\">" + button.container.title + "</span>\n    </li>\n    ";
    }).join('') + "\n  </ul>\n</div>\n";
  };

  var arrow = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"40 40 432 432\"><g transform=\"rotate(0, 256, 256)\"><path fill=\"currentColor\" d=\"M425.23 210.55H227.39a5 5 0 01-3.53-8.53l56.56-56.57a45.5 45.5 0 000-64.28 45.15 45.15 0 00-32.13-13.3 45.15 45.15 0 00-32.14 13.3L41.32 256l174.83 174.83a45.15 45.15 0 0032.14 13.3 45.15 45.15 0 0032.13-13.3 45.5 45.5 0 000-64.28l-56.57-56.57a5 5 0 013.54-8.53h197.84c25.06 0 45.45-20.39 45.45-45.45s-20.4-45.45-45.45-45.45z\"/></g><!-- Created by Flatart from the Noun Project --></svg>\n";

  /**
   * @summary Helper for pressable things (buttons, keyboard)
   * @description When the pressed thing goes up and was not pressed long enough, wait a bit more before execution
   * @private
   */
  var PressHandler = /*#__PURE__*/function () {
    function PressHandler(delay) {
      if (delay === void 0) {
        delay = 200;
      }

      this.delay = delay;
      this.time = 0;
      this.timeout = null;
    }

    var _proto = PressHandler.prototype;

    _proto.down = function down() {
      if (this.timeout) {
        clearTimeout(this.timeout);
        this.timeout = null;
      }

      this.time = new Date().getTime();
    };

    _proto.up = function up(cb) {
      var _this = this;

      if (!this.time) {
        return;
      }

      var elapsed = new Date().getTime() - this.time;

      if (elapsed < this.delay) {
        this.timeout = setTimeout(function () {
          cb();
          _this.timeout = null;
          _this.time = 0;
        }, this.delay);
      } else {
        cb();
        this.time = 0;
      }
    };

    return PressHandler;
  }();

  function getOrientedArrow(direction) {
    var angle = 0;

    switch (direction) {
      // @formatter:off
      case 'up':
        angle = 90;
        break;

      case 'right':
        angle = 180;
        break;

      case 'down':
        angle = -90;
        break;

      default:
        angle = 0;
        break;
      // @formatter:on
    }

    return arrow.replace('rotate(0', "rotate(" + angle);
  }
  /**
   * @summary Navigation bar move button class
   * @extends PSV.buttons.AbstractButton
   * @memberof PSV.buttons
   */

  var AbstractMoveButton = /*#__PURE__*/function (_AbstractButton) {
    _inheritsLoose(AbstractMoveButton, _AbstractButton);

    /**
     * @param {PSV.components.Navbar} navbar
     * @param {number} value
     */
    function AbstractMoveButton(navbar, value) {
      var _this;

      _this = _AbstractButton.call(this, navbar, 'psv-button--hover-scale psv-move-button') || this;
      _this.container.title = _this.psv.config.lang.move;
      /**
       * @override
       * @property {{longitude: boolean, latitude: boolean}} value
       * @property {PressHandler} handler
       */

      _this.prop = _extends({}, _this.prop, {
        value: value,
        handler: new PressHandler()
      });

      _this.container.addEventListener('mousedown', _assertThisInitialized(_this));

      _this.container.addEventListener('keydown', _assertThisInitialized(_this));

      _this.container.addEventListener('keyup', _assertThisInitialized(_this));

      _this.psv.container.addEventListener('mouseup', _assertThisInitialized(_this));

      _this.psv.container.addEventListener('touchend', _assertThisInitialized(_this));

      return _this;
    }
    /**
     * @override
     */


    var _proto = AbstractMoveButton.prototype;

    _proto.destroy = function destroy() {
      this.__onMouseUp();

      this.psv.container.removeEventListener('mouseup', this);
      this.psv.container.removeEventListener('touchend', this);

      _AbstractButton.prototype.destroy.call(this);
    }
    /**
     * @summary Handles events
     * @param {Event} e
     * @private
     */
    ;

    _proto.handleEvent = function handleEvent(e) {
      /* eslint-disable */
      switch (e.type) {
        // @formatter:off
        case 'mousedown':
          this.__onMouseDown();

          break;

        case 'mouseup':
          this.__onMouseUp();

          break;

        case 'touchend':
          this.__onMouseUp();

          break;

        case 'keydown':
          e.key === KEY_CODES.Enter && this.__onMouseDown();
          break;

        case 'keyup':
          e.key === KEY_CODES.Enter && this.__onMouseUp();
          break;
        // @formatter:on
      }
      /* eslint-enable */

    }
    /**
     * @override
     */
    ;

    _proto.isSupported = function isSupported() {
      return {
        initial: !SYSTEM.isTouchEnabled.initial,
        promise: SYSTEM.isTouchEnabled.promise.then(function (enabled) {
          return !enabled;
        })
      };
    }
    /**
     * @override
     */
    ;

    _proto.onClick = function onClick() {// nothing
    }
    /**
     * @private
     */
    ;

    _proto.__onMouseDown = function __onMouseDown() {
      if (!this.prop.enabled) {
        return;
      }

      this.psv.__stopAll();

      this.psv.dynamics.position.roll(this.prop.value);
      this.prop.handler.down();
    }
    /**
     * @private
     */
    ;

    _proto.__onMouseUp = function __onMouseUp() {
      var _this2 = this;

      if (!this.prop.enabled) {
        return;
      }

      this.prop.handler.up(function () {
        _this2.psv.dynamics.position.stop();

        _this2.psv.resetIdleTimer();
      });
    };

    return AbstractMoveButton;
  }(AbstractButton);
  AbstractMoveButton.groupId = 'move';

  /**
   * @summary Navigation bar move down button class
   * @extends PSV.buttons.AbstractMoveButton
   * @memberof PSV.buttons
   */

  var MoveDownButton = /*#__PURE__*/function (_AbstractMoveButton) {
    _inheritsLoose(MoveDownButton, _AbstractMoveButton);

    /**
     * @param {PSV.components.Navbar} navbar
     */
    function MoveDownButton(navbar) {
      return _AbstractMoveButton.call(this, navbar, {
        latitude: true
      }) || this;
    }

    return MoveDownButton;
  }(AbstractMoveButton);
  MoveDownButton.id = 'moveDown';
  MoveDownButton.icon = getOrientedArrow('down');

  /**
   * @summary Navigation bar move left button class
   * @extends PSV.buttons.AbstractMoveButton
   * @memberof PSV.buttons
   */

  var MoveLeftButton = /*#__PURE__*/function (_AbstractMoveButton) {
    _inheritsLoose(MoveLeftButton, _AbstractMoveButton);

    /**
     * @param {PSV.components.Navbar} navbar
     */
    function MoveLeftButton(navbar) {
      return _AbstractMoveButton.call(this, navbar, {
        longitude: true
      }) || this;
    }

    return MoveLeftButton;
  }(AbstractMoveButton);
  MoveLeftButton.id = 'moveLeft';
  MoveLeftButton.icon = getOrientedArrow('left');

  /**
   * @summary Navigation bar move right button class
   * @extends PSV.buttons.AbstractMoveButton
   * @memberof PSV.buttons
   */

  var MoveRightButton = /*#__PURE__*/function (_AbstractMoveButton) {
    _inheritsLoose(MoveRightButton, _AbstractMoveButton);

    /**
     * @param {PSV.components.Navbar} navbar
     */
    function MoveRightButton(navbar) {
      return _AbstractMoveButton.call(this, navbar, {
        longitude: false
      }) || this;
    }

    return MoveRightButton;
  }(AbstractMoveButton);
  MoveRightButton.id = 'moveRight';
  MoveRightButton.icon = getOrientedArrow('right');

  /**
   * @summary Navigation bar move up button class
   * @extends PSV.buttons.AbstractMoveButton
   * @memberof PSV.buttons
   */

  var MoveUpButton = /*#__PURE__*/function (_AbstractMoveButton) {
    _inheritsLoose(MoveUpButton, _AbstractMoveButton);

    /**
     * @param {PSV.components.Navbar} navbar
     */
    function MoveUpButton(navbar) {
      return _AbstractMoveButton.call(this, navbar, {
        latitude: false
      }) || this;
    }

    return MoveUpButton;
  }(AbstractMoveButton);
  MoveUpButton.id = 'moveUp';
  MoveUpButton.icon = getOrientedArrow('up');

  /**
   * @summary Navigation bar zoom button class
   * @extends PSV.buttons.AbstractButton
   * @memberof PSV.buttons
   */

  var AbstractZoomButton = /*#__PURE__*/function (_AbstractButton) {
    _inheritsLoose(AbstractZoomButton, _AbstractButton);

    /**
     * @param {PSV.components.Navbar} navbar
     * @param {number} value
     */
    function AbstractZoomButton(navbar, value) {
      var _this;

      _this = _AbstractButton.call(this, navbar, 'psv-button--hover-scale psv-zoom-button') || this;
      /**
       * @override
       * @property {boolean} value
       * @property {PressHandler} handler
       */

      _this.prop = _extends({}, _this.prop, {
        value: value,
        handler: new PressHandler()
      });

      _this.container.addEventListener('mousedown', _assertThisInitialized(_this));

      _this.container.addEventListener('keydown', _assertThisInitialized(_this));

      _this.container.addEventListener('keyup', _assertThisInitialized(_this));

      _this.psv.container.addEventListener('mouseup', _assertThisInitialized(_this));

      _this.psv.container.addEventListener('touchend', _assertThisInitialized(_this));

      return _this;
    }
    /**
     * @override
     */


    var _proto = AbstractZoomButton.prototype;

    _proto.destroy = function destroy() {
      this.__onMouseUp();

      this.psv.container.removeEventListener('mouseup', this);
      this.psv.container.removeEventListener('touchend', this);

      _AbstractButton.prototype.destroy.call(this);
    }
    /**
     * @summary Handles events
     * @param {Event} e
     * @private
     */
    ;

    _proto.handleEvent = function handleEvent(e) {
      /* eslint-disable */
      switch (e.type) {
        // @formatter:off
        case 'mousedown':
          this.__onMouseDown();

          break;

        case 'mouseup':
          this.__onMouseUp();

          break;

        case 'touchend':
          this.__onMouseUp();

          break;

        case 'keydown':
          e.key === KEY_CODES.Enter && this.__onMouseDown();
          break;

        case 'keyup':
          e.key === KEY_CODES.Enter && this.__onMouseUp();
          break;
        // @formatter:on
      }
      /* eslint-enable */

    }
    /**
     * @override
     */
    ;

    _proto.isSupported = function isSupported() {
      return {
        initial: !SYSTEM.isTouchEnabled.initial,
        promise: SYSTEM.isTouchEnabled.promise.then(function (enabled) {
          return !enabled;
        })
      };
    }
    /**
     * @override
     */
    ;

    _proto.onClick = function onClick() {// nothing
    }
    /**
     * @private
     */
    ;

    _proto.__onMouseDown = function __onMouseDown() {
      if (!this.prop.enabled) {
        return;
      }

      this.psv.dynamics.zoom.roll(this.prop.value);
      this.prop.handler.down();
    }
    /**
     * @private
     */
    ;

    _proto.__onMouseUp = function __onMouseUp() {
      var _this2 = this;

      if (!this.prop.enabled) {
        return;
      }

      this.prop.handler.up(function () {
        return _this2.psv.dynamics.zoom.stop();
      });
    };

    return AbstractZoomButton;
  }(AbstractButton);
  AbstractZoomButton.groupId = 'zoom';

  var zoomIn = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\"><path fill=\"currentColor\" d=\"M14.043 12.22a7.738 7.738 0 1 0-1.823 1.822l4.985 4.985c.503.504 1.32.504 1.822 0a1.285 1.285 0 0 0 0-1.822l-4.984-4.985zm-6.305 1.043a5.527 5.527 0 1 1 0-11.053 5.527 5.527 0 0 1 0 11.053z\"/><path fill=\"currentColor\" d=\"M8.728 4.009H6.744v2.737H4.006V8.73h2.738v2.736h1.984V8.73h2.737V6.746H8.728z\"/><!--Created by Ryan Canning from the Noun Project--></svg>\n";

  /**
   * @summary Navigation bar zoom-in button class
   * @extends PSV.buttons.AbstractZoomButton
   * @memberof PSV.buttons
   */

  var ZoomInButton = /*#__PURE__*/function (_AbstractZoomButton) {
    _inheritsLoose(ZoomInButton, _AbstractZoomButton);

    /**
     * @param {PSV.components.Navbar} navbar
     */
    function ZoomInButton(navbar) {
      return _AbstractZoomButton.call(this, navbar, false) || this;
    }

    return ZoomInButton;
  }(AbstractZoomButton);
  ZoomInButton.id = 'zoomIn';
  ZoomInButton.icon = zoomIn;

  var zoomOut = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\"><path fill=\"currentColor\" d=\"M14.043 12.22a7.738 7.738 0 1 0-1.823 1.822l4.985 4.985c.503.504 1.32.504 1.822 0a1.285 1.285 0 0 0 0-1.822l-4.984-4.985zm-6.305 1.043a5.527 5.527 0 1 1 0-11.053 5.527 5.527 0 0 1 0 11.053z\"/><path fill=\"currentColor\" d=\"M4.006 6.746h7.459V8.73H4.006z\"/><!--Created by Ryan Canning from the Noun Project--></svg>\n";

  /**
   * @summary Navigation bar zoom-out button class
   * @extends PSV.buttons.AbstractZoomButton
   * @memberof PSV.buttons
   */

  var ZoomOutButton = /*#__PURE__*/function (_AbstractZoomButton) {
    _inheritsLoose(ZoomOutButton, _AbstractZoomButton);

    /**
     * @param {PSV.components.Navbar} navbar
     */
    function ZoomOutButton(navbar) {
      return _AbstractZoomButton.call(this, navbar, true) || this;
    }

    return ZoomOutButton;
  }(AbstractZoomButton);
  ZoomOutButton.id = 'zoomOut';
  ZoomOutButton.icon = zoomOut;

  /**
   * @summary Navigation bar zoom button class
   * @extends PSV.buttons.AbstractButton
   * @memberof PSV.buttons
   */

  var ZoomRangeButton = /*#__PURE__*/function (_AbstractButton) {
    _inheritsLoose(ZoomRangeButton, _AbstractButton);

    /**
     * @param {PSV.components.Navbar} navbar
     */
    function ZoomRangeButton(navbar) {
      var _this;

      _this = _AbstractButton.call(this, navbar, 'psv-zoom-range', false, false) || this;
      /**
       * @override
       * @property {number} mediaMinWidth
       */

      _this.prop = _extends({}, _this.prop, {
        mediaMinWidth: 0
      });
      /**
       * @member {HTMLElement}
       * @readonly
       * @private
       */

      _this.zoomRange = document.createElement('div');
      _this.zoomRange.className = 'psv-zoom-range-line';

      _this.container.appendChild(_this.zoomRange);
      /**
       * @member {HTMLElement}
       * @readonly
       * @private
       */


      _this.zoomValue = document.createElement('div');
      _this.zoomValue.className = 'psv-zoom-range-handle';

      _this.zoomRange.appendChild(_this.zoomValue);
      /**
       * @member {PSV.Slider}
       * @readonly
       * @private
       */


      _this.slider = new Slider({
        container: _this.container,
        direction: Slider.HORIZONTAL,
        onUpdate: function onUpdate(e) {
          return _this.__onSliderUpdate(e);
        }
      });
      _this.prop.mediaMinWidth = parseInt(getStyle(_this.container, 'maxWidth'), 10);

      _this.psv.on(EVENTS.ZOOM_UPDATED, _assertThisInitialized(_this));

      if (_this.psv.prop.ready) {
        _this.__moveZoomValue(_this.psv.getZoomLevel());
      } else {
        _this.psv.once(EVENTS.READY, _assertThisInitialized(_this));
      }

      _this.refreshUi();

      return _this;
    }
    /**
     * @override
     */


    var _proto = ZoomRangeButton.prototype;

    _proto.destroy = function destroy() {
      this.slider.destroy();
      delete this.zoomRange;
      delete this.zoomValue;
      this.psv.off(EVENTS.ZOOM_UPDATED, this);
      this.psv.off(EVENTS.READY, this);

      _AbstractButton.prototype.destroy.call(this);
    }
    /**
     * @summary Handles events
     * @param {Event} e
     * @private
     */
    ;

    _proto.handleEvent = function handleEvent(e) {
      /* eslint-disable */
      switch (e.type) {
        // @formatter:off
        case EVENTS.ZOOM_UPDATED:
          this.__moveZoomValue(e.args[0]);

          break;

        case EVENTS.READY:
          this.__moveZoomValue(this.psv.getZoomLevel());

          break;
        // @formatter:on
      }
      /* eslint-enable */

    }
    /**
     * @override
     */
    ;

    _proto.isSupported = function isSupported() {
      return {
        initial: !SYSTEM.isTouchEnabled.initial,
        promise: SYSTEM.isTouchEnabled.promise.then(function (enabled) {
          return !enabled;
        })
      };
    }
    /**
     * @override
     */
    ;

    _proto.refreshUi = function refreshUi() {
      if (this.prop.supported) {
        if (this.psv.prop.size.width <= this.prop.mediaMinWidth && this.prop.visible) {
          this.hide();
        } else if (this.psv.prop.size.width > this.prop.mediaMinWidth && !this.prop.visible) {
          this.show();
        }
      }
    }
    /**
     * @override
     */
    ;

    _proto.onClick = function onClick() {// nothing
    }
    /**
     * @summary Moves the zoom cursor
     * @param {number} level
     * @private
     */
    ;

    _proto.__moveZoomValue = function __moveZoomValue(level) {
      this.zoomValue.style.left = level / 100 * this.zoomRange.offsetWidth - this.zoomValue.offsetWidth / 2 + 'px';
    }
    /**
     * @summary Zoom change
     * @private
     */
    ;

    _proto.__onSliderUpdate = function __onSliderUpdate(e) {
      if (e.mousedown) {
        this.psv.zoom(e.value * 100);
      }
    };

    return ZoomRangeButton;
  }(AbstractButton);
  ZoomRangeButton.id = 'zoomRange';
  ZoomRangeButton.groupId = 'zoom';

  /**
   * @namespace PSV.plugins
   */

  /**
   * @summary Base plugins class
   * @memberof PSV.plugins
   * @abstract
   */

  var AbstractPlugin = /*#__PURE__*/function (_EventEmitter) {
    _inheritsLoose(AbstractPlugin, _EventEmitter);

    /**
     * @summary Unique identifier of the plugin
     * @member {string}
     * @readonly
     * @static
     */

    /**
     * @param {PSV.Viewer} psv
     */
    function AbstractPlugin(psv) {
      var _this;

      _this = _EventEmitter.call(this) || this;
      /**
       * @summary Reference to main controller
       * @type {PSV.Viewer}
       * @readonly
       */

      _this.psv = psv;
      return _this;
    }
    /**
     * @summary Initializes the plugin
     * @package
     */


    var _proto = AbstractPlugin.prototype;

    _proto.init = function init() {}
    /**
     * @summary Destroys the plugin
     * @package
     */
    ;

    _proto.destroy = function destroy() {
      delete this.psv;
    };

    return AbstractPlugin;
  }(uevent.EventEmitter);
  AbstractPlugin.id = null;

  var _keyboard;
  /**
   * @summary Default options
   * @type {PSV.Options}
   * @memberOf PSV
   * @constant
   */

  var DEFAULTS = {
    panorama: null,
    overlay: null,
    overlayOpacity: 1,
    container: null,
    adapter: null,
    plugins: [],
    caption: null,
    description: null,
    downloadUrl: null,
    loadingImg: null,
    loadingTxt: 'Loading...',
    size: null,
    fisheye: false,
    minFov: 30,
    maxFov: 90,
    defaultZoomLvl: 50,
    defaultLong: 0,
    defaultLat: 0,
    sphereCorrection: null,
    moveSpeed: 1,
    zoomSpeed: 1,
    autorotateDelay: null,
    autorotateIdle: false,
    autorotateSpeed: '2rpm',
    autorotateLat: null,
    autorotateZoomLvl: null,
    moveInertia: true,
    mousewheel: true,
    mousemove: true,
    mousewheelCtrlKey: false,
    touchmoveTwoFingers: false,
    useXmpData: true,
    panoData: null,
    requestHeaders: null,
    canvasBackground: '#000',
    withCredentials: false,
    navbar: ['autorotate', 'zoom', 'move', 'download', 'description', 'caption', 'fullscreen'],
    lang: {
      autorotate: 'Automatic rotation',
      zoom: 'Zoom',
      zoomOut: 'Zoom out',
      zoomIn: 'Zoom in',
      move: 'Move',
      download: 'Download',
      fullscreen: 'Fullscreen',
      menu: 'Menu',
      twoFingers: 'Use two fingers to navigate',
      ctrlZoom: 'Use ctrl + scroll to zoom the image',
      loadError: 'The panorama can\'t be loaded'
    },
    keyboard: (_keyboard = {}, _keyboard[KEY_CODES.ArrowUp] = ACTIONS.ROTATE_LAT_UP, _keyboard[KEY_CODES.ArrowDown] = ACTIONS.ROTATE_LAT_DOWN, _keyboard[KEY_CODES.ArrowRight] = ACTIONS.ROTATE_LONG_RIGHT, _keyboard[KEY_CODES.ArrowLeft] = ACTIONS.ROTATE_LONG_LEFT, _keyboard[KEY_CODES.PageUp] = ACTIONS.ZOOM_IN, _keyboard[KEY_CODES.PageDown] = ACTIONS.ZOOM_OUT, _keyboard[KEY_CODES.Plus] = ACTIONS.ZOOM_IN, _keyboard[KEY_CODES.Minus] = ACTIONS.ZOOM_OUT, _keyboard[KEY_CODES.Space] = ACTIONS.TOGGLE_AUTOROTATE, _keyboard)
  };
  /**
   * @summary List of unmodifiable options and their error messages
   * @private
   */

  var READONLY_OPTIONS = {
    panorama: 'Use setPanorama method to change the panorama',
    panoData: 'Use setPanorama method to change the panorama',
    container: 'Cannot change viewer container',
    adapter: 'Cannot change adapter',
    plugins: 'Cannot change plugins'
  };
  /**
   * @summary List of deprecated options and their warning messages
   * @private
   */

  var DEPRECATED_OPTIONS = {
    captureCursor: 'captureCursor is deprecated'
  };
  /**
   * @summary Parsers/validators for each option
   * @private
   */

  var CONFIG_PARSERS = {
    container: function container(_container) {
      if (!_container) {
        throw new PSVError('No value given for container.');
      }

      return _container;
    },
    adapter: function adapter(_adapter) {
      if (!_adapter) {
        _adapter = [EquirectangularAdapter];
      } else if (Array.isArray(_adapter)) {
        _adapter = [pluginInterop(_adapter[0], AbstractAdapter), _adapter[1]];
      } else {
        _adapter = [pluginInterop(_adapter, AbstractAdapter)];
      }

      if (!_adapter[0]) {
        throw new PSVError('Un undefined value with given for adapter.');
      }

      return _adapter;
    },
    overlayOpacity: function overlayOpacity(_overlayOpacity) {
      return three.MathUtils.clamp(_overlayOpacity, 0, 1);
    },
    defaultLong: function defaultLong(_defaultLong) {
      // defaultLat is between 0 and PI
      return parseAngle(_defaultLong);
    },
    defaultLat: function defaultLat(_defaultLat) {
      // defaultLat is between -PI/2 and PI/2
      return parseAngle(_defaultLat, true);
    },
    defaultZoomLvl: function defaultZoomLvl(_defaultZoomLvl) {
      return three.MathUtils.clamp(_defaultZoomLvl, 0, 100);
    },
    minFov: function minFov(_minFov, config) {
      // minFov and maxFov must be ordered
      if (config.maxFov < _minFov) {
        logWarn('maxFov cannot be lower than minFov');
        _minFov = config.maxFov;
      } // minFov between 1 and 179


      return three.MathUtils.clamp(_minFov, 1, 179);
    },
    maxFov: function maxFov(_maxFov, config) {
      // minFov and maxFov must be ordered
      if (_maxFov < config.minFov) {
        _maxFov = config.minFov;
      } // maxFov between 1 and 179


      return three.MathUtils.clamp(_maxFov, 1, 179);
    },
    lang: function lang(_lang) {
      if (Array.isArray(_lang.twoFingers)) {
        logWarn('lang.twoFingers must not be an array');
        _lang.twoFingers = _lang.twoFingers[0];
      }

      return _extends({}, DEFAULTS.lang, _lang);
    },
    keyboard: function keyboard(_keyboard2) {
      // keyboard=true becomes the default map
      if (_keyboard2 === true) {
        return clone(DEFAULTS.keyboard);
      }

      return _keyboard2;
    },
    autorotateLat: function autorotateLat(_autorotateLat, config) {
      // default autorotateLat is defaultLat
      if (_autorotateLat === null) {
        return parseAngle(config.defaultLat, true);
      } // autorotateLat is between -PI/2 and PI/2
      else {
        return parseAngle(_autorotateLat, true);
      }
    },
    autorotateZoomLvl: function autorotateZoomLvl(_autorotateZoomLvl) {
      if (isNil(_autorotateZoomLvl)) {
        return null;
      } else {
        return three.MathUtils.clamp(_autorotateZoomLvl, 0, 100);
      }
    },
    autorotateSpeed: function autorotateSpeed(_autorotateSpeed) {
      return parseSpeed(_autorotateSpeed);
    },
    autorotateIdle: function autorotateIdle(_autorotateIdle, config) {
      if (_autorotateIdle && isNil(config.autorotateDelay)) {
        logWarn('autorotateIdle requires a non null autorotateDelay');
        return false;
      }

      return _autorotateIdle;
    },
    fisheye: function fisheye(_fisheye) {
      // translate boolean fisheye to amount
      if (_fisheye === true) {
        return 1;
      } else if (_fisheye === false) {
        return 0;
      }

      return _fisheye;
    },
    plugins: function plugins(_plugins) {
      return _plugins.map(function (plugin) {
        if (Array.isArray(plugin)) {
          plugin = [pluginInterop(plugin[0], AbstractPlugin), plugin[1]];
        } else {
          plugin = [pluginInterop(plugin, AbstractPlugin)];
        }

        if (!plugin[0]) {
          throw new PSVError('Un undefined value was given for plugins.');
        }

        return plugin;
      });
    }
  };
  /**
   * @summary Merge user config with default config and performs validation
   * @param {PSV.Options} options
   * @returns {PSV.Options}
   * @memberOf PSV
   * @private
   */

  function getConfig(options) {
    var tempConfig = clone(DEFAULTS);
    deepmerge(tempConfig, options);
    var config = {};
    each(tempConfig, function (value, key) {
      if (DEPRECATED_OPTIONS[key]) {
        logWarn(DEPRECATED_OPTIONS[key]);
        return;
      }

      if (!Object.prototype.hasOwnProperty.call(DEFAULTS, key)) {
        throw new PSVError("Unknown option " + key);
      }

      if (CONFIG_PARSERS[key]) {
        config[key] = CONFIG_PARSERS[key](value, tempConfig);
      } else {
        config[key] = value;
      }
    });
    return config;
  }

  /**
   * @summary Navbar caption class
   * @extends PSV.components.AbstractComponent
   * @memberof PSV.components
   */

  var NavbarCaption = /*#__PURE__*/function (_AbstractComponent) {
    _inheritsLoose(NavbarCaption, _AbstractComponent);

    /**
     * @param {PSV.components.Navbar} navbar
     * @param {string} caption
     */
    function NavbarCaption(navbar, caption) {
      var _this;

      _this = _AbstractComponent.call(this, navbar, 'psv-caption') || this;
      /**
       * @override
       * @property {string} id
       * @property {boolean} collapsable
       * @property {number} width
       * @property {number} contentWidth - width of the caption content
       */

      _this.prop = _extends({}, _this.prop, {
        id: _this.constructor.id,
        collapsable: false,
        width: 0,
        contentWidth: 0
      });
      /**
       * @member {HTMLElement}
       * @readonly
       * @private
       */

      _this.content = document.createElement('div');
      _this.content.className = 'psv-caption-content';

      _this.container.appendChild(_this.content);

      _this.setCaption(caption);

      return _this;
    }
    /**
     * @override
     */


    var _proto = NavbarCaption.prototype;

    _proto.destroy = function destroy() {
      delete this.content;

      _AbstractComponent.prototype.destroy.call(this);
    }
    /**
     * @summary Sets the bar caption
     * @param {string} html
     */
    ;

    _proto.setCaption = function setCaption(html) {
      this.show();
      this.content.innerHTML = html;
      this.prop.contentWidth = html ? this.content.offsetWidth : 0;
      this.refreshUi();
    }
    /**
     * @summary Toggles content and icon depending on available space
     * @private
     */
    ;

    _proto.refreshUi = function refreshUi() {
      this.toggle(this.container.offsetWidth >= this.prop.contentWidth);

      this.__refreshButton();
    }
    /**
     * @override
     */
    ;

    _proto.hide = function hide() {
      this.content.style.display = 'none';
      this.prop.visible = false;
    }
    /**
     * @override
     */
    ;

    _proto.show = function show() {
      this.content.style.display = '';
      this.prop.visible = true;
    }
    /**
     * @private
     */
    ;

    _proto.__refreshButton = function __refreshButton() {
      var _this$psv$navbar$getB;

      (_this$psv$navbar$getB = this.psv.navbar.getButton(DescriptionButton.id, false)) == null ? void 0 : _this$psv$navbar$getB.refreshUi(true);
    };

    return NavbarCaption;
  }(AbstractComponent);
  NavbarCaption.id = 'caption';

  /**
   * @summary List of available buttons
   * @type {Object<string, Class<PSV.buttons.AbstractButton>>}
   * @private
   */

  var AVAILABLE_BUTTONS = {};
  /**
   * @summary List of available buttons
   * @type {Object<string, Array<Class<PSV.buttons.AbstractButton>>>}
   * @private
   */

  var AVAILABLE_GROUPS = {};
  /**
   * @summary Register a new button available for all viewers
   * @param {Class<PSV.buttons.AbstractButton>} button
   * @param {'start' | 'end' | '[id]:left' | '[id]:right'} [defaultPosition]
   *    If provided the default configuration of the navbar will be modified.
   * @memberOf PSV
   */

  function registerButton(button, defaultPosition) {
    if (!button.id) {
      throw new PSVError('Button ID is required');
    }

    AVAILABLE_BUTTONS[button.id] = button;

    if (button.groupId) {
      AVAILABLE_GROUPS[button.groupId] = AVAILABLE_GROUPS[button.groupId] || [];
      AVAILABLE_GROUPS[button.groupId].push(button);
    }

    if (typeof defaultPosition === 'string') {
      switch (defaultPosition) {
        case 'start':
          DEFAULTS.navbar.unshift(button.id);
          break;

        case 'end':
          DEFAULTS.navbar.push(button.id);
          break;

        default:
          var _defaultPosition$spli = defaultPosition.split(':'),
              id = _defaultPosition$spli[0],
              pos = _defaultPosition$spli[1];

          DEFAULTS.navbar.splice(DEFAULTS.navbar.indexOf(id) + (pos === 'right' ? 1 : 0), 0, button.id);
      }
    }
  }
  [AutorotateButton, ZoomOutButton, ZoomRangeButton, ZoomInButton, DescriptionButton, DownloadButton, FullscreenButton, MoveLeftButton, MoveRightButton, MoveUpButton, MoveDownButton].forEach(registerButton);
  /**
   * @summary Navigation bar component
   * @extends PSV.components.AbstractComponent
   * @memberof PSV.components
   */

  var Navbar = /*#__PURE__*/function (_AbstractComponent) {
    _inheritsLoose(Navbar, _AbstractComponent);

    /**
     * @param {PSV.Viewer} psv
     */
    function Navbar(psv) {
      var _this;

      _this = _AbstractComponent.call(this, psv, 'psv-navbar psv--capture-event') || this;
      /**
       * @summary List of buttons of the navbar
       * @member {PSV.buttons.AbstractButton[]}
       * @override
       */

      _this.children = [];
      /**
       * @summary List of collapsed buttons
       * @member {PSV.buttons.AbstractButton[]}
       * @private
       */

      _this.collapsed = [];
      return _this;
    }
    /**
     * @summary Change the buttons visible on the navbar
     * @param {string|Array<string|PSV.NavbarCustomButton>} buttons
     * @throws {PSV.PSVError} when a button is unknown
     */


    var _proto = Navbar.prototype;

    _proto.setButtons = function setButtons(buttons) {
      var _this2 = this;

      this.children.slice().forEach(function (item) {
        return item.destroy();
      });
      this.children.length = 0;

      var cleanedButtons = this.__cleanButtons(buttons); // force description button if caption is present (used on narrow screens)


      if (cleanedButtons.indexOf(NavbarCaption.id) !== -1 && cleanedButtons.indexOf(DescriptionButton.id) === -1) {
        cleanedButtons.splice(cleanedButtons.indexOf(NavbarCaption.id), 0, DescriptionButton.id);
      }
      /* eslint-disable no-new */


      cleanedButtons.forEach(function (button) {
        if (typeof button === 'object') {
          new CustomButton(_this2, button);
        } else if (AVAILABLE_BUTTONS[button]) {
          new AVAILABLE_BUTTONS[button](_this2);
        } else if (AVAILABLE_GROUPS[button]) {
          AVAILABLE_GROUPS[button].forEach(function (buttonCtor) {
            return new buttonCtor(_this2);
          }); // eslint-disable-line new-cap
        } else if (button === NavbarCaption.id) {
          new NavbarCaption(_this2, _this2.psv.config.caption);
        } else {
          throw new PSVError('Unknown button ' + button);
        }
      });
      new MenuButton(this);
      /* eslint-enable no-new */

      this.children.forEach(function (item) {
        if (typeof item.checkSupported === 'function') {
          item.checkSupported();
        }
      });
    }
    /**
     * @summary Sets the bar caption
     * @param {string} html
     */
    ;

    _proto.setCaption = function setCaption(html) {
      var caption = this.getButton(NavbarCaption.id, false);
      caption == null ? void 0 : caption.setCaption(html);
    }
    /**
     * @summary Returns a button by its identifier
     * @param {string} id
     * @param {boolean} [warnNotFound=true]
     * @returns {PSV.buttons.AbstractButton}
     */
    ;

    _proto.getButton = function getButton(id, warnNotFound) {
      if (warnNotFound === void 0) {
        warnNotFound = true;
      }

      var button = null;
      this.children.some(function (item) {
        if (item.prop.id === id) {
          button = item;
          return true;
        } else {
          return false;
        }
      });

      if (!button && warnNotFound) {
        logWarn("button \"" + id + "\" not found in the navbar");
      }

      return button;
    }
    /**
     * @summary Shows the navbar
     */
    ;

    _proto.show = function show() {
      this.container.classList.add('psv-navbar--open');
      this.prop.visible = true;
    }
    /**
     * @summary Hides the navbar
     */
    ;

    _proto.hide = function hide() {
      this.container.classList.remove('psv-navbar--open');
      this.prop.visible = false;
    }
    /**
     * @override
     */
    ;

    _proto.refreshUi = function refreshUi() {
      _AbstractComponent.prototype.refreshUi.call(this);

      if (this.psv.prop.uiRefresh === true) {
        var availableWidth = this.container.offsetWidth;
        var totalWidth = 0;
        var visibleButtons = [];
        var collapsableButtons = [];
        this.children.forEach(function (item) {
          if (item.prop.visible) {
            totalWidth += item.prop.width;
            visibleButtons.push(item);

            if (item.prop.collapsable) {
              collapsableButtons.push(item);
            }
          }
        });

        if (!visibleButtons.length) {
          return;
        }

        if (availableWidth < totalWidth && collapsableButtons.length > 0) {
          collapsableButtons.forEach(function (item) {
            return item.collapse();
          });
          this.collapsed = collapsableButtons;
          this.getButton(MenuButton.id).show(false);
        } else if (availableWidth >= totalWidth && this.collapsed.length > 0) {
          this.collapsed.forEach(function (item) {
            return item.uncollapse();
          });
          this.collapsed = [];
          this.getButton(MenuButton.id).hide(false);
        }

        var caption = this.getButton(NavbarCaption.id, false);

        if (caption) {
          caption.refreshUi();
        }
      }
    }
    /**
     * @summary Ensure the buttons configuration is correct
     * @private
     */
    ;

    _proto.__cleanButtons = function __cleanButtons(buttons) {
      // true becomes the default array
      if (buttons === true) {
        return clone(DEFAULTS.navbar);
      } // can be a space or coma separated list
      else if (typeof buttons === 'string') {
        return buttons.split(/[ ,]/);
      } else {
        return buttons || [];
      }
    };

    return Navbar;
  }(AbstractComponent);

  /**
   * @summary Loader component
   * @extends PSV.components.AbstractComponent
   * @memberof PSV.components
   */

  var Loader = /*#__PURE__*/function (_AbstractComponent) {
    _inheritsLoose(Loader, _AbstractComponent);

    /**
     * @param {PSV.Viewer} psv
     */
    function Loader(psv) {
      var _this;

      _this = _AbstractComponent.call(this, psv, 'psv-loader-container') || this;
      /**
       * @summary Inner container for vertical center
       * @member {HTMLElement}
       * @readonly
       * @private
       */

      _this.loader = document.createElement('div');
      _this.loader.className = 'psv-loader';

      _this.container.appendChild(_this.loader);
      /**
       * @summary Animation canvas
       * @member {HTMLCanvasElement}
       * @readonly
       * @private
       */


      _this.canvas = document.createElement('canvas');
      _this.canvas.className = 'psv-loader-canvas';
      _this.canvas.width = _this.loader.clientWidth * SYSTEM.pixelRatio;
      _this.canvas.height = _this.loader.clientWidth * SYSTEM.pixelRatio;

      _this.loader.appendChild(_this.canvas);
      /**
       * @override
       * @property {number} thickness
       * @property {string} current
       */


      _this.prop = _extends({}, _this.prop, {
        tickness: (_this.loader.offsetWidth - _this.loader.clientWidth) / 2 * SYSTEM.pixelRatio,
        current: null
      });

      _this.refreshUi();

      _this.hide();

      return _this;
    }
    /**
     * @override
     */


    var _proto = Loader.prototype;

    _proto.destroy = function destroy() {
      delete this.loader;
      delete this.canvas;

      _AbstractComponent.prototype.destroy.call(this);
    }
    /**
     * @override
     */
    ;

    _proto.refreshUi = function refreshUi() {
      if (this.prop.current !== (this.psv.config.loadingImg || this.psv.config.loadingTxt)) {
        if (this.prop.current) {
          this.loader.removeChild(this.loader.lastChild);
        }

        var inner;

        if (this.psv.config.loadingImg) {
          inner = document.createElement('img');
          inner.className = 'psv-loader-image';
          inner.src = this.psv.config.loadingImg;
        } else if (this.psv.config.loadingTxt) {
          inner = document.createElement('div');
          inner.className = 'psv-loader-text';
          inner.innerHTML = this.psv.config.loadingTxt;
        }

        if (inner) {
          var size = Math.round(Math.sqrt(2 * Math.pow((this.canvas.width / 2 - this.prop.tickness / 2) / SYSTEM.pixelRatio, 2)));
          inner.style.maxWidth = size + 'px';
          inner.style.maxHeight = size + 'px';
          this.loader.appendChild(inner);
        }

        this.prop.current = this.psv.config.loadingImg || this.psv.config.loadingTxt;
      }
    }
    /**
     * @summary Sets the loader progression
     * @param {number} value - from 0 to 100
     */
    ;

    _proto.setProgress = function setProgress(value) {
      var context = this.canvas.getContext('2d');
      context.clearRect(0, 0, this.canvas.width, this.canvas.height);
      context.lineWidth = this.prop.tickness;
      context.strokeStyle = getStyle(this.loader, 'color');
      context.beginPath();
      context.arc(this.canvas.width / 2, this.canvas.height / 2, this.canvas.width / 2 - this.prop.tickness / 2, -Math.PI / 2, three.MathUtils.clamp(value, 0, 100) / 100 * 2 * Math.PI - Math.PI / 2);
      context.stroke();
      this.psv.trigger(EVENTS.LOAD_PROGRESS, Math.round(value));
    };

    return Loader;
  }(AbstractComponent);

  /**
   * @summary Notification component
   * @extends PSV.components.AbstractComponent
   * @memberof PSV.components
   */

  var Notification = /*#__PURE__*/function (_AbstractComponent) {
    _inheritsLoose(Notification, _AbstractComponent);

    /**
     * @param {PSV.Viewer} psv
     */
    function Notification(psv) {
      var _this;

      _this = _AbstractComponent.call(this, psv, 'psv-notification') || this;
      /**
       * @override
       * @property {*} timeout
       */

      _this.prop = _extends({}, _this.prop, {
        visible: false,
        contentId: undefined,
        timeout: null
      });
      /**
       * Notification content
       * @member {HTMLElement}
       * @readonly
       * @private
       */

      _this.content = document.createElement('div');
      _this.content.className = 'psv-notification-content';

      _this.container.appendChild(_this.content);

      _this.content.addEventListener('click', function () {
        return _this.hide();
      });

      return _this;
    }
    /**
     * @override
     */


    var _proto = Notification.prototype;

    _proto.destroy = function destroy() {
      delete this.content;

      _AbstractComponent.prototype.destroy.call(this);
    }
    /**
     * @override
     * @param {string} [id]
     */
    ;

    _proto.isVisible = function isVisible(id) {
      return this.prop.visible && (!id || !this.prop.contentId || this.prop.contentId === id);
    }
    /**
     * @override
     * @summary This method is not supported
     * @throws {PSV.PSVError} always
     */
    ;

    _proto.toggle = function toggle() {
      throw new PSVError('Notification cannot be toggled');
    }
    /**
     * @summary Displays a notification on the viewer
     * @param {Object|string} config
     * @param {string} [config.id] - unique identifier to use with "hide"
     * @param {string} config.content
     * @param {number} [config.timeout]
     * @fires PSV.show-notification
     *
     * @example
     * viewer.showNotification({ content: 'Hello world', timeout: 5000 })
     * @example
     * viewer.showNotification('Hello world')
     */
    ;

    _proto.show = function show(config) {
      var _this2 = this;

      if (this.prop.timeout) {
        clearTimeout(this.prop.timeout);
        this.prop.timeout = null;
      }

      if (typeof config === 'string') {
        config = {
          content: config
        };
      }

      this.prop.contentId = config.id;
      this.content.innerHTML = config.content;
      this.container.classList.add('psv-notification--visible');
      this.prop.visible = true;
      this.psv.trigger(EVENTS.SHOW_NOTIFICATION, config.id);

      if (config.timeout) {
        this.prop.timeout = setTimeout(function () {
          return _this2.hide(config.id);
        }, config.timeout);
      }
    }
    /**
     * @summary Hides the notification
     * @param {string} [id]
     * @fires PSV.hide-notification
     */
    ;

    _proto.hide = function hide(id) {
      if (this.isVisible(id)) {
        var contentId = this.prop.contentId;
        this.container.classList.remove('psv-notification--visible');
        this.prop.visible = false;
        this.prop.contentId = undefined;
        this.psv.trigger(EVENTS.HIDE_NOTIFICATION, contentId);
      }
    };

    return Notification;
  }(AbstractComponent);

  /**
   * @summary Overlay component
   * @extends PSV.components.AbstractComponent
   * @memberof PSV.components
   */

  var Overlay = /*#__PURE__*/function (_AbstractComponent) {
    _inheritsLoose(Overlay, _AbstractComponent);

    /**
     * @param {PSV.Viewer} psv
     */
    function Overlay(psv) {
      var _this;

      _this = _AbstractComponent.call(this, psv, 'psv-overlay') || this;
      /**
       * @override
       * @property {string} contentId
       * @property {boolean} dissmisable
       */

      _this.prop = _extends({}, _this.prop, {
        contentId: undefined,
        dissmisable: true
      });
      /**
       * Image container
       * @member {HTMLElement}
       * @readonly
       * @private
       */

      _this.image = document.createElement('div');
      _this.image.className = 'psv-overlay-image';

      _this.container.appendChild(_this.image);
      /**
       * Text container
       * @member {HTMLElement}
       * @readonly
       * @private
       */


      _this.text = document.createElement('div');
      _this.text.className = 'psv-overlay-text';

      _this.container.appendChild(_this.text);
      /**
       * Subtext container
       * @member {HTMLElement}
       * @readonly
       * @private
       */


      _this.subtext = document.createElement('div');
      _this.subtext.className = 'psv-overlay-subtext';

      _this.container.appendChild(_this.subtext);

      _this.psv.on(EVENTS.CLICK, _assertThisInitialized(_this));

      _this.psv.on(EVENTS.KEY_PRESS, _assertThisInitialized(_this));

      _AbstractComponent.prototype.hide.call(_assertThisInitialized(_this));

      return _this;
    }
    /**
     * @override
     */


    var _proto = Overlay.prototype;

    _proto.destroy = function destroy() {
      this.psv.off(EVENTS.CLICK, this);
      this.psv.off(EVENTS.KEY_PRESS, this);
      delete this.image;
      delete this.text;
      delete this.subtext;

      _AbstractComponent.prototype.destroy.call(this);
    }
    /**
     * @summary Handles events
     * @param {Event} e
     * @private
     */
    ;

    _proto.handleEvent = function handleEvent(e) {
      /* eslint-disable */
      switch (e.type) {
        case EVENTS.CLICK:
          if (this.isVisible() && this.prop.dissmisable) {
            this.hide();
            e.stopPropagation();
          }

          break;

        case EVENTS.KEY_PRESS:
          if (this.isVisible() && this.prop.dissmisable && e.args[0] === KEY_CODES.Escape) {
            this.hide();
            e.preventDefault();
          }

          break;
      }
      /* eslint-enable */

    }
    /**
     * @override
     * @param {string} [id]
     */
    ;

    _proto.isVisible = function isVisible(id) {
      return this.prop.visible && (!id || !this.prop.contentId || this.prop.contentId === id);
    }
    /**
     * @override
     * @summary This method is not supported
     * @throws {PSV.PSVError} always
     */
    ;

    _proto.toggle = function toggle() {
      throw new PSVError('Overlay cannot be toggled');
    }
    /**
     * @summary Displays an overlay on the viewer
     * @param {Object|string} config
     * @param {string} [config.id] - unique identifier to use with "hide"
     * @param {string} config.image - SVG image/icon displayed above the text
     * @param {string} config.text - main message
     * @param {string} [config.subtext] - secondary message
     * @param {boolean} [config.dissmisable=true] - if the user can hide the overlay by clicking
     * @fires PSV.show-overlay
     */
    ;

    _proto.show = function show(config) {
      if (typeof config === 'string') {
        config = {
          text: config
        };
      }

      this.prop.contentId = config.id;
      this.prop.dissmisable = config.dissmisable !== false;
      this.image.innerHTML = config.image || '';
      this.text.innerHTML = config.text || '';
      this.subtext.innerHTML = config.subtext || '';

      _AbstractComponent.prototype.show.call(this);

      this.psv.trigger(EVENTS.SHOW_OVERLAY, config.id);
    }
    /**
     * @summary Hides the overlay
     * @param {string} [id]
     * @fires PSV.hide-overlay
     */
    ;

    _proto.hide = function hide(id) {
      if (this.isVisible(id)) {
        var contentId = this.prop.contentId;

        _AbstractComponent.prototype.hide.call(this);

        this.prop.contentId = undefined;
        this.psv.trigger(EVENTS.HIDE_OVERLAY, contentId);
      }
    };

    return Overlay;
  }(AbstractComponent);

  /**
   * @summary Minimum width of the panel
   * @type {number}
   * @constant
   * @private
   */

  var PANEL_MIN_WIDTH = 200;
  /**
   * @summary Panel component
   * @extends PSV.components.AbstractComponent
   * @memberof PSV.components
   */

  var Panel = /*#__PURE__*/function (_AbstractComponent) {
    _inheritsLoose(Panel, _AbstractComponent);

    /**
     * @param {PSV.Viewer} psv
     */
    function Panel(psv) {
      var _this;

      _this = _AbstractComponent.call(this, psv, 'psv-panel psv--capture-event') || this;
      /**
       * @override
       * @property {string} contentId
       * @property {number} mouseX
       * @property {number} mouseY
       * @property {boolean} mousedown
       * @property {function} clickHandler
       * @property {function} keyHandler
       */

      _this.prop = _extends({}, _this.prop, {
        visible: false,
        contentId: undefined,
        mouseX: 0,
        mouseY: 0,
        mousedown: false,
        clickHandler: null,
        keyHandler: null,
        width: {}
      });
      var resizer = document.createElement('div');
      resizer.className = 'psv-panel-resizer';

      _this.container.appendChild(resizer);

      var closeBtn = document.createElement('div');
      closeBtn.className = 'psv-panel-close-button';

      _this.container.appendChild(closeBtn);
      /**
       * @summary Content container
       * @member {HTMLElement}
       * @readonly
       * @private
       */


      _this.content = document.createElement('div');
      _this.content.className = 'psv-panel-content';

      _this.container.appendChild(_this.content); // Stop wheel event bubbling from panel


      _this.container.addEventListener(SYSTEM.mouseWheelEvent, function (e) {
        return e.stopPropagation();
      });

      closeBtn.addEventListener('click', function () {
        return _this.hide();
      }); // Event for panel resizing + stop bubling

      resizer.addEventListener('mousedown', _assertThisInitialized(_this));
      resizer.addEventListener('touchstart', _assertThisInitialized(_this));

      _this.psv.container.addEventListener('mouseup', _assertThisInitialized(_this));

      _this.psv.container.addEventListener('touchend', _assertThisInitialized(_this));

      _this.psv.container.addEventListener('mousemove', _assertThisInitialized(_this));

      _this.psv.container.addEventListener('touchmove', _assertThisInitialized(_this));

      _this.psv.on(EVENTS.KEY_PRESS, _assertThisInitialized(_this));

      return _this;
    }
    /**
     * @override
     */


    var _proto = Panel.prototype;

    _proto.destroy = function destroy() {
      this.psv.off(EVENTS.KEY_PRESS, this);
      this.psv.container.removeEventListener('mousemove', this);
      this.psv.container.removeEventListener('touchmove', this);
      this.psv.container.removeEventListener('mouseup', this);
      this.psv.container.removeEventListener('touchend', this);
      delete this.prop;
      delete this.content;

      _AbstractComponent.prototype.destroy.call(this);
    }
    /**
     * @summary Handles events
     * @param {Event} e
     * @private
     */
    ;

    _proto.handleEvent = function handleEvent(e) {
      /* eslint-disable */
      switch (e.type) {
        // @formatter:off
        case 'mousedown':
          this.__onMouseDown(e);

          break;

        case 'touchstart':
          this.__onTouchStart(e);

          break;

        case 'mousemove':
          this.__onMouseMove(e);

          break;

        case 'touchmove':
          this.__onTouchMove(e);

          break;

        case 'mouseup':
          this.__onMouseUp(e);

          break;

        case 'touchend':
          this.__onMouseUp(e);

          break;

        case EVENTS.KEY_PRESS:
          if (this.isVisible() && e.args[0] === KEY_CODES.Escape) {
            this.hide();
            e.preventDefault();
          }

          break;
        // @formatter:on
      }
      /* eslint-enable */

    }
    /**
     * @override
     * @param {string} [id]
     */
    ;

    _proto.isVisible = function isVisible(id) {
      return this.prop.visible && (!id || !this.prop.contentId || this.prop.contentId === id);
    }
    /**
     * @override
     * @summary This method is not supported
     * @throws {PSV.PSVError} always
     */
    ;

    _proto.toggle = function toggle() {
      throw new PSVError('Panel cannot be toggled');
    }
    /**
     * @summary Shows the panel
     * @param {string|Object} config
     * @param {string} [config.id] - unique identifier to use with "hide" and to store the user desired width
     * @param {string} config.content - HTML content of the panel
     * @param {boolean} [config.noMargin=false] - remove the default margins
     * @param {string} [config.width] - initial width
     * @param {Function} [config.clickHandler] - called when the user clicks inside the panel or presses the Enter key while an element focused
     * @fires PSV.open-panel
     */
    ;

    _proto.show = function show(config) {
      var _this2 = this;

      var wasVisible = this.isVisible(config.id);

      if (typeof config === 'string') {
        config = {
          content: config
        };
      }

      this.prop.contentId = config.id;
      this.prop.visible = true;

      if (this.prop.clickHandler) {
        this.content.removeEventListener('click', this.prop.clickHandler);
        this.content.removeEventListener('keydown', this.prop.keyHandler);
        this.prop.clickHandler = null;
        this.prop.keyHandler = null;
      }

      if (config.id && this.prop.width[config.id]) {
        this.container.style.width = this.prop.width[config.id];
      } else if (config.width) {
        this.container.style.width = config.width;
      } else {
        this.container.style.width = null;
      }

      this.content.innerHTML = config.content;
      this.content.scrollTop = 0;
      this.container.classList.add('psv-panel--open');
      toggleClass(this.content, 'psv-panel-content--no-margin', config.noMargin === true);

      if (config.clickHandler) {
        this.prop.clickHandler = config.clickHandler;

        this.prop.keyHandler = function (e) {
          if (e.key === KEY_CODES.Enter) {
            config.clickHandler(e);
          }
        };

        this.content.addEventListener('click', this.prop.clickHandler);
        this.content.addEventListener('keydown', this.prop.keyHandler); // focus the first element if possible, after animation ends

        if (!wasVisible) {
          setTimeout(function () {
            var _this2$content$queryS;

            (_this2$content$queryS = _this2.content.querySelector('a,button,[tabindex]')) == null ? void 0 : _this2$content$queryS.focus();
          }, 300);
        }
      }

      this.psv.trigger(EVENTS.OPEN_PANEL, config.id);
    }
    /**
     * @summary Hides the panel
     * @param {string} [id]
     * @fires PSV.close-panel
     */
    ;

    _proto.hide = function hide(id) {
      if (this.isVisible(id)) {
        var contentId = this.prop.contentId;
        this.prop.visible = false;
        this.prop.contentId = undefined;
        this.content.innerHTML = null;
        this.container.classList.remove('psv-panel--open');

        if (this.prop.clickHandler) {
          this.content.removeEventListener('click', this.prop.clickHandler);
          this.prop.clickHandler = null;
        }

        this.psv.trigger(EVENTS.CLOSE_PANEL, contentId);
      }
    }
    /**
     * @summary Handles mouse down events
     * @param {MouseEvent} evt
     * @private
     */
    ;

    _proto.__onMouseDown = function __onMouseDown(evt) {
      evt.stopPropagation();

      this.__startResize(evt);
    }
    /**
     * @summary Handles touch events
     * @param {TouchEvent} evt
     * @private
     */
    ;

    _proto.__onTouchStart = function __onTouchStart(evt) {
      evt.stopPropagation();

      this.__startResize(evt.changedTouches[0]);
    }
    /**
     * @summary Handles mouse up events
     * @param {MouseEvent} evt
     * @private
     */
    ;

    _proto.__onMouseUp = function __onMouseUp(evt) {
      if (this.prop.mousedown) {
        evt.stopPropagation();
        this.prop.mousedown = false;
        this.content.classList.remove('psv-panel-content--no-interaction');
      }
    }
    /**
     * @summary Handles mouse move events
     * @param {MouseEvent} evt
     * @private
     */
    ;

    _proto.__onMouseMove = function __onMouseMove(evt) {
      if (this.prop.mousedown) {
        evt.stopPropagation();

        this.__resize(evt);
      }
    }
    /**
     * @summary Handles touch move events
     * @param {TouchEvent} evt
     * @private
     */
    ;

    _proto.__onTouchMove = function __onTouchMove(evt) {
      if (this.prop.mousedown) {
        this.__resize(evt.touches[0]);
      }
    }
    /**
     * @summary Initializes the panel resize
     * @param {MouseEvent|Touch} evt
     * @private
     */
    ;

    _proto.__startResize = function __startResize(evt) {
      this.prop.mouseX = evt.clientX;
      this.prop.mouseY = evt.clientY;
      this.prop.mousedown = true;
      this.content.classList.add('psv-panel-content--no-interaction');
    }
    /**
     * @summary Resizes the panel
     * @param {MouseEvent|Touch} evt
     * @private
     */
    ;

    _proto.__resize = function __resize(evt) {
      var x = evt.clientX;
      var y = evt.clientY;
      var width = Math.max(PANEL_MIN_WIDTH, this.container.offsetWidth - (x - this.prop.mouseX)) + 'px';

      if (this.prop.contentId) {
        this.prop.width[this.prop.contentId] = width;
      }

      this.container.style.width = width;
      this.prop.mouseX = x;
      this.prop.mouseY = y;
    };

    return Panel;
  }(AbstractComponent);

  var errorIcon = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"15 15 70 70\"><path fill=\"currentColor\" d=\"M50,16.2c-18.6,0-33.8,15.1-33.8,33.8S31.4,83.7,50,83.7S83.8,68.6,83.8,50S68.6,16.2,50,16.2z M50,80.2c-16.7,0-30.2-13.6-30.2-30.2S33.3,19.7,50,19.7S80.3,33.3,80.3,50S66.7,80.2,50,80.2z\"/><rect fill=\"currentColor\" x=\"48\" y=\"31.7\" width=\"4\" height=\"28\"/><rect fill=\"currentColor\" x=\"48\" y=\"63.2\" width=\"4\" height=\"5\"/><!--Created by Shastry from the Noun Project--></svg>\n";

  /**
   * @namespace PSV.services
   */

  /**
   * @summary Base services class
   * @memberof PSV.services
   * @abstract
   */
  var AbstractService = /*#__PURE__*/function () {
    /**
     * @param {PSV.Viewer} psv
     */
    function AbstractService(psv) {
      /**
       * @summary Reference to main controller
       * @type {PSV.Viewer}
       * @readonly
       */
      this.psv = psv;
      /**
       * @summary Configuration holder
       * @type {PSV.Options}
       * @readonly
       */

      this.config = psv.config;
      /**
       * @summary Properties holder
       * @type {Object}
       * @readonly
       */

      this.prop = psv.prop;
    }
    /**
     * @summary Destroys the service
     */


    var _proto = AbstractService.prototype;

    _proto.destroy = function destroy() {
      delete this.psv;
      delete this.config;
      delete this.prop;
    };

    return AbstractService;
  }();

  var vector2 = new three.Vector2();
  var vector3 = new three.Vector3();
  var eulerZero = new three.Euler(0, 0, 0, 'ZXY');
  /**
   * @summary Collections of data converters for the current viewer
   * @extends PSV.services.AbstractService
   * @memberof PSV.services
   */

  var DataHelper = /*#__PURE__*/function (_AbstractService) {
    _inheritsLoose(DataHelper, _AbstractService);

    /**
     * @param {PSV.Viewer} psv
     */
    function DataHelper(psv) {
      return _AbstractService.call(this, psv) || this;
    }
    /**
     * @summary Converts vertical FOV to zoom level
     * @param {number} fov
     * @returns {number}
     */


    var _proto = DataHelper.prototype;

    _proto.fovToZoomLevel = function fovToZoomLevel(fov) {
      var temp = Math.round((fov - this.config.minFov) / (this.config.maxFov - this.config.minFov) * 100);
      return temp - 2 * (temp - 50);
    }
    /**
     * @summary Converts zoom level to vertical FOV
     * @param {number} level
     * @returns {number}
     */
    ;

    _proto.zoomLevelToFov = function zoomLevelToFov(level) {
      return this.config.maxFov + level / 100 * (this.config.minFov - this.config.maxFov);
    }
    /**
     * @summary Convert vertical FOV to horizontal FOV
     * @param {number} vFov
     * @returns {number}
     */
    ;

    _proto.vFovToHFov = function vFovToHFov(vFov) {
      return three.MathUtils.radToDeg(2 * Math.atan(Math.tan(three.MathUtils.degToRad(vFov) / 2) * this.prop.aspect));
    }
    /**
     * @summary Converts a speed into a duration from current position to a new position
     * @param {string|number} value
     * @param {number} angle
     * @returns {number}
     */
    ;

    _proto.speedToDuration = function speedToDuration(value, angle) {
      if (!value || typeof value !== 'number') {
        // desired radial speed
        var speed = value ? parseSpeed(value) : this.config.autorotateSpeed; // compute duration

        return angle / Math.abs(speed) * 1000;
      } else {
        return Math.abs(value);
      }
    }
    /**
     * @summary Converts pixel texture coordinates to spherical radians coordinates
     * @param {PSV.Point} point
     * @returns {PSV.Position}
     * @throws {PSV.PSVError} when the current adapter does not support texture coordinates
     */
    ;

    _proto.textureCoordsToSphericalCoords = function textureCoordsToSphericalCoords(point) {
      var panoData = this.prop.panoData;

      if (!panoData) {
        throw new PSVError('Current adapter does not support texture coordinates.');
      }

      var relativeX = (point.x + panoData.croppedX) / panoData.fullWidth * Math.PI * 2;
      var relativeY = (point.y + panoData.croppedY) / panoData.fullHeight * Math.PI;
      var result = {
        longitude: relativeX >= Math.PI ? relativeX - Math.PI : relativeX + Math.PI,
        latitude: Math.PI / 2 - relativeY
      }; // Apply panoData pose and sphereCorrection

      if (!eulerZero.equals(this.psv.renderer.mesh.rotation) || !eulerZero.equals(this.psv.renderer.meshContainer.rotation)) {
        this.sphericalCoordsToVector3(result, vector3);
        vector3.applyEuler(this.psv.renderer.mesh.rotation);
        vector3.applyEuler(this.psv.renderer.meshContainer.rotation);
        return this.vector3ToSphericalCoords(vector3);
      } else {
        return result;
      }
    }
    /**
     * @summary Converts spherical radians coordinates to pixel texture coordinates
     * @param {PSV.Position} position
     * @returns {PSV.Point}
     * @throws {PSV.PSVError} when the current adapter does not support texture coordinates
     */
    ;

    _proto.sphericalCoordsToTextureCoords = function sphericalCoordsToTextureCoords(position) {
      var panoData = this.prop.panoData;

      if (!panoData) {
        throw new PSVError('Current adapter does not support texture coordinates.');
      } // Apply panoData pose and sphereCorrection


      if (!eulerZero.equals(this.psv.renderer.mesh.rotation) || !eulerZero.equals(this.psv.renderer.meshContainer.rotation)) {
        this.sphericalCoordsToVector3(position, vector3);
        applyEulerInverse(vector3, this.psv.renderer.meshContainer.rotation);
        applyEulerInverse(vector3, this.psv.renderer.mesh.rotation);
        position = this.vector3ToSphericalCoords(vector3);
      }

      var relativeLong = position.longitude / Math.PI / 2 * panoData.fullWidth;
      var relativeLat = position.latitude / Math.PI * panoData.fullHeight;
      return {
        x: Math.round(position.longitude < Math.PI ? relativeLong + panoData.fullWidth / 2 : relativeLong - panoData.fullWidth / 2) - panoData.croppedX,
        y: Math.round(panoData.fullHeight / 2 - relativeLat) - panoData.croppedY
      };
    }
    /**
     * @summary Converts spherical radians coordinates to a THREE.Vector3
     * @param {PSV.Position} position
     * @param {external:THREE.Vector3} [vector]
     * @returns {external:THREE.Vector3}
     */
    ;

    _proto.sphericalCoordsToVector3 = function sphericalCoordsToVector3(position, vector) {
      if (!vector) {
        vector = new three.Vector3();
      }

      vector.x = SPHERE_RADIUS * -Math.cos(position.latitude) * Math.sin(position.longitude);
      vector.y = SPHERE_RADIUS * Math.sin(position.latitude);
      vector.z = SPHERE_RADIUS * Math.cos(position.latitude) * Math.cos(position.longitude);
      return vector;
    }
    /**
     * @summary Converts a THREE.Vector3 to spherical radians coordinates
     * @param {external:THREE.Vector3} vector
     * @returns {PSV.Position}
     */
    ;

    _proto.vector3ToSphericalCoords = function vector3ToSphericalCoords(vector) {
      var phi = Math.acos(vector.y / Math.sqrt(vector.x * vector.x + vector.y * vector.y + vector.z * vector.z));
      var theta = Math.atan2(vector.x, vector.z);
      return {
        longitude: theta < 0 ? -theta : Math.PI * 2 - theta,
        latitude: Math.PI / 2 - phi
      };
    }
    /**
     * @summary Converts position on the viewer to a THREE.Vector3
     * @param {PSV.Point} viewerPoint
     * @returns {external:THREE.Vector3}
     */
    ;

    _proto.viewerCoordsToVector3 = function viewerCoordsToVector3(viewerPoint) {
      var sphereIntersect = this.getIntersections(viewerPoint).filter(function (i) {
        return i.object.userData[MESH_USER_DATA];
      });

      if (sphereIntersect.length) {
        return sphereIntersect[0].point;
      } else {
        return null;
      }
    }
    /**
     * @summary Converts a THREE.Vector3 to position on the viewer
     * @param {external:THREE.Vector3} vector
     * @returns {PSV.Point}
     */
    ;

    _proto.vector3ToViewerCoords = function vector3ToViewerCoords(vector) {
      var vectorClone = vector.clone();
      vectorClone.project(this.psv.renderer.camera);
      return {
        x: Math.round((vectorClone.x + 1) / 2 * this.prop.size.width),
        y: Math.round((1 - vectorClone.y) / 2 * this.prop.size.height)
      };
    }
    /**
     * @summary Converts spherical radians coordinates to position on the viewer
     * @param {PSV.Position} position
     * @returns {PSV.Point}
     */
    ;

    _proto.sphericalCoordsToViewerCoords = function sphericalCoordsToViewerCoords(position) {
      return this.vector3ToViewerCoords(this.sphericalCoordsToVector3(position, vector3));
    }
    /**
     * @summary Returns intersections with objects in the scene
     * @param {PSV.Point} viewerPoint
     * @return {external:THREE.Intersection[]}
     */
    ;

    _proto.getIntersections = function getIntersections(viewerPoint) {
      vector2.x = 2 * viewerPoint.x / this.prop.size.width - 1;
      vector2.y = -2 * viewerPoint.y / this.prop.size.height + 1;
      this.psv.renderer.raycaster.setFromCamera(vector2, this.psv.renderer.camera);
      return this.psv.renderer.raycaster.intersectObjects(this.psv.renderer.scene.children, true).filter(function (i) {
        return !!i.object.userData;
      });
    }
    /**
     * @summary Converts x/y to latitude/longitude if present and ensure boundaries
     * @param {PSV.ExtendedPosition} position
     * @returns {PSV.Position}
     */
    ;

    _proto.cleanPosition = function cleanPosition(position) {
      if (position.x !== undefined && position.y !== undefined) {
        return this.textureCoordsToSphericalCoords(position);
      } else {
        return {
          longitude: parseAngle(position.longitude),
          latitude: parseAngle(position.latitude, !this.prop.littlePlanet)
        };
      }
    }
    /**
     * @summary Ensure a SphereCorrection object is valid
     * @param {PSV.SphereCorrection} sphereCorrection
     * @returns {PSV.SphereCorrection}
     */
    ;

    _proto.cleanSphereCorrection = function cleanSphereCorrection(sphereCorrection) {
      return {
        pan: parseAngle((sphereCorrection == null ? void 0 : sphereCorrection.pan) || 0),
        tilt: parseAngle((sphereCorrection == null ? void 0 : sphereCorrection.tilt) || 0, true),
        roll: parseAngle((sphereCorrection == null ? void 0 : sphereCorrection.roll) || 0, true, false)
      };
    }
    /**
     * @summary Parse the pose angles of the pano data
     * @param {PSV.PanoData} panoData
     * @returns {PSV.SphereCorrection}
     */
    ;

    _proto.cleanPanoramaPose = function cleanPanoramaPose(panoData) {
      return {
        pan: three.MathUtils.degToRad((panoData == null ? void 0 : panoData.poseHeading) || 0),
        tilt: three.MathUtils.degToRad((panoData == null ? void 0 : panoData.posePitch) || 0),
        roll: three.MathUtils.degToRad((panoData == null ? void 0 : panoData.poseRoll) || 0)
      };
    };

    return DataHelper;
  }(AbstractService);

  var gestureIcon = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 100 100\"><path fill=\"currentColor\" d=\"M33.38 33.2a1.96 1.96 0 0 0 1.5-3.23 10.61 10.61 0 0 1 7.18-17.51c.7-.06 1.31-.49 1.61-1.12a13.02 13.02 0 0 1 11.74-7.43c7.14 0 12.96 5.8 12.96 12.9 0 3.07-1.1 6.05-3.1 8.38-.7.82-.61 2.05.21 2.76.83.7 2.07.6 2.78-.22a16.77 16.77 0 0 0 4.04-10.91C72.3 7.54 64.72 0 55.4 0a16.98 16.98 0 0 0-14.79 8.7 14.6 14.6 0 0 0-12.23 14.36c0 3.46 1.25 6.82 3.5 9.45.4.45.94.69 1.5.69m45.74 43.55a22.13 22.13 0 0 1-5.23 12.4c-4 4.55-9.53 6.86-16.42 6.86-12.6 0-20.1-10.8-20.17-10.91a1.82 1.82 0 0 0-.08-.1c-5.3-6.83-14.55-23.82-17.27-28.87-.05-.1 0-.21.02-.23a6.3 6.3 0 0 1 8.24 1.85l9.38 12.59a1.97 1.97 0 0 0 3.54-1.17V25.34a4 4 0 0 1 1.19-2.87 3.32 3.32 0 0 1 2.4-.95c1.88.05 3.4 1.82 3.4 3.94v24.32a1.96 1.96 0 0 0 3.93 0v-33.1a3.5 3.5 0 0 1 7 0v35.39a1.96 1.96 0 0 0 3.93 0v-.44c.05-2.05 1.6-3.7 3.49-3.7 1.93 0 3.5 1.7 3.5 3.82v5.63c0 .24.04.48.13.71l.1.26a1.97 1.97 0 0 0 3.76-.37c.33-1.78 1.77-3.07 3.43-3.07 1.9 0 3.45 1.67 3.5 3.74l-1.77 18.1zM77.39 51c-1.25 0-2.45.32-3.5.9v-.15c0-4.27-3.33-7.74-7.42-7.74-1.26 0-2.45.33-3.5.9V16.69a7.42 7.42 0 0 0-14.85 0v1.86a7 7 0 0 0-3.28-.94 7.21 7.21 0 0 0-5.26 2.07 7.92 7.92 0 0 0-2.38 5.67v37.9l-5.83-7.82a10.2 10.2 0 0 0-13.35-2.92 4.1 4.1 0 0 0-1.53 5.48C20 64.52 28.74 80.45 34.07 87.34c.72 1.04 9.02 12.59 23.4 12.59 7.96 0 14.66-2.84 19.38-8.2a26.06 26.06 0 0 0 6.18-14.6l1.78-18.2v-.2c0-4.26-3.32-7.73-7.42-7.73z\"/><!--Created by AomAm from the Noun Project--></svg>\n";

  var mousewheelIcon = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"10 17 79 79\"><path fill=\"currentColor\" d=\"M38.1 29.27c-.24 0-.44.2-.44.45v10.7a.45.45 0 00.9 0v-10.7c0-.25-.2-.45-.45-.45zm10.2 26.66a11.54 11.54 0 01-8.48-6.14.45.45 0 10-.8.41 12.45 12.45 0 009.22 6.62.45.45 0 00.07-.9zm24.55-13.08a23.04 23.04 0 00-22.56-23v7.07l-.01.05a2.83 2.83 0 012.39 2.78v14.03l.09-.02h8.84v-9.22a.45.45 0 11.9 0v9.22h10.35v-.9zm0 27.33V44.66H62.5c-.02 2.01-.52 4-1.47 5.76a.45.45 0 01-.61.18.45.45 0 01-.19-.61 11.54 11.54 0 001.36-5.33h-8.83l-.1-.01a2.83 2.83 0 01-2.83 2.84h-.04-.04a2.83 2.83 0 01-2.83-2.83v-14.9a2.82 2.82 0 012.47-2.8v-7.11a23.04 23.04 0 00-22.57 23v.91h14.72V29.88a8.2 8.2 0 015.02-7.57c.22-.1.5.01.59.24.1.23-.01.5-.24.6a7.3 7.3 0 00-4.47 6.73v13.88h3.9a.45.45 0 110 .9h-3.9v.15a7.32 7.32 0 0011.23 6.17.45.45 0 01.49.76 8.22 8.22 0 01-12.62-6.93v-.15H26.82v25.52a23.04 23.04 0 0023.01 23.01 23.04 23.04 0 0023.02-23.01zm1.8-27.33v27.33A24.85 24.85 0 0149.84 95a24.85 24.85 0 01-24.82-24.82V42.85a24.85 24.85 0 0124.82-24.82 24.85 24.85 0 0124.83 24.82zM57.98 29.88v9.36a.45.45 0 11-.9 0v-9.36a7.28 7.28 0 00-3.4-6.17.45.45 0 01.49-.76 8.18 8.18 0 013.8 6.93z\"/><!-- Created by Icon Island from the Noun Project --></svg>\n";

  var IDLE = 0;
  var MOVING = 1;
  var INERTIA = 2;
  /**
   * @summary Events handler
   * @extends PSV.services.AbstractService
   * @memberof PSV.services
   */

  var EventsHandler = /*#__PURE__*/function (_AbstractService) {
    _inheritsLoose(EventsHandler, _AbstractService);

    /**
     * @param {PSV.Viewer} psv
     */
    function EventsHandler(psv) {
      var _this;

      _this = _AbstractService.call(this, psv) || this;
      /**
       * @summary Internal properties
       * @member {Object}
       * @property {number} moveThreshold - computed threshold based on device pixel ratio
       * @property {number} step
       * @property {boolean} mousedown - before moving past the threshold
       * @property {number} startMouseX - start x position of the click/touch
       * @property {number} startMouseY - start y position of the click/touch
       * @property {number} mouseX - current x position of the cursor
       * @property {number} mouseY - current y position of the cursor
       * @property {number[][]} mouseHistory - list of latest positions of the cursor, [time, x, y]
       * @property {number} pinchDist - distance between fingers when zooming
       * @property {PressHandler} keyHandler
       * @property {boolean} ctrlKeyDown - when the Ctrl key is pressed
       * @property {PSV.ClickData} dblclickData - temporary storage of click data between two clicks
       * @property {number} dblclickTimeout - timeout id for double click
       * @property {number} twofingersTimeout - timeout id for "two fingers" overlay
       * @property {number} ctrlZoomTimeout - timeout id for "ctrol zoom" overlay
       * @protected
       */

      _this.state = {
        moveThreshold: MOVE_THRESHOLD * SYSTEM.pixelRatio,
        keyboardEnabled: false,
        step: IDLE,
        mousedown: false,
        startMouseX: 0,
        startMouseY: 0,
        mouseX: 0,
        mouseY: 0,
        mouseHistory: [],
        pinchDist: 0,
        keyHandler: new PressHandler(),
        ctrlKeyDown: false,
        dblclickData: null,
        dblclickTimeout: null,
        longtouchTimeout: null,
        twofingersTimeout: null,
        ctrlZoomTimeout: null
      };
      /**
       * @summary Throttled wrapper of {@link PSV.Viewer#autoSize}
       * @type {Function}
       * @private
       */

      _this.__onResize = throttle(function () {
        return _this.psv.autoSize();
      }, 50);
      return _this;
    }
    /**
     * @summary Initializes event handlers
     * @protected
     */


    var _proto = EventsHandler.prototype;

    _proto.init = function init() {
      window.addEventListener('resize', this);
      window.addEventListener('keydown', this, {
        passive: false
      });
      window.addEventListener('keyup', this);
      this.psv.container.addEventListener('mousedown', this);
      window.addEventListener('mousemove', this, {
        passive: false
      });
      window.addEventListener('mouseup', this);
      this.psv.container.addEventListener('touchstart', this, {
        passive: false
      });
      window.addEventListener('touchmove', this, {
        passive: false
      });
      window.addEventListener('touchend', this, {
        passive: false
      });
      this.psv.container.addEventListener(SYSTEM.mouseWheelEvent, this, {
        passive: false
      });

      if (SYSTEM.fullscreenEvent) {
        document.addEventListener(SYSTEM.fullscreenEvent, this);
      }
    }
    /**
     * @override
     */
    ;

    _proto.destroy = function destroy() {
      window.removeEventListener('resize', this);
      window.removeEventListener('keydown', this);
      window.removeEventListener('keyup', this);
      this.psv.container.removeEventListener('mousedown', this);
      window.removeEventListener('mousemove', this);
      window.removeEventListener('mouseup', this);
      this.psv.container.removeEventListener('touchstart', this);
      window.removeEventListener('touchmove', this);
      window.removeEventListener('touchend', this);
      this.psv.container.removeEventListener(SYSTEM.mouseWheelEvent, this);

      if (SYSTEM.fullscreenEvent) {
        document.removeEventListener(SYSTEM.fullscreenEvent, this);
      }

      clearTimeout(this.state.dblclickTimeout);
      clearTimeout(this.state.longtouchTimeout);
      clearTimeout(this.state.twofingersTimeout);
      clearTimeout(this.state.ctrlZoomTimeout);
      delete this.state;

      _AbstractService.prototype.destroy.call(this);
    }
    /**
     * @summary Handles events
     * @param {Event} evt
     * @private
     */
    ;

    _proto.handleEvent = function handleEvent(evt) {
      /* eslint-disable */
      switch (evt.type) {
        // @formatter:off
        case 'resize':
          this.__onResize();

          break;

        case 'keydown':
          this.__onKeyDown(evt);

          break;

        case 'keyup':
          this.__onKeyUp();

          break;

        case 'mousemove':
          this.__onMouseMove(evt);

          break;

        case 'mouseup':
          this.__onMouseUp(evt);

          break;

        case 'touchmove':
          this.__onTouchMove(evt);

          break;

        case 'touchend':
          this.__onTouchEnd(evt);

          break;

        case SYSTEM.fullscreenEvent:
          this.__fullscreenToggled();

          break;
        // @formatter:on
      }
      /* eslint-enable */


      if (!getClosest(evt.target, '.psv--capture-event')) {
        /* eslint-disable */
        switch (evt.type) {
          // @formatter:off
          case 'mousedown':
            this.__onMouseDown(evt);

            break;

          case 'touchstart':
            this.__onTouchStart(evt);

            break;

          case SYSTEM.mouseWheelEvent:
            this.__onMouseWheel(evt);

            break;
          // @formatter:on
        }
        /* eslint-enable */

      }
    }
    /**
     * @summary Enables the keyboard controls
     * @protected
     */
    ;

    _proto.enableKeyboard = function enableKeyboard() {
      this.state.keyboardEnabled = true;
    }
    /**
     * @summary Disables the keyboard controls
     * @protected
     */
    ;

    _proto.disableKeyboard = function disableKeyboard() {
      this.state.keyboardEnabled = false;
    }
    /**
     * @summary Handles keyboard events
     * @param {KeyboardEvent} e
     * @private
     */
    ;

    _proto.__onKeyDown = function __onKeyDown(e) {
      if (this.config.mousewheelCtrlKey) {
        this.state.ctrlKeyDown = e.key === KEY_CODES.Control;

        if (this.state.ctrlKeyDown) {
          clearTimeout(this.state.ctrlZoomTimeout);
          this.psv.overlay.hide(IDS.CTRL_ZOOM);
        }
      }

      var e2 = this.psv.trigger(EVENTS.KEY_PRESS, e.key);

      if (e2.isDefaultPrevented()) {
        return;
      }

      if (!this.state.keyboardEnabled) {
        return;
      }

      var action = this.config.keyboard[e.key];

      if (action === ACTIONS.TOGGLE_AUTOROTATE) {
        this.psv.toggleAutorotate();
        e.preventDefault();
      } else if (action && !this.state.keyHandler.time) {
        if (action !== ACTIONS.ZOOM_IN && action !== ACTIONS.ZOOM_OUT) {
          this.psv.__stopAll();
        }
        /* eslint-disable */


        switch (action) {
          // @formatter:off
          case ACTIONS.ROTATE_LAT_UP:
            this.psv.dynamics.position.roll({
              latitude: false
            });
            break;

          case ACTIONS.ROTATE_LAT_DOWN:
            this.psv.dynamics.position.roll({
              latitude: true
            });
            break;

          case ACTIONS.ROTATE_LONG_RIGHT:
            this.psv.dynamics.position.roll({
              longitude: false
            });
            break;

          case ACTIONS.ROTATE_LONG_LEFT:
            this.psv.dynamics.position.roll({
              longitude: true
            });
            break;

          case ACTIONS.ZOOM_IN:
            this.psv.dynamics.zoom.roll(false);
            break;

          case ACTIONS.ZOOM_OUT:
            this.psv.dynamics.zoom.roll(true);
            break;
          // @formatter:on
        }
        /* eslint-enable */


        this.state.keyHandler.down();
        e.preventDefault();
      }
    }
    /**
     * @summary Handles keyboard events
     * @private
     */
    ;

    _proto.__onKeyUp = function __onKeyUp() {
      var _this2 = this;

      this.state.ctrlKeyDown = false;

      if (!this.state.keyboardEnabled) {
        return;
      }

      this.state.keyHandler.up(function () {
        _this2.psv.dynamics.position.stop();

        _this2.psv.dynamics.zoom.stop();

        _this2.psv.resetIdleTimer();
      });
    }
    /**
     * @summary Handles mouse down events
     * @param {MouseEvent} evt
     * @private
     */
    ;

    _proto.__onMouseDown = function __onMouseDown(evt) {
      this.state.mousedown = true;
      this.state.startMouseX = evt.clientX;
      this.state.startMouseY = evt.clientY;
    }
    /**
     * @summary Handles mouse up events
     * @param {MouseEvent} evt
     * @private
     */
    ;

    _proto.__onMouseUp = function __onMouseUp(evt) {
      if (this.state.mousedown || this.state.step === MOVING) {
        this.__stopMove(evt.clientX, evt.clientY, evt.target, evt.button === 2);
      }
    }
    /**
     * @summary Handles mouse move events
     * @param {MouseEvent} evt
     * @private
     */
    ;

    _proto.__onMouseMove = function __onMouseMove(evt) {
      if (this.config.mousemove && (this.state.mousedown || this.state.step === MOVING)) {
        evt.preventDefault();

        this.__move(evt.clientX, evt.clientY);
      }

      if (!isEmpty(this.prop.objectsObservers) && hasParent(evt.target, this.psv.container)) {
        var viewerPos = getPosition(this.psv.container);
        var viewerPoint = {
          x: evt.clientX - viewerPos.left,
          y: evt.clientY - viewerPos.top
        };
        var intersections = this.psv.dataHelper.getIntersections(viewerPoint);

        var emit = function emit(observer, key, type) {
          observer.listener.handleEvent(new CustomEvent(type, {
            detail: {
              originalEvent: evt,
              object: observer.object,
              data: observer.object.userData[key],
              viewerPoint: viewerPoint
            }
          }));
        };

        each(this.prop.objectsObservers, function (observer, key) {
          var intersection = intersections.find(function (i) {
            return i.object.userData[key];
          });

          if (intersection) {
            if (observer.object && intersection.object !== observer.object) {
              emit(observer, key, OBJECT_EVENTS.LEAVE_OBJECT);
              delete observer.object;
            }

            if (!observer.object) {
              observer.object = intersection.object;
              emit(observer, key, OBJECT_EVENTS.ENTER_OBJECT);
            } else {
              emit(observer, key, OBJECT_EVENTS.HOVER_OBJECT);
            }
          } else if (observer.object) {
            emit(observer, key, OBJECT_EVENTS.LEAVE_OBJECT);
            delete observer.object;
          }
        });
      }
    }
    /**
     * @summary Handles touch events
     * @param {TouchEvent} evt
     * @private
     */
    ;

    _proto.__onTouchStart = function __onTouchStart(evt) {
      var _this3 = this;

      if (evt.touches.length === 1) {
        this.state.mousedown = true;
        this.state.startMouseX = evt.touches[0].clientX;
        this.state.startMouseY = evt.touches[0].clientY;

        if (!this.prop.longtouchTimeout) {
          this.prop.longtouchTimeout = setTimeout(function () {
            var touch = evt.touches[0];

            _this3.__stopMove(touch.clientX, touch.clientY, touch.target, true);

            _this3.prop.longtouchTimeout = null;
          }, LONGTOUCH_DELAY);
        }
      } else if (evt.touches.length === 2) {
        this.state.mousedown = false;

        this.__cancelLongTouch();

        if (this.config.mousemove) {
          this.__cancelTwoFingersOverlay();

          this.__startMoveZoom(evt);

          evt.preventDefault();
        }
      }
    }
    /**
     * @summary Handles touch events
     * @param {TouchEvent} evt
     * @private
     */
    ;

    _proto.__onTouchEnd = function __onTouchEnd(evt) {
      this.__cancelLongTouch();

      if (this.state.mousedown || this.state.step === MOVING) {
        evt.preventDefault();

        this.__cancelTwoFingersOverlay();

        if (evt.touches.length === 1) {
          this.__stopMove(this.state.mouseX, this.state.mouseY);
        } else if (evt.touches.length === 0) {
          var touch = evt.changedTouches[0];

          this.__stopMove(touch.clientX, touch.clientY, touch.target);
        }
      }
    }
    /**
     * @summary Handles touch move events
     * @param {TouchEvent} evt
     * @private
     */
    ;

    _proto.__onTouchMove = function __onTouchMove(evt) {
      var _this4 = this;

      this.__cancelLongTouch();

      if (!this.config.mousemove) {
        return;
      }

      if (evt.touches.length === 1) {
        if (this.config.touchmoveTwoFingers) {
          if (this.state.mousedown && !this.prop.twofingersTimeout) {
            this.prop.twofingersTimeout = setTimeout(function () {
              _this4.psv.overlay.show({
                id: IDS.TWO_FINGERS,
                image: gestureIcon,
                text: _this4.config.lang.twoFingers
              });
            }, TWOFINGERSOVERLAY_DELAY);
          }
        } else if (this.state.mousedown || this.state.step === MOVING) {
          evt.preventDefault();
          var touch = evt.touches[0];

          this.__move(touch.clientX, touch.clientY);
        }
      } else {
        this.__moveZoom(evt);

        this.__cancelTwoFingersOverlay();
      }
    }
    /**
     * @summary Cancel the long touch timer if any
     * @private
     */
    ;

    _proto.__cancelLongTouch = function __cancelLongTouch() {
      if (this.prop.longtouchTimeout) {
        clearTimeout(this.prop.longtouchTimeout);
        this.prop.longtouchTimeout = null;
      }
    }
    /**
     * @summary Cancel the two fingers overlay timer if any
     * @private
     */
    ;

    _proto.__cancelTwoFingersOverlay = function __cancelTwoFingersOverlay() {
      if (this.config.touchmoveTwoFingers) {
        if (this.prop.twofingersTimeout) {
          clearTimeout(this.prop.twofingersTimeout);
          this.prop.twofingersTimeout = null;
        }

        this.psv.overlay.hide(IDS.TWO_FINGERS);
      }
    }
    /**
     * @summary Handles mouse wheel events
     * @param {WheelEvent} evt
     * @private
     */
    ;

    _proto.__onMouseWheel = function __onMouseWheel(evt) {
      var _this5 = this;

      if (!this.config.mousewheel) {
        return;
      }

      if (this.config.mousewheelCtrlKey && !this.state.ctrlKeyDown) {
        this.psv.overlay.show({
          id: IDS.CTRL_ZOOM,
          image: mousewheelIcon,
          text: this.config.lang.ctrlZoom
        });
        clearTimeout(this.state.ctrlZoomTimeout);
        this.state.ctrlZoomTimeout = setTimeout(function () {
          return _this5.psv.overlay.hide(IDS.CTRL_ZOOM);
        }, CTRLZOOM_TIMEOUT);
        return;
      }

      evt.preventDefault();
      evt.stopPropagation();
      var delta = normalizeWheel(evt).spinY * 5 * this.config.zoomSpeed;

      if (delta !== 0) {
        this.psv.dynamics.zoom.step(-delta, 5);
      }
    }
    /**
     * @summary Handles fullscreen events
     * @param {boolean} [force] force state
     * @fires PSV.fullscreen-updated
     * @package
     */
    ;

    _proto.__fullscreenToggled = function __fullscreenToggled(force) {
      this.prop.fullscreen = force !== undefined ? force : isFullscreenEnabled(this.psv.container);

      if (this.config.keyboard) {
        if (this.prop.fullscreen) {
          this.psv.startKeyboardControl();
        } else {
          this.psv.stopKeyboardControl();
        }
      }

      this.psv.trigger(EVENTS.FULLSCREEN_UPDATED, this.prop.fullscreen);
    }
    /**
     * @summary Resets all state variables
     * @private
     */
    ;

    _proto.__resetMove = function __resetMove() {
      this.state.step = IDLE;
      this.state.mousedown = false;
      this.state.mouseX = 0;
      this.state.mouseY = 0;
      this.state.startMouseX = 0;
      this.state.startMouseY = 0;
      this.state.mouseHistory.length = 0;
    }
    /**
     * @summary Initializes the combines move and zoom
     * @param {TouchEvent} evt
     * @private
     */
    ;

    _proto.__startMoveZoom = function __startMoveZoom(evt) {
      this.psv.__stopAll();

      this.__resetMove();

      var p1 = {
        x: evt.touches[0].clientX,
        y: evt.touches[0].clientY
      };
      var p2 = {
        x: evt.touches[1].clientX,
        y: evt.touches[1].clientY
      };
      this.state.step = MOVING;
      this.state.pinchDist = distance(p1, p2);
      this.state.mouseX = (p1.x + p2.x) / 2;
      this.state.mouseY = (p1.y + p2.y) / 2;

      this.__logMouseMove(this.state.mouseX, this.state.mouseY);
    }
    /**
     * @summary Stops the movement
     * @description If the move threshold was not reached a click event is triggered, otherwise an animation is launched to simulate inertia
     * @param {int} clientX
     * @param {int} clientY
     * @param {EventTarget} [target]
     * @param {boolean} [rightclick=false]
     * @private
     */
    ;

    _proto.__stopMove = function __stopMove(clientX, clientY, target, rightclick) {
      if (target === void 0) {
        target = null;
      }

      if (rightclick === void 0) {
        rightclick = false;
      }

      if (this.state.step === MOVING) {
        if (this.config.moveInertia) {
          this.__logMouseMove(clientX, clientY);

          this.__stopMoveInertia(clientX, clientY);
        } else {
          this.__resetMove();

          this.psv.resetIdleTimer();
        }
      } else if (this.state.mousedown) {
        this.psv.stopAnimation();

        this.__click(clientX, clientY, target, rightclick);

        this.__resetMove();

        this.psv.resetIdleTimer();
      }
    }
    /**
     * @summary Performs an animation to simulate inertia when the movement stops
     * @param {int} clientX
     * @param {int} clientY
     * @private
     */
    ;

    _proto.__stopMoveInertia = function __stopMoveInertia(clientX, clientY) {
      var _this6 = this;

      // get direction at end of movement
      var curve = new three.SplineCurve(this.state.mouseHistory.map(function (_ref) {
        var x = _ref[1],
            y = _ref[2];
        return new three.Vector2(x, y);
      }));
      var direction = curve.getTangent(1); // average speed

      var speed = this.state.mouseHistory.slice(1).reduce(function (_ref2, curr) {
        var total = _ref2.total,
            prev = _ref2.prev;
        return {
          total: total + distance({
            x: prev[1],
            y: prev[2]
          }, {
            x: curr[1],
            y: curr[2]
          }) / (curr[0] - prev[0]),
          prev: curr
        };
      }, {
        total: 0,
        prev: this.state.mouseHistory[0]
      }).total / this.state.mouseHistory.length;

      if (!speed) {
        this.__resetMove();

        this.psv.resetIdleTimer();
        return;
      }

      this.state.step = INERTIA;
      var currentClientX = clientX;
      var currentClientY = clientY;
      this.prop.animationPromise = new Animation({
        properties: {
          speed: {
            start: speed,
            end: 0
          }
        },
        duration: 1000,
        easing: 'outQuad',
        onTick: function onTick(properties) {
          // 3 is a magic number
          currentClientX += properties.speed * direction.x * 3 * SYSTEM.pixelRatio;
          currentClientY += properties.speed * direction.y * 3 * SYSTEM.pixelRatio;

          _this6.__applyMove(currentClientX, currentClientY);
        }
      });
      this.prop.animationPromise.then(function (done) {
        _this6.prop.animationPromise = null;

        if (done) {
          _this6.__resetMove();

          _this6.psv.resetIdleTimer();
        }
      });
    }
    /**
     * @summary Triggers an event with all coordinates when a simple click is performed
     * @param {int} clientX
     * @param {int} clientY
     * @param {EventTarget} target
     * @param {boolean} [rightclick=false]
     * @fires PSV.click
     * @fires PSV.dblclick
     * @private
     */
    ;

    _proto.__click = function __click(clientX, clientY, target, rightclick) {
      var _this7 = this;

      if (rightclick === void 0) {
        rightclick = false;
      }

      var boundingRect = this.psv.container.getBoundingClientRect();
      /**
       * @type {PSV.ClickData}
       */

      var data = {
        rightclick: rightclick,
        target: target,
        clientX: clientX,
        clientY: clientY,
        viewerX: clientX - boundingRect.left,
        viewerY: clientY - boundingRect.top
      };
      var intersections = this.psv.dataHelper.getIntersections({
        x: data.viewerX,
        y: data.viewerY
      });
      var sphereIntersection = intersections.find(function (i) {
        return i.object.userData[MESH_USER_DATA];
      });

      if (sphereIntersection) {
        var sphericalCoords = this.psv.dataHelper.vector3ToSphericalCoords(sphereIntersection.point);
        data.longitude = sphericalCoords.longitude;
        data.latitude = sphericalCoords.latitude;
        data.objects = intersections.map(function (i) {
          return i.object;
        }).filter(function (o) {
          return !o.userData[MESH_USER_DATA];
        });

        try {
          var textureCoords = this.psv.dataHelper.sphericalCoordsToTextureCoords(data);
          data.textureX = textureCoords.x;
          data.textureY = textureCoords.y;
        } catch (e) {
          data.textureX = NaN;
          data.textureY = NaN;
        }

        if (!this.state.dblclickTimeout) {
          this.psv.trigger(EVENTS.CLICK, data);
          this.state.dblclickData = clone(data);
          this.state.dblclickTimeout = setTimeout(function () {
            _this7.state.dblclickTimeout = null;
            _this7.state.dblclickData = null;
          }, DBLCLICK_DELAY);
        } else {
          if (Math.abs(this.state.dblclickData.clientX - data.clientX) < this.state.moveThreshold && Math.abs(this.state.dblclickData.clientY - data.clientY) < this.state.moveThreshold) {
            this.psv.trigger(EVENTS.DOUBLE_CLICK, this.state.dblclickData);
          }

          clearTimeout(this.state.dblclickTimeout);
          this.state.dblclickTimeout = null;
          this.state.dblclickData = null;
        }
      }
    }
    /**
     * @summary Starts moving when crossing moveThreshold and performs movement
     * @param {int} clientX
     * @param {int} clientY
     * @private
     */
    ;

    _proto.__move = function __move(clientX, clientY) {
      if (this.state.mousedown && (Math.abs(clientX - this.state.startMouseX) >= this.state.moveThreshold || Math.abs(clientY - this.state.startMouseY) >= this.state.moveThreshold)) {
        this.psv.__stopAll();

        this.__resetMove();

        this.state.step = MOVING;
        this.state.mouseX = clientX;
        this.state.mouseY = clientY;

        this.__logMouseMove(clientX, clientY);
      } else if (this.state.step === MOVING) {
        this.__applyMove(clientX, clientY);

        this.__logMouseMove(clientX, clientY);
      }
    }
    /**
     * @summary Raw method for movement, called from mouse event and move inertia
     * @param {int} clientX
     * @param {int} clientY
     * @private
     */
    ;

    _proto.__applyMove = function __applyMove(clientX, clientY) {
      var rotation = {
        longitude: (clientX - this.state.mouseX) / this.prop.size.width * this.config.moveSpeed * three.MathUtils.degToRad(this.prop.littlePlanet ? 90 : this.prop.hFov),
        latitude: (clientY - this.state.mouseY) / this.prop.size.height * this.config.moveSpeed * three.MathUtils.degToRad(this.prop.littlePlanet ? 90 : this.prop.vFov)
      };
      var currentPosition = this.psv.getPosition();
      this.psv.rotate({
        longitude: currentPosition.longitude - rotation.longitude,
        latitude: currentPosition.latitude + rotation.latitude
      });
      this.state.mouseX = clientX;
      this.state.mouseY = clientY;
    }
    /**
     * @summary Perfoms combined move and zoom
     * @param {TouchEvent} evt
     * @private
     */
    ;

    _proto.__moveZoom = function __moveZoom(evt) {
      if (this.state.step === MOVING) {
        evt.preventDefault();
        var p1 = {
          x: evt.touches[0].clientX,
          y: evt.touches[0].clientY
        };
        var p2 = {
          x: evt.touches[1].clientX,
          y: evt.touches[1].clientY
        };
        var p = distance(p1, p2);
        var delta = (p - this.state.pinchDist) / SYSTEM.pixelRatio * this.config.zoomSpeed;
        this.psv.zoom(this.psv.getZoomLevel() + delta);

        this.__move((p1.x + p2.x) / 2, (p1.y + p2.y) / 2);

        this.state.pinchDist = p;
      }
    }
    /**
     * @summary Stores each mouse position during a mouse move
     * @description Positions older than "INERTIA_WINDOW" are removed<br>
     *     Positions before a pause of "INERTIA_WINDOW" / 10 are removed
     * @param {int} clientX
     * @param {int} clientY
     * @private
     */
    ;

    _proto.__logMouseMove = function __logMouseMove(clientX, clientY) {
      var now = Date.now();
      var last = this.state.mouseHistory.length ? this.state.mouseHistory[this.state.mouseHistory.length - 1] : [0, -1, -1]; // avoid duplicates

      if (last[1] === clientX && last[2] === clientY) {
        last[0] = now;
      } else if (now === last[0]) {
        last[1] = clientX;
        last[2] = clientY;
      } else {
        this.state.mouseHistory.push([now, clientX, clientY]);
      }

      var previous = null;

      for (var i = 0; i < this.state.mouseHistory.length;) {
        if (this.state.mouseHistory[i][0] < now - INERTIA_WINDOW) {
          this.state.mouseHistory.splice(i, 1);
        } else if (previous && this.state.mouseHistory[i][0] - previous > INERTIA_WINDOW / 10) {
          this.state.mouseHistory.splice(0, i);
          i = 0;
          previous = this.state.mouseHistory[i][0];
        } else {
          previous = this.state.mouseHistory[i][0];
          i++;
        }
      }
    };

    return EventsHandler;
  }(AbstractService);

  /**
   * @summary Viewer and renderer
   * @extends PSV.services.AbstractService
   * @memberof PSV.services
   */

  var Renderer = /*#__PURE__*/function (_AbstractService) {
    _inheritsLoose(Renderer, _AbstractService);

    /**
     * @param {PSV.Viewer} psv
     */
    function Renderer(psv) {
      var _this$mesh$userData;

      var _this;

      _this = _AbstractService.call(this, psv) || this;
      /**
       * @member {external:THREE.WebGLRenderer}
       * @readonly
       * @protected
       */

      _this.renderer = new three.WebGLRenderer({
        alpha: true,
        antialias: true
      });

      _this.renderer.setPixelRatio(SYSTEM.pixelRatio);

      _this.renderer.domElement.className = 'psv-canvas';
      /**
       * @member {external:THREE.Scene}
       * @readonly
       * @protected
       */

      _this.scene = new three.Scene();
      /**
       * @member {external:THREE.PerspectiveCamera}
       * @readonly
       * @protected
       */

      _this.camera = new three.PerspectiveCamera(50, 16 / 9, 0.1, 2 * SPHERE_RADIUS);
      /**
       * @member {external:THREE.Mesh}
       * @readonly
       * @protected
       */

      _this.mesh = _this.psv.adapter.createMesh();
      _this.mesh.userData = (_this$mesh$userData = {}, _this$mesh$userData[MESH_USER_DATA] = true, _this$mesh$userData);
      /**
       * @member {external:THREE.Group}
       * @readonly
       * @private
       */

      _this.meshContainer = new three.Group();

      _this.meshContainer.add(_this.mesh);

      _this.scene.add(_this.meshContainer);
      /**
       * @member {external:THREE.Raycaster}
       * @readonly
       * @protected
       */


      _this.raycaster = new three.Raycaster();
      /**
       * @member {number}
       * @private
       */

      _this.timestamp = null;
      /**
       * @member {boolean}
       * @private
       */

      _this.ready = false;
      /**
       * @member {HTMLElement}
       * @readonly
       * @package
       */

      _this.canvasContainer = document.createElement('div');
      _this.canvasContainer.className = 'psv-canvas-container';
      _this.canvasContainer.style.background = _this.psv.config.canvasBackground;
      _this.canvasContainer.style.cursor = _this.psv.config.mousemove ? 'move' : 'default';

      _this.canvasContainer.appendChild(_this.renderer.domElement);

      _this.psv.container.appendChild(_this.canvasContainer);

      psv.on(EVENTS.SIZE_UPDATED, _assertThisInitialized(_this));
      psv.on(EVENTS.ZOOM_UPDATED, _assertThisInitialized(_this));
      psv.on(EVENTS.POSITION_UPDATED, _assertThisInitialized(_this));
      psv.on(EVENTS.CONFIG_CHANGED, _assertThisInitialized(_this));

      _this.hide();

      return _this;
    }
    /**
     * @override
     */


    var _proto = Renderer.prototype;

    _proto.destroy = function destroy() {
      // cancel render loop
      this.renderer.setAnimationLoop(null); // destroy ThreeJS view

      this.__cleanTHREEScene(this.scene); // remove container


      this.psv.container.removeChild(this.canvasContainer);
      delete this.canvasContainer;
      delete this.renderer;
      delete this.scene;
      delete this.camera;
      delete this.mesh;
      delete this.meshContainer;
      delete this.raycaster;

      _AbstractService.prototype.destroy.call(this);
    }
    /**
     * @summary Handles events
     * @param {Event} evt
     * @private
     */
    ;

    _proto.handleEvent = function handleEvent(evt) {
      /* eslint-disable */
      switch (evt.type) {
        // @formatter:off
        case EVENTS.SIZE_UPDATED:
          this.__onSizeUpdated();

          break;

        case EVENTS.ZOOM_UPDATED:
          this.__onZoomUpdated();

          break;

        case EVENTS.POSITION_UPDATED:
          this.__onPositionUpdated();

          break;

        case EVENTS.CONFIG_CHANGED:
          if (evt.args[0].includes('fisheye')) {
            this.__onPositionUpdated();
          }

          if (evt.args[0].includes('mousemove')) {
            this.canvasContainer.style.cursor = this.psv.config.mousemove ? 'move' : 'default';
          }

          break;
        // @formatter:on
      }
      /* eslint-enable */

    }
    /**
     * @summary Hides the viewer
     */
    ;

    _proto.hide = function hide() {
      this.canvasContainer.style.opacity = 0;
    }
    /**
     * @summary Shows the viewer
     */
    ;

    _proto.show = function show() {
      this.canvasContainer.style.opacity = 1;
    }
    /**
     * @summary Updates the size of the renderer and the aspect of the camera
     * @private
     */
    ;

    _proto.__onSizeUpdated = function __onSizeUpdated() {
      this.renderer.setSize(this.prop.size.width, this.prop.size.height);
      this.camera.aspect = this.prop.aspect;
      this.camera.updateProjectionMatrix();
      this.prop.needsUpdate = true;
    }
    /**
     * @summary Updates the fov of the camera
     * @private
     */
    ;

    _proto.__onZoomUpdated = function __onZoomUpdated() {
      this.camera.fov = this.prop.vFov;
      this.camera.updateProjectionMatrix();
      this.prop.needsUpdate = true;
    }
    /**
     * @summary Updates the position of the camera
     * @private
     */
    ;

    _proto.__onPositionUpdated = function __onPositionUpdated() {
      this.camera.position.set(0, 0, 0);
      this.camera.lookAt(this.prop.direction);

      if (this.config.fisheye) {
        this.camera.position.copy(this.prop.direction).multiplyScalar(this.config.fisheye / 2).negate();
      }

      this.prop.needsUpdate = true;
    }
    /**
     * @summary Main event loop, calls {@link render} if `prop.needsUpdate` is true
     * @param {number} timestamp
     * @fires PSV.before-render
     * @private
     */
    ;

    _proto.__renderLoop = function __renderLoop(timestamp) {
      var elapsed = this.timestamp !== null ? timestamp - this.timestamp : 0;
      this.timestamp = timestamp;
      this.psv.trigger(EVENTS.BEFORE_RENDER, timestamp, elapsed);
      each(this.psv.dynamics, function (d) {
        return d.update(elapsed);
      });

      if (this.prop.idleTime > 0 && timestamp - this.prop.idleTime > this.config.autorotateDelay) {
        this.psv.startAutorotate();
      }

      if (this.prop.needsUpdate) {
        this.render();
        this.prop.needsUpdate = false;
      }
    }
    /**
     * @summary Performs a render
     * @description Do not call this method directly, instead call
     * {@link PSV.Viewer#needsUpdate} on {@link PSV.event:before-render}.
     * @fires PSV.render
     */
    ;

    _proto.render = function render() {
      this.renderer.render(this.scene, this.camera);
      this.psv.trigger(EVENTS.RENDER);
    }
    /**
     * @summary Applies the texture to the scene, creates the scene if needed
     * @param {PSV.TextureData} textureData
     * @fires PSV.panorama-loaded
     * @package
     */
    ;

    _proto.setTexture = function setTexture(textureData) {
      var _this2 = this;

      this.prop.panoData = textureData.panoData;
      this.psv.adapter.setTexture(this.mesh, textureData);

      if (!this.ready) {
        this.renderer.setAnimationLoop(function (t) {
          return _this2.__renderLoop(t);
        });
        this.ready = true;
      }

      this.psv.needsUpdate();
      this.psv.trigger(EVENTS.PANORAMA_LOADED, textureData);
    }
    /**
     * @summary Applies the overlay to the mesh
     * @param {PSV.TextureData} textureData
     * @param {number} opacity
     * @package
     */
    ;

    _proto.setOverlay = function setOverlay(textureData, opacity) {
      this.psv.adapter.setOverlay(this.mesh, textureData, opacity);
      this.psv.needsUpdate();
    }
    /**
     * @summary Apply a panorama data pose to a Mesh
     * @param {PSV.PanoData} [panoData]
     * @param {external:THREE.Mesh} [mesh=this.mesh]
     * @package
     */
    ;

    _proto.setPanoramaPose = function setPanoramaPose(panoData, mesh) {
      if (mesh === void 0) {
        mesh = this.mesh;
      }

      // By Google documentation the angles are applied on the camera in order : heading, pitch, roll
      // here we apply the reverse transformation on the sphere
      var cleanCorrection = this.psv.dataHelper.cleanPanoramaPose(panoData);
      mesh.rotation.set(-cleanCorrection.tilt, -cleanCorrection.pan, -cleanCorrection.roll, 'ZXY');
    }
    /**
     * @summary Apply a SphereCorrection to a Mesh
     * @param {PSV.SphereCorrection} [sphereCorrection]
     * @param {external:THREE.Mesh} [mesh=this.meshContainer]
     * @package
     */
    ;

    _proto.setSphereCorrection = function setSphereCorrection(sphereCorrection, mesh) {
      if (mesh === void 0) {
        mesh = this.meshContainer;
      }

      var cleanCorrection = this.psv.dataHelper.cleanSphereCorrection(sphereCorrection);
      mesh.rotation.set(cleanCorrection.tilt, cleanCorrection.pan, cleanCorrection.roll, 'ZXY');
    }
    /**
     * @summary Performs transition between the current and a new texture
     * @param {PSV.TextureData} textureData
     * @param {PSV.PanoramaOptions} options
     * @returns {PSV.utils.Animation}
     * @package
     */
    ;

    _proto.transition = function transition(textureData, options) {
      var _this3 = this;

      var positionProvided = isExtendedPosition(options);
      var zoomProvided = ('zoom' in options); // create temp group and new mesh, half size to be in "front" of the first one

      var group = new three.Group();
      var mesh = this.psv.adapter.createMesh(0.5);
      this.psv.adapter.setTexture(mesh, textureData, true);
      this.psv.adapter.setTextureOpacity(mesh, 0);
      this.setPanoramaPose(textureData.panoData, mesh);
      this.setSphereCorrection(options.sphereCorrection, group); // rotate the new sphere to make the target position face the camera

      if (positionProvided) {
        var cleanPosition = this.psv.dataHelper.cleanPosition(options);
        var currentPosition = this.psv.getPosition(); // Longitude rotation along the vertical axis

        var verticalAxis = new three.Vector3(0, 1, 0);
        group.rotateOnWorldAxis(verticalAxis, cleanPosition.longitude - currentPosition.longitude); // Latitude rotation along the camera horizontal axis

        var horizontalAxis = new three.Vector3(0, 1, 0).cross(this.camera.getWorldDirection(new three.Vector3())).normalize();
        group.rotateOnWorldAxis(horizontalAxis, cleanPosition.latitude - currentPosition.latitude);
      }

      group.add(mesh);
      this.scene.add(group);
      var animation = new Animation({
        properties: {
          opacity: {
            start: 0.0,
            end: 1.0
          },
          zoom: zoomProvided ? {
            start: this.psv.getZoomLevel(),
            end: options.zoom
          } : undefined
        },
        duration: options.transition,
        easing: 'outCubic',
        onTick: function onTick(properties) {
          _this3.psv.adapter.setTextureOpacity(mesh, properties.opacity);

          _this3.psv.adapter.setTextureOpacity(_this3.mesh, 1 - properties.opacity);

          if (zoomProvided) {
            _this3.psv.zoom(properties.zoom);
          }

          _this3.psv.needsUpdate();
        }
      });
      animation.then(function (completed) {
        if (completed) {
          // remove temp sphere and transfer the texture to the main mesh
          _this3.setTexture(textureData);

          _this3.psv.adapter.setTextureOpacity(_this3.mesh, 1);

          _this3.setPanoramaPose(textureData.panoData);

          _this3.setSphereCorrection(options.sphereCorrection); // actually rotate the camera


          if (positionProvided) {
            _this3.psv.rotate(options);
          }
        } else {
          _this3.psv.adapter.disposeTexture(textureData);
        }

        _this3.scene.remove(group);

        mesh.geometry.dispose();
        mesh.geometry = null;
      });
      return animation;
    }
    /**
     * @summary Calls `dispose` on all objects and textures
     * @param {external:THREE.Object3D} object
     * @private
     */
    ;

    _proto.__cleanTHREEScene = function __cleanTHREEScene(object) {
      var _this4 = this;

      object.traverse(function (item) {
        if (item.geometry) {
          item.geometry.dispose();
        }

        if (item.material) {
          if (Array.isArray(item.material)) {
            item.material.forEach(function (material) {
              if (material.map) {
                material.map.dispose();
              }

              material.dispose();
            });
          } else {
            if (item.material.map) {
              item.material.map.dispose();
            }

            item.material.dispose();
          }
        }

        if (item.dispose && !(item instanceof three.Scene)) {
          item.dispose();
        }

        if (item !== object) {
          _this4.__cleanTHREEScene(item);
        }
      });
    };

    return Renderer;
  }(AbstractService);

  /**
   * @summary Texture loader
   * @extends PSV.services.AbstractService
   * @memberof PSV.services
   */

  var TextureLoader = /*#__PURE__*/function (_AbstractService) {
    _inheritsLoose(TextureLoader, _AbstractService);

    /**
     * @param {PSV.Viewer} psv
     */
    function TextureLoader(psv) {
      var _this;

      _this = _AbstractService.call(this, psv) || this;
      /**
       * @summary THREE file loader
       * @type {external:THREE:FileLoader}
       * @private
       */

      _this.loader = new three.FileLoader();

      _this.loader.setResponseType('blob');

      if (_this.config.withCredentials) {
        _this.loader.setWithCredentials(true);
      }

      if (_this.config.requestHeaders && typeof _this.config.requestHeaders === 'object') {
        _this.loader.setRequestHeader(_this.config.requestHeaders);
      }

      return _this;
    }
    /**
     * @override
     */


    var _proto = TextureLoader.prototype;

    _proto.destroy = function destroy() {
      this.abortLoading();

      _AbstractService.prototype.destroy.call(this);
    }
    /**
     * @summary Cancels current HTTP requests
     * @package
     */
    ;

    _proto.abortLoading = function abortLoading() {// noop implementation waiting for https://github.com/mrdoob/three.js/pull/23070
    }
    /**
     * @summary Loads a Blob with FileLoader
     * @param {string} url
     * @param {function(number)} [onProgress]
     * @returns {Promise<Blob>}
     */
    ;

    _proto.loadFile = function loadFile(url, onProgress) {
      var _this2 = this;

      if (this.config.requestHeaders && typeof this.config.requestHeaders === 'function') {
        this.loader.setRequestHeader(this.config.requestHeaders(url));
      }

      return new Promise(function (resolve, reject) {
        var progress = 0;
        onProgress == null ? void 0 : onProgress(progress);

        _this2.loader.load(url, function (result) {
          progress = 100;
          onProgress == null ? void 0 : onProgress(progress);
          resolve(result);
        }, function (e) {
          if (e.lengthComputable) {
            var newProgress = e.loaded / e.total * 100;

            if (newProgress > progress) {
              progress = newProgress;
              onProgress == null ? void 0 : onProgress(progress);
            }
          }
        }, function (err) {
          reject(err);
        });
      });
    }
    /**
     * @summary Loads an Image using FileLoader to have progress events
     * @param {string} url
     * @param {function(number)} [onProgress]
     * @returns {Promise<HTMLImageElement>}
     */
    ;

    _proto.loadImage = function loadImage(url, onProgress) {
      return this.loadFile(url, onProgress).then(function (result) {
        return new Promise(function (resolve, reject) {
          var img = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');

          img.onload = function () {
            URL.revokeObjectURL(img.src);
            resolve(img);
          };

          img.onerror = reject;
          img.src = URL.createObjectURL(result);
        });
      });
    }
    /**
     * @summary Preload a panorama file without displaying it
     * @param {*} panorama
     * @returns {Promise}
     */
    ;

    _proto.preloadPanorama = function preloadPanorama(panorama) {
      if (this.psv.adapter.supportsPreload(panorama)) {
        return this.psv.adapter.loadTexture(panorama);
      } else {
        return Promise.resolve();
      }
    };

    return TextureLoader;
  }(AbstractService);

  var STATE = {
    NONE: 0,
    SHOWING: 1,
    HIDING: 2,
    READY: 3
  };
  /**
   * @typedef {Object} PSV.components.Tooltip.Position
   * @summary Object defining the tooltip position
   * @property {number} top - Position of the tip of the arrow of the tooltip, in pixels
   * @property {number} left - Position of the tip of the arrow of the tooltip, in pixels
   * @property {string|string[]} [position='top center'] - Tooltip position toward it's arrow tip.
   *           Accepted values are combinations of `top`, `center`, `bottom` and `left`, `center`, `right`
   * @property {Object} [box] - Used when displaying a tooltip on a marker
   * @property {number} [box.width=0]
   * @property {number} [box.height=0]
   */

  /**
   * @typedef {PSV.components.Tooltip.Position} PSV.components.Tooltip.Config
   * @summary Object defining the tooltip configuration
   * @property {string} content - HTML content of the tooltip
   * @property {string} [className] - Additional CSS class added to the tooltip
   * @property {*} [data] - Userdata associated to the tooltip
   */

  /**
   * @summary Tooltip component
   * @description Never instanciate tooltips directly use {@link PSV.services.TooltipRenderer} instead
   * @extends PSV.components.AbstractComponent
   * @memberof PSV.components
   */

  var Tooltip = /*#__PURE__*/function (_AbstractComponent) {
    _inheritsLoose(Tooltip, _AbstractComponent);

    /**
     * @param {PSV.Viewer} psv
     * @param {{arrow: number, border: number}} size
     */
    function Tooltip(psv, size) {
      var _this;

      _this = _AbstractComponent.call(this, psv, 'psv-tooltip') || this;
      /**
       * @override
       * @property {number} arrow
       * @property {number} border
       * @property {number} width
       * @property {number} height
       * @property {string} pos
       * @property {string} state
       * @property {*} data
       */

      _this.prop = _extends({}, _this.prop, size, {
        state: STATE.NONE,
        width: 0,
        height: 0,
        pos: '',
        config: null,
        data: null
      });
      /**
       * Tooltip content
       * @member {HTMLElement}
       * @readonly
       * @private
       */

      _this.content = document.createElement('div');
      _this.content.className = 'psv-tooltip-content';

      _this.container.appendChild(_this.content);
      /**
       * Tooltip arrow
       * @member {HTMLElement}
       * @readonly
       * @package
       */


      _this.arrow = document.createElement('div');
      _this.arrow.className = 'psv-tooltip-arrow';

      _this.container.appendChild(_this.arrow);

      _this.container.addEventListener('transitionend', _assertThisInitialized(_this));

      _this.container.style.top = '-1000px';
      _this.container.style.left = '-1000px';
      return _this;
    }
    /**
     * @override
     */


    var _proto = Tooltip.prototype;

    _proto.destroy = function destroy() {
      delete this.arrow;
      delete this.content;

      _AbstractComponent.prototype.destroy.call(this);
    }
    /**
     * @summary Handles events
     * @param {Event} e
     * @private
     */
    ;

    _proto.handleEvent = function handleEvent(e) {
      /* eslint-disable */
      switch (e.type) {
        // @formatter:off
        case 'transitionend':
          this.__onTransitionEnd(e);

          break;
        // @formatter:on
      }
      /* eslint-enable */

    }
    /**
     * @override
     * @summary This method is not supported
     * @throws {PSV.PSVError} always
     */
    ;

    _proto.toggle = function toggle() {
      throw new PSVError('Tooltip cannot be toggled');
    }
    /**
     * @summary Displays the tooltip on the viewer
     * Do not call this method directly, use {@link PSV.services.TooltipRenderer} instead.
     * @param {PSV.components.Tooltip.Config} config
     *
     * @fires PSV.show-tooltip
     * @throws {PSV.PSVError} when the configuration is incorrect
     *
     * @package
     */
    ;

    _proto.show = function show(config) {
      if (this.prop.state !== STATE.NONE) {
        throw new PSVError('Initialized tooltip cannot be re-initialized');
      }

      if (config.className) {
        addClasses(this.container, config.className);
      }

      this.content.innerHTML = config.content;
      var rect = this.container.getBoundingClientRect();
      this.prop.width = rect.right - rect.left;
      this.prop.height = rect.bottom - rect.top;
      this.prop.state = STATE.READY;
      this.move(config);
      this.prop.data = config.data;
      this.prop.state = STATE.SHOWING;
      this.psv.trigger(EVENTS.SHOW_TOOLTIP, this.prop.data, this);

      this.__waitImages();
    }
    /**
     * @summary Moves the tooltip to a new position
     * @param {PSV.components.Tooltip.Position} config
     *
     * @throws {PSV.PSVError} when the configuration is incorrect
     */
    ;

    _proto.move = function move(config) {
      if (this.prop.state !== STATE.SHOWING && this.prop.state !== STATE.READY) {
        throw new PSVError('Uninitialized tooltip cannot be moved');
      }

      if (!config.box) {
        config.box = {
          width: 0,
          height: 0
        };
      }

      this.config = config;
      var t = this.container;
      var a = this.arrow; // compute size

      var style = {
        posClass: cleanPosition(config.position, {
          allowCenter: false,
          cssOrder: false
        }) || ['top', 'center'],
        width: this.prop.width,
        height: this.prop.height,
        top: 0,
        left: 0,
        arrowTop: 0,
        arrowLeft: 0
      }; // set initial position

      this.__computeTooltipPosition(style, config); // correct position if overflow


      var swapY = null;
      var swapX = null;

      if (style.top < 0) {
        swapY = 'bottom';
      } else if (style.top + style.height > this.psv.prop.size.height) {
        swapY = 'top';
      }

      if (style.left < 0) {
        swapX = 'right';
      } else if (style.left + style.width > this.psv.prop.size.width) {
        swapX = 'left';
      }

      if (swapX || swapY) {
        var ordered = positionIsOrdered(style.posClass);

        if (swapY) {
          style.posClass[ordered ? 0 : 1] = swapY;
        }

        if (swapX) {
          style.posClass[ordered ? 1 : 0] = swapX;
        }

        this.__computeTooltipPosition(style, config);
      } // apply position


      t.style.top = style.top + 'px';
      t.style.left = style.left + 'px';
      a.style.top = style.arrowTop + 'px';
      a.style.left = style.arrowLeft + 'px';
      var newPos = style.posClass.join('-');

      if (newPos !== this.prop.pos) {
        t.classList.remove("psv-tooltip--" + this.prop.pos);
        this.prop.pos = newPos;
        t.classList.add("psv-tooltip--" + this.prop.pos);
      }
    }
    /**
     * @summary Hides the tooltip
     * @fires PSV.hide-tooltip
     */
    ;

    _proto.hide = function hide() {
      this.container.classList.remove('psv-tooltip--visible');
      this.prop.state = STATE.HIDING;
      this.psv.trigger(EVENTS.HIDE_TOOLTIP, this.prop.data);
    }
    /**
     * @summary Finalize transition
     * @param {TransitionEvent} e
     * @private
     */
    ;

    _proto.__onTransitionEnd = function __onTransitionEnd(e) {
      if (e.propertyName === 'transform') {
        switch (this.prop.state) {
          case STATE.SHOWING:
            this.container.classList.add('psv-tooltip--visible');
            this.prop.state = STATE.READY;
            break;

          case STATE.HIDING:
            this.prop.state = STATE.NONE;
            this.destroy();
            break;

        }
      }
    }
    /**
     * @summary Computes the position of the tooltip and its arrow
     * @param {Object} style
     * @param {Object} config
     * @private
     */
    ;

    _proto.__computeTooltipPosition = function __computeTooltipPosition(style, config) {
      var arrow = this.prop.arrow;
      var top = config.top;
      var height = style.height;
      var left = config.left;
      var width = style.width;
      var offsetSide = arrow + this.prop.border;
      var offsetX = config.box.width / 2 + arrow * 2;
      var offsetY = config.box.height / 2 + arrow * 2;

      switch (style.posClass.join('-')) {
        case 'top-left':
          style.top = top - offsetY - height;
          style.left = left + offsetSide - width;
          style.arrowTop = height;
          style.arrowLeft = width - offsetSide - arrow;
          break;

        case 'top-center':
          style.top = top - offsetY - height;
          style.left = left - width / 2;
          style.arrowTop = height;
          style.arrowLeft = width / 2 - arrow;
          break;

        case 'top-right':
          style.top = top - offsetY - height;
          style.left = left - offsetSide;
          style.arrowTop = height;
          style.arrowLeft = arrow;
          break;

        case 'bottom-left':
          style.top = top + offsetY;
          style.left = left + offsetSide - width;
          style.arrowTop = -arrow * 2;
          style.arrowLeft = width - offsetSide - arrow;
          break;

        case 'bottom-center':
          style.top = top + offsetY;
          style.left = left - width / 2;
          style.arrowTop = -arrow * 2;
          style.arrowLeft = width / 2 - arrow;
          break;

        case 'bottom-right':
          style.top = top + offsetY;
          style.left = left - offsetSide;
          style.arrowTop = -arrow * 2;
          style.arrowLeft = arrow;
          break;

        case 'left-top':
          style.top = top + offsetSide - height;
          style.left = left - offsetX - width;
          style.arrowTop = height - offsetSide - arrow;
          style.arrowLeft = width;
          break;

        case 'center-left':
          style.top = top - height / 2;
          style.left = left - offsetX - width;
          style.arrowTop = height / 2 - arrow;
          style.arrowLeft = width;
          break;

        case 'left-bottom':
          style.top = top - offsetSide;
          style.left = left - offsetX - width;
          style.arrowTop = arrow;
          style.arrowLeft = width;
          break;

        case 'right-top':
          style.top = top + offsetSide - height;
          style.left = left + offsetX;
          style.arrowTop = height - offsetSide - arrow;
          style.arrowLeft = -arrow * 2;
          break;

        case 'center-right':
          style.top = top - height / 2;
          style.left = left + offsetX;
          style.arrowTop = height / 2 - arrow;
          style.arrowLeft = -arrow * 2;
          break;

        case 'right-bottom':
          style.top = top - offsetSide;
          style.left = left + offsetX;
          style.arrowTop = arrow;
          style.arrowLeft = -arrow * 2;
          break;
        // no default
      }
    }
    /**
     * @summary If the tooltip contains images, recompute its size once they are loaded
     * @private
     */
    ;

    _proto.__waitImages = function __waitImages() {
      var _this2 = this;

      var images = this.content.querySelectorAll('img');

      if (images.length > 0) {
        var promises = [];
        images.forEach(function (image) {
          promises.push(new Promise(function (resolve) {
            image.onload = resolve;
            image.onerror = resolve;
          }));
        });
        Promise.all(promises).then(function () {
          if (_this2.prop.state === STATE.SHOWING || _this2.prop.state === STATE.READY) {
            var rect = _this2.container.getBoundingClientRect();

            _this2.prop.width = rect.right - rect.left;
            _this2.prop.height = rect.bottom - rect.top;

            _this2.move(_this2.config);
          }
        });
      }
    };

    return Tooltip;
  }(AbstractComponent);

  /**
   * @summary Tooltip renderer
   * @extends PSV.services.AbstractService
   * @memberof PSV.services
   */

  var TooltipRenderer = /*#__PURE__*/function (_AbstractService) {
    _inheritsLoose(TooltipRenderer, _AbstractService);

    /**
     * @param {PSV.Viewer} psv
     */
    function TooltipRenderer(psv) {
      var _this;

      _this = _AbstractService.call(this, psv) || this;
      var testTooltip = new Tooltip(_this.psv, {
        arrow: 0,
        border: 0
      });
      /**
       * @summary Computed static sizes
       * @member {Object}
       * @package
       * @property {number} arrow
       * @property {number} border
       */

      _this.size = {
        arrow: parseInt(getStyle(testTooltip.arrow, 'borderTopWidth'), 10),
        border: parseInt(getStyle(testTooltip.container, 'borderTopLeftRadius'), 10)
      };
      testTooltip.destroy();
      return _this;
    }
    /**
     * @override
     */


    var _proto = TooltipRenderer.prototype;

    _proto.destroy = function destroy() {
      delete this.size;

      _AbstractService.prototype.destroy.call(this);
    }
    /**
     * @summary Displays a tooltip on the viewer
     * @param {PSV.components.Tooltip.Config} config
     * @returns {PSV.components.Tooltip}
     *
     * @fires PSV.show-tooltip
     * @throws {PSV.PSVError} when the configuration is incorrect
     *
     * @example
     * viewer.tooltip.create({ content: 'Hello world', top: 200, left: 450, position: 'center bottom'})
     */
    ;

    _proto.create = function create(config) {
      var tooltip = new Tooltip(this.psv, this.size);
      tooltip.show(config);
      return tooltip;
    };

    return TooltipRenderer;
  }(AbstractService);

  three.Cache.enabled = true;
  /**
   * @summary Main class
   * @memberOf PSV
   * @extends {external:uEvent.EventEmitter}
   */

  var Viewer = /*#__PURE__*/function (_EventEmitter) {
    _inheritsLoose(Viewer, _EventEmitter);

    /**
     * @param {PSV.Options} options
     * @fires PSV.ready
     * @throws {PSV.PSVError} when the configuration is incorrect
     */
    function Viewer(options) {
      var _this;

      _this = _EventEmitter.call(this) || this;
      SYSTEM.load(); // must support WebGL

      if (!SYSTEM.isWebGLSupported) {
        throw new PSVError('WebGL is not supported.');
      }

      if (SYSTEM.maxTextureWidth === 0) {
        throw new PSVError('Unable to detect system capabilities');
      }
      /**
       * @summary Internal properties
       * @member {Object}
       * @protected
       * @property {boolean} ready - when all components are loaded
       * @property {boolean} uiRefresh - if the UI needs to be renderer
       * @property {boolean} needsUpdate - if the view needs to be renderer
       * @property {boolean} fullscreen - if the viewer is currently fullscreen
       * @property {external:THREE.Vector3} direction - direction of the camera
       * @property {number} vFov - vertical FOV
       * @property {number} hFov - horizontal FOV
       * @property {number} aspect - viewer aspect ratio
       * @property {boolean} autorotateEnabled - automatic rotation is enabled
       * @property {PSV.utils.Animation} animationPromise - promise of the current animation
       * @property {Promise} loadingPromise - promise of the setPanorama method
       * @property {boolean} littlePlanet - special tweaks for LittlePlanetAdapter
       * @property {number} idleTime - time of the last user action
       * @property {object} objectsObservers
       * @property {PSV.Size} size - size of the container
       * @property {PSV.PanoData} panoData - panorama metadata, if supported
       */


      _this.prop = {
        ready: false,
        uiRefresh: false,
        needsUpdate: false,
        fullscreen: false,
        direction: new three.Vector3(0, 0, SPHERE_RADIUS),
        vFov: null,
        hFov: null,
        aspect: null,
        autorotateEnabled: false,
        animationPromise: null,
        loadingPromise: null,
        littlePlanet: false,
        idleTime: -1,
        objectsObservers: {},
        size: {
          width: 0,
          height: 0
        },
        panoData: {
          fullWidth: 0,
          fullHeight: 0,
          croppedWidth: 0,
          croppedHeight: 0,
          croppedX: 0,
          croppedY: 0,
          poseHeading: 0,
          posePitch: 0,
          poseRoll: 0
        }
      };
      /**
       * @summary Configuration holder
       * @type {PSV.Options}
       * @readonly
       */

      _this.config = getConfig(options);
      /**
       * @summary Top most parent
       * @member {HTMLElement}
       * @readonly
       */

      _this.parent = typeof options.container === 'string' ? document.getElementById(options.container) : options.container;
      _this.parent[VIEWER_DATA] = _assertThisInitialized(_this);
      /**
       * @summary Main container
       * @member {HTMLElement}
       * @readonly
       */

      _this.container = document.createElement('div');

      _this.container.classList.add('psv-container');

      _this.parent.appendChild(_this.container);
      /**
       * @summary Render adapter
       * @type {PSV.adapters.AbstractAdapter}
       * @readonly
       * @package
       */


      _this.adapter = new _this.config.adapter[0](_assertThisInitialized(_this), _this.config.adapter[1]); // eslint-disable-line new-cap

      /**
       * @summary All child components
       * @type {PSV.components.AbstractComponent[]}
       * @readonly
       * @package
       */

      _this.children = [];
      /**
       * @summary All plugins
       * @type {Object<string, PSV.plugins.AbstractPlugin>}
       * @readonly
       * @package
       */

      _this.plugins = {};
      /**
       * @type {PSV.services.Renderer}
       * @readonly
       */

      _this.renderer = new Renderer(_assertThisInitialized(_this));
      /**
       * @type {PSV.services.TextureLoader}
       * @readonly
       */

      _this.textureLoader = new TextureLoader(_assertThisInitialized(_this));
      /**
       * @type {PSV.services.EventsHandler}
       * @readonly
       */

      _this.eventsHandler = new EventsHandler(_assertThisInitialized(_this));
      /**
       * @type {PSV.services.DataHelper}
       * @readonly
       */

      _this.dataHelper = new DataHelper(_assertThisInitialized(_this));
      /**
       * @member {PSV.components.Loader}
       * @readonly
       */

      _this.loader = new Loader(_assertThisInitialized(_this));
      /**
       * @member {PSV.components.Navbar}
       * @readonly
       */

      _this.navbar = new Navbar(_assertThisInitialized(_this));
      /**
       * @member {PSV.components.Panel}
       * @readonly
       */

      _this.panel = new Panel(_assertThisInitialized(_this));
      /**
       * @member {PSV.services.TooltipRenderer}
       * @readonly
       */

      _this.tooltip = new TooltipRenderer(_assertThisInitialized(_this));
      /**
       * @member {PSV.components.Notification}
       * @readonly
       */

      _this.notification = new Notification(_assertThisInitialized(_this));
      /**
       * @member {PSV.components.Overlay}
       * @readonly
       */

      _this.overlay = new Overlay(_assertThisInitialized(_this));
      /**
       * @member {Record<string, PSV.utils.Dynamic>}
       * @package
       */

      _this.dynamics = {
        zoom: new Dynamic(function (value) {
          _this.prop.vFov = _this.dataHelper.zoomLevelToFov(value);
          _this.prop.hFov = _this.dataHelper.vFovToHFov(_this.prop.vFov);

          _this.trigger(EVENTS.ZOOM_UPDATED, value);
        }, _this.config.defaultZoomLvl, 0, 100),
        position: new MultiDynamic({
          longitude: new Dynamic(null, _this.config.defaultLong, 0, 2 * Math.PI, true),
          latitude: _this.prop.littlePlanet ? new Dynamic(null, _this.config.defaultLat, 0, Math.PI * 2, true) : new Dynamic(null, _this.config.defaultLat, -Math.PI / 2, Math.PI / 2)
        }, function (position) {
          _this.dataHelper.sphericalCoordsToVector3(position, _this.prop.direction);

          _this.trigger(EVENTS.POSITION_UPDATED, position);
        })
      };

      _this.__updateSpeeds();

      _this.eventsHandler.init();

      _this.__resizeRefresh = throttle(function () {
        return _this.refreshUi('resize');
      }, 500); // apply container size

      _this.resize(_this.config.size); // init plugins


      _this.config.plugins.forEach(function (_ref) {
        var plugin = _ref[0],
            opts = _ref[1];
        _this.plugins[plugin.id] = new plugin(_assertThisInitialized(_this), opts); // eslint-disable-line new-cap
      });

      each(_this.plugins, function (plugin) {
        return plugin.init == null ? void 0 : plugin.init();
      }); // init buttons

      _this.navbar.setButtons(_this.config.navbar); // load panorama


      if (_this.config.panorama) {
        _this.setPanorama(_this.config.panorama);
      }

      toggleClass(_this.container, 'psv--is-touch', SYSTEM.isTouchEnabled.initial);
      SYSTEM.isTouchEnabled.promise.then(function (enabled) {
        return toggleClass(_this.container, 'psv--is-touch', enabled);
      }); // enable GUI after first render

      _this.once(EVENTS.RENDER, function () {
        if (_this.config.navbar) {
          _this.container.classList.add('psv--has-navbar');

          _this.navbar.show();
        } // Queue autorotate


        if (!isNil(_this.config.autorotateDelay)) {
          _this.prop.idleTime = performance.now();
        }

        _this.prop.ready = true;
        setTimeout(function () {
          _this.refreshUi('init');

          _this.trigger(EVENTS.READY);
        }, 0);
      });

      return _this;
    }
    /**
     * @summary Destroys the viewer
     * @description The memory used by the ThreeJS context is not totally cleared. This will be fixed as soon as possible.
     */


    var _proto = Viewer.prototype;

    _proto.destroy = function destroy() {
      this.__stopAll();

      this.stopKeyboardControl();
      this.exitFullscreen();
      each(this.plugins, function (plugin) {
        return plugin.destroy();
      });
      delete this.plugins;
      this.children.slice().forEach(function (child) {
        return child.destroy();
      });
      this.children.length = 0;
      this.eventsHandler.destroy();
      this.renderer.destroy();
      this.textureLoader.destroy();
      this.dataHelper.destroy();
      this.adapter.destroy();
      this.parent.removeChild(this.container);
      delete this.parent[VIEWER_DATA];
      delete this.parent;
      delete this.container;
      delete this.loader;
      delete this.navbar;
      delete this.panel;
      delete this.tooltip;
      delete this.notification;
      delete this.overlay;
      delete this.dynamics;
      delete this.config;
    }
    /**
     * @summary Refresh UI
     * @package
     */
    ;

    _proto.refreshUi = function refreshUi(reason) {
      var _this2 = this;

      if (!this.prop.ready) {
        return;
      }

      if (!this.prop.uiRefresh) {
        // console.log(`PhotoSphereViewer: UI Refresh, ${reason}`);
        this.prop.uiRefresh = true;
        this.children.every(function (child) {
          child.refreshUi();
          return _this2.prop.uiRefresh === true;
        });
        this.prop.uiRefresh = false;
      } else if (this.prop.uiRefresh !== 'new') {
        this.prop.uiRefresh = 'new'; // wait for current refresh to cancel

        setTimeout(function () {
          _this2.prop.uiRefresh = false;

          _this2.refreshUi(reason);
        });
      }
    }
    /**
     * @summary Returns the instance of a plugin if it exists
     * @param {Class<PSV.plugins.AbstractPlugin>|string} pluginId
     * @returns {PSV.plugins.AbstractPlugin}
     */
    ;

    _proto.getPlugin = function getPlugin(pluginId) {
      if (typeof pluginId === 'string') {
        return this.plugins[pluginId];
      } else {
        var pluginCtor = pluginInterop(pluginId, AbstractPlugin);
        return pluginCtor ? this.plugins[pluginCtor.id] : undefined;
      }
    }
    /**
     * @summary Returns the current position of the camera
     * @returns {PSV.Position}
     */
    ;

    _proto.getPosition = function getPosition() {
      return this.dataHelper.cleanPosition(this.dynamics.position.current);
    }
    /**
     * @summary Returns the current zoom level
     * @returns {number}
     */
    ;

    _proto.getZoomLevel = function getZoomLevel() {
      return this.dynamics.zoom.current;
    }
    /**
     * @summary Returns the current viewer size
     * @returns {PSV.Size}
     */
    ;

    _proto.getSize = function getSize() {
      return _extends({}, this.prop.size);
    }
    /**
     * @summary Checks if the automatic rotation is enabled
     * @returns {boolean}
     */
    ;

    _proto.isAutorotateEnabled = function isAutorotateEnabled() {
      return this.prop.autorotateEnabled;
    }
    /**
     * @summary Checks if the viewer is in fullscreen
     * @returns {boolean}
     */
    ;

    _proto.isFullscreenEnabled = function isFullscreenEnabled$1() {
      if (SYSTEM.fullscreenEvent) {
        return isFullscreenEnabled(this.container);
      } else {
        return this.prop.fullscreen;
      }
    }
    /**
     * @summary Flags the view has changed for the next render
     */
    ;

    _proto.needsUpdate = function needsUpdate() {
      this.prop.needsUpdate = true;
    }
    /**
     * @summary Resizes the canvas when the window is resized
     * @fires PSV.size-updated
     */
    ;

    _proto.autoSize = function autoSize() {
      if (this.container.clientWidth !== this.prop.size.width || this.container.clientHeight !== this.prop.size.height) {
        this.prop.size.width = Math.round(this.container.clientWidth);
        this.prop.size.height = Math.round(this.container.clientHeight);
        this.prop.aspect = this.prop.size.width / this.prop.size.height;
        this.prop.hFov = this.dataHelper.vFovToHFov(this.prop.vFov);
        this.trigger(EVENTS.SIZE_UPDATED, this.getSize());

        this.__resizeRefresh();
      }
    }
    /**
     * @summary Loads a new panorama file
     * @description Loads a new panorama file, optionally changing the camera position/zoom and activating the transition animation.<br>
     * If the "options" parameter is not defined, the camera will not move and the ongoing animation will continue.<br>
     * If another loading is already in progress it will be aborted.
     * @param {*} path - URL of the new panorama file
     * @param {PSV.PanoramaOptions} [options]
     * @returns {Promise<boolean>} resolves false if the loading was aborted by another call
     */
    ;

    _proto.setPanorama = function setPanorama(path, options) {
      var _this$prop$transition,
          _this3 = this;

      if (options === void 0) {
        options = {};
      }

      this.textureLoader.abortLoading();
      (_this$prop$transition = this.prop.transitionAnimation) == null ? void 0 : _this$prop$transition.cancel(); // apply default parameters on first load

      if (!this.prop.ready) {
        ['sphereCorrection', 'panoData', 'overlay', 'overlayOpacity'].forEach(function (opt) {
          if (!(opt in options)) {
            options[opt] = _this3.config[opt];
          }
        });
      }

      if (options.transition === undefined || options.transition === true) {
        options.transition = DEFAULT_TRANSITION;
      }

      if (options.showLoader === undefined) {
        options.showLoader = true;
      }

      if (options.caption === undefined) {
        options.caption = this.config.caption;
      }

      if (options.description === undefined) {
        options.description = this.config.description;
      }

      if (!options.panoData && typeof this.config.panoData === 'function') {
        options.panoData = this.config.panoData;
      }

      var positionProvided = isExtendedPosition(options);
      var zoomProvided = ('zoom' in options);

      if (positionProvided || zoomProvided) {
        this.__stopAll();
      }

      this.hideError();
      this.config.panorama = path;
      this.config.caption = options.caption;
      this.config.description = options.description;

      var done = function done(err) {
        _this3.loader.hide();

        _this3.prop.loadingPromise = null;

        if (isAbortError(err)) {
          return false;
        } else if (err) {
          _this3.navbar.setCaption('');

          _this3.showError(_this3.config.lang.loadError);

          console.error(err);
          throw err;
        } else {
          _this3.resetIdleTimer();

          _this3.setOverlay(options.overlay, options.overlayOpacity);

          _this3.navbar.setCaption(_this3.config.caption);

          return true;
        }
      };

      this.navbar.setCaption("<em>" + (this.config.loadingTxt || '') + "</em>");

      if (options.showLoader || !this.prop.ready) {
        this.loader.show();
      }

      var loadingPromise = this.adapter.loadTexture(this.config.panorama, options.panoData).then(function (textureData) {
        // check if another panorama was requested
        if (textureData.panorama !== _this3.config.panorama) {
          _this3.adapter.disposeTexture(textureData);

          throw getAbortError();
        }

        return textureData;
      });

      if (!options.transition || !this.prop.ready || !this.adapter.supportsTransition(this.config.panorama)) {
        this.prop.loadingPromise = loadingPromise.then(function (textureData) {
          _this3.renderer.show();

          _this3.renderer.setTexture(textureData);

          _this3.renderer.setPanoramaPose(textureData.panoData);

          _this3.renderer.setSphereCorrection(options.sphereCorrection);

          if (zoomProvided) {
            _this3.zoom(options.zoom);
          }

          if (positionProvided) {
            _this3.rotate(options);
          }
        }).then(done, done);
      } else {
        this.prop.loadingPromise = loadingPromise.then(function (textureData) {
          _this3.loader.hide();

          _this3.prop.transitionAnimation = _this3.renderer.transition(textureData, options);
          return _this3.prop.transitionAnimation;
        }).then(function (completed) {
          _this3.prop.transitionAnimation = null;

          if (!completed) {
            throw getAbortError();
          }
        }).then(done, done);
      }

      return this.prop.loadingPromise;
    }
    /**
     * @summary Loads a new overlay
     * @param {*} path - URL of the new overlay file
     * @param {number} [opacity=1]
     * @returns {Promise}
     */
    ;

    _proto.setOverlay = function setOverlay(path, opacity) {
      var _this4 = this;

      if (opacity === void 0) {
        opacity = 1;
      }

      if (!path) {
        if (this.adapter.constructor.supportsOverlay) {
          this.renderer.setOverlay(null, 0);
        }

        return Promise.resolve();
      } else {
        if (!this.adapter.constructor.supportsOverlay) {
          return Promise.reject(new PSVError(this.adapter.constructor.id + " adapter does not supports overlay"));
        }

        return this.adapter.loadTexture(path, function (image) {
          var p = _this4.prop.panoData;
          var r = image.width / p.croppedWidth;
          return {
            fullWidth: r * p.fullWidth,
            fullHeight: r * p.fullHeight,
            croppedWidth: r * p.croppedWidth,
            croppedHeight: r * p.croppedHeight,
            croppedX: r * p.croppedX,
            croppedY: r * p.croppedY
          };
        }, false).then(function (textureData) {
          _this4.renderer.setOverlay(textureData, opacity);
        });
      }
    }
    /**
     * @summary Update options
     * @param {PSV.Options} options
     * @fires PSV.config-changed
     * @throws {PSV.PSVError} when the configuration is incorrect
     */
    ;

    _proto.setOptions = function setOptions(options) {
      var _this5 = this;

      var rawConfig = _extends({}, this.config, options);

      each(options, function (value, key) {
        if (DEPRECATED_OPTIONS[key]) {
          logWarn(DEPRECATED_OPTIONS[key]);
          return;
        }

        if (!Object.prototype.hasOwnProperty.call(DEFAULTS, key)) {
          throw new PSVError("Unknown option " + key);
        }

        if (READONLY_OPTIONS[key]) {
          throw new PSVError(READONLY_OPTIONS[key]);
        }

        if (CONFIG_PARSERS[key]) {
          _this5.config[key] = CONFIG_PARSERS[key](value, rawConfig);
        } else {
          _this5.config[key] = value;
        }

        switch (key) {
          case 'overlay':
          case 'overlayOpacity':
            _this5.setOverlay(_this5.config.overlay, _this5.config.overlayOpacity);

            break;

          case 'caption':
          case 'description':
            _this5.navbar.setCaption(_this5.config.caption);

            break;

          case 'size':
            _this5.resize(value);

            break;

          case 'sphereCorrection':
            _this5.renderer.setSphereCorrection(value);

            break;

          case 'navbar':
          case 'lang':
            _this5.navbar.setButtons(_this5.config.navbar);

            break;

          case 'moveSpeed':
          case 'zoomSpeed':
            _this5.__updateSpeeds();

            break;

          case 'minFov':
          case 'maxFov':
            _this5.dynamics.zoom.setValue(_this5.dataHelper.fovToZoomLevel(_this5.prop.vFov));

            _this5.trigger(EVENTS.ZOOM_UPDATED, _this5.getZoomLevel());

            break;

          case 'canvasBackground':
            _this5.renderer.canvasContainer.style.background = _this5.config.canvasBackground;
            break;

          case 'autorotateIdle':
            _this5.resetIdleTimer();

            break;
        }
      });
      this.needsUpdate();
      this.refreshUi('set options');
      this.trigger(EVENTS.CONFIG_CHANGED, Object.keys(options));
    }
    /**
     * @summary Update options
     * @param {string} option
     * @param {any} value
     * @fires PSV.config-changed
     * @throws {PSV.PSVError} when the configuration is incorrect
     */
    ;

    _proto.setOption = function setOption(option, value) {
      var _this$setOptions;

      this.setOptions((_this$setOptions = {}, _this$setOptions[option] = value, _this$setOptions));
    }
    /**
     * @summary Restarts the idle timer (if `autorotateIdle=true`)
     * @package
     */
    ;

    _proto.resetIdleTimer = function resetIdleTimer() {
      this.prop.idleTime = this.config.autorotateIdle ? performance.now() : -1;
    }
    /**
     * @summary Stops the idle timer
     * @package
     */
    ;

    _proto.disableIdleTimer = function disableIdleTimer() {
      this.prop.idleTime = -1;
    }
    /**
     * @summary Starts the automatic rotation
     * @fires PSV.autorotate
     */
    ;

    _proto.startAutorotate = function startAutorotate(refresh) {
      if (refresh === void 0) {
        refresh = false;
      }

      if (refresh && !this.isAutorotateEnabled()) {
        return;
      }

      if (!refresh && this.isAutorotateEnabled()) {
        return;
      }

      if (!refresh) {
        this.__stopAll();
      }

      this.dynamics.position.roll({
        longitude: this.config.autorotateSpeed < 0
      }, Math.abs(this.config.autorotateSpeed / this.config.moveSpeed));
      this.dynamics.position.goto({
        latitude: this.config.autorotateLat
      }, Math.abs(this.config.autorotateSpeed / this.config.moveSpeed));

      if (this.config.autorotateZoomLvl !== null) {
        this.dynamics.zoom.goto(this.config.autorotateZoomLvl);
      }

      this.prop.autorotateEnabled = true;

      if (!refresh) {
        this.trigger(EVENTS.AUTOROTATE, true);
      }
    }
    /**
     * @summary Stops the automatic rotation
     * @fires PSV.autorotate
     */
    ;

    _proto.stopAutorotate = function stopAutorotate() {
      if (this.isAutorotateEnabled()) {
        this.dynamics.position.stop();
        this.dynamics.zoom.stop();
        this.prop.autorotateEnabled = false;
        this.trigger(EVENTS.AUTOROTATE, false);
      }
    }
    /**
     * @summary Starts or stops the automatic rotation
     * @fires PSV.autorotate
     */
    ;

    _proto.toggleAutorotate = function toggleAutorotate() {
      if (this.isAutorotateEnabled()) {
        this.stopAutorotate();
      } else {
        this.startAutorotate();
      }
    }
    /**
     * @summary Displays an error message over the viewer
     * @param {string} message
     */
    ;

    _proto.showError = function showError(message) {
      this.overlay.show({
        id: IDS.ERROR,
        image: errorIcon,
        text: message,
        dissmisable: false
      });
    }
    /**
     * @summary Hides the error message
     */
    ;

    _proto.hideError = function hideError() {
      this.overlay.hide(IDS.ERROR);
    }
    /**
     * @summary Rotates the view to specific longitude and latitude
     * @param {PSV.ExtendedPosition} position
     * @fires PSV.before-rotate
     * @fires PSV.position-updated
     */
    ;

    _proto.rotate = function rotate(position) {
      var e = this.trigger(EVENTS.BEFORE_ROTATE, position);

      if (e.isDefaultPrevented()) {
        return;
      }

      var cleanPosition = this.change(CHANGE_EVENTS.GET_ROTATE_POSITION, this.dataHelper.cleanPosition(position));
      this.dynamics.position.setValue(cleanPosition);
    }
    /**
     * @summary Rotates and zooms the view with a smooth animation
     * @param {PSV.AnimateOptions} options - position and/or zoom level
     * @returns {PSV.utils.Animation}
     */
    ;

    _proto.animate = function animate(options) {
      var _this6 = this;

      this.__stopAll();

      var positionProvided = isExtendedPosition(options);
      var zoomProvided = options.zoom !== undefined;
      var animProperties = {};
      var duration; // clean/filter position and compute duration

      if (positionProvided) {
        var cleanPosition = this.change(CHANGE_EVENTS.GET_ANIMATE_POSITION, this.dataHelper.cleanPosition(options));
        var currentPosition = this.getPosition(); // longitude offset for shortest arc

        var tOffset = getShortestArc(currentPosition.longitude, cleanPosition.longitude);
        animProperties.longitude = {
          start: currentPosition.longitude,
          end: currentPosition.longitude + tOffset
        };
        animProperties.latitude = {
          start: currentPosition.latitude,
          end: cleanPosition.latitude
        };
        duration = this.dataHelper.speedToDuration(options.speed, getAngle(currentPosition, cleanPosition));
      } // clean/filter zoom and compute duration


      if (zoomProvided) {
        var dZoom = Math.abs(options.zoom - this.getZoomLevel());
        animProperties.zoom = {
          start: this.getZoomLevel(),
          end: options.zoom
        };

        if (!duration) {
          // if animating zoom only and a speed is given, use an arbitrary PI/4 to compute the duration
          duration = this.dataHelper.speedToDuration(options.speed, Math.PI / 4 * dZoom / 100);
        }
      } // if no animation needed


      if (!duration) {
        if (positionProvided) {
          this.rotate(options);
        }

        if (zoomProvided) {
          this.zoom(options.zoom);
        }

        return new Animation();
      }

      this.prop.animationPromise = new Animation({
        properties: animProperties,
        duration: duration,
        easing: 'inOutSine',
        onTick: function onTick(properties) {
          if (positionProvided) {
            _this6.rotate(properties);
          }

          if (zoomProvided) {
            _this6.zoom(properties.zoom);
          }
        }
      });
      this.prop.animationPromise.then(function () {
        _this6.prop.animationPromise = null;

        _this6.resetIdleTimer();
      });
      return this.prop.animationPromise;
    }
    /**
     * @summary Stops the ongoing animation
     * @description The return value is a Promise because the is no guaranty the animation can be stopped synchronously.
     * @returns {Promise} Resolved when the animation has ben cancelled
     */
    ;

    _proto.stopAnimation = function stopAnimation() {
      if (this.prop.animationPromise) {
        this.prop.animationPromise.cancel();
        return this.prop.animationPromise;
      } else {
        return Promise.resolve();
      }
    }
    /**
     * @summary Zooms to a specific level between `max_fov` and `min_fov`
     * @param {number} level - new zoom level from 0 to 100
     * @fires PSV.zoom-updated
     */
    ;

    _proto.zoom = function zoom(level) {
      this.dynamics.zoom.setValue(level);
    }
    /**
     * @summary Increases the zoom level
     * @param {number} [step=1]
     */
    ;

    _proto.zoomIn = function zoomIn(step) {
      if (step === void 0) {
        step = 1;
      }

      this.dynamics.zoom.step(step);
    }
    /**
     * @summary Decreases the zoom level
     * @param {number} [step=1]
     */
    ;

    _proto.zoomOut = function zoomOut(step) {
      if (step === void 0) {
        step = 1;
      }

      this.dynamics.zoom.step(-step);
    }
    /**
     * @summary Resizes the viewer
     * @param {PSV.CssSize} size
     */
    ;

    _proto.resize = function resize(size) {
      var _this7 = this;

      ['width', 'height'].forEach(function (dim) {
        if (size && size[dim]) {
          if (/^[0-9.]+$/.test(size[dim])) {
            size[dim] += 'px';
          }

          _this7.parent.style[dim] = size[dim];
        }
      });
      this.autoSize();
    }
    /**
     * @summary Enters the fullscreen mode
     * @fires PSV.fullscreen-updated
     */
    ;

    _proto.enterFullscreen = function enterFullscreen() {
      if (SYSTEM.fullscreenEvent) {
        requestFullscreen(this.container);
      } else {
        this.container.classList.add('psv-container--fullscreen');
        this.autoSize();

        this.eventsHandler.__fullscreenToggled(true);
      }
    }
    /**
     * @summary Exits the fullscreen mode
     * @fires PSV.fullscreen-updated
     */
    ;

    _proto.exitFullscreen = function exitFullscreen$1() {
      if (this.isFullscreenEnabled()) {
        if (SYSTEM.fullscreenEvent) {
          exitFullscreen();
        } else {
          this.container.classList.remove('psv-container--fullscreen');
          this.autoSize();

          this.eventsHandler.__fullscreenToggled(false);
        }
      }
    }
    /**
     * @summary Enters or exits the fullscreen mode
     * @fires PSV.fullscreen-updated
     */
    ;

    _proto.toggleFullscreen = function toggleFullscreen() {
      if (!this.isFullscreenEnabled()) {
        this.enterFullscreen();
      } else {
        this.exitFullscreen();
      }
    }
    /**
     * @summary Enables the keyboard controls (done automatically when entering fullscreen)
     */
    ;

    _proto.startKeyboardControl = function startKeyboardControl() {
      this.eventsHandler.enableKeyboard();
    }
    /**
     * @summary Disables the keyboard controls (done automatically when exiting fullscreen)
     */
    ;

    _proto.stopKeyboardControl = function stopKeyboardControl() {
      this.eventsHandler.disableKeyboard();
    }
    /**
     * @summary Subscribes to events on objects in the scene
     * @param {string} userDataKey - only objects with the following `userData` will be emitted
     * @param {EventListener} listener - must implement `handleEvent`
     * @return {function} call to stop the subscription
     * @package
     */
    ;

    _proto.observeObjects = function observeObjects(userDataKey, listener) {
      var _this8 = this;

      this.prop.objectsObservers[userDataKey] = {
        listener: listener
      };
      return function () {
        delete _this8.prop.objectsObservers[userDataKey];
      };
    }
    /**
     * @summary Stops all current animations
     * @returns {Promise}
     * @package
     */
    ;

    _proto.__stopAll = function __stopAll() {
      this.trigger(EVENTS.STOP_ALL);
      this.disableIdleTimer();
      this.stopAutorotate();
      return this.stopAnimation();
    }
    /**
     * @summary Recomputes dynamics speeds
     * @private
     */
    ;

    _proto.__updateSpeeds = function __updateSpeeds() {
      this.dynamics.zoom.setSpeed(this.config.zoomSpeed * 50);
      this.dynamics.position.setSpeed(three.MathUtils.degToRad(this.config.moveSpeed * 50));
    };

    return Viewer;
  }(uevent.EventEmitter);

  exports.AbstractAdapter = AbstractAdapter;
  exports.AbstractButton = AbstractButton;
  exports.AbstractComponent = AbstractComponent;
  exports.AbstractPlugin = AbstractPlugin;
  exports.CONSTANTS = constants;
  exports.DEFAULTS = DEFAULTS;
  exports.EquirectangularAdapter = EquirectangularAdapter;
  exports.PSVError = PSVError;
  exports.SYSTEM = SYSTEM;
  exports.Viewer = Viewer;
  exports.registerButton = registerButton;
  exports.utils = index;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=photo-sphere-viewer.js.map


/***/ }),

/***/ "./node_modules/uevent/browser.js":
/*!****************************************!*\
  !*** ./node_modules/uevent/browser.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports) {

/*!
 * uevent (v2.2.0)
 * @copyright 2015-2022 Damien "Mistic" Sorel <contact@git.strangeplanet.fr>
 * @licence MIT
 */
(function (global, factory) {
     true ? factory(exports) :
    0;
})(this, (function (exports) { 'use strict';

    var returnTrue = function returnTrue() {
      return true;
    };

    var returnFalse = function returnFalse() {
      return false;
    };

    var Event = /*#__PURE__*/function () {
      /**
       * @param {*} target
       * @param {String} type
       * @param {Array} args
       */
      function Event(target, type, args) {
        Object.defineProperties(this, {
          'target': {
            get: function get() {
              return target;
            },
            set: function set() {},
            enumerable: true
          },
          'type': {
            get: function get() {
              return type;
            },
            set: function set() {},
            enumerable: true
          },
          'args': {
            get: function get() {
              return args;
            },
            set: function set() {},
            enumerable: true
          }
        });
        this.isDefaultPrevented = returnFalse;
        this.isPropagationStopped = returnFalse;
      }

      var _proto = Event.prototype;

      _proto.preventDefault = function preventDefault() {
        this.isDefaultPrevented = returnTrue;
      };

      _proto.stopPropagation = function stopPropagation() {
        this.isPropagationStopped = returnTrue;
      };

      return Event;
    }();

    var Event_1 = Event;

    /**
     * @typedef {Object.<String, Function>} Callbacks
     */

    var EventEmitter = /*#__PURE__*/function () {
      function EventEmitter() {}

      var _proto = EventEmitter.prototype;

      /**
       * Add one or many event handlers
       *
       * @example
       *  obj.on('event', callback)
       *  obj.on('event', listener) // listener has an `handleEvent` method
       *  obj.on('event1 event2', callback)
       *  obj.on({ event1: callback1, event2: callback2 })
       *
       * @param {String|Callbacks} events
       * @param {Function} [callback]
       * @return {this}
       */
      _proto.on = function on(events, callback) {
        var _this = this;

        this.__events = this.__events || {};

        if (typeof events === 'object') {
          for (var event in events) {
            if (events.hasOwnProperty(event)) {
              this.__events[event] = this.__events[event] || [];

              this.__events[event].push(events[event]);
            }
          }
        } else {
          events.split(' ').forEach(function (event) {
            _this.__events[event] = _this.__events[event] || [];

            _this.__events[event].push(callback);
          });
        }

        return this;
      }
      /**
       * Remove one or many or all event handlers
       *
       * @example
       *  obj.off('event')
       *  obj.off('event', callback)
       *  obj.off('event1 event2')
       *  obj.off({ event1: callback1, event2: callback2 })
       *  obj.off()
       *
       * @param {String|Callbacks} [events]
       * @param {Function} [callback]
       * @return {this}
       */
      ;

      _proto.off = function off(events, callback) {
        var _this2 = this;

        if (typeof events === 'object') {
          for (var event in events) {
            if (events.hasOwnProperty(event)) {
              if (this.__events && event in this.__events) {
                var index = this.__events[event].indexOf(events[event]);

                if (index !== -1) this.__events[event].splice(index, 1);
              }

              if (this.__once && event in this.__once) {
                var _index = this.__once[event].indexOf(events[event]);

                if (_index !== -1) this.__once[event].splice(_index, 1);
              }
            }
          }
        } else if (!!events) {
          events.split(' ').forEach(function (event) {
            if (_this2.__events && event in _this2.__events) {
              if (callback) {
                var _index2 = _this2.__events[event].indexOf(callback);

                if (_index2 !== -1) _this2.__events[event].splice(_index2, 1);
              } else {
                _this2.__events[event].length = 0;
              }
            }

            if (_this2.__once && event in _this2.__once) {
              if (callback) {
                var _index3 = _this2.__once[event].indexOf(callback);

                if (_index3 !== -1) _this2.__once[event].splice(_index3, 1);
              } else {
                _this2.__once[event].length = 0;
              }
            }
          });
        } else {
          this.__events = {};
          this.__once = {};
        }

        return this;
      }
      /**
       * Add one or many event handlers that will be called only once
       * This handlers are only applicable to "trigger", not "change"
       *
       * @example
       *  obj.once('event', callback)
       *  obj.once('event1 event2', callback)
       *  obj.once({ event1: callback1, event2: callback2 })
       *
       * @param {String|Callbacks} events
       * @param {Function} [callback]
       * @return {this}
       */
      ;

      _proto.once = function once(events, callback) {
        var _this3 = this;

        this.__once = this.__once || {};

        if (typeof events === 'object') {
          for (var event in events) {
            if (events.hasOwnProperty(event)) {
              this.__once[event] = this.__once[event] || [];

              this.__once[event].push(events[event]);
            }
          }
        } else {
          events.split(' ').forEach(function (event) {
            _this3.__once[event] = _this3.__once[event] || [];

            _this3.__once[event].push(callback);
          });
        }

        return this;
      }
      /**
       * Trigger all handlers for an event
       *
       * @param {String} event
       * @param {*...} [arguments]
       * @return {Event}
       */
      ;

      _proto.trigger = function trigger(event
      /* , args... */
      ) {
        var args = Array.prototype.slice.call(arguments, 1);
        var e = new Event_1(this, event, args);

        if (this.__events && event in this.__events) {
          for (var i = 0, l = this.__events[event].length; i < l; i++) {
            var f = this.__events[event][i];

            if (typeof f === 'object') {
              f.handleEvent(e);
            } else {
              f.call.apply(f, [this, e].concat(args));
            }

            if (e.isPropagationStopped()) {
              break;
            }
          }
        }

        if (this.__once && event in this.__once) {
          for (var _i = 0, _l = this.__once[event].length; _i < _l; _i++) {
            var _f = this.__once[event][_i];

            if (typeof _f === 'object') {
              _f.handleEvent(e);
            } else {
              _f.call.apply(_f, [this, e].concat(args));
            }

            if (e.isPropagationStopped()) {
              break;
            }
          }

          delete this.__once[event];
        }

        return e;
      }
      /**
       * Trigger all modificators for an event, each handler must return a value
       *
       * @param {String} event
       * @param {*} value
       * @param {*...} [arguments]
       * @return {*} modified value
       */
      ;

      _proto.change = function change(event, value
      /* , args... */
      ) {
        var args = Array.prototype.slice.call(arguments, 2);
        var e = new Event_1(this, event, args);
        e.value = value;

        if (this.__events && event in this.__events) {
          for (var i = 0, l = this.__events[event].length; i < l; i++) {
            var f = this.__events[event][i];

            if (typeof f === 'object') {
              e.value = f.handleEvent(e);
            } else {
              e.value = f.call.apply(f, [this, e, e.value].concat(args));
            }

            if (e.isPropagationStopped()) {
              break;
            }
          }
        }

        return e.value;
      };

      return EventEmitter;
    }();

    var EventEmitter_1 = EventEmitter;

    function mixin(target) {
      target = typeof target === 'function' ? target.prototype : target;
      ['on', 'off', 'once', 'trigger', 'change'].forEach(function (name) {
        target[name] = EventEmitter_1.prototype[name];
      });
      return target;
    }

    var uEvent = {
      EventEmitter: EventEmitter_1,
      Event: Event_1,
      mixin: mixin
    };
    var uEvent_1 = uEvent.EventEmitter;
    var uEvent_2 = uEvent.Event;
    var uEvent_3 = uEvent.mixin;

    exports.Event = uEvent_2;
    exports.EventEmitter = uEvent_1;
    exports["default"] = uEvent;
    exports.mixin = uEvent_3;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=browser.js.map


/***/ }),

/***/ "./node_modules/three/build/three.cjs":
/*!********************************************!*\
  !*** ./node_modules/three/build/three.cjs ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */


Object.defineProperty(exports, "__esModule", ({ value: true }));

const REVISION = '146';
const MOUSE = {
	LEFT: 0,
	MIDDLE: 1,
	RIGHT: 2,
	ROTATE: 0,
	DOLLY: 1,
	PAN: 2
};
const TOUCH = {
	ROTATE: 0,
	PAN: 1,
	DOLLY_PAN: 2,
	DOLLY_ROTATE: 3
};
const CullFaceNone = 0;
const CullFaceBack = 1;
const CullFaceFront = 2;
const CullFaceFrontBack = 3;
const BasicShadowMap = 0;
const PCFShadowMap = 1;
const PCFSoftShadowMap = 2;
const VSMShadowMap = 3;
const FrontSide = 0;
const BackSide = 1;
const DoubleSide = 2;
const NoBlending = 0;
const NormalBlending = 1;
const AdditiveBlending = 2;
const SubtractiveBlending = 3;
const MultiplyBlending = 4;
const CustomBlending = 5;
const AddEquation = 100;
const SubtractEquation = 101;
const ReverseSubtractEquation = 102;
const MinEquation = 103;
const MaxEquation = 104;
const ZeroFactor = 200;
const OneFactor = 201;
const SrcColorFactor = 202;
const OneMinusSrcColorFactor = 203;
const SrcAlphaFactor = 204;
const OneMinusSrcAlphaFactor = 205;
const DstAlphaFactor = 206;
const OneMinusDstAlphaFactor = 207;
const DstColorFactor = 208;
const OneMinusDstColorFactor = 209;
const SrcAlphaSaturateFactor = 210;
const NeverDepth = 0;
const AlwaysDepth = 1;
const LessDepth = 2;
const LessEqualDepth = 3;
const EqualDepth = 4;
const GreaterEqualDepth = 5;
const GreaterDepth = 6;
const NotEqualDepth = 7;
const MultiplyOperation = 0;
const MixOperation = 1;
const AddOperation = 2;
const NoToneMapping = 0;
const LinearToneMapping = 1;
const ReinhardToneMapping = 2;
const CineonToneMapping = 3;
const ACESFilmicToneMapping = 4;
const CustomToneMapping = 5;
const UVMapping = 300;
const CubeReflectionMapping = 301;
const CubeRefractionMapping = 302;
const EquirectangularReflectionMapping = 303;
const EquirectangularRefractionMapping = 304;
const CubeUVReflectionMapping = 306;
const RepeatWrapping = 1000;
const ClampToEdgeWrapping = 1001;
const MirroredRepeatWrapping = 1002;
const NearestFilter = 1003;
const NearestMipmapNearestFilter = 1004;
const NearestMipMapNearestFilter = 1004;
const NearestMipmapLinearFilter = 1005;
const NearestMipMapLinearFilter = 1005;
const LinearFilter = 1006;
const LinearMipmapNearestFilter = 1007;
const LinearMipMapNearestFilter = 1007;
const LinearMipmapLinearFilter = 1008;
const LinearMipMapLinearFilter = 1008;
const UnsignedByteType = 1009;
const ByteType = 1010;
const ShortType = 1011;
const UnsignedShortType = 1012;
const IntType = 1013;
const UnsignedIntType = 1014;
const FloatType = 1015;
const HalfFloatType = 1016;
const UnsignedShort4444Type = 1017;
const UnsignedShort5551Type = 1018;
const UnsignedInt248Type = 1020;
const AlphaFormat = 1021;
const RGBFormat = 1022; // @deprecated since r137
const RGBAFormat = 1023;
const LuminanceFormat = 1024;
const LuminanceAlphaFormat = 1025;
const DepthFormat = 1026;
const DepthStencilFormat = 1027;
const RedFormat = 1028;
const RedIntegerFormat = 1029;
const RGFormat = 1030;
const RGIntegerFormat = 1031;
const RGBAIntegerFormat = 1033;
const RGB_S3TC_DXT1_Format = 33776;
const RGBA_S3TC_DXT1_Format = 33777;
const RGBA_S3TC_DXT3_Format = 33778;
const RGBA_S3TC_DXT5_Format = 33779;
const RGB_PVRTC_4BPPV1_Format = 35840;
const RGB_PVRTC_2BPPV1_Format = 35841;
const RGBA_PVRTC_4BPPV1_Format = 35842;
const RGBA_PVRTC_2BPPV1_Format = 35843;
const RGB_ETC1_Format = 36196;
const RGB_ETC2_Format = 37492;
const RGBA_ETC2_EAC_Format = 37496;
const RGBA_ASTC_4x4_Format = 37808;
const RGBA_ASTC_5x4_Format = 37809;
const RGBA_ASTC_5x5_Format = 37810;
const RGBA_ASTC_6x5_Format = 37811;
const RGBA_ASTC_6x6_Format = 37812;
const RGBA_ASTC_8x5_Format = 37813;
const RGBA_ASTC_8x6_Format = 37814;
const RGBA_ASTC_8x8_Format = 37815;
const RGBA_ASTC_10x5_Format = 37816;
const RGBA_ASTC_10x6_Format = 37817;
const RGBA_ASTC_10x8_Format = 37818;
const RGBA_ASTC_10x10_Format = 37819;
const RGBA_ASTC_12x10_Format = 37820;
const RGBA_ASTC_12x12_Format = 37821;
const RGBA_BPTC_Format = 36492;
const LoopOnce = 2200;
const LoopRepeat = 2201;
const LoopPingPong = 2202;
const InterpolateDiscrete = 2300;
const InterpolateLinear = 2301;
const InterpolateSmooth = 2302;
const ZeroCurvatureEnding = 2400;
const ZeroSlopeEnding = 2401;
const WrapAroundEnding = 2402;
const NormalAnimationBlendMode = 2500;
const AdditiveAnimationBlendMode = 2501;
const TrianglesDrawMode = 0;
const TriangleStripDrawMode = 1;
const TriangleFanDrawMode = 2;
const LinearEncoding = 3000;
const sRGBEncoding = 3001;
const BasicDepthPacking = 3200;
const RGBADepthPacking = 3201;
const TangentSpaceNormalMap = 0;
const ObjectSpaceNormalMap = 1;

// Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.
const NoColorSpace = '';
const SRGBColorSpace = 'srgb';
const LinearSRGBColorSpace = 'srgb-linear';
const ZeroStencilOp = 0;
const KeepStencilOp = 7680;
const ReplaceStencilOp = 7681;
const IncrementStencilOp = 7682;
const DecrementStencilOp = 7683;
const IncrementWrapStencilOp = 34055;
const DecrementWrapStencilOp = 34056;
const InvertStencilOp = 5386;
const NeverStencilFunc = 512;
const LessStencilFunc = 513;
const EqualStencilFunc = 514;
const LessEqualStencilFunc = 515;
const GreaterStencilFunc = 516;
const NotEqualStencilFunc = 517;
const GreaterEqualStencilFunc = 518;
const AlwaysStencilFunc = 519;
const StaticDrawUsage = 35044;
const DynamicDrawUsage = 35048;
const StreamDrawUsage = 35040;
const StaticReadUsage = 35045;
const DynamicReadUsage = 35049;
const StreamReadUsage = 35041;
const StaticCopyUsage = 35046;
const DynamicCopyUsage = 35050;
const StreamCopyUsage = 35042;
const GLSL1 = '100';
const GLSL3 = '300 es';
const _SRGBAFormat = 1035; // fallback for WebGL 1

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

class EventDispatcher {
	addEventListener(type, listener) {
		if (this._listeners === undefined) this._listeners = {};
		const listeners = this._listeners;
		if (listeners[type] === undefined) {
			listeners[type] = [];
		}
		if (listeners[type].indexOf(listener) === -1) {
			listeners[type].push(listener);
		}
	}
	hasEventListener(type, listener) {
		if (this._listeners === undefined) return false;
		const listeners = this._listeners;
		return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
	}
	removeEventListener(type, listener) {
		if (this._listeners === undefined) return;
		const listeners = this._listeners;
		const listenerArray = listeners[type];
		if (listenerArray !== undefined) {
			const index = listenerArray.indexOf(listener);
			if (index !== -1) {
				listenerArray.splice(index, 1);
			}
		}
	}
	dispatchEvent(event) {
		if (this._listeners === undefined) return;
		const listeners = this._listeners;
		const listenerArray = listeners[event.type];
		if (listenerArray !== undefined) {
			event.target = this;

			// Make a copy, in case listeners are removed while iterating.
			const array = listenerArray.slice(0);
			for (let i = 0, l = array.length; i < l; i++) {
				array[i].call(this, event);
			}
			event.target = null;
		}
	}
}

const _lut = ['00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff'];
let _seed = 1234567;
const DEG2RAD = Math.PI / 180;
const RAD2DEG = 180 / Math.PI;

// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
function generateUUID() {
	const d0 = Math.random() * 0xffffffff | 0;
	const d1 = Math.random() * 0xffffffff | 0;
	const d2 = Math.random() * 0xffffffff | 0;
	const d3 = Math.random() * 0xffffffff | 0;
	const uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' + _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' + _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] + _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff];

	// .toLowerCase() here flattens concatenated strings to save heap memory space.
	return uuid.toLowerCase();
}
function clamp(value, min, max) {
	return Math.max(min, Math.min(max, value));
}

// compute euclidean modulo of m % n
// https://en.wikipedia.org/wiki/Modulo_operation
function euclideanModulo(n, m) {
	return (n % m + m) % m;
}

// Linear mapping from range <a1, a2> to range <b1, b2>
function mapLinear(x, a1, a2, b1, b2) {
	return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
}

// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/
function inverseLerp(x, y, value) {
	if (x !== y) {
		return (value - x) / (y - x);
	} else {
		return 0;
	}
}

// https://en.wikipedia.org/wiki/Linear_interpolation
function lerp(x, y, t) {
	return (1 - t) * x + t * y;
}

// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
function damp(x, y, lambda, dt) {
	return lerp(x, y, 1 - Math.exp(-lambda * dt));
}

// https://www.desmos.com/calculator/vcsjnyz7x4
function pingpong(x, length = 1) {
	return length - Math.abs(euclideanModulo(x, length * 2) - length);
}

// http://en.wikipedia.org/wiki/Smoothstep
function smoothstep(x, min, max) {
	if (x <= min) return 0;
	if (x >= max) return 1;
	x = (x - min) / (max - min);
	return x * x * (3 - 2 * x);
}
function smootherstep(x, min, max) {
	if (x <= min) return 0;
	if (x >= max) return 1;
	x = (x - min) / (max - min);
	return x * x * x * (x * (x * 6 - 15) + 10);
}

// Random integer from <low, high> interval
function randInt(low, high) {
	return low + Math.floor(Math.random() * (high - low + 1));
}

// Random float from <low, high> interval
function randFloat(low, high) {
	return low + Math.random() * (high - low);
}

// Random float from <-range/2, range/2> interval
function randFloatSpread(range) {
	return range * (0.5 - Math.random());
}

// Deterministic pseudo-random float in the interval [ 0, 1 ]
function seededRandom(s) {
	if (s !== undefined) _seed = s;

	// Mulberry32 generator

	let t = _seed += 0x6D2B79F5;
	t = Math.imul(t ^ t >>> 15, t | 1);
	t ^= t + Math.imul(t ^ t >>> 7, t | 61);
	return ((t ^ t >>> 14) >>> 0) / 4294967296;
}
function degToRad(degrees) {
	return degrees * DEG2RAD;
}
function radToDeg(radians) {
	return radians * RAD2DEG;
}
function isPowerOfTwo(value) {
	return (value & value - 1) === 0 && value !== 0;
}
function ceilPowerOfTwo(value) {
	return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
}
function floorPowerOfTwo(value) {
	return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
}
function setQuaternionFromProperEuler(q, a, b, c, order) {
	// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

	// rotations are applied to the axes in the order specified by 'order'
	// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
	// angles are in radians

	const cos = Math.cos;
	const sin = Math.sin;
	const c2 = cos(b / 2);
	const s2 = sin(b / 2);
	const c13 = cos((a + c) / 2);
	const s13 = sin((a + c) / 2);
	const c1_3 = cos((a - c) / 2);
	const s1_3 = sin((a - c) / 2);
	const c3_1 = cos((c - a) / 2);
	const s3_1 = sin((c - a) / 2);
	switch (order) {
		case 'XYX':
			q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
			break;
		case 'YZY':
			q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
			break;
		case 'ZXZ':
			q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
			break;
		case 'XZX':
			q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
			break;
		case 'YXY':
			q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
			break;
		case 'ZYZ':
			q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
			break;
		default:
			console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order);
	}
}
function denormalize(value, array) {
	switch (array.constructor) {
		case Float32Array:
			return value;
		case Uint16Array:
			return value / 65535.0;
		case Uint8Array:
			return value / 255.0;
		case Int16Array:
			return Math.max(value / 32767.0, -1.0);
		case Int8Array:
			return Math.max(value / 127.0, -1.0);
		default:
			throw new Error('Invalid component type.');
	}
}
function normalize(value, array) {
	switch (array.constructor) {
		case Float32Array:
			return value;
		case Uint16Array:
			return Math.round(value * 65535.0);
		case Uint8Array:
			return Math.round(value * 255.0);
		case Int16Array:
			return Math.round(value * 32767.0);
		case Int8Array:
			return Math.round(value * 127.0);
		default:
			throw new Error('Invalid component type.');
	}
}

var MathUtils = /*#__PURE__*/Object.freeze({
	__proto__: null,
	DEG2RAD: DEG2RAD,
	RAD2DEG: RAD2DEG,
	generateUUID: generateUUID,
	clamp: clamp,
	euclideanModulo: euclideanModulo,
	mapLinear: mapLinear,
	inverseLerp: inverseLerp,
	lerp: lerp,
	damp: damp,
	pingpong: pingpong,
	smoothstep: smoothstep,
	smootherstep: smootherstep,
	randInt: randInt,
	randFloat: randFloat,
	randFloatSpread: randFloatSpread,
	seededRandom: seededRandom,
	degToRad: degToRad,
	radToDeg: radToDeg,
	isPowerOfTwo: isPowerOfTwo,
	ceilPowerOfTwo: ceilPowerOfTwo,
	floorPowerOfTwo: floorPowerOfTwo,
	setQuaternionFromProperEuler: setQuaternionFromProperEuler,
	normalize: normalize,
	denormalize: denormalize
});

class Vector2 {
	constructor(x = 0, y = 0) {
		Vector2.prototype.isVector2 = true;
		this.x = x;
		this.y = y;
	}
	get width() {
		return this.x;
	}
	set width(value) {
		this.x = value;
	}
	get height() {
		return this.y;
	}
	set height(value) {
		this.y = value;
	}
	set(x, y) {
		this.x = x;
		this.y = y;
		return this;
	}
	setScalar(scalar) {
		this.x = scalar;
		this.y = scalar;
		return this;
	}
	setX(x) {
		this.x = x;
		return this;
	}
	setY(y) {
		this.y = y;
		return this;
	}
	setComponent(index, value) {
		switch (index) {
			case 0:
				this.x = value;
				break;
			case 1:
				this.y = value;
				break;
			default:
				throw new Error('index is out of range: ' + index);
		}
		return this;
	}
	getComponent(index) {
		switch (index) {
			case 0:
				return this.x;
			case 1:
				return this.y;
			default:
				throw new Error('index is out of range: ' + index);
		}
	}
	clone() {
		return new this.constructor(this.x, this.y);
	}
	copy(v) {
		this.x = v.x;
		this.y = v.y;
		return this;
	}
	add(v) {
		this.x += v.x;
		this.y += v.y;
		return this;
	}
	addScalar(s) {
		this.x += s;
		this.y += s;
		return this;
	}
	addVectors(a, b) {
		this.x = a.x + b.x;
		this.y = a.y + b.y;
		return this;
	}
	addScaledVector(v, s) {
		this.x += v.x * s;
		this.y += v.y * s;
		return this;
	}
	sub(v) {
		this.x -= v.x;
		this.y -= v.y;
		return this;
	}
	subScalar(s) {
		this.x -= s;
		this.y -= s;
		return this;
	}
	subVectors(a, b) {
		this.x = a.x - b.x;
		this.y = a.y - b.y;
		return this;
	}
	multiply(v) {
		this.x *= v.x;
		this.y *= v.y;
		return this;
	}
	multiplyScalar(scalar) {
		this.x *= scalar;
		this.y *= scalar;
		return this;
	}
	divide(v) {
		this.x /= v.x;
		this.y /= v.y;
		return this;
	}
	divideScalar(scalar) {
		return this.multiplyScalar(1 / scalar);
	}
	applyMatrix3(m) {
		const x = this.x,
			y = this.y;
		const e = m.elements;
		this.x = e[0] * x + e[3] * y + e[6];
		this.y = e[1] * x + e[4] * y + e[7];
		return this;
	}
	min(v) {
		this.x = Math.min(this.x, v.x);
		this.y = Math.min(this.y, v.y);
		return this;
	}
	max(v) {
		this.x = Math.max(this.x, v.x);
		this.y = Math.max(this.y, v.y);
		return this;
	}
	clamp(min, max) {
		// assumes min < max, componentwise

		this.x = Math.max(min.x, Math.min(max.x, this.x));
		this.y = Math.max(min.y, Math.min(max.y, this.y));
		return this;
	}
	clampScalar(minVal, maxVal) {
		this.x = Math.max(minVal, Math.min(maxVal, this.x));
		this.y = Math.max(minVal, Math.min(maxVal, this.y));
		return this;
	}
	clampLength(min, max) {
		const length = this.length();
		return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
	}
	floor() {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		return this;
	}
	ceil() {
		this.x = Math.ceil(this.x);
		this.y = Math.ceil(this.y);
		return this;
	}
	round() {
		this.x = Math.round(this.x);
		this.y = Math.round(this.y);
		return this;
	}
	roundToZero() {
		this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
		this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
		return this;
	}
	negate() {
		this.x = -this.x;
		this.y = -this.y;
		return this;
	}
	dot(v) {
		return this.x * v.x + this.y * v.y;
	}
	cross(v) {
		return this.x * v.y - this.y * v.x;
	}
	lengthSq() {
		return this.x * this.x + this.y * this.y;
	}
	length() {
		return Math.sqrt(this.x * this.x + this.y * this.y);
	}
	manhattanLength() {
		return Math.abs(this.x) + Math.abs(this.y);
	}
	normalize() {
		return this.divideScalar(this.length() || 1);
	}
	angle() {
		// computes the angle in radians with respect to the positive x-axis

		const angle = Math.atan2(-this.y, -this.x) + Math.PI;
		return angle;
	}
	distanceTo(v) {
		return Math.sqrt(this.distanceToSquared(v));
	}
	distanceToSquared(v) {
		const dx = this.x - v.x,
			dy = this.y - v.y;
		return dx * dx + dy * dy;
	}
	manhattanDistanceTo(v) {
		return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
	}
	setLength(length) {
		return this.normalize().multiplyScalar(length);
	}
	lerp(v, alpha) {
		this.x += (v.x - this.x) * alpha;
		this.y += (v.y - this.y) * alpha;
		return this;
	}
	lerpVectors(v1, v2, alpha) {
		this.x = v1.x + (v2.x - v1.x) * alpha;
		this.y = v1.y + (v2.y - v1.y) * alpha;
		return this;
	}
	equals(v) {
		return v.x === this.x && v.y === this.y;
	}
	fromArray(array, offset = 0) {
		this.x = array[offset];
		this.y = array[offset + 1];
		return this;
	}
	toArray(array = [], offset = 0) {
		array[offset] = this.x;
		array[offset + 1] = this.y;
		return array;
	}
	fromBufferAttribute(attribute, index) {
		this.x = attribute.getX(index);
		this.y = attribute.getY(index);
		return this;
	}
	rotateAround(center, angle) {
		const c = Math.cos(angle),
			s = Math.sin(angle);
		const x = this.x - center.x;
		const y = this.y - center.y;
		this.x = x * c - y * s + center.x;
		this.y = x * s + y * c + center.y;
		return this;
	}
	random() {
		this.x = Math.random();
		this.y = Math.random();
		return this;
	}
	*[Symbol.iterator]() {
		yield this.x;
		yield this.y;
	}
}

class Matrix3 {
	constructor() {
		Matrix3.prototype.isMatrix3 = true;
		this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
	}
	set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
		const te = this.elements;
		te[0] = n11;
		te[1] = n21;
		te[2] = n31;
		te[3] = n12;
		te[4] = n22;
		te[5] = n32;
		te[6] = n13;
		te[7] = n23;
		te[8] = n33;
		return this;
	}
	identity() {
		this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
		return this;
	}
	copy(m) {
		const te = this.elements;
		const me = m.elements;
		te[0] = me[0];
		te[1] = me[1];
		te[2] = me[2];
		te[3] = me[3];
		te[4] = me[4];
		te[5] = me[5];
		te[6] = me[6];
		te[7] = me[7];
		te[8] = me[8];
		return this;
	}
	extractBasis(xAxis, yAxis, zAxis) {
		xAxis.setFromMatrix3Column(this, 0);
		yAxis.setFromMatrix3Column(this, 1);
		zAxis.setFromMatrix3Column(this, 2);
		return this;
	}
	setFromMatrix4(m) {
		const me = m.elements;
		this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
		return this;
	}
	multiply(m) {
		return this.multiplyMatrices(this, m);
	}
	premultiply(m) {
		return this.multiplyMatrices(m, this);
	}
	multiplyMatrices(a, b) {
		const ae = a.elements;
		const be = b.elements;
		const te = this.elements;
		const a11 = ae[0],
			a12 = ae[3],
			a13 = ae[6];
		const a21 = ae[1],
			a22 = ae[4],
			a23 = ae[7];
		const a31 = ae[2],
			a32 = ae[5],
			a33 = ae[8];
		const b11 = be[0],
			b12 = be[3],
			b13 = be[6];
		const b21 = be[1],
			b22 = be[4],
			b23 = be[7];
		const b31 = be[2],
			b32 = be[5],
			b33 = be[8];
		te[0] = a11 * b11 + a12 * b21 + a13 * b31;
		te[3] = a11 * b12 + a12 * b22 + a13 * b32;
		te[6] = a11 * b13 + a12 * b23 + a13 * b33;
		te[1] = a21 * b11 + a22 * b21 + a23 * b31;
		te[4] = a21 * b12 + a22 * b22 + a23 * b32;
		te[7] = a21 * b13 + a22 * b23 + a23 * b33;
		te[2] = a31 * b11 + a32 * b21 + a33 * b31;
		te[5] = a31 * b12 + a32 * b22 + a33 * b32;
		te[8] = a31 * b13 + a32 * b23 + a33 * b33;
		return this;
	}
	multiplyScalar(s) {
		const te = this.elements;
		te[0] *= s;
		te[3] *= s;
		te[6] *= s;
		te[1] *= s;
		te[4] *= s;
		te[7] *= s;
		te[2] *= s;
		te[5] *= s;
		te[8] *= s;
		return this;
	}
	determinant() {
		const te = this.elements;
		const a = te[0],
			b = te[1],
			c = te[2],
			d = te[3],
			e = te[4],
			f = te[5],
			g = te[6],
			h = te[7],
			i = te[8];
		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
	}
	invert() {
		const te = this.elements,
			n11 = te[0],
			n21 = te[1],
			n31 = te[2],
			n12 = te[3],
			n22 = te[4],
			n32 = te[5],
			n13 = te[6],
			n23 = te[7],
			n33 = te[8],
			t11 = n33 * n22 - n32 * n23,
			t12 = n32 * n13 - n33 * n12,
			t13 = n23 * n12 - n22 * n13,
			det = n11 * t11 + n21 * t12 + n31 * t13;
		if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
		const detInv = 1 / det;
		te[0] = t11 * detInv;
		te[1] = (n31 * n23 - n33 * n21) * detInv;
		te[2] = (n32 * n21 - n31 * n22) * detInv;
		te[3] = t12 * detInv;
		te[4] = (n33 * n11 - n31 * n13) * detInv;
		te[5] = (n31 * n12 - n32 * n11) * detInv;
		te[6] = t13 * detInv;
		te[7] = (n21 * n13 - n23 * n11) * detInv;
		te[8] = (n22 * n11 - n21 * n12) * detInv;
		return this;
	}
	transpose() {
		let tmp;
		const m = this.elements;
		tmp = m[1];
		m[1] = m[3];
		m[3] = tmp;
		tmp = m[2];
		m[2] = m[6];
		m[6] = tmp;
		tmp = m[5];
		m[5] = m[7];
		m[7] = tmp;
		return this;
	}
	getNormalMatrix(matrix4) {
		return this.setFromMatrix4(matrix4).invert().transpose();
	}
	transposeIntoArray(r) {
		const m = this.elements;
		r[0] = m[0];
		r[1] = m[3];
		r[2] = m[6];
		r[3] = m[1];
		r[4] = m[4];
		r[5] = m[7];
		r[6] = m[2];
		r[7] = m[5];
		r[8] = m[8];
		return this;
	}
	setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
		const c = Math.cos(rotation);
		const s = Math.sin(rotation);
		this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
		return this;
	}
	scale(sx, sy) {
		const te = this.elements;
		te[0] *= sx;
		te[3] *= sx;
		te[6] *= sx;
		te[1] *= sy;
		te[4] *= sy;
		te[7] *= sy;
		return this;
	}
	rotate(theta) {
		const c = Math.cos(theta);
		const s = Math.sin(theta);
		const te = this.elements;
		const a11 = te[0],
			a12 = te[3],
			a13 = te[6];
		const a21 = te[1],
			a22 = te[4],
			a23 = te[7];
		te[0] = c * a11 + s * a21;
		te[3] = c * a12 + s * a22;
		te[6] = c * a13 + s * a23;
		te[1] = -s * a11 + c * a21;
		te[4] = -s * a12 + c * a22;
		te[7] = -s * a13 + c * a23;
		return this;
	}
	translate(tx, ty) {
		const te = this.elements;
		te[0] += tx * te[2];
		te[3] += tx * te[5];
		te[6] += tx * te[8];
		te[1] += ty * te[2];
		te[4] += ty * te[5];
		te[7] += ty * te[8];
		return this;
	}
	equals(matrix) {
		const te = this.elements;
		const me = matrix.elements;
		for (let i = 0; i < 9; i++) {
			if (te[i] !== me[i]) return false;
		}
		return true;
	}
	fromArray(array, offset = 0) {
		for (let i = 0; i < 9; i++) {
			this.elements[i] = array[i + offset];
		}
		return this;
	}
	toArray(array = [], offset = 0) {
		const te = this.elements;
		array[offset] = te[0];
		array[offset + 1] = te[1];
		array[offset + 2] = te[2];
		array[offset + 3] = te[3];
		array[offset + 4] = te[4];
		array[offset + 5] = te[5];
		array[offset + 6] = te[6];
		array[offset + 7] = te[7];
		array[offset + 8] = te[8];
		return array;
	}
	clone() {
		return new this.constructor().fromArray(this.elements);
	}
}

function arrayNeedsUint32(array) {
	// assumes larger values usually on last

	for (let i = array.length - 1; i >= 0; --i) {
		if (array[i] >= 65535) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565
	}

	return false;
}
const TYPED_ARRAYS = {
	Int8Array: Int8Array,
	Uint8Array: Uint8Array,
	Uint8ClampedArray: Uint8ClampedArray,
	Int16Array: Int16Array,
	Uint16Array: Uint16Array,
	Int32Array: Int32Array,
	Uint32Array: Uint32Array,
	Float32Array: Float32Array,
	Float64Array: Float64Array
};
function getTypedArray(type, buffer) {
	return new TYPED_ARRAYS[type](buffer);
}
function createElementNS(name) {
	return document.createElementNS('http://www.w3.org/1999/xhtml', name);
}

function SRGBToLinear(c) {
	return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(c) {
	return c < 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
}

// JavaScript RGB-to-RGB transforms, defined as
// FN[InputColorSpace][OutputColorSpace] callback functions.
const FN = {
	[SRGBColorSpace]: {
		[LinearSRGBColorSpace]: SRGBToLinear
	},
	[LinearSRGBColorSpace]: {
		[SRGBColorSpace]: LinearToSRGB
	}
};
const ColorManagement = {
	legacyMode: true,
	get workingColorSpace() {
		return LinearSRGBColorSpace;
	},
	set workingColorSpace(colorSpace) {
		console.warn('THREE.ColorManagement: .workingColorSpace is readonly.');
	},
	convert: function (color, sourceColorSpace, targetColorSpace) {
		if (this.legacyMode || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {
			return color;
		}
		if (FN[sourceColorSpace] && FN[sourceColorSpace][targetColorSpace] !== undefined) {
			const fn = FN[sourceColorSpace][targetColorSpace];
			color.r = fn(color.r);
			color.g = fn(color.g);
			color.b = fn(color.b);
			return color;
		}
		throw new Error('Unsupported color space conversion.');
	},
	fromWorkingColorSpace: function (color, targetColorSpace) {
		return this.convert(color, this.workingColorSpace, targetColorSpace);
	},
	toWorkingColorSpace: function (color, sourceColorSpace) {
		return this.convert(color, sourceColorSpace, this.workingColorSpace);
	}
};

const _colorKeywords = {
	'aliceblue': 0xF0F8FF,
	'antiquewhite': 0xFAEBD7,
	'aqua': 0x00FFFF,
	'aquamarine': 0x7FFFD4,
	'azure': 0xF0FFFF,
	'beige': 0xF5F5DC,
	'bisque': 0xFFE4C4,
	'black': 0x000000,
	'blanchedalmond': 0xFFEBCD,
	'blue': 0x0000FF,
	'blueviolet': 0x8A2BE2,
	'brown': 0xA52A2A,
	'burlywood': 0xDEB887,
	'cadetblue': 0x5F9EA0,
	'chartreuse': 0x7FFF00,
	'chocolate': 0xD2691E,
	'coral': 0xFF7F50,
	'cornflowerblue': 0x6495ED,
	'cornsilk': 0xFFF8DC,
	'crimson': 0xDC143C,
	'cyan': 0x00FFFF,
	'darkblue': 0x00008B,
	'darkcyan': 0x008B8B,
	'darkgoldenrod': 0xB8860B,
	'darkgray': 0xA9A9A9,
	'darkgreen': 0x006400,
	'darkgrey': 0xA9A9A9,
	'darkkhaki': 0xBDB76B,
	'darkmagenta': 0x8B008B,
	'darkolivegreen': 0x556B2F,
	'darkorange': 0xFF8C00,
	'darkorchid': 0x9932CC,
	'darkred': 0x8B0000,
	'darksalmon': 0xE9967A,
	'darkseagreen': 0x8FBC8F,
	'darkslateblue': 0x483D8B,
	'darkslategray': 0x2F4F4F,
	'darkslategrey': 0x2F4F4F,
	'darkturquoise': 0x00CED1,
	'darkviolet': 0x9400D3,
	'deeppink': 0xFF1493,
	'deepskyblue': 0x00BFFF,
	'dimgray': 0x696969,
	'dimgrey': 0x696969,
	'dodgerblue': 0x1E90FF,
	'firebrick': 0xB22222,
	'floralwhite': 0xFFFAF0,
	'forestgreen': 0x228B22,
	'fuchsia': 0xFF00FF,
	'gainsboro': 0xDCDCDC,
	'ghostwhite': 0xF8F8FF,
	'gold': 0xFFD700,
	'goldenrod': 0xDAA520,
	'gray': 0x808080,
	'green': 0x008000,
	'greenyellow': 0xADFF2F,
	'grey': 0x808080,
	'honeydew': 0xF0FFF0,
	'hotpink': 0xFF69B4,
	'indianred': 0xCD5C5C,
	'indigo': 0x4B0082,
	'ivory': 0xFFFFF0,
	'khaki': 0xF0E68C,
	'lavender': 0xE6E6FA,
	'lavenderblush': 0xFFF0F5,
	'lawngreen': 0x7CFC00,
	'lemonchiffon': 0xFFFACD,
	'lightblue': 0xADD8E6,
	'lightcoral': 0xF08080,
	'lightcyan': 0xE0FFFF,
	'lightgoldenrodyellow': 0xFAFAD2,
	'lightgray': 0xD3D3D3,
	'lightgreen': 0x90EE90,
	'lightgrey': 0xD3D3D3,
	'lightpink': 0xFFB6C1,
	'lightsalmon': 0xFFA07A,
	'lightseagreen': 0x20B2AA,
	'lightskyblue': 0x87CEFA,
	'lightslategray': 0x778899,
	'lightslategrey': 0x778899,
	'lightsteelblue': 0xB0C4DE,
	'lightyellow': 0xFFFFE0,
	'lime': 0x00FF00,
	'limegreen': 0x32CD32,
	'linen': 0xFAF0E6,
	'magenta': 0xFF00FF,
	'maroon': 0x800000,
	'mediumaquamarine': 0x66CDAA,
	'mediumblue': 0x0000CD,
	'mediumorchid': 0xBA55D3,
	'mediumpurple': 0x9370DB,
	'mediumseagreen': 0x3CB371,
	'mediumslateblue': 0x7B68EE,
	'mediumspringgreen': 0x00FA9A,
	'mediumturquoise': 0x48D1CC,
	'mediumvioletred': 0xC71585,
	'midnightblue': 0x191970,
	'mintcream': 0xF5FFFA,
	'mistyrose': 0xFFE4E1,
	'moccasin': 0xFFE4B5,
	'navajowhite': 0xFFDEAD,
	'navy': 0x000080,
	'oldlace': 0xFDF5E6,
	'olive': 0x808000,
	'olivedrab': 0x6B8E23,
	'orange': 0xFFA500,
	'orangered': 0xFF4500,
	'orchid': 0xDA70D6,
	'palegoldenrod': 0xEEE8AA,
	'palegreen': 0x98FB98,
	'paleturquoise': 0xAFEEEE,
	'palevioletred': 0xDB7093,
	'papayawhip': 0xFFEFD5,
	'peachpuff': 0xFFDAB9,
	'peru': 0xCD853F,
	'pink': 0xFFC0CB,
	'plum': 0xDDA0DD,
	'powderblue': 0xB0E0E6,
	'purple': 0x800080,
	'rebeccapurple': 0x663399,
	'red': 0xFF0000,
	'rosybrown': 0xBC8F8F,
	'royalblue': 0x4169E1,
	'saddlebrown': 0x8B4513,
	'salmon': 0xFA8072,
	'sandybrown': 0xF4A460,
	'seagreen': 0x2E8B57,
	'seashell': 0xFFF5EE,
	'sienna': 0xA0522D,
	'silver': 0xC0C0C0,
	'skyblue': 0x87CEEB,
	'slateblue': 0x6A5ACD,
	'slategray': 0x708090,
	'slategrey': 0x708090,
	'snow': 0xFFFAFA,
	'springgreen': 0x00FF7F,
	'steelblue': 0x4682B4,
	'tan': 0xD2B48C,
	'teal': 0x008080,
	'thistle': 0xD8BFD8,
	'tomato': 0xFF6347,
	'turquoise': 0x40E0D0,
	'violet': 0xEE82EE,
	'wheat': 0xF5DEB3,
	'white': 0xFFFFFF,
	'whitesmoke': 0xF5F5F5,
	'yellow': 0xFFFF00,
	'yellowgreen': 0x9ACD32
};
const _rgb = {
	r: 0,
	g: 0,
	b: 0
};
const _hslA = {
	h: 0,
	s: 0,
	l: 0
};
const _hslB = {
	h: 0,
	s: 0,
	l: 0
};
function hue2rgb(p, q, t) {
	if (t < 0) t += 1;
	if (t > 1) t -= 1;
	if (t < 1 / 6) return p + (q - p) * 6 * t;
	if (t < 1 / 2) return q;
	if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
	return p;
}
function toComponents(source, target) {
	target.r = source.r;
	target.g = source.g;
	target.b = source.b;
	return target;
}
class Color {
	constructor(r, g, b) {
		this.isColor = true;
		this.r = 1;
		this.g = 1;
		this.b = 1;
		if (g === undefined && b === undefined) {
			// r is THREE.Color, hex or string
			return this.set(r);
		}
		return this.setRGB(r, g, b);
	}
	set(value) {
		if (value && value.isColor) {
			this.copy(value);
		} else if (typeof value === 'number') {
			this.setHex(value);
		} else if (typeof value === 'string') {
			this.setStyle(value);
		}
		return this;
	}
	setScalar(scalar) {
		this.r = scalar;
		this.g = scalar;
		this.b = scalar;
		return this;
	}
	setHex(hex, colorSpace = SRGBColorSpace) {
		hex = Math.floor(hex);
		this.r = (hex >> 16 & 255) / 255;
		this.g = (hex >> 8 & 255) / 255;
		this.b = (hex & 255) / 255;
		ColorManagement.toWorkingColorSpace(this, colorSpace);
		return this;
	}
	setRGB(r, g, b, colorSpace = LinearSRGBColorSpace) {
		this.r = r;
		this.g = g;
		this.b = b;
		ColorManagement.toWorkingColorSpace(this, colorSpace);
		return this;
	}
	setHSL(h, s, l, colorSpace = LinearSRGBColorSpace) {
		// h,s,l ranges are in 0.0 - 1.0
		h = euclideanModulo(h, 1);
		s = clamp(s, 0, 1);
		l = clamp(l, 0, 1);
		if (s === 0) {
			this.r = this.g = this.b = l;
		} else {
			const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
			const q = 2 * l - p;
			this.r = hue2rgb(q, p, h + 1 / 3);
			this.g = hue2rgb(q, p, h);
			this.b = hue2rgb(q, p, h - 1 / 3);
		}
		ColorManagement.toWorkingColorSpace(this, colorSpace);
		return this;
	}
	setStyle(style, colorSpace = SRGBColorSpace) {
		function handleAlpha(string) {
			if (string === undefined) return;
			if (parseFloat(string) < 1) {
				console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
			}
		}
		let m;
		if (m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
			// rgb / hsl

			let color;
			const name = m[1];
			const components = m[2];
			switch (name) {
				case 'rgb':
				case 'rgba':
					if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
						// rgb(255,0,0) rgba(255,0,0,0.5)
						this.r = Math.min(255, parseInt(color[1], 10)) / 255;
						this.g = Math.min(255, parseInt(color[2], 10)) / 255;
						this.b = Math.min(255, parseInt(color[3], 10)) / 255;
						ColorManagement.toWorkingColorSpace(this, colorSpace);
						handleAlpha(color[4]);
						return this;
					}
					if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
						this.r = Math.min(100, parseInt(color[1], 10)) / 100;
						this.g = Math.min(100, parseInt(color[2], 10)) / 100;
						this.b = Math.min(100, parseInt(color[3], 10)) / 100;
						ColorManagement.toWorkingColorSpace(this, colorSpace);
						handleAlpha(color[4]);
						return this;
					}
					break;
				case 'hsl':
				case 'hsla':
					if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
						const h = parseFloat(color[1]) / 360;
						const s = parseFloat(color[2]) / 100;
						const l = parseFloat(color[3]) / 100;
						handleAlpha(color[4]);
						return this.setHSL(h, s, l, colorSpace);
					}
					break;
			}
		} else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
			// hex color

			const hex = m[1];
			const size = hex.length;
			if (size === 3) {
				// #ff0
				this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
				this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
				this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
				ColorManagement.toWorkingColorSpace(this, colorSpace);
				return this;
			} else if (size === 6) {
				// #ff0000
				this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
				this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
				this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
				ColorManagement.toWorkingColorSpace(this, colorSpace);
				return this;
			}
		}
		if (style && style.length > 0) {
			return this.setColorName(style, colorSpace);
		}
		return this;
	}
	setColorName(style, colorSpace = SRGBColorSpace) {
		// color keywords
		const hex = _colorKeywords[style.toLowerCase()];
		if (hex !== undefined) {
			// red
			this.setHex(hex, colorSpace);
		} else {
			// unknown color
			console.warn('THREE.Color: Unknown color ' + style);
		}
		return this;
	}
	clone() {
		return new this.constructor(this.r, this.g, this.b);
	}
	copy(color) {
		this.r = color.r;
		this.g = color.g;
		this.b = color.b;
		return this;
	}
	copySRGBToLinear(color) {
		this.r = SRGBToLinear(color.r);
		this.g = SRGBToLinear(color.g);
		this.b = SRGBToLinear(color.b);
		return this;
	}
	copyLinearToSRGB(color) {
		this.r = LinearToSRGB(color.r);
		this.g = LinearToSRGB(color.g);
		this.b = LinearToSRGB(color.b);
		return this;
	}
	convertSRGBToLinear() {
		this.copySRGBToLinear(this);
		return this;
	}
	convertLinearToSRGB() {
		this.copyLinearToSRGB(this);
		return this;
	}
	getHex(colorSpace = SRGBColorSpace) {
		ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);
		return clamp(_rgb.r * 255, 0, 255) << 16 ^ clamp(_rgb.g * 255, 0, 255) << 8 ^ clamp(_rgb.b * 255, 0, 255) << 0;
	}
	getHexString(colorSpace = SRGBColorSpace) {
		return ('000000' + this.getHex(colorSpace).toString(16)).slice(-6);
	}
	getHSL(target, colorSpace = LinearSRGBColorSpace) {
		// h,s,l ranges are in 0.0 - 1.0

		ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);
		const r = _rgb.r,
			g = _rgb.g,
			b = _rgb.b;
		const max = Math.max(r, g, b);
		const min = Math.min(r, g, b);
		let hue, saturation;
		const lightness = (min + max) / 2.0;
		if (min === max) {
			hue = 0;
			saturation = 0;
		} else {
			const delta = max - min;
			saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
			switch (max) {
				case r:
					hue = (g - b) / delta + (g < b ? 6 : 0);
					break;
				case g:
					hue = (b - r) / delta + 2;
					break;
				case b:
					hue = (r - g) / delta + 4;
					break;
			}
			hue /= 6;
		}
		target.h = hue;
		target.s = saturation;
		target.l = lightness;
		return target;
	}
	getRGB(target, colorSpace = LinearSRGBColorSpace) {
		ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);
		target.r = _rgb.r;
		target.g = _rgb.g;
		target.b = _rgb.b;
		return target;
	}
	getStyle(colorSpace = SRGBColorSpace) {
		ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);
		if (colorSpace !== SRGBColorSpace) {
			// Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).
			return `color(${colorSpace} ${_rgb.r} ${_rgb.g} ${_rgb.b})`;
		}
		return `rgb(${_rgb.r * 255 | 0},${_rgb.g * 255 | 0},${_rgb.b * 255 | 0})`;
	}
	offsetHSL(h, s, l) {
		this.getHSL(_hslA);
		_hslA.h += h;
		_hslA.s += s;
		_hslA.l += l;
		this.setHSL(_hslA.h, _hslA.s, _hslA.l);
		return this;
	}
	add(color) {
		this.r += color.r;
		this.g += color.g;
		this.b += color.b;
		return this;
	}
	addColors(color1, color2) {
		this.r = color1.r + color2.r;
		this.g = color1.g + color2.g;
		this.b = color1.b + color2.b;
		return this;
	}
	addScalar(s) {
		this.r += s;
		this.g += s;
		this.b += s;
		return this;
	}
	sub(color) {
		this.r = Math.max(0, this.r - color.r);
		this.g = Math.max(0, this.g - color.g);
		this.b = Math.max(0, this.b - color.b);
		return this;
	}
	multiply(color) {
		this.r *= color.r;
		this.g *= color.g;
		this.b *= color.b;
		return this;
	}
	multiplyScalar(s) {
		this.r *= s;
		this.g *= s;
		this.b *= s;
		return this;
	}
	lerp(color, alpha) {
		this.r += (color.r - this.r) * alpha;
		this.g += (color.g - this.g) * alpha;
		this.b += (color.b - this.b) * alpha;
		return this;
	}
	lerpColors(color1, color2, alpha) {
		this.r = color1.r + (color2.r - color1.r) * alpha;
		this.g = color1.g + (color2.g - color1.g) * alpha;
		this.b = color1.b + (color2.b - color1.b) * alpha;
		return this;
	}
	lerpHSL(color, alpha) {
		this.getHSL(_hslA);
		color.getHSL(_hslB);
		const h = lerp(_hslA.h, _hslB.h, alpha);
		const s = lerp(_hslA.s, _hslB.s, alpha);
		const l = lerp(_hslA.l, _hslB.l, alpha);
		this.setHSL(h, s, l);
		return this;
	}
	equals(c) {
		return c.r === this.r && c.g === this.g && c.b === this.b;
	}
	fromArray(array, offset = 0) {
		this.r = array[offset];
		this.g = array[offset + 1];
		this.b = array[offset + 2];
		return this;
	}
	toArray(array = [], offset = 0) {
		array[offset] = this.r;
		array[offset + 1] = this.g;
		array[offset + 2] = this.b;
		return array;
	}
	fromBufferAttribute(attribute, index) {
		this.r = attribute.getX(index);
		this.g = attribute.getY(index);
		this.b = attribute.getZ(index);
		return this;
	}
	toJSON() {
		return this.getHex();
	}
	*[Symbol.iterator]() {
		yield this.r;
		yield this.g;
		yield this.b;
	}
}
Color.NAMES = _colorKeywords;

let _canvas;
class ImageUtils {
	static getDataURL(image) {
		if (/^data:/i.test(image.src)) {
			return image.src;
		}
		if (typeof HTMLCanvasElement == 'undefined') {
			return image.src;
		}
		let canvas;
		if (image instanceof HTMLCanvasElement) {
			canvas = image;
		} else {
			if (_canvas === undefined) _canvas = createElementNS('canvas');
			_canvas.width = image.width;
			_canvas.height = image.height;
			const context = _canvas.getContext('2d');
			if (image instanceof ImageData) {
				context.putImageData(image, 0, 0);
			} else {
				context.drawImage(image, 0, 0, image.width, image.height);
			}
			canvas = _canvas;
		}
		if (canvas.width > 2048 || canvas.height > 2048) {
			console.warn('THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image);
			return canvas.toDataURL('image/jpeg', 0.6);
		} else {
			return canvas.toDataURL('image/png');
		}
	}
	static sRGBToLinear(image) {
		if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
			const canvas = createElementNS('canvas');
			canvas.width = image.width;
			canvas.height = image.height;
			const context = canvas.getContext('2d');
			context.drawImage(image, 0, 0, image.width, image.height);
			const imageData = context.getImageData(0, 0, image.width, image.height);
			const data = imageData.data;
			for (let i = 0; i < data.length; i++) {
				data[i] = SRGBToLinear(data[i] / 255) * 255;
			}
			context.putImageData(imageData, 0, 0);
			return canvas;
		} else if (image.data) {
			const data = image.data.slice(0);
			for (let i = 0; i < data.length; i++) {
				if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
					data[i] = Math.floor(SRGBToLinear(data[i] / 255) * 255);
				} else {
					// assuming float

					data[i] = SRGBToLinear(data[i]);
				}
			}
			return {
				data: data,
				width: image.width,
				height: image.height
			};
		} else {
			console.warn('THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.');
			return image;
		}
	}
}

class Source {
	constructor(data = null) {
		this.isSource = true;
		this.uuid = generateUUID();
		this.data = data;
		this.version = 0;
	}
	set needsUpdate(value) {
		if (value === true) this.version++;
	}
	toJSON(meta) {
		const isRootObject = meta === undefined || typeof meta === 'string';
		if (!isRootObject && meta.images[this.uuid] !== undefined) {
			return meta.images[this.uuid];
		}
		const output = {
			uuid: this.uuid,
			url: ''
		};
		const data = this.data;
		if (data !== null) {
			let url;
			if (Array.isArray(data)) {
				// cube texture

				url = [];
				for (let i = 0, l = data.length; i < l; i++) {
					if (data[i].isDataTexture) {
						url.push(serializeImage(data[i].image));
					} else {
						url.push(serializeImage(data[i]));
					}
				}
			} else {
				// texture

				url = serializeImage(data);
			}
			output.url = url;
		}
		if (!isRootObject) {
			meta.images[this.uuid] = output;
		}
		return output;
	}
}
function serializeImage(image) {
	if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
		// default images

		return ImageUtils.getDataURL(image);
	} else {
		if (image.data) {
			// images of DataTexture

			return {
				data: Array.from(image.data),
				width: image.width,
				height: image.height,
				type: image.data.constructor.name
			};
		} else {
			console.warn('THREE.Texture: Unable to serialize Texture.');
			return {};
		}
	}
}

let textureId = 0;
class Texture extends EventDispatcher {
	constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding) {
		super();
		this.isTexture = true;
		Object.defineProperty(this, 'id', {
			value: textureId++
		});
		this.uuid = generateUUID();
		this.name = '';
		this.source = new Source(image);
		this.mipmaps = [];
		this.mapping = mapping;
		this.wrapS = wrapS;
		this.wrapT = wrapT;
		this.magFilter = magFilter;
		this.minFilter = minFilter;
		this.anisotropy = anisotropy;
		this.format = format;
		this.internalFormat = null;
		this.type = type;
		this.offset = new Vector2(0, 0);
		this.repeat = new Vector2(1, 1);
		this.center = new Vector2(0, 0);
		this.rotation = 0;
		this.matrixAutoUpdate = true;
		this.matrix = new Matrix3();
		this.generateMipmaps = true;
		this.premultiplyAlpha = false;
		this.flipY = true;
		this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

		// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
		//
		// Also changing the encoding after already used by a Material will not automatically make the Material
		// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
		this.encoding = encoding;
		this.userData = {};
		this.version = 0;
		this.onUpdate = null;
		this.isRenderTargetTexture = false; // indicates whether a texture belongs to a render target or not
		this.needsPMREMUpdate = false; // indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)
	}

	get image() {
		return this.source.data;
	}
	set image(value) {
		this.source.data = value;
	}
	updateMatrix() {
		this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
	}
	clone() {
		return new this.constructor().copy(this);
	}
	copy(source) {
		this.name = source.name;
		this.source = source.source;
		this.mipmaps = source.mipmaps.slice(0);
		this.mapping = source.mapping;
		this.wrapS = source.wrapS;
		this.wrapT = source.wrapT;
		this.magFilter = source.magFilter;
		this.minFilter = source.minFilter;
		this.anisotropy = source.anisotropy;
		this.format = source.format;
		this.internalFormat = source.internalFormat;
		this.type = source.type;
		this.offset.copy(source.offset);
		this.repeat.copy(source.repeat);
		this.center.copy(source.center);
		this.rotation = source.rotation;
		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrix.copy(source.matrix);
		this.generateMipmaps = source.generateMipmaps;
		this.premultiplyAlpha = source.premultiplyAlpha;
		this.flipY = source.flipY;
		this.unpackAlignment = source.unpackAlignment;
		this.encoding = source.encoding;
		this.userData = JSON.parse(JSON.stringify(source.userData));
		this.needsUpdate = true;
		return this;
	}
	toJSON(meta) {
		const isRootObject = meta === undefined || typeof meta === 'string';
		if (!isRootObject && meta.textures[this.uuid] !== undefined) {
			return meta.textures[this.uuid];
		}
		const output = {
			metadata: {
				version: 4.5,
				type: 'Texture',
				generator: 'Texture.toJSON'
			},
			uuid: this.uuid,
			name: this.name,
			image: this.source.toJSON(meta).uuid,
			mapping: this.mapping,
			repeat: [this.repeat.x, this.repeat.y],
			offset: [this.offset.x, this.offset.y],
			center: [this.center.x, this.center.y],
			rotation: this.rotation,
			wrap: [this.wrapS, this.wrapT],
			format: this.format,
			type: this.type,
			encoding: this.encoding,
			minFilter: this.minFilter,
			magFilter: this.magFilter,
			anisotropy: this.anisotropy,
			flipY: this.flipY,
			premultiplyAlpha: this.premultiplyAlpha,
			unpackAlignment: this.unpackAlignment
		};
		if (JSON.stringify(this.userData) !== '{}') output.userData = this.userData;
		if (!isRootObject) {
			meta.textures[this.uuid] = output;
		}
		return output;
	}
	dispose() {
		this.dispatchEvent({
			type: 'dispose'
		});
	}
	transformUv(uv) {
		if (this.mapping !== UVMapping) return uv;
		uv.applyMatrix3(this.matrix);
		if (uv.x < 0 || uv.x > 1) {
			switch (this.wrapS) {
				case RepeatWrapping:
					uv.x = uv.x - Math.floor(uv.x);
					break;
				case ClampToEdgeWrapping:
					uv.x = uv.x < 0 ? 0 : 1;
					break;
				case MirroredRepeatWrapping:
					if (Math.abs(Math.floor(uv.x) % 2) === 1) {
						uv.x = Math.ceil(uv.x) - uv.x;
					} else {
						uv.x = uv.x - Math.floor(uv.x);
					}
					break;
			}
		}
		if (uv.y < 0 || uv.y > 1) {
			switch (this.wrapT) {
				case RepeatWrapping:
					uv.y = uv.y - Math.floor(uv.y);
					break;
				case ClampToEdgeWrapping:
					uv.y = uv.y < 0 ? 0 : 1;
					break;
				case MirroredRepeatWrapping:
					if (Math.abs(Math.floor(uv.y) % 2) === 1) {
						uv.y = Math.ceil(uv.y) - uv.y;
					} else {
						uv.y = uv.y - Math.floor(uv.y);
					}
					break;
			}
		}
		if (this.flipY) {
			uv.y = 1 - uv.y;
		}
		return uv;
	}
	set needsUpdate(value) {
		if (value === true) {
			this.version++;
			this.source.needsUpdate = true;
		}
	}
}
Texture.DEFAULT_IMAGE = null;
Texture.DEFAULT_MAPPING = UVMapping;

class Vector4 {
	constructor(x = 0, y = 0, z = 0, w = 1) {
		Vector4.prototype.isVector4 = true;
		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;
	}
	get width() {
		return this.z;
	}
	set width(value) {
		this.z = value;
	}
	get height() {
		return this.w;
	}
	set height(value) {
		this.w = value;
	}
	set(x, y, z, w) {
		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;
		return this;
	}
	setScalar(scalar) {
		this.x = scalar;
		this.y = scalar;
		this.z = scalar;
		this.w = scalar;
		return this;
	}
	setX(x) {
		this.x = x;
		return this;
	}
	setY(y) {
		this.y = y;
		return this;
	}
	setZ(z) {
		this.z = z;
		return this;
	}
	setW(w) {
		this.w = w;
		return this;
	}
	setComponent(index, value) {
		switch (index) {
			case 0:
				this.x = value;
				break;
			case 1:
				this.y = value;
				break;
			case 2:
				this.z = value;
				break;
			case 3:
				this.w = value;
				break;
			default:
				throw new Error('index is out of range: ' + index);
		}
		return this;
	}
	getComponent(index) {
		switch (index) {
			case 0:
				return this.x;
			case 1:
				return this.y;
			case 2:
				return this.z;
			case 3:
				return this.w;
			default:
				throw new Error('index is out of range: ' + index);
		}
	}
	clone() {
		return new this.constructor(this.x, this.y, this.z, this.w);
	}
	copy(v) {
		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		this.w = v.w !== undefined ? v.w : 1;
		return this;
	}
	add(v) {
		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		this.w += v.w;
		return this;
	}
	addScalar(s) {
		this.x += s;
		this.y += s;
		this.z += s;
		this.w += s;
		return this;
	}
	addVectors(a, b) {
		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;
		this.w = a.w + b.w;
		return this;
	}
	addScaledVector(v, s) {
		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;
		this.w += v.w * s;
		return this;
	}
	sub(v) {
		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		this.w -= v.w;
		return this;
	}
	subScalar(s) {
		this.x -= s;
		this.y -= s;
		this.z -= s;
		this.w -= s;
		return this;
	}
	subVectors(a, b) {
		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;
		this.w = a.w - b.w;
		return this;
	}
	multiply(v) {
		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;
		this.w *= v.w;
		return this;
	}
	multiplyScalar(scalar) {
		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;
		this.w *= scalar;
		return this;
	}
	applyMatrix4(m) {
		const x = this.x,
			y = this.y,
			z = this.z,
			w = this.w;
		const e = m.elements;
		this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
		this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
		this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
		this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
		return this;
	}
	divideScalar(scalar) {
		return this.multiplyScalar(1 / scalar);
	}
	setAxisAngleFromQuaternion(q) {
		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

		// q is assumed to be normalized

		this.w = 2 * Math.acos(q.w);
		const s = Math.sqrt(1 - q.w * q.w);
		if (s < 0.0001) {
			this.x = 1;
			this.y = 0;
			this.z = 0;
		} else {
			this.x = q.x / s;
			this.y = q.y / s;
			this.z = q.z / s;
		}
		return this;
	}
	setAxisAngleFromRotationMatrix(m) {
		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		let angle, x, y, z; // variables for result
		const epsilon = 0.01,
			// margin to allow for rounding errors
			epsilon2 = 0.1,
			// margin to distinguish between 0 and 180 degrees

			te = m.elements,
			m11 = te[0],
			m12 = te[4],
			m13 = te[8],
			m21 = te[1],
			m22 = te[5],
			m23 = te[9],
			m31 = te[2],
			m32 = te[6],
			m33 = te[10];
		if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
			// singularity found
			// first check for identity matrix which must have +1 for all terms
			// in leading diagonal and zero in other terms

			if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
				// this singularity is identity matrix so angle = 0

				this.set(1, 0, 0, 0);
				return this; // zero angle, arbitrary axis
			}

			// otherwise this singularity is angle = 180

			angle = Math.PI;
			const xx = (m11 + 1) / 2;
			const yy = (m22 + 1) / 2;
			const zz = (m33 + 1) / 2;
			const xy = (m12 + m21) / 4;
			const xz = (m13 + m31) / 4;
			const yz = (m23 + m32) / 4;
			if (xx > yy && xx > zz) {
				// m11 is the largest diagonal term

				if (xx < epsilon) {
					x = 0;
					y = 0.707106781;
					z = 0.707106781;
				} else {
					x = Math.sqrt(xx);
					y = xy / x;
					z = xz / x;
				}
			} else if (yy > zz) {
				// m22 is the largest diagonal term

				if (yy < epsilon) {
					x = 0.707106781;
					y = 0;
					z = 0.707106781;
				} else {
					y = Math.sqrt(yy);
					x = xy / y;
					z = yz / y;
				}
			} else {
				// m33 is the largest diagonal term so base result on this

				if (zz < epsilon) {
					x = 0.707106781;
					y = 0.707106781;
					z = 0;
				} else {
					z = Math.sqrt(zz);
					x = xz / z;
					y = yz / z;
				}
			}
			this.set(x, y, z, angle);
			return this; // return 180 deg rotation
		}

		// as we have reached here there are no singularities so we can handle normally

		let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize

		if (Math.abs(s) < 0.001) s = 1;

		// prevent divide by zero, should not happen if matrix is orthogonal and should be
		// caught by singularity test above, but I've left it in just in case

		this.x = (m32 - m23) / s;
		this.y = (m13 - m31) / s;
		this.z = (m21 - m12) / s;
		this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
		return this;
	}
	min(v) {
		this.x = Math.min(this.x, v.x);
		this.y = Math.min(this.y, v.y);
		this.z = Math.min(this.z, v.z);
		this.w = Math.min(this.w, v.w);
		return this;
	}
	max(v) {
		this.x = Math.max(this.x, v.x);
		this.y = Math.max(this.y, v.y);
		this.z = Math.max(this.z, v.z);
		this.w = Math.max(this.w, v.w);
		return this;
	}
	clamp(min, max) {
		// assumes min < max, componentwise

		this.x = Math.max(min.x, Math.min(max.x, this.x));
		this.y = Math.max(min.y, Math.min(max.y, this.y));
		this.z = Math.max(min.z, Math.min(max.z, this.z));
		this.w = Math.max(min.w, Math.min(max.w, this.w));
		return this;
	}
	clampScalar(minVal, maxVal) {
		this.x = Math.max(minVal, Math.min(maxVal, this.x));
		this.y = Math.max(minVal, Math.min(maxVal, this.y));
		this.z = Math.max(minVal, Math.min(maxVal, this.z));
		this.w = Math.max(minVal, Math.min(maxVal, this.w));
		return this;
	}
	clampLength(min, max) {
		const length = this.length();
		return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
	}
	floor() {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		this.z = Math.floor(this.z);
		this.w = Math.floor(this.w);
		return this;
	}
	ceil() {
		this.x = Math.ceil(this.x);
		this.y = Math.ceil(this.y);
		this.z = Math.ceil(this.z);
		this.w = Math.ceil(this.w);
		return this;
	}
	round() {
		this.x = Math.round(this.x);
		this.y = Math.round(this.y);
		this.z = Math.round(this.z);
		this.w = Math.round(this.w);
		return this;
	}
	roundToZero() {
		this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
		this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
		this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
		this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
		return this;
	}
	negate() {
		this.x = -this.x;
		this.y = -this.y;
		this.z = -this.z;
		this.w = -this.w;
		return this;
	}
	dot(v) {
		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
	}
	lengthSq() {
		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
	}
	length() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
	}
	manhattanLength() {
		return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
	}
	normalize() {
		return this.divideScalar(this.length() || 1);
	}
	setLength(length) {
		return this.normalize().multiplyScalar(length);
	}
	lerp(v, alpha) {
		this.x += (v.x - this.x) * alpha;
		this.y += (v.y - this.y) * alpha;
		this.z += (v.z - this.z) * alpha;
		this.w += (v.w - this.w) * alpha;
		return this;
	}
	lerpVectors(v1, v2, alpha) {
		this.x = v1.x + (v2.x - v1.x) * alpha;
		this.y = v1.y + (v2.y - v1.y) * alpha;
		this.z = v1.z + (v2.z - v1.z) * alpha;
		this.w = v1.w + (v2.w - v1.w) * alpha;
		return this;
	}
	equals(v) {
		return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
	}
	fromArray(array, offset = 0) {
		this.x = array[offset];
		this.y = array[offset + 1];
		this.z = array[offset + 2];
		this.w = array[offset + 3];
		return this;
	}
	toArray(array = [], offset = 0) {
		array[offset] = this.x;
		array[offset + 1] = this.y;
		array[offset + 2] = this.z;
		array[offset + 3] = this.w;
		return array;
	}
	fromBufferAttribute(attribute, index) {
		this.x = attribute.getX(index);
		this.y = attribute.getY(index);
		this.z = attribute.getZ(index);
		this.w = attribute.getW(index);
		return this;
	}
	random() {
		this.x = Math.random();
		this.y = Math.random();
		this.z = Math.random();
		this.w = Math.random();
		return this;
	}
	*[Symbol.iterator]() {
		yield this.x;
		yield this.y;
		yield this.z;
		yield this.w;
	}
}

/*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/
class WebGLRenderTarget extends EventDispatcher {
	constructor(width = 1, height = 1, options = {}) {
		super();
		this.isWebGLRenderTarget = true;
		this.width = width;
		this.height = height;
		this.depth = 1;
		this.scissor = new Vector4(0, 0, width, height);
		this.scissorTest = false;
		this.viewport = new Vector4(0, 0, width, height);
		const image = {
			width: width,
			height: height,
			depth: 1
		};
		this.texture = new Texture(image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
		this.texture.isRenderTargetTexture = true;
		this.texture.flipY = false;
		this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
		this.texture.internalFormat = options.internalFormat !== undefined ? options.internalFormat : null;
		this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
		this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
		this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;
		this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
		this.samples = options.samples !== undefined ? options.samples : 0;
	}
	setSize(width, height, depth = 1) {
		if (this.width !== width || this.height !== height || this.depth !== depth) {
			this.width = width;
			this.height = height;
			this.depth = depth;
			this.texture.image.width = width;
			this.texture.image.height = height;
			this.texture.image.depth = depth;
			this.dispose();
		}
		this.viewport.set(0, 0, width, height);
		this.scissor.set(0, 0, width, height);
	}
	clone() {
		return new this.constructor().copy(this);
	}
	copy(source) {
		this.width = source.width;
		this.height = source.height;
		this.depth = source.depth;
		this.viewport.copy(source.viewport);
		this.texture = source.texture.clone();
		this.texture.isRenderTargetTexture = true;

		// ensure image object is not shared, see #20328

		const image = Object.assign({}, source.texture.image);
		this.texture.source = new Source(image);
		this.depthBuffer = source.depthBuffer;
		this.stencilBuffer = source.stencilBuffer;
		if (source.depthTexture !== null) this.depthTexture = source.depthTexture.clone();
		this.samples = source.samples;
		return this;
	}
	dispose() {
		this.dispatchEvent({
			type: 'dispose'
		});
	}
}

class DataArrayTexture extends Texture {
	constructor(data = null, width = 1, height = 1, depth = 1) {
		super(null);
		this.isDataArrayTexture = true;
		this.image = {
			data,
			width,
			height,
			depth
		};
		this.magFilter = NearestFilter;
		this.minFilter = NearestFilter;
		this.wrapR = ClampToEdgeWrapping;
		this.generateMipmaps = false;
		this.flipY = false;
		this.unpackAlignment = 1;
	}
}

class WebGLArrayRenderTarget extends WebGLRenderTarget {
	constructor(width = 1, height = 1, depth = 1) {
		super(width, height);
		this.isWebGLArrayRenderTarget = true;
		this.depth = depth;
		this.texture = new DataArrayTexture(null, width, height, depth);
		this.texture.isRenderTargetTexture = true;
	}
}

class Data3DTexture extends Texture {
	constructor(data = null, width = 1, height = 1, depth = 1) {
		// We're going to add .setXXX() methods for setting properties later.
		// Users can still set in DataTexture3D directly.
		//
		//	const texture = new THREE.DataTexture3D( data, width, height, depth );
		// 	texture.anisotropy = 16;
		//
		// See #14839

		super(null);
		this.isData3DTexture = true;
		this.image = {
			data,
			width,
			height,
			depth
		};
		this.magFilter = NearestFilter;
		this.minFilter = NearestFilter;
		this.wrapR = ClampToEdgeWrapping;
		this.generateMipmaps = false;
		this.flipY = false;
		this.unpackAlignment = 1;
	}
}

class WebGL3DRenderTarget extends WebGLRenderTarget {
	constructor(width = 1, height = 1, depth = 1) {
		super(width, height);
		this.isWebGL3DRenderTarget = true;
		this.depth = depth;
		this.texture = new Data3DTexture(null, width, height, depth);
		this.texture.isRenderTargetTexture = true;
	}
}

class WebGLMultipleRenderTargets extends WebGLRenderTarget {
	constructor(width = 1, height = 1, count = 1, options = {}) {
		super(width, height, options);
		this.isWebGLMultipleRenderTargets = true;
		const texture = this.texture;
		this.texture = [];
		for (let i = 0; i < count; i++) {
			this.texture[i] = texture.clone();
			this.texture[i].isRenderTargetTexture = true;
		}
	}
	setSize(width, height, depth = 1) {
		if (this.width !== width || this.height !== height || this.depth !== depth) {
			this.width = width;
			this.height = height;
			this.depth = depth;
			for (let i = 0, il = this.texture.length; i < il; i++) {
				this.texture[i].image.width = width;
				this.texture[i].image.height = height;
				this.texture[i].image.depth = depth;
			}
			this.dispose();
		}
		this.viewport.set(0, 0, width, height);
		this.scissor.set(0, 0, width, height);
		return this;
	}
	copy(source) {
		this.dispose();
		this.width = source.width;
		this.height = source.height;
		this.depth = source.depth;
		this.viewport.set(0, 0, this.width, this.height);
		this.scissor.set(0, 0, this.width, this.height);
		this.depthBuffer = source.depthBuffer;
		this.stencilBuffer = source.stencilBuffer;
		if (source.depthTexture !== null) this.depthTexture = source.depthTexture.clone();
		this.texture.length = 0;
		for (let i = 0, il = source.texture.length; i < il; i++) {
			this.texture[i] = source.texture[i].clone();
			this.texture[i].isRenderTargetTexture = true;
		}
		return this;
	}
}

class Quaternion {
	constructor(x = 0, y = 0, z = 0, w = 1) {
		this.isQuaternion = true;
		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;
	}
	static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
		// fuzz-free, array-based Quaternion SLERP operation

		let x0 = src0[srcOffset0 + 0],
			y0 = src0[srcOffset0 + 1],
			z0 = src0[srcOffset0 + 2],
			w0 = src0[srcOffset0 + 3];
		const x1 = src1[srcOffset1 + 0],
			y1 = src1[srcOffset1 + 1],
			z1 = src1[srcOffset1 + 2],
			w1 = src1[srcOffset1 + 3];
		if (t === 0) {
			dst[dstOffset + 0] = x0;
			dst[dstOffset + 1] = y0;
			dst[dstOffset + 2] = z0;
			dst[dstOffset + 3] = w0;
			return;
		}
		if (t === 1) {
			dst[dstOffset + 0] = x1;
			dst[dstOffset + 1] = y1;
			dst[dstOffset + 2] = z1;
			dst[dstOffset + 3] = w1;
			return;
		}
		if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
			let s = 1 - t;
			const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
				dir = cos >= 0 ? 1 : -1,
				sqrSin = 1 - cos * cos;

			// Skip the Slerp for tiny steps to avoid numeric problems:
			if (sqrSin > Number.EPSILON) {
				const sin = Math.sqrt(sqrSin),
					len = Math.atan2(sin, cos * dir);
				s = Math.sin(s * len) / sin;
				t = Math.sin(t * len) / sin;
			}
			const tDir = t * dir;
			x0 = x0 * s + x1 * tDir;
			y0 = y0 * s + y1 * tDir;
			z0 = z0 * s + z1 * tDir;
			w0 = w0 * s + w1 * tDir;

			// Normalize in case we just did a lerp:
			if (s === 1 - t) {
				const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
				x0 *= f;
				y0 *= f;
				z0 *= f;
				w0 *= f;
			}
		}
		dst[dstOffset] = x0;
		dst[dstOffset + 1] = y0;
		dst[dstOffset + 2] = z0;
		dst[dstOffset + 3] = w0;
	}
	static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
		const x0 = src0[srcOffset0];
		const y0 = src0[srcOffset0 + 1];
		const z0 = src0[srcOffset0 + 2];
		const w0 = src0[srcOffset0 + 3];
		const x1 = src1[srcOffset1];
		const y1 = src1[srcOffset1 + 1];
		const z1 = src1[srcOffset1 + 2];
		const w1 = src1[srcOffset1 + 3];
		dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
		dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
		dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
		dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
		return dst;
	}
	get x() {
		return this._x;
	}
	set x(value) {
		this._x = value;
		this._onChangeCallback();
	}
	get y() {
		return this._y;
	}
	set y(value) {
		this._y = value;
		this._onChangeCallback();
	}
	get z() {
		return this._z;
	}
	set z(value) {
		this._z = value;
		this._onChangeCallback();
	}
	get w() {
		return this._w;
	}
	set w(value) {
		this._w = value;
		this._onChangeCallback();
	}
	set(x, y, z, w) {
		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;
		this._onChangeCallback();
		return this;
	}
	clone() {
		return new this.constructor(this._x, this._y, this._z, this._w);
	}
	copy(quaternion) {
		this._x = quaternion.x;
		this._y = quaternion.y;
		this._z = quaternion.z;
		this._w = quaternion.w;
		this._onChangeCallback();
		return this;
	}
	setFromEuler(euler, update) {
		const x = euler._x,
			y = euler._y,
			z = euler._z,
			order = euler._order;

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		const cos = Math.cos;
		const sin = Math.sin;
		const c1 = cos(x / 2);
		const c2 = cos(y / 2);
		const c3 = cos(z / 2);
		const s1 = sin(x / 2);
		const s2 = sin(y / 2);
		const s3 = sin(z / 2);
		switch (order) {
			case 'XYZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;
			case 'YXZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;
			case 'ZXY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;
			case 'ZYX':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;
			case 'YZX':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;
			case 'XZY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;
			default:
				console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order);
		}
		if (update !== false) this._onChangeCallback();
		return this;
	}
	setFromAxisAngle(axis, angle) {
		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

		// assumes axis is normalized

		const halfAngle = angle / 2,
			s = Math.sin(halfAngle);
		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos(halfAngle);
		this._onChangeCallback();
		return this;
	}
	setFromRotationMatrix(m) {
		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		const te = m.elements,
			m11 = te[0],
			m12 = te[4],
			m13 = te[8],
			m21 = te[1],
			m22 = te[5],
			m23 = te[9],
			m31 = te[2],
			m32 = te[6],
			m33 = te[10],
			trace = m11 + m22 + m33;
		if (trace > 0) {
			const s = 0.5 / Math.sqrt(trace + 1.0);
			this._w = 0.25 / s;
			this._x = (m32 - m23) * s;
			this._y = (m13 - m31) * s;
			this._z = (m21 - m12) * s;
		} else if (m11 > m22 && m11 > m33) {
			const s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
			this._w = (m32 - m23) / s;
			this._x = 0.25 * s;
			this._y = (m12 + m21) / s;
			this._z = (m13 + m31) / s;
		} else if (m22 > m33) {
			const s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
			this._w = (m13 - m31) / s;
			this._x = (m12 + m21) / s;
			this._y = 0.25 * s;
			this._z = (m23 + m32) / s;
		} else {
			const s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
			this._w = (m21 - m12) / s;
			this._x = (m13 + m31) / s;
			this._y = (m23 + m32) / s;
			this._z = 0.25 * s;
		}
		this._onChangeCallback();
		return this;
	}
	setFromUnitVectors(vFrom, vTo) {
		// assumes direction vectors vFrom and vTo are normalized

		let r = vFrom.dot(vTo) + 1;
		if (r < Number.EPSILON) {
			// vFrom and vTo point in opposite directions

			r = 0;
			if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
				this._x = -vFrom.y;
				this._y = vFrom.x;
				this._z = 0;
				this._w = r;
			} else {
				this._x = 0;
				this._y = -vFrom.z;
				this._z = vFrom.y;
				this._w = r;
			}
		} else {
			// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

			this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
			this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
			this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
			this._w = r;
		}
		return this.normalize();
	}
	angleTo(q) {
		return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));
	}
	rotateTowards(q, step) {
		const angle = this.angleTo(q);
		if (angle === 0) return this;
		const t = Math.min(1, step / angle);
		this.slerp(q, t);
		return this;
	}
	identity() {
		return this.set(0, 0, 0, 1);
	}
	invert() {
		// quaternion is assumed to have unit length

		return this.conjugate();
	}
	conjugate() {
		this._x *= -1;
		this._y *= -1;
		this._z *= -1;
		this._onChangeCallback();
		return this;
	}
	dot(v) {
		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
	}
	lengthSq() {
		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
	}
	length() {
		return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
	}
	normalize() {
		let l = this.length();
		if (l === 0) {
			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;
		} else {
			l = 1 / l;
			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;
		}
		this._onChangeCallback();
		return this;
	}
	multiply(q) {
		return this.multiplyQuaternions(this, q);
	}
	premultiply(q) {
		return this.multiplyQuaternions(q, this);
	}
	multiplyQuaternions(a, b) {
		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		const qax = a._x,
			qay = a._y,
			qaz = a._z,
			qaw = a._w;
		const qbx = b._x,
			qby = b._y,
			qbz = b._z,
			qbw = b._w;
		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
		this._onChangeCallback();
		return this;
	}
	slerp(qb, t) {
		if (t === 0) return this;
		if (t === 1) return this.copy(qb);
		const x = this._x,
			y = this._y,
			z = this._z,
			w = this._w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
		if (cosHalfTheta < 0) {
			this._w = -qb._w;
			this._x = -qb._x;
			this._y = -qb._y;
			this._z = -qb._z;
			cosHalfTheta = -cosHalfTheta;
		} else {
			this.copy(qb);
		}
		if (cosHalfTheta >= 1.0) {
			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;
			return this;
		}
		const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;
		if (sqrSinHalfTheta <= Number.EPSILON) {
			const s = 1 - t;
			this._w = s * w + t * this._w;
			this._x = s * x + t * this._x;
			this._y = s * y + t * this._y;
			this._z = s * z + t * this._z;
			this.normalize();
			this._onChangeCallback();
			return this;
		}
		const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
		const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
		const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
			ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
		this._w = w * ratioA + this._w * ratioB;
		this._x = x * ratioA + this._x * ratioB;
		this._y = y * ratioA + this._y * ratioB;
		this._z = z * ratioA + this._z * ratioB;
		this._onChangeCallback();
		return this;
	}
	slerpQuaternions(qa, qb, t) {
		return this.copy(qa).slerp(qb, t);
	}
	random() {
		// Derived from http://planning.cs.uiuc.edu/node198.html
		// Note, this source uses w, x, y, z ordering,
		// so we swap the order below.

		const u1 = Math.random();
		const sqrt1u1 = Math.sqrt(1 - u1);
		const sqrtu1 = Math.sqrt(u1);
		const u2 = 2 * Math.PI * Math.random();
		const u3 = 2 * Math.PI * Math.random();
		return this.set(sqrt1u1 * Math.cos(u2), sqrtu1 * Math.sin(u3), sqrtu1 * Math.cos(u3), sqrt1u1 * Math.sin(u2));
	}
	equals(quaternion) {
		return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
	}
	fromArray(array, offset = 0) {
		this._x = array[offset];
		this._y = array[offset + 1];
		this._z = array[offset + 2];
		this._w = array[offset + 3];
		this._onChangeCallback();
		return this;
	}
	toArray(array = [], offset = 0) {
		array[offset] = this._x;
		array[offset + 1] = this._y;
		array[offset + 2] = this._z;
		array[offset + 3] = this._w;
		return array;
	}
	fromBufferAttribute(attribute, index) {
		this._x = attribute.getX(index);
		this._y = attribute.getY(index);
		this._z = attribute.getZ(index);
		this._w = attribute.getW(index);
		return this;
	}
	_onChange(callback) {
		this._onChangeCallback = callback;
		return this;
	}
	_onChangeCallback() {}
	*[Symbol.iterator]() {
		yield this._x;
		yield this._y;
		yield this._z;
		yield this._w;
	}
}

class Vector3 {
	constructor(x = 0, y = 0, z = 0) {
		Vector3.prototype.isVector3 = true;
		this.x = x;
		this.y = y;
		this.z = z;
	}
	set(x, y, z) {
		if (z === undefined) z = this.z; // sprite.scale.set(x,y)

		this.x = x;
		this.y = y;
		this.z = z;
		return this;
	}
	setScalar(scalar) {
		this.x = scalar;
		this.y = scalar;
		this.z = scalar;
		return this;
	}
	setX(x) {
		this.x = x;
		return this;
	}
	setY(y) {
		this.y = y;
		return this;
	}
	setZ(z) {
		this.z = z;
		return this;
	}
	setComponent(index, value) {
		switch (index) {
			case 0:
				this.x = value;
				break;
			case 1:
				this.y = value;
				break;
			case 2:
				this.z = value;
				break;
			default:
				throw new Error('index is out of range: ' + index);
		}
		return this;
	}
	getComponent(index) {
		switch (index) {
			case 0:
				return this.x;
			case 1:
				return this.y;
			case 2:
				return this.z;
			default:
				throw new Error('index is out of range: ' + index);
		}
	}
	clone() {
		return new this.constructor(this.x, this.y, this.z);
	}
	copy(v) {
		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		return this;
	}
	add(v) {
		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		return this;
	}
	addScalar(s) {
		this.x += s;
		this.y += s;
		this.z += s;
		return this;
	}
	addVectors(a, b) {
		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;
		return this;
	}
	addScaledVector(v, s) {
		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;
		return this;
	}
	sub(v) {
		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		return this;
	}
	subScalar(s) {
		this.x -= s;
		this.y -= s;
		this.z -= s;
		return this;
	}
	subVectors(a, b) {
		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;
		return this;
	}
	multiply(v) {
		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;
		return this;
	}
	multiplyScalar(scalar) {
		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;
		return this;
	}
	multiplyVectors(a, b) {
		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;
		return this;
	}
	applyEuler(euler) {
		return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
	}
	applyAxisAngle(axis, angle) {
		return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
	}
	applyMatrix3(m) {
		const x = this.x,
			y = this.y,
			z = this.z;
		const e = m.elements;
		this.x = e[0] * x + e[3] * y + e[6] * z;
		this.y = e[1] * x + e[4] * y + e[7] * z;
		this.z = e[2] * x + e[5] * y + e[8] * z;
		return this;
	}
	applyNormalMatrix(m) {
		return this.applyMatrix3(m).normalize();
	}
	applyMatrix4(m) {
		const x = this.x,
			y = this.y,
			z = this.z;
		const e = m.elements;
		const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
		this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
		this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
		this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
		return this;
	}
	applyQuaternion(q) {
		const x = this.x,
			y = this.y,
			z = this.z;
		const qx = q.x,
			qy = q.y,
			qz = q.z,
			qw = q.w;

		// calculate quat * vector

		const ix = qw * x + qy * z - qz * y;
		const iy = qw * y + qz * x - qx * z;
		const iz = qw * z + qx * y - qy * x;
		const iw = -qx * x - qy * y - qz * z;

		// calculate result * inverse quat

		this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
		this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
		this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
		return this;
	}
	project(camera) {
		return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
	}
	unproject(camera) {
		return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
	}
	transformDirection(m) {
		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		const x = this.x,
			y = this.y,
			z = this.z;
		const e = m.elements;
		this.x = e[0] * x + e[4] * y + e[8] * z;
		this.y = e[1] * x + e[5] * y + e[9] * z;
		this.z = e[2] * x + e[6] * y + e[10] * z;
		return this.normalize();
	}
	divide(v) {
		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;
		return this;
	}
	divideScalar(scalar) {
		return this.multiplyScalar(1 / scalar);
	}
	min(v) {
		this.x = Math.min(this.x, v.x);
		this.y = Math.min(this.y, v.y);
		this.z = Math.min(this.z, v.z);
		return this;
	}
	max(v) {
		this.x = Math.max(this.x, v.x);
		this.y = Math.max(this.y, v.y);
		this.z = Math.max(this.z, v.z);
		return this;
	}
	clamp(min, max) {
		// assumes min < max, componentwise

		this.x = Math.max(min.x, Math.min(max.x, this.x));
		this.y = Math.max(min.y, Math.min(max.y, this.y));
		this.z = Math.max(min.z, Math.min(max.z, this.z));
		return this;
	}
	clampScalar(minVal, maxVal) {
		this.x = Math.max(minVal, Math.min(maxVal, this.x));
		this.y = Math.max(minVal, Math.min(maxVal, this.y));
		this.z = Math.max(minVal, Math.min(maxVal, this.z));
		return this;
	}
	clampLength(min, max) {
		const length = this.length();
		return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
	}
	floor() {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		this.z = Math.floor(this.z);
		return this;
	}
	ceil() {
		this.x = Math.ceil(this.x);
		this.y = Math.ceil(this.y);
		this.z = Math.ceil(this.z);
		return this;
	}
	round() {
		this.x = Math.round(this.x);
		this.y = Math.round(this.y);
		this.z = Math.round(this.z);
		return this;
	}
	roundToZero() {
		this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
		this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
		this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
		return this;
	}
	negate() {
		this.x = -this.x;
		this.y = -this.y;
		this.z = -this.z;
		return this;
	}
	dot(v) {
		return this.x * v.x + this.y * v.y + this.z * v.z;
	}

	// TODO lengthSquared?

	lengthSq() {
		return this.x * this.x + this.y * this.y + this.z * this.z;
	}
	length() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
	}
	manhattanLength() {
		return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
	}
	normalize() {
		return this.divideScalar(this.length() || 1);
	}
	setLength(length) {
		return this.normalize().multiplyScalar(length);
	}
	lerp(v, alpha) {
		this.x += (v.x - this.x) * alpha;
		this.y += (v.y - this.y) * alpha;
		this.z += (v.z - this.z) * alpha;
		return this;
	}
	lerpVectors(v1, v2, alpha) {
		this.x = v1.x + (v2.x - v1.x) * alpha;
		this.y = v1.y + (v2.y - v1.y) * alpha;
		this.z = v1.z + (v2.z - v1.z) * alpha;
		return this;
	}
	cross(v) {
		return this.crossVectors(this, v);
	}
	crossVectors(a, b) {
		const ax = a.x,
			ay = a.y,
			az = a.z;
		const bx = b.x,
			by = b.y,
			bz = b.z;
		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;
		return this;
	}
	projectOnVector(v) {
		const denominator = v.lengthSq();
		if (denominator === 0) return this.set(0, 0, 0);
		const scalar = v.dot(this) / denominator;
		return this.copy(v).multiplyScalar(scalar);
	}
	projectOnPlane(planeNormal) {
		_vector$c.copy(this).projectOnVector(planeNormal);
		return this.sub(_vector$c);
	}
	reflect(normal) {
		// reflect incident vector off plane orthogonal to normal
		// normal is assumed to have unit length

		return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
	}
	angleTo(v) {
		const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
		if (denominator === 0) return Math.PI / 2;
		const theta = this.dot(v) / denominator;

		// clamp, to handle numerical problems

		return Math.acos(clamp(theta, -1, 1));
	}
	distanceTo(v) {
		return Math.sqrt(this.distanceToSquared(v));
	}
	distanceToSquared(v) {
		const dx = this.x - v.x,
			dy = this.y - v.y,
			dz = this.z - v.z;
		return dx * dx + dy * dy + dz * dz;
	}
	manhattanDistanceTo(v) {
		return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
	}
	setFromSpherical(s) {
		return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
	}
	setFromSphericalCoords(radius, phi, theta) {
		const sinPhiRadius = Math.sin(phi) * radius;
		this.x = sinPhiRadius * Math.sin(theta);
		this.y = Math.cos(phi) * radius;
		this.z = sinPhiRadius * Math.cos(theta);
		return this;
	}
	setFromCylindrical(c) {
		return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
	}
	setFromCylindricalCoords(radius, theta, y) {
		this.x = radius * Math.sin(theta);
		this.y = y;
		this.z = radius * Math.cos(theta);
		return this;
	}
	setFromMatrixPosition(m) {
		const e = m.elements;
		this.x = e[12];
		this.y = e[13];
		this.z = e[14];
		return this;
	}
	setFromMatrixScale(m) {
		const sx = this.setFromMatrixColumn(m, 0).length();
		const sy = this.setFromMatrixColumn(m, 1).length();
		const sz = this.setFromMatrixColumn(m, 2).length();
		this.x = sx;
		this.y = sy;
		this.z = sz;
		return this;
	}
	setFromMatrixColumn(m, index) {
		return this.fromArray(m.elements, index * 4);
	}
	setFromMatrix3Column(m, index) {
		return this.fromArray(m.elements, index * 3);
	}
	setFromEuler(e) {
		this.x = e._x;
		this.y = e._y;
		this.z = e._z;
		return this;
	}
	equals(v) {
		return v.x === this.x && v.y === this.y && v.z === this.z;
	}
	fromArray(array, offset = 0) {
		this.x = array[offset];
		this.y = array[offset + 1];
		this.z = array[offset + 2];
		return this;
	}
	toArray(array = [], offset = 0) {
		array[offset] = this.x;
		array[offset + 1] = this.y;
		array[offset + 2] = this.z;
		return array;
	}
	fromBufferAttribute(attribute, index) {
		this.x = attribute.getX(index);
		this.y = attribute.getY(index);
		this.z = attribute.getZ(index);
		return this;
	}
	random() {
		this.x = Math.random();
		this.y = Math.random();
		this.z = Math.random();
		return this;
	}
	randomDirection() {
		// Derived from https://mathworld.wolfram.com/SpherePointPicking.html

		const u = (Math.random() - 0.5) * 2;
		const t = Math.random() * Math.PI * 2;
		const f = Math.sqrt(1 - u ** 2);
		this.x = f * Math.cos(t);
		this.y = f * Math.sin(t);
		this.z = u;
		return this;
	}
	*[Symbol.iterator]() {
		yield this.x;
		yield this.y;
		yield this.z;
	}
}
const _vector$c = /*@__PURE__*/new Vector3();
const _quaternion$4 = /*@__PURE__*/new Quaternion();

class Box3 {
	constructor(min = new Vector3(+Infinity, +Infinity, +Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
		this.isBox3 = true;
		this.min = min;
		this.max = max;
	}
	set(min, max) {
		this.min.copy(min);
		this.max.copy(max);
		return this;
	}
	setFromArray(array) {
		let minX = +Infinity;
		let minY = +Infinity;
		let minZ = +Infinity;
		let maxX = -Infinity;
		let maxY = -Infinity;
		let maxZ = -Infinity;
		for (let i = 0, l = array.length; i < l; i += 3) {
			const x = array[i];
			const y = array[i + 1];
			const z = array[i + 2];
			if (x < minX) minX = x;
			if (y < minY) minY = y;
			if (z < minZ) minZ = z;
			if (x > maxX) maxX = x;
			if (y > maxY) maxY = y;
			if (z > maxZ) maxZ = z;
		}
		this.min.set(minX, minY, minZ);
		this.max.set(maxX, maxY, maxZ);
		return this;
	}
	setFromBufferAttribute(attribute) {
		let minX = +Infinity;
		let minY = +Infinity;
		let minZ = +Infinity;
		let maxX = -Infinity;
		let maxY = -Infinity;
		let maxZ = -Infinity;
		for (let i = 0, l = attribute.count; i < l; i++) {
			const x = attribute.getX(i);
			const y = attribute.getY(i);
			const z = attribute.getZ(i);
			if (x < minX) minX = x;
			if (y < minY) minY = y;
			if (z < minZ) minZ = z;
			if (x > maxX) maxX = x;
			if (y > maxY) maxY = y;
			if (z > maxZ) maxZ = z;
		}
		this.min.set(minX, minY, minZ);
		this.max.set(maxX, maxY, maxZ);
		return this;
	}
	setFromPoints(points) {
		this.makeEmpty();
		for (let i = 0, il = points.length; i < il; i++) {
			this.expandByPoint(points[i]);
		}
		return this;
	}
	setFromCenterAndSize(center, size) {
		const halfSize = _vector$b.copy(size).multiplyScalar(0.5);
		this.min.copy(center).sub(halfSize);
		this.max.copy(center).add(halfSize);
		return this;
	}
	setFromObject(object, precise = false) {
		this.makeEmpty();
		return this.expandByObject(object, precise);
	}
	clone() {
		return new this.constructor().copy(this);
	}
	copy(box) {
		this.min.copy(box.min);
		this.max.copy(box.max);
		return this;
	}
	makeEmpty() {
		this.min.x = this.min.y = this.min.z = +Infinity;
		this.max.x = this.max.y = this.max.z = -Infinity;
		return this;
	}
	isEmpty() {
		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
	}
	getCenter(target) {
		return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
	}
	getSize(target) {
		return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
	}
	expandByPoint(point) {
		this.min.min(point);
		this.max.max(point);
		return this;
	}
	expandByVector(vector) {
		this.min.sub(vector);
		this.max.add(vector);
		return this;
	}
	expandByScalar(scalar) {
		this.min.addScalar(-scalar);
		this.max.addScalar(scalar);
		return this;
	}
	expandByObject(object, precise = false) {
		// Computes the world-axis-aligned bounding box of an object (including its children),
		// accounting for both the object's, and children's, world transforms

		object.updateWorldMatrix(false, false);
		const geometry = object.geometry;
		if (geometry !== undefined) {
			if (precise && geometry.attributes != undefined && geometry.attributes.position !== undefined) {
				const position = geometry.attributes.position;
				for (let i = 0, l = position.count; i < l; i++) {
					_vector$b.fromBufferAttribute(position, i).applyMatrix4(object.matrixWorld);
					this.expandByPoint(_vector$b);
				}
			} else {
				if (geometry.boundingBox === null) {
					geometry.computeBoundingBox();
				}
				_box$3.copy(geometry.boundingBox);
				_box$3.applyMatrix4(object.matrixWorld);
				this.union(_box$3);
			}
		}
		const children = object.children;
		for (let i = 0, l = children.length; i < l; i++) {
			this.expandByObject(children[i], precise);
		}
		return this;
	}
	containsPoint(point) {
		return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
	}
	containsBox(box) {
		return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
	}
	getParameter(point, target) {
		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
	}
	intersectsBox(box) {
		// using 6 splitting planes to rule out intersections.
		return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
	}
	intersectsSphere(sphere) {
		// Find the point on the AABB closest to the sphere center.
		this.clampPoint(sphere.center, _vector$b);

		// If that point is inside the sphere, the AABB and sphere intersect.
		return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
	}
	intersectsPlane(plane) {
		// We compute the minimum and maximum dot product values. If those values
		// are on the same side (back or front) of the plane, then there is no intersection.

		let min, max;
		if (plane.normal.x > 0) {
			min = plane.normal.x * this.min.x;
			max = plane.normal.x * this.max.x;
		} else {
			min = plane.normal.x * this.max.x;
			max = plane.normal.x * this.min.x;
		}
		if (plane.normal.y > 0) {
			min += plane.normal.y * this.min.y;
			max += plane.normal.y * this.max.y;
		} else {
			min += plane.normal.y * this.max.y;
			max += plane.normal.y * this.min.y;
		}
		if (plane.normal.z > 0) {
			min += plane.normal.z * this.min.z;
			max += plane.normal.z * this.max.z;
		} else {
			min += plane.normal.z * this.max.z;
			max += plane.normal.z * this.min.z;
		}
		return min <= -plane.constant && max >= -plane.constant;
	}
	intersectsTriangle(triangle) {
		if (this.isEmpty()) {
			return false;
		}

		// compute box center and extents
		this.getCenter(_center);
		_extents.subVectors(this.max, _center);

		// translate triangle to aabb origin
		_v0$2.subVectors(triangle.a, _center);
		_v1$7.subVectors(triangle.b, _center);
		_v2$4.subVectors(triangle.c, _center);

		// compute edge vectors for triangle
		_f0.subVectors(_v1$7, _v0$2);
		_f1.subVectors(_v2$4, _v1$7);
		_f2.subVectors(_v0$2, _v2$4);

		// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
		// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
		// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
		let axes = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];
		if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
			return false;
		}

		// test 3 face normals from the aabb
		axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
		if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
			return false;
		}

		// finally testing the face normal of the triangle
		// use already existing triangle edge vectors here
		_triangleNormal.crossVectors(_f0, _f1);
		axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
		return satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents);
	}
	clampPoint(point, target) {
		return target.copy(point).clamp(this.min, this.max);
	}
	distanceToPoint(point) {
		const clampedPoint = _vector$b.copy(point).clamp(this.min, this.max);
		return clampedPoint.sub(point).length();
	}
	getBoundingSphere(target) {
		this.getCenter(target.center);
		target.radius = this.getSize(_vector$b).length() * 0.5;
		return target;
	}
	intersect(box) {
		this.min.max(box.min);
		this.max.min(box.max);

		// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
		if (this.isEmpty()) this.makeEmpty();
		return this;
	}
	union(box) {
		this.min.min(box.min);
		this.max.max(box.max);
		return this;
	}
	applyMatrix4(matrix) {
		// transform of empty box is an empty box.
		if (this.isEmpty()) return this;

		// NOTE: I am using a binary pattern to specify all 2^3 combinations below
		_points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000
		_points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001
		_points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010
		_points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011
		_points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100
		_points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101
		_points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110
		_points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111

		this.setFromPoints(_points);
		return this;
	}
	translate(offset) {
		this.min.add(offset);
		this.max.add(offset);
		return this;
	}
	equals(box) {
		return box.min.equals(this.min) && box.max.equals(this.max);
	}
}
const _points = [/*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3()];
const _vector$b = /*@__PURE__*/new Vector3();
const _box$3 = /*@__PURE__*/new Box3();

// triangle centered vertices

const _v0$2 = /*@__PURE__*/new Vector3();
const _v1$7 = /*@__PURE__*/new Vector3();
const _v2$4 = /*@__PURE__*/new Vector3();

// triangle edge vectors

const _f0 = /*@__PURE__*/new Vector3();
const _f1 = /*@__PURE__*/new Vector3();
const _f2 = /*@__PURE__*/new Vector3();
const _center = /*@__PURE__*/new Vector3();
const _extents = /*@__PURE__*/new Vector3();
const _triangleNormal = /*@__PURE__*/new Vector3();
const _testAxis = /*@__PURE__*/new Vector3();
function satForAxes(axes, v0, v1, v2, extents) {
	for (let i = 0, j = axes.length - 3; i <= j; i += 3) {
		_testAxis.fromArray(axes, i);
		// project the aabb onto the separating axis
		const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
		// project all 3 vertices of the triangle onto the separating axis
		const p0 = v0.dot(_testAxis);
		const p1 = v1.dot(_testAxis);
		const p2 = v2.dot(_testAxis);
		// actual test, basically see if either of the most extreme of the triangle points intersects r
		if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
			// points of the projected triangle are outside the projected half-length of the aabb
			// the axis is separating and we can exit
			return false;
		}
	}
	return true;
}

const _box$2 = /*@__PURE__*/new Box3();
const _v1$6 = /*@__PURE__*/new Vector3();
const _v2$3 = /*@__PURE__*/new Vector3();
class Sphere {
	constructor(center = new Vector3(), radius = -1) {
		this.center = center;
		this.radius = radius;
	}
	set(center, radius) {
		this.center.copy(center);
		this.radius = radius;
		return this;
	}
	setFromPoints(points, optionalCenter) {
		const center = this.center;
		if (optionalCenter !== undefined) {
			center.copy(optionalCenter);
		} else {
			_box$2.setFromPoints(points).getCenter(center);
		}
		let maxRadiusSq = 0;
		for (let i = 0, il = points.length; i < il; i++) {
			maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
		}
		this.radius = Math.sqrt(maxRadiusSq);
		return this;
	}
	copy(sphere) {
		this.center.copy(sphere.center);
		this.radius = sphere.radius;
		return this;
	}
	isEmpty() {
		return this.radius < 0;
	}
	makeEmpty() {
		this.center.set(0, 0, 0);
		this.radius = -1;
		return this;
	}
	containsPoint(point) {
		return point.distanceToSquared(this.center) <= this.radius * this.radius;
	}
	distanceToPoint(point) {
		return point.distanceTo(this.center) - this.radius;
	}
	intersectsSphere(sphere) {
		const radiusSum = this.radius + sphere.radius;
		return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
	}
	intersectsBox(box) {
		return box.intersectsSphere(this);
	}
	intersectsPlane(plane) {
		return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
	}
	clampPoint(point, target) {
		const deltaLengthSq = this.center.distanceToSquared(point);
		target.copy(point);
		if (deltaLengthSq > this.radius * this.radius) {
			target.sub(this.center).normalize();
			target.multiplyScalar(this.radius).add(this.center);
		}
		return target;
	}
	getBoundingBox(target) {
		if (this.isEmpty()) {
			// Empty sphere produces empty bounding box
			target.makeEmpty();
			return target;
		}
		target.set(this.center, this.center);
		target.expandByScalar(this.radius);
		return target;
	}
	applyMatrix4(matrix) {
		this.center.applyMatrix4(matrix);
		this.radius = this.radius * matrix.getMaxScaleOnAxis();
		return this;
	}
	translate(offset) {
		this.center.add(offset);
		return this;
	}
	expandByPoint(point) {
		if (this.isEmpty()) {
			this.center.copy(point);
			this.radius = 0;
			return this;
		}
		_v1$6.subVectors(point, this.center);
		const lengthSq = _v1$6.lengthSq();
		if (lengthSq > this.radius * this.radius) {
			// calculate the minimal sphere

			const length = Math.sqrt(lengthSq);
			const delta = (length - this.radius) * 0.5;
			this.center.addScaledVector(_v1$6, delta / length);
			this.radius += delta;
		}
		return this;
	}
	union(sphere) {
		if (sphere.isEmpty()) {
			return this;
		}
		if (this.isEmpty()) {
			this.copy(sphere);
			return this;
		}
		if (this.center.equals(sphere.center) === true) {
			this.radius = Math.max(this.radius, sphere.radius);
		} else {
			_v2$3.subVectors(sphere.center, this.center).setLength(sphere.radius);
			this.expandByPoint(_v1$6.copy(sphere.center).add(_v2$3));
			this.expandByPoint(_v1$6.copy(sphere.center).sub(_v2$3));
		}
		return this;
	}
	equals(sphere) {
		return sphere.center.equals(this.center) && sphere.radius === this.radius;
	}
	clone() {
		return new this.constructor().copy(this);
	}
}

const _vector$a = /*@__PURE__*/new Vector3();
const _segCenter = /*@__PURE__*/new Vector3();
const _segDir = /*@__PURE__*/new Vector3();
const _diff = /*@__PURE__*/new Vector3();
const _edge1 = /*@__PURE__*/new Vector3();
const _edge2 = /*@__PURE__*/new Vector3();
const _normal$1 = /*@__PURE__*/new Vector3();
class Ray {
	constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
		this.origin = origin;
		this.direction = direction;
	}
	set(origin, direction) {
		this.origin.copy(origin);
		this.direction.copy(direction);
		return this;
	}
	copy(ray) {
		this.origin.copy(ray.origin);
		this.direction.copy(ray.direction);
		return this;
	}
	at(t, target) {
		return target.copy(this.direction).multiplyScalar(t).add(this.origin);
	}
	lookAt(v) {
		this.direction.copy(v).sub(this.origin).normalize();
		return this;
	}
	recast(t) {
		this.origin.copy(this.at(t, _vector$a));
		return this;
	}
	closestPointToPoint(point, target) {
		target.subVectors(point, this.origin);
		const directionDistance = target.dot(this.direction);
		if (directionDistance < 0) {
			return target.copy(this.origin);
		}
		return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
	}
	distanceToPoint(point) {
		return Math.sqrt(this.distanceSqToPoint(point));
	}
	distanceSqToPoint(point) {
		const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);

		// point behind the ray

		if (directionDistance < 0) {
			return this.origin.distanceToSquared(point);
		}
		_vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
		return _vector$a.distanceToSquared(point);
	}
	distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
		// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h
		// It returns the min distance between the ray and the segment
		// defined by v0 and v1
		// It can also set two optional targets :
		// - The closest point on the ray
		// - The closest point on the segment

		_segCenter.copy(v0).add(v1).multiplyScalar(0.5);
		_segDir.copy(v1).sub(v0).normalize();
		_diff.copy(this.origin).sub(_segCenter);
		const segExtent = v0.distanceTo(v1) * 0.5;
		const a01 = -this.direction.dot(_segDir);
		const b0 = _diff.dot(this.direction);
		const b1 = -_diff.dot(_segDir);
		const c = _diff.lengthSq();
		const det = Math.abs(1 - a01 * a01);
		let s0, s1, sqrDist, extDet;
		if (det > 0) {
			// The ray and segment are not parallel.

			s0 = a01 * b1 - b0;
			s1 = a01 * b0 - b1;
			extDet = segExtent * det;
			if (s0 >= 0) {
				if (s1 >= -extDet) {
					if (s1 <= extDet) {
						// region 0
						// Minimum at interior points of ray and segment.

						const invDet = 1 / det;
						s0 *= invDet;
						s1 *= invDet;
						sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
					} else {
						// region 1

						s1 = segExtent;
						s0 = Math.max(0, -(a01 * s1 + b0));
						sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
					}
				} else {
					// region 5

					s1 = -segExtent;
					s0 = Math.max(0, -(a01 * s1 + b0));
					sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
				}
			} else {
				if (s1 <= -extDet) {
					// region 4

					s0 = Math.max(0, -(-a01 * segExtent + b0));
					s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
					sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
				} else if (s1 <= extDet) {
					// region 3

					s0 = 0;
					s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
					sqrDist = s1 * (s1 + 2 * b1) + c;
				} else {
					// region 2

					s0 = Math.max(0, -(a01 * segExtent + b0));
					s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
					sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
				}
			}
		} else {
			// Ray and segment are parallel.

			s1 = a01 > 0 ? -segExtent : segExtent;
			s0 = Math.max(0, -(a01 * s1 + b0));
			sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
		}
		if (optionalPointOnRay) {
			optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
		}
		if (optionalPointOnSegment) {
			optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
		}
		return sqrDist;
	}
	intersectSphere(sphere, target) {
		_vector$a.subVectors(sphere.center, this.origin);
		const tca = _vector$a.dot(this.direction);
		const d2 = _vector$a.dot(_vector$a) - tca * tca;
		const radius2 = sphere.radius * sphere.radius;
		if (d2 > radius2) return null;
		const thc = Math.sqrt(radius2 - d2);

		// t0 = first intersect point - entrance on front of sphere
		const t0 = tca - thc;

		// t1 = second intersect point - exit point on back of sphere
		const t1 = tca + thc;

		// test to see if both t0 and t1 are behind the ray - if so, return null
		if (t0 < 0 && t1 < 0) return null;

		// test to see if t0 is behind the ray:
		// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
		// in order to always return an intersect point that is in front of the ray.
		if (t0 < 0) return this.at(t1, target);

		// else t0 is in front of the ray, so return the first collision point scaled by t0
		return this.at(t0, target);
	}
	intersectsSphere(sphere) {
		return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
	}
	distanceToPlane(plane) {
		const denominator = plane.normal.dot(this.direction);
		if (denominator === 0) {
			// line is coplanar, return origin
			if (plane.distanceToPoint(this.origin) === 0) {
				return 0;
			}

			// Null is preferable to undefined since undefined means.... it is undefined

			return null;
		}
		const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;

		// Return if the ray never intersects the plane

		return t >= 0 ? t : null;
	}
	intersectPlane(plane, target) {
		const t = this.distanceToPlane(plane);
		if (t === null) {
			return null;
		}
		return this.at(t, target);
	}
	intersectsPlane(plane) {
		// check if the ray lies on the plane first

		const distToPoint = plane.distanceToPoint(this.origin);
		if (distToPoint === 0) {
			return true;
		}
		const denominator = plane.normal.dot(this.direction);
		if (denominator * distToPoint < 0) {
			return true;
		}

		// ray origin is behind the plane (and is pointing behind it)

		return false;
	}
	intersectBox(box, target) {
		let tmin, tmax, tymin, tymax, tzmin, tzmax;
		const invdirx = 1 / this.direction.x,
			invdiry = 1 / this.direction.y,
			invdirz = 1 / this.direction.z;
		const origin = this.origin;
		if (invdirx >= 0) {
			tmin = (box.min.x - origin.x) * invdirx;
			tmax = (box.max.x - origin.x) * invdirx;
		} else {
			tmin = (box.max.x - origin.x) * invdirx;
			tmax = (box.min.x - origin.x) * invdirx;
		}
		if (invdiry >= 0) {
			tymin = (box.min.y - origin.y) * invdiry;
			tymax = (box.max.y - origin.y) * invdiry;
		} else {
			tymin = (box.max.y - origin.y) * invdiry;
			tymax = (box.min.y - origin.y) * invdiry;
		}
		if (tmin > tymax || tymin > tmax) return null;
		if (tymin > tmin || isNaN(tmin)) tmin = tymin;
		if (tymax < tmax || isNaN(tmax)) tmax = tymax;
		if (invdirz >= 0) {
			tzmin = (box.min.z - origin.z) * invdirz;
			tzmax = (box.max.z - origin.z) * invdirz;
		} else {
			tzmin = (box.max.z - origin.z) * invdirz;
			tzmax = (box.min.z - origin.z) * invdirz;
		}
		if (tmin > tzmax || tzmin > tmax) return null;
		if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
		if (tzmax < tmax || tmax !== tmax) tmax = tzmax;

		//return point closest to the ray (positive side)

		if (tmax < 0) return null;
		return this.at(tmin >= 0 ? tmin : tmax, target);
	}
	intersectsBox(box) {
		return this.intersectBox(box, _vector$a) !== null;
	}
	intersectTriangle(a, b, c, backfaceCulling, target) {
		// Compute the offset origin, edges, and normal.

		// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

		_edge1.subVectors(b, a);
		_edge2.subVectors(c, a);
		_normal$1.crossVectors(_edge1, _edge2);

		// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
		// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
		//	 |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
		//	 |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
		//	 |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
		let DdN = this.direction.dot(_normal$1);
		let sign;
		if (DdN > 0) {
			if (backfaceCulling) return null;
			sign = 1;
		} else if (DdN < 0) {
			sign = -1;
			DdN = -DdN;
		} else {
			return null;
		}
		_diff.subVectors(this.origin, a);
		const DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2));

		// b1 < 0, no intersection
		if (DdQxE2 < 0) {
			return null;
		}
		const DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff));

		// b2 < 0, no intersection
		if (DdE1xQ < 0) {
			return null;
		}

		// b1+b2 > 1, no intersection
		if (DdQxE2 + DdE1xQ > DdN) {
			return null;
		}

		// Line intersects triangle, check if ray does.
		const QdN = -sign * _diff.dot(_normal$1);

		// t < 0, no intersection
		if (QdN < 0) {
			return null;
		}

		// Ray intersects triangle.
		return this.at(QdN / DdN, target);
	}
	applyMatrix4(matrix4) {
		this.origin.applyMatrix4(matrix4);
		this.direction.transformDirection(matrix4);
		return this;
	}
	equals(ray) {
		return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
	}
	clone() {
		return new this.constructor().copy(this);
	}
}

class Matrix4 {
	constructor() {
		Matrix4.prototype.isMatrix4 = true;
		this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
	}
	set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
		const te = this.elements;
		te[0] = n11;
		te[4] = n12;
		te[8] = n13;
		te[12] = n14;
		te[1] = n21;
		te[5] = n22;
		te[9] = n23;
		te[13] = n24;
		te[2] = n31;
		te[6] = n32;
		te[10] = n33;
		te[14] = n34;
		te[3] = n41;
		te[7] = n42;
		te[11] = n43;
		te[15] = n44;
		return this;
	}
	identity() {
		this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
		return this;
	}
	clone() {
		return new Matrix4().fromArray(this.elements);
	}
	copy(m) {
		const te = this.elements;
		const me = m.elements;
		te[0] = me[0];
		te[1] = me[1];
		te[2] = me[2];
		te[3] = me[3];
		te[4] = me[4];
		te[5] = me[5];
		te[6] = me[6];
		te[7] = me[7];
		te[8] = me[8];
		te[9] = me[9];
		te[10] = me[10];
		te[11] = me[11];
		te[12] = me[12];
		te[13] = me[13];
		te[14] = me[14];
		te[15] = me[15];
		return this;
	}
	copyPosition(m) {
		const te = this.elements,
			me = m.elements;
		te[12] = me[12];
		te[13] = me[13];
		te[14] = me[14];
		return this;
	}
	setFromMatrix3(m) {
		const me = m.elements;
		this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
		return this;
	}
	extractBasis(xAxis, yAxis, zAxis) {
		xAxis.setFromMatrixColumn(this, 0);
		yAxis.setFromMatrixColumn(this, 1);
		zAxis.setFromMatrixColumn(this, 2);
		return this;
	}
	makeBasis(xAxis, yAxis, zAxis) {
		this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
		return this;
	}
	extractRotation(m) {
		// this method does not support reflection matrices

		const te = this.elements;
		const me = m.elements;
		const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();
		const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();
		const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();
		te[0] = me[0] * scaleX;
		te[1] = me[1] * scaleX;
		te[2] = me[2] * scaleX;
		te[3] = 0;
		te[4] = me[4] * scaleY;
		te[5] = me[5] * scaleY;
		te[6] = me[6] * scaleY;
		te[7] = 0;
		te[8] = me[8] * scaleZ;
		te[9] = me[9] * scaleZ;
		te[10] = me[10] * scaleZ;
		te[11] = 0;
		te[12] = 0;
		te[13] = 0;
		te[14] = 0;
		te[15] = 1;
		return this;
	}
	makeRotationFromEuler(euler) {
		const te = this.elements;
		const x = euler.x,
			y = euler.y,
			z = euler.z;
		const a = Math.cos(x),
			b = Math.sin(x);
		const c = Math.cos(y),
			d = Math.sin(y);
		const e = Math.cos(z),
			f = Math.sin(z);
		if (euler.order === 'XYZ') {
			const ae = a * e,
				af = a * f,
				be = b * e,
				bf = b * f;
			te[0] = c * e;
			te[4] = -c * f;
			te[8] = d;
			te[1] = af + be * d;
			te[5] = ae - bf * d;
			te[9] = -b * c;
			te[2] = bf - ae * d;
			te[6] = be + af * d;
			te[10] = a * c;
		} else if (euler.order === 'YXZ') {
			const ce = c * e,
				cf = c * f,
				de = d * e,
				df = d * f;
			te[0] = ce + df * b;
			te[4] = de * b - cf;
			te[8] = a * d;
			te[1] = a * f;
			te[5] = a * e;
			te[9] = -b;
			te[2] = cf * b - de;
			te[6] = df + ce * b;
			te[10] = a * c;
		} else if (euler.order === 'ZXY') {
			const ce = c * e,
				cf = c * f,
				de = d * e,
				df = d * f;
			te[0] = ce - df * b;
			te[4] = -a * f;
			te[8] = de + cf * b;
			te[1] = cf + de * b;
			te[5] = a * e;
			te[9] = df - ce * b;
			te[2] = -a * d;
			te[6] = b;
			te[10] = a * c;
		} else if (euler.order === 'ZYX') {
			const ae = a * e,
				af = a * f,
				be = b * e,
				bf = b * f;
			te[0] = c * e;
			te[4] = be * d - af;
			te[8] = ae * d + bf;
			te[1] = c * f;
			te[5] = bf * d + ae;
			te[9] = af * d - be;
			te[2] = -d;
			te[6] = b * c;
			te[10] = a * c;
		} else if (euler.order === 'YZX') {
			const ac = a * c,
				ad = a * d,
				bc = b * c,
				bd = b * d;
			te[0] = c * e;
			te[4] = bd - ac * f;
			te[8] = bc * f + ad;
			te[1] = f;
			te[5] = a * e;
			te[9] = -b * e;
			te[2] = -d * e;
			te[6] = ad * f + bc;
			te[10] = ac - bd * f;
		} else if (euler.order === 'XZY') {
			const ac = a * c,
				ad = a * d,
				bc = b * c,
				bd = b * d;
			te[0] = c * e;
			te[4] = -f;
			te[8] = d * e;
			te[1] = ac * f + bd;
			te[5] = a * e;
			te[9] = ad * f - bc;
			te[2] = bc * f - ad;
			te[6] = b * e;
			te[10] = bd * f + ac;
		}

		// bottom row
		te[3] = 0;
		te[7] = 0;
		te[11] = 0;

		// last column
		te[12] = 0;
		te[13] = 0;
		te[14] = 0;
		te[15] = 1;
		return this;
	}
	makeRotationFromQuaternion(q) {
		return this.compose(_zero, q, _one);
	}
	lookAt(eye, target, up) {
		const te = this.elements;
		_z.subVectors(eye, target);
		if (_z.lengthSq() === 0) {
			// eye and target are in the same position

			_z.z = 1;
		}
		_z.normalize();
		_x.crossVectors(up, _z);
		if (_x.lengthSq() === 0) {
			// up and z are parallel

			if (Math.abs(up.z) === 1) {
				_z.x += 0.0001;
			} else {
				_z.z += 0.0001;
			}
			_z.normalize();
			_x.crossVectors(up, _z);
		}
		_x.normalize();
		_y.crossVectors(_z, _x);
		te[0] = _x.x;
		te[4] = _y.x;
		te[8] = _z.x;
		te[1] = _x.y;
		te[5] = _y.y;
		te[9] = _z.y;
		te[2] = _x.z;
		te[6] = _y.z;
		te[10] = _z.z;
		return this;
	}
	multiply(m) {
		return this.multiplyMatrices(this, m);
	}
	premultiply(m) {
		return this.multiplyMatrices(m, this);
	}
	multiplyMatrices(a, b) {
		const ae = a.elements;
		const be = b.elements;
		const te = this.elements;
		const a11 = ae[0],
			a12 = ae[4],
			a13 = ae[8],
			a14 = ae[12];
		const a21 = ae[1],
			a22 = ae[5],
			a23 = ae[9],
			a24 = ae[13];
		const a31 = ae[2],
			a32 = ae[6],
			a33 = ae[10],
			a34 = ae[14];
		const a41 = ae[3],
			a42 = ae[7],
			a43 = ae[11],
			a44 = ae[15];
		const b11 = be[0],
			b12 = be[4],
			b13 = be[8],
			b14 = be[12];
		const b21 = be[1],
			b22 = be[5],
			b23 = be[9],
			b24 = be[13];
		const b31 = be[2],
			b32 = be[6],
			b33 = be[10],
			b34 = be[14];
		const b41 = be[3],
			b42 = be[7],
			b43 = be[11],
			b44 = be[15];
		te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
		te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
		te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
		te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
		return this;
	}
	multiplyScalar(s) {
		const te = this.elements;
		te[0] *= s;
		te[4] *= s;
		te[8] *= s;
		te[12] *= s;
		te[1] *= s;
		te[5] *= s;
		te[9] *= s;
		te[13] *= s;
		te[2] *= s;
		te[6] *= s;
		te[10] *= s;
		te[14] *= s;
		te[3] *= s;
		te[7] *= s;
		te[11] *= s;
		te[15] *= s;
		return this;
	}
	determinant() {
		const te = this.elements;
		const n11 = te[0],
			n12 = te[4],
			n13 = te[8],
			n14 = te[12];
		const n21 = te[1],
			n22 = te[5],
			n23 = te[9],
			n24 = te[13];
		const n31 = te[2],
			n32 = te[6],
			n33 = te[10],
			n34 = te[14];
		const n41 = te[3],
			n42 = te[7],
			n43 = te[11],
			n44 = te[15];

		//TODO: make this more efficient
		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
	}
	transpose() {
		const te = this.elements;
		let tmp;
		tmp = te[1];
		te[1] = te[4];
		te[4] = tmp;
		tmp = te[2];
		te[2] = te[8];
		te[8] = tmp;
		tmp = te[6];
		te[6] = te[9];
		te[9] = tmp;
		tmp = te[3];
		te[3] = te[12];
		te[12] = tmp;
		tmp = te[7];
		te[7] = te[13];
		te[13] = tmp;
		tmp = te[11];
		te[11] = te[14];
		te[14] = tmp;
		return this;
	}
	setPosition(x, y, z) {
		const te = this.elements;
		if (x.isVector3) {
			te[12] = x.x;
			te[13] = x.y;
			te[14] = x.z;
		} else {
			te[12] = x;
			te[13] = y;
			te[14] = z;
		}
		return this;
	}
	invert() {
		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		const te = this.elements,
			n11 = te[0],
			n21 = te[1],
			n31 = te[2],
			n41 = te[3],
			n12 = te[4],
			n22 = te[5],
			n32 = te[6],
			n42 = te[7],
			n13 = te[8],
			n23 = te[9],
			n33 = te[10],
			n43 = te[11],
			n14 = te[12],
			n24 = te[13],
			n34 = te[14],
			n44 = te[15],
			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
		const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
		if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
		const detInv = 1 / det;
		te[0] = t11 * detInv;
		te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
		te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
		te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
		te[4] = t12 * detInv;
		te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
		te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
		te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
		te[8] = t13 * detInv;
		te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
		te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
		te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
		te[12] = t14 * detInv;
		te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
		te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
		te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
		return this;
	}
	scale(v) {
		const te = this.elements;
		const x = v.x,
			y = v.y,
			z = v.z;
		te[0] *= x;
		te[4] *= y;
		te[8] *= z;
		te[1] *= x;
		te[5] *= y;
		te[9] *= z;
		te[2] *= x;
		te[6] *= y;
		te[10] *= z;
		te[3] *= x;
		te[7] *= y;
		te[11] *= z;
		return this;
	}
	getMaxScaleOnAxis() {
		const te = this.elements;
		const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
		const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
		const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
		return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
	}
	makeTranslation(x, y, z) {
		this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
		return this;
	}
	makeRotationX(theta) {
		const c = Math.cos(theta),
			s = Math.sin(theta);
		this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
		return this;
	}
	makeRotationY(theta) {
		const c = Math.cos(theta),
			s = Math.sin(theta);
		this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
		return this;
	}
	makeRotationZ(theta) {
		const c = Math.cos(theta),
			s = Math.sin(theta);
		this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
		return this;
	}
	makeRotationAxis(axis, angle) {
		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		const c = Math.cos(angle);
		const s = Math.sin(angle);
		const t = 1 - c;
		const x = axis.x,
			y = axis.y,
			z = axis.z;
		const tx = t * x,
			ty = t * y;
		this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
		return this;
	}
	makeScale(x, y, z) {
		this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
		return this;
	}
	makeShear(xy, xz, yx, yz, zx, zy) {
		this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);
		return this;
	}
	compose(position, quaternion, scale) {
		const te = this.elements;
		const x = quaternion._x,
			y = quaternion._y,
			z = quaternion._z,
			w = quaternion._w;
		const x2 = x + x,
			y2 = y + y,
			z2 = z + z;
		const xx = x * x2,
			xy = x * y2,
			xz = x * z2;
		const yy = y * y2,
			yz = y * z2,
			zz = z * z2;
		const wx = w * x2,
			wy = w * y2,
			wz = w * z2;
		const sx = scale.x,
			sy = scale.y,
			sz = scale.z;
		te[0] = (1 - (yy + zz)) * sx;
		te[1] = (xy + wz) * sx;
		te[2] = (xz - wy) * sx;
		te[3] = 0;
		te[4] = (xy - wz) * sy;
		te[5] = (1 - (xx + zz)) * sy;
		te[6] = (yz + wx) * sy;
		te[7] = 0;
		te[8] = (xz + wy) * sz;
		te[9] = (yz - wx) * sz;
		te[10] = (1 - (xx + yy)) * sz;
		te[11] = 0;
		te[12] = position.x;
		te[13] = position.y;
		te[14] = position.z;
		te[15] = 1;
		return this;
	}
	decompose(position, quaternion, scale) {
		const te = this.elements;
		let sx = _v1$5.set(te[0], te[1], te[2]).length();
		const sy = _v1$5.set(te[4], te[5], te[6]).length();
		const sz = _v1$5.set(te[8], te[9], te[10]).length();

		// if determine is negative, we need to invert one scale
		const det = this.determinant();
		if (det < 0) sx = -sx;
		position.x = te[12];
		position.y = te[13];
		position.z = te[14];

		// scale the rotation part
		_m1$2.copy(this);
		const invSX = 1 / sx;
		const invSY = 1 / sy;
		const invSZ = 1 / sz;
		_m1$2.elements[0] *= invSX;
		_m1$2.elements[1] *= invSX;
		_m1$2.elements[2] *= invSX;
		_m1$2.elements[4] *= invSY;
		_m1$2.elements[5] *= invSY;
		_m1$2.elements[6] *= invSY;
		_m1$2.elements[8] *= invSZ;
		_m1$2.elements[9] *= invSZ;
		_m1$2.elements[10] *= invSZ;
		quaternion.setFromRotationMatrix(_m1$2);
		scale.x = sx;
		scale.y = sy;
		scale.z = sz;
		return this;
	}
	makePerspective(left, right, top, bottom, near, far) {
		const te = this.elements;
		const x = 2 * near / (right - left);
		const y = 2 * near / (top - bottom);
		const a = (right + left) / (right - left);
		const b = (top + bottom) / (top - bottom);
		const c = -(far + near) / (far - near);
		const d = -2 * far * near / (far - near);
		te[0] = x;
		te[4] = 0;
		te[8] = a;
		te[12] = 0;
		te[1] = 0;
		te[5] = y;
		te[9] = b;
		te[13] = 0;
		te[2] = 0;
		te[6] = 0;
		te[10] = c;
		te[14] = d;
		te[3] = 0;
		te[7] = 0;
		te[11] = -1;
		te[15] = 0;
		return this;
	}
	makeOrthographic(left, right, top, bottom, near, far) {
		const te = this.elements;
		const w = 1.0 / (right - left);
		const h = 1.0 / (top - bottom);
		const p = 1.0 / (far - near);
		const x = (right + left) * w;
		const y = (top + bottom) * h;
		const z = (far + near) * p;
		te[0] = 2 * w;
		te[4] = 0;
		te[8] = 0;
		te[12] = -x;
		te[1] = 0;
		te[5] = 2 * h;
		te[9] = 0;
		te[13] = -y;
		te[2] = 0;
		te[6] = 0;
		te[10] = -2 * p;
		te[14] = -z;
		te[3] = 0;
		te[7] = 0;
		te[11] = 0;
		te[15] = 1;
		return this;
	}
	equals(matrix) {
		const te = this.elements;
		const me = matrix.elements;
		for (let i = 0; i < 16; i++) {
			if (te[i] !== me[i]) return false;
		}
		return true;
	}
	fromArray(array, offset = 0) {
		for (let i = 0; i < 16; i++) {
			this.elements[i] = array[i + offset];
		}
		return this;
	}
	toArray(array = [], offset = 0) {
		const te = this.elements;
		array[offset] = te[0];
		array[offset + 1] = te[1];
		array[offset + 2] = te[2];
		array[offset + 3] = te[3];
		array[offset + 4] = te[4];
		array[offset + 5] = te[5];
		array[offset + 6] = te[6];
		array[offset + 7] = te[7];
		array[offset + 8] = te[8];
		array[offset + 9] = te[9];
		array[offset + 10] = te[10];
		array[offset + 11] = te[11];
		array[offset + 12] = te[12];
		array[offset + 13] = te[13];
		array[offset + 14] = te[14];
		array[offset + 15] = te[15];
		return array;
	}
}
const _v1$5 = /*@__PURE__*/new Vector3();
const _m1$2 = /*@__PURE__*/new Matrix4();
const _zero = /*@__PURE__*/new Vector3(0, 0, 0);
const _one = /*@__PURE__*/new Vector3(1, 1, 1);
const _x = /*@__PURE__*/new Vector3();
const _y = /*@__PURE__*/new Vector3();
const _z = /*@__PURE__*/new Vector3();

const _matrix$1 = /*@__PURE__*/new Matrix4();
const _quaternion$3 = /*@__PURE__*/new Quaternion();
class Euler {
	constructor(x = 0, y = 0, z = 0, order = Euler.DefaultOrder) {
		this.isEuler = true;
		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order;
	}
	get x() {
		return this._x;
	}
	set x(value) {
		this._x = value;
		this._onChangeCallback();
	}
	get y() {
		return this._y;
	}
	set y(value) {
		this._y = value;
		this._onChangeCallback();
	}
	get z() {
		return this._z;
	}
	set z(value) {
		this._z = value;
		this._onChangeCallback();
	}
	get order() {
		return this._order;
	}
	set order(value) {
		this._order = value;
		this._onChangeCallback();
	}
	set(x, y, z, order = this._order) {
		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order;
		this._onChangeCallback();
		return this;
	}
	clone() {
		return new this.constructor(this._x, this._y, this._z, this._order);
	}
	copy(euler) {
		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;
		this._onChangeCallback();
		return this;
	}
	setFromRotationMatrix(m, order = this._order, update = true) {
		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		const te = m.elements;
		const m11 = te[0],
			m12 = te[4],
			m13 = te[8];
		const m21 = te[1],
			m22 = te[5],
			m23 = te[9];
		const m31 = te[2],
			m32 = te[6],
			m33 = te[10];
		switch (order) {
			case 'XYZ':
				this._y = Math.asin(clamp(m13, -1, 1));
				if (Math.abs(m13) < 0.9999999) {
					this._x = Math.atan2(-m23, m33);
					this._z = Math.atan2(-m12, m11);
				} else {
					this._x = Math.atan2(m32, m22);
					this._z = 0;
				}
				break;
			case 'YXZ':
				this._x = Math.asin(-clamp(m23, -1, 1));
				if (Math.abs(m23) < 0.9999999) {
					this._y = Math.atan2(m13, m33);
					this._z = Math.atan2(m21, m22);
				} else {
					this._y = Math.atan2(-m31, m11);
					this._z = 0;
				}
				break;
			case 'ZXY':
				this._x = Math.asin(clamp(m32, -1, 1));
				if (Math.abs(m32) < 0.9999999) {
					this._y = Math.atan2(-m31, m33);
					this._z = Math.atan2(-m12, m22);
				} else {
					this._y = 0;
					this._z = Math.atan2(m21, m11);
				}
				break;
			case 'ZYX':
				this._y = Math.asin(-clamp(m31, -1, 1));
				if (Math.abs(m31) < 0.9999999) {
					this._x = Math.atan2(m32, m33);
					this._z = Math.atan2(m21, m11);
				} else {
					this._x = 0;
					this._z = Math.atan2(-m12, m22);
				}
				break;
			case 'YZX':
				this._z = Math.asin(clamp(m21, -1, 1));
				if (Math.abs(m21) < 0.9999999) {
					this._x = Math.atan2(-m23, m22);
					this._y = Math.atan2(-m31, m11);
				} else {
					this._x = 0;
					this._y = Math.atan2(m13, m33);
				}
				break;
			case 'XZY':
				this._z = Math.asin(-clamp(m12, -1, 1));
				if (Math.abs(m12) < 0.9999999) {
					this._x = Math.atan2(m32, m22);
					this._y = Math.atan2(m13, m11);
				} else {
					this._x = Math.atan2(-m23, m33);
					this._y = 0;
				}
				break;
			default:
				console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order);
		}
		this._order = order;
		if (update === true) this._onChangeCallback();
		return this;
	}
	setFromQuaternion(q, order, update) {
		_matrix$1.makeRotationFromQuaternion(q);
		return this.setFromRotationMatrix(_matrix$1, order, update);
	}
	setFromVector3(v, order = this._order) {
		return this.set(v.x, v.y, v.z, order);
	}
	reorder(newOrder) {
		// WARNING: this discards revolution information -bhouston

		_quaternion$3.setFromEuler(this);
		return this.setFromQuaternion(_quaternion$3, newOrder);
	}
	equals(euler) {
		return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
	}
	fromArray(array) {
		this._x = array[0];
		this._y = array[1];
		this._z = array[2];
		if (array[3] !== undefined) this._order = array[3];
		this._onChangeCallback();
		return this;
	}
	toArray(array = [], offset = 0) {
		array[offset] = this._x;
		array[offset + 1] = this._y;
		array[offset + 2] = this._z;
		array[offset + 3] = this._order;
		return array;
	}
	_onChange(callback) {
		this._onChangeCallback = callback;
		return this;
	}
	_onChangeCallback() {}
	*[Symbol.iterator]() {
		yield this._x;
		yield this._y;
		yield this._z;
		yield this._order;
	}

	// @deprecated since r138, 02cf0df1cb4575d5842fef9c85bb5a89fe020d53

	toVector3() {
		console.error('THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead');
	}
}
Euler.DefaultOrder = 'XYZ';
Euler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];

class Layers {
	constructor() {
		this.mask = 1 | 0;
	}
	set(channel) {
		this.mask = (1 << channel | 0) >>> 0;
	}
	enable(channel) {
		this.mask |= 1 << channel | 0;
	}
	enableAll() {
		this.mask = 0xffffffff | 0;
	}
	toggle(channel) {
		this.mask ^= 1 << channel | 0;
	}
	disable(channel) {
		this.mask &= ~(1 << channel | 0);
	}
	disableAll() {
		this.mask = 0;
	}
	test(layers) {
		return (this.mask & layers.mask) !== 0;
	}
	isEnabled(channel) {
		return (this.mask & (1 << channel | 0)) !== 0;
	}
}

let _object3DId = 0;
const _v1$4 = /*@__PURE__*/new Vector3();
const _q1 = /*@__PURE__*/new Quaternion();
const _m1$1 = /*@__PURE__*/new Matrix4();
const _target = /*@__PURE__*/new Vector3();
const _position$3 = /*@__PURE__*/new Vector3();
const _scale$2 = /*@__PURE__*/new Vector3();
const _quaternion$2 = /*@__PURE__*/new Quaternion();
const _xAxis = /*@__PURE__*/new Vector3(1, 0, 0);
const _yAxis = /*@__PURE__*/new Vector3(0, 1, 0);
const _zAxis = /*@__PURE__*/new Vector3(0, 0, 1);
const _addedEvent = {
	type: 'added'
};
const _removedEvent = {
	type: 'removed'
};
class Object3D extends EventDispatcher {
	constructor() {
		super();
		this.isObject3D = true;
		Object.defineProperty(this, 'id', {
			value: _object3DId++
		});
		this.uuid = generateUUID();
		this.name = '';
		this.type = 'Object3D';
		this.parent = null;
		this.children = [];
		this.up = Object3D.DefaultUp.clone();
		const position = new Vector3();
		const rotation = new Euler();
		const quaternion = new Quaternion();
		const scale = new Vector3(1, 1, 1);
		function onRotationChange() {
			quaternion.setFromEuler(rotation, false);
		}
		function onQuaternionChange() {
			rotation.setFromQuaternion(quaternion, undefined, false);
		}
		rotation._onChange(onRotationChange);
		quaternion._onChange(onQuaternionChange);
		Object.defineProperties(this, {
			position: {
				configurable: true,
				enumerable: true,
				value: position
			},
			rotation: {
				configurable: true,
				enumerable: true,
				value: rotation
			},
			quaternion: {
				configurable: true,
				enumerable: true,
				value: quaternion
			},
			scale: {
				configurable: true,
				enumerable: true,
				value: scale
			},
			modelViewMatrix: {
				value: new Matrix4()
			},
			normalMatrix: {
				value: new Matrix3()
			}
		});
		this.matrix = new Matrix4();
		this.matrixWorld = new Matrix4();
		this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
		this.matrixWorldNeedsUpdate = false;
		this.matrixWorldAutoUpdate = Object3D.DefaultMatrixWorldAutoUpdate; // checked by the renderer

		this.layers = new Layers();
		this.visible = true;
		this.castShadow = false;
		this.receiveShadow = false;
		this.frustumCulled = true;
		this.renderOrder = 0;
		this.animations = [];
		this.userData = {};
	}
	onBeforeRender() {}
	onAfterRender() {}
	applyMatrix4(matrix) {
		if (this.matrixAutoUpdate) this.updateMatrix();
		this.matrix.premultiply(matrix);
		this.matrix.decompose(this.position, this.quaternion, this.scale);
	}
	applyQuaternion(q) {
		this.quaternion.premultiply(q);
		return this;
	}
	setRotationFromAxisAngle(axis, angle) {
		// assumes axis is normalized

		this.quaternion.setFromAxisAngle(axis, angle);
	}
	setRotationFromEuler(euler) {
		this.quaternion.setFromEuler(euler, true);
	}
	setRotationFromMatrix(m) {
		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		this.quaternion.setFromRotationMatrix(m);
	}
	setRotationFromQuaternion(q) {
		// assumes q is normalized

		this.quaternion.copy(q);
	}
	rotateOnAxis(axis, angle) {
		// rotate object on axis in object space
		// axis is assumed to be normalized

		_q1.setFromAxisAngle(axis, angle);
		this.quaternion.multiply(_q1);
		return this;
	}
	rotateOnWorldAxis(axis, angle) {
		// rotate object on axis in world space
		// axis is assumed to be normalized
		// method assumes no rotated parent

		_q1.setFromAxisAngle(axis, angle);
		this.quaternion.premultiply(_q1);
		return this;
	}
	rotateX(angle) {
		return this.rotateOnAxis(_xAxis, angle);
	}
	rotateY(angle) {
		return this.rotateOnAxis(_yAxis, angle);
	}
	rotateZ(angle) {
		return this.rotateOnAxis(_zAxis, angle);
	}
	translateOnAxis(axis, distance) {
		// translate object by distance along axis in object space
		// axis is assumed to be normalized

		_v1$4.copy(axis).applyQuaternion(this.quaternion);
		this.position.add(_v1$4.multiplyScalar(distance));
		return this;
	}
	translateX(distance) {
		return this.translateOnAxis(_xAxis, distance);
	}
	translateY(distance) {
		return this.translateOnAxis(_yAxis, distance);
	}
	translateZ(distance) {
		return this.translateOnAxis(_zAxis, distance);
	}
	localToWorld(vector) {
		return vector.applyMatrix4(this.matrixWorld);
	}
	worldToLocal(vector) {
		return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
	}
	lookAt(x, y, z) {
		// This method does not support objects having non-uniformly-scaled parent(s)

		if (x.isVector3) {
			_target.copy(x);
		} else {
			_target.set(x, y, z);
		}
		const parent = this.parent;
		this.updateWorldMatrix(true, false);
		_position$3.setFromMatrixPosition(this.matrixWorld);
		if (this.isCamera || this.isLight) {
			_m1$1.lookAt(_position$3, _target, this.up);
		} else {
			_m1$1.lookAt(_target, _position$3, this.up);
		}
		this.quaternion.setFromRotationMatrix(_m1$1);
		if (parent) {
			_m1$1.extractRotation(parent.matrixWorld);
			_q1.setFromRotationMatrix(_m1$1);
			this.quaternion.premultiply(_q1.invert());
		}
	}
	add(object) {
		if (arguments.length > 1) {
			for (let i = 0; i < arguments.length; i++) {
				this.add(arguments[i]);
			}
			return this;
		}
		if (object === this) {
			console.error('THREE.Object3D.add: object can\'t be added as a child of itself.', object);
			return this;
		}
		if (object && object.isObject3D) {
			if (object.parent !== null) {
				object.parent.remove(object);
			}
			object.parent = this;
			this.children.push(object);
			object.dispatchEvent(_addedEvent);
		} else {
			console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', object);
		}
		return this;
	}
	remove(object) {
		if (arguments.length > 1) {
			for (let i = 0; i < arguments.length; i++) {
				this.remove(arguments[i]);
			}
			return this;
		}
		const index = this.children.indexOf(object);
		if (index !== -1) {
			object.parent = null;
			this.children.splice(index, 1);
			object.dispatchEvent(_removedEvent);
		}
		return this;
	}
	removeFromParent() {
		const parent = this.parent;
		if (parent !== null) {
			parent.remove(this);
		}
		return this;
	}
	clear() {
		for (let i = 0; i < this.children.length; i++) {
			const object = this.children[i];
			object.parent = null;
			object.dispatchEvent(_removedEvent);
		}
		this.children.length = 0;
		return this;
	}
	attach(object) {
		// adds object as a child of this, while maintaining the object's world transform

		// Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)

		this.updateWorldMatrix(true, false);
		_m1$1.copy(this.matrixWorld).invert();
		if (object.parent !== null) {
			object.parent.updateWorldMatrix(true, false);
			_m1$1.multiply(object.parent.matrixWorld);
		}
		object.applyMatrix4(_m1$1);
		this.add(object);
		object.updateWorldMatrix(false, true);
		return this;
	}
	getObjectById(id) {
		return this.getObjectByProperty('id', id);
	}
	getObjectByName(name) {
		return this.getObjectByProperty('name', name);
	}
	getObjectByProperty(name, value) {
		if (this[name] === value) return this;
		for (let i = 0, l = this.children.length; i < l; i++) {
			const child = this.children[i];
			const object = child.getObjectByProperty(name, value);
			if (object !== undefined) {
				return object;
			}
		}
		return undefined;
	}
	getWorldPosition(target) {
		this.updateWorldMatrix(true, false);
		return target.setFromMatrixPosition(this.matrixWorld);
	}
	getWorldQuaternion(target) {
		this.updateWorldMatrix(true, false);
		this.matrixWorld.decompose(_position$3, target, _scale$2);
		return target;
	}
	getWorldScale(target) {
		this.updateWorldMatrix(true, false);
		this.matrixWorld.decompose(_position$3, _quaternion$2, target);
		return target;
	}
	getWorldDirection(target) {
		this.updateWorldMatrix(true, false);
		const e = this.matrixWorld.elements;
		return target.set(e[8], e[9], e[10]).normalize();
	}
	raycast() {}
	traverse(callback) {
		callback(this);
		const children = this.children;
		for (let i = 0, l = children.length; i < l; i++) {
			children[i].traverse(callback);
		}
	}
	traverseVisible(callback) {
		if (this.visible === false) return;
		callback(this);
		const children = this.children;
		for (let i = 0, l = children.length; i < l; i++) {
			children[i].traverseVisible(callback);
		}
	}
	traverseAncestors(callback) {
		const parent = this.parent;
		if (parent !== null) {
			callback(parent);
			parent.traverseAncestors(callback);
		}
	}
	updateMatrix() {
		this.matrix.compose(this.position, this.quaternion, this.scale);
		this.matrixWorldNeedsUpdate = true;
	}
	updateMatrixWorld(force) {
		if (this.matrixAutoUpdate) this.updateMatrix();
		if (this.matrixWorldNeedsUpdate || force) {
			if (this.parent === null) {
				this.matrixWorld.copy(this.matrix);
			} else {
				this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
			}
			this.matrixWorldNeedsUpdate = false;
			force = true;
		}

		// update children

		const children = this.children;
		for (let i = 0, l = children.length; i < l; i++) {
			const child = children[i];
			if (child.matrixWorldAutoUpdate === true || force === true) {
				child.updateMatrixWorld(force);
			}
		}
	}
	updateWorldMatrix(updateParents, updateChildren) {
		const parent = this.parent;
		if (updateParents === true && parent !== null && parent.matrixWorldAutoUpdate === true) {
			parent.updateWorldMatrix(true, false);
		}
		if (this.matrixAutoUpdate) this.updateMatrix();
		if (this.parent === null) {
			this.matrixWorld.copy(this.matrix);
		} else {
			this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
		}

		// update children

		if (updateChildren === true) {
			const children = this.children;
			for (let i = 0, l = children.length; i < l; i++) {
				const child = children[i];
				if (child.matrixWorldAutoUpdate === true) {
					child.updateWorldMatrix(false, true);
				}
			}
		}
	}
	toJSON(meta) {
		// meta is a string when called from JSON.stringify
		const isRootObject = meta === undefined || typeof meta === 'string';
		const output = {};

		// meta is a hash used to collect geometries, materials.
		// not providing it implies that this is the root object
		// being serialized.
		if (isRootObject) {
			// initialize meta obj
			meta = {
				geometries: {},
				materials: {},
				textures: {},
				images: {},
				shapes: {},
				skeletons: {},
				animations: {},
				nodes: {}
			};
			output.metadata = {
				version: 4.5,
				type: 'Object',
				generator: 'Object3D.toJSON'
			};
		}

		// standard Object3D serialization

		const object = {};
		object.uuid = this.uuid;
		object.type = this.type;
		if (this.name !== '') object.name = this.name;
		if (this.castShadow === true) object.castShadow = true;
		if (this.receiveShadow === true) object.receiveShadow = true;
		if (this.visible === false) object.visible = false;
		if (this.frustumCulled === false) object.frustumCulled = false;
		if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
		if (JSON.stringify(this.userData) !== '{}') object.userData = this.userData;
		object.layers = this.layers.mask;
		object.matrix = this.matrix.toArray();
		if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;

		// object specific properties

		if (this.isInstancedMesh) {
			object.type = 'InstancedMesh';
			object.count = this.count;
			object.instanceMatrix = this.instanceMatrix.toJSON();
			if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();
		}

		//

		function serialize(library, element) {
			if (library[element.uuid] === undefined) {
				library[element.uuid] = element.toJSON(meta);
			}
			return element.uuid;
		}
		if (this.isScene) {
			if (this.background) {
				if (this.background.isColor) {
					object.background = this.background.toJSON();
				} else if (this.background.isTexture) {
					object.background = this.background.toJSON(meta).uuid;
				}
			}
			if (this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true) {
				object.environment = this.environment.toJSON(meta).uuid;
			}
		} else if (this.isMesh || this.isLine || this.isPoints) {
			object.geometry = serialize(meta.geometries, this.geometry);
			const parameters = this.geometry.parameters;
			if (parameters !== undefined && parameters.shapes !== undefined) {
				const shapes = parameters.shapes;
				if (Array.isArray(shapes)) {
					for (let i = 0, l = shapes.length; i < l; i++) {
						const shape = shapes[i];
						serialize(meta.shapes, shape);
					}
				} else {
					serialize(meta.shapes, shapes);
				}
			}
		}
		if (this.isSkinnedMesh) {
			object.bindMode = this.bindMode;
			object.bindMatrix = this.bindMatrix.toArray();
			if (this.skeleton !== undefined) {
				serialize(meta.skeletons, this.skeleton);
				object.skeleton = this.skeleton.uuid;
			}
		}
		if (this.material !== undefined) {
			if (Array.isArray(this.material)) {
				const uuids = [];
				for (let i = 0, l = this.material.length; i < l; i++) {
					uuids.push(serialize(meta.materials, this.material[i]));
				}
				object.material = uuids;
			} else {
				object.material = serialize(meta.materials, this.material);
			}
		}

		//

		if (this.children.length > 0) {
			object.children = [];
			for (let i = 0; i < this.children.length; i++) {
				object.children.push(this.children[i].toJSON(meta).object);
			}
		}

		//

		if (this.animations.length > 0) {
			object.animations = [];
			for (let i = 0; i < this.animations.length; i++) {
				const animation = this.animations[i];
				object.animations.push(serialize(meta.animations, animation));
			}
		}
		if (isRootObject) {
			const geometries = extractFromCache(meta.geometries);
			const materials = extractFromCache(meta.materials);
			const textures = extractFromCache(meta.textures);
			const images = extractFromCache(meta.images);
			const shapes = extractFromCache(meta.shapes);
			const skeletons = extractFromCache(meta.skeletons);
			const animations = extractFromCache(meta.animations);
			const nodes = extractFromCache(meta.nodes);
			if (geometries.length > 0) output.geometries = geometries;
			if (materials.length > 0) output.materials = materials;
			if (textures.length > 0) output.textures = textures;
			if (images.length > 0) output.images = images;
			if (shapes.length > 0) output.shapes = shapes;
			if (skeletons.length > 0) output.skeletons = skeletons;
			if (animations.length > 0) output.animations = animations;
			if (nodes.length > 0) output.nodes = nodes;
		}
		output.object = object;
		return output;

		// extract data from the cache hash
		// remove metadata on each item
		// and return as array
		function extractFromCache(cache) {
			const values = [];
			for (const key in cache) {
				const data = cache[key];
				delete data.metadata;
				values.push(data);
			}
			return values;
		}
	}
	clone(recursive) {
		return new this.constructor().copy(this, recursive);
	}
	copy(source, recursive = true) {
		this.name = source.name;
		this.up.copy(source.up);
		this.position.copy(source.position);
		this.rotation.order = source.rotation.order;
		this.quaternion.copy(source.quaternion);
		this.scale.copy(source.scale);
		this.matrix.copy(source.matrix);
		this.matrixWorld.copy(source.matrixWorld);
		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
		this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
		this.layers.mask = source.layers.mask;
		this.visible = source.visible;
		this.castShadow = source.castShadow;
		this.receiveShadow = source.receiveShadow;
		this.frustumCulled = source.frustumCulled;
		this.renderOrder = source.renderOrder;
		this.userData = JSON.parse(JSON.stringify(source.userData));
		if (recursive === true) {
			for (let i = 0; i < source.children.length; i++) {
				const child = source.children[i];
				this.add(child.clone());
			}
		}
		return this;
	}
}
Object3D.DefaultUp = /*@__PURE__*/new Vector3(0, 1, 0);
Object3D.DefaultMatrixAutoUpdate = true;
Object3D.DefaultMatrixWorldAutoUpdate = true;

const _v0$1 = /*@__PURE__*/new Vector3();
const _v1$3 = /*@__PURE__*/new Vector3();
const _v2$2 = /*@__PURE__*/new Vector3();
const _v3$1 = /*@__PURE__*/new Vector3();
const _vab = /*@__PURE__*/new Vector3();
const _vac = /*@__PURE__*/new Vector3();
const _vbc = /*@__PURE__*/new Vector3();
const _vap = /*@__PURE__*/new Vector3();
const _vbp = /*@__PURE__*/new Vector3();
const _vcp = /*@__PURE__*/new Vector3();
class Triangle {
	constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {
		this.a = a;
		this.b = b;
		this.c = c;
	}
	static getNormal(a, b, c, target) {
		target.subVectors(c, b);
		_v0$1.subVectors(a, b);
		target.cross(_v0$1);
		const targetLengthSq = target.lengthSq();
		if (targetLengthSq > 0) {
			return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
		}
		return target.set(0, 0, 0);
	}

	// static/instance method to calculate barycentric coordinates
	// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
	static getBarycoord(point, a, b, c, target) {
		_v0$1.subVectors(c, a);
		_v1$3.subVectors(b, a);
		_v2$2.subVectors(point, a);
		const dot00 = _v0$1.dot(_v0$1);
		const dot01 = _v0$1.dot(_v1$3);
		const dot02 = _v0$1.dot(_v2$2);
		const dot11 = _v1$3.dot(_v1$3);
		const dot12 = _v1$3.dot(_v2$2);
		const denom = dot00 * dot11 - dot01 * dot01;

		// collinear or singular triangle
		if (denom === 0) {
			// arbitrary location outside of triangle?
			// not sure if this is the best idea, maybe should be returning undefined
			return target.set(-2, -1, -1);
		}
		const invDenom = 1 / denom;
		const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
		const v = (dot00 * dot12 - dot01 * dot02) * invDenom;

		// barycentric coordinates must always sum to 1
		return target.set(1 - u - v, v, u);
	}
	static containsPoint(point, a, b, c) {
		this.getBarycoord(point, a, b, c, _v3$1);
		return _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;
	}
	static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
		this.getBarycoord(point, p1, p2, p3, _v3$1);
		target.set(0, 0);
		target.addScaledVector(uv1, _v3$1.x);
		target.addScaledVector(uv2, _v3$1.y);
		target.addScaledVector(uv3, _v3$1.z);
		return target;
	}
	static isFrontFacing(a, b, c, direction) {
		_v0$1.subVectors(c, b);
		_v1$3.subVectors(a, b);

		// strictly front facing
		return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
	}
	set(a, b, c) {
		this.a.copy(a);
		this.b.copy(b);
		this.c.copy(c);
		return this;
	}
	setFromPointsAndIndices(points, i0, i1, i2) {
		this.a.copy(points[i0]);
		this.b.copy(points[i1]);
		this.c.copy(points[i2]);
		return this;
	}
	setFromAttributeAndIndices(attribute, i0, i1, i2) {
		this.a.fromBufferAttribute(attribute, i0);
		this.b.fromBufferAttribute(attribute, i1);
		this.c.fromBufferAttribute(attribute, i2);
		return this;
	}
	clone() {
		return new this.constructor().copy(this);
	}
	copy(triangle) {
		this.a.copy(triangle.a);
		this.b.copy(triangle.b);
		this.c.copy(triangle.c);
		return this;
	}
	getArea() {
		_v0$1.subVectors(this.c, this.b);
		_v1$3.subVectors(this.a, this.b);
		return _v0$1.cross(_v1$3).length() * 0.5;
	}
	getMidpoint(target) {
		return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
	}
	getNormal(target) {
		return Triangle.getNormal(this.a, this.b, this.c, target);
	}
	getPlane(target) {
		return target.setFromCoplanarPoints(this.a, this.b, this.c);
	}
	getBarycoord(point, target) {
		return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
	}
	getUV(point, uv1, uv2, uv3, target) {
		return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
	}
	containsPoint(point) {
		return Triangle.containsPoint(point, this.a, this.b, this.c);
	}
	isFrontFacing(direction) {
		return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
	}
	intersectsBox(box) {
		return box.intersectsTriangle(this);
	}
	closestPointToPoint(p, target) {
		const a = this.a,
			b = this.b,
			c = this.c;
		let v, w;

		// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
		// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
		// under the accompanying license; see chapter 5.1.5 for detailed explanation.
		// basically, we're distinguishing which of the voronoi regions of the triangle
		// the point lies in with the minimum amount of redundant computation.

		_vab.subVectors(b, a);
		_vac.subVectors(c, a);
		_vap.subVectors(p, a);
		const d1 = _vab.dot(_vap);
		const d2 = _vac.dot(_vap);
		if (d1 <= 0 && d2 <= 0) {
			// vertex region of A; barycentric coords (1, 0, 0)
			return target.copy(a);
		}
		_vbp.subVectors(p, b);
		const d3 = _vab.dot(_vbp);
		const d4 = _vac.dot(_vbp);
		if (d3 >= 0 && d4 <= d3) {
			// vertex region of B; barycentric coords (0, 1, 0)
			return target.copy(b);
		}
		const vc = d1 * d4 - d3 * d2;
		if (vc <= 0 && d1 >= 0 && d3 <= 0) {
			v = d1 / (d1 - d3);
			// edge region of AB; barycentric coords (1-v, v, 0)
			return target.copy(a).addScaledVector(_vab, v);
		}
		_vcp.subVectors(p, c);
		const d5 = _vab.dot(_vcp);
		const d6 = _vac.dot(_vcp);
		if (d6 >= 0 && d5 <= d6) {
			// vertex region of C; barycentric coords (0, 0, 1)
			return target.copy(c);
		}
		const vb = d5 * d2 - d1 * d6;
		if (vb <= 0 && d2 >= 0 && d6 <= 0) {
			w = d2 / (d2 - d6);
			// edge region of AC; barycentric coords (1-w, 0, w)
			return target.copy(a).addScaledVector(_vac, w);
		}
		const va = d3 * d6 - d5 * d4;
		if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
			_vbc.subVectors(c, b);
			w = (d4 - d3) / (d4 - d3 + (d5 - d6));
			// edge region of BC; barycentric coords (0, 1-w, w)
			return target.copy(b).addScaledVector(_vbc, w); // edge region of BC
		}

		// face region
		const denom = 1 / (va + vb + vc);
		// u = va * denom
		v = vb * denom;
		w = vc * denom;
		return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
	}
	equals(triangle) {
		return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
	}
}

let materialId = 0;
class Material extends EventDispatcher {
	constructor() {
		super();
		this.isMaterial = true;
		Object.defineProperty(this, 'id', {
			value: materialId++
		});
		this.uuid = generateUUID();
		this.name = '';
		this.type = 'Material';
		this.blending = NormalBlending;
		this.side = FrontSide;
		this.vertexColors = false;
		this.opacity = 1;
		this.transparent = false;
		this.blendSrc = SrcAlphaFactor;
		this.blendDst = OneMinusSrcAlphaFactor;
		this.blendEquation = AddEquation;
		this.blendSrcAlpha = null;
		this.blendDstAlpha = null;
		this.blendEquationAlpha = null;
		this.depthFunc = LessEqualDepth;
		this.depthTest = true;
		this.depthWrite = true;
		this.stencilWriteMask = 0xff;
		this.stencilFunc = AlwaysStencilFunc;
		this.stencilRef = 0;
		this.stencilFuncMask = 0xff;
		this.stencilFail = KeepStencilOp;
		this.stencilZFail = KeepStencilOp;
		this.stencilZPass = KeepStencilOp;
		this.stencilWrite = false;
		this.clippingPlanes = null;
		this.clipIntersection = false;
		this.clipShadows = false;
		this.shadowSide = null;
		this.colorWrite = true;
		this.precision = null; // override the renderer's default precision for this material

		this.polygonOffset = false;
		this.polygonOffsetFactor = 0;
		this.polygonOffsetUnits = 0;
		this.dithering = false;
		this.alphaToCoverage = false;
		this.premultipliedAlpha = false;
		this.visible = true;
		this.toneMapped = true;
		this.userData = {};
		this.version = 0;
		this._alphaTest = 0;
	}
	get alphaTest() {
		return this._alphaTest;
	}
	set alphaTest(value) {
		if (this._alphaTest > 0 !== value > 0) {
			this.version++;
		}
		this._alphaTest = value;
	}
	onBuild() {}
	onBeforeRender() {}
	onBeforeCompile() {}
	customProgramCacheKey() {
		return this.onBeforeCompile.toString();
	}
	setValues(values) {
		if (values === undefined) return;
		for (const key in values) {
			const newValue = values[key];
			if (newValue === undefined) {
				console.warn('THREE.Material: \'' + key + '\' parameter is undefined.');
				continue;
			}
			const currentValue = this[key];
			if (currentValue === undefined) {
				console.warn('THREE.' + this.type + ': \'' + key + '\' is not a property of this material.');
				continue;
			}
			if (currentValue && currentValue.isColor) {
				currentValue.set(newValue);
			} else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) {
				currentValue.copy(newValue);
			} else {
				this[key] = newValue;
			}
		}
	}
	toJSON(meta) {
		const isRootObject = meta === undefined || typeof meta === 'string';
		if (isRootObject) {
			meta = {
				textures: {},
				images: {}
			};
		}
		const data = {
			metadata: {
				version: 4.5,
				type: 'Material',
				generator: 'Material.toJSON'
			}
		};

		// standard Material serialization
		data.uuid = this.uuid;
		data.type = this.type;
		if (this.name !== '') data.name = this.name;
		if (this.color && this.color.isColor) data.color = this.color.getHex();
		if (this.roughness !== undefined) data.roughness = this.roughness;
		if (this.metalness !== undefined) data.metalness = this.metalness;
		if (this.sheen !== undefined) data.sheen = this.sheen;
		if (this.sheenColor && this.sheenColor.isColor) data.sheenColor = this.sheenColor.getHex();
		if (this.sheenRoughness !== undefined) data.sheenRoughness = this.sheenRoughness;
		if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
		if (this.emissiveIntensity && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
		if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
		if (this.specularIntensity !== undefined) data.specularIntensity = this.specularIntensity;
		if (this.specularColor && this.specularColor.isColor) data.specularColor = this.specularColor.getHex();
		if (this.shininess !== undefined) data.shininess = this.shininess;
		if (this.clearcoat !== undefined) data.clearcoat = this.clearcoat;
		if (this.clearcoatRoughness !== undefined) data.clearcoatRoughness = this.clearcoatRoughness;
		if (this.clearcoatMap && this.clearcoatMap.isTexture) {
			data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
		}
		if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
			data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
		}
		if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
			data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
			data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
		}
		if (this.iridescence !== undefined) data.iridescence = this.iridescence;
		if (this.iridescenceIOR !== undefined) data.iridescenceIOR = this.iridescenceIOR;
		if (this.iridescenceThicknessRange !== undefined) data.iridescenceThicknessRange = this.iridescenceThicknessRange;
		if (this.iridescenceMap && this.iridescenceMap.isTexture) {
			data.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid;
		}
		if (this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture) {
			data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(meta).uuid;
		}
		if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
		if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
		if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
		if (this.lightMap && this.lightMap.isTexture) {
			data.lightMap = this.lightMap.toJSON(meta).uuid;
			data.lightMapIntensity = this.lightMapIntensity;
		}
		if (this.aoMap && this.aoMap.isTexture) {
			data.aoMap = this.aoMap.toJSON(meta).uuid;
			data.aoMapIntensity = this.aoMapIntensity;
		}
		if (this.bumpMap && this.bumpMap.isTexture) {
			data.bumpMap = this.bumpMap.toJSON(meta).uuid;
			data.bumpScale = this.bumpScale;
		}
		if (this.normalMap && this.normalMap.isTexture) {
			data.normalMap = this.normalMap.toJSON(meta).uuid;
			data.normalMapType = this.normalMapType;
			data.normalScale = this.normalScale.toArray();
		}
		if (this.displacementMap && this.displacementMap.isTexture) {
			data.displacementMap = this.displacementMap.toJSON(meta).uuid;
			data.displacementScale = this.displacementScale;
			data.displacementBias = this.displacementBias;
		}
		if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
		if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
		if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
		if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;
		if (this.specularIntensityMap && this.specularIntensityMap.isTexture) data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
		if (this.specularColorMap && this.specularColorMap.isTexture) data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
		if (this.envMap && this.envMap.isTexture) {
			data.envMap = this.envMap.toJSON(meta).uuid;
			if (this.combine !== undefined) data.combine = this.combine;
		}
		if (this.envMapIntensity !== undefined) data.envMapIntensity = this.envMapIntensity;
		if (this.reflectivity !== undefined) data.reflectivity = this.reflectivity;
		if (this.refractionRatio !== undefined) data.refractionRatio = this.refractionRatio;
		if (this.gradientMap && this.gradientMap.isTexture) {
			data.gradientMap = this.gradientMap.toJSON(meta).uuid;
		}
		if (this.transmission !== undefined) data.transmission = this.transmission;
		if (this.transmissionMap && this.transmissionMap.isTexture) data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
		if (this.thickness !== undefined) data.thickness = this.thickness;
		if (this.thicknessMap && this.thicknessMap.isTexture) data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
		if (this.attenuationDistance !== undefined && this.attenuationDistance !== Infinity) data.attenuationDistance = this.attenuationDistance;
		if (this.attenuationColor !== undefined) data.attenuationColor = this.attenuationColor.getHex();
		if (this.size !== undefined) data.size = this.size;
		if (this.shadowSide !== null) data.shadowSide = this.shadowSide;
		if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;
		if (this.blending !== NormalBlending) data.blending = this.blending;
		if (this.side !== FrontSide) data.side = this.side;
		if (this.vertexColors) data.vertexColors = true;
		if (this.opacity < 1) data.opacity = this.opacity;
		if (this.transparent === true) data.transparent = this.transparent;
		data.depthFunc = this.depthFunc;
		data.depthTest = this.depthTest;
		data.depthWrite = this.depthWrite;
		data.colorWrite = this.colorWrite;
		data.stencilWrite = this.stencilWrite;
		data.stencilWriteMask = this.stencilWriteMask;
		data.stencilFunc = this.stencilFunc;
		data.stencilRef = this.stencilRef;
		data.stencilFuncMask = this.stencilFuncMask;
		data.stencilFail = this.stencilFail;
		data.stencilZFail = this.stencilZFail;
		data.stencilZPass = this.stencilZPass;

		// rotation (SpriteMaterial)
		if (this.rotation !== undefined && this.rotation !== 0) data.rotation = this.rotation;
		if (this.polygonOffset === true) data.polygonOffset = true;
		if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
		if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
		if (this.linewidth !== undefined && this.linewidth !== 1) data.linewidth = this.linewidth;
		if (this.dashSize !== undefined) data.dashSize = this.dashSize;
		if (this.gapSize !== undefined) data.gapSize = this.gapSize;
		if (this.scale !== undefined) data.scale = this.scale;
		if (this.dithering === true) data.dithering = true;
		if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
		if (this.alphaToCoverage === true) data.alphaToCoverage = this.alphaToCoverage;
		if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;
		if (this.wireframe === true) data.wireframe = this.wireframe;
		if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
		if (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;
		if (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;
		if (this.flatShading === true) data.flatShading = this.flatShading;
		if (this.visible === false) data.visible = false;
		if (this.toneMapped === false) data.toneMapped = false;
		if (this.fog === false) data.fog = false;
		if (JSON.stringify(this.userData) !== '{}') data.userData = this.userData;

		// TODO: Copied from Object3D.toJSON

		function extractFromCache(cache) {
			const values = [];
			for (const key in cache) {
				const data = cache[key];
				delete data.metadata;
				values.push(data);
			}
			return values;
		}
		if (isRootObject) {
			const textures = extractFromCache(meta.textures);
			const images = extractFromCache(meta.images);
			if (textures.length > 0) data.textures = textures;
			if (images.length > 0) data.images = images;
		}
		return data;
	}
	clone() {
		return new this.constructor().copy(this);
	}
	copy(source) {
		this.name = source.name;
		this.blending = source.blending;
		this.side = source.side;
		this.vertexColors = source.vertexColors;
		this.opacity = source.opacity;
		this.transparent = source.transparent;
		this.blendSrc = source.blendSrc;
		this.blendDst = source.blendDst;
		this.blendEquation = source.blendEquation;
		this.blendSrcAlpha = source.blendSrcAlpha;
		this.blendDstAlpha = source.blendDstAlpha;
		this.blendEquationAlpha = source.blendEquationAlpha;
		this.depthFunc = source.depthFunc;
		this.depthTest = source.depthTest;
		this.depthWrite = source.depthWrite;
		this.stencilWriteMask = source.stencilWriteMask;
		this.stencilFunc = source.stencilFunc;
		this.stencilRef = source.stencilRef;
		this.stencilFuncMask = source.stencilFuncMask;
		this.stencilFail = source.stencilFail;
		this.stencilZFail = source.stencilZFail;
		this.stencilZPass = source.stencilZPass;
		this.stencilWrite = source.stencilWrite;
		const srcPlanes = source.clippingPlanes;
		let dstPlanes = null;
		if (srcPlanes !== null) {
			const n = srcPlanes.length;
			dstPlanes = new Array(n);
			for (let i = 0; i !== n; ++i) {
				dstPlanes[i] = srcPlanes[i].clone();
			}
		}
		this.clippingPlanes = dstPlanes;
		this.clipIntersection = source.clipIntersection;
		this.clipShadows = source.clipShadows;
		this.shadowSide = source.shadowSide;
		this.colorWrite = source.colorWrite;
		this.precision = source.precision;
		this.polygonOffset = source.polygonOffset;
		this.polygonOffsetFactor = source.polygonOffsetFactor;
		this.polygonOffsetUnits = source.polygonOffsetUnits;
		this.dithering = source.dithering;
		this.alphaTest = source.alphaTest;
		this.alphaToCoverage = source.alphaToCoverage;
		this.premultipliedAlpha = source.premultipliedAlpha;
		this.visible = source.visible;
		this.toneMapped = source.toneMapped;
		this.userData = JSON.parse(JSON.stringify(source.userData));
		return this;
	}
	dispose() {
		this.dispatchEvent({
			type: 'dispose'
		});
	}
	set needsUpdate(value) {
		if (value === true) this.version++;
	}
}

class MeshBasicMaterial extends Material {
	constructor(parameters) {
		super();
		this.isMeshBasicMaterial = true;
		this.type = 'MeshBasicMaterial';
		this.color = new Color(0xffffff); // emissive

		this.map = null;
		this.lightMap = null;
		this.lightMapIntensity = 1.0;
		this.aoMap = null;
		this.aoMapIntensity = 1.0;
		this.specularMap = null;
		this.alphaMap = null;
		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';
		this.fog = true;
		this.setValues(parameters);
	}
	copy(source) {
		super.copy(source);
		this.color.copy(source.color);
		this.map = source.map;
		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;
		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;
		this.specularMap = source.specularMap;
		this.alphaMap = source.alphaMap;
		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;
		this.fog = source.fog;
		return this;
	}
}

const _vector$9 = /*@__PURE__*/new Vector3();
const _vector2$1 = /*@__PURE__*/new Vector2();
class BufferAttribute {
	constructor(array, itemSize, normalized) {
		if (Array.isArray(array)) {
			throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
		}
		this.isBufferAttribute = true;
		this.name = '';
		this.array = array;
		this.itemSize = itemSize;
		this.count = array !== undefined ? array.length / itemSize : 0;
		this.normalized = normalized === true;
		this.usage = StaticDrawUsage;
		this.updateRange = {
			offset: 0,
			count: -1
		};
		this.version = 0;
	}
	onUploadCallback() {}
	set needsUpdate(value) {
		if (value === true) this.version++;
	}
	setUsage(value) {
		this.usage = value;
		return this;
	}
	copy(source) {
		this.name = source.name;
		this.array = new source.array.constructor(source.array);
		this.itemSize = source.itemSize;
		this.count = source.count;
		this.normalized = source.normalized;
		this.usage = source.usage;
		return this;
	}
	copyAt(index1, attribute, index2) {
		index1 *= this.itemSize;
		index2 *= attribute.itemSize;
		for (let i = 0, l = this.itemSize; i < l; i++) {
			this.array[index1 + i] = attribute.array[index2 + i];
		}
		return this;
	}
	copyArray(array) {
		this.array.set(array);
		return this;
	}
	applyMatrix3(m) {
		if (this.itemSize === 2) {
			for (let i = 0, l = this.count; i < l; i++) {
				_vector2$1.fromBufferAttribute(this, i);
				_vector2$1.applyMatrix3(m);
				this.setXY(i, _vector2$1.x, _vector2$1.y);
			}
		} else if (this.itemSize === 3) {
			for (let i = 0, l = this.count; i < l; i++) {
				_vector$9.fromBufferAttribute(this, i);
				_vector$9.applyMatrix3(m);
				this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
			}
		}
		return this;
	}
	applyMatrix4(m) {
		for (let i = 0, l = this.count; i < l; i++) {
			_vector$9.fromBufferAttribute(this, i);
			_vector$9.applyMatrix4(m);
			this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
		}
		return this;
	}
	applyNormalMatrix(m) {
		for (let i = 0, l = this.count; i < l; i++) {
			_vector$9.fromBufferAttribute(this, i);
			_vector$9.applyNormalMatrix(m);
			this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
		}
		return this;
	}
	transformDirection(m) {
		for (let i = 0, l = this.count; i < l; i++) {
			_vector$9.fromBufferAttribute(this, i);
			_vector$9.transformDirection(m);
			this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
		}
		return this;
	}
	set(value, offset = 0) {
		// Matching BufferAttribute constructor, do not normalize the array.
		this.array.set(value, offset);
		return this;
	}
	getX(index) {
		let x = this.array[index * this.itemSize];
		if (this.normalized) x = denormalize(x, this.array);
		return x;
	}
	setX(index, x) {
		if (this.normalized) x = normalize(x, this.array);
		this.array[index * this.itemSize] = x;
		return this;
	}
	getY(index) {
		let y = this.array[index * this.itemSize + 1];
		if (this.normalized) y = denormalize(y, this.array);
		return y;
	}
	setY(index, y) {
		if (this.normalized) y = normalize(y, this.array);
		this.array[index * this.itemSize + 1] = y;
		return this;
	}
	getZ(index) {
		let z = this.array[index * this.itemSize + 2];
		if (this.normalized) z = denormalize(z, this.array);
		return z;
	}
	setZ(index, z) {
		if (this.normalized) z = normalize(z, this.array);
		this.array[index * this.itemSize + 2] = z;
		return this;
	}
	getW(index) {
		let w = this.array[index * this.itemSize + 3];
		if (this.normalized) w = denormalize(w, this.array);
		return w;
	}
	setW(index, w) {
		if (this.normalized) w = normalize(w, this.array);
		this.array[index * this.itemSize + 3] = w;
		return this;
	}
	setXY(index, x, y) {
		index *= this.itemSize;
		if (this.normalized) {
			x = normalize(x, this.array);
			y = normalize(y, this.array);
		}
		this.array[index + 0] = x;
		this.array[index + 1] = y;
		return this;
	}
	setXYZ(index, x, y, z) {
		index *= this.itemSize;
		if (this.normalized) {
			x = normalize(x, this.array);
			y = normalize(y, this.array);
			z = normalize(z, this.array);
		}
		this.array[index + 0] = x;
		this.array[index + 1] = y;
		this.array[index + 2] = z;
		return this;
	}
	setXYZW(index, x, y, z, w) {
		index *= this.itemSize;
		if (this.normalized) {
			x = normalize(x, this.array);
			y = normalize(y, this.array);
			z = normalize(z, this.array);
			w = normalize(w, this.array);
		}
		this.array[index + 0] = x;
		this.array[index + 1] = y;
		this.array[index + 2] = z;
		this.array[index + 3] = w;
		return this;
	}
	onUpload(callback) {
		this.onUploadCallback = callback;
		return this;
	}
	clone() {
		return new this.constructor(this.array, this.itemSize).copy(this);
	}
	toJSON() {
		const data = {
			itemSize: this.itemSize,
			type: this.array.constructor.name,
			array: Array.from(this.array),
			normalized: this.normalized
		};
		if (this.name !== '') data.name = this.name;
		if (this.usage !== StaticDrawUsage) data.usage = this.usage;
		if (this.updateRange.offset !== 0 || this.updateRange.count !== -1) data.updateRange = this.updateRange;
		return data;
	}

	// @deprecated

	copyColorsArray() {
		console.error('THREE.BufferAttribute: copyColorsArray() was removed in r144.');
	}
	copyVector2sArray() {
		console.error('THREE.BufferAttribute: copyVector2sArray() was removed in r144.');
	}
	copyVector3sArray() {
		console.error('THREE.BufferAttribute: copyVector3sArray() was removed in r144.');
	}
	copyVector4sArray() {
		console.error('THREE.BufferAttribute: copyVector4sArray() was removed in r144.');
	}
}

//

class Int8BufferAttribute extends BufferAttribute {
	constructor(array, itemSize, normalized) {
		super(new Int8Array(array), itemSize, normalized);
	}
}
class Uint8BufferAttribute extends BufferAttribute {
	constructor(array, itemSize, normalized) {
		super(new Uint8Array(array), itemSize, normalized);
	}
}
class Uint8ClampedBufferAttribute extends BufferAttribute {
	constructor(array, itemSize, normalized) {
		super(new Uint8ClampedArray(array), itemSize, normalized);
	}
}
class Int16BufferAttribute extends BufferAttribute {
	constructor(array, itemSize, normalized) {
		super(new Int16Array(array), itemSize, normalized);
	}
}
class Uint16BufferAttribute extends BufferAttribute {
	constructor(array, itemSize, normalized) {
		super(new Uint16Array(array), itemSize, normalized);
	}
}
class Int32BufferAttribute extends BufferAttribute {
	constructor(array, itemSize, normalized) {
		super(new Int32Array(array), itemSize, normalized);
	}
}
class Uint32BufferAttribute extends BufferAttribute {
	constructor(array, itemSize, normalized) {
		super(new Uint32Array(array), itemSize, normalized);
	}
}
class Float16BufferAttribute extends BufferAttribute {
	constructor(array, itemSize, normalized) {
		super(new Uint16Array(array), itemSize, normalized);
		this.isFloat16BufferAttribute = true;
	}
}
class Float32BufferAttribute extends BufferAttribute {
	constructor(array, itemSize, normalized) {
		super(new Float32Array(array), itemSize, normalized);
	}
}
class Float64BufferAttribute extends BufferAttribute {
	constructor(array, itemSize, normalized) {
		super(new Float64Array(array), itemSize, normalized);
	}
}

let _id$1 = 0;
const _m1 = /*@__PURE__*/new Matrix4();
const _obj = /*@__PURE__*/new Object3D();
const _offset = /*@__PURE__*/new Vector3();
const _box$1 = /*@__PURE__*/new Box3();
const _boxMorphTargets = /*@__PURE__*/new Box3();
const _vector$8 = /*@__PURE__*/new Vector3();
class BufferGeometry extends EventDispatcher {
	constructor() {
		super();
		this.isBufferGeometry = true;
		Object.defineProperty(this, 'id', {
			value: _id$1++
		});
		this.uuid = generateUUID();
		this.name = '';
		this.type = 'BufferGeometry';
		this.index = null;
		this.attributes = {};
		this.morphAttributes = {};
		this.morphTargetsRelative = false;
		this.groups = [];
		this.boundingBox = null;
		this.boundingSphere = null;
		this.drawRange = {
			start: 0,
			count: Infinity
		};
		this.userData = {};
	}
	getIndex() {
		return this.index;
	}
	setIndex(index) {
		if (Array.isArray(index)) {
			this.index = new (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
		} else {
			this.index = index;
		}
		return this;
	}
	getAttribute(name) {
		return this.attributes[name];
	}
	setAttribute(name, attribute) {
		this.attributes[name] = attribute;
		return this;
	}
	deleteAttribute(name) {
		delete this.attributes[name];
		return this;
	}
	hasAttribute(name) {
		return this.attributes[name] !== undefined;
	}
	addGroup(start, count, materialIndex = 0) {
		this.groups.push({
			start: start,
			count: count,
			materialIndex: materialIndex
		});
	}
	clearGroups() {
		this.groups = [];
	}
	setDrawRange(start, count) {
		this.drawRange.start = start;
		this.drawRange.count = count;
	}
	applyMatrix4(matrix) {
		const position = this.attributes.position;
		if (position !== undefined) {
			position.applyMatrix4(matrix);
			position.needsUpdate = true;
		}
		const normal = this.attributes.normal;
		if (normal !== undefined) {
			const normalMatrix = new Matrix3().getNormalMatrix(matrix);
			normal.applyNormalMatrix(normalMatrix);
			normal.needsUpdate = true;
		}
		const tangent = this.attributes.tangent;
		if (tangent !== undefined) {
			tangent.transformDirection(matrix);
			tangent.needsUpdate = true;
		}
		if (this.boundingBox !== null) {
			this.computeBoundingBox();
		}
		if (this.boundingSphere !== null) {
			this.computeBoundingSphere();
		}
		return this;
	}
	applyQuaternion(q) {
		_m1.makeRotationFromQuaternion(q);
		this.applyMatrix4(_m1);
		return this;
	}
	rotateX(angle) {
		// rotate geometry around world x-axis

		_m1.makeRotationX(angle);
		this.applyMatrix4(_m1);
		return this;
	}
	rotateY(angle) {
		// rotate geometry around world y-axis

		_m1.makeRotationY(angle);
		this.applyMatrix4(_m1);
		return this;
	}
	rotateZ(angle) {
		// rotate geometry around world z-axis

		_m1.makeRotationZ(angle);
		this.applyMatrix4(_m1);
		return this;
	}
	translate(x, y, z) {
		// translate geometry

		_m1.makeTranslation(x, y, z);
		this.applyMatrix4(_m1);
		return this;
	}
	scale(x, y, z) {
		// scale geometry

		_m1.makeScale(x, y, z);
		this.applyMatrix4(_m1);
		return this;
	}
	lookAt(vector) {
		_obj.lookAt(vector);
		_obj.updateMatrix();
		this.applyMatrix4(_obj.matrix);
		return this;
	}
	center() {
		this.computeBoundingBox();
		this.boundingBox.getCenter(_offset).negate();
		this.translate(_offset.x, _offset.y, _offset.z);
		return this;
	}
	setFromPoints(points) {
		const position = [];
		for (let i = 0, l = points.length; i < l; i++) {
			const point = points[i];
			position.push(point.x, point.y, point.z || 0);
		}
		this.setAttribute('position', new Float32BufferAttribute(position, 3));
		return this;
	}
	computeBoundingBox() {
		if (this.boundingBox === null) {
			this.boundingBox = new Box3();
		}
		const position = this.attributes.position;
		const morphAttributesPosition = this.morphAttributes.position;
		if (position && position.isGLBufferAttribute) {
			console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
			this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(+Infinity, +Infinity, +Infinity));
			return;
		}
		if (position !== undefined) {
			this.boundingBox.setFromBufferAttribute(position);

			// process morph attributes if present

			if (morphAttributesPosition) {
				for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
					const morphAttribute = morphAttributesPosition[i];
					_box$1.setFromBufferAttribute(morphAttribute);
					if (this.morphTargetsRelative) {
						_vector$8.addVectors(this.boundingBox.min, _box$1.min);
						this.boundingBox.expandByPoint(_vector$8);
						_vector$8.addVectors(this.boundingBox.max, _box$1.max);
						this.boundingBox.expandByPoint(_vector$8);
					} else {
						this.boundingBox.expandByPoint(_box$1.min);
						this.boundingBox.expandByPoint(_box$1.max);
					}
				}
			}
		} else {
			this.boundingBox.makeEmpty();
		}
		if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
			console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
		}
	}
	computeBoundingSphere() {
		if (this.boundingSphere === null) {
			this.boundingSphere = new Sphere();
		}
		const position = this.attributes.position;
		const morphAttributesPosition = this.morphAttributes.position;
		if (position && position.isGLBufferAttribute) {
			console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
			this.boundingSphere.set(new Vector3(), Infinity);
			return;
		}
		if (position) {
			// first, find the center of the bounding sphere

			const center = this.boundingSphere.center;
			_box$1.setFromBufferAttribute(position);

			// process morph attributes if present

			if (morphAttributesPosition) {
				for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
					const morphAttribute = morphAttributesPosition[i];
					_boxMorphTargets.setFromBufferAttribute(morphAttribute);
					if (this.morphTargetsRelative) {
						_vector$8.addVectors(_box$1.min, _boxMorphTargets.min);
						_box$1.expandByPoint(_vector$8);
						_vector$8.addVectors(_box$1.max, _boxMorphTargets.max);
						_box$1.expandByPoint(_vector$8);
					} else {
						_box$1.expandByPoint(_boxMorphTargets.min);
						_box$1.expandByPoint(_boxMorphTargets.max);
					}
				}
			}
			_box$1.getCenter(center);

			// second, try to find a boundingSphere with a radius smaller than the
			// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

			let maxRadiusSq = 0;
			for (let i = 0, il = position.count; i < il; i++) {
				_vector$8.fromBufferAttribute(position, i);
				maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
			}

			// process morph attributes if present

			if (morphAttributesPosition) {
				for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
					const morphAttribute = morphAttributesPosition[i];
					const morphTargetsRelative = this.morphTargetsRelative;
					for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
						_vector$8.fromBufferAttribute(morphAttribute, j);
						if (morphTargetsRelative) {
							_offset.fromBufferAttribute(position, j);
							_vector$8.add(_offset);
						}
						maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
					}
				}
			}
			this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
			if (isNaN(this.boundingSphere.radius)) {
				console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
			}
		}
	}
	computeTangents() {
		const index = this.index;
		const attributes = this.attributes;

		// based on http://www.terathon.com/code/tangent.html
		// (per vertex tangents)

		if (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {
			console.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');
			return;
		}
		const indices = index.array;
		const positions = attributes.position.array;
		const normals = attributes.normal.array;
		const uvs = attributes.uv.array;
		const nVertices = positions.length / 3;
		if (this.hasAttribute('tangent') === false) {
			this.setAttribute('tangent', new BufferAttribute(new Float32Array(4 * nVertices), 4));
		}
		const tangents = this.getAttribute('tangent').array;
		const tan1 = [],
			tan2 = [];
		for (let i = 0; i < nVertices; i++) {
			tan1[i] = new Vector3();
			tan2[i] = new Vector3();
		}
		const vA = new Vector3(),
			vB = new Vector3(),
			vC = new Vector3(),
			uvA = new Vector2(),
			uvB = new Vector2(),
			uvC = new Vector2(),
			sdir = new Vector3(),
			tdir = new Vector3();
		function handleTriangle(a, b, c) {
			vA.fromArray(positions, a * 3);
			vB.fromArray(positions, b * 3);
			vC.fromArray(positions, c * 3);
			uvA.fromArray(uvs, a * 2);
			uvB.fromArray(uvs, b * 2);
			uvC.fromArray(uvs, c * 2);
			vB.sub(vA);
			vC.sub(vA);
			uvB.sub(uvA);
			uvC.sub(uvA);
			const r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y);

			// silently ignore degenerate uv triangles having coincident or colinear vertices

			if (!isFinite(r)) return;
			sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
			tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
			tan1[a].add(sdir);
			tan1[b].add(sdir);
			tan1[c].add(sdir);
			tan2[a].add(tdir);
			tan2[b].add(tdir);
			tan2[c].add(tdir);
		}
		let groups = this.groups;
		if (groups.length === 0) {
			groups = [{
				start: 0,
				count: indices.length
			}];
		}
		for (let i = 0, il = groups.length; i < il; ++i) {
			const group = groups[i];
			const start = group.start;
			const count = group.count;
			for (let j = start, jl = start + count; j < jl; j += 3) {
				handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);
			}
		}
		const tmp = new Vector3(),
			tmp2 = new Vector3();
		const n = new Vector3(),
			n2 = new Vector3();
		function handleVertex(v) {
			n.fromArray(normals, v * 3);
			n2.copy(n);
			const t = tan1[v];

			// Gram-Schmidt orthogonalize

			tmp.copy(t);
			tmp.sub(n.multiplyScalar(n.dot(t))).normalize();

			// Calculate handedness

			tmp2.crossVectors(n2, t);
			const test = tmp2.dot(tan2[v]);
			const w = test < 0.0 ? -1.0 : 1.0;
			tangents[v * 4] = tmp.x;
			tangents[v * 4 + 1] = tmp.y;
			tangents[v * 4 + 2] = tmp.z;
			tangents[v * 4 + 3] = w;
		}
		for (let i = 0, il = groups.length; i < il; ++i) {
			const group = groups[i];
			const start = group.start;
			const count = group.count;
			for (let j = start, jl = start + count; j < jl; j += 3) {
				handleVertex(indices[j + 0]);
				handleVertex(indices[j + 1]);
				handleVertex(indices[j + 2]);
			}
		}
	}
	computeVertexNormals() {
		const index = this.index;
		const positionAttribute = this.getAttribute('position');
		if (positionAttribute !== undefined) {
			let normalAttribute = this.getAttribute('normal');
			if (normalAttribute === undefined) {
				normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
				this.setAttribute('normal', normalAttribute);
			} else {
				// reset existing normals to zero

				for (let i = 0, il = normalAttribute.count; i < il; i++) {
					normalAttribute.setXYZ(i, 0, 0, 0);
				}
			}
			const pA = new Vector3(),
				pB = new Vector3(),
				pC = new Vector3();
			const nA = new Vector3(),
				nB = new Vector3(),
				nC = new Vector3();
			const cb = new Vector3(),
				ab = new Vector3();

			// indexed elements

			if (index) {
				for (let i = 0, il = index.count; i < il; i += 3) {
					const vA = index.getX(i + 0);
					const vB = index.getX(i + 1);
					const vC = index.getX(i + 2);
					pA.fromBufferAttribute(positionAttribute, vA);
					pB.fromBufferAttribute(positionAttribute, vB);
					pC.fromBufferAttribute(positionAttribute, vC);
					cb.subVectors(pC, pB);
					ab.subVectors(pA, pB);
					cb.cross(ab);
					nA.fromBufferAttribute(normalAttribute, vA);
					nB.fromBufferAttribute(normalAttribute, vB);
					nC.fromBufferAttribute(normalAttribute, vC);
					nA.add(cb);
					nB.add(cb);
					nC.add(cb);
					normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
					normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
					normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
				}
			} else {
				// non-indexed elements (unconnected triangle soup)

				for (let i = 0, il = positionAttribute.count; i < il; i += 3) {
					pA.fromBufferAttribute(positionAttribute, i + 0);
					pB.fromBufferAttribute(positionAttribute, i + 1);
					pC.fromBufferAttribute(positionAttribute, i + 2);
					cb.subVectors(pC, pB);
					ab.subVectors(pA, pB);
					cb.cross(ab);
					normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);
					normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);
					normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);
				}
			}
			this.normalizeNormals();
			normalAttribute.needsUpdate = true;
		}
	}

	// @deprecated since r144

	merge() {
		console.error('THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead.');
		return this;
	}
	normalizeNormals() {
		const normals = this.attributes.normal;
		for (let i = 0, il = normals.count; i < il; i++) {
			_vector$8.fromBufferAttribute(normals, i);
			_vector$8.normalize();
			normals.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z);
		}
	}
	toNonIndexed() {
		function convertBufferAttribute(attribute, indices) {
			const array = attribute.array;
			const itemSize = attribute.itemSize;
			const normalized = attribute.normalized;
			const array2 = new array.constructor(indices.length * itemSize);
			let index = 0,
				index2 = 0;
			for (let i = 0, l = indices.length; i < l; i++) {
				if (attribute.isInterleavedBufferAttribute) {
					index = indices[i] * attribute.data.stride + attribute.offset;
				} else {
					index = indices[i] * itemSize;
				}
				for (let j = 0; j < itemSize; j++) {
					array2[index2++] = array[index++];
				}
			}
			return new BufferAttribute(array2, itemSize, normalized);
		}

		//

		if (this.index === null) {
			console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');
			return this;
		}
		const geometry2 = new BufferGeometry();
		const indices = this.index.array;
		const attributes = this.attributes;

		// attributes

		for (const name in attributes) {
			const attribute = attributes[name];
			const newAttribute = convertBufferAttribute(attribute, indices);
			geometry2.setAttribute(name, newAttribute);
		}

		// morph attributes

		const morphAttributes = this.morphAttributes;
		for (const name in morphAttributes) {
			const morphArray = [];
			const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

			for (let i = 0, il = morphAttribute.length; i < il; i++) {
				const attribute = morphAttribute[i];
				const newAttribute = convertBufferAttribute(attribute, indices);
				morphArray.push(newAttribute);
			}
			geometry2.morphAttributes[name] = morphArray;
		}
		geometry2.morphTargetsRelative = this.morphTargetsRelative;

		// groups

		const groups = this.groups;
		for (let i = 0, l = groups.length; i < l; i++) {
			const group = groups[i];
			geometry2.addGroup(group.start, group.count, group.materialIndex);
		}
		return geometry2;
	}
	toJSON() {
		const data = {
			metadata: {
				version: 4.5,
				type: 'BufferGeometry',
				generator: 'BufferGeometry.toJSON'
			}
		};

		// standard BufferGeometry serialization

		data.uuid = this.uuid;
		data.type = this.type;
		if (this.name !== '') data.name = this.name;
		if (Object.keys(this.userData).length > 0) data.userData = this.userData;
		if (this.parameters !== undefined) {
			const parameters = this.parameters;
			for (const key in parameters) {
				if (parameters[key] !== undefined) data[key] = parameters[key];
			}
			return data;
		}

		// for simplicity the code assumes attributes are not shared across geometries, see #15811

		data.data = {
			attributes: {}
		};
		const index = this.index;
		if (index !== null) {
			data.data.index = {
				type: index.array.constructor.name,
				array: Array.prototype.slice.call(index.array)
			};
		}
		const attributes = this.attributes;
		for (const key in attributes) {
			const attribute = attributes[key];
			data.data.attributes[key] = attribute.toJSON(data.data);
		}
		const morphAttributes = {};
		let hasMorphAttributes = false;
		for (const key in this.morphAttributes) {
			const attributeArray = this.morphAttributes[key];
			const array = [];
			for (let i = 0, il = attributeArray.length; i < il; i++) {
				const attribute = attributeArray[i];
				array.push(attribute.toJSON(data.data));
			}
			if (array.length > 0) {
				morphAttributes[key] = array;
				hasMorphAttributes = true;
			}
		}
		if (hasMorphAttributes) {
			data.data.morphAttributes = morphAttributes;
			data.data.morphTargetsRelative = this.morphTargetsRelative;
		}
		const groups = this.groups;
		if (groups.length > 0) {
			data.data.groups = JSON.parse(JSON.stringify(groups));
		}
		const boundingSphere = this.boundingSphere;
		if (boundingSphere !== null) {
			data.data.boundingSphere = {
				center: boundingSphere.center.toArray(),
				radius: boundingSphere.radius
			};
		}
		return data;
	}
	clone() {
		return new this.constructor().copy(this);
	}
	copy(source) {
		// reset

		this.index = null;
		this.attributes = {};
		this.morphAttributes = {};
		this.groups = [];
		this.boundingBox = null;
		this.boundingSphere = null;

		// used for storing cloned, shared data

		const data = {};

		// name

		this.name = source.name;

		// index

		const index = source.index;
		if (index !== null) {
			this.setIndex(index.clone(data));
		}

		// attributes

		const attributes = source.attributes;
		for (const name in attributes) {
			const attribute = attributes[name];
			this.setAttribute(name, attribute.clone(data));
		}

		// morph attributes

		const morphAttributes = source.morphAttributes;
		for (const name in morphAttributes) {
			const array = [];
			const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

			for (let i = 0, l = morphAttribute.length; i < l; i++) {
				array.push(morphAttribute[i].clone(data));
			}
			this.morphAttributes[name] = array;
		}
		this.morphTargetsRelative = source.morphTargetsRelative;

		// groups

		const groups = source.groups;
		for (let i = 0, l = groups.length; i < l; i++) {
			const group = groups[i];
			this.addGroup(group.start, group.count, group.materialIndex);
		}

		// bounding box

		const boundingBox = source.boundingBox;
		if (boundingBox !== null) {
			this.boundingBox = boundingBox.clone();
		}

		// bounding sphere

		const boundingSphere = source.boundingSphere;
		if (boundingSphere !== null) {
			this.boundingSphere = boundingSphere.clone();
		}

		// draw range

		this.drawRange.start = source.drawRange.start;
		this.drawRange.count = source.drawRange.count;

		// user data

		this.userData = source.userData;

		// geometry generator parameters

		if (source.parameters !== undefined) this.parameters = Object.assign({}, source.parameters);
		return this;
	}
	dispose() {
		this.dispatchEvent({
			type: 'dispose'
		});
	}
}

const _inverseMatrix$2 = /*@__PURE__*/new Matrix4();
const _ray$2 = /*@__PURE__*/new Ray();
const _sphere$3 = /*@__PURE__*/new Sphere();
const _vA$1 = /*@__PURE__*/new Vector3();
const _vB$1 = /*@__PURE__*/new Vector3();
const _vC$1 = /*@__PURE__*/new Vector3();
const _tempA = /*@__PURE__*/new Vector3();
const _tempB = /*@__PURE__*/new Vector3();
const _tempC = /*@__PURE__*/new Vector3();
const _morphA = /*@__PURE__*/new Vector3();
const _morphB = /*@__PURE__*/new Vector3();
const _morphC = /*@__PURE__*/new Vector3();
const _uvA$1 = /*@__PURE__*/new Vector2();
const _uvB$1 = /*@__PURE__*/new Vector2();
const _uvC$1 = /*@__PURE__*/new Vector2();
const _intersectionPoint = /*@__PURE__*/new Vector3();
const _intersectionPointWorld = /*@__PURE__*/new Vector3();
class Mesh extends Object3D {
	constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
		super();
		this.isMesh = true;
		this.type = 'Mesh';
		this.geometry = geometry;
		this.material = material;
		this.updateMorphTargets();
	}
	copy(source, recursive) {
		super.copy(source, recursive);
		if (source.morphTargetInfluences !== undefined) {
			this.morphTargetInfluences = source.morphTargetInfluences.slice();
		}
		if (source.morphTargetDictionary !== undefined) {
			this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
		}
		this.material = source.material;
		this.geometry = source.geometry;
		return this;
	}
	updateMorphTargets() {
		const geometry = this.geometry;
		const morphAttributes = geometry.morphAttributes;
		const keys = Object.keys(morphAttributes);
		if (keys.length > 0) {
			const morphAttribute = morphAttributes[keys[0]];
			if (morphAttribute !== undefined) {
				this.morphTargetInfluences = [];
				this.morphTargetDictionary = {};
				for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
					const name = morphAttribute[m].name || String(m);
					this.morphTargetInfluences.push(0);
					this.morphTargetDictionary[name] = m;
				}
			}
		}
	}
	raycast(raycaster, intersects) {
		const geometry = this.geometry;
		const material = this.material;
		const matrixWorld = this.matrixWorld;
		if (material === undefined) return;

		// Checking boundingSphere distance to ray

		if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
		_sphere$3.copy(geometry.boundingSphere);
		_sphere$3.applyMatrix4(matrixWorld);
		if (raycaster.ray.intersectsSphere(_sphere$3) === false) return;

		//

		_inverseMatrix$2.copy(matrixWorld).invert();
		_ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);

		// Check boundingBox before continuing

		if (geometry.boundingBox !== null) {
			if (_ray$2.intersectsBox(geometry.boundingBox) === false) return;
		}
		let intersection;
		const index = geometry.index;
		const position = geometry.attributes.position;
		const morphPosition = geometry.morphAttributes.position;
		const morphTargetsRelative = geometry.morphTargetsRelative;
		const uv = geometry.attributes.uv;
		const uv2 = geometry.attributes.uv2;
		const groups = geometry.groups;
		const drawRange = geometry.drawRange;
		if (index !== null) {
			// indexed buffer geometry

			if (Array.isArray(material)) {
				for (let i = 0, il = groups.length; i < il; i++) {
					const group = groups[i];
					const groupMaterial = material[group.materialIndex];
					const start = Math.max(group.start, drawRange.start);
					const end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
					for (let j = start, jl = end; j < jl; j += 3) {
						const a = index.getX(j);
						const b = index.getX(j + 1);
						const c = index.getX(j + 2);
						intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
						if (intersection) {
							intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics
							intersection.face.materialIndex = group.materialIndex;
							intersects.push(intersection);
						}
					}
				}
			} else {
				const start = Math.max(0, drawRange.start);
				const end = Math.min(index.count, drawRange.start + drawRange.count);
				for (let i = start, il = end; i < il; i += 3) {
					const a = index.getX(i);
					const b = index.getX(i + 1);
					const c = index.getX(i + 2);
					intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
					if (intersection) {
						intersection.faceIndex = Math.floor(i / 3); // triangle number in indexed buffer semantics
						intersects.push(intersection);
					}
				}
			}
		} else if (position !== undefined) {
			// non-indexed buffer geometry

			if (Array.isArray(material)) {
				for (let i = 0, il = groups.length; i < il; i++) {
					const group = groups[i];
					const groupMaterial = material[group.materialIndex];
					const start = Math.max(group.start, drawRange.start);
					const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
					for (let j = start, jl = end; j < jl; j += 3) {
						const a = j;
						const b = j + 1;
						const c = j + 2;
						intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
						if (intersection) {
							intersection.faceIndex = Math.floor(j / 3); // triangle number in non-indexed buffer semantics
							intersection.face.materialIndex = group.materialIndex;
							intersects.push(intersection);
						}
					}
				}
			} else {
				const start = Math.max(0, drawRange.start);
				const end = Math.min(position.count, drawRange.start + drawRange.count);
				for (let i = start, il = end; i < il; i += 3) {
					const a = i;
					const b = i + 1;
					const c = i + 2;
					intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
					if (intersection) {
						intersection.faceIndex = Math.floor(i / 3); // triangle number in non-indexed buffer semantics
						intersects.push(intersection);
					}
				}
			}
		}
	}
}
function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
	let intersect;
	if (material.side === BackSide) {
		intersect = ray.intersectTriangle(pC, pB, pA, true, point);
	} else {
		intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
	}
	if (intersect === null) return null;
	_intersectionPointWorld.copy(point);
	_intersectionPointWorld.applyMatrix4(object.matrixWorld);
	const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
	if (distance < raycaster.near || distance > raycaster.far) return null;
	return {
		distance: distance,
		point: _intersectionPointWorld.clone(),
		object: object
	};
}
function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {
	_vA$1.fromBufferAttribute(position, a);
	_vB$1.fromBufferAttribute(position, b);
	_vC$1.fromBufferAttribute(position, c);
	const morphInfluences = object.morphTargetInfluences;
	if (morphPosition && morphInfluences) {
		_morphA.set(0, 0, 0);
		_morphB.set(0, 0, 0);
		_morphC.set(0, 0, 0);
		for (let i = 0, il = morphPosition.length; i < il; i++) {
			const influence = morphInfluences[i];
			const morphAttribute = morphPosition[i];
			if (influence === 0) continue;
			_tempA.fromBufferAttribute(morphAttribute, a);
			_tempB.fromBufferAttribute(morphAttribute, b);
			_tempC.fromBufferAttribute(morphAttribute, c);
			if (morphTargetsRelative) {
				_morphA.addScaledVector(_tempA, influence);
				_morphB.addScaledVector(_tempB, influence);
				_morphC.addScaledVector(_tempC, influence);
			} else {
				_morphA.addScaledVector(_tempA.sub(_vA$1), influence);
				_morphB.addScaledVector(_tempB.sub(_vB$1), influence);
				_morphC.addScaledVector(_tempC.sub(_vC$1), influence);
			}
		}
		_vA$1.add(_morphA);
		_vB$1.add(_morphB);
		_vC$1.add(_morphC);
	}
	if (object.isSkinnedMesh) {
		object.boneTransform(a, _vA$1);
		object.boneTransform(b, _vB$1);
		object.boneTransform(c, _vC$1);
	}
	const intersection = checkIntersection(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
	if (intersection) {
		if (uv) {
			_uvA$1.fromBufferAttribute(uv, a);
			_uvB$1.fromBufferAttribute(uv, b);
			_uvC$1.fromBufferAttribute(uv, c);
			intersection.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
		}
		if (uv2) {
			_uvA$1.fromBufferAttribute(uv2, a);
			_uvB$1.fromBufferAttribute(uv2, b);
			_uvC$1.fromBufferAttribute(uv2, c);
			intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
		}
		const face = {
			a: a,
			b: b,
			c: c,
			normal: new Vector3(),
			materialIndex: 0
		};
		Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
		intersection.face = face;
	}
	return intersection;
}

class BoxGeometry extends BufferGeometry {
	constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
		super();
		this.type = 'BoxGeometry';
		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};
		const scope = this;

		// segments

		widthSegments = Math.floor(widthSegments);
		heightSegments = Math.floor(heightSegments);
		depthSegments = Math.floor(depthSegments);

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let numberOfVertices = 0;
		let groupStart = 0;

		// build each side of the box geometry

		buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px
		buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx
		buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py
		buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny
		buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz
		buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz

		// build geometry

		this.setIndex(indices);
		this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
		this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
		this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
		function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
			const segmentWidth = width / gridX;
			const segmentHeight = height / gridY;
			const widthHalf = width / 2;
			const heightHalf = height / 2;
			const depthHalf = depth / 2;
			const gridX1 = gridX + 1;
			const gridY1 = gridY + 1;
			let vertexCounter = 0;
			let groupCount = 0;
			const vector = new Vector3();

			// generate vertices, normals and uvs

			for (let iy = 0; iy < gridY1; iy++) {
				const y = iy * segmentHeight - heightHalf;
				for (let ix = 0; ix < gridX1; ix++) {
					const x = ix * segmentWidth - widthHalf;

					// set values to correct vector component

					vector[u] = x * udir;
					vector[v] = y * vdir;
					vector[w] = depthHalf;

					// now apply vector to vertex buffer

					vertices.push(vector.x, vector.y, vector.z);

					// set values to correct vector component

					vector[u] = 0;
					vector[v] = 0;
					vector[w] = depth > 0 ? 1 : -1;

					// now apply vector to normal buffer

					normals.push(vector.x, vector.y, vector.z);

					// uvs

					uvs.push(ix / gridX);
					uvs.push(1 - iy / gridY);

					// counters

					vertexCounter += 1;
				}
			}

			// indices

			// 1. you need three indices to draw a single face
			// 2. a single segment consists of two faces
			// 3. so we need to generate six (2*3) indices per segment

			for (let iy = 0; iy < gridY; iy++) {
				for (let ix = 0; ix < gridX; ix++) {
					const a = numberOfVertices + ix + gridX1 * iy;
					const b = numberOfVertices + ix + gridX1 * (iy + 1);
					const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
					const d = numberOfVertices + (ix + 1) + gridX1 * iy;

					// faces

					indices.push(a, b, d);
					indices.push(b, c, d);

					// increase counter

					groupCount += 6;
				}
			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup(groupStart, groupCount, materialIndex);

			// calculate new start value for groups

			groupStart += groupCount;

			// update total number of vertices

			numberOfVertices += vertexCounter;
		}
	}
	static fromJSON(data) {
		return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
	}
}

/**
 * Uniform Utilities
 */

function cloneUniforms(src) {
	const dst = {};
	for (const u in src) {
		dst[u] = {};
		for (const p in src[u]) {
			const property = src[u][p];
			if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
				dst[u][p] = property.clone();
			} else if (Array.isArray(property)) {
				dst[u][p] = property.slice();
			} else {
				dst[u][p] = property;
			}
		}
	}
	return dst;
}
function mergeUniforms(uniforms) {
	const merged = {};
	for (let u = 0; u < uniforms.length; u++) {
		const tmp = cloneUniforms(uniforms[u]);
		for (const p in tmp) {
			merged[p] = tmp[p];
		}
	}
	return merged;
}
function cloneUniformsGroups(src) {
	const dst = [];
	for (let u = 0; u < src.length; u++) {
		dst.push(src[u].clone());
	}
	return dst;
}

// Legacy

const UniformsUtils = {
	clone: cloneUniforms,
	merge: mergeUniforms
};

var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

class ShaderMaterial extends Material {
	constructor(parameters) {
		super();
		this.isShaderMaterial = true;
		this.type = 'ShaderMaterial';
		this.defines = {};
		this.uniforms = {};
		this.uniformsGroups = [];
		this.vertexShader = default_vertex;
		this.fragmentShader = default_fragment;
		this.linewidth = 1;
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.fog = false; // set to use scene fog
		this.lights = false; // set to use scene lights
		this.clipping = false; // set to use user-defined clipping planes

		this.extensions = {
			derivatives: false,
			// set to use derivatives
			fragDepth: false,
			// set to use fragment depth values
			drawBuffers: false,
			// set to use draw buffers
			shaderTextureLOD: false // set to use shader texture LOD
		};

		// When rendered geometry doesn't include these attributes but the material does,
		// use these default values in WebGL. This avoids errors when buffer data is missing.
		this.defaultAttributeValues = {
			'color': [1, 1, 1],
			'uv': [0, 0],
			'uv2': [0, 0]
		};
		this.index0AttributeName = undefined;
		this.uniformsNeedUpdate = false;
		this.glslVersion = null;
		if (parameters !== undefined) {
			this.setValues(parameters);
		}
	}
	copy(source) {
		super.copy(source);
		this.fragmentShader = source.fragmentShader;
		this.vertexShader = source.vertexShader;
		this.uniforms = cloneUniforms(source.uniforms);
		this.uniformsGroups = cloneUniformsGroups(source.uniformsGroups);
		this.defines = Object.assign({}, source.defines);
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.fog = source.fog;
		this.lights = source.lights;
		this.clipping = source.clipping;
		this.extensions = Object.assign({}, source.extensions);
		this.glslVersion = source.glslVersion;
		return this;
	}
	toJSON(meta) {
		const data = super.toJSON(meta);
		data.glslVersion = this.glslVersion;
		data.uniforms = {};
		for (const name in this.uniforms) {
			const uniform = this.uniforms[name];
			const value = uniform.value;
			if (value && value.isTexture) {
				data.uniforms[name] = {
					type: 't',
					value: value.toJSON(meta).uuid
				};
			} else if (value && value.isColor) {
				data.uniforms[name] = {
					type: 'c',
					value: value.getHex()
				};
			} else if (value && value.isVector2) {
				data.uniforms[name] = {
					type: 'v2',
					value: value.toArray()
				};
			} else if (value && value.isVector3) {
				data.uniforms[name] = {
					type: 'v3',
					value: value.toArray()
				};
			} else if (value && value.isVector4) {
				data.uniforms[name] = {
					type: 'v4',
					value: value.toArray()
				};
			} else if (value && value.isMatrix3) {
				data.uniforms[name] = {
					type: 'm3',
					value: value.toArray()
				};
			} else if (value && value.isMatrix4) {
				data.uniforms[name] = {
					type: 'm4',
					value: value.toArray()
				};
			} else {
				data.uniforms[name] = {
					value: value
				};

				// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far
			}
		}

		if (Object.keys(this.defines).length > 0) data.defines = this.defines;
		data.vertexShader = this.vertexShader;
		data.fragmentShader = this.fragmentShader;
		const extensions = {};
		for (const key in this.extensions) {
			if (this.extensions[key] === true) extensions[key] = true;
		}
		if (Object.keys(extensions).length > 0) data.extensions = extensions;
		return data;
	}
}

class Camera extends Object3D {
	constructor() {
		super();
		this.isCamera = true;
		this.type = 'Camera';
		this.matrixWorldInverse = new Matrix4();
		this.projectionMatrix = new Matrix4();
		this.projectionMatrixInverse = new Matrix4();
	}
	copy(source, recursive) {
		super.copy(source, recursive);
		this.matrixWorldInverse.copy(source.matrixWorldInverse);
		this.projectionMatrix.copy(source.projectionMatrix);
		this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
		return this;
	}
	getWorldDirection(target) {
		this.updateWorldMatrix(true, false);
		const e = this.matrixWorld.elements;
		return target.set(-e[8], -e[9], -e[10]).normalize();
	}
	updateMatrixWorld(force) {
		super.updateMatrixWorld(force);
		this.matrixWorldInverse.copy(this.matrixWorld).invert();
	}
	updateWorldMatrix(updateParents, updateChildren) {
		super.updateWorldMatrix(updateParents, updateChildren);
		this.matrixWorldInverse.copy(this.matrixWorld).invert();
	}
	clone() {
		return new this.constructor().copy(this);
	}
}

class PerspectiveCamera extends Camera {
	constructor(fov = 50, aspect = 1, near = 0.1, far = 2000) {
		super();
		this.isPerspectiveCamera = true;
		this.type = 'PerspectiveCamera';
		this.fov = fov;
		this.zoom = 1;
		this.near = near;
		this.far = far;
		this.focus = 10;
		this.aspect = aspect;
		this.view = null;
		this.filmGauge = 35; // width of the film (default in millimeters)
		this.filmOffset = 0; // horizontal film offset (same unit as gauge)

		this.updateProjectionMatrix();
	}
	copy(source, recursive) {
		super.copy(source, recursive);
		this.fov = source.fov;
		this.zoom = source.zoom;
		this.near = source.near;
		this.far = source.far;
		this.focus = source.focus;
		this.aspect = source.aspect;
		this.view = source.view === null ? null : Object.assign({}, source.view);
		this.filmGauge = source.filmGauge;
		this.filmOffset = source.filmOffset;
		return this;
	}

	/**
	 * Sets the FOV by focal length in respect to the current .filmGauge.
	 *
	 * The default film gauge is 35, so that the focal length can be specified for
	 * a 35mm (full frame) camera.
	 *
	 * Values for focal length and film gauge must have the same unit.
	 */
	setFocalLength(focalLength) {
		/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
		const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
		this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
		this.updateProjectionMatrix();
	}

	/**
	 * Calculates the focal length from the current .fov and .filmGauge.
	 */
	getFocalLength() {
		const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
		return 0.5 * this.getFilmHeight() / vExtentSlope;
	}
	getEffectiveFOV() {
		return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom);
	}
	getFilmWidth() {
		// film not completely covered in portrait format (aspect < 1)
		return this.filmGauge * Math.min(this.aspect, 1);
	}
	getFilmHeight() {
		// film not completely covered in landscape format (aspect > 1)
		return this.filmGauge / Math.max(this.aspect, 1);
	}

	/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *	 +---+---+---+
	 *	 | A | B | C |
	 *	 +---+---+---+
	 *	 | D | E | F |
	 *	 +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *	 const w = 1920;
	 *	 const h = 1080;
	 *	 const fullWidth = w * 3;
	 *	 const fullHeight = h * 2;
	 *
	 *	 --A--
	 *	 camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *	 --B--
	 *	 camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *	 --C--
	 *	 camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *	 --D--
	 *	 camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *	 --E--
	 *	 camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *	 --F--
	 *	 camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *	 Note there is no reason monitors have to be the same size or in a grid.
	 */
	setViewOffset(fullWidth, fullHeight, x, y, width, height) {
		this.aspect = fullWidth / fullHeight;
		if (this.view === null) {
			this.view = {
				enabled: true,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			};
		}
		this.view.enabled = true;
		this.view.fullWidth = fullWidth;
		this.view.fullHeight = fullHeight;
		this.view.offsetX = x;
		this.view.offsetY = y;
		this.view.width = width;
		this.view.height = height;
		this.updateProjectionMatrix();
	}
	clearViewOffset() {
		if (this.view !== null) {
			this.view.enabled = false;
		}
		this.updateProjectionMatrix();
	}
	updateProjectionMatrix() {
		const near = this.near;
		let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
		let height = 2 * top;
		let width = this.aspect * height;
		let left = -0.5 * width;
		const view = this.view;
		if (this.view !== null && this.view.enabled) {
			const fullWidth = view.fullWidth,
				fullHeight = view.fullHeight;
			left += view.offsetX * width / fullWidth;
			top -= view.offsetY * height / fullHeight;
			width *= view.width / fullWidth;
			height *= view.height / fullHeight;
		}
		const skew = this.filmOffset;
		if (skew !== 0) left += near * skew / this.getFilmWidth();
		this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
		this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
	}
	toJSON(meta) {
		const data = super.toJSON(meta);
		data.object.fov = this.fov;
		data.object.zoom = this.zoom;
		data.object.near = this.near;
		data.object.far = this.far;
		data.object.focus = this.focus;
		data.object.aspect = this.aspect;
		if (this.view !== null) data.object.view = Object.assign({}, this.view);
		data.object.filmGauge = this.filmGauge;
		data.object.filmOffset = this.filmOffset;
		return data;
	}
}

const fov = 90,
	aspect = 1;
class CubeCamera extends Object3D {
	constructor(near, far, renderTarget) {
		super();
		this.type = 'CubeCamera';
		this.renderTarget = renderTarget;
		const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
		cameraPX.layers = this.layers;
		cameraPX.up.set(0, -1, 0);
		cameraPX.lookAt(new Vector3(1, 0, 0));
		this.add(cameraPX);
		const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
		cameraNX.layers = this.layers;
		cameraNX.up.set(0, -1, 0);
		cameraNX.lookAt(new Vector3(-1, 0, 0));
		this.add(cameraNX);
		const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
		cameraPY.layers = this.layers;
		cameraPY.up.set(0, 0, 1);
		cameraPY.lookAt(new Vector3(0, 1, 0));
		this.add(cameraPY);
		const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
		cameraNY.layers = this.layers;
		cameraNY.up.set(0, 0, -1);
		cameraNY.lookAt(new Vector3(0, -1, 0));
		this.add(cameraNY);
		const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
		cameraPZ.layers = this.layers;
		cameraPZ.up.set(0, -1, 0);
		cameraPZ.lookAt(new Vector3(0, 0, 1));
		this.add(cameraPZ);
		const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
		cameraNZ.layers = this.layers;
		cameraNZ.up.set(0, -1, 0);
		cameraNZ.lookAt(new Vector3(0, 0, -1));
		this.add(cameraNZ);
	}
	update(renderer, scene) {
		if (this.parent === null) this.updateMatrixWorld();
		const renderTarget = this.renderTarget;
		const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
		const currentRenderTarget = renderer.getRenderTarget();
		const currentToneMapping = renderer.toneMapping;
		const currentXrEnabled = renderer.xr.enabled;
		renderer.toneMapping = NoToneMapping;
		renderer.xr.enabled = false;
		const generateMipmaps = renderTarget.texture.generateMipmaps;
		renderTarget.texture.generateMipmaps = false;
		renderer.setRenderTarget(renderTarget, 0);
		renderer.render(scene, cameraPX);
		renderer.setRenderTarget(renderTarget, 1);
		renderer.render(scene, cameraNX);
		renderer.setRenderTarget(renderTarget, 2);
		renderer.render(scene, cameraPY);
		renderer.setRenderTarget(renderTarget, 3);
		renderer.render(scene, cameraNY);
		renderer.setRenderTarget(renderTarget, 4);
		renderer.render(scene, cameraPZ);
		renderTarget.texture.generateMipmaps = generateMipmaps;
		renderer.setRenderTarget(renderTarget, 5);
		renderer.render(scene, cameraNZ);
		renderer.setRenderTarget(currentRenderTarget);
		renderer.toneMapping = currentToneMapping;
		renderer.xr.enabled = currentXrEnabled;
		renderTarget.texture.needsPMREMUpdate = true;
	}
}

class CubeTexture extends Texture {
	constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
		images = images !== undefined ? images : [];
		mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
		super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
		this.isCubeTexture = true;
		this.flipY = false;
	}
	get images() {
		return this.image;
	}
	set images(value) {
		this.image = value;
	}
}

class WebGLCubeRenderTarget extends WebGLRenderTarget {
	constructor(size = 1, options = {}) {
		super(size, size, options);
		this.isWebGLCubeRenderTarget = true;
		const image = {
			width: size,
			height: size,
			depth: 1
		};
		const images = [image, image, image, image, image, image];
		this.texture = new CubeTexture(images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);

		// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
		// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
		// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.

		// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
		// and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
		// as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).

		this.texture.isRenderTargetTexture = true;
		this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
		this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
	}
	fromEquirectangularTexture(renderer, texture) {
		this.texture.type = texture.type;
		this.texture.encoding = texture.encoding;
		this.texture.generateMipmaps = texture.generateMipmaps;
		this.texture.minFilter = texture.minFilter;
		this.texture.magFilter = texture.magFilter;
		const shader = {
			uniforms: {
				tEquirect: {
					value: null
				}
			},
			vertexShader: /* glsl */`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
			fragmentShader: /* glsl */`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
		};
		const geometry = new BoxGeometry(5, 5, 5);
		const material = new ShaderMaterial({
			name: 'CubemapFromEquirect',
			uniforms: cloneUniforms(shader.uniforms),
			vertexShader: shader.vertexShader,
			fragmentShader: shader.fragmentShader,
			side: BackSide,
			blending: NoBlending
		});
		material.uniforms.tEquirect.value = texture;
		const mesh = new Mesh(geometry, material);
		const currentMinFilter = texture.minFilter;

		// Avoid blurred poles
		if (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;
		const camera = new CubeCamera(1, 10, this);
		camera.update(renderer, mesh);
		texture.minFilter = currentMinFilter;
		mesh.geometry.dispose();
		mesh.material.dispose();
		return this;
	}
	clear(renderer, color, depth, stencil) {
		const currentRenderTarget = renderer.getRenderTarget();
		for (let i = 0; i < 6; i++) {
			renderer.setRenderTarget(this, i);
			renderer.clear(color, depth, stencil);
		}
		renderer.setRenderTarget(currentRenderTarget);
	}
}

const _vector1 = /*@__PURE__*/new Vector3();
const _vector2 = /*@__PURE__*/new Vector3();
const _normalMatrix = /*@__PURE__*/new Matrix3();
class Plane {
	constructor(normal = new Vector3(1, 0, 0), constant = 0) {
		this.isPlane = true;

		// normal is assumed to be normalized

		this.normal = normal;
		this.constant = constant;
	}
	set(normal, constant) {
		this.normal.copy(normal);
		this.constant = constant;
		return this;
	}
	setComponents(x, y, z, w) {
		this.normal.set(x, y, z);
		this.constant = w;
		return this;
	}
	setFromNormalAndCoplanarPoint(normal, point) {
		this.normal.copy(normal);
		this.constant = -point.dot(this.normal);
		return this;
	}
	setFromCoplanarPoints(a, b, c) {
		const normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();

		// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

		this.setFromNormalAndCoplanarPoint(normal, a);
		return this;
	}
	copy(plane) {
		this.normal.copy(plane.normal);
		this.constant = plane.constant;
		return this;
	}
	normalize() {
		// Note: will lead to a divide by zero if the plane is invalid.

		const inverseNormalLength = 1.0 / this.normal.length();
		this.normal.multiplyScalar(inverseNormalLength);
		this.constant *= inverseNormalLength;
		return this;
	}
	negate() {
		this.constant *= -1;
		this.normal.negate();
		return this;
	}
	distanceToPoint(point) {
		return this.normal.dot(point) + this.constant;
	}
	distanceToSphere(sphere) {
		return this.distanceToPoint(sphere.center) - sphere.radius;
	}
	projectPoint(point, target) {
		return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
	}
	intersectLine(line, target) {
		const direction = line.delta(_vector1);
		const denominator = this.normal.dot(direction);
		if (denominator === 0) {
			// line is coplanar, return origin
			if (this.distanceToPoint(line.start) === 0) {
				return target.copy(line.start);
			}

			// Unsure if this is the correct method to handle this case.
			return null;
		}
		const t = -(line.start.dot(this.normal) + this.constant) / denominator;
		if (t < 0 || t > 1) {
			return null;
		}
		return target.copy(direction).multiplyScalar(t).add(line.start);
	}
	intersectsLine(line) {
		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

		const startSign = this.distanceToPoint(line.start);
		const endSign = this.distanceToPoint(line.end);
		return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
	}
	intersectsBox(box) {
		return box.intersectsPlane(this);
	}
	intersectsSphere(sphere) {
		return sphere.intersectsPlane(this);
	}
	coplanarPoint(target) {
		return target.copy(this.normal).multiplyScalar(-this.constant);
	}
	applyMatrix4(matrix, optionalNormalMatrix) {
		const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
		const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
		const normal = this.normal.applyMatrix3(normalMatrix).normalize();
		this.constant = -referencePoint.dot(normal);
		return this;
	}
	translate(offset) {
		this.constant -= offset.dot(this.normal);
		return this;
	}
	equals(plane) {
		return plane.normal.equals(this.normal) && plane.constant === this.constant;
	}
	clone() {
		return new this.constructor().copy(this);
	}
}

const _sphere$2 = /*@__PURE__*/new Sphere();
const _vector$7 = /*@__PURE__*/new Vector3();
class Frustum {
	constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
		this.planes = [p0, p1, p2, p3, p4, p5];
	}
	set(p0, p1, p2, p3, p4, p5) {
		const planes = this.planes;
		planes[0].copy(p0);
		planes[1].copy(p1);
		planes[2].copy(p2);
		planes[3].copy(p3);
		planes[4].copy(p4);
		planes[5].copy(p5);
		return this;
	}
	copy(frustum) {
		const planes = this.planes;
		for (let i = 0; i < 6; i++) {
			planes[i].copy(frustum.planes[i]);
		}
		return this;
	}
	setFromProjectionMatrix(m) {
		const planes = this.planes;
		const me = m.elements;
		const me0 = me[0],
			me1 = me[1],
			me2 = me[2],
			me3 = me[3];
		const me4 = me[4],
			me5 = me[5],
			me6 = me[6],
			me7 = me[7];
		const me8 = me[8],
			me9 = me[9],
			me10 = me[10],
			me11 = me[11];
		const me12 = me[12],
			me13 = me[13],
			me14 = me[14],
			me15 = me[15];
		planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
		planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
		planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
		planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
		planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
		planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
		return this;
	}
	intersectsObject(object) {
		const geometry = object.geometry;
		if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
		_sphere$2.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
		return this.intersectsSphere(_sphere$2);
	}
	intersectsSprite(sprite) {
		_sphere$2.center.set(0, 0, 0);
		_sphere$2.radius = 0.7071067811865476;
		_sphere$2.applyMatrix4(sprite.matrixWorld);
		return this.intersectsSphere(_sphere$2);
	}
	intersectsSphere(sphere) {
		const planes = this.planes;
		const center = sphere.center;
		const negRadius = -sphere.radius;
		for (let i = 0; i < 6; i++) {
			const distance = planes[i].distanceToPoint(center);
			if (distance < negRadius) {
				return false;
			}
		}
		return true;
	}
	intersectsBox(box) {
		const planes = this.planes;
		for (let i = 0; i < 6; i++) {
			const plane = planes[i];

			// corner at max distance

			_vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
			_vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
			_vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;
			if (plane.distanceToPoint(_vector$7) < 0) {
				return false;
			}
		}
		return true;
	}
	containsPoint(point) {
		const planes = this.planes;
		for (let i = 0; i < 6; i++) {
			if (planes[i].distanceToPoint(point) < 0) {
				return false;
			}
		}
		return true;
	}
	clone() {
		return new this.constructor().copy(this);
	}
}

function WebGLAnimation() {
	let context = null;
	let isAnimating = false;
	let animationLoop = null;
	let requestId = null;
	function onAnimationFrame(time, frame) {
		animationLoop(time, frame);
		requestId = context.requestAnimationFrame(onAnimationFrame);
	}
	return {
		start: function () {
			if (isAnimating === true) return;
			if (animationLoop === null) return;
			requestId = context.requestAnimationFrame(onAnimationFrame);
			isAnimating = true;
		},
		stop: function () {
			context.cancelAnimationFrame(requestId);
			isAnimating = false;
		},
		setAnimationLoop: function (callback) {
			animationLoop = callback;
		},
		setContext: function (value) {
			context = value;
		}
	};
}

function WebGLAttributes(gl, capabilities) {
	const isWebGL2 = capabilities.isWebGL2;
	const buffers = new WeakMap();
	function createBuffer(attribute, bufferType) {
		const array = attribute.array;
		const usage = attribute.usage;
		const buffer = gl.createBuffer();
		gl.bindBuffer(bufferType, buffer);
		gl.bufferData(bufferType, array, usage);
		attribute.onUploadCallback();
		let type;
		if (array instanceof Float32Array) {
			type = gl.FLOAT;
		} else if (array instanceof Uint16Array) {
			if (attribute.isFloat16BufferAttribute) {
				if (isWebGL2) {
					type = gl.HALF_FLOAT;
				} else {
					throw new Error('THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.');
				}
			} else {
				type = gl.UNSIGNED_SHORT;
			}
		} else if (array instanceof Int16Array) {
			type = gl.SHORT;
		} else if (array instanceof Uint32Array) {
			type = gl.UNSIGNED_INT;
		} else if (array instanceof Int32Array) {
			type = gl.INT;
		} else if (array instanceof Int8Array) {
			type = gl.BYTE;
		} else if (array instanceof Uint8Array) {
			type = gl.UNSIGNED_BYTE;
		} else if (array instanceof Uint8ClampedArray) {
			type = gl.UNSIGNED_BYTE;
		} else {
			throw new Error('THREE.WebGLAttributes: Unsupported buffer data format: ' + array);
		}
		return {
			buffer: buffer,
			type: type,
			bytesPerElement: array.BYTES_PER_ELEMENT,
			version: attribute.version
		};
	}
	function updateBuffer(buffer, attribute, bufferType) {
		const array = attribute.array;
		const updateRange = attribute.updateRange;
		gl.bindBuffer(bufferType, buffer);
		if (updateRange.count === -1) {
			// Not using update ranges

			gl.bufferSubData(bufferType, 0, array);
		} else {
			if (isWebGL2) {
				gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
			} else {
				gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
			}
			updateRange.count = -1; // reset range
		}
	}

	//

	function get(attribute) {
		if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
		return buffers.get(attribute);
	}
	function remove(attribute) {
		if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
		const data = buffers.get(attribute);
		if (data) {
			gl.deleteBuffer(data.buffer);
			buffers.delete(attribute);
		}
	}
	function update(attribute, bufferType) {
		if (attribute.isGLBufferAttribute) {
			const cached = buffers.get(attribute);
			if (!cached || cached.version < attribute.version) {
				buffers.set(attribute, {
					buffer: attribute.buffer,
					type: attribute.type,
					bytesPerElement: attribute.elementSize,
					version: attribute.version
				});
			}
			return;
		}
		if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
		const data = buffers.get(attribute);
		if (data === undefined) {
			buffers.set(attribute, createBuffer(attribute, bufferType));
		} else if (data.version < attribute.version) {
			updateBuffer(data.buffer, attribute, bufferType);
			data.version = attribute.version;
		}
	}
	return {
		get: get,
		remove: remove,
		update: update
	};
}

class PlaneGeometry extends BufferGeometry {
	constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
		super();
		this.type = 'PlaneGeometry';
		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};
		const width_half = width / 2;
		const height_half = height / 2;
		const gridX = Math.floor(widthSegments);
		const gridY = Math.floor(heightSegments);
		const gridX1 = gridX + 1;
		const gridY1 = gridY + 1;
		const segment_width = width / gridX;
		const segment_height = height / gridY;

		//

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];
		for (let iy = 0; iy < gridY1; iy++) {
			const y = iy * segment_height - height_half;
			for (let ix = 0; ix < gridX1; ix++) {
				const x = ix * segment_width - width_half;
				vertices.push(x, -y, 0);
				normals.push(0, 0, 1);
				uvs.push(ix / gridX);
				uvs.push(1 - iy / gridY);
			}
		}
		for (let iy = 0; iy < gridY; iy++) {
			for (let ix = 0; ix < gridX; ix++) {
				const a = ix + gridX1 * iy;
				const b = ix + gridX1 * (iy + 1);
				const c = ix + 1 + gridX1 * (iy + 1);
				const d = ix + 1 + gridX1 * iy;
				indices.push(a, b, d);
				indices.push(b, c, d);
			}
		}
		this.setIndex(indices);
		this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
		this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
		this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
	}
	static fromJSON(data) {
		return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
	}
}

var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";

var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

var alphatest_fragment = "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif";

var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif";

var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif";

var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

var begin_vertex = "vec3 transformed = vec3( position );";

var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";

var bsdfs = "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n		float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n		float x2 = x * x;\n		float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n		return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif";

var iridescence_fragment = "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,	0.0556434,\n\t\t-1.5371385,	1.8760108, -0.2040259,\n\t\t-0.4985314,	0.0415560,	1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\t return vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat R21 = R12;\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif";

var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";

var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";

var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";

var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";

var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";

var color_fragment = "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";

var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";

var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";

var color_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";

var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}";

var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_v0 0.339\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_v1 0.276\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_v4 0.046\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_v5 0.016\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_v6 0.0038\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";

var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";

var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";

var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";

var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";

var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";

var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";

var encodings_pars_fragment = "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";

var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";

var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";

var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";

var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";

var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";

var fog_vertex = "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif";

var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif";

var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";

var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}";

var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";

var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

var lights_lambert_fragment = "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;";

var lights_lambert_pars_fragment = "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert\n#define Material_LightProbeLOD( material )\t(0)";

var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif";

var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif";

var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";

var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";

var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";

var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";

var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif";

var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(		0, 1,		0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n\t#else\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";

var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";

var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif";

var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";

var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";

var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";

var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";

var map_fragment = "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif";

var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";

var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";

var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";

var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

var morphcolor_vertex = "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif";

var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif";

var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif";

var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif";

var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";

var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";

var normal_pars_fragment = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";

var normal_pars_vertex = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";

var normal_vertex = "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif";

var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif";

var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";

var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif";

var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";

var iridescence_pars_fragment = "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif";

var output_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";

var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";

var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";

var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";

var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";

var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";

var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";

var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

var shadowmap_pars_fragment = "#if NUM_SPOT_LIGHT_COORDS > 0\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t	texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t	f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t	texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t	f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";

var shadowmap_pars_vertex = "#if NUM_SPOT_LIGHT_COORDS > 0\n	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";

var shadowmap_vertex = "#if defined( USE_SHADOWMAP ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_COORDS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";

var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";

var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif";

var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";

var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";

var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";

var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(	1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,	1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,	1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";

var transmission_fragment = "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );\n#endif";

var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif";

var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";

var uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";

var uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";

var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";

var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";

var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";

const vertex$h = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
const fragment$h = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tgl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n\t#endif\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

const vertex$g = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";
const fragment$g = "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

const vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";
const fragment$f = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

const vertex$e = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";
const fragment$e = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";

const vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";
const fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";

const vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";
const fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

const vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
const fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

const vertex$a = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";
const fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$9 = "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
const fragment$9 = "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";
const fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";
const fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}";

const vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
const fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}";
const fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
const fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";
const fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

const vertex$2 = "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
const fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

const vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
const fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

const ShaderChunk = {
	alphamap_fragment: alphamap_fragment,
	alphamap_pars_fragment: alphamap_pars_fragment,
	alphatest_fragment: alphatest_fragment,
	alphatest_pars_fragment: alphatest_pars_fragment,
	aomap_fragment: aomap_fragment,
	aomap_pars_fragment: aomap_pars_fragment,
	begin_vertex: begin_vertex,
	beginnormal_vertex: beginnormal_vertex,
	bsdfs: bsdfs,
	iridescence_fragment: iridescence_fragment,
	bumpmap_pars_fragment: bumpmap_pars_fragment,
	clipping_planes_fragment: clipping_planes_fragment,
	clipping_planes_pars_fragment: clipping_planes_pars_fragment,
	clipping_planes_pars_vertex: clipping_planes_pars_vertex,
	clipping_planes_vertex: clipping_planes_vertex,
	color_fragment: color_fragment,
	color_pars_fragment: color_pars_fragment,
	color_pars_vertex: color_pars_vertex,
	color_vertex: color_vertex,
	common: common,
	cube_uv_reflection_fragment: cube_uv_reflection_fragment,
	defaultnormal_vertex: defaultnormal_vertex,
	displacementmap_pars_vertex: displacementmap_pars_vertex,
	displacementmap_vertex: displacementmap_vertex,
	emissivemap_fragment: emissivemap_fragment,
	emissivemap_pars_fragment: emissivemap_pars_fragment,
	encodings_fragment: encodings_fragment,
	encodings_pars_fragment: encodings_pars_fragment,
	envmap_fragment: envmap_fragment,
	envmap_common_pars_fragment: envmap_common_pars_fragment,
	envmap_pars_fragment: envmap_pars_fragment,
	envmap_pars_vertex: envmap_pars_vertex,
	envmap_physical_pars_fragment: envmap_physical_pars_fragment,
	envmap_vertex: envmap_vertex,
	fog_vertex: fog_vertex,
	fog_pars_vertex: fog_pars_vertex,
	fog_fragment: fog_fragment,
	fog_pars_fragment: fog_pars_fragment,
	gradientmap_pars_fragment: gradientmap_pars_fragment,
	lightmap_fragment: lightmap_fragment,
	lightmap_pars_fragment: lightmap_pars_fragment,
	lights_lambert_fragment: lights_lambert_fragment,
	lights_lambert_pars_fragment: lights_lambert_pars_fragment,
	lights_pars_begin: lights_pars_begin,
	lights_toon_fragment: lights_toon_fragment,
	lights_toon_pars_fragment: lights_toon_pars_fragment,
	lights_phong_fragment: lights_phong_fragment,
	lights_phong_pars_fragment: lights_phong_pars_fragment,
	lights_physical_fragment: lights_physical_fragment,
	lights_physical_pars_fragment: lights_physical_pars_fragment,
	lights_fragment_begin: lights_fragment_begin,
	lights_fragment_maps: lights_fragment_maps,
	lights_fragment_end: lights_fragment_end,
	logdepthbuf_fragment: logdepthbuf_fragment,
	logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
	logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
	logdepthbuf_vertex: logdepthbuf_vertex,
	map_fragment: map_fragment,
	map_pars_fragment: map_pars_fragment,
	map_particle_fragment: map_particle_fragment,
	map_particle_pars_fragment: map_particle_pars_fragment,
	metalnessmap_fragment: metalnessmap_fragment,
	metalnessmap_pars_fragment: metalnessmap_pars_fragment,
	morphcolor_vertex: morphcolor_vertex,
	morphnormal_vertex: morphnormal_vertex,
	morphtarget_pars_vertex: morphtarget_pars_vertex,
	morphtarget_vertex: morphtarget_vertex,
	normal_fragment_begin: normal_fragment_begin,
	normal_fragment_maps: normal_fragment_maps,
	normal_pars_fragment: normal_pars_fragment,
	normal_pars_vertex: normal_pars_vertex,
	normal_vertex: normal_vertex,
	normalmap_pars_fragment: normalmap_pars_fragment,
	clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
	clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
	clearcoat_pars_fragment: clearcoat_pars_fragment,
	iridescence_pars_fragment: iridescence_pars_fragment,
	output_fragment: output_fragment,
	packing: packing,
	premultiplied_alpha_fragment: premultiplied_alpha_fragment,
	project_vertex: project_vertex,
	dithering_fragment: dithering_fragment,
	dithering_pars_fragment: dithering_pars_fragment,
	roughnessmap_fragment: roughnessmap_fragment,
	roughnessmap_pars_fragment: roughnessmap_pars_fragment,
	shadowmap_pars_fragment: shadowmap_pars_fragment,
	shadowmap_pars_vertex: shadowmap_pars_vertex,
	shadowmap_vertex: shadowmap_vertex,
	shadowmask_pars_fragment: shadowmask_pars_fragment,
	skinbase_vertex: skinbase_vertex,
	skinning_pars_vertex: skinning_pars_vertex,
	skinning_vertex: skinning_vertex,
	skinnormal_vertex: skinnormal_vertex,
	specularmap_fragment: specularmap_fragment,
	specularmap_pars_fragment: specularmap_pars_fragment,
	tonemapping_fragment: tonemapping_fragment,
	tonemapping_pars_fragment: tonemapping_pars_fragment,
	transmission_fragment: transmission_fragment,
	transmission_pars_fragment: transmission_pars_fragment,
	uv_pars_fragment: uv_pars_fragment,
	uv_pars_vertex: uv_pars_vertex,
	uv_vertex: uv_vertex,
	uv2_pars_fragment: uv2_pars_fragment,
	uv2_pars_vertex: uv2_pars_vertex,
	uv2_vertex: uv2_vertex,
	worldpos_vertex: worldpos_vertex,
	background_vert: vertex$h,
	background_frag: fragment$h,
	backgroundCube_vert: vertex$g,
	backgroundCube_frag: fragment$g,
	cube_vert: vertex$f,
	cube_frag: fragment$f,
	depth_vert: vertex$e,
	depth_frag: fragment$e,
	distanceRGBA_vert: vertex$d,
	distanceRGBA_frag: fragment$d,
	equirect_vert: vertex$c,
	equirect_frag: fragment$c,
	linedashed_vert: vertex$b,
	linedashed_frag: fragment$b,
	meshbasic_vert: vertex$a,
	meshbasic_frag: fragment$a,
	meshlambert_vert: vertex$9,
	meshlambert_frag: fragment$9,
	meshmatcap_vert: vertex$8,
	meshmatcap_frag: fragment$8,
	meshnormal_vert: vertex$7,
	meshnormal_frag: fragment$7,
	meshphong_vert: vertex$6,
	meshphong_frag: fragment$6,
	meshphysical_vert: vertex$5,
	meshphysical_frag: fragment$5,
	meshtoon_vert: vertex$4,
	meshtoon_frag: fragment$4,
	points_vert: vertex$3,
	points_frag: fragment$3,
	shadow_vert: vertex$2,
	shadow_frag: fragment$2,
	sprite_vert: vertex$1,
	sprite_frag: fragment$1
};

/**
 * Uniforms library for shared webgl shaders
 */

const UniformsLib = {
	common: {
		diffuse: {
			value: /*@__PURE__*/new Color(0xffffff)
		},
		opacity: {
			value: 1.0
		},
		map: {
			value: null
		},
		uvTransform: {
			value: /*@__PURE__*/new Matrix3()
		},
		uv2Transform: {
			value: /*@__PURE__*/new Matrix3()
		},
		alphaMap: {
			value: null
		},
		alphaTest: {
			value: 0
		}
	},
	specularmap: {
		specularMap: {
			value: null
		}
	},
	envmap: {
		envMap: {
			value: null
		},
		flipEnvMap: {
			value: -1
		},
		reflectivity: {
			value: 1.0
		},
		// basic, lambert, phong
		ior: {
			value: 1.5
		},
		// physical
		refractionRatio: {
			value: 0.98
		} // basic, lambert, phong
	},

	aomap: {
		aoMap: {
			value: null
		},
		aoMapIntensity: {
			value: 1
		}
	},
	lightmap: {
		lightMap: {
			value: null
		},
		lightMapIntensity: {
			value: 1
		}
	},
	emissivemap: {
		emissiveMap: {
			value: null
		}
	},
	bumpmap: {
		bumpMap: {
			value: null
		},
		bumpScale: {
			value: 1
		}
	},
	normalmap: {
		normalMap: {
			value: null
		},
		normalScale: {
			value: /*@__PURE__*/new Vector2(1, 1)
		}
	},
	displacementmap: {
		displacementMap: {
			value: null
		},
		displacementScale: {
			value: 1
		},
		displacementBias: {
			value: 0
		}
	},
	roughnessmap: {
		roughnessMap: {
			value: null
		}
	},
	metalnessmap: {
		metalnessMap: {
			value: null
		}
	},
	gradientmap: {
		gradientMap: {
			value: null
		}
	},
	fog: {
		fogDensity: {
			value: 0.00025
		},
		fogNear: {
			value: 1
		},
		fogFar: {
			value: 2000
		},
		fogColor: {
			value: /*@__PURE__*/new Color(0xffffff)
		}
	},
	lights: {
		ambientLightColor: {
			value: []
		},
		lightProbe: {
			value: []
		},
		directionalLights: {
			value: [],
			properties: {
				direction: {},
				color: {}
			}
		},
		directionalLightShadows: {
			value: [],
			properties: {
				shadowBias: {},
				shadowNormalBias: {},
				shadowRadius: {},
				shadowMapSize: {}
			}
		},
		directionalShadowMap: {
			value: []
		},
		directionalShadowMatrix: {
			value: []
		},
		spotLights: {
			value: [],
			properties: {
				color: {},
				position: {},
				direction: {},
				distance: {},
				coneCos: {},
				penumbraCos: {},
				decay: {}
			}
		},
		spotLightShadows: {
			value: [],
			properties: {
				shadowBias: {},
				shadowNormalBias: {},
				shadowRadius: {},
				shadowMapSize: {}
			}
		},
		spotLightMap: {
			value: []
		},
		spotShadowMap: {
			value: []
		},
		spotLightMatrix: {
			value: []
		},
		pointLights: {
			value: [],
			properties: {
				color: {},
				position: {},
				decay: {},
				distance: {}
			}
		},
		pointLightShadows: {
			value: [],
			properties: {
				shadowBias: {},
				shadowNormalBias: {},
				shadowRadius: {},
				shadowMapSize: {},
				shadowCameraNear: {},
				shadowCameraFar: {}
			}
		},
		pointShadowMap: {
			value: []
		},
		pointShadowMatrix: {
			value: []
		},
		hemisphereLights: {
			value: [],
			properties: {
				direction: {},
				skyColor: {},
				groundColor: {}
			}
		},
		// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
		rectAreaLights: {
			value: [],
			properties: {
				color: {},
				position: {},
				width: {},
				height: {}
			}
		},
		ltc_1: {
			value: null
		},
		ltc_2: {
			value: null
		}
	},
	points: {
		diffuse: {
			value: /*@__PURE__*/new Color(0xffffff)
		},
		opacity: {
			value: 1.0
		},
		size: {
			value: 1.0
		},
		scale: {
			value: 1.0
		},
		map: {
			value: null
		},
		alphaMap: {
			value: null
		},
		alphaTest: {
			value: 0
		},
		uvTransform: {
			value: /*@__PURE__*/new Matrix3()
		}
	},
	sprite: {
		diffuse: {
			value: /*@__PURE__*/new Color(0xffffff)
		},
		opacity: {
			value: 1.0
		},
		center: {
			value: /*@__PURE__*/new Vector2(0.5, 0.5)
		},
		rotation: {
			value: 0.0
		},
		map: {
			value: null
		},
		alphaMap: {
			value: null
		},
		alphaTest: {
			value: 0
		},
		uvTransform: {
			value: /*@__PURE__*/new Matrix3()
		}
	}
};

const ShaderLib = {
	basic: {
		uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]),
		vertexShader: ShaderChunk.meshbasic_vert,
		fragmentShader: ShaderChunk.meshbasic_frag
	},
	lambert: {
		uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {
			emissive: {
				value: /*@__PURE__*/new Color(0x000000)
			}
		}]),
		vertexShader: ShaderChunk.meshlambert_vert,
		fragmentShader: ShaderChunk.meshlambert_frag
	},
	phong: {
		uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {
			emissive: {
				value: /*@__PURE__*/new Color(0x000000)
			},
			specular: {
				value: /*@__PURE__*/new Color(0x111111)
			},
			shininess: {
				value: 30
			}
		}]),
		vertexShader: ShaderChunk.meshphong_vert,
		fragmentShader: ShaderChunk.meshphong_frag
	},
	standard: {
		uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, {
			emissive: {
				value: /*@__PURE__*/new Color(0x000000)
			},
			roughness: {
				value: 1.0
			},
			metalness: {
				value: 0.0
			},
			envMapIntensity: {
				value: 1
			} // temporary
		}]),

		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag
	},
	toon: {
		uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, {
			emissive: {
				value: /*@__PURE__*/new Color(0x000000)
			}
		}]),
		vertexShader: ShaderChunk.meshtoon_vert,
		fragmentShader: ShaderChunk.meshtoon_frag
	},
	matcap: {
		uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, {
			matcap: {
				value: null
			}
		}]),
		vertexShader: ShaderChunk.meshmatcap_vert,
		fragmentShader: ShaderChunk.meshmatcap_frag
	},
	points: {
		uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.points, UniformsLib.fog]),
		vertexShader: ShaderChunk.points_vert,
		fragmentShader: ShaderChunk.points_frag
	},
	dashed: {
		uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.common, UniformsLib.fog, {
			scale: {
				value: 1
			},
			dashSize: {
				value: 1
			},
			totalSize: {
				value: 2
			}
		}]),
		vertexShader: ShaderChunk.linedashed_vert,
		fragmentShader: ShaderChunk.linedashed_frag
	},
	depth: {
		uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]),
		vertexShader: ShaderChunk.depth_vert,
		fragmentShader: ShaderChunk.depth_frag
	},
	normal: {
		uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, {
			opacity: {
				value: 1.0
			}
		}]),
		vertexShader: ShaderChunk.meshnormal_vert,
		fragmentShader: ShaderChunk.meshnormal_frag
	},
	sprite: {
		uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),
		vertexShader: ShaderChunk.sprite_vert,
		fragmentShader: ShaderChunk.sprite_frag
	},
	background: {
		uniforms: {
			uvTransform: {
				value: /*@__PURE__*/new Matrix3()
			},
			t2D: {
				value: null
			}
		},
		vertexShader: ShaderChunk.background_vert,
		fragmentShader: ShaderChunk.background_frag
	},
	backgroundCube: {
		uniforms: {
			envMap: {
				value: null
			},
			flipEnvMap: {
				value: -1
			},
			backgroundBlurriness: {
				value: 0
			}
		},
		vertexShader: ShaderChunk.backgroundCube_vert,
		fragmentShader: ShaderChunk.backgroundCube_frag
	},
	cube: {
		uniforms: {
			tCube: {
				value: null
			},
			tFlip: {
				value: -1
			},
			opacity: {
				value: 1.0
			}
		},
		vertexShader: ShaderChunk.cube_vert,
		fragmentShader: ShaderChunk.cube_frag
	},
	equirect: {
		uniforms: {
			tEquirect: {
				value: null
			}
		},
		vertexShader: ShaderChunk.equirect_vert,
		fragmentShader: ShaderChunk.equirect_frag
	},
	distanceRGBA: {
		uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, {
			referencePosition: {
				value: /*@__PURE__*/new Vector3()
			},
			nearDistance: {
				value: 1
			},
			farDistance: {
				value: 1000
			}
		}]),
		vertexShader: ShaderChunk.distanceRGBA_vert,
		fragmentShader: ShaderChunk.distanceRGBA_frag
	},
	shadow: {
		uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.lights, UniformsLib.fog, {
			color: {
				value: /*@__PURE__*/new Color(0x00000)
			},
			opacity: {
				value: 1.0
			}
		}]),
		vertexShader: ShaderChunk.shadow_vert,
		fragmentShader: ShaderChunk.shadow_frag
	}
};
ShaderLib.physical = {
	uniforms: /*@__PURE__*/mergeUniforms([ShaderLib.standard.uniforms, {
		clearcoat: {
			value: 0
		},
		clearcoatMap: {
			value: null
		},
		clearcoatRoughness: {
			value: 0
		},
		clearcoatRoughnessMap: {
			value: null
		},
		clearcoatNormalScale: {
			value: /*@__PURE__*/new Vector2(1, 1)
		},
		clearcoatNormalMap: {
			value: null
		},
		iridescence: {
			value: 0
		},
		iridescenceMap: {
			value: null
		},
		iridescenceIOR: {
			value: 1.3
		},
		iridescenceThicknessMinimum: {
			value: 100
		},
		iridescenceThicknessMaximum: {
			value: 400
		},
		iridescenceThicknessMap: {
			value: null
		},
		sheen: {
			value: 0
		},
		sheenColor: {
			value: /*@__PURE__*/new Color(0x000000)
		},
		sheenColorMap: {
			value: null
		},
		sheenRoughness: {
			value: 1
		},
		sheenRoughnessMap: {
			value: null
		},
		transmission: {
			value: 0
		},
		transmissionMap: {
			value: null
		},
		transmissionSamplerSize: {
			value: /*@__PURE__*/new Vector2()
		},
		transmissionSamplerMap: {
			value: null
		},
		thickness: {
			value: 0
		},
		thicknessMap: {
			value: null
		},
		attenuationDistance: {
			value: 0
		},
		attenuationColor: {
			value: /*@__PURE__*/new Color(0x000000)
		},
		specularIntensity: {
			value: 1
		},
		specularIntensityMap: {
			value: null
		},
		specularColor: {
			value: /*@__PURE__*/new Color(1, 1, 1)
		},
		specularColorMap: {
			value: null
		}
	}]),
	vertexShader: ShaderChunk.meshphysical_vert,
	fragmentShader: ShaderChunk.meshphysical_frag
};

function WebGLBackground(renderer, cubemaps, cubeuvmaps, state, objects, alpha, premultipliedAlpha) {
	const clearColor = new Color(0x000000);
	let clearAlpha = alpha === true ? 0 : 1;
	let planeMesh;
	let boxMesh;
	let currentBackground = null;
	let currentBackgroundVersion = 0;
	let currentTonemapping = null;
	function render(renderList, scene) {
		let forceClear = false;
		let background = scene.isScene === true ? scene.background : null;
		if (background && background.isTexture) {
			const usePMREM = scene.backgroundBlurriness > 0; // use PMREM if the user wants to blur the background
			background = (usePMREM ? cubeuvmaps : cubemaps).get(background);
		}

		// Ignore background in AR
		// TODO: Reconsider this.

		const xr = renderer.xr;
		const session = xr.getSession && xr.getSession();
		if (session && session.environmentBlendMode === 'additive') {
			background = null;
		}
		if (background === null) {
			setClear(clearColor, clearAlpha);
		} else if (background && background.isColor) {
			setClear(background, 1);
			forceClear = true;
		}
		if (renderer.autoClear || forceClear) {
			renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
		}
		if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
			if (boxMesh === undefined) {
				boxMesh = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({
					name: 'BackgroundCubeMaterial',
					uniforms: cloneUniforms(ShaderLib.backgroundCube.uniforms),
					vertexShader: ShaderLib.backgroundCube.vertexShader,
					fragmentShader: ShaderLib.backgroundCube.fragmentShader,
					side: BackSide,
					depthTest: false,
					depthWrite: false,
					fog: false
				}));
				boxMesh.geometry.deleteAttribute('normal');
				boxMesh.geometry.deleteAttribute('uv');
				boxMesh.onBeforeRender = function (renderer, scene, camera) {
					this.matrixWorld.copyPosition(camera.matrixWorld);
				};

				// add "envMap" material property so the renderer can evaluate it like for built-in materials
				Object.defineProperty(boxMesh.material, 'envMap', {
					get: function () {
						return this.uniforms.envMap.value;
					}
				});
				objects.update(boxMesh);
			}
			boxMesh.material.uniforms.envMap.value = background;
			boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;
			boxMesh.material.uniforms.backgroundBlurriness.value = scene.backgroundBlurriness;
			if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
				boxMesh.material.needsUpdate = true;
				currentBackground = background;
				currentBackgroundVersion = background.version;
				currentTonemapping = renderer.toneMapping;
			}
			boxMesh.layers.enableAll();

			// push to the pre-sorted opaque render list
			renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
		} else if (background && background.isTexture) {
			if (planeMesh === undefined) {
				planeMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({
					name: 'BackgroundMaterial',
					uniforms: cloneUniforms(ShaderLib.background.uniforms),
					vertexShader: ShaderLib.background.vertexShader,
					fragmentShader: ShaderLib.background.fragmentShader,
					side: FrontSide,
					depthTest: false,
					depthWrite: false,
					fog: false
				}));
				planeMesh.geometry.deleteAttribute('normal');

				// add "map" material property so the renderer can evaluate it like for built-in materials
				Object.defineProperty(planeMesh.material, 'map', {
					get: function () {
						return this.uniforms.t2D.value;
					}
				});
				objects.update(planeMesh);
			}
			planeMesh.material.uniforms.t2D.value = background;
			if (background.matrixAutoUpdate === true) {
				background.updateMatrix();
			}
			planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
			if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
				planeMesh.material.needsUpdate = true;
				currentBackground = background;
				currentBackgroundVersion = background.version;
				currentTonemapping = renderer.toneMapping;
			}
			planeMesh.layers.enableAll();

			// push to the pre-sorted opaque render list
			renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
		}
	}
	function setClear(color, alpha) {
		state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
	}
	return {
		getClearColor: function () {
			return clearColor;
		},
		setClearColor: function (color, alpha = 1) {
			clearColor.set(color);
			clearAlpha = alpha;
			setClear(clearColor, clearAlpha);
		},
		getClearAlpha: function () {
			return clearAlpha;
		},
		setClearAlpha: function (alpha) {
			clearAlpha = alpha;
			setClear(clearColor, clearAlpha);
		},
		render: render
	};
}

function WebGLBindingStates(gl, extensions, attributes, capabilities) {
	const maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
	const extension = capabilities.isWebGL2 ? null : extensions.get('OES_vertex_array_object');
	const vaoAvailable = capabilities.isWebGL2 || extension !== null;
	const bindingStates = {};
	const defaultState = createBindingState(null);
	let currentState = defaultState;
	let forceUpdate = false;
	function setup(object, material, program, geometry, index) {
		let updateBuffers = false;
		if (vaoAvailable) {
			const state = getBindingState(geometry, program, material);
			if (currentState !== state) {
				currentState = state;
				bindVertexArrayObject(currentState.object);
			}
			updateBuffers = needsUpdate(object, geometry, program, index);
			if (updateBuffers) saveCache(object, geometry, program, index);
		} else {
			const wireframe = material.wireframe === true;
			if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
				currentState.geometry = geometry.id;
				currentState.program = program.id;
				currentState.wireframe = wireframe;
				updateBuffers = true;
			}
		}
		if (index !== null) {
			attributes.update(index, gl.ELEMENT_ARRAY_BUFFER);
		}
		if (updateBuffers || forceUpdate) {
			forceUpdate = false;
			setupVertexAttributes(object, material, program, geometry);
			if (index !== null) {
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, attributes.get(index).buffer);
			}
		}
	}
	function createVertexArrayObject() {
		if (capabilities.isWebGL2) return gl.createVertexArray();
		return extension.createVertexArrayOES();
	}
	function bindVertexArrayObject(vao) {
		if (capabilities.isWebGL2) return gl.bindVertexArray(vao);
		return extension.bindVertexArrayOES(vao);
	}
	function deleteVertexArrayObject(vao) {
		if (capabilities.isWebGL2) return gl.deleteVertexArray(vao);
		return extension.deleteVertexArrayOES(vao);
	}
	function getBindingState(geometry, program, material) {
		const wireframe = material.wireframe === true;
		let programMap = bindingStates[geometry.id];
		if (programMap === undefined) {
			programMap = {};
			bindingStates[geometry.id] = programMap;
		}
		let stateMap = programMap[program.id];
		if (stateMap === undefined) {
			stateMap = {};
			programMap[program.id] = stateMap;
		}
		let state = stateMap[wireframe];
		if (state === undefined) {
			state = createBindingState(createVertexArrayObject());
			stateMap[wireframe] = state;
		}
		return state;
	}
	function createBindingState(vao) {
		const newAttributes = [];
		const enabledAttributes = [];
		const attributeDivisors = [];
		for (let i = 0; i < maxVertexAttributes; i++) {
			newAttributes[i] = 0;
			enabledAttributes[i] = 0;
			attributeDivisors[i] = 0;
		}
		return {
			// for backward compatibility on non-VAO support browser
			geometry: null,
			program: null,
			wireframe: false,
			newAttributes: newAttributes,
			enabledAttributes: enabledAttributes,
			attributeDivisors: attributeDivisors,
			object: vao,
			attributes: {},
			index: null
		};
	}
	function needsUpdate(object, geometry, program, index) {
		const cachedAttributes = currentState.attributes;
		const geometryAttributes = geometry.attributes;
		let attributesNum = 0;
		const programAttributes = program.getAttributes();
		for (const name in programAttributes) {
			const programAttribute = programAttributes[name];
			if (programAttribute.location >= 0) {
				const cachedAttribute = cachedAttributes[name];
				let geometryAttribute = geometryAttributes[name];
				if (geometryAttribute === undefined) {
					if (name === 'instanceMatrix' && object.instanceMatrix) geometryAttribute = object.instanceMatrix;
					if (name === 'instanceColor' && object.instanceColor) geometryAttribute = object.instanceColor;
				}
				if (cachedAttribute === undefined) return true;
				if (cachedAttribute.attribute !== geometryAttribute) return true;
				if (geometryAttribute && cachedAttribute.data !== geometryAttribute.data) return true;
				attributesNum++;
			}
		}
		if (currentState.attributesNum !== attributesNum) return true;
		if (currentState.index !== index) return true;
		return false;
	}
	function saveCache(object, geometry, program, index) {
		const cache = {};
		const attributes = geometry.attributes;
		let attributesNum = 0;
		const programAttributes = program.getAttributes();
		for (const name in programAttributes) {
			const programAttribute = programAttributes[name];
			if (programAttribute.location >= 0) {
				let attribute = attributes[name];
				if (attribute === undefined) {
					if (name === 'instanceMatrix' && object.instanceMatrix) attribute = object.instanceMatrix;
					if (name === 'instanceColor' && object.instanceColor) attribute = object.instanceColor;
				}
				const data = {};
				data.attribute = attribute;
				if (attribute && attribute.data) {
					data.data = attribute.data;
				}
				cache[name] = data;
				attributesNum++;
			}
		}
		currentState.attributes = cache;
		currentState.attributesNum = attributesNum;
		currentState.index = index;
	}
	function initAttributes() {
		const newAttributes = currentState.newAttributes;
		for (let i = 0, il = newAttributes.length; i < il; i++) {
			newAttributes[i] = 0;
		}
	}
	function enableAttribute(attribute) {
		enableAttributeAndDivisor(attribute, 0);
	}
	function enableAttributeAndDivisor(attribute, meshPerAttribute) {
		const newAttributes = currentState.newAttributes;
		const enabledAttributes = currentState.enabledAttributes;
		const attributeDivisors = currentState.attributeDivisors;
		newAttributes[attribute] = 1;
		if (enabledAttributes[attribute] === 0) {
			gl.enableVertexAttribArray(attribute);
			enabledAttributes[attribute] = 1;
		}
		if (attributeDivisors[attribute] !== meshPerAttribute) {
			const extension = capabilities.isWebGL2 ? gl : extensions.get('ANGLE_instanced_arrays');
			extension[capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'](attribute, meshPerAttribute);
			attributeDivisors[attribute] = meshPerAttribute;
		}
	}
	function disableUnusedAttributes() {
		const newAttributes = currentState.newAttributes;
		const enabledAttributes = currentState.enabledAttributes;
		for (let i = 0, il = enabledAttributes.length; i < il; i++) {
			if (enabledAttributes[i] !== newAttributes[i]) {
				gl.disableVertexAttribArray(i);
				enabledAttributes[i] = 0;
			}
		}
	}
	function vertexAttribPointer(index, size, type, normalized, stride, offset) {
		if (capabilities.isWebGL2 === true && (type === gl.INT || type === gl.UNSIGNED_INT)) {
			gl.vertexAttribIPointer(index, size, type, stride, offset);
		} else {
			gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
		}
	}
	function setupVertexAttributes(object, material, program, geometry) {
		if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
			if (extensions.get('ANGLE_instanced_arrays') === null) return;
		}
		initAttributes();
		const geometryAttributes = geometry.attributes;
		const programAttributes = program.getAttributes();
		const materialDefaultAttributeValues = material.defaultAttributeValues;
		for (const name in programAttributes) {
			const programAttribute = programAttributes[name];
			if (programAttribute.location >= 0) {
				let geometryAttribute = geometryAttributes[name];
				if (geometryAttribute === undefined) {
					if (name === 'instanceMatrix' && object.instanceMatrix) geometryAttribute = object.instanceMatrix;
					if (name === 'instanceColor' && object.instanceColor) geometryAttribute = object.instanceColor;
				}
				if (geometryAttribute !== undefined) {
					const normalized = geometryAttribute.normalized;
					const size = geometryAttribute.itemSize;
					const attribute = attributes.get(geometryAttribute);

					// TODO Attribute may not be available on context restore

					if (attribute === undefined) continue;
					const buffer = attribute.buffer;
					const type = attribute.type;
					const bytesPerElement = attribute.bytesPerElement;
					if (geometryAttribute.isInterleavedBufferAttribute) {
						const data = geometryAttribute.data;
						const stride = data.stride;
						const offset = geometryAttribute.offset;
						if (data.isInstancedInterleavedBuffer) {
							for (let i = 0; i < programAttribute.locationSize; i++) {
								enableAttributeAndDivisor(programAttribute.location + i, data.meshPerAttribute);
							}
							if (object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined) {
								geometry._maxInstanceCount = data.meshPerAttribute * data.count;
							}
						} else {
							for (let i = 0; i < programAttribute.locationSize; i++) {
								enableAttribute(programAttribute.location + i);
							}
						}
						gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
						for (let i = 0; i < programAttribute.locationSize; i++) {
							vertexAttribPointer(programAttribute.location + i, size / programAttribute.locationSize, type, normalized, stride * bytesPerElement, (offset + size / programAttribute.locationSize * i) * bytesPerElement);
						}
					} else {
						if (geometryAttribute.isInstancedBufferAttribute) {
							for (let i = 0; i < programAttribute.locationSize; i++) {
								enableAttributeAndDivisor(programAttribute.location + i, geometryAttribute.meshPerAttribute);
							}
							if (object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined) {
								geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
							}
						} else {
							for (let i = 0; i < programAttribute.locationSize; i++) {
								enableAttribute(programAttribute.location + i);
							}
						}
						gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
						for (let i = 0; i < programAttribute.locationSize; i++) {
							vertexAttribPointer(programAttribute.location + i, size / programAttribute.locationSize, type, normalized, size * bytesPerElement, size / programAttribute.locationSize * i * bytesPerElement);
						}
					}
				} else if (materialDefaultAttributeValues !== undefined) {
					const value = materialDefaultAttributeValues[name];
					if (value !== undefined) {
						switch (value.length) {
							case 2:
								gl.vertexAttrib2fv(programAttribute.location, value);
								break;
							case 3:
								gl.vertexAttrib3fv(programAttribute.location, value);
								break;
							case 4:
								gl.vertexAttrib4fv(programAttribute.location, value);
								break;
							default:
								gl.vertexAttrib1fv(programAttribute.location, value);
						}
					}
				}
			}
		}
		disableUnusedAttributes();
	}
	function dispose() {
		reset();
		for (const geometryId in bindingStates) {
			const programMap = bindingStates[geometryId];
			for (const programId in programMap) {
				const stateMap = programMap[programId];
				for (const wireframe in stateMap) {
					deleteVertexArrayObject(stateMap[wireframe].object);
					delete stateMap[wireframe];
				}
				delete programMap[programId];
			}
			delete bindingStates[geometryId];
		}
	}
	function releaseStatesOfGeometry(geometry) {
		if (bindingStates[geometry.id] === undefined) return;
		const programMap = bindingStates[geometry.id];
		for (const programId in programMap) {
			const stateMap = programMap[programId];
			for (const wireframe in stateMap) {
				deleteVertexArrayObject(stateMap[wireframe].object);
				delete stateMap[wireframe];
			}
			delete programMap[programId];
		}
		delete bindingStates[geometry.id];
	}
	function releaseStatesOfProgram(program) {
		for (const geometryId in bindingStates) {
			const programMap = bindingStates[geometryId];
			if (programMap[program.id] === undefined) continue;
			const stateMap = programMap[program.id];
			for (const wireframe in stateMap) {
				deleteVertexArrayObject(stateMap[wireframe].object);
				delete stateMap[wireframe];
			}
			delete programMap[program.id];
		}
	}
	function reset() {
		resetDefaultState();
		forceUpdate = true;
		if (currentState === defaultState) return;
		currentState = defaultState;
		bindVertexArrayObject(currentState.object);
	}

	// for backward-compatibility

	function resetDefaultState() {
		defaultState.geometry = null;
		defaultState.program = null;
		defaultState.wireframe = false;
	}
	return {
		setup: setup,
		reset: reset,
		resetDefaultState: resetDefaultState,
		dispose: dispose,
		releaseStatesOfGeometry: releaseStatesOfGeometry,
		releaseStatesOfProgram: releaseStatesOfProgram,
		initAttributes: initAttributes,
		enableAttribute: enableAttribute,
		disableUnusedAttributes: disableUnusedAttributes
	};
}

function WebGLBufferRenderer(gl, extensions, info, capabilities) {
	const isWebGL2 = capabilities.isWebGL2;
	let mode;
	function setMode(value) {
		mode = value;
	}
	function render(start, count) {
		gl.drawArrays(mode, start, count);
		info.update(count, mode, 1);
	}
	function renderInstances(start, count, primcount) {
		if (primcount === 0) return;
		let extension, methodName;
		if (isWebGL2) {
			extension = gl;
			methodName = 'drawArraysInstanced';
		} else {
			extension = extensions.get('ANGLE_instanced_arrays');
			methodName = 'drawArraysInstancedANGLE';
			if (extension === null) {
				console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
				return;
			}
		}
		extension[methodName](mode, start, count, primcount);
		info.update(count, mode, primcount);
	}

	//

	this.setMode = setMode;
	this.render = render;
	this.renderInstances = renderInstances;
}

function WebGLCapabilities(gl, extensions, parameters) {
	let maxAnisotropy;
	function getMaxAnisotropy() {
		if (maxAnisotropy !== undefined) return maxAnisotropy;
		if (extensions.has('EXT_texture_filter_anisotropic') === true) {
			const extension = extensions.get('EXT_texture_filter_anisotropic');
			maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
		} else {
			maxAnisotropy = 0;
		}
		return maxAnisotropy;
	}
	function getMaxPrecision(precision) {
		if (precision === 'highp') {
			if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
				return 'highp';
			}
			precision = 'mediump';
		}
		if (precision === 'mediump') {
			if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
				return 'mediump';
			}
		}
		return 'lowp';
	}
	const isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext;
	let precision = parameters.precision !== undefined ? parameters.precision : 'highp';
	const maxPrecision = getMaxPrecision(precision);
	if (maxPrecision !== precision) {
		console.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.');
		precision = maxPrecision;
	}
	const drawBuffers = isWebGL2 || extensions.has('WEBGL_draw_buffers');
	const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
	const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
	const maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
	const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
	const maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
	const maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
	const maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
	const maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
	const maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
	const vertexTextures = maxVertexTextures > 0;
	const floatFragmentTextures = isWebGL2 || extensions.has('OES_texture_float');
	const floatVertexTextures = vertexTextures && floatFragmentTextures;
	const maxSamples = isWebGL2 ? gl.getParameter(gl.MAX_SAMPLES) : 0;
	return {
		isWebGL2: isWebGL2,
		drawBuffers: drawBuffers,
		getMaxAnisotropy: getMaxAnisotropy,
		getMaxPrecision: getMaxPrecision,
		precision: precision,
		logarithmicDepthBuffer: logarithmicDepthBuffer,
		maxTextures: maxTextures,
		maxVertexTextures: maxVertexTextures,
		maxTextureSize: maxTextureSize,
		maxCubemapSize: maxCubemapSize,
		maxAttributes: maxAttributes,
		maxVertexUniforms: maxVertexUniforms,
		maxVaryings: maxVaryings,
		maxFragmentUniforms: maxFragmentUniforms,
		vertexTextures: vertexTextures,
		floatFragmentTextures: floatFragmentTextures,
		floatVertexTextures: floatVertexTextures,
		maxSamples: maxSamples
	};
}

function WebGLClipping(properties) {
	const scope = this;
	let globalState = null,
		numGlobalPlanes = 0,
		localClippingEnabled = false,
		renderingShadows = false;
	const plane = new Plane(),
		viewNormalMatrix = new Matrix3(),
		uniform = {
			value: null,
			needsUpdate: false
		};
	this.uniform = uniform;
	this.numPlanes = 0;
	this.numIntersection = 0;
	this.init = function (planes, enableLocalClipping, camera) {
		const enabled = planes.length !== 0 || enableLocalClipping ||
		// enable state of previous frame - the clipping code has to
		// run another frame in order to reset the state:
		numGlobalPlanes !== 0 || localClippingEnabled;
		localClippingEnabled = enableLocalClipping;
		globalState = projectPlanes(planes, camera, 0);
		numGlobalPlanes = planes.length;
		return enabled;
	};
	this.beginShadows = function () {
		renderingShadows = true;
		projectPlanes(null);
	};
	this.endShadows = function () {
		renderingShadows = false;
		resetGlobalState();
	};
	this.setState = function (material, camera, useCache) {
		const planes = material.clippingPlanes,
			clipIntersection = material.clipIntersection,
			clipShadows = material.clipShadows;
		const materialProperties = properties.get(material);
		if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
			// there's no local clipping

			if (renderingShadows) {
				// there's no global clipping

				projectPlanes(null);
			} else {
				resetGlobalState();
			}
		} else {
			const nGlobal = renderingShadows ? 0 : numGlobalPlanes,
				lGlobal = nGlobal * 4;
			let dstArray = materialProperties.clippingState || null;
			uniform.value = dstArray; // ensure unique state

			dstArray = projectPlanes(planes, camera, lGlobal, useCache);
			for (let i = 0; i !== lGlobal; ++i) {
				dstArray[i] = globalState[i];
			}
			materialProperties.clippingState = dstArray;
			this.numIntersection = clipIntersection ? this.numPlanes : 0;
			this.numPlanes += nGlobal;
		}
	};
	function resetGlobalState() {
		if (uniform.value !== globalState) {
			uniform.value = globalState;
			uniform.needsUpdate = numGlobalPlanes > 0;
		}
		scope.numPlanes = numGlobalPlanes;
		scope.numIntersection = 0;
	}
	function projectPlanes(planes, camera, dstOffset, skipTransform) {
		const nPlanes = planes !== null ? planes.length : 0;
		let dstArray = null;
		if (nPlanes !== 0) {
			dstArray = uniform.value;
			if (skipTransform !== true || dstArray === null) {
				const flatSize = dstOffset + nPlanes * 4,
					viewMatrix = camera.matrixWorldInverse;
				viewNormalMatrix.getNormalMatrix(viewMatrix);
				if (dstArray === null || dstArray.length < flatSize) {
					dstArray = new Float32Array(flatSize);
				}
				for (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
					plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
					plane.normal.toArray(dstArray, i4);
					dstArray[i4 + 3] = plane.constant;
				}
			}
			uniform.value = dstArray;
			uniform.needsUpdate = true;
		}
		scope.numPlanes = nPlanes;
		scope.numIntersection = 0;
		return dstArray;
	}
}

function WebGLCubeMaps(renderer) {
	let cubemaps = new WeakMap();
	function mapTextureMapping(texture, mapping) {
		if (mapping === EquirectangularReflectionMapping) {
			texture.mapping = CubeReflectionMapping;
		} else if (mapping === EquirectangularRefractionMapping) {
			texture.mapping = CubeRefractionMapping;
		}
		return texture;
	}
	function get(texture) {
		if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
			const mapping = texture.mapping;
			if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
				if (cubemaps.has(texture)) {
					const cubemap = cubemaps.get(texture).texture;
					return mapTextureMapping(cubemap, texture.mapping);
				} else {
					const image = texture.image;
					if (image && image.height > 0) {
						const renderTarget = new WebGLCubeRenderTarget(image.height / 2);
						renderTarget.fromEquirectangularTexture(renderer, texture);
						cubemaps.set(texture, renderTarget);
						texture.addEventListener('dispose', onTextureDispose);
						return mapTextureMapping(renderTarget.texture, texture.mapping);
					} else {
						// image not yet ready. try the conversion next frame

						return null;
					}
				}
			}
		}
		return texture;
	}
	function onTextureDispose(event) {
		const texture = event.target;
		texture.removeEventListener('dispose', onTextureDispose);
		const cubemap = cubemaps.get(texture);
		if (cubemap !== undefined) {
			cubemaps.delete(texture);
			cubemap.dispose();
		}
	}
	function dispose() {
		cubemaps = new WeakMap();
	}
	return {
		get: get,
		dispose: dispose
	};
}

class OrthographicCamera extends Camera {
	constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2000) {
		super();
		this.isOrthographicCamera = true;
		this.type = 'OrthographicCamera';
		this.zoom = 1;
		this.view = null;
		this.left = left;
		this.right = right;
		this.top = top;
		this.bottom = bottom;
		this.near = near;
		this.far = far;
		this.updateProjectionMatrix();
	}
	copy(source, recursive) {
		super.copy(source, recursive);
		this.left = source.left;
		this.right = source.right;
		this.top = source.top;
		this.bottom = source.bottom;
		this.near = source.near;
		this.far = source.far;
		this.zoom = source.zoom;
		this.view = source.view === null ? null : Object.assign({}, source.view);
		return this;
	}
	setViewOffset(fullWidth, fullHeight, x, y, width, height) {
		if (this.view === null) {
			this.view = {
				enabled: true,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			};
		}
		this.view.enabled = true;
		this.view.fullWidth = fullWidth;
		this.view.fullHeight = fullHeight;
		this.view.offsetX = x;
		this.view.offsetY = y;
		this.view.width = width;
		this.view.height = height;
		this.updateProjectionMatrix();
	}
	clearViewOffset() {
		if (this.view !== null) {
			this.view.enabled = false;
		}
		this.updateProjectionMatrix();
	}
	updateProjectionMatrix() {
		const dx = (this.right - this.left) / (2 * this.zoom);
		const dy = (this.top - this.bottom) / (2 * this.zoom);
		const cx = (this.right + this.left) / 2;
		const cy = (this.top + this.bottom) / 2;
		let left = cx - dx;
		let right = cx + dx;
		let top = cy + dy;
		let bottom = cy - dy;
		if (this.view !== null && this.view.enabled) {
			const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
			const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
			left += scaleW * this.view.offsetX;
			right = left + scaleW * this.view.width;
			top -= scaleH * this.view.offsetY;
			bottom = top - scaleH * this.view.height;
		}
		this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
		this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
	}
	toJSON(meta) {
		const data = super.toJSON(meta);
		data.object.zoom = this.zoom;
		data.object.left = this.left;
		data.object.right = this.right;
		data.object.top = this.top;
		data.object.bottom = this.bottom;
		data.object.near = this.near;
		data.object.far = this.far;
		if (this.view !== null) data.object.view = Object.assign({}, this.view);
		return data;
	}
}

const LOD_MIN = 4;

// The standard deviations (radians) associated with the extra mips. These are
// chosen to approximate a Trowbridge-Reitz distribution function times the
// geometric shadowing function. These sigma values squared must match the
// variance #defines in cube_uv_reflection_fragment.glsl.js.
const EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];

// The maximum length of the blur for loop. Smaller sigmas will use fewer
// samples and exit early, but not recompile the shader.
const MAX_SAMPLES = 20;
const _flatCamera = /*@__PURE__*/new OrthographicCamera();
const _clearColor = /*@__PURE__*/new Color();
let _oldTarget = null;

// Golden Ratio
const PHI = (1 + Math.sqrt(5)) / 2;
const INV_PHI = 1 / PHI;

// Vertices of a dodecahedron (except the opposites, which represent the
// same axis), used as axis directions evenly spread on a sphere.
const _axisDirections = [/*@__PURE__*/new Vector3(1, 1, 1), /*@__PURE__*/new Vector3(-1, 1, 1), /*@__PURE__*/new Vector3(1, 1, -1), /*@__PURE__*/new Vector3(-1, 1, -1), /*@__PURE__*/new Vector3(0, PHI, INV_PHI), /*@__PURE__*/new Vector3(0, PHI, -INV_PHI), /*@__PURE__*/new Vector3(INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(-INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(PHI, INV_PHI, 0), /*@__PURE__*/new Vector3(-PHI, INV_PHI, 0)];

/**
 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
 * (PMREM) from a cubeMap environment texture. This allows different levels of
 * blur to be quickly accessed based on material roughness. It is packed into a
 * special CubeUV format that allows us to perform custom interpolation so that
 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
 * higher roughness levels. In this way we maintain resolution to smoothly
 * interpolate diffuse lighting while limiting sampling computation.
 *
 * Paper: Fast, Accurate Image-Based Lighting
 * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
*/

class PMREMGenerator {
	constructor(renderer) {
		this._renderer = renderer;
		this._pingPongRenderTarget = null;
		this._lodMax = 0;
		this._cubeSize = 0;
		this._lodPlanes = [];
		this._sizeLods = [];
		this._sigmas = [];
		this._blurMaterial = null;
		this._cubemapMaterial = null;
		this._equirectMaterial = null;
		this._compileMaterial(this._blurMaterial);
	}

	/**
	 * Generates a PMREM from a supplied Scene, which can be faster than using an
	 * image if networking bandwidth is low. Optional sigma specifies a blur radius
	 * in radians to be applied to the scene before PMREM generation. Optional near
	 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
	 * is placed at the origin).
	 */
	fromScene(scene, sigma = 0, near = 0.1, far = 100) {
		_oldTarget = this._renderer.getRenderTarget();
		this._setSize(256);
		const cubeUVRenderTarget = this._allocateTargets();
		cubeUVRenderTarget.depthBuffer = true;
		this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
		if (sigma > 0) {
			this._blur(cubeUVRenderTarget, 0, 0, sigma);
		}
		this._applyPMREM(cubeUVRenderTarget);
		this._cleanup(cubeUVRenderTarget);
		return cubeUVRenderTarget;
	}

	/**
	 * Generates a PMREM from an equirectangular texture, which can be either LDR
	 * or HDR. The ideal input image size is 1k (1024 x 512),
	 * as this matches best with the 256 x 256 cubemap output.
	 */
	fromEquirectangular(equirectangular, renderTarget = null) {
		return this._fromTexture(equirectangular, renderTarget);
	}

	/**
	 * Generates a PMREM from an cubemap texture, which can be either LDR
	 * or HDR. The ideal input cube size is 256 x 256,
	 * as this matches best with the 256 x 256 cubemap output.
	 */
	fromCubemap(cubemap, renderTarget = null) {
		return this._fromTexture(cubemap, renderTarget);
	}

	/**
	 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */
	compileCubemapShader() {
		if (this._cubemapMaterial === null) {
			this._cubemapMaterial = _getCubemapMaterial();
			this._compileMaterial(this._cubemapMaterial);
		}
	}

	/**
	 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */
	compileEquirectangularShader() {
		if (this._equirectMaterial === null) {
			this._equirectMaterial = _getEquirectMaterial();
			this._compileMaterial(this._equirectMaterial);
		}
	}

	/**
	 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
	 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
	 * one of them will cause any others to also become unusable.
	 */
	dispose() {
		this._dispose();
		if (this._cubemapMaterial !== null) this._cubemapMaterial.dispose();
		if (this._equirectMaterial !== null) this._equirectMaterial.dispose();
	}

	// private interface

	_setSize(cubeSize) {
		this._lodMax = Math.floor(Math.log2(cubeSize));
		this._cubeSize = Math.pow(2, this._lodMax);
	}
	_dispose() {
		if (this._blurMaterial !== null) this._blurMaterial.dispose();
		if (this._pingPongRenderTarget !== null) this._pingPongRenderTarget.dispose();
		for (let i = 0; i < this._lodPlanes.length; i++) {
			this._lodPlanes[i].dispose();
		}
	}
	_cleanup(outputTarget) {
		this._renderer.setRenderTarget(_oldTarget);
		outputTarget.scissorTest = false;
		_setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
	}
	_fromTexture(texture, renderTarget) {
		if (texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping) {
			this._setSize(texture.image.length === 0 ? 16 : texture.image[0].width || texture.image[0].image.width);
		} else {
			// Equirectangular

			this._setSize(texture.image.width / 4);
		}
		_oldTarget = this._renderer.getRenderTarget();
		const cubeUVRenderTarget = renderTarget || this._allocateTargets();
		this._textureToCubeUV(texture, cubeUVRenderTarget);
		this._applyPMREM(cubeUVRenderTarget);
		this._cleanup(cubeUVRenderTarget);
		return cubeUVRenderTarget;
	}
	_allocateTargets() {
		const width = 3 * Math.max(this._cubeSize, 16 * 7);
		const height = 4 * this._cubeSize;
		const params = {
			magFilter: LinearFilter,
			minFilter: LinearFilter,
			generateMipmaps: false,
			type: HalfFloatType,
			format: RGBAFormat,
			encoding: LinearEncoding,
			depthBuffer: false
		};
		const cubeUVRenderTarget = _createRenderTarget(width, height, params);
		if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width) {
			if (this._pingPongRenderTarget !== null) {
				this._dispose();
			}
			this._pingPongRenderTarget = _createRenderTarget(width, height, params);
			const {
				_lodMax
			} = this;
			({
				sizeLods: this._sizeLods,
				lodPlanes: this._lodPlanes,
				sigmas: this._sigmas
			} = _createPlanes(_lodMax));
			this._blurMaterial = _getBlurShader(_lodMax, width, height);
		}
		return cubeUVRenderTarget;
	}
	_compileMaterial(material) {
		const tmpMesh = new Mesh(this._lodPlanes[0], material);
		this._renderer.compile(tmpMesh, _flatCamera);
	}
	_sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
		const fov = 90;
		const aspect = 1;
		const cubeCamera = new PerspectiveCamera(fov, aspect, near, far);
		const upSign = [1, -1, 1, 1, 1, 1];
		const forwardSign = [1, 1, 1, -1, -1, -1];
		const renderer = this._renderer;
		const originalAutoClear = renderer.autoClear;
		const toneMapping = renderer.toneMapping;
		renderer.getClearColor(_clearColor);
		renderer.toneMapping = NoToneMapping;
		renderer.autoClear = false;
		const backgroundMaterial = new MeshBasicMaterial({
			name: 'PMREM.Background',
			side: BackSide,
			depthWrite: false,
			depthTest: false
		});
		const backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
		let useSolidColor = false;
		const background = scene.background;
		if (background) {
			if (background.isColor) {
				backgroundMaterial.color.copy(background);
				scene.background = null;
				useSolidColor = true;
			}
		} else {
			backgroundMaterial.color.copy(_clearColor);
			useSolidColor = true;
		}
		for (let i = 0; i < 6; i++) {
			const col = i % 3;
			if (col === 0) {
				cubeCamera.up.set(0, upSign[i], 0);
				cubeCamera.lookAt(forwardSign[i], 0, 0);
			} else if (col === 1) {
				cubeCamera.up.set(0, 0, upSign[i]);
				cubeCamera.lookAt(0, forwardSign[i], 0);
			} else {
				cubeCamera.up.set(0, upSign[i], 0);
				cubeCamera.lookAt(0, 0, forwardSign[i]);
			}
			const size = this._cubeSize;
			_setViewport(cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size);
			renderer.setRenderTarget(cubeUVRenderTarget);
			if (useSolidColor) {
				renderer.render(backgroundBox, cubeCamera);
			}
			renderer.render(scene, cubeCamera);
		}
		backgroundBox.geometry.dispose();
		backgroundBox.material.dispose();
		renderer.toneMapping = toneMapping;
		renderer.autoClear = originalAutoClear;
		scene.background = background;
	}
	_textureToCubeUV(texture, cubeUVRenderTarget) {
		const renderer = this._renderer;
		const isCubeTexture = texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping;
		if (isCubeTexture) {
			if (this._cubemapMaterial === null) {
				this._cubemapMaterial = _getCubemapMaterial();
			}
			this._cubemapMaterial.uniforms.flipEnvMap.value = texture.isRenderTargetTexture === false ? -1 : 1;
		} else {
			if (this._equirectMaterial === null) {
				this._equirectMaterial = _getEquirectMaterial();
			}
		}
		const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
		const mesh = new Mesh(this._lodPlanes[0], material);
		const uniforms = material.uniforms;
		uniforms['envMap'].value = texture;
		const size = this._cubeSize;
		_setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);
		renderer.setRenderTarget(cubeUVRenderTarget);
		renderer.render(mesh, _flatCamera);
	}
	_applyPMREM(cubeUVRenderTarget) {
		const renderer = this._renderer;
		const autoClear = renderer.autoClear;
		renderer.autoClear = false;
		for (let i = 1; i < this._lodPlanes.length; i++) {
			const sigma = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]);
			const poleAxis = _axisDirections[(i - 1) % _axisDirections.length];
			this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);
		}
		renderer.autoClear = autoClear;
	}

	/**
	 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
	 * vertically and horizontally, but this breaks down on a cube. Here we apply
	 * the blur latitudinally (around the poles), and then longitudinally (towards
	 * the poles) to approximate the orthogonally-separable blur. It is least
	 * accurate at the poles, but still does a decent job.
	 */
	_blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
		const pingPongRenderTarget = this._pingPongRenderTarget;
		this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, 'latitudinal', poleAxis);
		this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, 'longitudinal', poleAxis);
	}
	_halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
		const renderer = this._renderer;
		const blurMaterial = this._blurMaterial;
		if (direction !== 'latitudinal' && direction !== 'longitudinal') {
			console.error('blur direction must be either latitudinal or longitudinal!');
		}

		// Number of standard deviations at which to cut off the discrete approximation.
		const STANDARD_DEVIATIONS = 3;
		const blurMesh = new Mesh(this._lodPlanes[lodOut], blurMaterial);
		const blurUniforms = blurMaterial.uniforms;
		const pixels = this._sizeLods[lodIn] - 1;
		const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
		const sigmaPixels = sigmaRadians / radiansPerPixel;
		const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
		if (samples > MAX_SAMPLES) {
			console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
		}
		const weights = [];
		let sum = 0;
		for (let i = 0; i < MAX_SAMPLES; ++i) {
			const x = i / sigmaPixels;
			const weight = Math.exp(-x * x / 2);
			weights.push(weight);
			if (i === 0) {
				sum += weight;
			} else if (i < samples) {
				sum += 2 * weight;
			}
		}
		for (let i = 0; i < weights.length; i++) {
			weights[i] = weights[i] / sum;
		}
		blurUniforms['envMap'].value = targetIn.texture;
		blurUniforms['samples'].value = samples;
		blurUniforms['weights'].value = weights;
		blurUniforms['latitudinal'].value = direction === 'latitudinal';
		if (poleAxis) {
			blurUniforms['poleAxis'].value = poleAxis;
		}
		const {
			_lodMax
		} = this;
		blurUniforms['dTheta'].value = radiansPerPixel;
		blurUniforms['mipInt'].value = _lodMax - lodIn;
		const outputSize = this._sizeLods[lodOut];
		const x = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);
		const y = 4 * (this._cubeSize - outputSize);
		_setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);
		renderer.setRenderTarget(targetOut);
		renderer.render(blurMesh, _flatCamera);
	}
}
function _createPlanes(lodMax) {
	const lodPlanes = [];
	const sizeLods = [];
	const sigmas = [];
	let lod = lodMax;
	const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
	for (let i = 0; i < totalLods; i++) {
		const sizeLod = Math.pow(2, lod);
		sizeLods.push(sizeLod);
		let sigma = 1.0 / sizeLod;
		if (i > lodMax - LOD_MIN) {
			sigma = EXTRA_LOD_SIGMA[i - lodMax + LOD_MIN - 1];
		} else if (i === 0) {
			sigma = 0;
		}
		sigmas.push(sigma);
		const texelSize = 1.0 / (sizeLod - 2);
		const min = -texelSize;
		const max = 1 + texelSize;
		const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
		const cubeFaces = 6;
		const vertices = 6;
		const positionSize = 3;
		const uvSize = 2;
		const faceIndexSize = 1;
		const position = new Float32Array(positionSize * vertices * cubeFaces);
		const uv = new Float32Array(uvSize * vertices * cubeFaces);
		const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
		for (let face = 0; face < cubeFaces; face++) {
			const x = face % 3 * 2 / 3 - 1;
			const y = face > 2 ? 0 : -1;
			const coordinates = [x, y, 0, x + 2 / 3, y, 0, x + 2 / 3, y + 1, 0, x, y, 0, x + 2 / 3, y + 1, 0, x, y + 1, 0];
			position.set(coordinates, positionSize * vertices * face);
			uv.set(uv1, uvSize * vertices * face);
			const fill = [face, face, face, face, face, face];
			faceIndex.set(fill, faceIndexSize * vertices * face);
		}
		const planes = new BufferGeometry();
		planes.setAttribute('position', new BufferAttribute(position, positionSize));
		planes.setAttribute('uv', new BufferAttribute(uv, uvSize));
		planes.setAttribute('faceIndex', new BufferAttribute(faceIndex, faceIndexSize));
		lodPlanes.push(planes);
		if (lod > LOD_MIN) {
			lod--;
		}
	}
	return {
		lodPlanes,
		sizeLods,
		sigmas
	};
}
function _createRenderTarget(width, height, params) {
	const cubeUVRenderTarget = new WebGLRenderTarget(width, height, params);
	cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
	cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
	cubeUVRenderTarget.scissorTest = true;
	return cubeUVRenderTarget;
}
function _setViewport(target, x, y, width, height) {
	target.viewport.set(x, y, width, height);
	target.scissor.set(x, y, width, height);
}
function _getBlurShader(lodMax, width, height) {
	const weights = new Float32Array(MAX_SAMPLES);
	const poleAxis = new Vector3(0, 1, 0);
	const shaderMaterial = new ShaderMaterial({
		name: 'SphericalGaussianBlur',
		defines: {
			'n': MAX_SAMPLES,
			'CUBEUV_TEXEL_WIDTH': 1.0 / width,
			'CUBEUV_TEXEL_HEIGHT': 1.0 / height,
			'CUBEUV_MAX_MIP': `${lodMax}.0`
		},
		uniforms: {
			'envMap': {
				value: null
			},
			'samples': {
				value: 1
			},
			'weights': {
				value: weights
			},
			'latitudinal': {
				value: false
			},
			'dTheta': {
				value: 0
			},
			'mipInt': {
				value: 0
			},
			'poleAxis': {
				value: poleAxis
			}
		},
		vertexShader: _getCommonVertexShader(),
		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
		blending: NoBlending,
		depthTest: false,
		depthWrite: false
	});
	return shaderMaterial;
}
function _getEquirectMaterial() {
	return new ShaderMaterial({
		name: 'EquirectangularToCubeUV',
		uniforms: {
			'envMap': {
				value: null
			}
		},
		vertexShader: _getCommonVertexShader(),
		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
		blending: NoBlending,
		depthTest: false,
		depthWrite: false
	});
}
function _getCubemapMaterial() {
	return new ShaderMaterial({
		name: 'CubemapToCubeUV',
		uniforms: {
			'envMap': {
				value: null
			},
			'flipEnvMap': {
				value: -1
			}
		},
		vertexShader: _getCommonVertexShader(),
		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
		blending: NoBlending,
		depthTest: false,
		depthWrite: false
	});
}
function _getCommonVertexShader() {
	return (/* glsl */`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
	);
}

function WebGLCubeUVMaps(renderer) {
	let cubeUVmaps = new WeakMap();
	let pmremGenerator = null;
	function get(texture) {
		if (texture && texture.isTexture) {
			const mapping = texture.mapping;
			const isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;
			const isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;

			// equirect/cube map to cubeUV conversion

			if (isEquirectMap || isCubeMap) {
				if (texture.isRenderTargetTexture && texture.needsPMREMUpdate === true) {
					texture.needsPMREMUpdate = false;
					let renderTarget = cubeUVmaps.get(texture);
					if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);
					renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture, renderTarget) : pmremGenerator.fromCubemap(texture, renderTarget);
					cubeUVmaps.set(texture, renderTarget);
					return renderTarget.texture;
				} else {
					if (cubeUVmaps.has(texture)) {
						return cubeUVmaps.get(texture).texture;
					} else {
						const image = texture.image;
						if (isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {
							if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);
							const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);
							cubeUVmaps.set(texture, renderTarget);
							texture.addEventListener('dispose', onTextureDispose);
							return renderTarget.texture;
						} else {
							// image not yet ready. try the conversion next frame

							return null;
						}
					}
				}
			}
		}
		return texture;
	}
	function isCubeTextureComplete(image) {
		let count = 0;
		const length = 6;
		for (let i = 0; i < length; i++) {
			if (image[i] !== undefined) count++;
		}
		return count === length;
	}
	function onTextureDispose(event) {
		const texture = event.target;
		texture.removeEventListener('dispose', onTextureDispose);
		const cubemapUV = cubeUVmaps.get(texture);
		if (cubemapUV !== undefined) {
			cubeUVmaps.delete(texture);
			cubemapUV.dispose();
		}
	}
	function dispose() {
		cubeUVmaps = new WeakMap();
		if (pmremGenerator !== null) {
			pmremGenerator.dispose();
			pmremGenerator = null;
		}
	}
	return {
		get: get,
		dispose: dispose
	};
}

function WebGLExtensions(gl) {
	const extensions = {};
	function getExtension(name) {
		if (extensions[name] !== undefined) {
			return extensions[name];
		}
		let extension;
		switch (name) {
			case 'WEBGL_depth_texture':
				extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
				break;
			case 'EXT_texture_filter_anisotropic':
				extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
				break;
			case 'WEBGL_compressed_texture_s3tc':
				extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
				break;
			case 'WEBGL_compressed_texture_pvrtc':
				extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
				break;
			default:
				extension = gl.getExtension(name);
		}
		extensions[name] = extension;
		return extension;
	}
	return {
		has: function (name) {
			return getExtension(name) !== null;
		},
		init: function (capabilities) {
			if (capabilities.isWebGL2) {
				getExtension('EXT_color_buffer_float');
			} else {
				getExtension('WEBGL_depth_texture');
				getExtension('OES_texture_float');
				getExtension('OES_texture_half_float');
				getExtension('OES_texture_half_float_linear');
				getExtension('OES_standard_derivatives');
				getExtension('OES_element_index_uint');
				getExtension('OES_vertex_array_object');
				getExtension('ANGLE_instanced_arrays');
			}
			getExtension('OES_texture_float_linear');
			getExtension('EXT_color_buffer_half_float');
			getExtension('WEBGL_multisampled_render_to_texture');
		},
		get: function (name) {
			const extension = getExtension(name);
			if (extension === null) {
				console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');
			}
			return extension;
		}
	};
}

function WebGLGeometries(gl, attributes, info, bindingStates) {
	const geometries = {};
	const wireframeAttributes = new WeakMap();
	function onGeometryDispose(event) {
		const geometry = event.target;
		if (geometry.index !== null) {
			attributes.remove(geometry.index);
		}
		for (const name in geometry.attributes) {
			attributes.remove(geometry.attributes[name]);
		}
		geometry.removeEventListener('dispose', onGeometryDispose);
		delete geometries[geometry.id];
		const attribute = wireframeAttributes.get(geometry);
		if (attribute) {
			attributes.remove(attribute);
			wireframeAttributes.delete(geometry);
		}
		bindingStates.releaseStatesOfGeometry(geometry);
		if (geometry.isInstancedBufferGeometry === true) {
			delete geometry._maxInstanceCount;
		}

		//

		info.memory.geometries--;
	}
	function get(object, geometry) {
		if (geometries[geometry.id] === true) return geometry;
		geometry.addEventListener('dispose', onGeometryDispose);
		geometries[geometry.id] = true;
		info.memory.geometries++;
		return geometry;
	}
	function update(geometry) {
		const geometryAttributes = geometry.attributes;

		// Updating index buffer in VAO now. See WebGLBindingStates.

		for (const name in geometryAttributes) {
			attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);
		}

		// morph targets

		const morphAttributes = geometry.morphAttributes;
		for (const name in morphAttributes) {
			const array = morphAttributes[name];
			for (let i = 0, l = array.length; i < l; i++) {
				attributes.update(array[i], gl.ARRAY_BUFFER);
			}
		}
	}
	function updateWireframeAttribute(geometry) {
		const indices = [];
		const geometryIndex = geometry.index;
		const geometryPosition = geometry.attributes.position;
		let version = 0;
		if (geometryIndex !== null) {
			const array = geometryIndex.array;
			version = geometryIndex.version;
			for (let i = 0, l = array.length; i < l; i += 3) {
				const a = array[i + 0];
				const b = array[i + 1];
				const c = array[i + 2];
				indices.push(a, b, b, c, c, a);
			}
		} else {
			const array = geometryPosition.array;
			version = geometryPosition.version;
			for (let i = 0, l = array.length / 3 - 1; i < l; i += 3) {
				const a = i + 0;
				const b = i + 1;
				const c = i + 2;
				indices.push(a, b, b, c, c, a);
			}
		}
		const attribute = new (arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
		attribute.version = version;

		// Updating index buffer in VAO now. See WebGLBindingStates

		//

		const previousAttribute = wireframeAttributes.get(geometry);
		if (previousAttribute) attributes.remove(previousAttribute);

		//

		wireframeAttributes.set(geometry, attribute);
	}
	function getWireframeAttribute(geometry) {
		const currentAttribute = wireframeAttributes.get(geometry);
		if (currentAttribute) {
			const geometryIndex = geometry.index;
			if (geometryIndex !== null) {
				// if the attribute is obsolete, create a new one

				if (currentAttribute.version < geometryIndex.version) {
					updateWireframeAttribute(geometry);
				}
			}
		} else {
			updateWireframeAttribute(geometry);
		}
		return wireframeAttributes.get(geometry);
	}
	return {
		get: get,
		update: update,
		getWireframeAttribute: getWireframeAttribute
	};
}

function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
	const isWebGL2 = capabilities.isWebGL2;
	let mode;
	function setMode(value) {
		mode = value;
	}
	let type, bytesPerElement;
	function setIndex(value) {
		type = value.type;
		bytesPerElement = value.bytesPerElement;
	}
	function render(start, count) {
		gl.drawElements(mode, count, type, start * bytesPerElement);
		info.update(count, mode, 1);
	}
	function renderInstances(start, count, primcount) {
		if (primcount === 0) return;
		let extension, methodName;
		if (isWebGL2) {
			extension = gl;
			methodName = 'drawElementsInstanced';
		} else {
			extension = extensions.get('ANGLE_instanced_arrays');
			methodName = 'drawElementsInstancedANGLE';
			if (extension === null) {
				console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
				return;
			}
		}
		extension[methodName](mode, count, type, start * bytesPerElement, primcount);
		info.update(count, mode, primcount);
	}

	//

	this.setMode = setMode;
	this.setIndex = setIndex;
	this.render = render;
	this.renderInstances = renderInstances;
}

function WebGLInfo(gl) {
	const memory = {
		geometries: 0,
		textures: 0
	};
	const render = {
		frame: 0,
		calls: 0,
		triangles: 0,
		points: 0,
		lines: 0
	};
	function update(count, mode, instanceCount) {
		render.calls++;
		switch (mode) {
			case gl.TRIANGLES:
				render.triangles += instanceCount * (count / 3);
				break;
			case gl.LINES:
				render.lines += instanceCount * (count / 2);
				break;
			case gl.LINE_STRIP:
				render.lines += instanceCount * (count - 1);
				break;
			case gl.LINE_LOOP:
				render.lines += instanceCount * count;
				break;
			case gl.POINTS:
				render.points += instanceCount * count;
				break;
			default:
				console.error('THREE.WebGLInfo: Unknown draw mode:', mode);
				break;
		}
	}
	function reset() {
		render.frame++;
		render.calls = 0;
		render.triangles = 0;
		render.points = 0;
		render.lines = 0;
	}
	return {
		memory: memory,
		render: render,
		programs: null,
		autoReset: true,
		reset: reset,
		update: update
	};
}

function numericalSort(a, b) {
	return a[0] - b[0];
}
function absNumericalSort(a, b) {
	return Math.abs(b[1]) - Math.abs(a[1]);
}
function WebGLMorphtargets(gl, capabilities, textures) {
	const influencesList = {};
	const morphInfluences = new Float32Array(8);
	const morphTextures = new WeakMap();
	const morph = new Vector4();
	const workInfluences = [];
	for (let i = 0; i < 8; i++) {
		workInfluences[i] = [i, 0];
	}
	function update(object, geometry, material, program) {
		const objectInfluences = object.morphTargetInfluences;
		if (capabilities.isWebGL2 === true) {
			// instead of using attributes, the WebGL 2 code path encodes morph targets
			// into an array of data textures. Each layer represents a single morph target.

			const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
			const morphTargetsCount = morphAttribute !== undefined ? morphAttribute.length : 0;
			let entry = morphTextures.get(geometry);
			if (entry === undefined || entry.count !== morphTargetsCount) {
				if (entry !== undefined) entry.texture.dispose();
				const hasMorphPosition = geometry.morphAttributes.position !== undefined;
				const hasMorphNormals = geometry.morphAttributes.normal !== undefined;
				const hasMorphColors = geometry.morphAttributes.color !== undefined;
				const morphTargets = geometry.morphAttributes.position || [];
				const morphNormals = geometry.morphAttributes.normal || [];
				const morphColors = geometry.morphAttributes.color || [];
				let vertexDataCount = 0;
				if (hasMorphPosition === true) vertexDataCount = 1;
				if (hasMorphNormals === true) vertexDataCount = 2;
				if (hasMorphColors === true) vertexDataCount = 3;
				let width = geometry.attributes.position.count * vertexDataCount;
				let height = 1;
				if (width > capabilities.maxTextureSize) {
					height = Math.ceil(width / capabilities.maxTextureSize);
					width = capabilities.maxTextureSize;
				}
				const buffer = new Float32Array(width * height * 4 * morphTargetsCount);
				const texture = new DataArrayTexture(buffer, width, height, morphTargetsCount);
				texture.type = FloatType;
				texture.needsUpdate = true;

				// fill buffer

				const vertexDataStride = vertexDataCount * 4;
				for (let i = 0; i < morphTargetsCount; i++) {
					const morphTarget = morphTargets[i];
					const morphNormal = morphNormals[i];
					const morphColor = morphColors[i];
					const offset = width * height * 4 * i;
					for (let j = 0; j < morphTarget.count; j++) {
						const stride = j * vertexDataStride;
						if (hasMorphPosition === true) {
							morph.fromBufferAttribute(morphTarget, j);
							buffer[offset + stride + 0] = morph.x;
							buffer[offset + stride + 1] = morph.y;
							buffer[offset + stride + 2] = morph.z;
							buffer[offset + stride + 3] = 0;
						}
						if (hasMorphNormals === true) {
							morph.fromBufferAttribute(morphNormal, j);
							buffer[offset + stride + 4] = morph.x;
							buffer[offset + stride + 5] = morph.y;
							buffer[offset + stride + 6] = morph.z;
							buffer[offset + stride + 7] = 0;
						}
						if (hasMorphColors === true) {
							morph.fromBufferAttribute(morphColor, j);
							buffer[offset + stride + 8] = morph.x;
							buffer[offset + stride + 9] = morph.y;
							buffer[offset + stride + 10] = morph.z;
							buffer[offset + stride + 11] = morphColor.itemSize === 4 ? morph.w : 1;
						}
					}
				}
				entry = {
					count: morphTargetsCount,
					texture: texture,
					size: new Vector2(width, height)
				};
				morphTextures.set(geometry, entry);
				function disposeTexture() {
					texture.dispose();
					morphTextures.delete(geometry);
					geometry.removeEventListener('dispose', disposeTexture);
				}
				geometry.addEventListener('dispose', disposeTexture);
			}

			//

			let morphInfluencesSum = 0;
			for (let i = 0; i < objectInfluences.length; i++) {
				morphInfluencesSum += objectInfluences[i];
			}
			const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
			program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);
			program.getUniforms().setValue(gl, 'morphTargetInfluences', objectInfluences);
			program.getUniforms().setValue(gl, 'morphTargetsTexture', entry.texture, textures);
			program.getUniforms().setValue(gl, 'morphTargetsTextureSize', entry.size);
		} else {
			// When object doesn't have morph target influences defined, we treat it as a 0-length array
			// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences

			const length = objectInfluences === undefined ? 0 : objectInfluences.length;
			let influences = influencesList[geometry.id];
			if (influences === undefined || influences.length !== length) {
				// initialise list

				influences = [];
				for (let i = 0; i < length; i++) {
					influences[i] = [i, 0];
				}
				influencesList[geometry.id] = influences;
			}

			// Collect influences

			for (let i = 0; i < length; i++) {
				const influence = influences[i];
				influence[0] = i;
				influence[1] = objectInfluences[i];
			}
			influences.sort(absNumericalSort);
			for (let i = 0; i < 8; i++) {
				if (i < length && influences[i][1]) {
					workInfluences[i][0] = influences[i][0];
					workInfluences[i][1] = influences[i][1];
				} else {
					workInfluences[i][0] = Number.MAX_SAFE_INTEGER;
					workInfluences[i][1] = 0;
				}
			}
			workInfluences.sort(numericalSort);
			const morphTargets = geometry.morphAttributes.position;
			const morphNormals = geometry.morphAttributes.normal;
			let morphInfluencesSum = 0;
			for (let i = 0; i < 8; i++) {
				const influence = workInfluences[i];
				const index = influence[0];
				const value = influence[1];
				if (index !== Number.MAX_SAFE_INTEGER && value) {
					if (morphTargets && geometry.getAttribute('morphTarget' + i) !== morphTargets[index]) {
						geometry.setAttribute('morphTarget' + i, morphTargets[index]);
					}
					if (morphNormals && geometry.getAttribute('morphNormal' + i) !== morphNormals[index]) {
						geometry.setAttribute('morphNormal' + i, morphNormals[index]);
					}
					morphInfluences[i] = value;
					morphInfluencesSum += value;
				} else {
					if (morphTargets && geometry.hasAttribute('morphTarget' + i) === true) {
						geometry.deleteAttribute('morphTarget' + i);
					}
					if (morphNormals && geometry.hasAttribute('morphNormal' + i) === true) {
						geometry.deleteAttribute('morphNormal' + i);
					}
					morphInfluences[i] = 0;
				}
			}

			// GLSL shader uses formula baseinfluence * base + sum(target * influence)
			// This allows us to switch between absolute morphs and relative morphs without changing shader code
			// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
			const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
			program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);
			program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);
		}
	}
	return {
		update: update
	};
}

function WebGLObjects(gl, geometries, attributes, info) {
	let updateMap = new WeakMap();
	function update(object) {
		const frame = info.render.frame;
		const geometry = object.geometry;
		const buffergeometry = geometries.get(object, geometry);

		// Update once per frame

		if (updateMap.get(buffergeometry) !== frame) {
			geometries.update(buffergeometry);
			updateMap.set(buffergeometry, frame);
		}
		if (object.isInstancedMesh) {
			if (object.hasEventListener('dispose', onInstancedMeshDispose) === false) {
				object.addEventListener('dispose', onInstancedMeshDispose);
			}
			attributes.update(object.instanceMatrix, gl.ARRAY_BUFFER);
			if (object.instanceColor !== null) {
				attributes.update(object.instanceColor, gl.ARRAY_BUFFER);
			}
		}
		return buffergeometry;
	}
	function dispose() {
		updateMap = new WeakMap();
	}
	function onInstancedMeshDispose(event) {
		const instancedMesh = event.target;
		instancedMesh.removeEventListener('dispose', onInstancedMeshDispose);
		attributes.remove(instancedMesh.instanceMatrix);
		if (instancedMesh.instanceColor !== null) attributes.remove(instancedMesh.instanceColor);
	}
	return {
		update: update,
		dispose: dispose
	};
}

/**
 * Uniforms of a program.
 * Those form a tree structure with a special top-level container for the root,
 * which you get by calling 'new WebGLUniforms( gl, program )'.
 *
 *
 * Properties of inner nodes including the top-level container:
 *
 * .seq - array of nested uniforms
 * .map - nested uniforms by name
 *
 *
 * Methods of all nodes except the top-level container:
 *
 * .setValue( gl, value, [textures] )
 *
 * 		uploads a uniform value(s)
 *		the 'textures' parameter is needed for sampler uniforms
 *
 *
 * Static methods of the top-level container (textures factorizations):
 *
 * .upload( gl, seq, values, textures )
 *
 * 		sets uniforms in 'seq' to 'values[id].value'
 *
 * .seqWithValue( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with corresponding entry in values
 *
 *
 * Methods of the top-level container (textures factorizations):
 *
 * .setValue( gl, name, value, textures )
 *
 * 		sets uniform with	name 'name' to 'value'
 *
 * .setOptional( gl, obj, prop )
 *
 * 		like .set for an optional property of the object
 *
 */
const emptyTexture = /*@__PURE__*/new Texture();
const emptyArrayTexture = /*@__PURE__*/new DataArrayTexture();
const empty3dTexture = /*@__PURE__*/new Data3DTexture();
const emptyCubeTexture = /*@__PURE__*/new CubeTexture();

// --- Utilities ---

// Array Caches (provide typed arrays for temporary by size)

const arrayCacheF32 = [];
const arrayCacheI32 = [];

// Float32Array caches used for uploading Matrix uniforms

const mat4array = new Float32Array(16);
const mat3array = new Float32Array(9);
const mat2array = new Float32Array(4);

// Flattening for arrays of vectors and matrices

function flatten(array, nBlocks, blockSize) {
	const firstElem = array[0];
	if (firstElem <= 0 || firstElem > 0) return array;
	// unoptimized: ! isNaN( firstElem )
	// see http://jacksondunstan.com/articles/983

	const n = nBlocks * blockSize;
	let r = arrayCacheF32[n];
	if (r === undefined) {
		r = new Float32Array(n);
		arrayCacheF32[n] = r;
	}
	if (nBlocks !== 0) {
		firstElem.toArray(r, 0);
		for (let i = 1, offset = 0; i !== nBlocks; ++i) {
			offset += blockSize;
			array[i].toArray(r, offset);
		}
	}
	return r;
}
function arraysEqual(a, b) {
	if (a.length !== b.length) return false;
	for (let i = 0, l = a.length; i < l; i++) {
		if (a[i] !== b[i]) return false;
	}
	return true;
}
function copyArray(a, b) {
	for (let i = 0, l = b.length; i < l; i++) {
		a[i] = b[i];
	}
}

// Texture unit allocation

function allocTexUnits(textures, n) {
	let r = arrayCacheI32[n];
	if (r === undefined) {
		r = new Int32Array(n);
		arrayCacheI32[n] = r;
	}
	for (let i = 0; i !== n; ++i) {
		r[i] = textures.allocateTextureUnit();
	}
	return r;
}

// --- Setters ---

// Note: Defining these methods externally, because they come in a bunch
// and this way their names minify.

// Single scalar

function setValueV1f(gl, v) {
	const cache = this.cache;
	if (cache[0] === v) return;
	gl.uniform1f(this.addr, v);
	cache[0] = v;
}

// Single float vector (from flat array or THREE.VectorN)

function setValueV2f(gl, v) {
	const cache = this.cache;
	if (v.x !== undefined) {
		if (cache[0] !== v.x || cache[1] !== v.y) {
			gl.uniform2f(this.addr, v.x, v.y);
			cache[0] = v.x;
			cache[1] = v.y;
		}
	} else {
		if (arraysEqual(cache, v)) return;
		gl.uniform2fv(this.addr, v);
		copyArray(cache, v);
	}
}
function setValueV3f(gl, v) {
	const cache = this.cache;
	if (v.x !== undefined) {
		if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
			gl.uniform3f(this.addr, v.x, v.y, v.z);
			cache[0] = v.x;
			cache[1] = v.y;
			cache[2] = v.z;
		}
	} else if (v.r !== undefined) {
		if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
			gl.uniform3f(this.addr, v.r, v.g, v.b);
			cache[0] = v.r;
			cache[1] = v.g;
			cache[2] = v.b;
		}
	} else {
		if (arraysEqual(cache, v)) return;
		gl.uniform3fv(this.addr, v);
		copyArray(cache, v);
	}
}
function setValueV4f(gl, v) {
	const cache = this.cache;
	if (v.x !== undefined) {
		if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
			gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
			cache[0] = v.x;
			cache[1] = v.y;
			cache[2] = v.z;
			cache[3] = v.w;
		}
	} else {
		if (arraysEqual(cache, v)) return;
		gl.uniform4fv(this.addr, v);
		copyArray(cache, v);
	}
}

// Single matrix (from flat array or THREE.MatrixN)

function setValueM2(gl, v) {
	const cache = this.cache;
	const elements = v.elements;
	if (elements === undefined) {
		if (arraysEqual(cache, v)) return;
		gl.uniformMatrix2fv(this.addr, false, v);
		copyArray(cache, v);
	} else {
		if (arraysEqual(cache, elements)) return;
		mat2array.set(elements);
		gl.uniformMatrix2fv(this.addr, false, mat2array);
		copyArray(cache, elements);
	}
}
function setValueM3(gl, v) {
	const cache = this.cache;
	const elements = v.elements;
	if (elements === undefined) {
		if (arraysEqual(cache, v)) return;
		gl.uniformMatrix3fv(this.addr, false, v);
		copyArray(cache, v);
	} else {
		if (arraysEqual(cache, elements)) return;
		mat3array.set(elements);
		gl.uniformMatrix3fv(this.addr, false, mat3array);
		copyArray(cache, elements);
	}
}
function setValueM4(gl, v) {
	const cache = this.cache;
	const elements = v.elements;
	if (elements === undefined) {
		if (arraysEqual(cache, v)) return;
		gl.uniformMatrix4fv(this.addr, false, v);
		copyArray(cache, v);
	} else {
		if (arraysEqual(cache, elements)) return;
		mat4array.set(elements);
		gl.uniformMatrix4fv(this.addr, false, mat4array);
		copyArray(cache, elements);
	}
}

// Single integer / boolean

function setValueV1i(gl, v) {
	const cache = this.cache;
	if (cache[0] === v) return;
	gl.uniform1i(this.addr, v);
	cache[0] = v;
}

// Single integer / boolean vector (from flat array or THREE.VectorN)

function setValueV2i(gl, v) {
	const cache = this.cache;
	if (v.x !== undefined) {
		if (cache[0] !== v.x || cache[1] !== v.y) {
			gl.uniform2i(this.addr, v.x, v.y);
			cache[0] = v.x;
			cache[1] = v.y;
		}
	} else {
		if (arraysEqual(cache, v)) return;
		gl.uniform2iv(this.addr, v);
		copyArray(cache, v);
	}
}
function setValueV3i(gl, v) {
	const cache = this.cache;
	if (v.x !== undefined) {
		if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
			gl.uniform3i(this.addr, v.x, v.y, v.z);
			cache[0] = v.x;
			cache[1] = v.y;
			cache[2] = v.z;
		}
	} else {
		if (arraysEqual(cache, v)) return;
		gl.uniform3iv(this.addr, v);
		copyArray(cache, v);
	}
}
function setValueV4i(gl, v) {
	const cache = this.cache;
	if (v.x !== undefined) {
		if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
			gl.uniform4i(this.addr, v.x, v.y, v.z, v.w);
			cache[0] = v.x;
			cache[1] = v.y;
			cache[2] = v.z;
			cache[3] = v.w;
		}
	} else {
		if (arraysEqual(cache, v)) return;
		gl.uniform4iv(this.addr, v);
		copyArray(cache, v);
	}
}

// Single unsigned integer

function setValueV1ui(gl, v) {
	const cache = this.cache;
	if (cache[0] === v) return;
	gl.uniform1ui(this.addr, v);
	cache[0] = v;
}

// Single unsigned integer vector (from flat array or THREE.VectorN)

function setValueV2ui(gl, v) {
	const cache = this.cache;
	if (v.x !== undefined) {
		if (cache[0] !== v.x || cache[1] !== v.y) {
			gl.uniform2ui(this.addr, v.x, v.y);
			cache[0] = v.x;
			cache[1] = v.y;
		}
	} else {
		if (arraysEqual(cache, v)) return;
		gl.uniform2uiv(this.addr, v);
		copyArray(cache, v);
	}
}
function setValueV3ui(gl, v) {
	const cache = this.cache;
	if (v.x !== undefined) {
		if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
			gl.uniform3ui(this.addr, v.x, v.y, v.z);
			cache[0] = v.x;
			cache[1] = v.y;
			cache[2] = v.z;
		}
	} else {
		if (arraysEqual(cache, v)) return;
		gl.uniform3uiv(this.addr, v);
		copyArray(cache, v);
	}
}
function setValueV4ui(gl, v) {
	const cache = this.cache;
	if (v.x !== undefined) {
		if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
			gl.uniform4ui(this.addr, v.x, v.y, v.z, v.w);
			cache[0] = v.x;
			cache[1] = v.y;
			cache[2] = v.z;
			cache[3] = v.w;
		}
	} else {
		if (arraysEqual(cache, v)) return;
		gl.uniform4uiv(this.addr, v);
		copyArray(cache, v);
	}
}

// Single texture (2D / Cube)

function setValueT1(gl, v, textures) {
	const cache = this.cache;
	const unit = textures.allocateTextureUnit();
	if (cache[0] !== unit) {
		gl.uniform1i(this.addr, unit);
		cache[0] = unit;
	}
	textures.setTexture2D(v || emptyTexture, unit);
}
function setValueT3D1(gl, v, textures) {
	const cache = this.cache;
	const unit = textures.allocateTextureUnit();
	if (cache[0] !== unit) {
		gl.uniform1i(this.addr, unit);
		cache[0] = unit;
	}
	textures.setTexture3D(v || empty3dTexture, unit);
}
function setValueT6(gl, v, textures) {
	const cache = this.cache;
	const unit = textures.allocateTextureUnit();
	if (cache[0] !== unit) {
		gl.uniform1i(this.addr, unit);
		cache[0] = unit;
	}
	textures.setTextureCube(v || emptyCubeTexture, unit);
}
function setValueT2DArray1(gl, v, textures) {
	const cache = this.cache;
	const unit = textures.allocateTextureUnit();
	if (cache[0] !== unit) {
		gl.uniform1i(this.addr, unit);
		cache[0] = unit;
	}
	textures.setTexture2DArray(v || emptyArrayTexture, unit);
}

// Helper to pick the right setter for the singular case

function getSingularSetter(type) {
	switch (type) {
		case 0x1406:
			return setValueV1f;
		// FLOAT
		case 0x8b50:
			return setValueV2f;
		// _VEC2
		case 0x8b51:
			return setValueV3f;
		// _VEC3
		case 0x8b52:
			return setValueV4f;
		// _VEC4

		case 0x8b5a:
			return setValueM2;
		// _MAT2
		case 0x8b5b:
			return setValueM3;
		// _MAT3
		case 0x8b5c:
			return setValueM4;
		// _MAT4

		case 0x1404:
		case 0x8b56:
			return setValueV1i;
		// INT, BOOL
		case 0x8b53:
		case 0x8b57:
			return setValueV2i;
		// _VEC2
		case 0x8b54:
		case 0x8b58:
			return setValueV3i;
		// _VEC3
		case 0x8b55:
		case 0x8b59:
			return setValueV4i;
		// _VEC4

		case 0x1405:
			return setValueV1ui;
		// UINT
		case 0x8dc6:
			return setValueV2ui;
		// _VEC2
		case 0x8dc7:
			return setValueV3ui;
		// _VEC3
		case 0x8dc8:
			return setValueV4ui;
		// _VEC4

		case 0x8b5e: // SAMPLER_2D
		case 0x8d66: // SAMPLER_EXTERNAL_OES
		case 0x8dca: // INT_SAMPLER_2D
		case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
		case 0x8b62:
			// SAMPLER_2D_SHADOW
			return setValueT1;
		case 0x8b5f: // SAMPLER_3D
		case 0x8dcb: // INT_SAMPLER_3D
		case 0x8dd3:
			// UNSIGNED_INT_SAMPLER_3D
			return setValueT3D1;
		case 0x8b60: // SAMPLER_CUBE
		case 0x8dcc: // INT_SAMPLER_CUBE
		case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
		case 0x8dc5:
			// SAMPLER_CUBE_SHADOW
			return setValueT6;
		case 0x8dc1: // SAMPLER_2D_ARRAY
		case 0x8dcf: // INT_SAMPLER_2D_ARRAY
		case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
		case 0x8dc4:
			// SAMPLER_2D_ARRAY_SHADOW
			return setValueT2DArray1;
	}
}

// Array of scalars

function setValueV1fArray(gl, v) {
	gl.uniform1fv(this.addr, v);
}

// Array of vectors (from flat array or array of THREE.VectorN)

function setValueV2fArray(gl, v) {
	const data = flatten(v, this.size, 2);
	gl.uniform2fv(this.addr, data);
}
function setValueV3fArray(gl, v) {
	const data = flatten(v, this.size, 3);
	gl.uniform3fv(this.addr, data);
}
function setValueV4fArray(gl, v) {
	const data = flatten(v, this.size, 4);
	gl.uniform4fv(this.addr, data);
}

// Array of matrices (from flat array or array of THREE.MatrixN)

function setValueM2Array(gl, v) {
	const data = flatten(v, this.size, 4);
	gl.uniformMatrix2fv(this.addr, false, data);
}
function setValueM3Array(gl, v) {
	const data = flatten(v, this.size, 9);
	gl.uniformMatrix3fv(this.addr, false, data);
}
function setValueM4Array(gl, v) {
	const data = flatten(v, this.size, 16);
	gl.uniformMatrix4fv(this.addr, false, data);
}

// Array of integer / boolean

function setValueV1iArray(gl, v) {
	gl.uniform1iv(this.addr, v);
}

// Array of integer / boolean vectors (from flat array)

function setValueV2iArray(gl, v) {
	gl.uniform2iv(this.addr, v);
}
function setValueV3iArray(gl, v) {
	gl.uniform3iv(this.addr, v);
}
function setValueV4iArray(gl, v) {
	gl.uniform4iv(this.addr, v);
}

// Array of unsigned integer

function setValueV1uiArray(gl, v) {
	gl.uniform1uiv(this.addr, v);
}

// Array of unsigned integer vectors (from flat array)

function setValueV2uiArray(gl, v) {
	gl.uniform2uiv(this.addr, v);
}
function setValueV3uiArray(gl, v) {
	gl.uniform3uiv(this.addr, v);
}
function setValueV4uiArray(gl, v) {
	gl.uniform4uiv(this.addr, v);
}

// Array of textures (2D / 3D / Cube / 2DArray)

function setValueT1Array(gl, v, textures) {
	const cache = this.cache;
	const n = v.length;
	const units = allocTexUnits(textures, n);
	if (!arraysEqual(cache, units)) {
		gl.uniform1iv(this.addr, units);
		copyArray(cache, units);
	}
	for (let i = 0; i !== n; ++i) {
		textures.setTexture2D(v[i] || emptyTexture, units[i]);
	}
}
function setValueT3DArray(gl, v, textures) {
	const cache = this.cache;
	const n = v.length;
	const units = allocTexUnits(textures, n);
	if (!arraysEqual(cache, units)) {
		gl.uniform1iv(this.addr, units);
		copyArray(cache, units);
	}
	for (let i = 0; i !== n; ++i) {
		textures.setTexture3D(v[i] || empty3dTexture, units[i]);
	}
}
function setValueT6Array(gl, v, textures) {
	const cache = this.cache;
	const n = v.length;
	const units = allocTexUnits(textures, n);
	if (!arraysEqual(cache, units)) {
		gl.uniform1iv(this.addr, units);
		copyArray(cache, units);
	}
	for (let i = 0; i !== n; ++i) {
		textures.setTextureCube(v[i] || emptyCubeTexture, units[i]);
	}
}
function setValueT2DArrayArray(gl, v, textures) {
	const cache = this.cache;
	const n = v.length;
	const units = allocTexUnits(textures, n);
	if (!arraysEqual(cache, units)) {
		gl.uniform1iv(this.addr, units);
		copyArray(cache, units);
	}
	for (let i = 0; i !== n; ++i) {
		textures.setTexture2DArray(v[i] || emptyArrayTexture, units[i]);
	}
}

// Helper to pick the right setter for a pure (bottom-level) array

function getPureArraySetter(type) {
	switch (type) {
		case 0x1406:
			return setValueV1fArray;
		// FLOAT
		case 0x8b50:
			return setValueV2fArray;
		// _VEC2
		case 0x8b51:
			return setValueV3fArray;
		// _VEC3
		case 0x8b52:
			return setValueV4fArray;
		// _VEC4

		case 0x8b5a:
			return setValueM2Array;
		// _MAT2
		case 0x8b5b:
			return setValueM3Array;
		// _MAT3
		case 0x8b5c:
			return setValueM4Array;
		// _MAT4

		case 0x1404:
		case 0x8b56:
			return setValueV1iArray;
		// INT, BOOL
		case 0x8b53:
		case 0x8b57:
			return setValueV2iArray;
		// _VEC2
		case 0x8b54:
		case 0x8b58:
			return setValueV3iArray;
		// _VEC3
		case 0x8b55:
		case 0x8b59:
			return setValueV4iArray;
		// _VEC4

		case 0x1405:
			return setValueV1uiArray;
		// UINT
		case 0x8dc6:
			return setValueV2uiArray;
		// _VEC2
		case 0x8dc7:
			return setValueV3uiArray;
		// _VEC3
		case 0x8dc8:
			return setValueV4uiArray;
		// _VEC4

		case 0x8b5e: // SAMPLER_2D
		case 0x8d66: // SAMPLER_EXTERNAL_OES
		case 0x8dca: // INT_SAMPLER_2D
		case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
		case 0x8b62:
			// SAMPLER_2D_SHADOW
			return setValueT1Array;
		case 0x8b5f: // SAMPLER_3D
		case 0x8dcb: // INT_SAMPLER_3D
		case 0x8dd3:
			// UNSIGNED_INT_SAMPLER_3D
			return setValueT3DArray;
		case 0x8b60: // SAMPLER_CUBE
		case 0x8dcc: // INT_SAMPLER_CUBE
		case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
		case 0x8dc5:
			// SAMPLER_CUBE_SHADOW
			return setValueT6Array;
		case 0x8dc1: // SAMPLER_2D_ARRAY
		case 0x8dcf: // INT_SAMPLER_2D_ARRAY
		case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
		case 0x8dc4:
			// SAMPLER_2D_ARRAY_SHADOW
			return setValueT2DArrayArray;
	}
}

// --- Uniform Classes ---

class SingleUniform {
	constructor(id, activeInfo, addr) {
		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.setValue = getSingularSetter(activeInfo.type);

		// this.path = activeInfo.name; // DEBUG
	}
}

class PureArrayUniform {
	constructor(id, activeInfo, addr) {
		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.size = activeInfo.size;
		this.setValue = getPureArraySetter(activeInfo.type);

		// this.path = activeInfo.name; // DEBUG
	}
}

class StructuredUniform {
	constructor(id) {
		this.id = id;
		this.seq = [];
		this.map = {};
	}
	setValue(gl, value, textures) {
		const seq = this.seq;
		for (let i = 0, n = seq.length; i !== n; ++i) {
			const u = seq[i];
			u.setValue(gl, value[u.id], textures);
		}
	}
}

// --- Top-level ---

// Parser - builds up the property tree from the path strings

const RePathPart = /(\w+)(\])?(\[|\.)?/g;

// extracts
// 	- the identifier (member name or array index)
//	- followed by an optional right bracket (found when array index)
//	- followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.

function addUniform(container, uniformObject) {
	container.seq.push(uniformObject);
	container.map[uniformObject.id] = uniformObject;
}
function parseUniform(activeInfo, addr, container) {
	const path = activeInfo.name,
		pathLength = path.length;

	// reset RegExp object, because of the early exit of a previous run
	RePathPart.lastIndex = 0;
	while (true) {
		const match = RePathPart.exec(path),
			matchEnd = RePathPart.lastIndex;
		let id = match[1];
		const idIsIndex = match[2] === ']',
			subscript = match[3];
		if (idIsIndex) id = id | 0; // convert to integer

		if (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {
			// bare name or "pure" bottom-level array "[0]" suffix

			addUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
			break;
		} else {
			// step into inner node / create it in case it doesn't exist

			const map = container.map;
			let next = map[id];
			if (next === undefined) {
				next = new StructuredUniform(id);
				addUniform(container, next);
			}
			container = next;
		}
	}
}

// Root Container

class WebGLUniforms {
	constructor(gl, program) {
		this.seq = [];
		this.map = {};
		const n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
		for (let i = 0; i < n; ++i) {
			const info = gl.getActiveUniform(program, i),
				addr = gl.getUniformLocation(program, info.name);
			parseUniform(info, addr, this);
		}
	}
	setValue(gl, name, value, textures) {
		const u = this.map[name];
		if (u !== undefined) u.setValue(gl, value, textures);
	}
	setOptional(gl, object, name) {
		const v = object[name];
		if (v !== undefined) this.setValue(gl, name, v);
	}
	static upload(gl, seq, values, textures) {
		for (let i = 0, n = seq.length; i !== n; ++i) {
			const u = seq[i],
				v = values[u.id];
			if (v.needsUpdate !== false) {
				// note: always updating when .needsUpdate is undefined
				u.setValue(gl, v.value, textures);
			}
		}
	}
	static seqWithValue(seq, values) {
		const r = [];
		for (let i = 0, n = seq.length; i !== n; ++i) {
			const u = seq[i];
			if (u.id in values) r.push(u);
		}
		return r;
	}
}

function WebGLShader(gl, type, string) {
	const shader = gl.createShader(type);
	gl.shaderSource(shader, string);
	gl.compileShader(shader);
	return shader;
}

let programIdCount = 0;
function handleSource(string, errorLine) {
	const lines = string.split('\n');
	const lines2 = [];
	const from = Math.max(errorLine - 6, 0);
	const to = Math.min(errorLine + 6, lines.length);
	for (let i = from; i < to; i++) {
		const line = i + 1;
		lines2.push(`${line === errorLine ? '>' : ' '} ${line}: ${lines[i]}`);
	}
	return lines2.join('\n');
}
function getEncodingComponents(encoding) {
	switch (encoding) {
		case LinearEncoding:
			return ['Linear', '( value )'];
		case sRGBEncoding:
			return ['sRGB', '( value )'];
		default:
			console.warn('THREE.WebGLProgram: Unsupported encoding:', encoding);
			return ['Linear', '( value )'];
	}
}
function getShaderErrors(gl, shader, type) {
	const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
	const errors = gl.getShaderInfoLog(shader).trim();
	if (status && errors === '') return '';
	const errorMatches = /ERROR: 0:(\d+)/.exec(errors);
	if (errorMatches) {
		// --enable-privileged-webgl-extension
		// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

		const errorLine = parseInt(errorMatches[1]);
		return type.toUpperCase() + '\n\n' + errors + '\n\n' + handleSource(gl.getShaderSource(shader), errorLine);
	} else {
		return errors;
	}
}
function getTexelEncodingFunction(functionName, encoding) {
	const components = getEncodingComponents(encoding);
	return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }';
}
function getToneMappingFunction(functionName, toneMapping) {
	let toneMappingName;
	switch (toneMapping) {
		case LinearToneMapping:
			toneMappingName = 'Linear';
			break;
		case ReinhardToneMapping:
			toneMappingName = 'Reinhard';
			break;
		case CineonToneMapping:
			toneMappingName = 'OptimizedCineon';
			break;
		case ACESFilmicToneMapping:
			toneMappingName = 'ACESFilmic';
			break;
		case CustomToneMapping:
			toneMappingName = 'Custom';
			break;
		default:
			console.warn('THREE.WebGLProgram: Unsupported toneMapping:', toneMapping);
			toneMappingName = 'Linear';
	}
	return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';
}
function generateExtensions(parameters) {
	const chunks = [parameters.extensionDerivatives || !!parameters.envMapCubeUVHeight || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ? '#extension GL_OES_standard_derivatives : enable' : '', (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '', parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? '#extension GL_EXT_draw_buffers : require' : '', (parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''];
	return chunks.filter(filterEmptyLine).join('\n');
}
function generateDefines(defines) {
	const chunks = [];
	for (const name in defines) {
		const value = defines[name];
		if (value === false) continue;
		chunks.push('#define ' + name + ' ' + value);
	}
	return chunks.join('\n');
}
function fetchAttributeLocations(gl, program) {
	const attributes = {};
	const n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
	for (let i = 0; i < n; i++) {
		const info = gl.getActiveAttrib(program, i);
		const name = info.name;
		let locationSize = 1;
		if (info.type === gl.FLOAT_MAT2) locationSize = 2;
		if (info.type === gl.FLOAT_MAT3) locationSize = 3;
		if (info.type === gl.FLOAT_MAT4) locationSize = 4;

		// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

		attributes[name] = {
			type: info.type,
			location: gl.getAttribLocation(program, name),
			locationSize: locationSize
		};
	}
	return attributes;
}
function filterEmptyLine(string) {
	return string !== '';
}
function replaceLightNums(string, parameters) {
	const numSpotLightCoords = parameters.numSpotLightShadows + parameters.numSpotLightMaps - parameters.numSpotLightShadowsWithMaps;
	return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, parameters.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, numSpotLightCoords).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, parameters.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
}
function replaceClippingPlaneNums(string, parameters) {
	return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
}

// Resolve Includes

const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(string) {
	return string.replace(includePattern, includeReplacer);
}
function includeReplacer(match, include) {
	const string = ShaderChunk[include];
	if (string === undefined) {
		throw new Error('Can not resolve #include <' + include + '>');
	}
	return resolveIncludes(string);
}

// Unroll Loops

const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function unrollLoops(string) {
	return string.replace(unrollLoopPattern, loopReplacer);
}
function loopReplacer(match, start, end, snippet) {
	let string = '';
	for (let i = parseInt(start); i < parseInt(end); i++) {
		string += snippet.replace(/\[\s*i\s*\]/g, '[ ' + i + ' ]').replace(/UNROLLED_LOOP_INDEX/g, i);
	}
	return string;
}

//

function generatePrecision(parameters) {
	let precisionstring = 'precision ' + parameters.precision + ' float;\nprecision ' + parameters.precision + ' int;';
	if (parameters.precision === 'highp') {
		precisionstring += '\n#define HIGH_PRECISION';
	} else if (parameters.precision === 'mediump') {
		precisionstring += '\n#define MEDIUM_PRECISION';
	} else if (parameters.precision === 'lowp') {
		precisionstring += '\n#define LOW_PRECISION';
	}
	return precisionstring;
}
function generateShadowMapTypeDefine(parameters) {
	let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
	if (parameters.shadowMapType === PCFShadowMap) {
		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
	} else if (parameters.shadowMapType === PCFSoftShadowMap) {
		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
	} else if (parameters.shadowMapType === VSMShadowMap) {
		shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';
	}
	return shadowMapTypeDefine;
}
function generateEnvMapTypeDefine(parameters) {
	let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
	if (parameters.envMap) {
		switch (parameters.envMapMode) {
			case CubeReflectionMapping:
			case CubeRefractionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
				break;
			case CubeUVReflectionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
				break;
		}
	}
	return envMapTypeDefine;
}
function generateEnvMapModeDefine(parameters) {
	let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
	if (parameters.envMap) {
		switch (parameters.envMapMode) {
			case CubeRefractionMapping:
				envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
				break;
		}
	}
	return envMapModeDefine;
}
function generateEnvMapBlendingDefine(parameters) {
	let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';
	if (parameters.envMap) {
		switch (parameters.combine) {
			case MultiplyOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
				break;
			case MixOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
				break;
			case AddOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
				break;
		}
	}
	return envMapBlendingDefine;
}
function generateCubeUVSize(parameters) {
	const imageHeight = parameters.envMapCubeUVHeight;
	if (imageHeight === null) return null;
	const maxMip = Math.log2(imageHeight) - 2;
	const texelHeight = 1.0 / imageHeight;
	const texelWidth = 1.0 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
	return {
		texelWidth,
		texelHeight,
		maxMip
	};
}
function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
	// TODO Send this event to Three.js DevTools
	// console.log( 'WebGLProgram', cacheKey );

	const gl = renderer.getContext();
	const defines = parameters.defines;
	let vertexShader = parameters.vertexShader;
	let fragmentShader = parameters.fragmentShader;
	const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
	const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
	const envMapModeDefine = generateEnvMapModeDefine(parameters);
	const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
	const envMapCubeUVSize = generateCubeUVSize(parameters);
	const customExtensions = parameters.isWebGL2 ? '' : generateExtensions(parameters);
	const customDefines = generateDefines(defines);
	const program = gl.createProgram();
	let prefixVertex, prefixFragment;
	let versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : '';
	if (parameters.isRawShaderMaterial) {
		prefixVertex = [customDefines].filter(filterEmptyLine).join('\n');
		if (prefixVertex.length > 0) {
			prefixVertex += '\n';
		}
		prefixFragment = [customExtensions, customDefines].filter(filterEmptyLine).join('\n');
		if (prefixFragment.length > 0) {
			prefixFragment += '\n';
		}
	} else {
		prefixVertex = [generatePrecision(parameters), '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.instancing ? '#define USE_INSTANCING' : '', parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '', parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '', parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '', parameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '', parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '', parameters.specularColorMap ? '#define USE_SPECULARCOLORMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.transmission ? '#define USE_TRANSMISSION' : '', parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '', parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '', parameters.sheenColorMap ? '#define USE_SHEENCOLORMAP' : '', parameters.sheenRoughnessMap ? '#define USE_SHEENROUGHNESSMAP' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '', parameters.vertexUvs ? '#define USE_UV' : '', parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.skinning ? '#define USE_SKINNING' : '', parameters.morphTargets ? '#define USE_MORPHTARGETS' : '', parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '', parameters.morphColors && parameters.isWebGL2 ? '#define USE_MORPHCOLORS' : '', parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? '#define MORPHTARGETS_TEXTURE' : '', parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? '#define MORPHTARGETS_TEXTURE_STRIDE ' + parameters.morphTextureStride : '', parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? '#define MORPHTARGETS_COUNT ' + parameters.morphTargetsCount : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '', 'uniform mat4 modelMatrix;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform mat4 viewMatrix;', 'uniform mat3 normalMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', '#ifdef USE_INSTANCING', '	attribute mat4 instanceMatrix;', '#endif', '#ifdef USE_INSTANCING_COLOR', '	attribute vec3 instanceColor;', '#endif', 'attribute vec3 position;', 'attribute vec3 normal;', 'attribute vec2 uv;', '#ifdef USE_TANGENT', '	attribute vec4 tangent;', '#endif', '#if defined( USE_COLOR_ALPHA )', '	attribute vec4 color;', '#elif defined( USE_COLOR )', '	attribute vec3 color;', '#endif', '#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )', '	attribute vec3 morphTarget0;', '	attribute vec3 morphTarget1;', '	attribute vec3 morphTarget2;', '	attribute vec3 morphTarget3;', '	#ifdef USE_MORPHNORMALS', '		attribute vec3 morphNormal0;', '		attribute vec3 morphNormal1;', '		attribute vec3 morphNormal2;', '		attribute vec3 morphNormal3;', '	#else', '		attribute vec3 morphTarget4;', '		attribute vec3 morphTarget5;', '		attribute vec3 morphTarget6;', '		attribute vec3 morphTarget7;', '	#endif', '#endif', '#ifdef USE_SKINNING', '	attribute vec4 skinIndex;', '	attribute vec4 skinWeight;', '#endif', '\n'].filter(filterEmptyLine).join('\n');
		prefixFragment = [customExtensions, generatePrecision(parameters), '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.matcap ? '#define USE_MATCAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapTypeDefine : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.envMap ? '#define ' + envMapBlendingDefine : '', envMapCubeUVSize ? '#define CUBEUV_TEXEL_WIDTH ' + envMapCubeUVSize.texelWidth : '', envMapCubeUVSize ? '#define CUBEUV_TEXEL_HEIGHT ' + envMapCubeUVSize.texelHeight : '', envMapCubeUVSize ? '#define CUBEUV_MAX_MIP ' + envMapCubeUVSize.maxMip + '.0' : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', parameters.clearcoat ? '#define USE_CLEARCOAT' : '', parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.iridescence ? '#define USE_IRIDESCENCE' : '', parameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '', parameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '', parameters.specularColorMap ? '#define USE_SPECULARCOLORMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.alphaTest ? '#define USE_ALPHATEST' : '', parameters.sheen ? '#define USE_SHEEN' : '', parameters.sheenColorMap ? '#define USE_SHEENCOLORMAP' : '', parameters.sheenRoughnessMap ? '#define USE_SHEENROUGHNESSMAP' : '', parameters.transmission ? '#define USE_TRANSMISSION' : '', parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '', parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '', parameters.decodeVideoTexture ? '#define DECODE_VIDEO_TEXTURE' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '', parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '', parameters.vertexUvs ? '#define USE_UV' : '', parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', parameters.gradientMap ? '#define USE_GRADIENTMAP' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '', parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '', 'uniform mat4 viewMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', parameters.toneMapping !== NoToneMapping ? '#define TONE_MAPPING' : '', parameters.toneMapping !== NoToneMapping ? ShaderChunk['tonemapping_pars_fragment'] : '',
		// this code is required here because it is used by the toneMapping() function defined below
		parameters.toneMapping !== NoToneMapping ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '', parameters.dithering ? '#define DITHERING' : '', parameters.opaque ? '#define OPAQUE' : '', ShaderChunk['encodings_pars_fragment'],
		// this code is required here because it is used by the various encoding/decoding function defined below
		getTexelEncodingFunction('linearToOutputTexel', parameters.outputEncoding), parameters.useDepthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '', '\n'].filter(filterEmptyLine).join('\n');
	}
	vertexShader = resolveIncludes(vertexShader);
	vertexShader = replaceLightNums(vertexShader, parameters);
	vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
	fragmentShader = resolveIncludes(fragmentShader);
	fragmentShader = replaceLightNums(fragmentShader, parameters);
	fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
	vertexShader = unrollLoops(vertexShader);
	fragmentShader = unrollLoops(fragmentShader);
	if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
		// GLSL 3.0 conversion for built-in materials and ShaderMaterial

		versionString = '#version 300 es\n';
		prefixVertex = ['precision mediump sampler2DArray;', '#define attribute in', '#define varying out', '#define texture2D texture'].join('\n') + '\n' + prefixVertex;
		prefixFragment = ['#define varying in', parameters.glslVersion === GLSL3 ? '' : 'layout(location = 0) out highp vec4 pc_fragColor;', parameters.glslVersion === GLSL3 ? '' : '#define gl_FragColor pc_fragColor', '#define gl_FragDepthEXT gl_FragDepth', '#define texture2D texture', '#define textureCube texture', '#define texture2DProj textureProj', '#define texture2DLodEXT textureLod', '#define texture2DProjLodEXT textureProjLod', '#define textureCubeLodEXT textureLod', '#define texture2DGradEXT textureGrad', '#define texture2DProjGradEXT textureProjGrad', '#define textureCubeGradEXT textureGrad'].join('\n') + '\n' + prefixFragment;
	}
	const vertexGlsl = versionString + prefixVertex + vertexShader;
	const fragmentGlsl = versionString + prefixFragment + fragmentShader;

	// console.log( '*VERTEX*', vertexGlsl );
	// console.log( '*FRAGMENT*', fragmentGlsl );

	const glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
	const glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
	gl.attachShader(program, glVertexShader);
	gl.attachShader(program, glFragmentShader);

	// Force a particular attribute to index 0.

	if (parameters.index0AttributeName !== undefined) {
		gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
	} else if (parameters.morphTargets === true) {
		// programs with morphTargets displace position out of attribute 0
		gl.bindAttribLocation(program, 0, 'position');
	}
	gl.linkProgram(program);

	// check for link errors
	if (renderer.debug.checkShaderErrors) {
		const programLog = gl.getProgramInfoLog(program).trim();
		const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
		const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
		let runnable = true;
		let haveDiagnostics = true;
		if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
			runnable = false;
			const vertexErrors = getShaderErrors(gl, glVertexShader, 'vertex');
			const fragmentErrors = getShaderErrors(gl, glFragmentShader, 'fragment');
			console.error('THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' + 'VALIDATE_STATUS ' + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + '\n\n' + 'Program Info Log: ' + programLog + '\n' + vertexErrors + '\n' + fragmentErrors);
		} else if (programLog !== '') {
			console.warn('THREE.WebGLProgram: Program Info Log:', programLog);
		} else if (vertexLog === '' || fragmentLog === '') {
			haveDiagnostics = false;
		}
		if (haveDiagnostics) {
			this.diagnostics = {
				runnable: runnable,
				programLog: programLog,
				vertexShader: {
					log: vertexLog,
					prefix: prefixVertex
				},
				fragmentShader: {
					log: fragmentLog,
					prefix: prefixFragment
				}
			};
		}
	}

	// Clean up

	// Crashes in iOS9 and iOS10. #18402
	// gl.detachShader( program, glVertexShader );
	// gl.detachShader( program, glFragmentShader );

	gl.deleteShader(glVertexShader);
	gl.deleteShader(glFragmentShader);

	// set up caching for uniform locations

	let cachedUniforms;
	this.getUniforms = function () {
		if (cachedUniforms === undefined) {
			cachedUniforms = new WebGLUniforms(gl, program);
		}
		return cachedUniforms;
	};

	// set up caching for attribute locations

	let cachedAttributes;
	this.getAttributes = function () {
		if (cachedAttributes === undefined) {
			cachedAttributes = fetchAttributeLocations(gl, program);
		}
		return cachedAttributes;
	};

	// free resource

	this.destroy = function () {
		bindingStates.releaseStatesOfProgram(this);
		gl.deleteProgram(program);
		this.program = undefined;
	};

	//

	this.name = parameters.shaderName;
	this.id = programIdCount++;
	this.cacheKey = cacheKey;
	this.usedTimes = 1;
	this.program = program;
	this.vertexShader = glVertexShader;
	this.fragmentShader = glFragmentShader;
	return this;
}

let _id = 0;
class WebGLShaderCache {
	constructor() {
		this.shaderCache = new Map();
		this.materialCache = new Map();
	}
	update(material) {
		const vertexShader = material.vertexShader;
		const fragmentShader = material.fragmentShader;
		const vertexShaderStage = this._getShaderStage(vertexShader);
		const fragmentShaderStage = this._getShaderStage(fragmentShader);
		const materialShaders = this._getShaderCacheForMaterial(material);
		if (materialShaders.has(vertexShaderStage) === false) {
			materialShaders.add(vertexShaderStage);
			vertexShaderStage.usedTimes++;
		}
		if (materialShaders.has(fragmentShaderStage) === false) {
			materialShaders.add(fragmentShaderStage);
			fragmentShaderStage.usedTimes++;
		}
		return this;
	}
	remove(material) {
		const materialShaders = this.materialCache.get(material);
		for (const shaderStage of materialShaders) {
			shaderStage.usedTimes--;
			if (shaderStage.usedTimes === 0) this.shaderCache.delete(shaderStage.code);
		}
		this.materialCache.delete(material);
		return this;
	}
	getVertexShaderID(material) {
		return this._getShaderStage(material.vertexShader).id;
	}
	getFragmentShaderID(material) {
		return this._getShaderStage(material.fragmentShader).id;
	}
	dispose() {
		this.shaderCache.clear();
		this.materialCache.clear();
	}
	_getShaderCacheForMaterial(material) {
		const cache = this.materialCache;
		let set = cache.get(material);
		if (set === undefined) {
			set = new Set();
			cache.set(material, set);
		}
		return set;
	}
	_getShaderStage(code) {
		const cache = this.shaderCache;
		let stage = cache.get(code);
		if (stage === undefined) {
			stage = new WebGLShaderStage(code);
			cache.set(code, stage);
		}
		return stage;
	}
}
class WebGLShaderStage {
	constructor(code) {
		this.id = _id++;
		this.code = code;
		this.usedTimes = 0;
	}
}

function WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {
	const _programLayers = new Layers();
	const _customShaders = new WebGLShaderCache();
	const programs = [];
	const isWebGL2 = capabilities.isWebGL2;
	const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
	const vertexTextures = capabilities.vertexTextures;
	let precision = capabilities.precision;
	const shaderIDs = {
		MeshDepthMaterial: 'depth',
		MeshDistanceMaterial: 'distanceRGBA',
		MeshNormalMaterial: 'normal',
		MeshBasicMaterial: 'basic',
		MeshLambertMaterial: 'lambert',
		MeshPhongMaterial: 'phong',
		MeshToonMaterial: 'toon',
		MeshStandardMaterial: 'physical',
		MeshPhysicalMaterial: 'physical',
		MeshMatcapMaterial: 'matcap',
		LineBasicMaterial: 'basic',
		LineDashedMaterial: 'dashed',
		PointsMaterial: 'points',
		ShadowMaterial: 'shadow',
		SpriteMaterial: 'sprite'
	};
	function getParameters(material, lights, shadows, scene, object) {
		const fog = scene.fog;
		const geometry = object.geometry;
		const environment = material.isMeshStandardMaterial ? scene.environment : null;
		const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
		const envMapCubeUVHeight = !!envMap && envMap.mapping === CubeUVReflectionMapping ? envMap.image.height : null;
		const shaderID = shaderIDs[material.type];

		// heuristics to create shader parameters according to lights in the scene
		// (not to blow over maxLights budget)

		if (material.precision !== null) {
			precision = capabilities.getMaxPrecision(material.precision);
			if (precision !== material.precision) {
				console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');
			}
		}

		//

		const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
		const morphTargetsCount = morphAttribute !== undefined ? morphAttribute.length : 0;
		let morphTextureStride = 0;
		if (geometry.morphAttributes.position !== undefined) morphTextureStride = 1;
		if (geometry.morphAttributes.normal !== undefined) morphTextureStride = 2;
		if (geometry.morphAttributes.color !== undefined) morphTextureStride = 3;

		//

		let vertexShader, fragmentShader;
		let customVertexShaderID, customFragmentShaderID;
		if (shaderID) {
			const shader = ShaderLib[shaderID];
			vertexShader = shader.vertexShader;
			fragmentShader = shader.fragmentShader;
		} else {
			vertexShader = material.vertexShader;
			fragmentShader = material.fragmentShader;
			_customShaders.update(material);
			customVertexShaderID = _customShaders.getVertexShaderID(material);
			customFragmentShaderID = _customShaders.getFragmentShaderID(material);
		}
		const currentRenderTarget = renderer.getRenderTarget();
		const useAlphaTest = material.alphaTest > 0;
		const useClearcoat = material.clearcoat > 0;
		const useIridescence = material.iridescence > 0;
		const parameters = {
			isWebGL2: isWebGL2,
			shaderID: shaderID,
			shaderName: material.type,
			vertexShader: vertexShader,
			fragmentShader: fragmentShader,
			defines: material.defines,
			customVertexShaderID: customVertexShaderID,
			customFragmentShaderID: customFragmentShaderID,
			isRawShaderMaterial: material.isRawShaderMaterial === true,
			glslVersion: material.glslVersion,
			precision: precision,
			instancing: object.isInstancedMesh === true,
			instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
			supportsVertexTextures: vertexTextures,
			outputEncoding: currentRenderTarget === null ? renderer.outputEncoding : currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.encoding : LinearEncoding,
			map: !!material.map,
			matcap: !!material.matcap,
			envMap: !!envMap,
			envMapMode: envMap && envMap.mapping,
			envMapCubeUVHeight: envMapCubeUVHeight,
			lightMap: !!material.lightMap,
			aoMap: !!material.aoMap,
			emissiveMap: !!material.emissiveMap,
			bumpMap: !!material.bumpMap,
			normalMap: !!material.normalMap,
			objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
			tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
			decodeVideoTexture: !!material.map && material.map.isVideoTexture === true && material.map.encoding === sRGBEncoding,
			clearcoat: useClearcoat,
			clearcoatMap: useClearcoat && !!material.clearcoatMap,
			clearcoatRoughnessMap: useClearcoat && !!material.clearcoatRoughnessMap,
			clearcoatNormalMap: useClearcoat && !!material.clearcoatNormalMap,
			iridescence: useIridescence,
			iridescenceMap: useIridescence && !!material.iridescenceMap,
			iridescenceThicknessMap: useIridescence && !!material.iridescenceThicknessMap,
			displacementMap: !!material.displacementMap,
			roughnessMap: !!material.roughnessMap,
			metalnessMap: !!material.metalnessMap,
			specularMap: !!material.specularMap,
			specularIntensityMap: !!material.specularIntensityMap,
			specularColorMap: !!material.specularColorMap,
			opaque: material.transparent === false && material.blending === NormalBlending,
			alphaMap: !!material.alphaMap,
			alphaTest: useAlphaTest,
			gradientMap: !!material.gradientMap,
			sheen: material.sheen > 0,
			sheenColorMap: !!material.sheenColorMap,
			sheenRoughnessMap: !!material.sheenRoughnessMap,
			transmission: material.transmission > 0,
			transmissionMap: !!material.transmissionMap,
			thicknessMap: !!material.thicknessMap,
			combine: material.combine,
			vertexTangents: !!material.normalMap && !!geometry.attributes.tangent,
			vertexColors: material.vertexColors,
			vertexAlphas: material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4,
			vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.iridescenceMap || !!material.iridescenceThicknessMap || !!material.displacementMap || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || !!material.sheenColorMap || !!material.sheenRoughnessMap,
			uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || !!material.iridescenceMap || !!material.iridescenceThicknessMap || material.transmission > 0 || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || material.sheen > 0 || !!material.sheenColorMap || !!material.sheenRoughnessMap) && !!material.displacementMap,
			fog: !!fog,
			useFog: material.fog === true,
			fogExp2: fog && fog.isFogExp2,
			flatShading: !!material.flatShading,
			sizeAttenuation: material.sizeAttenuation,
			logarithmicDepthBuffer: logarithmicDepthBuffer,
			skinning: object.isSkinnedMesh === true,
			morphTargets: geometry.morphAttributes.position !== undefined,
			morphNormals: geometry.morphAttributes.normal !== undefined,
			morphColors: geometry.morphAttributes.color !== undefined,
			morphTargetsCount: morphTargetsCount,
			morphTextureStride: morphTextureStride,
			numDirLights: lights.directional.length,
			numPointLights: lights.point.length,
			numSpotLights: lights.spot.length,
			numSpotLightMaps: lights.spotLightMap.length,
			numRectAreaLights: lights.rectArea.length,
			numHemiLights: lights.hemi.length,
			numDirLightShadows: lights.directionalShadowMap.length,
			numPointLightShadows: lights.pointShadowMap.length,
			numSpotLightShadows: lights.spotShadowMap.length,
			numSpotLightShadowsWithMaps: lights.numSpotLightShadowsWithMaps,
			numClippingPlanes: clipping.numPlanes,
			numClipIntersection: clipping.numIntersection,
			dithering: material.dithering,
			shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
			shadowMapType: renderer.shadowMap.type,
			toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
			physicallyCorrectLights: renderer.physicallyCorrectLights,
			premultipliedAlpha: material.premultipliedAlpha,
			doubleSided: material.side === DoubleSide,
			flipSided: material.side === BackSide,
			useDepthPacking: !!material.depthPacking,
			depthPacking: material.depthPacking || 0,
			index0AttributeName: material.index0AttributeName,
			extensionDerivatives: material.extensions && material.extensions.derivatives,
			extensionFragDepth: material.extensions && material.extensions.fragDepth,
			extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
			extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
			rendererExtensionFragDepth: isWebGL2 || extensions.has('EXT_frag_depth'),
			rendererExtensionDrawBuffers: isWebGL2 || extensions.has('WEBGL_draw_buffers'),
			rendererExtensionShaderTextureLod: isWebGL2 || extensions.has('EXT_shader_texture_lod'),
			customProgramCacheKey: material.customProgramCacheKey()
		};
		return parameters;
	}
	function getProgramCacheKey(parameters) {
		const array = [];
		if (parameters.shaderID) {
			array.push(parameters.shaderID);
		} else {
			array.push(parameters.customVertexShaderID);
			array.push(parameters.customFragmentShaderID);
		}
		if (parameters.defines !== undefined) {
			for (const name in parameters.defines) {
				array.push(name);
				array.push(parameters.defines[name]);
			}
		}
		if (parameters.isRawShaderMaterial === false) {
			getProgramCacheKeyParameters(array, parameters);
			getProgramCacheKeyBooleans(array, parameters);
			array.push(renderer.outputEncoding);
		}
		array.push(parameters.customProgramCacheKey);
		return array.join();
	}
	function getProgramCacheKeyParameters(array, parameters) {
		array.push(parameters.precision);
		array.push(parameters.outputEncoding);
		array.push(parameters.envMapMode);
		array.push(parameters.envMapCubeUVHeight);
		array.push(parameters.combine);
		array.push(parameters.vertexUvs);
		array.push(parameters.fogExp2);
		array.push(parameters.sizeAttenuation);
		array.push(parameters.morphTargetsCount);
		array.push(parameters.morphAttributeCount);
		array.push(parameters.numDirLights);
		array.push(parameters.numPointLights);
		array.push(parameters.numSpotLights);
		array.push(parameters.numSpotLightMaps);
		array.push(parameters.numHemiLights);
		array.push(parameters.numRectAreaLights);
		array.push(parameters.numDirLightShadows);
		array.push(parameters.numPointLightShadows);
		array.push(parameters.numSpotLightShadows);
		array.push(parameters.numSpotLightShadowsWithMaps);
		array.push(parameters.shadowMapType);
		array.push(parameters.toneMapping);
		array.push(parameters.numClippingPlanes);
		array.push(parameters.numClipIntersection);
		array.push(parameters.depthPacking);
	}
	function getProgramCacheKeyBooleans(array, parameters) {
		_programLayers.disableAll();
		if (parameters.isWebGL2) _programLayers.enable(0);
		if (parameters.supportsVertexTextures) _programLayers.enable(1);
		if (parameters.instancing) _programLayers.enable(2);
		if (parameters.instancingColor) _programLayers.enable(3);
		if (parameters.map) _programLayers.enable(4);
		if (parameters.matcap) _programLayers.enable(5);
		if (parameters.envMap) _programLayers.enable(6);
		if (parameters.lightMap) _programLayers.enable(7);
		if (parameters.aoMap) _programLayers.enable(8);
		if (parameters.emissiveMap) _programLayers.enable(9);
		if (parameters.bumpMap) _programLayers.enable(10);
		if (parameters.normalMap) _programLayers.enable(11);
		if (parameters.objectSpaceNormalMap) _programLayers.enable(12);
		if (parameters.tangentSpaceNormalMap) _programLayers.enable(13);
		if (parameters.clearcoat) _programLayers.enable(14);
		if (parameters.clearcoatMap) _programLayers.enable(15);
		if (parameters.clearcoatRoughnessMap) _programLayers.enable(16);
		if (parameters.clearcoatNormalMap) _programLayers.enable(17);
		if (parameters.iridescence) _programLayers.enable(18);
		if (parameters.iridescenceMap) _programLayers.enable(19);
		if (parameters.iridescenceThicknessMap) _programLayers.enable(20);
		if (parameters.displacementMap) _programLayers.enable(21);
		if (parameters.specularMap) _programLayers.enable(22);
		if (parameters.roughnessMap) _programLayers.enable(23);
		if (parameters.metalnessMap) _programLayers.enable(24);
		if (parameters.gradientMap) _programLayers.enable(25);
		if (parameters.alphaMap) _programLayers.enable(26);
		if (parameters.alphaTest) _programLayers.enable(27);
		if (parameters.vertexColors) _programLayers.enable(28);
		if (parameters.vertexAlphas) _programLayers.enable(29);
		if (parameters.vertexUvs) _programLayers.enable(30);
		if (parameters.vertexTangents) _programLayers.enable(31);
		if (parameters.uvsVertexOnly) _programLayers.enable(32);
		array.push(_programLayers.mask);
		_programLayers.disableAll();
		if (parameters.fog) _programLayers.enable(0);
		if (parameters.useFog) _programLayers.enable(1);
		if (parameters.flatShading) _programLayers.enable(2);
		if (parameters.logarithmicDepthBuffer) _programLayers.enable(3);
		if (parameters.skinning) _programLayers.enable(4);
		if (parameters.morphTargets) _programLayers.enable(5);
		if (parameters.morphNormals) _programLayers.enable(6);
		if (parameters.morphColors) _programLayers.enable(7);
		if (parameters.premultipliedAlpha) _programLayers.enable(8);
		if (parameters.shadowMapEnabled) _programLayers.enable(9);
		if (parameters.physicallyCorrectLights) _programLayers.enable(10);
		if (parameters.doubleSided) _programLayers.enable(11);
		if (parameters.flipSided) _programLayers.enable(12);
		if (parameters.useDepthPacking) _programLayers.enable(13);
		if (parameters.dithering) _programLayers.enable(14);
		if (parameters.specularIntensityMap) _programLayers.enable(15);
		if (parameters.specularColorMap) _programLayers.enable(16);
		if (parameters.transmission) _programLayers.enable(17);
		if (parameters.transmissionMap) _programLayers.enable(18);
		if (parameters.thicknessMap) _programLayers.enable(19);
		if (parameters.sheen) _programLayers.enable(20);
		if (parameters.sheenColorMap) _programLayers.enable(21);
		if (parameters.sheenRoughnessMap) _programLayers.enable(22);
		if (parameters.decodeVideoTexture) _programLayers.enable(23);
		if (parameters.opaque) _programLayers.enable(24);
		array.push(_programLayers.mask);
	}
	function getUniforms(material) {
		const shaderID = shaderIDs[material.type];
		let uniforms;
		if (shaderID) {
			const shader = ShaderLib[shaderID];
			uniforms = UniformsUtils.clone(shader.uniforms);
		} else {
			uniforms = material.uniforms;
		}
		return uniforms;
	}
	function acquireProgram(parameters, cacheKey) {
		let program;

		// Check if code has been already compiled
		for (let p = 0, pl = programs.length; p < pl; p++) {
			const preexistingProgram = programs[p];
			if (preexistingProgram.cacheKey === cacheKey) {
				program = preexistingProgram;
				++program.usedTimes;
				break;
			}
		}
		if (program === undefined) {
			program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
			programs.push(program);
		}
		return program;
	}
	function releaseProgram(program) {
		if (--program.usedTimes === 0) {
			// Remove from unordered set
			const i = programs.indexOf(program);
			programs[i] = programs[programs.length - 1];
			programs.pop();

			// Free WebGL resources
			program.destroy();
		}
	}
	function releaseShaderCache(material) {
		_customShaders.remove(material);
	}
	function dispose() {
		_customShaders.dispose();
	}
	return {
		getParameters: getParameters,
		getProgramCacheKey: getProgramCacheKey,
		getUniforms: getUniforms,
		acquireProgram: acquireProgram,
		releaseProgram: releaseProgram,
		releaseShaderCache: releaseShaderCache,
		// Exposed for resource monitoring & error feedback via renderer.info:
		programs: programs,
		dispose: dispose
	};
}

function WebGLProperties() {
	let properties = new WeakMap();
	function get(object) {
		let map = properties.get(object);
		if (map === undefined) {
			map = {};
			properties.set(object, map);
		}
		return map;
	}
	function remove(object) {
		properties.delete(object);
	}
	function update(object, key, value) {
		properties.get(object)[key] = value;
	}
	function dispose() {
		properties = new WeakMap();
	}
	return {
		get: get,
		remove: remove,
		update: update,
		dispose: dispose
	};
}

function painterSortStable(a, b) {
	if (a.groupOrder !== b.groupOrder) {
		return a.groupOrder - b.groupOrder;
	} else if (a.renderOrder !== b.renderOrder) {
		return a.renderOrder - b.renderOrder;
	} else if (a.material.id !== b.material.id) {
		return a.material.id - b.material.id;
	} else if (a.z !== b.z) {
		return a.z - b.z;
	} else {
		return a.id - b.id;
	}
}
function reversePainterSortStable(a, b) {
	if (a.groupOrder !== b.groupOrder) {
		return a.groupOrder - b.groupOrder;
	} else if (a.renderOrder !== b.renderOrder) {
		return a.renderOrder - b.renderOrder;
	} else if (a.z !== b.z) {
		return b.z - a.z;
	} else {
		return a.id - b.id;
	}
}
function WebGLRenderList() {
	const renderItems = [];
	let renderItemsIndex = 0;
	const opaque = [];
	const transmissive = [];
	const transparent = [];
	function init() {
		renderItemsIndex = 0;
		opaque.length = 0;
		transmissive.length = 0;
		transparent.length = 0;
	}
	function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
		let renderItem = renderItems[renderItemsIndex];
		if (renderItem === undefined) {
			renderItem = {
				id: object.id,
				object: object,
				geometry: geometry,
				material: material,
				groupOrder: groupOrder,
				renderOrder: object.renderOrder,
				z: z,
				group: group
			};
			renderItems[renderItemsIndex] = renderItem;
		} else {
			renderItem.id = object.id;
			renderItem.object = object;
			renderItem.geometry = geometry;
			renderItem.material = material;
			renderItem.groupOrder = groupOrder;
			renderItem.renderOrder = object.renderOrder;
			renderItem.z = z;
			renderItem.group = group;
		}
		renderItemsIndex++;
		return renderItem;
	}
	function push(object, geometry, material, groupOrder, z, group) {
		const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
		if (material.transmission > 0.0) {
			transmissive.push(renderItem);
		} else if (material.transparent === true) {
			transparent.push(renderItem);
		} else {
			opaque.push(renderItem);
		}
	}
	function unshift(object, geometry, material, groupOrder, z, group) {
		const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
		if (material.transmission > 0.0) {
			transmissive.unshift(renderItem);
		} else if (material.transparent === true) {
			transparent.unshift(renderItem);
		} else {
			opaque.unshift(renderItem);
		}
	}
	function sort(customOpaqueSort, customTransparentSort) {
		if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);
		if (transmissive.length > 1) transmissive.sort(customTransparentSort || reversePainterSortStable);
		if (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable);
	}
	function finish() {
		// Clear references from inactive renderItems in the list

		for (let i = renderItemsIndex, il = renderItems.length; i < il; i++) {
			const renderItem = renderItems[i];
			if (renderItem.id === null) break;
			renderItem.id = null;
			renderItem.object = null;
			renderItem.geometry = null;
			renderItem.material = null;
			renderItem.group = null;
		}
	}
	return {
		opaque: opaque,
		transmissive: transmissive,
		transparent: transparent,
		init: init,
		push: push,
		unshift: unshift,
		finish: finish,
		sort: sort
	};
}
function WebGLRenderLists() {
	let lists = new WeakMap();
	function get(scene, renderCallDepth) {
		const listArray = lists.get(scene);
		let list;
		if (listArray === undefined) {
			list = new WebGLRenderList();
			lists.set(scene, [list]);
		} else {
			if (renderCallDepth >= listArray.length) {
				list = new WebGLRenderList();
				listArray.push(list);
			} else {
				list = listArray[renderCallDepth];
			}
		}
		return list;
	}
	function dispose() {
		lists = new WeakMap();
	}
	return {
		get: get,
		dispose: dispose
	};
}

function UniformsCache() {
	const lights = {};
	return {
		get: function (light) {
			if (lights[light.id] !== undefined) {
				return lights[light.id];
			}
			let uniforms;
			switch (light.type) {
				case 'DirectionalLight':
					uniforms = {
						direction: new Vector3(),
						color: new Color()
					};
					break;
				case 'SpotLight':
					uniforms = {
						position: new Vector3(),
						direction: new Vector3(),
						color: new Color(),
						distance: 0,
						coneCos: 0,
						penumbraCos: 0,
						decay: 0
					};
					break;
				case 'PointLight':
					uniforms = {
						position: new Vector3(),
						color: new Color(),
						distance: 0,
						decay: 0
					};
					break;
				case 'HemisphereLight':
					uniforms = {
						direction: new Vector3(),
						skyColor: new Color(),
						groundColor: new Color()
					};
					break;
				case 'RectAreaLight':
					uniforms = {
						color: new Color(),
						position: new Vector3(),
						halfWidth: new Vector3(),
						halfHeight: new Vector3()
					};
					break;
			}
			lights[light.id] = uniforms;
			return uniforms;
		}
	};
}
function ShadowUniformsCache() {
	const lights = {};
	return {
		get: function (light) {
			if (lights[light.id] !== undefined) {
				return lights[light.id];
			}
			let uniforms;
			switch (light.type) {
				case 'DirectionalLight':
					uniforms = {
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2()
					};
					break;
				case 'SpotLight':
					uniforms = {
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2()
					};
					break;
				case 'PointLight':
					uniforms = {
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2(),
						shadowCameraNear: 1,
						shadowCameraFar: 1000
					};
					break;

				// TODO (abelnation): set RectAreaLight shadow uniforms
			}

			lights[light.id] = uniforms;
			return uniforms;
		}
	};
}
let nextVersion = 0;
function shadowCastingAndTexturingLightsFirst(lightA, lightB) {
	return (lightB.castShadow ? 2 : 0) - (lightA.castShadow ? 2 : 0) + (lightB.map ? 1 : 0) - (lightA.map ? 1 : 0);
}
function WebGLLights(extensions, capabilities) {
	const cache = new UniformsCache();
	const shadowCache = ShadowUniformsCache();
	const state = {
		version: 0,
		hash: {
			directionalLength: -1,
			pointLength: -1,
			spotLength: -1,
			rectAreaLength: -1,
			hemiLength: -1,
			numDirectionalShadows: -1,
			numPointShadows: -1,
			numSpotShadows: -1,
			numSpotMaps: -1
		},
		ambient: [0, 0, 0],
		probe: [],
		directional: [],
		directionalShadow: [],
		directionalShadowMap: [],
		directionalShadowMatrix: [],
		spot: [],
		spotLightMap: [],
		spotShadow: [],
		spotShadowMap: [],
		spotLightMatrix: [],
		rectArea: [],
		rectAreaLTC1: null,
		rectAreaLTC2: null,
		point: [],
		pointShadow: [],
		pointShadowMap: [],
		pointShadowMatrix: [],
		hemi: [],
		numSpotLightShadowsWithMaps: 0
	};
	for (let i = 0; i < 9; i++) state.probe.push(new Vector3());
	const vector3 = new Vector3();
	const matrix4 = new Matrix4();
	const matrix42 = new Matrix4();
	function setup(lights, physicallyCorrectLights) {
		let r = 0,
			g = 0,
			b = 0;
		for (let i = 0; i < 9; i++) state.probe[i].set(0, 0, 0);
		let directionalLength = 0;
		let pointLength = 0;
		let spotLength = 0;
		let rectAreaLength = 0;
		let hemiLength = 0;
		let numDirectionalShadows = 0;
		let numPointShadows = 0;
		let numSpotShadows = 0;
		let numSpotMaps = 0;
		let numSpotShadowsWithMaps = 0;

		// ordering : [shadow casting + map texturing, map texturing, shadow casting, none ]
		lights.sort(shadowCastingAndTexturingLightsFirst);

		// artist-friendly light intensity scaling factor
		const scaleFactor = physicallyCorrectLights !== true ? Math.PI : 1;
		for (let i = 0, l = lights.length; i < l; i++) {
			const light = lights[i];
			const color = light.color;
			const intensity = light.intensity;
			const distance = light.distance;
			const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
			if (light.isAmbientLight) {
				r += color.r * intensity * scaleFactor;
				g += color.g * intensity * scaleFactor;
				b += color.b * intensity * scaleFactor;
			} else if (light.isLightProbe) {
				for (let j = 0; j < 9; j++) {
					state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
				}
			} else if (light.isDirectionalLight) {
				const uniforms = cache.get(light);
				uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
				if (light.castShadow) {
					const shadow = light.shadow;
					const shadowUniforms = shadowCache.get(light);
					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowNormalBias = shadow.normalBias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;
					state.directionalShadow[directionalLength] = shadowUniforms;
					state.directionalShadowMap[directionalLength] = shadowMap;
					state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
					numDirectionalShadows++;
				}
				state.directional[directionalLength] = uniforms;
				directionalLength++;
			} else if (light.isSpotLight) {
				const uniforms = cache.get(light);
				uniforms.position.setFromMatrixPosition(light.matrixWorld);
				uniforms.color.copy(color).multiplyScalar(intensity * scaleFactor);
				uniforms.distance = distance;
				uniforms.coneCos = Math.cos(light.angle);
				uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
				uniforms.decay = light.decay;
				state.spot[spotLength] = uniforms;
				const shadow = light.shadow;
				if (light.map) {
					state.spotLightMap[numSpotMaps] = light.map;
					numSpotMaps++;

					// make sure the lightMatrix is up to date
					// TODO : do it if required only
					shadow.updateMatrices(light);
					if (light.castShadow) numSpotShadowsWithMaps++;
				}
				state.spotLightMatrix[spotLength] = shadow.matrix;
				if (light.castShadow) {
					const shadowUniforms = shadowCache.get(light);
					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowNormalBias = shadow.normalBias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;
					state.spotShadow[spotLength] = shadowUniforms;
					state.spotShadowMap[spotLength] = shadowMap;
					numSpotShadows++;
				}
				spotLength++;
			} else if (light.isRectAreaLight) {
				const uniforms = cache.get(light);

				// (a) intensity is the total visible light emitted
				//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );

				// (b) intensity is the brightness of the light
				uniforms.color.copy(color).multiplyScalar(intensity);
				uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
				uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);
				state.rectArea[rectAreaLength] = uniforms;
				rectAreaLength++;
			} else if (light.isPointLight) {
				const uniforms = cache.get(light);
				uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
				uniforms.distance = light.distance;
				uniforms.decay = light.decay;
				if (light.castShadow) {
					const shadow = light.shadow;
					const shadowUniforms = shadowCache.get(light);
					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowNormalBias = shadow.normalBias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;
					shadowUniforms.shadowCameraNear = shadow.camera.near;
					shadowUniforms.shadowCameraFar = shadow.camera.far;
					state.pointShadow[pointLength] = shadowUniforms;
					state.pointShadowMap[pointLength] = shadowMap;
					state.pointShadowMatrix[pointLength] = light.shadow.matrix;
					numPointShadows++;
				}
				state.point[pointLength] = uniforms;
				pointLength++;
			} else if (light.isHemisphereLight) {
				const uniforms = cache.get(light);
				uniforms.skyColor.copy(light.color).multiplyScalar(intensity * scaleFactor);
				uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity * scaleFactor);
				state.hemi[hemiLength] = uniforms;
				hemiLength++;
			}
		}
		if (rectAreaLength > 0) {
			if (capabilities.isWebGL2) {
				// WebGL 2

				state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
				state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
			} else {
				// WebGL 1

				if (extensions.has('OES_texture_float_linear') === true) {
					state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
					state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
				} else if (extensions.has('OES_texture_half_float_linear') === true) {
					state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
					state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
				} else {
					console.error('THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.');
				}
			}
		}
		state.ambient[0] = r;
		state.ambient[1] = g;
		state.ambient[2] = b;
		const hash = state.hash;
		if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows || hash.numSpotMaps !== numSpotMaps) {
			state.directional.length = directionalLength;
			state.spot.length = spotLength;
			state.rectArea.length = rectAreaLength;
			state.point.length = pointLength;
			state.hemi.length = hemiLength;
			state.directionalShadow.length = numDirectionalShadows;
			state.directionalShadowMap.length = numDirectionalShadows;
			state.pointShadow.length = numPointShadows;
			state.pointShadowMap.length = numPointShadows;
			state.spotShadow.length = numSpotShadows;
			state.spotShadowMap.length = numSpotShadows;
			state.directionalShadowMatrix.length = numDirectionalShadows;
			state.pointShadowMatrix.length = numPointShadows;
			state.spotLightMatrix.length = numSpotShadows + numSpotMaps - numSpotShadowsWithMaps;
			state.spotLightMap.length = numSpotMaps;
			state.numSpotLightShadowsWithMaps = numSpotShadowsWithMaps;
			hash.directionalLength = directionalLength;
			hash.pointLength = pointLength;
			hash.spotLength = spotLength;
			hash.rectAreaLength = rectAreaLength;
			hash.hemiLength = hemiLength;
			hash.numDirectionalShadows = numDirectionalShadows;
			hash.numPointShadows = numPointShadows;
			hash.numSpotShadows = numSpotShadows;
			hash.numSpotMaps = numSpotMaps;
			state.version = nextVersion++;
		}
	}
	function setupView(lights, camera) {
		let directionalLength = 0;
		let pointLength = 0;
		let spotLength = 0;
		let rectAreaLength = 0;
		let hemiLength = 0;
		const viewMatrix = camera.matrixWorldInverse;
		for (let i = 0, l = lights.length; i < l; i++) {
			const light = lights[i];
			if (light.isDirectionalLight) {
				const uniforms = state.directional[directionalLength];
				uniforms.direction.setFromMatrixPosition(light.matrixWorld);
				vector3.setFromMatrixPosition(light.target.matrixWorld);
				uniforms.direction.sub(vector3);
				uniforms.direction.transformDirection(viewMatrix);
				directionalLength++;
			} else if (light.isSpotLight) {
				const uniforms = state.spot[spotLength];
				uniforms.position.setFromMatrixPosition(light.matrixWorld);
				uniforms.position.applyMatrix4(viewMatrix);
				uniforms.direction.setFromMatrixPosition(light.matrixWorld);
				vector3.setFromMatrixPosition(light.target.matrixWorld);
				uniforms.direction.sub(vector3);
				uniforms.direction.transformDirection(viewMatrix);
				spotLength++;
			} else if (light.isRectAreaLight) {
				const uniforms = state.rectArea[rectAreaLength];
				uniforms.position.setFromMatrixPosition(light.matrixWorld);
				uniforms.position.applyMatrix4(viewMatrix);

				// extract local rotation of light to derive width/height half vectors
				matrix42.identity();
				matrix4.copy(light.matrixWorld);
				matrix4.premultiply(viewMatrix);
				matrix42.extractRotation(matrix4);
				uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
				uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);
				uniforms.halfWidth.applyMatrix4(matrix42);
				uniforms.halfHeight.applyMatrix4(matrix42);
				rectAreaLength++;
			} else if (light.isPointLight) {
				const uniforms = state.point[pointLength];
				uniforms.position.setFromMatrixPosition(light.matrixWorld);
				uniforms.position.applyMatrix4(viewMatrix);
				pointLength++;
			} else if (light.isHemisphereLight) {
				const uniforms = state.hemi[hemiLength];
				uniforms.direction.setFromMatrixPosition(light.matrixWorld);
				uniforms.direction.transformDirection(viewMatrix);
				hemiLength++;
			}
		}
	}
	return {
		setup: setup,
		setupView: setupView,
		state: state
	};
}

function WebGLRenderState(extensions, capabilities) {
	const lights = new WebGLLights(extensions, capabilities);
	const lightsArray = [];
	const shadowsArray = [];
	function init() {
		lightsArray.length = 0;
		shadowsArray.length = 0;
	}
	function pushLight(light) {
		lightsArray.push(light);
	}
	function pushShadow(shadowLight) {
		shadowsArray.push(shadowLight);
	}
	function setupLights(physicallyCorrectLights) {
		lights.setup(lightsArray, physicallyCorrectLights);
	}
	function setupLightsView(camera) {
		lights.setupView(lightsArray, camera);
	}
	const state = {
		lightsArray: lightsArray,
		shadowsArray: shadowsArray,
		lights: lights
	};
	return {
		init: init,
		state: state,
		setupLights: setupLights,
		setupLightsView: setupLightsView,
		pushLight: pushLight,
		pushShadow: pushShadow
	};
}
function WebGLRenderStates(extensions, capabilities) {
	let renderStates = new WeakMap();
	function get(scene, renderCallDepth = 0) {
		const renderStateArray = renderStates.get(scene);
		let renderState;
		if (renderStateArray === undefined) {
			renderState = new WebGLRenderState(extensions, capabilities);
			renderStates.set(scene, [renderState]);
		} else {
			if (renderCallDepth >= renderStateArray.length) {
				renderState = new WebGLRenderState(extensions, capabilities);
				renderStateArray.push(renderState);
			} else {
				renderState = renderStateArray[renderCallDepth];
			}
		}
		return renderState;
	}
	function dispose() {
		renderStates = new WeakMap();
	}
	return {
		get: get,
		dispose: dispose
	};
}

class MeshDepthMaterial extends Material {
	constructor(parameters) {
		super();
		this.isMeshDepthMaterial = true;
		this.type = 'MeshDepthMaterial';
		this.depthPacking = BasicDepthPacking;
		this.map = null;
		this.alphaMap = null;
		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.setValues(parameters);
	}
	copy(source) {
		super.copy(source);
		this.depthPacking = source.depthPacking;
		this.map = source.map;
		this.alphaMap = source.alphaMap;
		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		return this;
	}
}

class MeshDistanceMaterial extends Material {
	constructor(parameters) {
		super();
		this.isMeshDistanceMaterial = true;
		this.type = 'MeshDistanceMaterial';
		this.referencePosition = new Vector3();
		this.nearDistance = 1;
		this.farDistance = 1000;
		this.map = null;
		this.alphaMap = null;
		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
		this.setValues(parameters);
	}
	copy(source) {
		super.copy(source);
		this.referencePosition.copy(source.referencePosition);
		this.nearDistance = source.nearDistance;
		this.farDistance = source.farDistance;
		this.map = source.map;
		this.alphaMap = source.alphaMap;
		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
		return this;
	}
}

const vertex = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";
const fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";

function WebGLShadowMap(_renderer, _objects, _capabilities) {
	let _frustum = new Frustum();
	const _shadowMapSize = new Vector2(),
		_viewportSize = new Vector2(),
		_viewport = new Vector4(),
		_depthMaterial = new MeshDepthMaterial({
			depthPacking: RGBADepthPacking
		}),
		_distanceMaterial = new MeshDistanceMaterial(),
		_materialCache = {},
		_maxTextureSize = _capabilities.maxTextureSize;
	const shadowSide = {
		0: BackSide,
		1: FrontSide,
		2: DoubleSide
	};
	const shadowMaterialVertical = new ShaderMaterial({
		defines: {
			VSM_SAMPLES: 8
		},
		uniforms: {
			shadow_pass: {
				value: null
			},
			resolution: {
				value: new Vector2()
			},
			radius: {
				value: 4.0
			}
		},
		vertexShader: vertex,
		fragmentShader: fragment
	});
	const shadowMaterialHorizontal = shadowMaterialVertical.clone();
	shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
	const fullScreenTri = new BufferGeometry();
	fullScreenTri.setAttribute('position', new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
	const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
	const scope = this;
	this.enabled = false;
	this.autoUpdate = true;
	this.needsUpdate = false;
	this.type = PCFShadowMap;
	this.render = function (lights, scene, camera) {
		if (scope.enabled === false) return;
		if (scope.autoUpdate === false && scope.needsUpdate === false) return;
		if (lights.length === 0) return;
		const currentRenderTarget = _renderer.getRenderTarget();
		const activeCubeFace = _renderer.getActiveCubeFace();
		const activeMipmapLevel = _renderer.getActiveMipmapLevel();
		const _state = _renderer.state;

		// Set GL state for depth map.
		_state.setBlending(NoBlending);
		_state.buffers.color.setClear(1, 1, 1, 1);
		_state.buffers.depth.setTest(true);
		_state.setScissorTest(false);

		// render depth map

		for (let i = 0, il = lights.length; i < il; i++) {
			const light = lights[i];
			const shadow = light.shadow;
			if (shadow === undefined) {
				console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
				continue;
			}
			if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;
			_shadowMapSize.copy(shadow.mapSize);
			const shadowFrameExtents = shadow.getFrameExtents();
			_shadowMapSize.multiply(shadowFrameExtents);
			_viewportSize.copy(shadow.mapSize);
			if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
				if (_shadowMapSize.x > _maxTextureSize) {
					_viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
					_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
					shadow.mapSize.x = _viewportSize.x;
				}
				if (_shadowMapSize.y > _maxTextureSize) {
					_viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
					_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
					shadow.mapSize.y = _viewportSize.y;
				}
			}
			if (shadow.map === null) {
				const pars = this.type !== VSMShadowMap ? {
					minFilter: NearestFilter,
					magFilter: NearestFilter
				} : {};
				shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
				shadow.map.texture.name = light.name + '.shadowMap';
				shadow.camera.updateProjectionMatrix();
			}
			_renderer.setRenderTarget(shadow.map);
			_renderer.clear();
			const viewportCount = shadow.getViewportCount();
			for (let vp = 0; vp < viewportCount; vp++) {
				const viewport = shadow.getViewport(vp);
				_viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);
				_state.viewport(_viewport);
				shadow.updateMatrices(light, vp);
				_frustum = shadow.getFrustum();
				renderObject(scene, camera, shadow.camera, light, this.type);
			}

			// do blur pass for VSM

			if (shadow.isPointLightShadow !== true && this.type === VSMShadowMap) {
				VSMPass(shadow, camera);
			}
			shadow.needsUpdate = false;
		}
		scope.needsUpdate = false;
		_renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
	};
	function VSMPass(shadow, camera) {
		const geometry = _objects.update(fullScreenMesh);
		if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples) {
			shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
			shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;
			shadowMaterialVertical.needsUpdate = true;
			shadowMaterialHorizontal.needsUpdate = true;
		}
		if (shadow.mapPass === null) {
			shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y);
		}

		// vertical pass

		shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
		shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
		shadowMaterialVertical.uniforms.radius.value = shadow.radius;
		_renderer.setRenderTarget(shadow.mapPass);
		_renderer.clear();
		_renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);

		// horizontal pass

		shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
		shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
		shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
		_renderer.setRenderTarget(shadow.map);
		_renderer.clear();
		_renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
	}
	function getDepthMaterial(object, material, light, shadowCameraNear, shadowCameraFar, type) {
		let result = null;
		const customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;
		if (customMaterial !== undefined) {
			result = customMaterial;
		} else {
			result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;
		}
		if (_renderer.localClippingEnabled && material.clipShadows === true && Array.isArray(material.clippingPlanes) && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0) {
			// in this case we need a unique material instance reflecting the
			// appropriate state

			const keyA = result.uuid,
				keyB = material.uuid;
			let materialsForVariant = _materialCache[keyA];
			if (materialsForVariant === undefined) {
				materialsForVariant = {};
				_materialCache[keyA] = materialsForVariant;
			}
			let cachedMaterial = materialsForVariant[keyB];
			if (cachedMaterial === undefined) {
				cachedMaterial = result.clone();
				materialsForVariant[keyB] = cachedMaterial;
			}
			result = cachedMaterial;
		}
		result.visible = material.visible;
		result.wireframe = material.wireframe;
		if (type === VSMShadowMap) {
			result.side = material.shadowSide !== null ? material.shadowSide : material.side;
		} else {
			result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
		}
		result.alphaMap = material.alphaMap;
		result.alphaTest = material.alphaTest;
		result.clipShadows = material.clipShadows;
		result.clippingPlanes = material.clippingPlanes;
		result.clipIntersection = material.clipIntersection;
		result.displacementMap = material.displacementMap;
		result.displacementScale = material.displacementScale;
		result.displacementBias = material.displacementBias;
		result.wireframeLinewidth = material.wireframeLinewidth;
		result.linewidth = material.linewidth;
		if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
			result.referencePosition.setFromMatrixPosition(light.matrixWorld);
			result.nearDistance = shadowCameraNear;
			result.farDistance = shadowCameraFar;
		}
		return result;
	}
	function renderObject(object, camera, shadowCamera, light, type) {
		if (object.visible === false) return;
		const visible = object.layers.test(camera.layers);
		if (visible && (object.isMesh || object.isLine || object.isPoints)) {
			if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
				object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
				const geometry = _objects.update(object);
				const material = object.material;
				if (Array.isArray(material)) {
					const groups = geometry.groups;
					for (let k = 0, kl = groups.length; k < kl; k++) {
						const group = groups[k];
						const groupMaterial = material[group.materialIndex];
						if (groupMaterial && groupMaterial.visible) {
							const depthMaterial = getDepthMaterial(object, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);
							_renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
						}
					}
				} else if (material.visible) {
					const depthMaterial = getDepthMaterial(object, material, light, shadowCamera.near, shadowCamera.far, type);
					_renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
				}
			}
		}
		const children = object.children;
		for (let i = 0, l = children.length; i < l; i++) {
			renderObject(children[i], camera, shadowCamera, light, type);
		}
	}
}

function WebGLState(gl, extensions, capabilities) {
	const isWebGL2 = capabilities.isWebGL2;
	function ColorBuffer() {
		let locked = false;
		const color = new Vector4();
		let currentColorMask = null;
		const currentColorClear = new Vector4(0, 0, 0, 0);
		return {
			setMask: function (colorMask) {
				if (currentColorMask !== colorMask && !locked) {
					gl.colorMask(colorMask, colorMask, colorMask, colorMask);
					currentColorMask = colorMask;
				}
			},
			setLocked: function (lock) {
				locked = lock;
			},
			setClear: function (r, g, b, a, premultipliedAlpha) {
				if (premultipliedAlpha === true) {
					r *= a;
					g *= a;
					b *= a;
				}
				color.set(r, g, b, a);
				if (currentColorClear.equals(color) === false) {
					gl.clearColor(r, g, b, a);
					currentColorClear.copy(color);
				}
			},
			reset: function () {
				locked = false;
				currentColorMask = null;
				currentColorClear.set(-1, 0, 0, 0); // set to invalid state
			}
		};
	}

	function DepthBuffer() {
		let locked = false;
		let currentDepthMask = null;
		let currentDepthFunc = null;
		let currentDepthClear = null;
		return {
			setTest: function (depthTest) {
				if (depthTest) {
					enable(gl.DEPTH_TEST);
				} else {
					disable(gl.DEPTH_TEST);
				}
			},
			setMask: function (depthMask) {
				if (currentDepthMask !== depthMask && !locked) {
					gl.depthMask(depthMask);
					currentDepthMask = depthMask;
				}
			},
			setFunc: function (depthFunc) {
				if (currentDepthFunc !== depthFunc) {
					switch (depthFunc) {
						case NeverDepth:
							gl.depthFunc(gl.NEVER);
							break;
						case AlwaysDepth:
							gl.depthFunc(gl.ALWAYS);
							break;
						case LessDepth:
							gl.depthFunc(gl.LESS);
							break;
						case LessEqualDepth:
							gl.depthFunc(gl.LEQUAL);
							break;
						case EqualDepth:
							gl.depthFunc(gl.EQUAL);
							break;
						case GreaterEqualDepth:
							gl.depthFunc(gl.GEQUAL);
							break;
						case GreaterDepth:
							gl.depthFunc(gl.GREATER);
							break;
						case NotEqualDepth:
							gl.depthFunc(gl.NOTEQUAL);
							break;
						default:
							gl.depthFunc(gl.LEQUAL);
					}
					currentDepthFunc = depthFunc;
				}
			},
			setLocked: function (lock) {
				locked = lock;
			},
			setClear: function (depth) {
				if (currentDepthClear !== depth) {
					gl.clearDepth(depth);
					currentDepthClear = depth;
				}
			},
			reset: function () {
				locked = false;
				currentDepthMask = null;
				currentDepthFunc = null;
				currentDepthClear = null;
			}
		};
	}
	function StencilBuffer() {
		let locked = false;
		let currentStencilMask = null;
		let currentStencilFunc = null;
		let currentStencilRef = null;
		let currentStencilFuncMask = null;
		let currentStencilFail = null;
		let currentStencilZFail = null;
		let currentStencilZPass = null;
		let currentStencilClear = null;
		return {
			setTest: function (stencilTest) {
				if (!locked) {
					if (stencilTest) {
						enable(gl.STENCIL_TEST);
					} else {
						disable(gl.STENCIL_TEST);
					}
				}
			},
			setMask: function (stencilMask) {
				if (currentStencilMask !== stencilMask && !locked) {
					gl.stencilMask(stencilMask);
					currentStencilMask = stencilMask;
				}
			},
			setFunc: function (stencilFunc, stencilRef, stencilMask) {
				if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
					gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
					currentStencilFunc = stencilFunc;
					currentStencilRef = stencilRef;
					currentStencilFuncMask = stencilMask;
				}
			},
			setOp: function (stencilFail, stencilZFail, stencilZPass) {
				if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
					gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
					currentStencilFail = stencilFail;
					currentStencilZFail = stencilZFail;
					currentStencilZPass = stencilZPass;
				}
			},
			setLocked: function (lock) {
				locked = lock;
			},
			setClear: function (stencil) {
				if (currentStencilClear !== stencil) {
					gl.clearStencil(stencil);
					currentStencilClear = stencil;
				}
			},
			reset: function () {
				locked = false;
				currentStencilMask = null;
				currentStencilFunc = null;
				currentStencilRef = null;
				currentStencilFuncMask = null;
				currentStencilFail = null;
				currentStencilZFail = null;
				currentStencilZPass = null;
				currentStencilClear = null;
			}
		};
	}

	//

	const colorBuffer = new ColorBuffer();
	const depthBuffer = new DepthBuffer();
	const stencilBuffer = new StencilBuffer();
	const uboBindings = new WeakMap();
	const uboProgamMap = new WeakMap();
	let enabledCapabilities = {};
	let currentBoundFramebuffers = {};
	let currentDrawbuffers = new WeakMap();
	let defaultDrawbuffers = [];
	let currentProgram = null;
	let currentBlendingEnabled = false;
	let currentBlending = null;
	let currentBlendEquation = null;
	let currentBlendSrc = null;
	let currentBlendDst = null;
	let currentBlendEquationAlpha = null;
	let currentBlendSrcAlpha = null;
	let currentBlendDstAlpha = null;
	let currentPremultipledAlpha = false;
	let currentFlipSided = null;
	let currentCullFace = null;
	let currentLineWidth = null;
	let currentPolygonOffsetFactor = null;
	let currentPolygonOffsetUnits = null;
	const maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
	let lineWidthAvailable = false;
	let version = 0;
	const glVersion = gl.getParameter(gl.VERSION);
	if (glVersion.indexOf('WebGL') !== -1) {
		version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
		lineWidthAvailable = version >= 1.0;
	} else if (glVersion.indexOf('OpenGL ES') !== -1) {
		version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
		lineWidthAvailable = version >= 2.0;
	}
	let currentTextureSlot = null;
	let currentBoundTextures = {};
	const scissorParam = gl.getParameter(gl.SCISSOR_BOX);
	const viewportParam = gl.getParameter(gl.VIEWPORT);
	const currentScissor = new Vector4().fromArray(scissorParam);
	const currentViewport = new Vector4().fromArray(viewportParam);
	function createTexture(type, target, count) {
		const data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.
		const texture = gl.createTexture();
		gl.bindTexture(type, texture);
		gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
		gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
		for (let i = 0; i < count; i++) {
			gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
		}
		return texture;
	}
	const emptyTextures = {};
	emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
	emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6);

	// init

	colorBuffer.setClear(0, 0, 0, 1);
	depthBuffer.setClear(1);
	stencilBuffer.setClear(0);
	enable(gl.DEPTH_TEST);
	depthBuffer.setFunc(LessEqualDepth);
	setFlipSided(false);
	setCullFace(CullFaceBack);
	enable(gl.CULL_FACE);
	setBlending(NoBlending);

	//

	function enable(id) {
		if (enabledCapabilities[id] !== true) {
			gl.enable(id);
			enabledCapabilities[id] = true;
		}
	}
	function disable(id) {
		if (enabledCapabilities[id] !== false) {
			gl.disable(id);
			enabledCapabilities[id] = false;
		}
	}
	function bindFramebuffer(target, framebuffer) {
		if (currentBoundFramebuffers[target] !== framebuffer) {
			gl.bindFramebuffer(target, framebuffer);
			currentBoundFramebuffers[target] = framebuffer;
			if (isWebGL2) {
				// gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER

				if (target === gl.DRAW_FRAMEBUFFER) {
					currentBoundFramebuffers[gl.FRAMEBUFFER] = framebuffer;
				}
				if (target === gl.FRAMEBUFFER) {
					currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer;
				}
			}
			return true;
		}
		return false;
	}
	function drawBuffers(renderTarget, framebuffer) {
		let drawBuffers = defaultDrawbuffers;
		let needsUpdate = false;
		if (renderTarget) {
			drawBuffers = currentDrawbuffers.get(framebuffer);
			if (drawBuffers === undefined) {
				drawBuffers = [];
				currentDrawbuffers.set(framebuffer, drawBuffers);
			}
			if (renderTarget.isWebGLMultipleRenderTargets) {
				const textures = renderTarget.texture;
				if (drawBuffers.length !== textures.length || drawBuffers[0] !== gl.COLOR_ATTACHMENT0) {
					for (let i = 0, il = textures.length; i < il; i++) {
						drawBuffers[i] = gl.COLOR_ATTACHMENT0 + i;
					}
					drawBuffers.length = textures.length;
					needsUpdate = true;
				}
			} else {
				if (drawBuffers[0] !== gl.COLOR_ATTACHMENT0) {
					drawBuffers[0] = gl.COLOR_ATTACHMENT0;
					needsUpdate = true;
				}
			}
		} else {
			if (drawBuffers[0] !== gl.BACK) {
				drawBuffers[0] = gl.BACK;
				needsUpdate = true;
			}
		}
		if (needsUpdate) {
			if (capabilities.isWebGL2) {
				gl.drawBuffers(drawBuffers);
			} else {
				extensions.get('WEBGL_draw_buffers').drawBuffersWEBGL(drawBuffers);
			}
		}
	}
	function useProgram(program) {
		if (currentProgram !== program) {
			gl.useProgram(program);
			currentProgram = program;
			return true;
		}
		return false;
	}
	const equationToGL = {
		[AddEquation]: gl.FUNC_ADD,
		[SubtractEquation]: gl.FUNC_SUBTRACT,
		[ReverseSubtractEquation]: gl.FUNC_REVERSE_SUBTRACT
	};
	if (isWebGL2) {
		equationToGL[MinEquation] = gl.MIN;
		equationToGL[MaxEquation] = gl.MAX;
	} else {
		const extension = extensions.get('EXT_blend_minmax');
		if (extension !== null) {
			equationToGL[MinEquation] = extension.MIN_EXT;
			equationToGL[MaxEquation] = extension.MAX_EXT;
		}
	}
	const factorToGL = {
		[ZeroFactor]: gl.ZERO,
		[OneFactor]: gl.ONE,
		[SrcColorFactor]: gl.SRC_COLOR,
		[SrcAlphaFactor]: gl.SRC_ALPHA,
		[SrcAlphaSaturateFactor]: gl.SRC_ALPHA_SATURATE,
		[DstColorFactor]: gl.DST_COLOR,
		[DstAlphaFactor]: gl.DST_ALPHA,
		[OneMinusSrcColorFactor]: gl.ONE_MINUS_SRC_COLOR,
		[OneMinusSrcAlphaFactor]: gl.ONE_MINUS_SRC_ALPHA,
		[OneMinusDstColorFactor]: gl.ONE_MINUS_DST_COLOR,
		[OneMinusDstAlphaFactor]: gl.ONE_MINUS_DST_ALPHA
	};
	function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
		if (blending === NoBlending) {
			if (currentBlendingEnabled === true) {
				disable(gl.BLEND);
				currentBlendingEnabled = false;
			}
			return;
		}
		if (currentBlendingEnabled === false) {
			enable(gl.BLEND);
			currentBlendingEnabled = true;
		}
		if (blending !== CustomBlending) {
			if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
				if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
					gl.blendEquation(gl.FUNC_ADD);
					currentBlendEquation = AddEquation;
					currentBlendEquationAlpha = AddEquation;
				}
				if (premultipliedAlpha) {
					switch (blending) {
						case NormalBlending:
							gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
							break;
						case AdditiveBlending:
							gl.blendFunc(gl.ONE, gl.ONE);
							break;
						case SubtractiveBlending:
							gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
							break;
						case MultiplyBlending:
							gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
							break;
						default:
							console.error('THREE.WebGLState: Invalid blending: ', blending);
							break;
					}
				} else {
					switch (blending) {
						case NormalBlending:
							gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
							break;
						case AdditiveBlending:
							gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
							break;
						case SubtractiveBlending:
							gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
							break;
						case MultiplyBlending:
							gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
							break;
						default:
							console.error('THREE.WebGLState: Invalid blending: ', blending);
							break;
					}
				}
				currentBlendSrc = null;
				currentBlendDst = null;
				currentBlendSrcAlpha = null;
				currentBlendDstAlpha = null;
				currentBlending = blending;
				currentPremultipledAlpha = premultipliedAlpha;
			}
			return;
		}

		// custom blending

		blendEquationAlpha = blendEquationAlpha || blendEquation;
		blendSrcAlpha = blendSrcAlpha || blendSrc;
		blendDstAlpha = blendDstAlpha || blendDst;
		if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
			gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
			currentBlendEquation = blendEquation;
			currentBlendEquationAlpha = blendEquationAlpha;
		}
		if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
			gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
			currentBlendSrc = blendSrc;
			currentBlendDst = blendDst;
			currentBlendSrcAlpha = blendSrcAlpha;
			currentBlendDstAlpha = blendDstAlpha;
		}
		currentBlending = blending;
		currentPremultipledAlpha = null;
	}
	function setMaterial(material, frontFaceCW) {
		material.side === DoubleSide ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);
		let flipSided = material.side === BackSide;
		if (frontFaceCW) flipSided = !flipSided;
		setFlipSided(flipSided);
		material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
		depthBuffer.setFunc(material.depthFunc);
		depthBuffer.setTest(material.depthTest);
		depthBuffer.setMask(material.depthWrite);
		colorBuffer.setMask(material.colorWrite);
		const stencilWrite = material.stencilWrite;
		stencilBuffer.setTest(stencilWrite);
		if (stencilWrite) {
			stencilBuffer.setMask(material.stencilWriteMask);
			stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
			stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
		}
		setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
		material.alphaToCoverage === true ? enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
	}

	//

	function setFlipSided(flipSided) {
		if (currentFlipSided !== flipSided) {
			if (flipSided) {
				gl.frontFace(gl.CW);
			} else {
				gl.frontFace(gl.CCW);
			}
			currentFlipSided = flipSided;
		}
	}
	function setCullFace(cullFace) {
		if (cullFace !== CullFaceNone) {
			enable(gl.CULL_FACE);
			if (cullFace !== currentCullFace) {
				if (cullFace === CullFaceBack) {
					gl.cullFace(gl.BACK);
				} else if (cullFace === CullFaceFront) {
					gl.cullFace(gl.FRONT);
				} else {
					gl.cullFace(gl.FRONT_AND_BACK);
				}
			}
		} else {
			disable(gl.CULL_FACE);
		}
		currentCullFace = cullFace;
	}
	function setLineWidth(width) {
		if (width !== currentLineWidth) {
			if (lineWidthAvailable) gl.lineWidth(width);
			currentLineWidth = width;
		}
	}
	function setPolygonOffset(polygonOffset, factor, units) {
		if (polygonOffset) {
			enable(gl.POLYGON_OFFSET_FILL);
			if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
				gl.polygonOffset(factor, units);
				currentPolygonOffsetFactor = factor;
				currentPolygonOffsetUnits = units;
			}
		} else {
			disable(gl.POLYGON_OFFSET_FILL);
		}
	}
	function setScissorTest(scissorTest) {
		if (scissorTest) {
			enable(gl.SCISSOR_TEST);
		} else {
			disable(gl.SCISSOR_TEST);
		}
	}

	// texture

	function activeTexture(webglSlot) {
		if (webglSlot === undefined) webglSlot = gl.TEXTURE0 + maxTextures - 1;
		if (currentTextureSlot !== webglSlot) {
			gl.activeTexture(webglSlot);
			currentTextureSlot = webglSlot;
		}
	}
	function bindTexture(webglType, webglTexture, webglSlot) {
		if (webglSlot === undefined) {
			if (currentTextureSlot === null) {
				webglSlot = gl.TEXTURE0 + maxTextures - 1;
			} else {
				webglSlot = currentTextureSlot;
			}
		}
		let boundTexture = currentBoundTextures[webglSlot];
		if (boundTexture === undefined) {
			boundTexture = {
				type: undefined,
				texture: undefined
			};
			currentBoundTextures[webglSlot] = boundTexture;
		}
		if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
			if (currentTextureSlot !== webglSlot) {
				gl.activeTexture(webglSlot);
				currentTextureSlot = webglSlot;
			}
			gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
			boundTexture.type = webglType;
			boundTexture.texture = webglTexture;
		}
	}
	function unbindTexture() {
		const boundTexture = currentBoundTextures[currentTextureSlot];
		if (boundTexture !== undefined && boundTexture.type !== undefined) {
			gl.bindTexture(boundTexture.type, null);
			boundTexture.type = undefined;
			boundTexture.texture = undefined;
		}
	}
	function compressedTexImage2D() {
		try {
			gl.compressedTexImage2D.apply(gl, arguments);
		} catch (error) {
			console.error('THREE.WebGLState:', error);
		}
	}
	function compressedTexImage3D() {
		try {
			gl.compressedTexImage3D.apply(gl, arguments);
		} catch (error) {
			console.error('THREE.WebGLState:', error);
		}
	}
	function texSubImage2D() {
		try {
			gl.texSubImage2D.apply(gl, arguments);
		} catch (error) {
			console.error('THREE.WebGLState:', error);
		}
	}
	function texSubImage3D() {
		try {
			gl.texSubImage3D.apply(gl, arguments);
		} catch (error) {
			console.error('THREE.WebGLState:', error);
		}
	}
	function compressedTexSubImage2D() {
		try {
			gl.compressedTexSubImage2D.apply(gl, arguments);
		} catch (error) {
			console.error('THREE.WebGLState:', error);
		}
	}
	function compressedTexSubImage3D() {
		try {
			gl.compressedTexSubImage3D.apply(gl, arguments);
		} catch (error) {
			console.error('THREE.WebGLState:', error);
		}
	}
	function texStorage2D() {
		try {
			gl.texStorage2D.apply(gl, arguments);
		} catch (error) {
			console.error('THREE.WebGLState:', error);
		}
	}
	function texStorage3D() {
		try {
			gl.texStorage3D.apply(gl, arguments);
		} catch (error) {
			console.error('THREE.WebGLState:', error);
		}
	}
	function texImage2D() {
		try {
			gl.texImage2D.apply(gl, arguments);
		} catch (error) {
			console.error('THREE.WebGLState:', error);
		}
	}
	function texImage3D() {
		try {
			gl.texImage3D.apply(gl, arguments);
		} catch (error) {
			console.error('THREE.WebGLState:', error);
		}
	}

	//

	function scissor(scissor) {
		if (currentScissor.equals(scissor) === false) {
			gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
			currentScissor.copy(scissor);
		}
	}
	function viewport(viewport) {
		if (currentViewport.equals(viewport) === false) {
			gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
			currentViewport.copy(viewport);
		}
	}
	function updateUBOMapping(uniformsGroup, program) {
		let mapping = uboProgamMap.get(program);
		if (mapping === undefined) {
			mapping = new WeakMap();
			uboProgamMap.set(program, mapping);
		}
		let blockIndex = mapping.get(uniformsGroup);
		if (blockIndex === undefined) {
			blockIndex = gl.getUniformBlockIndex(program, uniformsGroup.name);
			mapping.set(uniformsGroup, blockIndex);
		}
	}
	function uniformBlockBinding(uniformsGroup, program) {
		const mapping = uboProgamMap.get(program);
		const blockIndex = mapping.get(uniformsGroup);
		if (uboBindings.get(uniformsGroup) !== blockIndex) {
			// bind shader specific block index to global block point

			gl.uniformBlockBinding(program, blockIndex, uniformsGroup.__bindingPointIndex);
			uboBindings.set(uniformsGroup, blockIndex);
		}
	}

	//

	function reset() {
		// reset state

		gl.disable(gl.BLEND);
		gl.disable(gl.CULL_FACE);
		gl.disable(gl.DEPTH_TEST);
		gl.disable(gl.POLYGON_OFFSET_FILL);
		gl.disable(gl.SCISSOR_TEST);
		gl.disable(gl.STENCIL_TEST);
		gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
		gl.blendEquation(gl.FUNC_ADD);
		gl.blendFunc(gl.ONE, gl.ZERO);
		gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
		gl.colorMask(true, true, true, true);
		gl.clearColor(0, 0, 0, 0);
		gl.depthMask(true);
		gl.depthFunc(gl.LESS);
		gl.clearDepth(1);
		gl.stencilMask(0xffffffff);
		gl.stencilFunc(gl.ALWAYS, 0, 0xffffffff);
		gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
		gl.clearStencil(0);
		gl.cullFace(gl.BACK);
		gl.frontFace(gl.CCW);
		gl.polygonOffset(0, 0);
		gl.activeTexture(gl.TEXTURE0);
		gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		if (isWebGL2 === true) {
			gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
			gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
		}
		gl.useProgram(null);
		gl.lineWidth(1);
		gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
		gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

		// reset internals

		enabledCapabilities = {};
		currentTextureSlot = null;
		currentBoundTextures = {};
		currentBoundFramebuffers = {};
		currentDrawbuffers = new WeakMap();
		defaultDrawbuffers = [];
		currentProgram = null;
		currentBlendingEnabled = false;
		currentBlending = null;
		currentBlendEquation = null;
		currentBlendSrc = null;
		currentBlendDst = null;
		currentBlendEquationAlpha = null;
		currentBlendSrcAlpha = null;
		currentBlendDstAlpha = null;
		currentPremultipledAlpha = false;
		currentFlipSided = null;
		currentCullFace = null;
		currentLineWidth = null;
		currentPolygonOffsetFactor = null;
		currentPolygonOffsetUnits = null;
		currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
		currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
		colorBuffer.reset();
		depthBuffer.reset();
		stencilBuffer.reset();
	}
	return {
		buffers: {
			color: colorBuffer,
			depth: depthBuffer,
			stencil: stencilBuffer
		},
		enable: enable,
		disable: disable,
		bindFramebuffer: bindFramebuffer,
		drawBuffers: drawBuffers,
		useProgram: useProgram,
		setBlending: setBlending,
		setMaterial: setMaterial,
		setFlipSided: setFlipSided,
		setCullFace: setCullFace,
		setLineWidth: setLineWidth,
		setPolygonOffset: setPolygonOffset,
		setScissorTest: setScissorTest,
		activeTexture: activeTexture,
		bindTexture: bindTexture,
		unbindTexture: unbindTexture,
		compressedTexImage2D: compressedTexImage2D,
		compressedTexImage3D: compressedTexImage3D,
		texImage2D: texImage2D,
		texImage3D: texImage3D,
		updateUBOMapping: updateUBOMapping,
		uniformBlockBinding: uniformBlockBinding,
		texStorage2D: texStorage2D,
		texStorage3D: texStorage3D,
		texSubImage2D: texSubImage2D,
		texSubImage3D: texSubImage3D,
		compressedTexSubImage2D: compressedTexSubImage2D,
		compressedTexSubImage3D: compressedTexSubImage3D,
		scissor: scissor,
		viewport: viewport,
		reset: reset
	};
}

function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
	const isWebGL2 = capabilities.isWebGL2;
	const maxTextures = capabilities.maxTextures;
	const maxCubemapSize = capabilities.maxCubemapSize;
	const maxTextureSize = capabilities.maxTextureSize;
	const maxSamples = capabilities.maxSamples;
	const multisampledRTTExt = extensions.has('WEBGL_multisampled_render_to_texture') ? extensions.get('WEBGL_multisampled_render_to_texture') : null;
	const supportsInvalidateFramebuffer = /OculusBrowser/g.test(typeof navigator === 'undefined' ? '' : navigator.userAgent);
	const _videoTextures = new WeakMap();
	let _canvas;
	const _sources = new WeakMap(); // maps WebglTexture objects to instances of Source

	// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
	// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
	// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).

	let useOffscreenCanvas = false;
	try {
		useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'
		// eslint-disable-next-line compat/compat
		&& new OffscreenCanvas(1, 1).getContext('2d') !== null;
	} catch (err) {

		// Ignore any errors
	}
	function createCanvas(width, height) {
		// Use OffscreenCanvas when available. Specially needed in web workers

		return useOffscreenCanvas ?
		// eslint-disable-next-line compat/compat
		new OffscreenCanvas(width, height) : createElementNS('canvas');
	}
	function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
		let scale = 1;

		// handle case if texture exceeds max size

		if (image.width > maxSize || image.height > maxSize) {
			scale = maxSize / Math.max(image.width, image.height);
		}

		// only perform resize if necessary

		if (scale < 1 || needsPowerOfTwo === true) {
			// only perform resize for certain image types

			if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
				const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;
				const width = floor(scale * image.width);
				const height = floor(scale * image.height);
				if (_canvas === undefined) _canvas = createCanvas(width, height);

				// cube textures can't reuse the same canvas

				const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas;
				canvas.width = width;
				canvas.height = height;
				const context = canvas.getContext('2d');
				context.drawImage(image, 0, 0, width, height);
				console.warn('THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').');
				return canvas;
			} else {
				if ('data' in image) {
					console.warn('THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').');
				}
				return image;
			}
		}
		return image;
	}
	function isPowerOfTwo$1(image) {
		return isPowerOfTwo(image.width) && isPowerOfTwo(image.height);
	}
	function textureNeedsPowerOfTwo(texture) {
		if (isWebGL2) return false;
		return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
	}
	function textureNeedsGenerateMipmaps(texture, supportsMips) {
		return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
	}
	function generateMipmap(target) {
		_gl.generateMipmap(target);
	}
	function getInternalFormat(internalFormatName, glFormat, glType, encoding, forceLinearEncoding = false) {
		if (isWebGL2 === false) return glFormat;
		if (internalFormatName !== null) {
			if (_gl[internalFormatName] !== undefined) return _gl[internalFormatName];
			console.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'');
		}
		let internalFormat = glFormat;
		if (glFormat === _gl.RED) {
			if (glType === _gl.FLOAT) internalFormat = _gl.R32F;
			if (glType === _gl.HALF_FLOAT) internalFormat = _gl.R16F;
			if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8;
		}
		if (glFormat === _gl.RG) {
			if (glType === _gl.FLOAT) internalFormat = _gl.RG32F;
			if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RG16F;
			if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RG8;
		}
		if (glFormat === _gl.RGBA) {
			if (glType === _gl.FLOAT) internalFormat = _gl.RGBA32F;
			if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGBA16F;
			if (glType === _gl.UNSIGNED_BYTE) internalFormat = encoding === sRGBEncoding && forceLinearEncoding === false ? _gl.SRGB8_ALPHA8 : _gl.RGBA8;
			if (glType === _gl.UNSIGNED_SHORT_4_4_4_4) internalFormat = _gl.RGBA4;
			if (glType === _gl.UNSIGNED_SHORT_5_5_5_1) internalFormat = _gl.RGB5_A1;
		}
		if (internalFormat === _gl.R16F || internalFormat === _gl.R32F || internalFormat === _gl.RG16F || internalFormat === _gl.RG32F || internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) {
			extensions.get('EXT_color_buffer_float');
		}
		return internalFormat;
	}
	function getMipLevels(texture, image, supportsMips) {
		if (textureNeedsGenerateMipmaps(texture, supportsMips) === true || texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
			return Math.log2(Math.max(image.width, image.height)) + 1;
		} else if (texture.mipmaps !== undefined && texture.mipmaps.length > 0) {
			// user-defined mipmaps

			return texture.mipmaps.length;
		} else if (texture.isCompressedTexture && Array.isArray(texture.image)) {
			return image.mipmaps.length;
		} else {
			// texture without mipmaps (only base level)

			return 1;
		}
	}

	// Fallback filters for non-power-of-2 textures

	function filterFallback(f) {
		if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {
			return _gl.NEAREST;
		}
		return _gl.LINEAR;
	}

	//

	function onTextureDispose(event) {
		const texture = event.target;
		texture.removeEventListener('dispose', onTextureDispose);
		deallocateTexture(texture);
		if (texture.isVideoTexture) {
			_videoTextures.delete(texture);
		}
	}
	function onRenderTargetDispose(event) {
		const renderTarget = event.target;
		renderTarget.removeEventListener('dispose', onRenderTargetDispose);
		deallocateRenderTarget(renderTarget);
	}

	//

	function deallocateTexture(texture) {
		const textureProperties = properties.get(texture);
		if (textureProperties.__webglInit === undefined) return;

		// check if it's necessary to remove the WebGLTexture object

		const source = texture.source;
		const webglTextures = _sources.get(source);
		if (webglTextures) {
			const webglTexture = webglTextures[textureProperties.__cacheKey];
			webglTexture.usedTimes--;

			// the WebGLTexture object is not used anymore, remove it

			if (webglTexture.usedTimes === 0) {
				deleteTexture(texture);
			}

			// remove the weak map entry if no WebGLTexture uses the source anymore

			if (Object.keys(webglTextures).length === 0) {
				_sources.delete(source);
			}
		}
		properties.remove(texture);
	}
	function deleteTexture(texture) {
		const textureProperties = properties.get(texture);
		_gl.deleteTexture(textureProperties.__webglTexture);
		const source = texture.source;
		const webglTextures = _sources.get(source);
		delete webglTextures[textureProperties.__cacheKey];
		info.memory.textures--;
	}
	function deallocateRenderTarget(renderTarget) {
		const texture = renderTarget.texture;
		const renderTargetProperties = properties.get(renderTarget);
		const textureProperties = properties.get(texture);
		if (textureProperties.__webglTexture !== undefined) {
			_gl.deleteTexture(textureProperties.__webglTexture);
			info.memory.textures--;
		}
		if (renderTarget.depthTexture) {
			renderTarget.depthTexture.dispose();
		}
		if (renderTarget.isWebGLCubeRenderTarget) {
			for (let i = 0; i < 6; i++) {
				_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
				if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
			}
		} else {
			_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
			if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
			if (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
			if (renderTargetProperties.__webglColorRenderbuffer) {
				for (let i = 0; i < renderTargetProperties.__webglColorRenderbuffer.length; i++) {
					if (renderTargetProperties.__webglColorRenderbuffer[i]) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer[i]);
				}
			}
			if (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
		}
		if (renderTarget.isWebGLMultipleRenderTargets) {
			for (let i = 0, il = texture.length; i < il; i++) {
				const attachmentProperties = properties.get(texture[i]);
				if (attachmentProperties.__webglTexture) {
					_gl.deleteTexture(attachmentProperties.__webglTexture);
					info.memory.textures--;
				}
				properties.remove(texture[i]);
			}
		}
		properties.remove(texture);
		properties.remove(renderTarget);
	}

	//

	let textureUnits = 0;
	function resetTextureUnits() {
		textureUnits = 0;
	}
	function allocateTextureUnit() {
		const textureUnit = textureUnits;
		if (textureUnit >= maxTextures) {
			console.warn('THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures);
		}
		textureUnits += 1;
		return textureUnit;
	}
	function getTextureCacheKey(texture) {
		const array = [];
		array.push(texture.wrapS);
		array.push(texture.wrapT);
		array.push(texture.wrapR || 0);
		array.push(texture.magFilter);
		array.push(texture.minFilter);
		array.push(texture.anisotropy);
		array.push(texture.internalFormat);
		array.push(texture.format);
		array.push(texture.type);
		array.push(texture.generateMipmaps);
		array.push(texture.premultiplyAlpha);
		array.push(texture.flipY);
		array.push(texture.unpackAlignment);
		array.push(texture.encoding);
		return array.join();
	}

	//

	function setTexture2D(texture, slot) {
		const textureProperties = properties.get(texture);
		if (texture.isVideoTexture) updateVideoTexture(texture);
		if (texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version) {
			const image = texture.image;
			if (image === null) {
				console.warn('THREE.WebGLRenderer: Texture marked for update but no image data found.');
			} else if (image.complete === false) {
				console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');
			} else {
				uploadTexture(textureProperties, texture, slot);
				return;
			}
		}
		state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
	}
	function setTexture2DArray(texture, slot) {
		const textureProperties = properties.get(texture);
		if (texture.version > 0 && textureProperties.__version !== texture.version) {
			uploadTexture(textureProperties, texture, slot);
			return;
		}
		state.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
	}
	function setTexture3D(texture, slot) {
		const textureProperties = properties.get(texture);
		if (texture.version > 0 && textureProperties.__version !== texture.version) {
			uploadTexture(textureProperties, texture, slot);
			return;
		}
		state.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
	}
	function setTextureCube(texture, slot) {
		const textureProperties = properties.get(texture);
		if (texture.version > 0 && textureProperties.__version !== texture.version) {
			uploadCubeTexture(textureProperties, texture, slot);
			return;
		}
		state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
	}
	const wrappingToGL = {
		[RepeatWrapping]: _gl.REPEAT,
		[ClampToEdgeWrapping]: _gl.CLAMP_TO_EDGE,
		[MirroredRepeatWrapping]: _gl.MIRRORED_REPEAT
	};
	const filterToGL = {
		[NearestFilter]: _gl.NEAREST,
		[NearestMipmapNearestFilter]: _gl.NEAREST_MIPMAP_NEAREST,
		[NearestMipmapLinearFilter]: _gl.NEAREST_MIPMAP_LINEAR,
		[LinearFilter]: _gl.LINEAR,
		[LinearMipmapNearestFilter]: _gl.LINEAR_MIPMAP_NEAREST,
		[LinearMipmapLinearFilter]: _gl.LINEAR_MIPMAP_LINEAR
	};
	function setTextureParameters(textureType, texture, supportsMips) {
		if (supportsMips) {
			_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]);
			_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]);
			if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
				_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR]);
			}
			_gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]);
			_gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[texture.minFilter]);
		} else {
			_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
			_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
			if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
				_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, _gl.CLAMP_TO_EDGE);
			}
			if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
				console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.');
			}
			_gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));
			_gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));
			if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
				console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.');
			}
		}
		if (extensions.has('EXT_texture_filter_anisotropic') === true) {
			const extension = extensions.get('EXT_texture_filter_anisotropic');
			if (texture.type === FloatType && extensions.has('OES_texture_float_linear') === false) return; // verify extension for WebGL 1 and WebGL 2
			if (isWebGL2 === false && texture.type === HalfFloatType && extensions.has('OES_texture_half_float_linear') === false) return; // verify extension for WebGL 1 only

			if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
				_gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
				properties.get(texture).__currentAnisotropy = texture.anisotropy;
			}
		}
	}
	function initTexture(textureProperties, texture) {
		let forceUpload = false;
		if (textureProperties.__webglInit === undefined) {
			textureProperties.__webglInit = true;
			texture.addEventListener('dispose', onTextureDispose);
		}

		// create Source <-> WebGLTextures mapping if necessary

		const source = texture.source;
		let webglTextures = _sources.get(source);
		if (webglTextures === undefined) {
			webglTextures = {};
			_sources.set(source, webglTextures);
		}

		// check if there is already a WebGLTexture object for the given texture parameters

		const textureCacheKey = getTextureCacheKey(texture);
		if (textureCacheKey !== textureProperties.__cacheKey) {
			// if not, create a new instance of WebGLTexture

			if (webglTextures[textureCacheKey] === undefined) {
				// create new entry

				webglTextures[textureCacheKey] = {
					texture: _gl.createTexture(),
					usedTimes: 0
				};
				info.memory.textures++;

				// when a new instance of WebGLTexture was created, a texture upload is required
				// even if the image contents are identical

				forceUpload = true;
			}
			webglTextures[textureCacheKey].usedTimes++;

			// every time the texture cache key changes, it's necessary to check if an instance of
			// WebGLTexture can be deleted in order to avoid a memory leak.

			const webglTexture = webglTextures[textureProperties.__cacheKey];
			if (webglTexture !== undefined) {
				webglTextures[textureProperties.__cacheKey].usedTimes--;
				if (webglTexture.usedTimes === 0) {
					deleteTexture(texture);
				}
			}

			// store references to cache key and WebGLTexture object

			textureProperties.__cacheKey = textureCacheKey;
			textureProperties.__webglTexture = webglTextures[textureCacheKey].texture;
		}
		return forceUpload;
	}
	function uploadTexture(textureProperties, texture, slot) {
		let textureType = _gl.TEXTURE_2D;
		if (texture.isDataArrayTexture || texture.isCompressedArrayTexture) textureType = _gl.TEXTURE_2D_ARRAY;
		if (texture.isData3DTexture) textureType = _gl.TEXTURE_3D;
		const forceUpload = initTexture(textureProperties, texture);
		const source = texture.source;
		state.bindTexture(textureType, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
		const sourceProperties = properties.get(source);
		if (source.version !== sourceProperties.__version || forceUpload === true) {
			state.activeTexture(_gl.TEXTURE0 + slot);
			_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
			_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
			_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
			_gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE);
			const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo$1(texture.image) === false;
			let image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
			image = verifyColorSpace(texture, image);
			const supportsMips = isPowerOfTwo$1(image) || isWebGL2,
				glFormat = utils.convert(texture.format, texture.encoding);
			let glType = utils.convert(texture.type),
				glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding, texture.isVideoTexture);
			setTextureParameters(textureType, texture, supportsMips);
			let mipmap;
			const mipmaps = texture.mipmaps;
			const useTexStorage = isWebGL2 && texture.isVideoTexture !== true;
			const allocateMemory = sourceProperties.__version === undefined || forceUpload === true;
			const levels = getMipLevels(texture, image, supportsMips);
			if (texture.isDepthTexture) {
				// populate depth texture with dummy data

				glInternalFormat = _gl.DEPTH_COMPONENT;
				if (isWebGL2) {
					if (texture.type === FloatType) {
						glInternalFormat = _gl.DEPTH_COMPONENT32F;
					} else if (texture.type === UnsignedIntType) {
						glInternalFormat = _gl.DEPTH_COMPONENT24;
					} else if (texture.type === UnsignedInt248Type) {
						glInternalFormat = _gl.DEPTH24_STENCIL8;
					} else {
						glInternalFormat = _gl.DEPTH_COMPONENT16; // WebGL2 requires sized internalformat for glTexImage2D
					}
				} else {
					if (texture.type === FloatType) {
						console.error('WebGLRenderer: Floating point depth texture requires WebGL2.');
					}
				}

				// validation checks for WebGL 1

				if (texture.format === DepthFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {
					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
						console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');
						texture.type = UnsignedIntType;
						glType = utils.convert(texture.type);
					}
				}
				if (texture.format === DepthStencilFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {
					// Depth stencil textures need the DEPTH_STENCIL internal format
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					glInternalFormat = _gl.DEPTH_STENCIL;

					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if (texture.type !== UnsignedInt248Type) {
						console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');
						texture.type = UnsignedInt248Type;
						glType = utils.convert(texture.type);
					}
				}

				//

				if (allocateMemory) {
					if (useTexStorage) {
						state.texStorage2D(_gl.TEXTURE_2D, 1, glInternalFormat, image.width, image.height);
					} else {
						state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
					}
				}
			} else if (texture.isDataTexture) {
				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if (mipmaps.length > 0 && supportsMips) {
					if (useTexStorage && allocateMemory) {
						state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
					}
					for (let i = 0, il = mipmaps.length; i < il; i++) {
						mipmap = mipmaps[i];
						if (useTexStorage) {
							state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
						} else {
							state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
						}
					}
					texture.generateMipmaps = false;
				} else {
					if (useTexStorage) {
						if (allocateMemory) {
							state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
						}
						state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, glFormat, glType, image.data);
					} else {
						state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
					}
				}
			} else if (texture.isCompressedTexture) {
				if (texture.isCompressedArrayTexture) {
					if (useTexStorage && allocateMemory) {
						state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height, image.depth);
					}
					for (let i = 0, il = mipmaps.length; i < il; i++) {
						mipmap = mipmaps[i];
						if (texture.format !== RGBAFormat) {
							if (glFormat !== null) {
								if (useTexStorage) {
									state.compressedTexSubImage3D(_gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data, 0, 0);
								} else {
									state.compressedTexImage3D(_gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, mipmap.data, 0, 0);
								}
							} else {
								console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
							}
						} else {
							if (useTexStorage) {
								state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data);
							} else {
								state.texImage3D(_gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, glFormat, glType, mipmap.data);
							}
						}
					}
				} else {
					if (useTexStorage && allocateMemory) {
						state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
					}
					for (let i = 0, il = mipmaps.length; i < il; i++) {
						mipmap = mipmaps[i];
						if (texture.format !== RGBAFormat) {
							if (glFormat !== null) {
								if (useTexStorage) {
									state.compressedTexSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
								} else {
									state.compressedTexImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
								}
							} else {
								console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
							}
						} else {
							if (useTexStorage) {
								state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
							} else {
								state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
							}
						}
					}
				}
			} else if (texture.isDataArrayTexture) {
				if (useTexStorage) {
					if (allocateMemory) {
						state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, image.width, image.height, image.depth);
					}
					state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
				} else {
					state.texImage3D(_gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
				}
			} else if (texture.isData3DTexture) {
				if (useTexStorage) {
					if (allocateMemory) {
						state.texStorage3D(_gl.TEXTURE_3D, levels, glInternalFormat, image.width, image.height, image.depth);
					}
					state.texSubImage3D(_gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
				} else {
					state.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
				}
			} else if (texture.isFramebufferTexture) {
				if (allocateMemory) {
					if (useTexStorage) {
						state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
					} else {
						let width = image.width,
							height = image.height;
						for (let i = 0; i < levels; i++) {
							state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, width, height, 0, glFormat, glType, null);
							width >>= 1;
							height >>= 1;
						}
					}
				}
			} else {
				// regular Texture (image, video, canvas)

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if (mipmaps.length > 0 && supportsMips) {
					if (useTexStorage && allocateMemory) {
						state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
					}
					for (let i = 0, il = mipmaps.length; i < il; i++) {
						mipmap = mipmaps[i];
						if (useTexStorage) {
							state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, glFormat, glType, mipmap);
						} else {
							state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap);
						}
					}
					texture.generateMipmaps = false;
				} else {
					if (useTexStorage) {
						if (allocateMemory) {
							state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
						}
						state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, glFormat, glType, image);
					} else {
						state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image);
					}
				}
			}
			if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
				generateMipmap(textureType);
			}
			sourceProperties.__version = source.version;
			if (texture.onUpdate) texture.onUpdate(texture);
		}
		textureProperties.__version = texture.version;
	}
	function uploadCubeTexture(textureProperties, texture, slot) {
		if (texture.image.length !== 6) return;
		const forceUpload = initTexture(textureProperties, texture);
		const source = texture.source;
		state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
		const sourceProperties = properties.get(source);
		if (source.version !== sourceProperties.__version || forceUpload === true) {
			state.activeTexture(_gl.TEXTURE0 + slot);
			_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
			_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
			_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
			_gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE);
			const isCompressed = texture.isCompressedTexture || texture.image[0].isCompressedTexture;
			const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
			const cubeImage = [];
			for (let i = 0; i < 6; i++) {
				if (!isCompressed && !isDataTexture) {
					cubeImage[i] = resizeImage(texture.image[i], false, true, maxCubemapSize);
				} else {
					cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
				}
				cubeImage[i] = verifyColorSpace(texture, cubeImage[i]);
			}
			const image = cubeImage[0],
				supportsMips = isPowerOfTwo$1(image) || isWebGL2,
				glFormat = utils.convert(texture.format, texture.encoding),
				glType = utils.convert(texture.type),
				glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
			const useTexStorage = isWebGL2 && texture.isVideoTexture !== true;
			const allocateMemory = sourceProperties.__version === undefined || forceUpload === true;
			let levels = getMipLevels(texture, image, supportsMips);
			setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);
			let mipmaps;
			if (isCompressed) {
				if (useTexStorage && allocateMemory) {
					state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, image.width, image.height);
				}
				for (let i = 0; i < 6; i++) {
					mipmaps = cubeImage[i].mipmaps;
					for (let j = 0; j < mipmaps.length; j++) {
						const mipmap = mipmaps[j];
						if (texture.format !== RGBAFormat) {
							if (glFormat !== null) {
								if (useTexStorage) {
									state.compressedTexSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
								} else {
									state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
								}
							} else {
								console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');
							}
						} else {
							if (useTexStorage) {
								state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
							} else {
								state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
							}
						}
					}
				}
			} else {
				mipmaps = texture.mipmaps;
				if (useTexStorage && allocateMemory) {
					// TODO: Uniformly handle mipmap definitions
					// Normal textures and compressed cube textures define base level + mips with their mipmap array
					// Uncompressed cube textures use their mipmap array only for mips (no base level)

					if (mipmaps.length > 0) levels++;
					state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, cubeImage[0].width, cubeImage[0].height);
				}
				for (let i = 0; i < 6; i++) {
					if (isDataTexture) {
						if (useTexStorage) {
							state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, cubeImage[i].width, cubeImage[i].height, glFormat, glType, cubeImage[i].data);
						} else {
							state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
						}
						for (let j = 0; j < mipmaps.length; j++) {
							const mipmap = mipmaps[j];
							const mipmapImage = mipmap.image[i].image;
							if (useTexStorage) {
								state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data);
							} else {
								state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
							}
						}
					} else {
						if (useTexStorage) {
							state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, glFormat, glType, cubeImage[i]);
						} else {
							state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);
						}
						for (let j = 0; j < mipmaps.length; j++) {
							const mipmap = mipmaps[j];
							if (useTexStorage) {
								state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, glFormat, glType, mipmap.image[i]);
							} else {
								state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i]);
							}
						}
					}
				}
			}
			if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
				// We assume images for cube map have the same size.
				generateMipmap(_gl.TEXTURE_CUBE_MAP);
			}
			sourceProperties.__version = source.version;
			if (texture.onUpdate) texture.onUpdate(texture);
		}
		textureProperties.__version = texture.version;
	}

	// Render targets

	// Setup storage for target texture and bind it to correct framebuffer
	function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget) {
		const glFormat = utils.convert(texture.format, texture.encoding);
		const glType = utils.convert(texture.type);
		const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
		const renderTargetProperties = properties.get(renderTarget);
		if (!renderTargetProperties.__hasExternalTextures) {
			if (textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY) {
				state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);
			} else {
				state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
			}
		}
		state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
		if (useMultisampledRTT(renderTarget)) {
			multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, 0, getRenderTargetSamples(renderTarget));
		} else if (textureTarget === _gl.TEXTURE_2D || textureTarget >= _gl.TEXTURE_CUBE_MAP_POSITIVE_X && textureTarget <= _gl.TEXTURE_CUBE_MAP_NEGATIVE_Z) {
			// see #24753

			_gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, 0);
		}
		state.bindFramebuffer(_gl.FRAMEBUFFER, null);
	}

	// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
	function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
		_gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
		if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
			let glInternalFormat = _gl.DEPTH_COMPONENT16;
			if (isMultisample || useMultisampledRTT(renderTarget)) {
				const depthTexture = renderTarget.depthTexture;
				if (depthTexture && depthTexture.isDepthTexture) {
					if (depthTexture.type === FloatType) {
						glInternalFormat = _gl.DEPTH_COMPONENT32F;
					} else if (depthTexture.type === UnsignedIntType) {
						glInternalFormat = _gl.DEPTH_COMPONENT24;
					}
				}
				const samples = getRenderTargetSamples(renderTarget);
				if (useMultisampledRTT(renderTarget)) {
					multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
				} else {
					_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
				}
			} else {
				_gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
			}
			_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
		} else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
			const samples = getRenderTargetSamples(renderTarget);
			if (isMultisample && useMultisampledRTT(renderTarget) === false) {
				_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height);
			} else if (useMultisampledRTT(renderTarget)) {
				multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height);
			} else {
				_gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
			}
			_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
		} else {
			const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];
			for (let i = 0; i < textures.length; i++) {
				const texture = textures[i];
				const glFormat = utils.convert(texture.format, texture.encoding);
				const glType = utils.convert(texture.type);
				const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
				const samples = getRenderTargetSamples(renderTarget);
				if (isMultisample && useMultisampledRTT(renderTarget) === false) {
					_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
				} else if (useMultisampledRTT(renderTarget)) {
					multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
				} else {
					_gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
				}
			}
		}
		_gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
	}

	// Setup resources for a Depth Texture for a FBO (needs an extension)
	function setupDepthTexture(framebuffer, renderTarget) {
		const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
		if (isCube) throw new Error('Depth Texture with cube render targets is not supported');
		state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
		if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
			throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
		}

		// upload an empty depth texture with framebuffer size
		if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
			renderTarget.depthTexture.image.width = renderTarget.width;
			renderTarget.depthTexture.image.height = renderTarget.height;
			renderTarget.depthTexture.needsUpdate = true;
		}
		setTexture2D(renderTarget.depthTexture, 0);
		const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
		const samples = getRenderTargetSamples(renderTarget);
		if (renderTarget.depthTexture.format === DepthFormat) {
			if (useMultisampledRTT(renderTarget)) {
				multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);
			} else {
				_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
			}
		} else if (renderTarget.depthTexture.format === DepthStencilFormat) {
			if (useMultisampledRTT(renderTarget)) {
				multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);
			} else {
				_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
			}
		} else {
			throw new Error('Unknown depthTexture format');
		}
	}

	// Setup GL resources for a non-texture depth buffer
	function setupDepthRenderbuffer(renderTarget) {
		const renderTargetProperties = properties.get(renderTarget);
		const isCube = renderTarget.isWebGLCubeRenderTarget === true;
		if (renderTarget.depthTexture && !renderTargetProperties.__autoAllocateDepthBuffer) {
			if (isCube) throw new Error('target.depthTexture not supported in Cube render targets');
			setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
		} else {
			if (isCube) {
				renderTargetProperties.__webglDepthbuffer = [];
				for (let i = 0; i < 6; i++) {
					state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);
					renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
					setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false);
				}
			} else {
				state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
				renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
				setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
			}
		}
		state.bindFramebuffer(_gl.FRAMEBUFFER, null);
	}

	// rebind framebuffer with external textures
	function rebindTextures(renderTarget, colorTexture, depthTexture) {
		const renderTargetProperties = properties.get(renderTarget);
		if (colorTexture !== undefined) {
			setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D);
		}
		if (depthTexture !== undefined) {
			setupDepthRenderbuffer(renderTarget);
		}
	}

	// Set up GL resources for the render target
	function setupRenderTarget(renderTarget) {
		const texture = renderTarget.texture;
		const renderTargetProperties = properties.get(renderTarget);
		const textureProperties = properties.get(texture);
		renderTarget.addEventListener('dispose', onRenderTargetDispose);
		if (renderTarget.isWebGLMultipleRenderTargets !== true) {
			if (textureProperties.__webglTexture === undefined) {
				textureProperties.__webglTexture = _gl.createTexture();
			}
			textureProperties.__version = texture.version;
			info.memory.textures++;
		}
		const isCube = renderTarget.isWebGLCubeRenderTarget === true;
		const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;
		const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;

		// Setup framebuffer

		if (isCube) {
			renderTargetProperties.__webglFramebuffer = [];
			for (let i = 0; i < 6; i++) {
				renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
			}
		} else {
			renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
			if (isMultipleRenderTargets) {
				if (capabilities.drawBuffers) {
					const textures = renderTarget.texture;
					for (let i = 0, il = textures.length; i < il; i++) {
						const attachmentProperties = properties.get(textures[i]);
						if (attachmentProperties.__webglTexture === undefined) {
							attachmentProperties.__webglTexture = _gl.createTexture();
							info.memory.textures++;
						}
					}
				} else {
					console.warn('THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.');
				}
			}
			if (isWebGL2 && renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
				const textures = isMultipleRenderTargets ? texture : [texture];
				renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
				renderTargetProperties.__webglColorRenderbuffer = [];
				state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
				for (let i = 0; i < textures.length; i++) {
					const texture = textures[i];
					renderTargetProperties.__webglColorRenderbuffer[i] = _gl.createRenderbuffer();
					_gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
					const glFormat = utils.convert(texture.format, texture.encoding);
					const glType = utils.convert(texture.type);
					const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding, renderTarget.isXRRenderTarget === true);
					const samples = getRenderTargetSamples(renderTarget);
					_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
					_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
				}
				_gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
				if (renderTarget.depthBuffer) {
					renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
					setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
				}
				state.bindFramebuffer(_gl.FRAMEBUFFER, null);
			}
		}

		// Setup color buffer

		if (isCube) {
			state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
			setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);
			for (let i = 0; i < 6; i++) {
				setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);
			}
			if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
				generateMipmap(_gl.TEXTURE_CUBE_MAP);
			}
			state.unbindTexture();
		} else if (isMultipleRenderTargets) {
			const textures = renderTarget.texture;
			for (let i = 0, il = textures.length; i < il; i++) {
				const attachment = textures[i];
				const attachmentProperties = properties.get(attachment);
				state.bindTexture(_gl.TEXTURE_2D, attachmentProperties.__webglTexture);
				setTextureParameters(_gl.TEXTURE_2D, attachment, supportsMips);
				setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D);
				if (textureNeedsGenerateMipmaps(attachment, supportsMips)) {
					generateMipmap(_gl.TEXTURE_2D);
				}
			}
			state.unbindTexture();
		} else {
			let glTextureType = _gl.TEXTURE_2D;
			if (renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget) {
				if (isWebGL2) {
					glTextureType = renderTarget.isWebGL3DRenderTarget ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;
				} else {
					console.error('THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.');
				}
			}
			state.bindTexture(glTextureType, textureProperties.__webglTexture);
			setTextureParameters(glTextureType, texture, supportsMips);
			setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType);
			if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
				generateMipmap(glTextureType);
			}
			state.unbindTexture();
		}

		// Setup depth and stencil buffers

		if (renderTarget.depthBuffer) {
			setupDepthRenderbuffer(renderTarget);
		}
	}
	function updateRenderTargetMipmap(renderTarget) {
		const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
		const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];
		for (let i = 0, il = textures.length; i < il; i++) {
			const texture = textures[i];
			if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
				const target = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
				const webglTexture = properties.get(texture).__webglTexture;
				state.bindTexture(target, webglTexture);
				generateMipmap(target);
				state.unbindTexture();
			}
		}
	}
	function updateMultisampleRenderTarget(renderTarget) {
		if (isWebGL2 && renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
			const textures = renderTarget.isWebGLMultipleRenderTargets ? renderTarget.texture : [renderTarget.texture];
			const width = renderTarget.width;
			const height = renderTarget.height;
			let mask = _gl.COLOR_BUFFER_BIT;
			const invalidationArray = [];
			const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
			const renderTargetProperties = properties.get(renderTarget);
			const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;

			// If MRT we need to remove FBO attachments
			if (isMultipleRenderTargets) {
				for (let i = 0; i < textures.length; i++) {
					state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
					_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, null);
					state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
					_gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, null, 0);
				}
			}
			state.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
			state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
			for (let i = 0; i < textures.length; i++) {
				invalidationArray.push(_gl.COLOR_ATTACHMENT0 + i);
				if (renderTarget.depthBuffer) {
					invalidationArray.push(depthStyle);
				}
				const ignoreDepthValues = renderTargetProperties.__ignoreDepthValues !== undefined ? renderTargetProperties.__ignoreDepthValues : false;
				if (ignoreDepthValues === false) {
					if (renderTarget.depthBuffer) mask |= _gl.DEPTH_BUFFER_BIT;
					if (renderTarget.stencilBuffer) mask |= _gl.STENCIL_BUFFER_BIT;
				}
				if (isMultipleRenderTargets) {
					_gl.framebufferRenderbuffer(_gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
				}
				if (ignoreDepthValues === true) {
					_gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, [depthStyle]);
					_gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, [depthStyle]);
				}
				if (isMultipleRenderTargets) {
					const webglTexture = properties.get(textures[i]).__webglTexture;
					_gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, webglTexture, 0);
				}
				_gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST);
				if (supportsInvalidateFramebuffer) {
					_gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, invalidationArray);
				}
			}
			state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);
			state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, null);

			// If MRT since pre-blit we removed the FBO we need to reconstruct the attachments
			if (isMultipleRenderTargets) {
				for (let i = 0; i < textures.length; i++) {
					state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
					_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
					const webglTexture = properties.get(textures[i]).__webglTexture;
					state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
					_gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, webglTexture, 0);
				}
			}
			state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
		}
	}
	function getRenderTargetSamples(renderTarget) {
		return Math.min(maxSamples, renderTarget.samples);
	}
	function useMultisampledRTT(renderTarget) {
		const renderTargetProperties = properties.get(renderTarget);
		return isWebGL2 && renderTarget.samples > 0 && extensions.has('WEBGL_multisampled_render_to_texture') === true && renderTargetProperties.__useRenderToTexture !== false;
	}
	function updateVideoTexture(texture) {
		const frame = info.render.frame;

		// Check the last frame we updated the VideoTexture

		if (_videoTextures.get(texture) !== frame) {
			_videoTextures.set(texture, frame);
			texture.update();
		}
	}
	function verifyColorSpace(texture, image) {
		const encoding = texture.encoding;
		const format = texture.format;
		const type = texture.type;
		if (texture.isCompressedTexture === true || texture.isVideoTexture === true || texture.format === _SRGBAFormat) return image;
		if (encoding !== LinearEncoding) {
			// sRGB

			if (encoding === sRGBEncoding) {
				if (isWebGL2 === false) {
					// in WebGL 1, try to use EXT_sRGB extension and unsized formats

					if (extensions.has('EXT_sRGB') === true && format === RGBAFormat) {
						texture.format = _SRGBAFormat;

						// it's not possible to generate mips in WebGL 1 with this extension

						texture.minFilter = LinearFilter;
						texture.generateMipmaps = false;
					} else {
						// slow fallback (CPU decode)

						image = ImageUtils.sRGBToLinear(image);
					}
				} else {
					// in WebGL 2 uncompressed textures can only be sRGB encoded if they have the RGBA8 format

					if (format !== RGBAFormat || type !== UnsignedByteType) {
						console.warn('THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.');
					}
				}
			} else {
				console.error('THREE.WebGLTextures: Unsupported texture encoding:', encoding);
			}
		}
		return image;
	}

	//

	this.allocateTextureUnit = allocateTextureUnit;
	this.resetTextureUnits = resetTextureUnits;
	this.setTexture2D = setTexture2D;
	this.setTexture2DArray = setTexture2DArray;
	this.setTexture3D = setTexture3D;
	this.setTextureCube = setTextureCube;
	this.rebindTextures = rebindTextures;
	this.setupRenderTarget = setupRenderTarget;
	this.updateRenderTargetMipmap = updateRenderTargetMipmap;
	this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
	this.setupDepthRenderbuffer = setupDepthRenderbuffer;
	this.setupFrameBufferTexture = setupFrameBufferTexture;
	this.useMultisampledRTT = useMultisampledRTT;
}

function WebGLUtils(gl, extensions, capabilities) {
	const isWebGL2 = capabilities.isWebGL2;
	function convert(p, encoding = null) {
		let extension;
		if (p === UnsignedByteType) return gl.UNSIGNED_BYTE;
		if (p === UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;
		if (p === UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;
		if (p === ByteType) return gl.BYTE;
		if (p === ShortType) return gl.SHORT;
		if (p === UnsignedShortType) return gl.UNSIGNED_SHORT;
		if (p === IntType) return gl.INT;
		if (p === UnsignedIntType) return gl.UNSIGNED_INT;
		if (p === FloatType) return gl.FLOAT;
		if (p === HalfFloatType) {
			if (isWebGL2) return gl.HALF_FLOAT;
			extension = extensions.get('OES_texture_half_float');
			if (extension !== null) {
				return extension.HALF_FLOAT_OES;
			} else {
				return null;
			}
		}
		if (p === AlphaFormat) return gl.ALPHA;
		if (p === RGBAFormat) return gl.RGBA;
		if (p === LuminanceFormat) return gl.LUMINANCE;
		if (p === LuminanceAlphaFormat) return gl.LUMINANCE_ALPHA;
		if (p === DepthFormat) return gl.DEPTH_COMPONENT;
		if (p === DepthStencilFormat) return gl.DEPTH_STENCIL;
		if (p === RedFormat) return gl.RED;

		// @deprecated since r137

		if (p === RGBFormat) {
			console.warn('THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228');
			return gl.RGBA;
		}

		// WebGL 1 sRGB fallback

		if (p === _SRGBAFormat) {
			extension = extensions.get('EXT_sRGB');
			if (extension !== null) {
				return extension.SRGB_ALPHA_EXT;
			} else {
				return null;
			}
		}

		// WebGL2 formats.

		if (p === RedIntegerFormat) return gl.RED_INTEGER;
		if (p === RGFormat) return gl.RG;
		if (p === RGIntegerFormat) return gl.RG_INTEGER;
		if (p === RGBAIntegerFormat) return gl.RGBA_INTEGER;

		// S3TC

		if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
			if (encoding === sRGBEncoding) {
				extension = extensions.get('WEBGL_compressed_texture_s3tc_srgb');
				if (extension !== null) {
					if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
					if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
					if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
					if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
				} else {
					return null;
				}
			} else {
				extension = extensions.get('WEBGL_compressed_texture_s3tc');
				if (extension !== null) {
					if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
					if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
					if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
					if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
				} else {
					return null;
				}
			}
		}

		// PVRTC

		if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
			extension = extensions.get('WEBGL_compressed_texture_pvrtc');
			if (extension !== null) {
				if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
			} else {
				return null;
			}
		}

		// ETC1

		if (p === RGB_ETC1_Format) {
			extension = extensions.get('WEBGL_compressed_texture_etc1');
			if (extension !== null) {
				return extension.COMPRESSED_RGB_ETC1_WEBGL;
			} else {
				return null;
			}
		}

		// ETC2

		if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
			extension = extensions.get('WEBGL_compressed_texture_etc');
			if (extension !== null) {
				if (p === RGB_ETC2_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
				if (p === RGBA_ETC2_EAC_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;
			} else {
				return null;
			}
		}

		// ASTC

		if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format) {
			extension = extensions.get('WEBGL_compressed_texture_astc');
			if (extension !== null) {
				if (p === RGBA_ASTC_4x4_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
				if (p === RGBA_ASTC_5x4_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
				if (p === RGBA_ASTC_5x5_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
				if (p === RGBA_ASTC_6x5_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
				if (p === RGBA_ASTC_6x6_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
				if (p === RGBA_ASTC_8x5_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
				if (p === RGBA_ASTC_8x6_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
				if (p === RGBA_ASTC_8x8_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
				if (p === RGBA_ASTC_10x5_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
				if (p === RGBA_ASTC_10x6_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
				if (p === RGBA_ASTC_10x8_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
				if (p === RGBA_ASTC_10x10_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
				if (p === RGBA_ASTC_12x10_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
				if (p === RGBA_ASTC_12x12_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;
			} else {
				return null;
			}
		}

		// BPTC

		if (p === RGBA_BPTC_Format) {
			extension = extensions.get('EXT_texture_compression_bptc');
			if (extension !== null) {
				if (p === RGBA_BPTC_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
			} else {
				return null;
			}
		}

		//

		if (p === UnsignedInt248Type) {
			if (isWebGL2) return gl.UNSIGNED_INT_24_8;
			extension = extensions.get('WEBGL_depth_texture');
			if (extension !== null) {
				return extension.UNSIGNED_INT_24_8_WEBGL;
			} else {
				return null;
			}
		}

		// if "p" can't be resolved, assume the user defines a WebGL constant as a string (fallback/workaround for packed RGB formats)

		return gl[p] !== undefined ? gl[p] : null;
	}
	return {
		convert: convert
	};
}

class ArrayCamera extends PerspectiveCamera {
	constructor(array = []) {
		super();
		this.isArrayCamera = true;
		this.cameras = array;
	}
}

class Group extends Object3D {
	constructor() {
		super();
		this.isGroup = true;
		this.type = 'Group';
	}
}

const _moveEvent = {
	type: 'move'
};
class WebXRController {
	constructor() {
		this._targetRay = null;
		this._grip = null;
		this._hand = null;
	}
	getHandSpace() {
		if (this._hand === null) {
			this._hand = new Group();
			this._hand.matrixAutoUpdate = false;
			this._hand.visible = false;
			this._hand.joints = {};
			this._hand.inputState = {
				pinching: false
			};
		}
		return this._hand;
	}
	getTargetRaySpace() {
		if (this._targetRay === null) {
			this._targetRay = new Group();
			this._targetRay.matrixAutoUpdate = false;
			this._targetRay.visible = false;
			this._targetRay.hasLinearVelocity = false;
			this._targetRay.linearVelocity = new Vector3();
			this._targetRay.hasAngularVelocity = false;
			this._targetRay.angularVelocity = new Vector3();
		}
		return this._targetRay;
	}
	getGripSpace() {
		if (this._grip === null) {
			this._grip = new Group();
			this._grip.matrixAutoUpdate = false;
			this._grip.visible = false;
			this._grip.hasLinearVelocity = false;
			this._grip.linearVelocity = new Vector3();
			this._grip.hasAngularVelocity = false;
			this._grip.angularVelocity = new Vector3();
		}
		return this._grip;
	}
	dispatchEvent(event) {
		if (this._targetRay !== null) {
			this._targetRay.dispatchEvent(event);
		}
		if (this._grip !== null) {
			this._grip.dispatchEvent(event);
		}
		if (this._hand !== null) {
			this._hand.dispatchEvent(event);
		}
		return this;
	}
	disconnect(inputSource) {
		this.dispatchEvent({
			type: 'disconnected',
			data: inputSource
		});
		if (this._targetRay !== null) {
			this._targetRay.visible = false;
		}
		if (this._grip !== null) {
			this._grip.visible = false;
		}
		if (this._hand !== null) {
			this._hand.visible = false;
		}
		return this;
	}
	update(inputSource, frame, referenceSpace) {
		let inputPose = null;
		let gripPose = null;
		let handPose = null;
		const targetRay = this._targetRay;
		const grip = this._grip;
		const hand = this._hand;
		if (inputSource && frame.session.visibilityState !== 'visible-blurred') {
			if (hand && inputSource.hand) {
				handPose = true;
				for (const inputjoint of inputSource.hand.values()) {
					// Update the joints groups with the XRJoint poses
					const jointPose = frame.getJointPose(inputjoint, referenceSpace);
					if (hand.joints[inputjoint.jointName] === undefined) {
						// The transform of this joint will be updated with the joint pose on each frame
						const joint = new Group();
						joint.matrixAutoUpdate = false;
						joint.visible = false;
						hand.joints[inputjoint.jointName] = joint;
						// ??
						hand.add(joint);
					}
					const joint = hand.joints[inputjoint.jointName];
					if (jointPose !== null) {
						joint.matrix.fromArray(jointPose.transform.matrix);
						joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
						joint.jointRadius = jointPose.radius;
					}
					joint.visible = jointPose !== null;
				}

				// Custom events

				// Check pinchz
				const indexTip = hand.joints['index-finger-tip'];
				const thumbTip = hand.joints['thumb-tip'];
				const distance = indexTip.position.distanceTo(thumbTip.position);
				const distanceToPinch = 0.02;
				const threshold = 0.005;
				if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
					hand.inputState.pinching = false;
					this.dispatchEvent({
						type: 'pinchend',
						handedness: inputSource.handedness,
						target: this
					});
				} else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
					hand.inputState.pinching = true;
					this.dispatchEvent({
						type: 'pinchstart',
						handedness: inputSource.handedness,
						target: this
					});
				}
			} else {
				if (grip !== null && inputSource.gripSpace) {
					gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
					if (gripPose !== null) {
						grip.matrix.fromArray(gripPose.transform.matrix);
						grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
						if (gripPose.linearVelocity) {
							grip.hasLinearVelocity = true;
							grip.linearVelocity.copy(gripPose.linearVelocity);
						} else {
							grip.hasLinearVelocity = false;
						}
						if (gripPose.angularVelocity) {
							grip.hasAngularVelocity = true;
							grip.angularVelocity.copy(gripPose.angularVelocity);
						} else {
							grip.hasAngularVelocity = false;
						}
					}
				}
			}
			if (targetRay !== null) {
				inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);

				// Some runtimes (namely Vive Cosmos with Vive OpenXR Runtime) have only grip space and ray space is equal to it
				if (inputPose === null && gripPose !== null) {
					inputPose = gripPose;
				}
				if (inputPose !== null) {
					targetRay.matrix.fromArray(inputPose.transform.matrix);
					targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
					if (inputPose.linearVelocity) {
						targetRay.hasLinearVelocity = true;
						targetRay.linearVelocity.copy(inputPose.linearVelocity);
					} else {
						targetRay.hasLinearVelocity = false;
					}
					if (inputPose.angularVelocity) {
						targetRay.hasAngularVelocity = true;
						targetRay.angularVelocity.copy(inputPose.angularVelocity);
					} else {
						targetRay.hasAngularVelocity = false;
					}
					this.dispatchEvent(_moveEvent);
				}
			}
		}
		if (targetRay !== null) {
			targetRay.visible = inputPose !== null;
		}
		if (grip !== null) {
			grip.visible = gripPose !== null;
		}
		if (hand !== null) {
			hand.visible = handPose !== null;
		}
		return this;
	}
}

class DepthTexture extends Texture {
	constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
		format = format !== undefined ? format : DepthFormat;
		if (format !== DepthFormat && format !== DepthStencilFormat) {
			throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');
		}
		if (type === undefined && format === DepthFormat) type = UnsignedIntType;
		if (type === undefined && format === DepthStencilFormat) type = UnsignedInt248Type;
		super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
		this.isDepthTexture = true;
		this.image = {
			width: width,
			height: height
		};
		this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
		this.flipY = false;
		this.generateMipmaps = false;
	}
}

class WebXRManager extends EventDispatcher {
	constructor(renderer, gl) {
		super();
		const scope = this;
		let session = null;
		let framebufferScaleFactor = 1.0;
		let referenceSpace = null;
		let referenceSpaceType = 'local-floor';
		let customReferenceSpace = null;
		let pose = null;
		let glBinding = null;
		let glProjLayer = null;
		let glBaseLayer = null;
		let xrFrame = null;
		const attributes = gl.getContextAttributes();
		let initialRenderTarget = null;
		let newRenderTarget = null;
		const controllers = [];
		const controllerInputSources = [];

		//

		const cameraL = new PerspectiveCamera();
		cameraL.layers.enable(1);
		cameraL.viewport = new Vector4();
		const cameraR = new PerspectiveCamera();
		cameraR.layers.enable(2);
		cameraR.viewport = new Vector4();
		const cameras = [cameraL, cameraR];
		const cameraVR = new ArrayCamera();
		cameraVR.layers.enable(1);
		cameraVR.layers.enable(2);
		let _currentDepthNear = null;
		let _currentDepthFar = null;

		//

		this.cameraAutoUpdate = true;
		this.enabled = false;
		this.isPresenting = false;
		this.getController = function (index) {
			let controller = controllers[index];
			if (controller === undefined) {
				controller = new WebXRController();
				controllers[index] = controller;
			}
			return controller.getTargetRaySpace();
		};
		this.getControllerGrip = function (index) {
			let controller = controllers[index];
			if (controller === undefined) {
				controller = new WebXRController();
				controllers[index] = controller;
			}
			return controller.getGripSpace();
		};
		this.getHand = function (index) {
			let controller = controllers[index];
			if (controller === undefined) {
				controller = new WebXRController();
				controllers[index] = controller;
			}
			return controller.getHandSpace();
		};

		//

		function onSessionEvent(event) {
			const controllerIndex = controllerInputSources.indexOf(event.inputSource);
			if (controllerIndex === -1) {
				return;
			}
			const controller = controllers[controllerIndex];
			if (controller !== undefined) {
				controller.dispatchEvent({
					type: event.type,
					data: event.inputSource
				});
			}
		}
		function onSessionEnd() {
			session.removeEventListener('select', onSessionEvent);
			session.removeEventListener('selectstart', onSessionEvent);
			session.removeEventListener('selectend', onSessionEvent);
			session.removeEventListener('squeeze', onSessionEvent);
			session.removeEventListener('squeezestart', onSessionEvent);
			session.removeEventListener('squeezeend', onSessionEvent);
			session.removeEventListener('end', onSessionEnd);
			session.removeEventListener('inputsourceschange', onInputSourcesChange);
			for (let i = 0; i < controllers.length; i++) {
				const inputSource = controllerInputSources[i];
				if (inputSource === null) continue;
				controllerInputSources[i] = null;
				controllers[i].disconnect(inputSource);
			}
			_currentDepthNear = null;
			_currentDepthFar = null;

			// restore framebuffer/rendering state

			renderer.setRenderTarget(initialRenderTarget);
			glBaseLayer = null;
			glProjLayer = null;
			glBinding = null;
			session = null;
			newRenderTarget = null;

			//

			animation.stop();
			scope.isPresenting = false;
			scope.dispatchEvent({
				type: 'sessionend'
			});
		}
		this.setFramebufferScaleFactor = function (value) {
			framebufferScaleFactor = value;
			if (scope.isPresenting === true) {
				console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.');
			}
		};
		this.setReferenceSpaceType = function (value) {
			referenceSpaceType = value;
			if (scope.isPresenting === true) {
				console.warn('THREE.WebXRManager: Cannot change reference space type while presenting.');
			}
		};
		this.getReferenceSpace = function () {
			return customReferenceSpace || referenceSpace;
		};
		this.setReferenceSpace = function (space) {
			customReferenceSpace = space;
		};
		this.getBaseLayer = function () {
			return glProjLayer !== null ? glProjLayer : glBaseLayer;
		};
		this.getBinding = function () {
			return glBinding;
		};
		this.getFrame = function () {
			return xrFrame;
		};
		this.getSession = function () {
			return session;
		};
		this.setSession = async function (value) {
			session = value;
			if (session !== null) {
				initialRenderTarget = renderer.getRenderTarget();
				session.addEventListener('select', onSessionEvent);
				session.addEventListener('selectstart', onSessionEvent);
				session.addEventListener('selectend', onSessionEvent);
				session.addEventListener('squeeze', onSessionEvent);
				session.addEventListener('squeezestart', onSessionEvent);
				session.addEventListener('squeezeend', onSessionEvent);
				session.addEventListener('end', onSessionEnd);
				session.addEventListener('inputsourceschange', onInputSourcesChange);
				if (attributes.xrCompatible !== true) {
					await gl.makeXRCompatible();
				}
				if (session.renderState.layers === undefined || renderer.capabilities.isWebGL2 === false) {
					const layerInit = {
						antialias: session.renderState.layers === undefined ? attributes.antialias : true,
						alpha: attributes.alpha,
						depth: attributes.depth,
						stencil: attributes.stencil,
						framebufferScaleFactor: framebufferScaleFactor
					};
					glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
					session.updateRenderState({
						baseLayer: glBaseLayer
					});
					newRenderTarget = new WebGLRenderTarget(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, {
						format: RGBAFormat,
						type: UnsignedByteType,
						encoding: renderer.outputEncoding,
						stencilBuffer: attributes.stencil
					});
				} else {
					let depthFormat = null;
					let depthType = null;
					let glDepthFormat = null;
					if (attributes.depth) {
						glDepthFormat = attributes.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;
						depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
						depthType = attributes.stencil ? UnsignedInt248Type : UnsignedIntType;
					}
					const projectionlayerInit = {
						colorFormat: gl.RGBA8,
						depthFormat: glDepthFormat,
						scaleFactor: framebufferScaleFactor
					};
					glBinding = new XRWebGLBinding(session, gl);
					glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
					session.updateRenderState({
						layers: [glProjLayer]
					});
					newRenderTarget = new WebGLRenderTarget(glProjLayer.textureWidth, glProjLayer.textureHeight, {
						format: RGBAFormat,
						type: UnsignedByteType,
						depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, undefined, undefined, undefined, undefined, undefined, undefined, depthFormat),
						stencilBuffer: attributes.stencil,
						encoding: renderer.outputEncoding,
						samples: attributes.antialias ? 4 : 0
					});
					const renderTargetProperties = renderer.properties.get(newRenderTarget);
					renderTargetProperties.__ignoreDepthValues = glProjLayer.ignoreDepthValues;
				}
				newRenderTarget.isXRRenderTarget = true; // TODO Remove this when possible, see #23278

				// Set foveation to maximum.
				this.setFoveation(1.0);
				customReferenceSpace = null;
				referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
				animation.setContext(session);
				animation.start();
				scope.isPresenting = true;
				scope.dispatchEvent({
					type: 'sessionstart'
				});
			}
		};
		function onInputSourcesChange(event) {
			// Notify disconnected

			for (let i = 0; i < event.removed.length; i++) {
				const inputSource = event.removed[i];
				const index = controllerInputSources.indexOf(inputSource);
				if (index >= 0) {
					controllerInputSources[index] = null;
					controllers[index].dispatchEvent({
						type: 'disconnected',
						data: inputSource
					});
				}
			}

			// Notify connected

			for (let i = 0; i < event.added.length; i++) {
				const inputSource = event.added[i];
				let controllerIndex = controllerInputSources.indexOf(inputSource);
				if (controllerIndex === -1) {
					// Assign input source a controller that currently has no input source

					for (let i = 0; i < controllers.length; i++) {
						if (i >= controllerInputSources.length) {
							controllerInputSources.push(inputSource);
							controllerIndex = i;
							break;
						} else if (controllerInputSources[i] === null) {
							controllerInputSources[i] = inputSource;
							controllerIndex = i;
							break;
						}
					}

					// If all controllers do currently receive input we ignore new ones

					if (controllerIndex === -1) break;
				}
				const controller = controllers[controllerIndex];
				if (controller) {
					controller.dispatchEvent({
						type: 'connected',
						data: inputSource
					});
				}
			}
		}

		//

		const cameraLPos = new Vector3();
		const cameraRPos = new Vector3();

		/**
		 * Assumes 2 cameras that are parallel and share an X-axis, and that
		 * the cameras' projection and world matrices have already been set.
		 * And that near and far planes are identical for both cameras.
		 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
		 */
		function setProjectionFromUnion(camera, cameraL, cameraR) {
			cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
			cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);
			const ipd = cameraLPos.distanceTo(cameraRPos);
			const projL = cameraL.projectionMatrix.elements;
			const projR = cameraR.projectionMatrix.elements;

			// VR systems will have identical far and near planes, and
			// most likely identical top and bottom frustum extents.
			// Use the left camera for these values.
			const near = projL[14] / (projL[10] - 1);
			const far = projL[14] / (projL[10] + 1);
			const topFov = (projL[9] + 1) / projL[5];
			const bottomFov = (projL[9] - 1) / projL[5];
			const leftFov = (projL[8] - 1) / projL[0];
			const rightFov = (projR[8] + 1) / projR[0];
			const left = near * leftFov;
			const right = near * rightFov;

			// Calculate the new camera's position offset from the
			// left camera. xOffset should be roughly half `ipd`.
			const zOffset = ipd / (-leftFov + rightFov);
			const xOffset = zOffset * -leftFov;

			// TODO: Better way to apply this offset?
			cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
			camera.translateX(xOffset);
			camera.translateZ(zOffset);
			camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
			camera.matrixWorldInverse.copy(camera.matrixWorld).invert();

			// Find the union of the frustum values of the cameras and scale
			// the values so that the near plane's position does not change in world space,
			// although must now be relative to the new union camera.
			const near2 = near + zOffset;
			const far2 = far + zOffset;
			const left2 = left - xOffset;
			const right2 = right + (ipd - xOffset);
			const top2 = topFov * far / far2 * near2;
			const bottom2 = bottomFov * far / far2 * near2;
			camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
		}
		function updateCamera(camera, parent) {
			if (parent === null) {
				camera.matrixWorld.copy(camera.matrix);
			} else {
				camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
			}
			camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
		}
		this.updateCamera = function (camera) {
			if (session === null) return;
			cameraVR.near = cameraR.near = cameraL.near = camera.near;
			cameraVR.far = cameraR.far = cameraL.far = camera.far;
			if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
				// Note that the new renderState won't apply until the next frame. See #18320

				session.updateRenderState({
					depthNear: cameraVR.near,
					depthFar: cameraVR.far
				});
				_currentDepthNear = cameraVR.near;
				_currentDepthFar = cameraVR.far;
			}
			const parent = camera.parent;
			const cameras = cameraVR.cameras;
			updateCamera(cameraVR, parent);
			for (let i = 0; i < cameras.length; i++) {
				updateCamera(cameras[i], parent);
			}
			cameraVR.matrixWorld.decompose(cameraVR.position, cameraVR.quaternion, cameraVR.scale);

			// update user camera and its children

			camera.matrix.copy(cameraVR.matrix);
			camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
			const children = camera.children;
			for (let i = 0, l = children.length; i < l; i++) {
				children[i].updateMatrixWorld(true);
			}

			// update projection matrix for proper view frustum culling

			if (cameras.length === 2) {
				setProjectionFromUnion(cameraVR, cameraL, cameraR);
			} else {
				// assume single camera setup (AR)

				cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
			}
		};
		this.getCamera = function () {
			return cameraVR;
		};
		this.getFoveation = function () {
			if (glProjLayer !== null) {
				return glProjLayer.fixedFoveation;
			}
			if (glBaseLayer !== null) {
				return glBaseLayer.fixedFoveation;
			}
			return undefined;
		};
		this.setFoveation = function (foveation) {
			// 0 = no foveation = full resolution
			// 1 = maximum foveation = the edges render at lower resolution

			if (glProjLayer !== null) {
				glProjLayer.fixedFoveation = foveation;
			}
			if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined) {
				glBaseLayer.fixedFoveation = foveation;
			}
		};

		// Animation Loop

		let onAnimationFrameCallback = null;
		function onAnimationFrame(time, frame) {
			pose = frame.getViewerPose(customReferenceSpace || referenceSpace);
			xrFrame = frame;
			if (pose !== null) {
				const views = pose.views;
				if (glBaseLayer !== null) {
					renderer.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer);
					renderer.setRenderTarget(newRenderTarget);
				}
				let cameraVRNeedsUpdate = false;

				// check if it's necessary to rebuild cameraVR's camera list

				if (views.length !== cameraVR.cameras.length) {
					cameraVR.cameras.length = 0;
					cameraVRNeedsUpdate = true;
				}
				for (let i = 0; i < views.length; i++) {
					const view = views[i];
					let viewport = null;
					if (glBaseLayer !== null) {
						viewport = glBaseLayer.getViewport(view);
					} else {
						const glSubImage = glBinding.getViewSubImage(glProjLayer, view);
						viewport = glSubImage.viewport;

						// For side-by-side projection, we only produce a single texture for both eyes.
						if (i === 0) {
							renderer.setRenderTargetTextures(newRenderTarget, glSubImage.colorTexture, glProjLayer.ignoreDepthValues ? undefined : glSubImage.depthStencilTexture);
							renderer.setRenderTarget(newRenderTarget);
						}
					}
					let camera = cameras[i];
					if (camera === undefined) {
						camera = new PerspectiveCamera();
						camera.layers.enable(i);
						camera.viewport = new Vector4();
						cameras[i] = camera;
					}
					camera.matrix.fromArray(view.transform.matrix);
					camera.projectionMatrix.fromArray(view.projectionMatrix);
					camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
					if (i === 0) {
						cameraVR.matrix.copy(camera.matrix);
					}
					if (cameraVRNeedsUpdate === true) {
						cameraVR.cameras.push(camera);
					}
				}
			}

			//

			for (let i = 0; i < controllers.length; i++) {
				const inputSource = controllerInputSources[i];
				const controller = controllers[i];
				if (inputSource !== null && controller !== undefined) {
					controller.update(inputSource, frame, customReferenceSpace || referenceSpace);
				}
			}
			if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);
			xrFrame = null;
		}
		const animation = new WebGLAnimation();
		animation.setAnimationLoop(onAnimationFrame);
		this.setAnimationLoop = function (callback) {
			onAnimationFrameCallback = callback;
		};
		this.dispose = function () {};
	}
}

function WebGLMaterials(renderer, properties) {
	function refreshFogUniforms(uniforms, fog) {
		uniforms.fogColor.value.copy(fog.color);
		if (fog.isFog) {
			uniforms.fogNear.value = fog.near;
			uniforms.fogFar.value = fog.far;
		} else if (fog.isFogExp2) {
			uniforms.fogDensity.value = fog.density;
		}
	}
	function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {
		if (material.isMeshBasicMaterial) {
			refreshUniformsCommon(uniforms, material);
		} else if (material.isMeshLambertMaterial) {
			refreshUniformsCommon(uniforms, material);
		} else if (material.isMeshToonMaterial) {
			refreshUniformsCommon(uniforms, material);
			refreshUniformsToon(uniforms, material);
		} else if (material.isMeshPhongMaterial) {
			refreshUniformsCommon(uniforms, material);
			refreshUniformsPhong(uniforms, material);
		} else if (material.isMeshStandardMaterial) {
			refreshUniformsCommon(uniforms, material);
			refreshUniformsStandard(uniforms, material);
			if (material.isMeshPhysicalMaterial) {
				refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
			}
		} else if (material.isMeshMatcapMaterial) {
			refreshUniformsCommon(uniforms, material);
			refreshUniformsMatcap(uniforms, material);
		} else if (material.isMeshDepthMaterial) {
			refreshUniformsCommon(uniforms, material);
		} else if (material.isMeshDistanceMaterial) {
			refreshUniformsCommon(uniforms, material);
			refreshUniformsDistance(uniforms, material);
		} else if (material.isMeshNormalMaterial) {
			refreshUniformsCommon(uniforms, material);
		} else if (material.isLineBasicMaterial) {
			refreshUniformsLine(uniforms, material);
			if (material.isLineDashedMaterial) {
				refreshUniformsDash(uniforms, material);
			}
		} else if (material.isPointsMaterial) {
			refreshUniformsPoints(uniforms, material, pixelRatio, height);
		} else if (material.isSpriteMaterial) {
			refreshUniformsSprites(uniforms, material);
		} else if (material.isShadowMaterial) {
			uniforms.color.value.copy(material.color);
			uniforms.opacity.value = material.opacity;
		} else if (material.isShaderMaterial) {
			material.uniformsNeedUpdate = false; // #15581
		}
	}

	function refreshUniformsCommon(uniforms, material) {
		uniforms.opacity.value = material.opacity;
		if (material.color) {
			uniforms.diffuse.value.copy(material.color);
		}
		if (material.emissive) {
			uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
		}
		if (material.map) {
			uniforms.map.value = material.map;
		}
		if (material.alphaMap) {
			uniforms.alphaMap.value = material.alphaMap;
		}
		if (material.bumpMap) {
			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if (material.side === BackSide) uniforms.bumpScale.value *= -1;
		}
		if (material.displacementMap) {
			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;
		}
		if (material.emissiveMap) {
			uniforms.emissiveMap.value = material.emissiveMap;
		}
		if (material.normalMap) {
			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy(material.normalScale);
			if (material.side === BackSide) uniforms.normalScale.value.negate();
		}
		if (material.specularMap) {
			uniforms.specularMap.value = material.specularMap;
		}
		if (material.alphaTest > 0) {
			uniforms.alphaTest.value = material.alphaTest;
		}
		const envMap = properties.get(material).envMap;
		if (envMap) {
			uniforms.envMap.value = envMap;
			uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
			uniforms.reflectivity.value = material.reflectivity;
			uniforms.ior.value = material.ior;
			uniforms.refractionRatio.value = material.refractionRatio;
		}
		if (material.lightMap) {
			uniforms.lightMap.value = material.lightMap;

			// artist-friendly light intensity scaling factor
			const scaleFactor = renderer.physicallyCorrectLights !== true ? Math.PI : 1;
			uniforms.lightMapIntensity.value = material.lightMapIntensity * scaleFactor;
		}
		if (material.aoMap) {
			uniforms.aoMap.value = material.aoMap;
			uniforms.aoMapIntensity.value = material.aoMapIntensity;
		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. specular map
		// 3. displacementMap map
		// 4. normal map
		// 5. bump map
		// 6. roughnessMap map
		// 7. metalnessMap map
		// 8. alphaMap map
		// 9. emissiveMap map
		// 10. clearcoat map
		// 11. clearcoat normal map
		// 12. clearcoat roughnessMap map
		// 13. iridescence map
		// 14. iridescence thickness map
		// 15. specular intensity map
		// 16. specular tint map
		// 17. transmission map
		// 18. thickness map

		let uvScaleMap;
		if (material.map) {
			uvScaleMap = material.map;
		} else if (material.specularMap) {
			uvScaleMap = material.specularMap;
		} else if (material.displacementMap) {
			uvScaleMap = material.displacementMap;
		} else if (material.normalMap) {
			uvScaleMap = material.normalMap;
		} else if (material.bumpMap) {
			uvScaleMap = material.bumpMap;
		} else if (material.roughnessMap) {
			uvScaleMap = material.roughnessMap;
		} else if (material.metalnessMap) {
			uvScaleMap = material.metalnessMap;
		} else if (material.alphaMap) {
			uvScaleMap = material.alphaMap;
		} else if (material.emissiveMap) {
			uvScaleMap = material.emissiveMap;
		} else if (material.clearcoatMap) {
			uvScaleMap = material.clearcoatMap;
		} else if (material.clearcoatNormalMap) {
			uvScaleMap = material.clearcoatNormalMap;
		} else if (material.clearcoatRoughnessMap) {
			uvScaleMap = material.clearcoatRoughnessMap;
		} else if (material.iridescenceMap) {
			uvScaleMap = material.iridescenceMap;
		} else if (material.iridescenceThicknessMap) {
			uvScaleMap = material.iridescenceThicknessMap;
		} else if (material.specularIntensityMap) {
			uvScaleMap = material.specularIntensityMap;
		} else if (material.specularColorMap) {
			uvScaleMap = material.specularColorMap;
		} else if (material.transmissionMap) {
			uvScaleMap = material.transmissionMap;
		} else if (material.thicknessMap) {
			uvScaleMap = material.thicknessMap;
		} else if (material.sheenColorMap) {
			uvScaleMap = material.sheenColorMap;
		} else if (material.sheenRoughnessMap) {
			uvScaleMap = material.sheenRoughnessMap;
		}
		if (uvScaleMap !== undefined) {
			// backwards compatibility
			if (uvScaleMap.isWebGLRenderTarget) {
				uvScaleMap = uvScaleMap.texture;
			}
			if (uvScaleMap.matrixAutoUpdate === true) {
				uvScaleMap.updateMatrix();
			}
			uniforms.uvTransform.value.copy(uvScaleMap.matrix);
		}

		// uv repeat and offset setting priorities for uv2
		// 1. ao map
		// 2. light map

		let uv2ScaleMap;
		if (material.aoMap) {
			uv2ScaleMap = material.aoMap;
		} else if (material.lightMap) {
			uv2ScaleMap = material.lightMap;
		}
		if (uv2ScaleMap !== undefined) {
			// backwards compatibility
			if (uv2ScaleMap.isWebGLRenderTarget) {
				uv2ScaleMap = uv2ScaleMap.texture;
			}
			if (uv2ScaleMap.matrixAutoUpdate === true) {
				uv2ScaleMap.updateMatrix();
			}
			uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
		}
	}
	function refreshUniformsLine(uniforms, material) {
		uniforms.diffuse.value.copy(material.color);
		uniforms.opacity.value = material.opacity;
	}
	function refreshUniformsDash(uniforms, material) {
		uniforms.dashSize.value = material.dashSize;
		uniforms.totalSize.value = material.dashSize + material.gapSize;
		uniforms.scale.value = material.scale;
	}
	function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
		uniforms.diffuse.value.copy(material.color);
		uniforms.opacity.value = material.opacity;
		uniforms.size.value = material.size * pixelRatio;
		uniforms.scale.value = height * 0.5;
		if (material.map) {
			uniforms.map.value = material.map;
		}
		if (material.alphaMap) {
			uniforms.alphaMap.value = material.alphaMap;
		}
		if (material.alphaTest > 0) {
			uniforms.alphaTest.value = material.alphaTest;
		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. alpha map

		let uvScaleMap;
		if (material.map) {
			uvScaleMap = material.map;
		} else if (material.alphaMap) {
			uvScaleMap = material.alphaMap;
		}
		if (uvScaleMap !== undefined) {
			if (uvScaleMap.matrixAutoUpdate === true) {
				uvScaleMap.updateMatrix();
			}
			uniforms.uvTransform.value.copy(uvScaleMap.matrix);
		}
	}
	function refreshUniformsSprites(uniforms, material) {
		uniforms.diffuse.value.copy(material.color);
		uniforms.opacity.value = material.opacity;
		uniforms.rotation.value = material.rotation;
		if (material.map) {
			uniforms.map.value = material.map;
		}
		if (material.alphaMap) {
			uniforms.alphaMap.value = material.alphaMap;
		}
		if (material.alphaTest > 0) {
			uniforms.alphaTest.value = material.alphaTest;
		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. alpha map

		let uvScaleMap;
		if (material.map) {
			uvScaleMap = material.map;
		} else if (material.alphaMap) {
			uvScaleMap = material.alphaMap;
		}
		if (uvScaleMap !== undefined) {
			if (uvScaleMap.matrixAutoUpdate === true) {
				uvScaleMap.updateMatrix();
			}
			uniforms.uvTransform.value.copy(uvScaleMap.matrix);
		}
	}
	function refreshUniformsPhong(uniforms, material) {
		uniforms.specular.value.copy(material.specular);
		uniforms.shininess.value = Math.max(material.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )
	}

	function refreshUniformsToon(uniforms, material) {
		if (material.gradientMap) {
			uniforms.gradientMap.value = material.gradientMap;
		}
	}
	function refreshUniformsStandard(uniforms, material) {
		uniforms.roughness.value = material.roughness;
		uniforms.metalness.value = material.metalness;
		if (material.roughnessMap) {
			uniforms.roughnessMap.value = material.roughnessMap;
		}
		if (material.metalnessMap) {
			uniforms.metalnessMap.value = material.metalnessMap;
		}
		const envMap = properties.get(material).envMap;
		if (envMap) {
			//uniforms.envMap.value = material.envMap; // part of uniforms common
			uniforms.envMapIntensity.value = material.envMapIntensity;
		}
	}
	function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
		uniforms.ior.value = material.ior; // also part of uniforms common

		if (material.sheen > 0) {
			uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);
			uniforms.sheenRoughness.value = material.sheenRoughness;
			if (material.sheenColorMap) {
				uniforms.sheenColorMap.value = material.sheenColorMap;
			}
			if (material.sheenRoughnessMap) {
				uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;
			}
		}
		if (material.clearcoat > 0) {
			uniforms.clearcoat.value = material.clearcoat;
			uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
			if (material.clearcoatMap) {
				uniforms.clearcoatMap.value = material.clearcoatMap;
			}
			if (material.clearcoatRoughnessMap) {
				uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
			}
			if (material.clearcoatNormalMap) {
				uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
				uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
				if (material.side === BackSide) {
					uniforms.clearcoatNormalScale.value.negate();
				}
			}
		}
		if (material.iridescence > 0) {
			uniforms.iridescence.value = material.iridescence;
			uniforms.iridescenceIOR.value = material.iridescenceIOR;
			uniforms.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[0];
			uniforms.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[1];
			if (material.iridescenceMap) {
				uniforms.iridescenceMap.value = material.iridescenceMap;
			}
			if (material.iridescenceThicknessMap) {
				uniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap;
			}
		}
		if (material.transmission > 0) {
			uniforms.transmission.value = material.transmission;
			uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
			uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
			if (material.transmissionMap) {
				uniforms.transmissionMap.value = material.transmissionMap;
			}
			uniforms.thickness.value = material.thickness;
			if (material.thicknessMap) {
				uniforms.thicknessMap.value = material.thicknessMap;
			}
			uniforms.attenuationDistance.value = material.attenuationDistance;
			uniforms.attenuationColor.value.copy(material.attenuationColor);
		}
		uniforms.specularIntensity.value = material.specularIntensity;
		uniforms.specularColor.value.copy(material.specularColor);
		if (material.specularIntensityMap) {
			uniforms.specularIntensityMap.value = material.specularIntensityMap;
		}
		if (material.specularColorMap) {
			uniforms.specularColorMap.value = material.specularColorMap;
		}
	}
	function refreshUniformsMatcap(uniforms, material) {
		if (material.matcap) {
			uniforms.matcap.value = material.matcap;
		}
	}
	function refreshUniformsDistance(uniforms, material) {
		uniforms.referencePosition.value.copy(material.referencePosition);
		uniforms.nearDistance.value = material.nearDistance;
		uniforms.farDistance.value = material.farDistance;
	}
	return {
		refreshFogUniforms: refreshFogUniforms,
		refreshMaterialUniforms: refreshMaterialUniforms
	};
}

function WebGLUniformsGroups(gl, info, capabilities, state) {
	let buffers = {};
	let updateList = {};
	let allocatedBindingPoints = [];
	const maxBindingPoints = capabilities.isWebGL2 ? gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS) : 0; // binding points are global whereas block indices are per shader program

	function bind(uniformsGroup, program) {
		const webglProgram = program.program;
		state.uniformBlockBinding(uniformsGroup, webglProgram);
	}
	function update(uniformsGroup, program) {
		let buffer = buffers[uniformsGroup.id];
		if (buffer === undefined) {
			prepareUniformsGroup(uniformsGroup);
			buffer = createBuffer(uniformsGroup);
			buffers[uniformsGroup.id] = buffer;
			uniformsGroup.addEventListener('dispose', onUniformsGroupsDispose);
		}

		// ensure to update the binding points/block indices mapping for this program

		const webglProgram = program.program;
		state.updateUBOMapping(uniformsGroup, webglProgram);

		// update UBO once per frame

		const frame = info.render.frame;
		if (updateList[uniformsGroup.id] !== frame) {
			updateBufferData(uniformsGroup);
			updateList[uniformsGroup.id] = frame;
		}
	}
	function createBuffer(uniformsGroup) {
		// the setup of an UBO is independent of a particular shader program but global

		const bindingPointIndex = allocateBindingPointIndex();
		uniformsGroup.__bindingPointIndex = bindingPointIndex;
		const buffer = gl.createBuffer();
		const size = uniformsGroup.__size;
		const usage = uniformsGroup.usage;
		gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);
		gl.bufferData(gl.UNIFORM_BUFFER, size, usage);
		gl.bindBuffer(gl.UNIFORM_BUFFER, null);
		gl.bindBufferBase(gl.UNIFORM_BUFFER, bindingPointIndex, buffer);
		return buffer;
	}
	function allocateBindingPointIndex() {
		for (let i = 0; i < maxBindingPoints; i++) {
			if (allocatedBindingPoints.indexOf(i) === -1) {
				allocatedBindingPoints.push(i);
				return i;
			}
		}
		console.error('THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.');
		return 0;
	}
	function updateBufferData(uniformsGroup) {
		const buffer = buffers[uniformsGroup.id];
		const uniforms = uniformsGroup.uniforms;
		const cache = uniformsGroup.__cache;
		gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);
		for (let i = 0, il = uniforms.length; i < il; i++) {
			const uniform = uniforms[i];

			// partly update the buffer if necessary

			if (hasUniformChanged(uniform, i, cache) === true) {
				const value = uniform.value;
				const offset = uniform.__offset;
				if (typeof value === 'number') {
					uniform.__data[0] = value;
					gl.bufferSubData(gl.UNIFORM_BUFFER, offset, uniform.__data);
				} else {
					if (uniform.value.isMatrix3) {
						// manually converting 3x3 to 3x4

						uniform.__data[0] = uniform.value.elements[0];
						uniform.__data[1] = uniform.value.elements[1];
						uniform.__data[2] = uniform.value.elements[2];
						uniform.__data[3] = uniform.value.elements[0];
						uniform.__data[4] = uniform.value.elements[3];
						uniform.__data[5] = uniform.value.elements[4];
						uniform.__data[6] = uniform.value.elements[5];
						uniform.__data[7] = uniform.value.elements[0];
						uniform.__data[8] = uniform.value.elements[6];
						uniform.__data[9] = uniform.value.elements[7];
						uniform.__data[10] = uniform.value.elements[8];
						uniform.__data[11] = uniform.value.elements[0];
					} else {
						value.toArray(uniform.__data);
					}
					gl.bufferSubData(gl.UNIFORM_BUFFER, offset, uniform.__data);
				}
			}
		}
		gl.bindBuffer(gl.UNIFORM_BUFFER, null);
	}
	function hasUniformChanged(uniform, index, cache) {
		const value = uniform.value;
		if (cache[index] === undefined) {
			// cache entry does not exist so far

			if (typeof value === 'number') {
				cache[index] = value;
			} else {
				cache[index] = value.clone();
			}
			return true;
		} else {
			// compare current value with cached entry

			if (typeof value === 'number') {
				if (cache[index] !== value) {
					cache[index] = value;
					return true;
				}
			} else {
				const cachedObject = cache[index];
				if (cachedObject.equals(value) === false) {
					cachedObject.copy(value);
					return true;
				}
			}
		}
		return false;
	}
	function prepareUniformsGroup(uniformsGroup) {
		// determine total buffer size according to the STD140 layout
		// Hint: STD140 is the only supported layout in WebGL 2

		const uniforms = uniformsGroup.uniforms;
		let offset = 0; // global buffer offset in bytes
		const chunkSize = 16; // size of a chunk in bytes
		let chunkOffset = 0; // offset within a single chunk in bytes

		for (let i = 0, l = uniforms.length; i < l; i++) {
			const uniform = uniforms[i];
			const info = getUniformSize(uniform);

			// the following two properties will be used for partial buffer updates

			uniform.__data = new Float32Array(info.storage / Float32Array.BYTES_PER_ELEMENT);
			uniform.__offset = offset;

			//

			if (i > 0) {
				chunkOffset = offset % chunkSize;
				const remainingSizeInChunk = chunkSize - chunkOffset;

				// check for chunk overflow

				if (chunkOffset !== 0 && remainingSizeInChunk - info.boundary < 0) {
					// add padding and adjust offset

					offset += chunkSize - chunkOffset;
					uniform.__offset = offset;
				}
			}
			offset += info.storage;
		}

		// ensure correct final padding

		chunkOffset = offset % chunkSize;
		if (chunkOffset > 0) offset += chunkSize - chunkOffset;

		//

		uniformsGroup.__size = offset;
		uniformsGroup.__cache = {};
		return this;
	}
	function getUniformSize(uniform) {
		const value = uniform.value;
		const info = {
			boundary: 0,
			// bytes
			storage: 0 // bytes
		};

		// determine sizes according to STD140

		if (typeof value === 'number') {
			// float/int

			info.boundary = 4;
			info.storage = 4;
		} else if (value.isVector2) {
			// vec2

			info.boundary = 8;
			info.storage = 8;
		} else if (value.isVector3 || value.isColor) {
			// vec3

			info.boundary = 16;
			info.storage = 12; // evil: vec3 must start on a 16-byte boundary but it only consumes 12 bytes
		} else if (value.isVector4) {
			// vec4

			info.boundary = 16;
			info.storage = 16;
		} else if (value.isMatrix3) {
			// mat3 (in STD140 a 3x3 matrix is represented as 3x4)

			info.boundary = 48;
			info.storage = 48;
		} else if (value.isMatrix4) {
			// mat4

			info.boundary = 64;
			info.storage = 64;
		} else if (value.isTexture) {
			console.warn('THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.');
		} else {
			console.warn('THREE.WebGLRenderer: Unsupported uniform value type.', value);
		}
		return info;
	}
	function onUniformsGroupsDispose(event) {
		const uniformsGroup = event.target;
		uniformsGroup.removeEventListener('dispose', onUniformsGroupsDispose);
		const index = allocatedBindingPoints.indexOf(uniformsGroup.__bindingPointIndex);
		allocatedBindingPoints.splice(index, 1);
		gl.deleteBuffer(buffers[uniformsGroup.id]);
		delete buffers[uniformsGroup.id];
		delete updateList[uniformsGroup.id];
	}
	function dispose() {
		for (const id in buffers) {
			gl.deleteBuffer(buffers[id]);
		}
		allocatedBindingPoints = [];
		buffers = {};
		updateList = {};
	}
	return {
		bind: bind,
		update: update,
		dispose: dispose
	};
}

function createCanvasElement() {
	const canvas = createElementNS('canvas');
	canvas.style.display = 'block';
	return canvas;
}
function WebGLRenderer(parameters = {}) {
	this.isWebGLRenderer = true;
	const _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement(),
		_context = parameters.context !== undefined ? parameters.context : null,
		_depth = parameters.depth !== undefined ? parameters.depth : true,
		_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
		_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
		_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
		_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
		_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
		_failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;
	let _alpha;
	if (_context !== null) {
		_alpha = _context.getContextAttributes().alpha;
	} else {
		_alpha = parameters.alpha !== undefined ? parameters.alpha : false;
	}
	let currentRenderList = null;
	let currentRenderState = null;

	// render() can be called from within a callback triggered by another render.
	// We track this so that the nested render call gets its list and state isolated from the parent render call.

	const renderListStack = [];
	const renderStateStack = [];

	// public properties

	this.domElement = _canvas;

	// Debug configuration container
	this.debug = {
		/**
		 * Enables error checking and reporting when shader programs are being compiled
		 * @type {boolean}
		 */
		checkShaderErrors: true
	};

	// clearing

	this.autoClear = true;
	this.autoClearColor = true;
	this.autoClearDepth = true;
	this.autoClearStencil = true;

	// scene graph

	this.sortObjects = true;

	// user-defined clipping

	this.clippingPlanes = [];
	this.localClippingEnabled = false;

	// physically based shading

	this.outputEncoding = LinearEncoding;

	// physical lights

	this.physicallyCorrectLights = false;

	// tone mapping

	this.toneMapping = NoToneMapping;
	this.toneMappingExposure = 1.0;

	//

	Object.defineProperties(this, {
		// @deprecated since r136, 0e21088102b4de7e0a0a33140620b7a3424b9e6d

		gammaFactor: {
			get: function () {
				console.warn('THREE.WebGLRenderer: .gammaFactor has been removed.');
				return 2;
			},
			set: function () {
				console.warn('THREE.WebGLRenderer: .gammaFactor has been removed.');
			}
		}
	});

	// internal properties

	const _this = this;
	let _isContextLost = false;

	// internal state cache

	let _currentActiveCubeFace = 0;
	let _currentActiveMipmapLevel = 0;
	let _currentRenderTarget = null;
	let _currentMaterialId = -1;
	let _currentCamera = null;
	const _currentViewport = new Vector4();
	const _currentScissor = new Vector4();
	let _currentScissorTest = null;

	//

	let _width = _canvas.width;
	let _height = _canvas.height;
	let _pixelRatio = 1;
	let _opaqueSort = null;
	let _transparentSort = null;
	const _viewport = new Vector4(0, 0, _width, _height);
	const _scissor = new Vector4(0, 0, _width, _height);
	let _scissorTest = false;

	// frustum

	const _frustum = new Frustum();

	// clipping

	let _clippingEnabled = false;
	let _localClippingEnabled = false;

	// transmission

	let _transmissionRenderTarget = null;

	// camera matrices cache

	const _projScreenMatrix = new Matrix4();
	const _vector2 = new Vector2();
	const _vector3 = new Vector3();
	const _emptyScene = {
		background: null,
		fog: null,
		environment: null,
		overrideMaterial: null,
		isScene: true
	};
	function getTargetPixelRatio() {
		return _currentRenderTarget === null ? _pixelRatio : 1;
	}

	// initialize

	let _gl = _context;
	function getContext(contextNames, contextAttributes) {
		for (let i = 0; i < contextNames.length; i++) {
			const contextName = contextNames[i];
			const context = _canvas.getContext(contextName, contextAttributes);
			if (context !== null) return context;
		}
		return null;
	}
	try {
		const contextAttributes = {
			alpha: true,
			depth: _depth,
			stencil: _stencil,
			antialias: _antialias,
			premultipliedAlpha: _premultipliedAlpha,
			preserveDrawingBuffer: _preserveDrawingBuffer,
			powerPreference: _powerPreference,
			failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
		};

		// OffscreenCanvas does not have setAttribute, see #22811
		if ('setAttribute' in _canvas) _canvas.setAttribute('data-engine', `three.js r${REVISION}`);

		// event listeners must be registered before WebGL context is created, see #12753
		_canvas.addEventListener('webglcontextlost', onContextLost, false);
		_canvas.addEventListener('webglcontextrestored', onContextRestore, false);
		_canvas.addEventListener('webglcontextcreationerror', onContextCreationError, false);
		if (_gl === null) {
			const contextNames = ['webgl2', 'webgl', 'experimental-webgl'];
			if (_this.isWebGL1Renderer === true) {
				contextNames.shift();
			}
			_gl = getContext(contextNames, contextAttributes);
			if (_gl === null) {
				if (getContext(contextNames)) {
					throw new Error('Error creating WebGL context with your selected attributes.');
				} else {
					throw new Error('Error creating WebGL context.');
				}
			}
		}

		// Some experimental-webgl implementations do not have getShaderPrecisionFormat

		if (_gl.getShaderPrecisionFormat === undefined) {
			_gl.getShaderPrecisionFormat = function () {
				return {
					'rangeMin': 1,
					'rangeMax': 1,
					'precision': 1
				};
			};
		}
	} catch (error) {
		console.error('THREE.WebGLRenderer: ' + error.message);
		throw error;
	}
	let extensions, capabilities, state, info;
	let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
	let programCache, materials, renderLists, renderStates, clipping, shadowMap;
	let background, morphtargets, bufferRenderer, indexedBufferRenderer;
	let utils, bindingStates, uniformsGroups;
	function initGLContext() {
		extensions = new WebGLExtensions(_gl);
		capabilities = new WebGLCapabilities(_gl, extensions, parameters);
		extensions.init(capabilities);
		utils = new WebGLUtils(_gl, extensions, capabilities);
		state = new WebGLState(_gl, extensions, capabilities);
		info = new WebGLInfo(_gl);
		properties = new WebGLProperties();
		textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
		cubemaps = new WebGLCubeMaps(_this);
		cubeuvmaps = new WebGLCubeUVMaps(_this);
		attributes = new WebGLAttributes(_gl, capabilities);
		bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
		geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
		objects = new WebGLObjects(_gl, geometries, attributes, info);
		morphtargets = new WebGLMorphtargets(_gl, capabilities, textures);
		clipping = new WebGLClipping(properties);
		programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);
		materials = new WebGLMaterials(_this, properties);
		renderLists = new WebGLRenderLists();
		renderStates = new WebGLRenderStates(extensions, capabilities);
		background = new WebGLBackground(_this, cubemaps, cubeuvmaps, state, objects, _alpha, _premultipliedAlpha);
		shadowMap = new WebGLShadowMap(_this, objects, capabilities);
		uniformsGroups = new WebGLUniformsGroups(_gl, info, capabilities, state);
		bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
		indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
		info.programs = programCache.programs;
		_this.capabilities = capabilities;
		_this.extensions = extensions;
		_this.properties = properties;
		_this.renderLists = renderLists;
		_this.shadowMap = shadowMap;
		_this.state = state;
		_this.info = info;
	}
	initGLContext();

	// xr

	const xr = new WebXRManager(_this, _gl);
	this.xr = xr;

	// API

	this.getContext = function () {
		return _gl;
	};
	this.getContextAttributes = function () {
		return _gl.getContextAttributes();
	};
	this.forceContextLoss = function () {
		const extension = extensions.get('WEBGL_lose_context');
		if (extension) extension.loseContext();
	};
	this.forceContextRestore = function () {
		const extension = extensions.get('WEBGL_lose_context');
		if (extension) extension.restoreContext();
	};
	this.getPixelRatio = function () {
		return _pixelRatio;
	};
	this.setPixelRatio = function (value) {
		if (value === undefined) return;
		_pixelRatio = value;
		this.setSize(_width, _height, false);
	};
	this.getSize = function (target) {
		return target.set(_width, _height);
	};
	this.setSize = function (width, height, updateStyle) {
		if (xr.isPresenting) {
			console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');
			return;
		}
		_width = width;
		_height = height;
		_canvas.width = Math.floor(width * _pixelRatio);
		_canvas.height = Math.floor(height * _pixelRatio);
		if (updateStyle !== false) {
			_canvas.style.width = width + 'px';
			_canvas.style.height = height + 'px';
		}
		this.setViewport(0, 0, width, height);
	};
	this.getDrawingBufferSize = function (target) {
		return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
	};
	this.setDrawingBufferSize = function (width, height, pixelRatio) {
		_width = width;
		_height = height;
		_pixelRatio = pixelRatio;
		_canvas.width = Math.floor(width * pixelRatio);
		_canvas.height = Math.floor(height * pixelRatio);
		this.setViewport(0, 0, width, height);
	};
	this.getCurrentViewport = function (target) {
		return target.copy(_currentViewport);
	};
	this.getViewport = function (target) {
		return target.copy(_viewport);
	};
	this.setViewport = function (x, y, width, height) {
		if (x.isVector4) {
			_viewport.set(x.x, x.y, x.z, x.w);
		} else {
			_viewport.set(x, y, width, height);
		}
		state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
	};
	this.getScissor = function (target) {
		return target.copy(_scissor);
	};
	this.setScissor = function (x, y, width, height) {
		if (x.isVector4) {
			_scissor.set(x.x, x.y, x.z, x.w);
		} else {
			_scissor.set(x, y, width, height);
		}
		state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
	};
	this.getScissorTest = function () {
		return _scissorTest;
	};
	this.setScissorTest = function (boolean) {
		state.setScissorTest(_scissorTest = boolean);
	};
	this.setOpaqueSort = function (method) {
		_opaqueSort = method;
	};
	this.setTransparentSort = function (method) {
		_transparentSort = method;
	};

	// Clearing

	this.getClearColor = function (target) {
		return target.copy(background.getClearColor());
	};
	this.setClearColor = function () {
		background.setClearColor.apply(background, arguments);
	};
	this.getClearAlpha = function () {
		return background.getClearAlpha();
	};
	this.setClearAlpha = function () {
		background.setClearAlpha.apply(background, arguments);
	};
	this.clear = function (color = true, depth = true, stencil = true) {
		let bits = 0;
		if (color) bits |= _gl.COLOR_BUFFER_BIT;
		if (depth) bits |= _gl.DEPTH_BUFFER_BIT;
		if (stencil) bits |= _gl.STENCIL_BUFFER_BIT;
		_gl.clear(bits);
	};
	this.clearColor = function () {
		this.clear(true, false, false);
	};
	this.clearDepth = function () {
		this.clear(false, true, false);
	};
	this.clearStencil = function () {
		this.clear(false, false, true);
	};

	//

	this.dispose = function () {
		_canvas.removeEventListener('webglcontextlost', onContextLost, false);
		_canvas.removeEventListener('webglcontextrestored', onContextRestore, false);
		_canvas.removeEventListener('webglcontextcreationerror', onContextCreationError, false);
		renderLists.dispose();
		renderStates.dispose();
		properties.dispose();
		cubemaps.dispose();
		cubeuvmaps.dispose();
		objects.dispose();
		bindingStates.dispose();
		uniformsGroups.dispose();
		programCache.dispose();
		xr.dispose();
		xr.removeEventListener('sessionstart', onXRSessionStart);
		xr.removeEventListener('sessionend', onXRSessionEnd);
		if (_transmissionRenderTarget) {
			_transmissionRenderTarget.dispose();
			_transmissionRenderTarget = null;
		}
		animation.stop();
	};

	// Events

	function onContextLost(event) {
		event.preventDefault();
		console.log('THREE.WebGLRenderer: Context Lost.');
		_isContextLost = true;
	}
	function /* event */
	onContextRestore() {
		console.log('THREE.WebGLRenderer: Context Restored.');
		_isContextLost = false;
		const infoAutoReset = info.autoReset;
		const shadowMapEnabled = shadowMap.enabled;
		const shadowMapAutoUpdate = shadowMap.autoUpdate;
		const shadowMapNeedsUpdate = shadowMap.needsUpdate;
		const shadowMapType = shadowMap.type;
		initGLContext();
		info.autoReset = infoAutoReset;
		shadowMap.enabled = shadowMapEnabled;
		shadowMap.autoUpdate = shadowMapAutoUpdate;
		shadowMap.needsUpdate = shadowMapNeedsUpdate;
		shadowMap.type = shadowMapType;
	}
	function onContextCreationError(event) {
		console.error('THREE.WebGLRenderer: A WebGL context could not be created. Reason: ', event.statusMessage);
	}
	function onMaterialDispose(event) {
		const material = event.target;
		material.removeEventListener('dispose', onMaterialDispose);
		deallocateMaterial(material);
	}

	// Buffer deallocation

	function deallocateMaterial(material) {
		releaseMaterialProgramReferences(material);
		properties.remove(material);
	}
	function releaseMaterialProgramReferences(material) {
		const programs = properties.get(material).programs;
		if (programs !== undefined) {
			programs.forEach(function (program) {
				programCache.releaseProgram(program);
			});
			if (material.isShaderMaterial) {
				programCache.releaseShaderCache(material);
			}
		}
	}

	// Buffer rendering

	this.renderBufferDirect = function (camera, scene, geometry, material, object, group) {
		if (scene === null) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)

		const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
		const program = setProgram(camera, scene, geometry, material, object);
		state.setMaterial(material, frontFaceCW);

		//

		let index = geometry.index;
		const position = geometry.attributes.position;

		//

		if (index === null) {
			if (position === undefined || position.count === 0) return;
		} else if (index.count === 0) {
			return;
		}

		//

		let rangeFactor = 1;
		if (material.wireframe === true) {
			index = geometries.getWireframeAttribute(geometry);
			rangeFactor = 2;
		}
		bindingStates.setup(object, material, program, geometry, index);
		let attribute;
		let renderer = bufferRenderer;
		if (index !== null) {
			attribute = attributes.get(index);
			renderer = indexedBufferRenderer;
			renderer.setIndex(attribute);
		}

		//

		const dataCount = index !== null ? index.count : position.count;
		const rangeStart = geometry.drawRange.start * rangeFactor;
		const rangeCount = geometry.drawRange.count * rangeFactor;
		const groupStart = group !== null ? group.start * rangeFactor : 0;
		const groupCount = group !== null ? group.count * rangeFactor : Infinity;
		const drawStart = Math.max(rangeStart, groupStart);
		const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
		const drawCount = Math.max(0, drawEnd - drawStart + 1);
		if (drawCount === 0) return;

		//

		if (object.isMesh) {
			if (material.wireframe === true) {
				state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
				renderer.setMode(_gl.LINES);
			} else {
				renderer.setMode(_gl.TRIANGLES);
			}
		} else if (object.isLine) {
			let lineWidth = material.linewidth;
			if (lineWidth === undefined) lineWidth = 1; // Not using Line*Material

			state.setLineWidth(lineWidth * getTargetPixelRatio());
			if (object.isLineSegments) {
				renderer.setMode(_gl.LINES);
			} else if (object.isLineLoop) {
				renderer.setMode(_gl.LINE_LOOP);
			} else {
				renderer.setMode(_gl.LINE_STRIP);
			}
		} else if (object.isPoints) {
			renderer.setMode(_gl.POINTS);
		} else if (object.isSprite) {
			renderer.setMode(_gl.TRIANGLES);
		}
		if (object.isInstancedMesh) {
			renderer.renderInstances(drawStart, drawCount, object.count);
		} else if (geometry.isInstancedBufferGeometry) {
			const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
			renderer.renderInstances(drawStart, drawCount, instanceCount);
		} else {
			renderer.render(drawStart, drawCount);
		}
	};

	// Compile

	this.compile = function (scene, camera) {
		function prepare(material, scene, object) {
			if (material.transparent === true && material.side === DoubleSide) {
				material.side = BackSide;
				material.needsUpdate = true;
				getProgram(material, scene, object);
				material.side = FrontSide;
				material.needsUpdate = true;
				getProgram(material, scene, object);
				material.side = DoubleSide;
			} else {
				getProgram(material, scene, object);
			}
		}
		currentRenderState = renderStates.get(scene);
		currentRenderState.init();
		renderStateStack.push(currentRenderState);
		scene.traverseVisible(function (object) {
			if (object.isLight && object.layers.test(camera.layers)) {
				currentRenderState.pushLight(object);
				if (object.castShadow) {
					currentRenderState.pushShadow(object);
				}
			}
		});
		currentRenderState.setupLights(_this.physicallyCorrectLights);
		scene.traverse(function (object) {
			const material = object.material;
			if (material) {
				if (Array.isArray(material)) {
					for (let i = 0; i < material.length; i++) {
						const material2 = material[i];
						prepare(material2, scene, object);
					}
				} else {
					prepare(material, scene, object);
				}
			}
		});
		renderStateStack.pop();
		currentRenderState = null;
	};

	// Animation Loop

	let onAnimationFrameCallback = null;
	function onAnimationFrame(time) {
		if (onAnimationFrameCallback) onAnimationFrameCallback(time);
	}
	function onXRSessionStart() {
		animation.stop();
	}
	function onXRSessionEnd() {
		animation.start();
	}
	const animation = new WebGLAnimation();
	animation.setAnimationLoop(onAnimationFrame);
	if (typeof self !== 'undefined') animation.setContext(self);
	this.setAnimationLoop = function (callback) {
		onAnimationFrameCallback = callback;
		xr.setAnimationLoop(callback);
		callback === null ? animation.stop() : animation.start();
	};
	xr.addEventListener('sessionstart', onXRSessionStart);
	xr.addEventListener('sessionend', onXRSessionEnd);

	// Rendering

	this.render = function (scene, camera) {
		if (camera !== undefined && camera.isCamera !== true) {
			console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
			return;
		}
		if (_isContextLost === true) return;

		// update scene graph

		if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld();

		// update camera matrices and frustum

		if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld();
		if (xr.enabled === true && xr.isPresenting === true) {
			if (xr.cameraAutoUpdate === true) xr.updateCamera(camera);
			camera = xr.getCamera(); // use XR camera for rendering
		}

		//
		if (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
		currentRenderState = renderStates.get(scene, renderStateStack.length);
		currentRenderState.init();
		renderStateStack.push(currentRenderState);
		_projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
		_frustum.setFromProjectionMatrix(_projScreenMatrix);
		_localClippingEnabled = this.localClippingEnabled;
		_clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
		currentRenderList = renderLists.get(scene, renderListStack.length);
		currentRenderList.init();
		renderListStack.push(currentRenderList);
		projectObject(scene, camera, 0, _this.sortObjects);
		currentRenderList.finish();
		if (_this.sortObjects === true) {
			currentRenderList.sort(_opaqueSort, _transparentSort);
		}

		//

		if (_clippingEnabled === true) clipping.beginShadows();
		const shadowsArray = currentRenderState.state.shadowsArray;
		shadowMap.render(shadowsArray, scene, camera);
		if (_clippingEnabled === true) clipping.endShadows();

		//

		if (this.info.autoReset === true) this.info.reset();

		//

		background.render(currentRenderList, scene);

		// render scene

		currentRenderState.setupLights(_this.physicallyCorrectLights);
		if (camera.isArrayCamera) {
			const cameras = camera.cameras;
			for (let i = 0, l = cameras.length; i < l; i++) {
				const camera2 = cameras[i];
				renderScene(currentRenderList, scene, camera2, camera2.viewport);
			}
		} else {
			renderScene(currentRenderList, scene, camera);
		}

		//

		if (_currentRenderTarget !== null) {
			// resolve multisample renderbuffers to a single-sample texture if necessary

			textures.updateMultisampleRenderTarget(_currentRenderTarget);

			// Generate mipmap if we're using any kind of mipmap filtering

			textures.updateRenderTargetMipmap(_currentRenderTarget);
		}

		//

		if (scene.isScene === true) scene.onAfterRender(_this, scene, camera);

		// _gl.finish();

		bindingStates.resetDefaultState();
		_currentMaterialId = -1;
		_currentCamera = null;
		renderStateStack.pop();
		if (renderStateStack.length > 0) {
			currentRenderState = renderStateStack[renderStateStack.length - 1];
		} else {
			currentRenderState = null;
		}
		renderListStack.pop();
		if (renderListStack.length > 0) {
			currentRenderList = renderListStack[renderListStack.length - 1];
		} else {
			currentRenderList = null;
		}
	};
	function projectObject(object, camera, groupOrder, sortObjects) {
		if (object.visible === false) return;
		const visible = object.layers.test(camera.layers);
		if (visible) {
			if (object.isGroup) {
				groupOrder = object.renderOrder;
			} else if (object.isLOD) {
				if (object.autoUpdate === true) object.update(camera);
			} else if (object.isLight) {
				currentRenderState.pushLight(object);
				if (object.castShadow) {
					currentRenderState.pushShadow(object);
				}
			} else if (object.isSprite) {
				if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
					if (sortObjects) {
						_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
					}
					const geometry = objects.update(object);
					const material = object.material;
					if (material.visible) {
						currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
					}
				}
			} else if (object.isMesh || object.isLine || object.isPoints) {
				if (object.isSkinnedMesh) {
					// update skeleton only once in a frame

					if (object.skeleton.frame !== info.render.frame) {
						object.skeleton.update();
						object.skeleton.frame = info.render.frame;
					}
				}
				if (!object.frustumCulled || _frustum.intersectsObject(object)) {
					if (sortObjects) {
						_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
					}
					const geometry = objects.update(object);
					const material = object.material;
					if (Array.isArray(material)) {
						const groups = geometry.groups;
						for (let i = 0, l = groups.length; i < l; i++) {
							const group = groups[i];
							const groupMaterial = material[group.materialIndex];
							if (groupMaterial && groupMaterial.visible) {
								currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
							}
						}
					} else if (material.visible) {
						currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
					}
				}
			}
		}
		const children = object.children;
		for (let i = 0, l = children.length; i < l; i++) {
			projectObject(children[i], camera, groupOrder, sortObjects);
		}
	}
	function renderScene(currentRenderList, scene, camera, viewport) {
		const opaqueObjects = currentRenderList.opaque;
		const transmissiveObjects = currentRenderList.transmissive;
		const transparentObjects = currentRenderList.transparent;
		currentRenderState.setupLightsView(camera);
		if (transmissiveObjects.length > 0) renderTransmissionPass(opaqueObjects, scene, camera);
		if (viewport) state.viewport(_currentViewport.copy(viewport));
		if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);
		if (transmissiveObjects.length > 0) renderObjects(transmissiveObjects, scene, camera);
		if (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera);

		// Ensure depth buffer writing is enabled so it can be cleared on next render

		state.buffers.depth.setTest(true);
		state.buffers.depth.setMask(true);
		state.buffers.color.setMask(true);
		state.setPolygonOffset(false);
	}
	function renderTransmissionPass(opaqueObjects, scene, camera) {
		const isWebGL2 = capabilities.isWebGL2;
		if (_transmissionRenderTarget === null) {
			_transmissionRenderTarget = new WebGLRenderTarget(1, 1, {
				generateMipmaps: true,
				type: extensions.has('EXT_color_buffer_half_float') ? HalfFloatType : UnsignedByteType,
				minFilter: LinearMipmapLinearFilter,
				samples: isWebGL2 && _antialias === true ? 4 : 0
			});
		}
		_this.getDrawingBufferSize(_vector2);
		if (isWebGL2) {
			_transmissionRenderTarget.setSize(_vector2.x, _vector2.y);
		} else {
			_transmissionRenderTarget.setSize(floorPowerOfTwo(_vector2.x), floorPowerOfTwo(_vector2.y));
		}

		//

		const currentRenderTarget = _this.getRenderTarget();
		_this.setRenderTarget(_transmissionRenderTarget);
		_this.clear();

		// Turn off the features which can affect the frag color for opaque objects pass.
		// Otherwise they are applied twice in opaque objects pass and transmission objects pass.
		const currentToneMapping = _this.toneMapping;
		_this.toneMapping = NoToneMapping;
		renderObjects(opaqueObjects, scene, camera);
		_this.toneMapping = currentToneMapping;
		textures.updateMultisampleRenderTarget(_transmissionRenderTarget);
		textures.updateRenderTargetMipmap(_transmissionRenderTarget);
		_this.setRenderTarget(currentRenderTarget);
	}
	function renderObjects(renderList, scene, camera) {
		const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
		for (let i = 0, l = renderList.length; i < l; i++) {
			const renderItem = renderList[i];
			const object = renderItem.object;
			const geometry = renderItem.geometry;
			const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
			const group = renderItem.group;
			if (object.layers.test(camera.layers)) {
				renderObject(object, scene, camera, geometry, material, group);
			}
		}
	}
	function renderObject(object, scene, camera, geometry, material, group) {
		object.onBeforeRender(_this, scene, camera, geometry, material, group);
		object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
		object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
		material.onBeforeRender(_this, scene, camera, geometry, object, group);
		if (material.transparent === true && material.side === DoubleSide) {
			material.side = BackSide;
			material.needsUpdate = true;
			_this.renderBufferDirect(camera, scene, geometry, material, object, group);
			material.side = FrontSide;
			material.needsUpdate = true;
			_this.renderBufferDirect(camera, scene, geometry, material, object, group);
			material.side = DoubleSide;
		} else {
			_this.renderBufferDirect(camera, scene, geometry, material, object, group);
		}
		object.onAfterRender(_this, scene, camera, geometry, material, group);
	}
	function getProgram(material, scene, object) {
		if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

		const materialProperties = properties.get(material);
		const lights = currentRenderState.state.lights;
		const shadowsArray = currentRenderState.state.shadowsArray;
		const lightsStateVersion = lights.state.version;
		const parameters = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
		const programCacheKey = programCache.getProgramCacheKey(parameters);
		let programs = materialProperties.programs;

		// always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change

		materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
		materialProperties.fog = scene.fog;
		materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);
		if (programs === undefined) {
			// new material

			material.addEventListener('dispose', onMaterialDispose);
			programs = new Map();
			materialProperties.programs = programs;
		}
		let program = programs.get(programCacheKey);
		if (program !== undefined) {
			// early out if program and light state is identical

			if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
				updateCommonMaterialProperties(material, parameters);
				return program;
			}
		} else {
			parameters.uniforms = programCache.getUniforms(material);
			material.onBuild(object, parameters, _this);
			material.onBeforeCompile(parameters, _this);
			program = programCache.acquireProgram(parameters, programCacheKey);
			programs.set(programCacheKey, program);
			materialProperties.uniforms = parameters.uniforms;
		}
		const uniforms = materialProperties.uniforms;
		if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
			uniforms.clippingPlanes = clipping.uniform;
		}
		updateCommonMaterialProperties(material, parameters);

		// store the light setup it was created for

		materialProperties.needsLights = materialNeedsLights(material);
		materialProperties.lightsStateVersion = lightsStateVersion;
		if (materialProperties.needsLights) {
			// wire up the material to this renderer's lighting state

			uniforms.ambientLightColor.value = lights.state.ambient;
			uniforms.lightProbe.value = lights.state.probe;
			uniforms.directionalLights.value = lights.state.directional;
			uniforms.directionalLightShadows.value = lights.state.directionalShadow;
			uniforms.spotLights.value = lights.state.spot;
			uniforms.spotLightShadows.value = lights.state.spotShadow;
			uniforms.rectAreaLights.value = lights.state.rectArea;
			uniforms.ltc_1.value = lights.state.rectAreaLTC1;
			uniforms.ltc_2.value = lights.state.rectAreaLTC2;
			uniforms.pointLights.value = lights.state.point;
			uniforms.pointLightShadows.value = lights.state.pointShadow;
			uniforms.hemisphereLights.value = lights.state.hemi;
			uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
			uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
			uniforms.spotShadowMap.value = lights.state.spotShadowMap;
			uniforms.spotLightMatrix.value = lights.state.spotLightMatrix;
			uniforms.spotLightMap.value = lights.state.spotLightMap;
			uniforms.pointShadowMap.value = lights.state.pointShadowMap;
			uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
			// TODO (abelnation): add area lights shadow info to uniforms
		}

		const progUniforms = program.getUniforms();
		const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
		materialProperties.currentProgram = program;
		materialProperties.uniformsList = uniformsList;
		return program;
	}
	function updateCommonMaterialProperties(material, parameters) {
		const materialProperties = properties.get(material);
		materialProperties.outputEncoding = parameters.outputEncoding;
		materialProperties.instancing = parameters.instancing;
		materialProperties.skinning = parameters.skinning;
		materialProperties.morphTargets = parameters.morphTargets;
		materialProperties.morphNormals = parameters.morphNormals;
		materialProperties.morphColors = parameters.morphColors;
		materialProperties.morphTargetsCount = parameters.morphTargetsCount;
		materialProperties.numClippingPlanes = parameters.numClippingPlanes;
		materialProperties.numIntersection = parameters.numClipIntersection;
		materialProperties.vertexAlphas = parameters.vertexAlphas;
		materialProperties.vertexTangents = parameters.vertexTangents;
		materialProperties.toneMapping = parameters.toneMapping;
	}
	function setProgram(camera, scene, geometry, material, object) {
		if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

		textures.resetTextureUnits();
		const fog = scene.fog;
		const environment = material.isMeshStandardMaterial ? scene.environment : null;
		const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.encoding : LinearEncoding;
		const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
		const vertexAlphas = material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;
		const vertexTangents = !!material.normalMap && !!geometry.attributes.tangent;
		const morphTargets = !!geometry.morphAttributes.position;
		const morphNormals = !!geometry.morphAttributes.normal;
		const morphColors = !!geometry.morphAttributes.color;
		const toneMapping = material.toneMapped ? _this.toneMapping : NoToneMapping;
		const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
		const morphTargetsCount = morphAttribute !== undefined ? morphAttribute.length : 0;
		const materialProperties = properties.get(material);
		const lights = currentRenderState.state.lights;
		if (_clippingEnabled === true) {
			if (_localClippingEnabled === true || camera !== _currentCamera) {
				const useCache = camera === _currentCamera && material.id === _currentMaterialId;

				// we might want to call this function with some ClippingGroup
				// object instead of the material, once it becomes feasible
				// (#8465, #8379)
				clipping.setState(material, camera, useCache);
			}
		}

		//

		let needsProgramChange = false;
		if (material.version === materialProperties.__version) {
			if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
				needsProgramChange = true;
			} else if (materialProperties.outputEncoding !== encoding) {
				needsProgramChange = true;
			} else if (object.isInstancedMesh && materialProperties.instancing === false) {
				needsProgramChange = true;
			} else if (!object.isInstancedMesh && materialProperties.instancing === true) {
				needsProgramChange = true;
			} else if (object.isSkinnedMesh && materialProperties.skinning === false) {
				needsProgramChange = true;
			} else if (!object.isSkinnedMesh && materialProperties.skinning === true) {
				needsProgramChange = true;
			} else if (materialProperties.envMap !== envMap) {
				needsProgramChange = true;
			} else if (material.fog === true && materialProperties.fog !== fog) {
				needsProgramChange = true;
			} else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
				needsProgramChange = true;
			} else if (materialProperties.vertexAlphas !== vertexAlphas) {
				needsProgramChange = true;
			} else if (materialProperties.vertexTangents !== vertexTangents) {
				needsProgramChange = true;
			} else if (materialProperties.morphTargets !== morphTargets) {
				needsProgramChange = true;
			} else if (materialProperties.morphNormals !== morphNormals) {
				needsProgramChange = true;
			} else if (materialProperties.morphColors !== morphColors) {
				needsProgramChange = true;
			} else if (materialProperties.toneMapping !== toneMapping) {
				needsProgramChange = true;
			} else if (capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount) {
				needsProgramChange = true;
			}
		} else {
			needsProgramChange = true;
			materialProperties.__version = material.version;
		}

		//

		let program = materialProperties.currentProgram;
		if (needsProgramChange === true) {
			program = getProgram(material, scene, object);
		}
		let refreshProgram = false;
		let refreshMaterial = false;
		let refreshLights = false;
		const p_uniforms = program.getUniforms(),
			m_uniforms = materialProperties.uniforms;
		if (state.useProgram(program.program)) {
			refreshProgram = true;
			refreshMaterial = true;
			refreshLights = true;
		}
		if (material.id !== _currentMaterialId) {
			_currentMaterialId = material.id;
			refreshMaterial = true;
		}
		if (refreshProgram || _currentCamera !== camera) {
			p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);
			if (capabilities.logarithmicDepthBuffer) {
				p_uniforms.setValue(_gl, 'logDepthBufFC', 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));
			}
			if (_currentCamera !== camera) {
				_currentCamera = camera;

				// lighting uniforms depend on the camera so enforce an update
				// now, in case this material supports lights - or later, when
				// the next material that does gets activated:

				refreshMaterial = true; // set to true on material change
				refreshLights = true; // remains set until update done
			}

			// load material specific uniforms
			// (shader material also gets them for the sake of genericity)

			if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
				const uCamPos = p_uniforms.map.cameraPosition;
				if (uCamPos !== undefined) {
					uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
				}
			}
			if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
				p_uniforms.setValue(_gl, 'isOrthographic', camera.isOrthographicCamera === true);
			}
			if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || object.isSkinnedMesh) {
				p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);
			}
		}

		// skinning and morph target uniforms must be set even if material didn't change
		// auto-setting of texture unit for bone and morph texture must go before other textures
		// otherwise textures used for skinning and morphing can take over texture units reserved for other material textures

		if (object.isSkinnedMesh) {
			p_uniforms.setOptional(_gl, object, 'bindMatrix');
			p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');
			const skeleton = object.skeleton;
			if (skeleton) {
				if (capabilities.floatVertexTextures) {
					if (skeleton.boneTexture === null) skeleton.computeBoneTexture();
					p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture, textures);
					p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);
				} else {
					console.warn('THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.');
				}
			}
		}
		const morphAttributes = geometry.morphAttributes;
		if (morphAttributes.position !== undefined || morphAttributes.normal !== undefined || morphAttributes.color !== undefined && capabilities.isWebGL2 === true) {
			morphtargets.update(object, geometry, material, program);
		}
		if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
			materialProperties.receiveShadow = object.receiveShadow;
			p_uniforms.setValue(_gl, 'receiveShadow', object.receiveShadow);
		}

		// https://github.com/mrdoob/three.js/pull/24467#issuecomment-1209031512

		if (material.isMeshGouraudMaterial && material.envMap !== null) {
			m_uniforms.envMap.value = envMap;
			m_uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
		}
		if (refreshMaterial) {
			p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);
			if (materialProperties.needsLights) {
				// the current material requires lighting info

				// note: all lighting uniforms are always set correctly
				// they simply reference the renderer's state for their
				// values
				//
				// use the current material's .needsUpdate flags to set
				// the GL state when required

				markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
			}

			// refresh uniforms common to several materials

			if (fog && material.fog === true) {
				materials.refreshFogUniforms(m_uniforms, fog);
			}
			materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget);
			WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
		}
		if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
			WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
			material.uniformsNeedUpdate = false;
		}
		if (material.isSpriteMaterial) {
			p_uniforms.setValue(_gl, 'center', object.center);
		}

		// common matrices

		p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);
		p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);
		p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);

		// UBOs

		if (material.isShaderMaterial || material.isRawShaderMaterial) {
			const groups = material.uniformsGroups;
			for (let i = 0, l = groups.length; i < l; i++) {
				if (capabilities.isWebGL2) {
					const group = groups[i];
					uniformsGroups.update(group, program);
					uniformsGroups.bind(group, program);
				} else {
					console.warn('THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.');
				}
			}
		}
		return program;
	}

	// If uniforms are marked as clean, they don't need to be loaded to the GPU.

	function markUniformsLightsNeedsUpdate(uniforms, value) {
		uniforms.ambientLightColor.needsUpdate = value;
		uniforms.lightProbe.needsUpdate = value;
		uniforms.directionalLights.needsUpdate = value;
		uniforms.directionalLightShadows.needsUpdate = value;
		uniforms.pointLights.needsUpdate = value;
		uniforms.pointLightShadows.needsUpdate = value;
		uniforms.spotLights.needsUpdate = value;
		uniforms.spotLightShadows.needsUpdate = value;
		uniforms.rectAreaLights.needsUpdate = value;
		uniforms.hemisphereLights.needsUpdate = value;
	}
	function materialNeedsLights(material) {
		return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
	}
	this.getActiveCubeFace = function () {
		return _currentActiveCubeFace;
	};
	this.getActiveMipmapLevel = function () {
		return _currentActiveMipmapLevel;
	};
	this.getRenderTarget = function () {
		return _currentRenderTarget;
	};
	this.setRenderTargetTextures = function (renderTarget, colorTexture, depthTexture) {
		properties.get(renderTarget.texture).__webglTexture = colorTexture;
		properties.get(renderTarget.depthTexture).__webglTexture = depthTexture;
		const renderTargetProperties = properties.get(renderTarget);
		renderTargetProperties.__hasExternalTextures = true;
		if (renderTargetProperties.__hasExternalTextures) {
			renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === undefined;
			if (!renderTargetProperties.__autoAllocateDepthBuffer) {
				// The multisample_render_to_texture extension doesn't work properly if there
				// are midframe flushes and an external depth buffer. Disable use of the extension.
				if (extensions.has('WEBGL_multisampled_render_to_texture') === true) {
					console.warn('THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided');
					renderTargetProperties.__useRenderToTexture = false;
				}
			}
		}
	};
	this.setRenderTargetFramebuffer = function (renderTarget, defaultFramebuffer) {
		const renderTargetProperties = properties.get(renderTarget);
		renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
		renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === undefined;
	};
	this.setRenderTarget = function (renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
		_currentRenderTarget = renderTarget;
		_currentActiveCubeFace = activeCubeFace;
		_currentActiveMipmapLevel = activeMipmapLevel;
		let useDefaultFramebuffer = true;
		let framebuffer = null;
		let isCube = false;
		let isRenderTarget3D = false;
		if (renderTarget) {
			const renderTargetProperties = properties.get(renderTarget);
			if (renderTargetProperties.__useDefaultFramebuffer !== undefined) {
				// We need to make sure to rebind the framebuffer.
				state.bindFramebuffer(_gl.FRAMEBUFFER, null);
				useDefaultFramebuffer = false;
			} else if (renderTargetProperties.__webglFramebuffer === undefined) {
				textures.setupRenderTarget(renderTarget);
			} else if (renderTargetProperties.__hasExternalTextures) {
				// Color and depth texture must be rebound in order for the swapchain to update.
				textures.rebindTextures(renderTarget, properties.get(renderTarget.texture).__webglTexture, properties.get(renderTarget.depthTexture).__webglTexture);
			}
			const texture = renderTarget.texture;
			if (texture.isData3DTexture || texture.isDataArrayTexture || texture.isCompressedArrayTexture) {
				isRenderTarget3D = true;
			}
			const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
			if (renderTarget.isWebGLCubeRenderTarget) {
				framebuffer = __webglFramebuffer[activeCubeFace];
				isCube = true;
			} else if (capabilities.isWebGL2 && renderTarget.samples > 0 && textures.useMultisampledRTT(renderTarget) === false) {
				framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
			} else {
				framebuffer = __webglFramebuffer;
			}
			_currentViewport.copy(renderTarget.viewport);
			_currentScissor.copy(renderTarget.scissor);
			_currentScissorTest = renderTarget.scissorTest;
		} else {
			_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
			_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
			_currentScissorTest = _scissorTest;
		}
		const framebufferBound = state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
		if (framebufferBound && capabilities.drawBuffers && useDefaultFramebuffer) {
			state.drawBuffers(renderTarget, framebuffer);
		}
		state.viewport(_currentViewport);
		state.scissor(_currentScissor);
		state.setScissorTest(_currentScissorTest);
		if (isCube) {
			const textureProperties = properties.get(renderTarget.texture);
			_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
		} else if (isRenderTarget3D) {
			const textureProperties = properties.get(renderTarget.texture);
			const layer = activeCubeFace || 0;
			_gl.framebufferTextureLayer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
		}
		_currentMaterialId = -1; // reset current material to ensure correct uniform bindings
	};

	this.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
		if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
			console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
			return;
		}
		let framebuffer = properties.get(renderTarget).__webglFramebuffer;
		if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) {
			framebuffer = framebuffer[activeCubeFaceIndex];
		}
		if (framebuffer) {
			state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
			try {
				const texture = renderTarget.texture;
				const textureFormat = texture.format;
				const textureType = texture.type;
				if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
					console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
					return;
				}
				const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has('EXT_color_buffer_half_float') || capabilities.isWebGL2 && extensions.has('EXT_color_buffer_float'));
				if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) &&
				// Edge and Chrome Mac < 52 (#9513)
				!(textureType === FloatType && (capabilities.isWebGL2 || extensions.has('OES_texture_float') || extensions.has('WEBGL_color_buffer_float'))) &&
				// Chrome Mac >= 52 and Firefox
				!halfFloatSupportedByExt) {
					console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
					return;
				}

				// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

				if (x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height) {
					_gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
				}
			} finally {
				// restore framebuffer of current render target if necessary

				const framebuffer = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
				state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
			}
		}
	};
	this.copyFramebufferToTexture = function (position, texture, level = 0) {
		const levelScale = Math.pow(2, -level);
		const width = Math.floor(texture.image.width * levelScale);
		const height = Math.floor(texture.image.height * levelScale);
		textures.setTexture2D(texture, 0);
		_gl.copyTexSubImage2D(_gl.TEXTURE_2D, level, 0, 0, position.x, position.y, width, height);
		state.unbindTexture();
	};
	this.copyTextureToTexture = function (position, srcTexture, dstTexture, level = 0) {
		const width = srcTexture.image.width;
		const height = srcTexture.image.height;
		const glFormat = utils.convert(dstTexture.format);
		const glType = utils.convert(dstTexture.type);
		textures.setTexture2D(dstTexture, 0);

		// As another texture upload may have changed pixelStorei
		// parameters, make sure they are correct for the dstTexture
		_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
		_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
		_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
		if (srcTexture.isDataTexture) {
			_gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
		} else {
			if (srcTexture.isCompressedTexture) {
				_gl.compressedTexSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
			} else {
				_gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, glFormat, glType, srcTexture.image);
			}
		}

		// Generate mipmaps only when copying level 0
		if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(_gl.TEXTURE_2D);
		state.unbindTexture();
	};
	this.copyTextureToTexture3D = function (sourceBox, position, srcTexture, dstTexture, level = 0) {
		if (_this.isWebGL1Renderer) {
			console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.');
			return;
		}
		const width = sourceBox.max.x - sourceBox.min.x + 1;
		const height = sourceBox.max.y - sourceBox.min.y + 1;
		const depth = sourceBox.max.z - sourceBox.min.z + 1;
		const glFormat = utils.convert(dstTexture.format);
		const glType = utils.convert(dstTexture.type);
		let glTarget;
		if (dstTexture.isData3DTexture) {
			textures.setTexture3D(dstTexture, 0);
			glTarget = _gl.TEXTURE_3D;
		} else if (dstTexture.isDataArrayTexture) {
			textures.setTexture2DArray(dstTexture, 0);
			glTarget = _gl.TEXTURE_2D_ARRAY;
		} else {
			console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.');
			return;
		}
		_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
		_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
		_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
		const unpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);
		const unpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);
		const unpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);
		const unpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);
		const unpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);
		const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[0] : srcTexture.image;
		_gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image.width);
		_gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, image.height);
		_gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, sourceBox.min.x);
		_gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, sourceBox.min.y);
		_gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, sourceBox.min.z);
		if (srcTexture.isDataTexture || srcTexture.isData3DTexture) {
			_gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data);
		} else {
			if (srcTexture.isCompressedArrayTexture) {
				console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.');
				_gl.compressedTexSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data);
			} else {
				_gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image);
			}
		}
		_gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, unpackRowLen);
		_gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, unpackImageHeight);
		_gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, unpackSkipPixels);
		_gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, unpackSkipRows);
		_gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, unpackSkipImages);

		// Generate mipmaps only when copying level 0
		if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(glTarget);
		state.unbindTexture();
	};
	this.initTexture = function (texture) {
		if (texture.isCubeTexture) {
			textures.setTextureCube(texture, 0);
		} else if (texture.isData3DTexture) {
			textures.setTexture3D(texture, 0);
		} else if (texture.isDataArrayTexture || texture.isCompressedArrayTexture) {
			textures.setTexture2DArray(texture, 0);
		} else {
			textures.setTexture2D(texture, 0);
		}
		state.unbindTexture();
	};
	this.resetState = function () {
		_currentActiveCubeFace = 0;
		_currentActiveMipmapLevel = 0;
		_currentRenderTarget = null;
		state.reset();
		bindingStates.reset();
	};
	if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
		__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
			detail: this
		}));
	}
}

class WebGL1Renderer extends WebGLRenderer {}
WebGL1Renderer.prototype.isWebGL1Renderer = true;

class FogExp2 {
	constructor(color, density = 0.00025) {
		this.isFogExp2 = true;
		this.name = '';
		this.color = new Color(color);
		this.density = density;
	}
	clone() {
		return new FogExp2(this.color, this.density);
	}
	toJSON() {
		return {
			type: 'FogExp2',
			color: this.color.getHex(),
			density: this.density
		};
	}
}

class Fog {
	constructor(color, near = 1, far = 1000) {
		this.isFog = true;
		this.name = '';
		this.color = new Color(color);
		this.near = near;
		this.far = far;
	}
	clone() {
		return new Fog(this.color, this.near, this.far);
	}
	toJSON() {
		return {
			type: 'Fog',
			color: this.color.getHex(),
			near: this.near,
			far: this.far
		};
	}
}

class Scene extends Object3D {
	constructor() {
		super();
		this.isScene = true;
		this.type = 'Scene';
		this.background = null;
		this.environment = null;
		this.fog = null;
		this.backgroundBlurriness = 0;
		this.overrideMaterial = null;
		if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
			__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
				detail: this
			}));
		}
	}
	copy(source, recursive) {
		super.copy(source, recursive);
		if (source.background !== null) this.background = source.background.clone();
		if (source.environment !== null) this.environment = source.environment.clone();
		if (source.fog !== null) this.fog = source.fog.clone();
		this.backgroundBlurriness = source.backgroundBlurriness;
		if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
		this.matrixAutoUpdate = source.matrixAutoUpdate;
		return this;
	}
	toJSON(meta) {
		const data = super.toJSON(meta);
		if (this.fog !== null) data.object.fog = this.fog.toJSON();
		if (this.backgroundBlurriness > 0) data.backgroundBlurriness = this.backgroundBlurriness;
		return data;
	}

	// @deprecated

	get autoUpdate() {
		console.warn('THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144.');
		return this.matrixWorldAutoUpdate;
	}
	set autoUpdate(value) {
		console.warn('THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144.');
		this.matrixWorldAutoUpdate = value;
	}
}

class InterleavedBuffer {
	constructor(array, stride) {
		this.isInterleavedBuffer = true;
		this.array = array;
		this.stride = stride;
		this.count = array !== undefined ? array.length / stride : 0;
		this.usage = StaticDrawUsage;
		this.updateRange = {
			offset: 0,
			count: -1
		};
		this.version = 0;
		this.uuid = generateUUID();
	}
	onUploadCallback() {}
	set needsUpdate(value) {
		if (value === true) this.version++;
	}
	setUsage(value) {
		this.usage = value;
		return this;
	}
	copy(source) {
		this.array = new source.array.constructor(source.array);
		this.count = source.count;
		this.stride = source.stride;
		this.usage = source.usage;
		return this;
	}
	copyAt(index1, attribute, index2) {
		index1 *= this.stride;
		index2 *= attribute.stride;
		for (let i = 0, l = this.stride; i < l; i++) {
			this.array[index1 + i] = attribute.array[index2 + i];
		}
		return this;
	}
	set(value, offset = 0) {
		this.array.set(value, offset);
		return this;
	}
	clone(data) {
		if (data.arrayBuffers === undefined) {
			data.arrayBuffers = {};
		}
		if (this.array.buffer._uuid === undefined) {
			this.array.buffer._uuid = generateUUID();
		}
		if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {
			data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
		}
		const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
		const ib = new this.constructor(array, this.stride);
		ib.setUsage(this.usage);
		return ib;
	}
	onUpload(callback) {
		this.onUploadCallback = callback;
		return this;
	}
	toJSON(data) {
		if (data.arrayBuffers === undefined) {
			data.arrayBuffers = {};
		}

		// generate UUID for array buffer if necessary

		if (this.array.buffer._uuid === undefined) {
			this.array.buffer._uuid = generateUUID();
		}
		if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {
			data.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer));
		}

		//

		return {
			uuid: this.uuid,
			buffer: this.array.buffer._uuid,
			type: this.array.constructor.name,
			stride: this.stride
		};
	}
}

const _vector$6 = /*@__PURE__*/new Vector3();
class InterleavedBufferAttribute {
	constructor(interleavedBuffer, itemSize, offset, normalized = false) {
		this.isInterleavedBufferAttribute = true;
		this.name = '';
		this.data = interleavedBuffer;
		this.itemSize = itemSize;
		this.offset = offset;
		this.normalized = normalized === true;
	}
	get count() {
		return this.data.count;
	}
	get array() {
		return this.data.array;
	}
	set needsUpdate(value) {
		this.data.needsUpdate = value;
	}
	applyMatrix4(m) {
		for (let i = 0, l = this.data.count; i < l; i++) {
			_vector$6.fromBufferAttribute(this, i);
			_vector$6.applyMatrix4(m);
			this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
		}
		return this;
	}
	applyNormalMatrix(m) {
		for (let i = 0, l = this.count; i < l; i++) {
			_vector$6.fromBufferAttribute(this, i);
			_vector$6.applyNormalMatrix(m);
			this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
		}
		return this;
	}
	transformDirection(m) {
		for (let i = 0, l = this.count; i < l; i++) {
			_vector$6.fromBufferAttribute(this, i);
			_vector$6.transformDirection(m);
			this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
		}
		return this;
	}
	setX(index, x) {
		if (this.normalized) x = normalize(x, this.array);
		this.data.array[index * this.data.stride + this.offset] = x;
		return this;
	}
	setY(index, y) {
		if (this.normalized) y = normalize(y, this.array);
		this.data.array[index * this.data.stride + this.offset + 1] = y;
		return this;
	}
	setZ(index, z) {
		if (this.normalized) z = normalize(z, this.array);
		this.data.array[index * this.data.stride + this.offset + 2] = z;
		return this;
	}
	setW(index, w) {
		if (this.normalized) w = normalize(w, this.array);
		this.data.array[index * this.data.stride + this.offset + 3] = w;
		return this;
	}
	getX(index) {
		let x = this.data.array[index * this.data.stride + this.offset];
		if (this.normalized) x = denormalize(x, this.array);
		return x;
	}
	getY(index) {
		let y = this.data.array[index * this.data.stride + this.offset + 1];
		if (this.normalized) y = denormalize(y, this.array);
		return y;
	}
	getZ(index) {
		let z = this.data.array[index * this.data.stride + this.offset + 2];
		if (this.normalized) z = denormalize(z, this.array);
		return z;
	}
	getW(index) {
		let w = this.data.array[index * this.data.stride + this.offset + 3];
		if (this.normalized) w = denormalize(w, this.array);
		return w;
	}
	setXY(index, x, y) {
		index = index * this.data.stride + this.offset;
		if (this.normalized) {
			x = normalize(x, this.array);
			y = normalize(y, this.array);
		}
		this.data.array[index + 0] = x;
		this.data.array[index + 1] = y;
		return this;
	}
	setXYZ(index, x, y, z) {
		index = index * this.data.stride + this.offset;
		if (this.normalized) {
			x = normalize(x, this.array);
			y = normalize(y, this.array);
			z = normalize(z, this.array);
		}
		this.data.array[index + 0] = x;
		this.data.array[index + 1] = y;
		this.data.array[index + 2] = z;
		return this;
	}
	setXYZW(index, x, y, z, w) {
		index = index * this.data.stride + this.offset;
		if (this.normalized) {
			x = normalize(x, this.array);
			y = normalize(y, this.array);
			z = normalize(z, this.array);
			w = normalize(w, this.array);
		}
		this.data.array[index + 0] = x;
		this.data.array[index + 1] = y;
		this.data.array[index + 2] = z;
		this.data.array[index + 3] = w;
		return this;
	}
	clone(data) {
		if (data === undefined) {
			console.log('THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will deinterleave buffer data.');
			const array = [];
			for (let i = 0; i < this.count; i++) {
				const index = i * this.data.stride + this.offset;
				for (let j = 0; j < this.itemSize; j++) {
					array.push(this.data.array[index + j]);
				}
			}
			return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
		} else {
			if (data.interleavedBuffers === undefined) {
				data.interleavedBuffers = {};
			}
			if (data.interleavedBuffers[this.data.uuid] === undefined) {
				data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
			}
			return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
		}
	}
	toJSON(data) {
		if (data === undefined) {
			console.log('THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will deinterleave buffer data.');
			const array = [];
			for (let i = 0; i < this.count; i++) {
				const index = i * this.data.stride + this.offset;
				for (let j = 0; j < this.itemSize; j++) {
					array.push(this.data.array[index + j]);
				}
			}

			// deinterleave data and save it as an ordinary buffer attribute for now

			return {
				itemSize: this.itemSize,
				type: this.array.constructor.name,
				array: array,
				normalized: this.normalized
			};
		} else {
			// save as true interleaved attribtue

			if (data.interleavedBuffers === undefined) {
				data.interleavedBuffers = {};
			}
			if (data.interleavedBuffers[this.data.uuid] === undefined) {
				data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
			}
			return {
				isInterleavedBufferAttribute: true,
				itemSize: this.itemSize,
				data: this.data.uuid,
				offset: this.offset,
				normalized: this.normalized
			};
		}
	}
}

class SpriteMaterial extends Material {
	constructor(parameters) {
		super();
		this.isSpriteMaterial = true;
		this.type = 'SpriteMaterial';
		this.color = new Color(0xffffff);
		this.map = null;
		this.alphaMap = null;
		this.rotation = 0;
		this.sizeAttenuation = true;
		this.transparent = true;
		this.fog = true;
		this.setValues(parameters);
	}
	copy(source) {
		super.copy(source);
		this.color.copy(source.color);
		this.map = source.map;
		this.alphaMap = source.alphaMap;
		this.rotation = source.rotation;
		this.sizeAttenuation = source.sizeAttenuation;
		this.fog = source.fog;
		return this;
	}
}

let _geometry;
const _intersectPoint = /*@__PURE__*/new Vector3();
const _worldScale = /*@__PURE__*/new Vector3();
const _mvPosition = /*@__PURE__*/new Vector3();
const _alignedPosition = /*@__PURE__*/new Vector2();
const _rotatedPosition = /*@__PURE__*/new Vector2();
const _viewWorldMatrix = /*@__PURE__*/new Matrix4();
const _vA = /*@__PURE__*/new Vector3();
const _vB = /*@__PURE__*/new Vector3();
const _vC = /*@__PURE__*/new Vector3();
const _uvA = /*@__PURE__*/new Vector2();
const _uvB = /*@__PURE__*/new Vector2();
const _uvC = /*@__PURE__*/new Vector2();
class Sprite extends Object3D {
	constructor(material) {
		super();
		this.isSprite = true;
		this.type = 'Sprite';
		if (_geometry === undefined) {
			_geometry = new BufferGeometry();
			const float32Array = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]);
			const interleavedBuffer = new InterleavedBuffer(float32Array, 5);
			_geometry.setIndex([0, 1, 2, 0, 2, 3]);
			_geometry.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
			_geometry.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
		}
		this.geometry = _geometry;
		this.material = material !== undefined ? material : new SpriteMaterial();
		this.center = new Vector2(0.5, 0.5);
	}
	raycast(raycaster, intersects) {
		if (raycaster.camera === null) {
			console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
		}
		_worldScale.setFromMatrixScale(this.matrixWorld);
		_viewWorldMatrix.copy(raycaster.camera.matrixWorld);
		this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
		_mvPosition.setFromMatrixPosition(this.modelViewMatrix);
		if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
			_worldScale.multiplyScalar(-_mvPosition.z);
		}
		const rotation = this.material.rotation;
		let sin, cos;
		if (rotation !== 0) {
			cos = Math.cos(rotation);
			sin = Math.sin(rotation);
		}
		const center = this.center;
		transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
		transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
		transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
		_uvA.set(0, 0);
		_uvB.set(1, 0);
		_uvC.set(1, 1);

		// check first triangle
		let intersect = raycaster.ray.intersectTriangle(_vA, _vB, _vC, false, _intersectPoint);
		if (intersect === null) {
			// check second triangle
			transformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
			_uvB.set(0, 1);
			intersect = raycaster.ray.intersectTriangle(_vA, _vC, _vB, false, _intersectPoint);
			if (intersect === null) {
				return;
			}
		}
		const distance = raycaster.ray.origin.distanceTo(_intersectPoint);
		if (distance < raycaster.near || distance > raycaster.far) return;
		intersects.push({
			distance: distance,
			point: _intersectPoint.clone(),
			uv: Triangle.getUV(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()),
			face: null,
			object: this
		});
	}
	copy(source, recursive) {
		super.copy(source, recursive);
		if (source.center !== undefined) this.center.copy(source.center);
		this.material = source.material;
		return this;
	}
}
function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
	// compute position in camera space
	_alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);

	// to check if rotation is not zero
	if (sin !== undefined) {
		_rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
		_rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
	} else {
		_rotatedPosition.copy(_alignedPosition);
	}
	vertexPosition.copy(mvPosition);
	vertexPosition.x += _rotatedPosition.x;
	vertexPosition.y += _rotatedPosition.y;

	// transform to world space
	vertexPosition.applyMatrix4(_viewWorldMatrix);
}

const _v1$2 = /*@__PURE__*/new Vector3();
const _v2$1 = /*@__PURE__*/new Vector3();
class LOD extends Object3D {
	constructor() {
		super();
		this._currentLevel = 0;
		this.type = 'LOD';
		Object.defineProperties(this, {
			levels: {
				enumerable: true,
				value: []
			},
			isLOD: {
				value: true
			}
		});
		this.autoUpdate = true;
	}
	copy(source) {
		super.copy(source, false);
		const levels = source.levels;
		for (let i = 0, l = levels.length; i < l; i++) {
			const level = levels[i];
			this.addLevel(level.object.clone(), level.distance);
		}
		this.autoUpdate = source.autoUpdate;
		return this;
	}
	addLevel(object, distance = 0) {
		distance = Math.abs(distance);
		const levels = this.levels;
		let l;
		for (l = 0; l < levels.length; l++) {
			if (distance < levels[l].distance) {
				break;
			}
		}
		levels.splice(l, 0, {
			distance: distance,
			object: object
		});
		this.add(object);
		return this;
	}
	getCurrentLevel() {
		return this._currentLevel;
	}
	getObjectForDistance(distance) {
		const levels = this.levels;
		if (levels.length > 0) {
			let i, l;
			for (i = 1, l = levels.length; i < l; i++) {
				if (distance < levels[i].distance) {
					break;
				}
			}
			return levels[i - 1].object;
		}
		return null;
	}
	raycast(raycaster, intersects) {
		const levels = this.levels;
		if (levels.length > 0) {
			_v1$2.setFromMatrixPosition(this.matrixWorld);
			const distance = raycaster.ray.origin.distanceTo(_v1$2);
			this.getObjectForDistance(distance).raycast(raycaster, intersects);
		}
	}
	update(camera) {
		const levels = this.levels;
		if (levels.length > 1) {
			_v1$2.setFromMatrixPosition(camera.matrixWorld);
			_v2$1.setFromMatrixPosition(this.matrixWorld);
			const distance = _v1$2.distanceTo(_v2$1) / camera.zoom;
			levels[0].object.visible = true;
			let i, l;
			for (i = 1, l = levels.length; i < l; i++) {
				if (distance >= levels[i].distance) {
					levels[i - 1].object.visible = false;
					levels[i].object.visible = true;
				} else {
					break;
				}
			}
			this._currentLevel = i - 1;
			for (; i < l; i++) {
				levels[i].object.visible = false;
			}
		}
	}
	toJSON(meta) {
		const data = super.toJSON(meta);
		if (this.autoUpdate === false) data.object.autoUpdate = false;
		data.object.levels = [];
		const levels = this.levels;
		for (let i = 0, l = levels.length; i < l; i++) {
			const level = levels[i];
			data.object.levels.push({
				object: level.object.uuid,
				distance: level.distance
			});
		}
		return data;
	}
}

const _basePosition = /*@__PURE__*/new Vector3();
const _skinIndex = /*@__PURE__*/new Vector4();
const _skinWeight = /*@__PURE__*/new Vector4();
const _vector$5 = /*@__PURE__*/new Vector3();
const _matrix = /*@__PURE__*/new Matrix4();
class SkinnedMesh extends Mesh {
	constructor(geometry, material) {
		super(geometry, material);
		this.isSkinnedMesh = true;
		this.type = 'SkinnedMesh';
		this.bindMode = 'attached';
		this.bindMatrix = new Matrix4();
		this.bindMatrixInverse = new Matrix4();
	}
	copy(source, recursive) {
		super.copy(source, recursive);
		this.bindMode = source.bindMode;
		this.bindMatrix.copy(source.bindMatrix);
		this.bindMatrixInverse.copy(source.bindMatrixInverse);
		this.skeleton = source.skeleton;
		return this;
	}
	bind(skeleton, bindMatrix) {
		this.skeleton = skeleton;
		if (bindMatrix === undefined) {
			this.updateMatrixWorld(true);
			this.skeleton.calculateInverses();
			bindMatrix = this.matrixWorld;
		}
		this.bindMatrix.copy(bindMatrix);
		this.bindMatrixInverse.copy(bindMatrix).invert();
	}
	pose() {
		this.skeleton.pose();
	}
	normalizeSkinWeights() {
		const vector = new Vector4();
		const skinWeight = this.geometry.attributes.skinWeight;
		for (let i = 0, l = skinWeight.count; i < l; i++) {
			vector.fromBufferAttribute(skinWeight, i);
			const scale = 1.0 / vector.manhattanLength();
			if (scale !== Infinity) {
				vector.multiplyScalar(scale);
			} else {
				vector.set(1, 0, 0, 0); // do something reasonable
			}

			skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);
		}
	}
	updateMatrixWorld(force) {
		super.updateMatrixWorld(force);
		if (this.bindMode === 'attached') {
			this.bindMatrixInverse.copy(this.matrixWorld).invert();
		} else if (this.bindMode === 'detached') {
			this.bindMatrixInverse.copy(this.bindMatrix).invert();
		} else {
			console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);
		}
	}
	boneTransform(index, target) {
		const skeleton = this.skeleton;
		const geometry = this.geometry;
		_skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
		_skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);
		_basePosition.copy(target).applyMatrix4(this.bindMatrix);
		target.set(0, 0, 0);
		for (let i = 0; i < 4; i++) {
			const weight = _skinWeight.getComponent(i);
			if (weight !== 0) {
				const boneIndex = _skinIndex.getComponent(i);
				_matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
				target.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix), weight);
			}
		}
		return target.applyMatrix4(this.bindMatrixInverse);
	}
}

class Bone extends Object3D {
	constructor() {
		super();
		this.isBone = true;
		this.type = 'Bone';
	}
}

class DataTexture extends Texture {
	constructor(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, encoding) {
		super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
		this.isDataTexture = true;
		this.image = {
			data: data,
			width: width,
			height: height
		};
		this.generateMipmaps = false;
		this.flipY = false;
		this.unpackAlignment = 1;
	}
}

const _offsetMatrix = /*@__PURE__*/new Matrix4();
const _identityMatrix = /*@__PURE__*/new Matrix4();
class Skeleton {
	constructor(bones = [], boneInverses = []) {
		this.uuid = generateUUID();
		this.bones = bones.slice(0);
		this.boneInverses = boneInverses;
		this.boneMatrices = null;
		this.boneTexture = null;
		this.boneTextureSize = 0;
		this.frame = -1;
		this.init();
	}
	init() {
		const bones = this.bones;
		const boneInverses = this.boneInverses;
		this.boneMatrices = new Float32Array(bones.length * 16);

		// calculate inverse bone matrices if necessary

		if (boneInverses.length === 0) {
			this.calculateInverses();
		} else {
			// handle special case

			if (bones.length !== boneInverses.length) {
				console.warn('THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.');
				this.boneInverses = [];
				for (let i = 0, il = this.bones.length; i < il; i++) {
					this.boneInverses.push(new Matrix4());
				}
			}
		}
	}
	calculateInverses() {
		this.boneInverses.length = 0;
		for (let i = 0, il = this.bones.length; i < il; i++) {
			const inverse = new Matrix4();
			if (this.bones[i]) {
				inverse.copy(this.bones[i].matrixWorld).invert();
			}
			this.boneInverses.push(inverse);
		}
	}
	pose() {
		// recover the bind-time world matrices

		for (let i = 0, il = this.bones.length; i < il; i++) {
			const bone = this.bones[i];
			if (bone) {
				bone.matrixWorld.copy(this.boneInverses[i]).invert();
			}
		}

		// compute the local matrices, positions, rotations and scales

		for (let i = 0, il = this.bones.length; i < il; i++) {
			const bone = this.bones[i];
			if (bone) {
				if (bone.parent && bone.parent.isBone) {
					bone.matrix.copy(bone.parent.matrixWorld).invert();
					bone.matrix.multiply(bone.matrixWorld);
				} else {
					bone.matrix.copy(bone.matrixWorld);
				}
				bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
			}
		}
	}
	update() {
		const bones = this.bones;
		const boneInverses = this.boneInverses;
		const boneMatrices = this.boneMatrices;
		const boneTexture = this.boneTexture;

		// flatten bone matrices to array

		for (let i = 0, il = bones.length; i < il; i++) {
			// compute the offset between the current and the original transform

			const matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;
			_offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);
			_offsetMatrix.toArray(boneMatrices, i * 16);
		}
		if (boneTexture !== null) {
			boneTexture.needsUpdate = true;
		}
	}
	clone() {
		return new Skeleton(this.bones, this.boneInverses);
	}
	computeBoneTexture() {
		// layout (1 matrix = 4 pixels)
		//			RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
		//	with	8x8	pixel texture max	 16 bones * 4 pixels =	(8 * 8)
		//			 16x16 pixel texture max	 64 bones * 4 pixels = (16 * 16)
		//			 32x32 pixel texture max	256 bones * 4 pixels = (32 * 32)
		//			 64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)

		let size = Math.sqrt(this.bones.length * 4); // 4 pixels needed for 1 matrix
		size = ceilPowerOfTwo(size);
		size = Math.max(size, 4);
		const boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel
		boneMatrices.set(this.boneMatrices); // copy current values

		const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
		boneTexture.needsUpdate = true;
		this.boneMatrices = boneMatrices;
		this.boneTexture = boneTexture;
		this.boneTextureSize = size;
		return this;
	}
	getBoneByName(name) {
		for (let i = 0, il = this.bones.length; i < il; i++) {
			const bone = this.bones[i];
			if (bone.name === name) {
				return bone;
			}
		}
		return undefined;
	}
	dispose() {
		if (this.boneTexture !== null) {
			this.boneTexture.dispose();
			this.boneTexture = null;
		}
	}
	fromJSON(json, bones) {
		this.uuid = json.uuid;
		for (let i = 0, l = json.bones.length; i < l; i++) {
			const uuid = json.bones[i];
			let bone = bones[uuid];
			if (bone === undefined) {
				console.warn('THREE.Skeleton: No bone found with UUID:', uuid);
				bone = new Bone();
			}
			this.bones.push(bone);
			this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i]));
		}
		this.init();
		return this;
	}
	toJSON() {
		const data = {
			metadata: {
				version: 4.5,
				type: 'Skeleton',
				generator: 'Skeleton.toJSON'
			},
			bones: [],
			boneInverses: []
		};
		data.uuid = this.uuid;
		const bones = this.bones;
		const boneInverses = this.boneInverses;
		for (let i = 0, l = bones.length; i < l; i++) {
			const bone = bones[i];
			data.bones.push(bone.uuid);
			const boneInverse = boneInverses[i];
			data.boneInverses.push(boneInverse.toArray());
		}
		return data;
	}
}

class InstancedBufferAttribute extends BufferAttribute {
	constructor(array, itemSize, normalized, meshPerAttribute = 1) {
		super(array, itemSize, normalized);
		this.isInstancedBufferAttribute = true;
		this.meshPerAttribute = meshPerAttribute;
	}
	copy(source) {
		super.copy(source);
		this.meshPerAttribute = source.meshPerAttribute;
		return this;
	}
	toJSON() {
		const data = super.toJSON();
		data.meshPerAttribute = this.meshPerAttribute;
		data.isInstancedBufferAttribute = true;
		return data;
	}
}

const _instanceLocalMatrix = /*@__PURE__*/new Matrix4();
const _instanceWorldMatrix = /*@__PURE__*/new Matrix4();
const _instanceIntersects = [];
const _identity = /*@__PURE__*/new Matrix4();
const _mesh = /*@__PURE__*/new Mesh();
class InstancedMesh extends Mesh {
	constructor(geometry, material, count) {
		super(geometry, material);
		this.isInstancedMesh = true;
		this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(count * 16), 16);
		this.instanceColor = null;
		this.count = count;
		this.frustumCulled = false;
		for (let i = 0; i < count; i++) {
			this.setMatrixAt(i, _identity);
		}
	}
	copy(source, recursive) {
		super.copy(source, recursive);
		this.instanceMatrix.copy(source.instanceMatrix);
		if (source.instanceColor !== null) this.instanceColor = source.instanceColor.clone();
		this.count = source.count;
		return this;
	}
	getColorAt(index, color) {
		color.fromArray(this.instanceColor.array, index * 3);
	}
	getMatrixAt(index, matrix) {
		matrix.fromArray(this.instanceMatrix.array, index * 16);
	}
	raycast(raycaster, intersects) {
		const matrixWorld = this.matrixWorld;
		const raycastTimes = this.count;
		_mesh.geometry = this.geometry;
		_mesh.material = this.material;
		if (_mesh.material === undefined) return;
		for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
			// calculate the world matrix for each instance

			this.getMatrixAt(instanceId, _instanceLocalMatrix);
			_instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);

			// the mesh represents this single instance

			_mesh.matrixWorld = _instanceWorldMatrix;
			_mesh.raycast(raycaster, _instanceIntersects);

			// process the result of raycast

			for (let i = 0, l = _instanceIntersects.length; i < l; i++) {
				const intersect = _instanceIntersects[i];
				intersect.instanceId = instanceId;
				intersect.object = this;
				intersects.push(intersect);
			}
			_instanceIntersects.length = 0;
		}
	}
	setColorAt(index, color) {
		if (this.instanceColor === null) {
			this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3), 3);
		}
		color.toArray(this.instanceColor.array, index * 3);
	}
	setMatrixAt(index, matrix) {
		matrix.toArray(this.instanceMatrix.array, index * 16);
	}
	updateMorphTargets() {}
	dispose() {
		this.dispatchEvent({
			type: 'dispose'
		});
	}
}

class LineBasicMaterial extends Material {
	constructor(parameters) {
		super();
		this.isLineBasicMaterial = true;
		this.type = 'LineBasicMaterial';
		this.color = new Color(0xffffff);
		this.linewidth = 1;
		this.linecap = 'round';
		this.linejoin = 'round';
		this.fog = true;
		this.setValues(parameters);
	}
	copy(source) {
		super.copy(source);
		this.color.copy(source.color);
		this.linewidth = source.linewidth;
		this.linecap = source.linecap;
		this.linejoin = source.linejoin;
		this.fog = source.fog;
		return this;
	}
}

const _start$1 = /*@__PURE__*/new Vector3();
const _end$1 = /*@__PURE__*/new Vector3();
const _inverseMatrix$1 = /*@__PURE__*/new Matrix4();
const _ray$1 = /*@__PURE__*/new Ray();
const _sphere$1 = /*@__PURE__*/new Sphere();
class Line extends Object3D {
	constructor(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {
		super();
		this.isLine = true;
		this.type = 'Line';
		this.geometry = geometry;
		this.material = material;
		this.updateMorphTargets();
	}
	copy(source, recursive) {
		super.copy(source, recursive);
		this.material = source.material;
		this.geometry = source.geometry;
		return this;
	}
	computeLineDistances() {
		const geometry = this.geometry;

		// we assume non-indexed geometry

		if (geometry.index === null) {
			const positionAttribute = geometry.attributes.position;
			const lineDistances = [0];
			for (let i = 1, l = positionAttribute.count; i < l; i++) {
				_start$1.fromBufferAttribute(positionAttribute, i - 1);
				_end$1.fromBufferAttribute(positionAttribute, i);
				lineDistances[i] = lineDistances[i - 1];
				lineDistances[i] += _start$1.distanceTo(_end$1);
			}
			geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
		} else {
			console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
		}
		return this;
	}
	raycast(raycaster, intersects) {
		const geometry = this.geometry;
		const matrixWorld = this.matrixWorld;
		const threshold = raycaster.params.Line.threshold;
		const drawRange = geometry.drawRange;

		// Checking boundingSphere distance to ray

		if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
		_sphere$1.copy(geometry.boundingSphere);
		_sphere$1.applyMatrix4(matrixWorld);
		_sphere$1.radius += threshold;
		if (raycaster.ray.intersectsSphere(_sphere$1) === false) return;

		//

		_inverseMatrix$1.copy(matrixWorld).invert();
		_ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
		const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
		const localThresholdSq = localThreshold * localThreshold;
		const vStart = new Vector3();
		const vEnd = new Vector3();
		const interSegment = new Vector3();
		const interRay = new Vector3();
		const step = this.isLineSegments ? 2 : 1;
		const index = geometry.index;
		const attributes = geometry.attributes;
		const positionAttribute = attributes.position;
		if (index !== null) {
			const start = Math.max(0, drawRange.start);
			const end = Math.min(index.count, drawRange.start + drawRange.count);
			for (let i = start, l = end - 1; i < l; i += step) {
				const a = index.getX(i);
				const b = index.getX(i + 1);
				vStart.fromBufferAttribute(positionAttribute, a);
				vEnd.fromBufferAttribute(positionAttribute, b);
				const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
				if (distSq > localThresholdSq) continue;
				interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

				const distance = raycaster.ray.origin.distanceTo(interRay);
				if (distance < raycaster.near || distance > raycaster.far) continue;
				intersects.push({
					distance: distance,
					// What do we want? intersection point on the ray or on the segment??
					// point: raycaster.ray.at( distance ),
					point: interSegment.clone().applyMatrix4(this.matrixWorld),
					index: i,
					face: null,
					faceIndex: null,
					object: this
				});
			}
		} else {
			const start = Math.max(0, drawRange.start);
			const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
			for (let i = start, l = end - 1; i < l; i += step) {
				vStart.fromBufferAttribute(positionAttribute, i);
				vEnd.fromBufferAttribute(positionAttribute, i + 1);
				const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
				if (distSq > localThresholdSq) continue;
				interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

				const distance = raycaster.ray.origin.distanceTo(interRay);
				if (distance < raycaster.near || distance > raycaster.far) continue;
				intersects.push({
					distance: distance,
					// What do we want? intersection point on the ray or on the segment??
					// point: raycaster.ray.at( distance ),
					point: interSegment.clone().applyMatrix4(this.matrixWorld),
					index: i,
					face: null,
					faceIndex: null,
					object: this
				});
			}
		}
	}
	updateMorphTargets() {
		const geometry = this.geometry;
		const morphAttributes = geometry.morphAttributes;
		const keys = Object.keys(morphAttributes);
		if (keys.length > 0) {
			const morphAttribute = morphAttributes[keys[0]];
			if (morphAttribute !== undefined) {
				this.morphTargetInfluences = [];
				this.morphTargetDictionary = {};
				for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
					const name = morphAttribute[m].name || String(m);
					this.morphTargetInfluences.push(0);
					this.morphTargetDictionary[name] = m;
				}
			}
		}
	}
}

const _start = /*@__PURE__*/new Vector3();
const _end = /*@__PURE__*/new Vector3();
class LineSegments extends Line {
	constructor(geometry, material) {
		super(geometry, material);
		this.isLineSegments = true;
		this.type = 'LineSegments';
	}
	computeLineDistances() {
		const geometry = this.geometry;

		// we assume non-indexed geometry

		if (geometry.index === null) {
			const positionAttribute = geometry.attributes.position;
			const lineDistances = [];
			for (let i = 0, l = positionAttribute.count; i < l; i += 2) {
				_start.fromBufferAttribute(positionAttribute, i);
				_end.fromBufferAttribute(positionAttribute, i + 1);
				lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
				lineDistances[i + 1] = lineDistances[i] + _start.distanceTo(_end);
			}
			geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
		} else {
			console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
		}
		return this;
	}
}

class LineLoop extends Line {
	constructor(geometry, material) {
		super(geometry, material);
		this.isLineLoop = true;
		this.type = 'LineLoop';
	}
}

class PointsMaterial extends Material {
	constructor(parameters) {
		super();
		this.isPointsMaterial = true;
		this.type = 'PointsMaterial';
		this.color = new Color(0xffffff);
		this.map = null;
		this.alphaMap = null;
		this.size = 1;
		this.sizeAttenuation = true;
		this.fog = true;
		this.setValues(parameters);
	}
	copy(source) {
		super.copy(source);
		this.color.copy(source.color);
		this.map = source.map;
		this.alphaMap = source.alphaMap;
		this.size = source.size;
		this.sizeAttenuation = source.sizeAttenuation;
		this.fog = source.fog;
		return this;
	}
}

const _inverseMatrix = /*@__PURE__*/new Matrix4();
const _ray = /*@__PURE__*/new Ray();
const _sphere = /*@__PURE__*/new Sphere();
const _position$2 = /*@__PURE__*/new Vector3();
class Points extends Object3D {
	constructor(geometry = new BufferGeometry(), material = new PointsMaterial()) {
		super();
		this.isPoints = true;
		this.type = 'Points';
		this.geometry = geometry;
		this.material = material;
		this.updateMorphTargets();
	}
	copy(source, recursive) {
		super.copy(source, recursive);
		this.material = source.material;
		this.geometry = source.geometry;
		return this;
	}
	raycast(raycaster, intersects) {
		const geometry = this.geometry;
		const matrixWorld = this.matrixWorld;
		const threshold = raycaster.params.Points.threshold;
		const drawRange = geometry.drawRange;

		// Checking boundingSphere distance to ray

		if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
		_sphere.copy(geometry.boundingSphere);
		_sphere.applyMatrix4(matrixWorld);
		_sphere.radius += threshold;
		if (raycaster.ray.intersectsSphere(_sphere) === false) return;

		//

		_inverseMatrix.copy(matrixWorld).invert();
		_ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
		const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
		const localThresholdSq = localThreshold * localThreshold;
		const index = geometry.index;
		const attributes = geometry.attributes;
		const positionAttribute = attributes.position;
		if (index !== null) {
			const start = Math.max(0, drawRange.start);
			const end = Math.min(index.count, drawRange.start + drawRange.count);
			for (let i = start, il = end; i < il; i++) {
				const a = index.getX(i);
				_position$2.fromBufferAttribute(positionAttribute, a);
				testPoint(_position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this);
			}
		} else {
			const start = Math.max(0, drawRange.start);
			const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
			for (let i = start, l = end; i < l; i++) {
				_position$2.fromBufferAttribute(positionAttribute, i);
				testPoint(_position$2, i, localThresholdSq, matrixWorld, raycaster, intersects, this);
			}
		}
	}
	updateMorphTargets() {
		const geometry = this.geometry;
		const morphAttributes = geometry.morphAttributes;
		const keys = Object.keys(morphAttributes);
		if (keys.length > 0) {
			const morphAttribute = morphAttributes[keys[0]];
			if (morphAttribute !== undefined) {
				this.morphTargetInfluences = [];
				this.morphTargetDictionary = {};
				for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
					const name = morphAttribute[m].name || String(m);
					this.morphTargetInfluences.push(0);
					this.morphTargetDictionary[name] = m;
				}
			}
		}
	}
}
function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {
	const rayPointDistanceSq = _ray.distanceSqToPoint(point);
	if (rayPointDistanceSq < localThresholdSq) {
		const intersectPoint = new Vector3();
		_ray.closestPointToPoint(point, intersectPoint);
		intersectPoint.applyMatrix4(matrixWorld);
		const distance = raycaster.ray.origin.distanceTo(intersectPoint);
		if (distance < raycaster.near || distance > raycaster.far) return;
		intersects.push({
			distance: distance,
			distanceToRay: Math.sqrt(rayPointDistanceSq),
			point: intersectPoint,
			index: index,
			face: null,
			object: object
		});
	}
}

class VideoTexture extends Texture {
	constructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
		super(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
		this.isVideoTexture = true;
		this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
		this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
		this.generateMipmaps = false;
		const scope = this;
		function updateVideo() {
			scope.needsUpdate = true;
			video.requestVideoFrameCallback(updateVideo);
		}
		if ('requestVideoFrameCallback' in video) {
			video.requestVideoFrameCallback(updateVideo);
		}
	}
	clone() {
		return new this.constructor(this.image).copy(this);
	}
	update() {
		const video = this.image;
		const hasVideoFrameCallback = ('requestVideoFrameCallback' in video);
		if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
			this.needsUpdate = true;
		}
	}
}

class FramebufferTexture extends Texture {
	constructor(width, height, format) {
		super({
			width,
			height
		});
		this.isFramebufferTexture = true;
		this.format = format;
		this.magFilter = NearestFilter;
		this.minFilter = NearestFilter;
		this.generateMipmaps = false;
		this.needsUpdate = true;
	}
}

class CompressedTexture extends Texture {
	constructor(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
		super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
		this.isCompressedTexture = true;
		this.image = {
			width: width,
			height: height
		};
		this.mipmaps = mipmaps;

		// no flipping for cube textures
		// (also flipping doesn't work for compressed textures )

		this.flipY = false;

		// can't generate mipmaps for compressed textures
		// mips must be embedded in DDS files

		this.generateMipmaps = false;
	}
}

class CompressedArrayTexture extends CompressedTexture {
	constructor(mipmaps, width, height, depth, format, type) {
		super(mipmaps, width, height, format, type);
		this.isCompressedArrayTexture = true;
		this.image.depth = depth;
		this.wrapR = ClampToEdgeWrapping;
	}
}

class CanvasTexture extends Texture {
	constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
		super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
		this.isCanvasTexture = true;
		this.needsUpdate = true;
	}
}

/**
 * Extensible curve object.
 *
 * Some common of curve methods:
 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following curves inherit from THREE.Curve:
 *
 * -- 2D curves --
 * THREE.ArcCurve
 * THREE.CubicBezierCurve
 * THREE.EllipseCurve
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.SplineCurve
 *
 * -- 3D curves --
 * THREE.CatmullRomCurve3
 * THREE.CubicBezierCurve3
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath.
 *
 **/

class Curve {
	constructor() {
		this.type = 'Curve';
		this.arcLengthDivisions = 200;
	}

	// Virtual base class method to overwrite and implement in subclasses
	//	- t [0 .. 1]

	getPoint() {
		console.warn('THREE.Curve: .getPoint() not implemented.');
		return null;
	}

	// Get point at relative position in curve according to arc length
	// - u [0 .. 1]

	getPointAt(u, optionalTarget) {
		const t = this.getUtoTmapping(u);
		return this.getPoint(t, optionalTarget);
	}

	// Get sequence of points using getPoint( t )

	getPoints(divisions = 5) {
		const points = [];
		for (let d = 0; d <= divisions; d++) {
			points.push(this.getPoint(d / divisions));
		}
		return points;
	}

	// Get sequence of points using getPointAt( u )

	getSpacedPoints(divisions = 5) {
		const points = [];
		for (let d = 0; d <= divisions; d++) {
			points.push(this.getPointAt(d / divisions));
		}
		return points;
	}

	// Get total curve arc length

	getLength() {
		const lengths = this.getLengths();
		return lengths[lengths.length - 1];
	}

	// Get list of cumulative segment lengths

	getLengths(divisions = this.arcLengthDivisions) {
		if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
			return this.cacheArcLengths;
		}
		this.needsUpdate = false;
		const cache = [];
		let current,
			last = this.getPoint(0);
		let sum = 0;
		cache.push(0);
		for (let p = 1; p <= divisions; p++) {
			current = this.getPoint(p / divisions);
			sum += current.distanceTo(last);
			cache.push(sum);
			last = current;
		}
		this.cacheArcLengths = cache;
		return cache; // { sums: cache, sum: sum }; Sum is in the last element.
	}

	updateArcLengths() {
		this.needsUpdate = true;
		this.getLengths();
	}

	// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

	getUtoTmapping(u, distance) {
		const arcLengths = this.getLengths();
		let i = 0;
		const il = arcLengths.length;
		let targetArcLength; // The targeted u distance value to get

		if (distance) {
			targetArcLength = distance;
		} else {
			targetArcLength = u * arcLengths[il - 1];
		}

		// binary search for the index with largest value smaller than target u distance

		let low = 0,
			high = il - 1,
			comparison;
		while (low <= high) {
			i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

			comparison = arcLengths[i] - targetArcLength;
			if (comparison < 0) {
				low = i + 1;
			} else if (comparison > 0) {
				high = i - 1;
			} else {
				high = i;
				break;

				// DONE
			}
		}

		i = high;
		if (arcLengths[i] === targetArcLength) {
			return i / (il - 1);
		}

		// we could get finer grain at lengths, or use simple interpolation between two points

		const lengthBefore = arcLengths[i];
		const lengthAfter = arcLengths[i + 1];
		const segmentLength = lengthAfter - lengthBefore;

		// determine where we are between the 'before' and 'after' points

		const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;

		// add that fractional amount to t

		const t = (i + segmentFraction) / (il - 1);
		return t;
	}

	// Returns a unit vector tangent at t
	// In case any sub curve does not implement its tangent derivation,
	// 2 points a small delta apart will be used to find its gradient
	// which seems to give a reasonable approximation

	getTangent(t, optionalTarget) {
		const delta = 0.0001;
		let t1 = t - delta;
		let t2 = t + delta;

		// Capping in case of danger

		if (t1 < 0) t1 = 0;
		if (t2 > 1) t2 = 1;
		const pt1 = this.getPoint(t1);
		const pt2 = this.getPoint(t2);
		const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
		tangent.copy(pt2).sub(pt1).normalize();
		return tangent;
	}
	getTangentAt(u, optionalTarget) {
		const t = this.getUtoTmapping(u);
		return this.getTangent(t, optionalTarget);
	}
	computeFrenetFrames(segments, closed) {
		// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

		const normal = new Vector3();
		const tangents = [];
		const normals = [];
		const binormals = [];
		const vec = new Vector3();
		const mat = new Matrix4();

		// compute the tangent vectors for each segment on the curve

		for (let i = 0; i <= segments; i++) {
			const u = i / segments;
			tangents[i] = this.getTangentAt(u, new Vector3());
		}

		// select an initial normal vector perpendicular to the first tangent vector,
		// and in the direction of the minimum tangent xyz component

		normals[0] = new Vector3();
		binormals[0] = new Vector3();
		let min = Number.MAX_VALUE;
		const tx = Math.abs(tangents[0].x);
		const ty = Math.abs(tangents[0].y);
		const tz = Math.abs(tangents[0].z);
		if (tx <= min) {
			min = tx;
			normal.set(1, 0, 0);
		}
		if (ty <= min) {
			min = ty;
			normal.set(0, 1, 0);
		}
		if (tz <= min) {
			normal.set(0, 0, 1);
		}
		vec.crossVectors(tangents[0], normal).normalize();
		normals[0].crossVectors(tangents[0], vec);
		binormals[0].crossVectors(tangents[0], normals[0]);

		// compute the slowly-varying normal and binormal vectors for each segment on the curve

		for (let i = 1; i <= segments; i++) {
			normals[i] = normals[i - 1].clone();
			binormals[i] = binormals[i - 1].clone();
			vec.crossVectors(tangents[i - 1], tangents[i]);
			if (vec.length() > Number.EPSILON) {
				vec.normalize();
				const theta = Math.acos(clamp(tangents[i - 1].dot(tangents[i]), -1, 1)); // clamp for floating pt errors

				normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
			}
			binormals[i].crossVectors(tangents[i], normals[i]);
		}

		// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

		if (closed === true) {
			let theta = Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));
			theta /= segments;
			if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
				theta = -theta;
			}
			for (let i = 1; i <= segments; i++) {
				// twist a little...
				normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
				binormals[i].crossVectors(tangents[i], normals[i]);
			}
		}
		return {
			tangents: tangents,
			normals: normals,
			binormals: binormals
		};
	}
	clone() {
		return new this.constructor().copy(this);
	}
	copy(source) {
		this.arcLengthDivisions = source.arcLengthDivisions;
		return this;
	}
	toJSON() {
		const data = {
			metadata: {
				version: 4.5,
				type: 'Curve',
				generator: 'Curve.toJSON'
			}
		};
		data.arcLengthDivisions = this.arcLengthDivisions;
		data.type = this.type;
		return data;
	}
	fromJSON(json) {
		this.arcLengthDivisions = json.arcLengthDivisions;
		return this;
	}
}

class EllipseCurve extends Curve {
	constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {
		super();
		this.isEllipseCurve = true;
		this.type = 'EllipseCurve';
		this.aX = aX;
		this.aY = aY;
		this.xRadius = xRadius;
		this.yRadius = yRadius;
		this.aStartAngle = aStartAngle;
		this.aEndAngle = aEndAngle;
		this.aClockwise = aClockwise;
		this.aRotation = aRotation;
	}
	getPoint(t, optionalTarget) {
		const point = optionalTarget || new Vector2();
		const twoPi = Math.PI * 2;
		let deltaAngle = this.aEndAngle - this.aStartAngle;
		const samePoints = Math.abs(deltaAngle) < Number.EPSILON;

		// ensures that deltaAngle is 0 .. 2 PI
		while (deltaAngle < 0) deltaAngle += twoPi;
		while (deltaAngle > twoPi) deltaAngle -= twoPi;
		if (deltaAngle < Number.EPSILON) {
			if (samePoints) {
				deltaAngle = 0;
			} else {
				deltaAngle = twoPi;
			}
		}
		if (this.aClockwise === true && !samePoints) {
			if (deltaAngle === twoPi) {
				deltaAngle = -twoPi;
			} else {
				deltaAngle = deltaAngle - twoPi;
			}
		}
		const angle = this.aStartAngle + t * deltaAngle;
		let x = this.aX + this.xRadius * Math.cos(angle);
		let y = this.aY + this.yRadius * Math.sin(angle);
		if (this.aRotation !== 0) {
			const cos = Math.cos(this.aRotation);
			const sin = Math.sin(this.aRotation);
			const tx = x - this.aX;
			const ty = y - this.aY;

			// Rotate the point about the center of the ellipse.
			x = tx * cos - ty * sin + this.aX;
			y = tx * sin + ty * cos + this.aY;
		}
		return point.set(x, y);
	}
	copy(source) {
		super.copy(source);
		this.aX = source.aX;
		this.aY = source.aY;
		this.xRadius = source.xRadius;
		this.yRadius = source.yRadius;
		this.aStartAngle = source.aStartAngle;
		this.aEndAngle = source.aEndAngle;
		this.aClockwise = source.aClockwise;
		this.aRotation = source.aRotation;
		return this;
	}
	toJSON() {
		const data = super.toJSON();
		data.aX = this.aX;
		data.aY = this.aY;
		data.xRadius = this.xRadius;
		data.yRadius = this.yRadius;
		data.aStartAngle = this.aStartAngle;
		data.aEndAngle = this.aEndAngle;
		data.aClockwise = this.aClockwise;
		data.aRotation = this.aRotation;
		return data;
	}
	fromJSON(json) {
		super.fromJSON(json);
		this.aX = json.aX;
		this.aY = json.aY;
		this.xRadius = json.xRadius;
		this.yRadius = json.yRadius;
		this.aStartAngle = json.aStartAngle;
		this.aEndAngle = json.aEndAngle;
		this.aClockwise = json.aClockwise;
		this.aRotation = json.aRotation;
		return this;
	}
}

class ArcCurve extends EllipseCurve {
	constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
		super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
		this.isArcCurve = true;
		this.type = 'ArcCurve';
	}
}

/**
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */

/*
Based on an optimized c++ solution in
 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
 - http://ideone.com/NoEbVM

This CubicPoly class could be used for reusing some variables and calculations,
but for three.js curve use, it could be possible inlined and flatten into a single function call
which can be placed in CurveUtils.
*/

function CubicPoly() {
	let c0 = 0,
		c1 = 0,
		c2 = 0,
		c3 = 0;

	/*
	 * Compute coefficients for a cubic polynomial
	 *	 p(s) = c0 + c1*s + c2*s^2 + c3*s^3
	 * such that
	 *	 p(0) = x0, p(1) = x1
	 *	and
	 *	 p'(0) = t0, p'(1) = t1.
	 */
	function init(x0, x1, t0, t1) {
		c0 = x0;
		c1 = t0;
		c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
		c3 = 2 * x0 - 2 * x1 + t0 + t1;
	}
	return {
		initCatmullRom: function (x0, x1, x2, x3, tension) {
			init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
		},
		initNonuniformCatmullRom: function (x0, x1, x2, x3, dt0, dt1, dt2) {
			// compute tangents when parameterized in [t1,t2]
			let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
			let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;

			// rescale tangents for parametrization in [0,1]
			t1 *= dt1;
			t2 *= dt1;
			init(x1, x2, t1, t2);
		},
		calc: function (t) {
			const t2 = t * t;
			const t3 = t2 * t;
			return c0 + c1 * t + c2 * t2 + c3 * t3;
		}
	};
}

//

const tmp = /*@__PURE__*/new Vector3();
const px = /*@__PURE__*/new CubicPoly();
const py = /*@__PURE__*/new CubicPoly();
const pz = /*@__PURE__*/new CubicPoly();
class CatmullRomCurve3 extends Curve {
	constructor(points = [], closed = false, curveType = 'centripetal', tension = 0.5) {
		super();
		this.isCatmullRomCurve3 = true;
		this.type = 'CatmullRomCurve3';
		this.points = points;
		this.closed = closed;
		this.curveType = curveType;
		this.tension = tension;
	}
	getPoint(t, optionalTarget = new Vector3()) {
		const point = optionalTarget;
		const points = this.points;
		const l = points.length;
		const p = (l - (this.closed ? 0 : 1)) * t;
		let intPoint = Math.floor(p);
		let weight = p - intPoint;
		if (this.closed) {
			intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
		} else if (weight === 0 && intPoint === l - 1) {
			intPoint = l - 2;
			weight = 1;
		}
		let p0, p3; // 4 points (p1 & p2 defined below)

		if (this.closed || intPoint > 0) {
			p0 = points[(intPoint - 1) % l];
		} else {
			// extrapolate first point
			tmp.subVectors(points[0], points[1]).add(points[0]);
			p0 = tmp;
		}
		const p1 = points[intPoint % l];
		const p2 = points[(intPoint + 1) % l];
		if (this.closed || intPoint + 2 < l) {
			p3 = points[(intPoint + 2) % l];
		} else {
			// extrapolate last point
			tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
			p3 = tmp;
		}
		if (this.curveType === 'centripetal' || this.curveType === 'chordal') {
			// init Centripetal / Chordal Catmull-Rom
			const pow = this.curveType === 'chordal' ? 0.5 : 0.25;
			let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
			let dt1 = Math.pow(p1.distanceToSquared(p2), pow);
			let dt2 = Math.pow(p2.distanceToSquared(p3), pow);

			// safety check for repeated points
			if (dt1 < 1e-4) dt1 = 1.0;
			if (dt0 < 1e-4) dt0 = dt1;
			if (dt2 < 1e-4) dt2 = dt1;
			px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
			py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
			pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
		} else if (this.curveType === 'catmullrom') {
			px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
			py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
			pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
		}
		point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
		return point;
	}
	copy(source) {
		super.copy(source);
		this.points = [];
		for (let i = 0, l = source.points.length; i < l; i++) {
			const point = source.points[i];
			this.points.push(point.clone());
		}
		this.closed = source.closed;
		this.curveType = source.curveType;
		this.tension = source.tension;
		return this;
	}
	toJSON() {
		const data = super.toJSON();
		data.points = [];
		for (let i = 0, l = this.points.length; i < l; i++) {
			const point = this.points[i];
			data.points.push(point.toArray());
		}
		data.closed = this.closed;
		data.curveType = this.curveType;
		data.tension = this.tension;
		return data;
	}
	fromJSON(json) {
		super.fromJSON(json);
		this.points = [];
		for (let i = 0, l = json.points.length; i < l; i++) {
			const point = json.points[i];
			this.points.push(new Vector3().fromArray(point));
		}
		this.closed = json.closed;
		this.curveType = json.curveType;
		this.tension = json.tension;
		return this;
	}
}

/**
 * Bezier Curves formulas obtained from
 * https://en.wikipedia.org/wiki/B%C3%A9zier_curve
 */

function CatmullRom(t, p0, p1, p2, p3) {
	const v0 = (p2 - p0) * 0.5;
	const v1 = (p3 - p1) * 0.5;
	const t2 = t * t;
	const t3 = t * t2;
	return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
}

//

function QuadraticBezierP0(t, p) {
	const k = 1 - t;
	return k * k * p;
}
function QuadraticBezierP1(t, p) {
	return 2 * (1 - t) * t * p;
}
function QuadraticBezierP2(t, p) {
	return t * t * p;
}
function QuadraticBezier(t, p0, p1, p2) {
	return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
}

//

function CubicBezierP0(t, p) {
	const k = 1 - t;
	return k * k * k * p;
}
function CubicBezierP1(t, p) {
	const k = 1 - t;
	return 3 * k * k * t * p;
}
function CubicBezierP2(t, p) {
	return 3 * (1 - t) * t * t * p;
}
function CubicBezierP3(t, p) {
	return t * t * t * p;
}
function CubicBezier(t, p0, p1, p2, p3) {
	return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
}

class CubicBezierCurve extends Curve {
	constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {
		super();
		this.isCubicBezierCurve = true;
		this.type = 'CubicBezierCurve';
		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;
	}
	getPoint(t, optionalTarget = new Vector2()) {
		const point = optionalTarget;
		const v0 = this.v0,
			v1 = this.v1,
			v2 = this.v2,
			v3 = this.v3;
		point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
		return point;
	}
	copy(source) {
		super.copy(source);
		this.v0.copy(source.v0);
		this.v1.copy(source.v1);
		this.v2.copy(source.v2);
		this.v3.copy(source.v3);
		return this;
	}
	toJSON() {
		const data = super.toJSON();
		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();
		return data;
	}
	fromJSON(json) {
		super.fromJSON(json);
		this.v0.fromArray(json.v0);
		this.v1.fromArray(json.v1);
		this.v2.fromArray(json.v2);
		this.v3.fromArray(json.v3);
		return this;
	}
}

class CubicBezierCurve3 extends Curve {
	constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()) {
		super();
		this.isCubicBezierCurve3 = true;
		this.type = 'CubicBezierCurve3';
		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;
	}
	getPoint(t, optionalTarget = new Vector3()) {
		const point = optionalTarget;
		const v0 = this.v0,
			v1 = this.v1,
			v2 = this.v2,
			v3 = this.v3;
		point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
		return point;
	}
	copy(source) {
		super.copy(source);
		this.v0.copy(source.v0);
		this.v1.copy(source.v1);
		this.v2.copy(source.v2);
		this.v3.copy(source.v3);
		return this;
	}
	toJSON() {
		const data = super.toJSON();
		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();
		return data;
	}
	fromJSON(json) {
		super.fromJSON(json);
		this.v0.fromArray(json.v0);
		this.v1.fromArray(json.v1);
		this.v2.fromArray(json.v2);
		this.v3.fromArray(json.v3);
		return this;
	}
}

class LineCurve extends Curve {
	constructor(v1 = new Vector2(), v2 = new Vector2()) {
		super();
		this.isLineCurve = true;
		this.type = 'LineCurve';
		this.v1 = v1;
		this.v2 = v2;
	}
	getPoint(t, optionalTarget = new Vector2()) {
		const point = optionalTarget;
		if (t === 1) {
			point.copy(this.v2);
		} else {
			point.copy(this.v2).sub(this.v1);
			point.multiplyScalar(t).add(this.v1);
		}
		return point;
	}

	// Line curve is linear, so we can overwrite default getPointAt
	getPointAt(u, optionalTarget) {
		return this.getPoint(u, optionalTarget);
	}
	getTangent(t, optionalTarget) {
		const tangent = optionalTarget || new Vector2();
		tangent.copy(this.v2).sub(this.v1).normalize();
		return tangent;
	}
	copy(source) {
		super.copy(source);
		this.v1.copy(source.v1);
		this.v2.copy(source.v2);
		return this;
	}
	toJSON() {
		const data = super.toJSON();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		return data;
	}
	fromJSON(json) {
		super.fromJSON(json);
		this.v1.fromArray(json.v1);
		this.v2.fromArray(json.v2);
		return this;
	}
}

class LineCurve3 extends Curve {
	constructor(v1 = new Vector3(), v2 = new Vector3()) {
		super();
		this.isLineCurve3 = true;
		this.type = 'LineCurve3';
		this.v1 = v1;
		this.v2 = v2;
	}
	getPoint(t, optionalTarget = new Vector3()) {
		const point = optionalTarget;
		if (t === 1) {
			point.copy(this.v2);
		} else {
			point.copy(this.v2).sub(this.v1);
			point.multiplyScalar(t).add(this.v1);
		}
		return point;
	}
	// Line curve is linear, so we can overwrite default getPointAt
	getPointAt(u, optionalTarget) {
		return this.getPoint(u, optionalTarget);
	}
	copy(source) {
		super.copy(source);
		this.v1.copy(source.v1);
		this.v2.copy(source.v2);
		return this;
	}
	toJSON() {
		const data = super.toJSON();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		return data;
	}
	fromJSON(json) {
		super.fromJSON(json);
		this.v1.fromArray(json.v1);
		this.v2.fromArray(json.v2);
		return this;
	}
}

class QuadraticBezierCurve extends Curve {
	constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {
		super();
		this.isQuadraticBezierCurve = true;
		this.type = 'QuadraticBezierCurve';
		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
	}
	getPoint(t, optionalTarget = new Vector2()) {
		const point = optionalTarget;
		const v0 = this.v0,
			v1 = this.v1,
			v2 = this.v2;
		point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
		return point;
	}
	copy(source) {
		super.copy(source);
		this.v0.copy(source.v0);
		this.v1.copy(source.v1);
		this.v2.copy(source.v2);
		return this;
	}
	toJSON() {
		const data = super.toJSON();
		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		return data;
	}
	fromJSON(json) {
		super.fromJSON(json);
		this.v0.fromArray(json.v0);
		this.v1.fromArray(json.v1);
		this.v2.fromArray(json.v2);
		return this;
	}
}

class QuadraticBezierCurve3 extends Curve {
	constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {
		super();
		this.isQuadraticBezierCurve3 = true;
		this.type = 'QuadraticBezierCurve3';
		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
	}
	getPoint(t, optionalTarget = new Vector3()) {
		const point = optionalTarget;
		const v0 = this.v0,
			v1 = this.v1,
			v2 = this.v2;
		point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));
		return point;
	}
	copy(source) {
		super.copy(source);
		this.v0.copy(source.v0);
		this.v1.copy(source.v1);
		this.v2.copy(source.v2);
		return this;
	}
	toJSON() {
		const data = super.toJSON();
		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		return data;
	}
	fromJSON(json) {
		super.fromJSON(json);
		this.v0.fromArray(json.v0);
		this.v1.fromArray(json.v1);
		this.v2.fromArray(json.v2);
		return this;
	}
}

class SplineCurve extends Curve {
	constructor(points = []) {
		super();
		this.isSplineCurve = true;
		this.type = 'SplineCurve';
		this.points = points;
	}
	getPoint(t, optionalTarget = new Vector2()) {
		const point = optionalTarget;
		const points = this.points;
		const p = (points.length - 1) * t;
		const intPoint = Math.floor(p);
		const weight = p - intPoint;
		const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
		const p1 = points[intPoint];
		const p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
		const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
		point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
		return point;
	}
	copy(source) {
		super.copy(source);
		this.points = [];
		for (let i = 0, l = source.points.length; i < l; i++) {
			const point = source.points[i];
			this.points.push(point.clone());
		}
		return this;
	}
	toJSON() {
		const data = super.toJSON();
		data.points = [];
		for (let i = 0, l = this.points.length; i < l; i++) {
			const point = this.points[i];
			data.points.push(point.toArray());
		}
		return data;
	}
	fromJSON(json) {
		super.fromJSON(json);
		this.points = [];
		for (let i = 0, l = json.points.length; i < l; i++) {
			const point = json.points[i];
			this.points.push(new Vector2().fromArray(point));
		}
		return this;
	}
}

var Curves = /*#__PURE__*/Object.freeze({
	__proto__: null,
	ArcCurve: ArcCurve,
	CatmullRomCurve3: CatmullRomCurve3,
	CubicBezierCurve: CubicBezierCurve,
	CubicBezierCurve3: CubicBezierCurve3,
	EllipseCurve: EllipseCurve,
	LineCurve: LineCurve,
	LineCurve3: LineCurve3,
	QuadraticBezierCurve: QuadraticBezierCurve,
	QuadraticBezierCurve3: QuadraticBezierCurve3,
	SplineCurve: SplineCurve
});

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *	curves, but retains the api of a curve
 **************************************************************/

class CurvePath extends Curve {
	constructor() {
		super();
		this.type = 'CurvePath';
		this.curves = [];
		this.autoClose = false; // Automatically closes the path
	}

	add(curve) {
		this.curves.push(curve);
	}
	closePath() {
		// Add a line curve if start and end of lines are not connected
		const startPoint = this.curves[0].getPoint(0);
		const endPoint = this.curves[this.curves.length - 1].getPoint(1);
		if (!startPoint.equals(endPoint)) {
			this.curves.push(new LineCurve(endPoint, startPoint));
		}
	}

	// To get accurate point with reference to
	// entire path distance at time t,
	// following has to be done:

	// 1. Length of each sub path have to be known
	// 2. Locate and identify type of curve
	// 3. Get t for the curve
	// 4. Return curve.getPointAt(t')

	getPoint(t, optionalTarget) {
		const d = t * this.getLength();
		const curveLengths = this.getCurveLengths();
		let i = 0;

		// To think about boundaries points.

		while (i < curveLengths.length) {
			if (curveLengths[i] >= d) {
				const diff = curveLengths[i] - d;
				const curve = this.curves[i];
				const segmentLength = curve.getLength();
				const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
				return curve.getPointAt(u, optionalTarget);
			}
			i++;
		}
		return null;

		// loop where sum != 0, sum > d , sum+1 <d
	}

	// We cannot use the default THREE.Curve getPoint() with getLength() because in
	// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
	// getPoint() depends on getLength

	getLength() {
		const lens = this.getCurveLengths();
		return lens[lens.length - 1];
	}

	// cacheLengths must be recalculated.
	updateArcLengths() {
		this.needsUpdate = true;
		this.cacheLengths = null;
		this.getCurveLengths();
	}

	// Compute lengths and cache them
	// We cannot overwrite getLengths() because UtoT mapping uses it.

	getCurveLengths() {
		// We use cache values if curves and cache array are same length

		if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
			return this.cacheLengths;
		}

		// Get length of sub-curve
		// Push sums into cached array

		const lengths = [];
		let sums = 0;
		for (let i = 0, l = this.curves.length; i < l; i++) {
			sums += this.curves[i].getLength();
			lengths.push(sums);
		}
		this.cacheLengths = lengths;
		return lengths;
	}
	getSpacedPoints(divisions = 40) {
		const points = [];
		for (let i = 0; i <= divisions; i++) {
			points.push(this.getPoint(i / divisions));
		}
		if (this.autoClose) {
			points.push(points[0]);
		}
		return points;
	}
	getPoints(divisions = 12) {
		const points = [];
		let last;
		for (let i = 0, curves = this.curves; i < curves.length; i++) {
			const curve = curves[i];
			const resolution = curve.isEllipseCurve ? divisions * 2 : curve.isLineCurve || curve.isLineCurve3 ? 1 : curve.isSplineCurve ? divisions * curve.points.length : divisions;
			const pts = curve.getPoints(resolution);
			for (let j = 0; j < pts.length; j++) {
				const point = pts[j];
				if (last && last.equals(point)) continue; // ensures no consecutive points are duplicates

				points.push(point);
				last = point;
			}
		}
		if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
			points.push(points[0]);
		}
		return points;
	}
	copy(source) {
		super.copy(source);
		this.curves = [];
		for (let i = 0, l = source.curves.length; i < l; i++) {
			const curve = source.curves[i];
			this.curves.push(curve.clone());
		}
		this.autoClose = source.autoClose;
		return this;
	}
	toJSON() {
		const data = super.toJSON();
		data.autoClose = this.autoClose;
		data.curves = [];
		for (let i = 0, l = this.curves.length; i < l; i++) {
			const curve = this.curves[i];
			data.curves.push(curve.toJSON());
		}
		return data;
	}
	fromJSON(json) {
		super.fromJSON(json);
		this.autoClose = json.autoClose;
		this.curves = [];
		for (let i = 0, l = json.curves.length; i < l; i++) {
			const curve = json.curves[i];
			this.curves.push(new Curves[curve.type]().fromJSON(curve));
		}
		return this;
	}
}

class Path extends CurvePath {
	constructor(points) {
		super();
		this.type = 'Path';
		this.currentPoint = new Vector2();
		if (points) {
			this.setFromPoints(points);
		}
	}
	setFromPoints(points) {
		this.moveTo(points[0].x, points[0].y);
		for (let i = 1, l = points.length; i < l; i++) {
			this.lineTo(points[i].x, points[i].y);
		}
		return this;
	}
	moveTo(x, y) {
		this.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?

		return this;
	}
	lineTo(x, y) {
		const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
		this.curves.push(curve);
		this.currentPoint.set(x, y);
		return this;
	}
	quadraticCurveTo(aCPx, aCPy, aX, aY) {
		const curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
		this.curves.push(curve);
		this.currentPoint.set(aX, aY);
		return this;
	}
	bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
		const curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
		this.curves.push(curve);
		this.currentPoint.set(aX, aY);
		return this;
	}
	splineThru(pts /*Array of Vector*/) {
		const npts = [this.currentPoint.clone()].concat(pts);
		const curve = new SplineCurve(npts);
		this.curves.push(curve);
		this.currentPoint.copy(pts[pts.length - 1]);
		return this;
	}
	arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
		const x0 = this.currentPoint.x;
		const y0 = this.currentPoint.y;
		this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
		return this;
	}
	absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
		this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
		return this;
	}
	ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
		const x0 = this.currentPoint.x;
		const y0 = this.currentPoint.y;
		this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
		return this;
	}
	absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
		const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
		if (this.curves.length > 0) {
			// if a previous curve is present, attempt to join
			const firstPoint = curve.getPoint(0);
			if (!firstPoint.equals(this.currentPoint)) {
				this.lineTo(firstPoint.x, firstPoint.y);
			}
		}
		this.curves.push(curve);
		const lastPoint = curve.getPoint(1);
		this.currentPoint.copy(lastPoint);
		return this;
	}
	copy(source) {
		super.copy(source);
		this.currentPoint.copy(source.currentPoint);
		return this;
	}
	toJSON() {
		const data = super.toJSON();
		data.currentPoint = this.currentPoint.toArray();
		return data;
	}
	fromJSON(json) {
		super.fromJSON(json);
		this.currentPoint.fromArray(json.currentPoint);
		return this;
	}
}

class LatheGeometry extends BufferGeometry {
	constructor(points = [new Vector2(0, -0.5), new Vector2(0.5, 0), new Vector2(0, 0.5)], segments = 12, phiStart = 0, phiLength = Math.PI * 2) {
		super();
		this.type = 'LatheGeometry';
		this.parameters = {
			points: points,
			segments: segments,
			phiStart: phiStart,
			phiLength: phiLength
		};
		segments = Math.floor(segments);

		// clamp phiLength so it's in range of [ 0, 2PI ]

		phiLength = clamp(phiLength, 0, Math.PI * 2);

		// buffers

		const indices = [];
		const vertices = [];
		const uvs = [];
		const initNormals = [];
		const normals = [];

		// helper variables

		const inverseSegments = 1.0 / segments;
		const vertex = new Vector3();
		const uv = new Vector2();
		const normal = new Vector3();
		const curNormal = new Vector3();
		const prevNormal = new Vector3();
		let dx = 0;
		let dy = 0;

		// pre-compute normals for initial "meridian"

		for (let j = 0; j <= points.length - 1; j++) {
			switch (j) {
				case 0:
					// special handling for 1st vertex on path

					dx = points[j + 1].x - points[j].x;
					dy = points[j + 1].y - points[j].y;
					normal.x = dy * 1.0;
					normal.y = -dx;
					normal.z = dy * 0.0;
					prevNormal.copy(normal);
					normal.normalize();
					initNormals.push(normal.x, normal.y, normal.z);
					break;
				case points.length - 1:
					// special handling for last Vertex on path

					initNormals.push(prevNormal.x, prevNormal.y, prevNormal.z);
					break;
				default:
					// default handling for all vertices in between

					dx = points[j + 1].x - points[j].x;
					dy = points[j + 1].y - points[j].y;
					normal.x = dy * 1.0;
					normal.y = -dx;
					normal.z = dy * 0.0;
					curNormal.copy(normal);
					normal.x += prevNormal.x;
					normal.y += prevNormal.y;
					normal.z += prevNormal.z;
					normal.normalize();
					initNormals.push(normal.x, normal.y, normal.z);
					prevNormal.copy(curNormal);
			}
		}

		// generate vertices, uvs and normals

		for (let i = 0; i <= segments; i++) {
			const phi = phiStart + i * inverseSegments * phiLength;
			const sin = Math.sin(phi);
			const cos = Math.cos(phi);
			for (let j = 0; j <= points.length - 1; j++) {
				// vertex

				vertex.x = points[j].x * sin;
				vertex.y = points[j].y;
				vertex.z = points[j].x * cos;
				vertices.push(vertex.x, vertex.y, vertex.z);

				// uv

				uv.x = i / segments;
				uv.y = j / (points.length - 1);
				uvs.push(uv.x, uv.y);

				// normal

				const x = initNormals[3 * j + 0] * sin;
				const y = initNormals[3 * j + 1];
				const z = initNormals[3 * j + 0] * cos;
				normals.push(x, y, z);
			}
		}

		// indices

		for (let i = 0; i < segments; i++) {
			for (let j = 0; j < points.length - 1; j++) {
				const base = j + i * points.length;
				const a = base;
				const b = base + points.length;
				const c = base + points.length + 1;
				const d = base + 1;

				// faces

				indices.push(a, b, d);
				indices.push(c, d, b);
			}
		}

		// build geometry

		this.setIndex(indices);
		this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
		this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
		this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
	}
	static fromJSON(data) {
		return new LatheGeometry(data.points, data.segments, data.phiStart, data.phiLength);
	}
}

class CapsuleGeometry extends LatheGeometry {
	constructor(radius = 1, length = 1, capSegments = 4, radialSegments = 8) {
		const path = new Path();
		path.absarc(0, -length / 2, radius, Math.PI * 1.5, 0);
		path.absarc(0, length / 2, radius, 0, Math.PI * 0.5);
		super(path.getPoints(capSegments), radialSegments);
		this.type = 'CapsuleGeometry';
		this.parameters = {
			radius: radius,
			height: length,
			capSegments: capSegments,
			radialSegments: radialSegments
		};
	}
	static fromJSON(data) {
		return new CapsuleGeometry(data.radius, data.length, data.capSegments, data.radialSegments);
	}
}

class CircleGeometry extends BufferGeometry {
	constructor(radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2) {
		super();
		this.type = 'CircleGeometry';
		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
		segments = Math.max(3, segments);

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		const vertex = new Vector3();
		const uv = new Vector2();

		// center point

		vertices.push(0, 0, 0);
		normals.push(0, 0, 1);
		uvs.push(0.5, 0.5);
		for (let s = 0, i = 3; s <= segments; s++, i += 3) {
			const segment = thetaStart + s / segments * thetaLength;

			// vertex

			vertex.x = radius * Math.cos(segment);
			vertex.y = radius * Math.sin(segment);
			vertices.push(vertex.x, vertex.y, vertex.z);

			// normal

			normals.push(0, 0, 1);

			// uvs

			uv.x = (vertices[i] / radius + 1) / 2;
			uv.y = (vertices[i + 1] / radius + 1) / 2;
			uvs.push(uv.x, uv.y);
		}

		// indices

		for (let i = 1; i <= segments; i++) {
			indices.push(i, i + 1, 0);
		}

		// build geometry

		this.setIndex(indices);
		this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
		this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
		this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
	}
	static fromJSON(data) {
		return new CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);
	}
}

class CylinderGeometry extends BufferGeometry {
	constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
		super();
		this.type = 'CylinderGeometry';
		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
		const scope = this;
		radialSegments = Math.floor(radialSegments);
		heightSegments = Math.floor(heightSegments);

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let index = 0;
		const indexArray = [];
		const halfHeight = height / 2;
		let groupStart = 0;

		// generate geometry

		generateTorso();
		if (openEnded === false) {
			if (radiusTop > 0) generateCap(true);
			if (radiusBottom > 0) generateCap(false);
		}

		// build geometry

		this.setIndex(indices);
		this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
		this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
		this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
		function generateTorso() {
			const normal = new Vector3();
			const vertex = new Vector3();
			let groupCount = 0;

			// this will be used to calculate the normal
			const slope = (radiusBottom - radiusTop) / height;

			// generate vertices, normals and uvs

			for (let y = 0; y <= heightSegments; y++) {
				const indexRow = [];
				const v = y / heightSegments;

				// calculate the radius of the current row

				const radius = v * (radiusBottom - radiusTop) + radiusTop;
				for (let x = 0; x <= radialSegments; x++) {
					const u = x / radialSegments;
					const theta = u * thetaLength + thetaStart;
					const sinTheta = Math.sin(theta);
					const cosTheta = Math.cos(theta);

					// vertex

					vertex.x = radius * sinTheta;
					vertex.y = -v * height + halfHeight;
					vertex.z = radius * cosTheta;
					vertices.push(vertex.x, vertex.y, vertex.z);

					// normal

					normal.set(sinTheta, slope, cosTheta).normalize();
					normals.push(normal.x, normal.y, normal.z);

					// uv

					uvs.push(u, 1 - v);

					// save index of vertex in respective row

					indexRow.push(index++);
				}

				// now save vertices of the row in our index array

				indexArray.push(indexRow);
			}

			// generate indices

			for (let x = 0; x < radialSegments; x++) {
				for (let y = 0; y < heightSegments; y++) {
					// we use the index array to access the correct indices

					const a = indexArray[y][x];
					const b = indexArray[y + 1][x];
					const c = indexArray[y + 1][x + 1];
					const d = indexArray[y][x + 1];

					// faces

					indices.push(a, b, d);
					indices.push(b, c, d);

					// update group counter

					groupCount += 6;
				}
			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup(groupStart, groupCount, 0);

			// calculate new start value for groups

			groupStart += groupCount;
		}
		function generateCap(top) {
			// save the index of the first center vertex
			const centerIndexStart = index;
			const uv = new Vector2();
			const vertex = new Vector3();
			let groupCount = 0;
			const radius = top === true ? radiusTop : radiusBottom;
			const sign = top === true ? 1 : -1;

			// first we generate the center vertex data of the cap.
			// because the geometry needs one set of uvs per face,
			// we must generate a center vertex per face/segment

			for (let x = 1; x <= radialSegments; x++) {
				// vertex

				vertices.push(0, halfHeight * sign, 0);

				// normal

				normals.push(0, sign, 0);

				// uv

				uvs.push(0.5, 0.5);

				// increase index

				index++;
			}

			// save the index of the last center vertex
			const centerIndexEnd = index;

			// now we generate the surrounding vertices, normals and uvs

			for (let x = 0; x <= radialSegments; x++) {
				const u = x / radialSegments;
				const theta = u * thetaLength + thetaStart;
				const cosTheta = Math.cos(theta);
				const sinTheta = Math.sin(theta);

				// vertex

				vertex.x = radius * sinTheta;
				vertex.y = halfHeight * sign;
				vertex.z = radius * cosTheta;
				vertices.push(vertex.x, vertex.y, vertex.z);

				// normal

				normals.push(0, sign, 0);

				// uv

				uv.x = cosTheta * 0.5 + 0.5;
				uv.y = sinTheta * 0.5 * sign + 0.5;
				uvs.push(uv.x, uv.y);

				// increase index

				index++;
			}

			// generate indices

			for (let x = 0; x < radialSegments; x++) {
				const c = centerIndexStart + x;
				const i = centerIndexEnd + x;
				if (top === true) {
					// face top

					indices.push(i, i + 1, c);
				} else {
					// face bottom

					indices.push(i + 1, i, c);
				}
				groupCount += 3;
			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);

			// calculate new start value for groups

			groupStart += groupCount;
		}
	}
	static fromJSON(data) {
		return new CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
	}
}

class ConeGeometry extends CylinderGeometry {
	constructor(radius = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
		super(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
		this.type = 'ConeGeometry';
		this.parameters = {
			radius: radius,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
	}
	static fromJSON(data) {
		return new ConeGeometry(data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
	}
}

class PolyhedronGeometry extends BufferGeometry {
	constructor(vertices = [], indices = [], radius = 1, detail = 0) {
		super();
		this.type = 'PolyhedronGeometry';
		this.parameters = {
			vertices: vertices,
			indices: indices,
			radius: radius,
			detail: detail
		};

		// default buffer data

		const vertexBuffer = [];
		const uvBuffer = [];

		// the subdivision creates the vertex buffer data

		subdivide(detail);

		// all vertices should lie on a conceptual sphere with a given radius

		applyRadius(radius);

		// finally, create the uv data

		generateUVs();

		// build non-indexed geometry

		this.setAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));
		this.setAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));
		this.setAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));
		if (detail === 0) {
			this.computeVertexNormals(); // flat normals
		} else {
			this.normalizeNormals(); // smooth normals
		}

		// helper functions

		function subdivide(detail) {
			const a = new Vector3();
			const b = new Vector3();
			const c = new Vector3();

			// iterate over all faces and apply a subdivison with the given detail value

			for (let i = 0; i < indices.length; i += 3) {
				// get the vertices of the face

				getVertexByIndex(indices[i + 0], a);
				getVertexByIndex(indices[i + 1], b);
				getVertexByIndex(indices[i + 2], c);

				// perform subdivision

				subdivideFace(a, b, c, detail);
			}
		}
		function subdivideFace(a, b, c, detail) {
			const cols = detail + 1;

			// we use this multidimensional array as a data structure for creating the subdivision

			const v = [];

			// construct all of the vertices for this subdivision

			for (let i = 0; i <= cols; i++) {
				v[i] = [];
				const aj = a.clone().lerp(c, i / cols);
				const bj = b.clone().lerp(c, i / cols);
				const rows = cols - i;
				for (let j = 0; j <= rows; j++) {
					if (j === 0 && i === cols) {
						v[i][j] = aj;
					} else {
						v[i][j] = aj.clone().lerp(bj, j / rows);
					}
				}
			}

			// construct all of the faces

			for (let i = 0; i < cols; i++) {
				for (let j = 0; j < 2 * (cols - i) - 1; j++) {
					const k = Math.floor(j / 2);
					if (j % 2 === 0) {
						pushVertex(v[i][k + 1]);
						pushVertex(v[i + 1][k]);
						pushVertex(v[i][k]);
					} else {
						pushVertex(v[i][k + 1]);
						pushVertex(v[i + 1][k + 1]);
						pushVertex(v[i + 1][k]);
					}
				}
			}
		}
		function applyRadius(radius) {
			const vertex = new Vector3();

			// iterate over the entire buffer and apply the radius to each vertex

			for (let i = 0; i < vertexBuffer.length; i += 3) {
				vertex.x = vertexBuffer[i + 0];
				vertex.y = vertexBuffer[i + 1];
				vertex.z = vertexBuffer[i + 2];
				vertex.normalize().multiplyScalar(radius);
				vertexBuffer[i + 0] = vertex.x;
				vertexBuffer[i + 1] = vertex.y;
				vertexBuffer[i + 2] = vertex.z;
			}
		}
		function generateUVs() {
			const vertex = new Vector3();
			for (let i = 0; i < vertexBuffer.length; i += 3) {
				vertex.x = vertexBuffer[i + 0];
				vertex.y = vertexBuffer[i + 1];
				vertex.z = vertexBuffer[i + 2];
				const u = azimuth(vertex) / 2 / Math.PI + 0.5;
				const v = inclination(vertex) / Math.PI + 0.5;
				uvBuffer.push(u, 1 - v);
			}
			correctUVs();
			correctSeam();
		}
		function correctSeam() {
			// handle case when face straddles the seam, see #3269

			for (let i = 0; i < uvBuffer.length; i += 6) {
				// uv data of a single face

				const x0 = uvBuffer[i + 0];
				const x1 = uvBuffer[i + 2];
				const x2 = uvBuffer[i + 4];
				const max = Math.max(x0, x1, x2);
				const min = Math.min(x0, x1, x2);

				// 0.9 is somewhat arbitrary

				if (max > 0.9 && min < 0.1) {
					if (x0 < 0.2) uvBuffer[i + 0] += 1;
					if (x1 < 0.2) uvBuffer[i + 2] += 1;
					if (x2 < 0.2) uvBuffer[i + 4] += 1;
				}
			}
		}
		function pushVertex(vertex) {
			vertexBuffer.push(vertex.x, vertex.y, vertex.z);
		}
		function getVertexByIndex(index, vertex) {
			const stride = index * 3;
			vertex.x = vertices[stride + 0];
			vertex.y = vertices[stride + 1];
			vertex.z = vertices[stride + 2];
		}
		function correctUVs() {
			const a = new Vector3();
			const b = new Vector3();
			const c = new Vector3();
			const centroid = new Vector3();
			const uvA = new Vector2();
			const uvB = new Vector2();
			const uvC = new Vector2();
			for (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
				a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
				b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
				c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
				uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
				uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
				uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
				centroid.copy(a).add(b).add(c).divideScalar(3);
				const azi = azimuth(centroid);
				correctUV(uvA, j + 0, a, azi);
				correctUV(uvB, j + 2, b, azi);
				correctUV(uvC, j + 4, c, azi);
			}
		}
		function correctUV(uv, stride, vector, azimuth) {
			if (azimuth < 0 && uv.x === 1) {
				uvBuffer[stride] = uv.x - 1;
			}
			if (vector.x === 0 && vector.z === 0) {
				uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;
			}
		}

		// Angle around the Y axis, counter-clockwise when looking from above.

		function azimuth(vector) {
			return Math.atan2(vector.z, -vector.x);
		}

		// Angle above the XZ plane.

		function inclination(vector) {
			return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
		}
	}
	static fromJSON(data) {
		return new PolyhedronGeometry(data.vertices, data.indices, data.radius, data.details);
	}
}

class DodecahedronGeometry extends PolyhedronGeometry {
	constructor(radius = 1, detail = 0) {
		const t = (1 + Math.sqrt(5)) / 2;
		const r = 1 / t;
		const vertices = [
		// (±1, ±1, ±1)
		-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1,
		// (0, ±1/φ, ±φ)
		0, -r, -t, 0, -r, t, 0, r, -t, 0, r, t,
		// (±1/φ, ±φ, 0)
		-r, -t, 0, -r, t, 0, r, -t, 0, r, t, 0,
		// (±φ, 0, ±1/φ)
		-t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r];
		const indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
		super(vertices, indices, radius, detail);
		this.type = 'DodecahedronGeometry';
		this.parameters = {
			radius: radius,
			detail: detail
		};
	}
	static fromJSON(data) {
		return new DodecahedronGeometry(data.radius, data.detail);
	}
}

const _v0 = /*@__PURE__*/new Vector3();
const _v1$1 = /*@__PURE__*/new Vector3();
const _normal = /*@__PURE__*/new Vector3();
const _triangle = /*@__PURE__*/new Triangle();
class EdgesGeometry extends BufferGeometry {
	constructor(geometry = null, thresholdAngle = 1) {
		super();
		this.type = 'EdgesGeometry';
		this.parameters = {
			geometry: geometry,
			thresholdAngle: thresholdAngle
		};
		if (geometry !== null) {
			const precisionPoints = 4;
			const precision = Math.pow(10, precisionPoints);
			const thresholdDot = Math.cos(DEG2RAD * thresholdAngle);
			const indexAttr = geometry.getIndex();
			const positionAttr = geometry.getAttribute('position');
			const indexCount = indexAttr ? indexAttr.count : positionAttr.count;
			const indexArr = [0, 0, 0];
			const vertKeys = ['a', 'b', 'c'];
			const hashes = new Array(3);
			const edgeData = {};
			const vertices = [];
			for (let i = 0; i < indexCount; i += 3) {
				if (indexAttr) {
					indexArr[0] = indexAttr.getX(i);
					indexArr[1] = indexAttr.getX(i + 1);
					indexArr[2] = indexAttr.getX(i + 2);
				} else {
					indexArr[0] = i;
					indexArr[1] = i + 1;
					indexArr[2] = i + 2;
				}
				const {
					a,
					b,
					c
				} = _triangle;
				a.fromBufferAttribute(positionAttr, indexArr[0]);
				b.fromBufferAttribute(positionAttr, indexArr[1]);
				c.fromBufferAttribute(positionAttr, indexArr[2]);
				_triangle.getNormal(_normal);

				// create hashes for the edge from the vertices
				hashes[0] = `${Math.round(a.x * precision)},${Math.round(a.y * precision)},${Math.round(a.z * precision)}`;
				hashes[1] = `${Math.round(b.x * precision)},${Math.round(b.y * precision)},${Math.round(b.z * precision)}`;
				hashes[2] = `${Math.round(c.x * precision)},${Math.round(c.y * precision)},${Math.round(c.z * precision)}`;

				// skip degenerate triangles
				if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {
					continue;
				}

				// iterate over every edge
				for (let j = 0; j < 3; j++) {
					// get the first and next vertex making up the edge
					const jNext = (j + 1) % 3;
					const vecHash0 = hashes[j];
					const vecHash1 = hashes[jNext];
					const v0 = _triangle[vertKeys[j]];
					const v1 = _triangle[vertKeys[jNext]];
					const hash = `${vecHash0}_${vecHash1}`;
					const reverseHash = `${vecHash1}_${vecHash0}`;
					if (reverseHash in edgeData && edgeData[reverseHash]) {
						// if we found a sibling edge add it into the vertex array if
						// it meets the angle threshold and delete the edge from the map.
						if (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {
							vertices.push(v0.x, v0.y, v0.z);
							vertices.push(v1.x, v1.y, v1.z);
						}
						edgeData[reverseHash] = null;
					} else if (!(hash in edgeData)) {
						// if we've already got an edge here then skip adding a new one
						edgeData[hash] = {
							index0: indexArr[j],
							index1: indexArr[jNext],
							normal: _normal.clone()
						};
					}
				}
			}

			// iterate over all remaining, unmatched edges and add them to the vertex array
			for (const key in edgeData) {
				if (edgeData[key]) {
					const {
						index0,
						index1
					} = edgeData[key];
					_v0.fromBufferAttribute(positionAttr, index0);
					_v1$1.fromBufferAttribute(positionAttr, index1);
					vertices.push(_v0.x, _v0.y, _v0.z);
					vertices.push(_v1$1.x, _v1$1.y, _v1$1.z);
				}
			}
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
		}
	}
}

class Shape extends Path {
	constructor(points) {
		super(points);
		this.uuid = generateUUID();
		this.type = 'Shape';
		this.holes = [];
	}
	getPointsHoles(divisions) {
		const holesPts = [];
		for (let i = 0, l = this.holes.length; i < l; i++) {
			holesPts[i] = this.holes[i].getPoints(divisions);
		}
		return holesPts;
	}

	// get points of shape and holes (keypoints based on segments parameter)

	extractPoints(divisions) {
		return {
			shape: this.getPoints(divisions),
			holes: this.getPointsHoles(divisions)
		};
	}
	copy(source) {
		super.copy(source);
		this.holes = [];
		for (let i = 0, l = source.holes.length; i < l; i++) {
			const hole = source.holes[i];
			this.holes.push(hole.clone());
		}
		return this;
	}
	toJSON() {
		const data = super.toJSON();
		data.uuid = this.uuid;
		data.holes = [];
		for (let i = 0, l = this.holes.length; i < l; i++) {
			const hole = this.holes[i];
			data.holes.push(hole.toJSON());
		}
		return data;
	}
	fromJSON(json) {
		super.fromJSON(json);
		this.uuid = json.uuid;
		this.holes = [];
		for (let i = 0, l = json.holes.length; i < l; i++) {
			const hole = json.holes[i];
			this.holes.push(new Path().fromJSON(hole));
		}
		return this;
	}
}

/**
 * Port from https://github.com/mapbox/earcut (v2.2.4)
 */

const Earcut = {
	triangulate: function (data, holeIndices, dim = 2) {
		const hasHoles = holeIndices && holeIndices.length;
		const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
		let outerNode = linkedList(data, 0, outerLen, dim, true);
		const triangles = [];
		if (!outerNode || outerNode.next === outerNode.prev) return triangles;
		let minX, minY, maxX, maxY, x, y, invSize;
		if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

		// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
		if (data.length > 80 * dim) {
			minX = maxX = data[0];
			minY = maxY = data[1];
			for (let i = dim; i < outerLen; i += dim) {
				x = data[i];
				y = data[i + 1];
				if (x < minX) minX = x;
				if (y < minY) minY = y;
				if (x > maxX) maxX = x;
				if (y > maxY) maxY = y;
			}

			// minX, minY and invSize are later used to transform coords into integers for z-order calculation
			invSize = Math.max(maxX - minX, maxY - minY);
			invSize = invSize !== 0 ? 32767 / invSize : 0;
		}
		earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
		return triangles;
	}
};

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
	let i, last;
	if (clockwise === signedArea(data, start, end, dim) > 0) {
		for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
	} else {
		for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
	}
	if (last && equals(last, last.next)) {
		removeNode(last);
		last = last.next;
	}
	return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
	if (!start) return start;
	if (!end) end = start;
	let p = start,
		again;
	do {
		again = false;
		if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
			removeNode(p);
			p = end = p.prev;
			if (p === p.next) break;
			again = true;
		} else {
			p = p.next;
		}
	} while (again || p !== end);
	return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
	if (!ear) return;

	// interlink polygon nodes in z-order
	if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
	let stop = ear,
		prev,
		next;

	// iterate through ears, slicing them one by one
	while (ear.prev !== ear.next) {
		prev = ear.prev;
		next = ear.next;
		if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
			// cut off the triangle
			triangles.push(prev.i / dim | 0);
			triangles.push(ear.i / dim | 0);
			triangles.push(next.i / dim | 0);
			removeNode(ear);

			// skipping the next vertex leads to less sliver triangles
			ear = next.next;
			stop = next.next;
			continue;
		}
		ear = next;

		// if we looped through the whole remaining polygon and can't find any more ears
		if (ear === stop) {
			// try filtering points and slicing again
			if (!pass) {
				earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

				// if this didn't work, try curing all small self-intersections locally
			} else if (pass === 1) {
				ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
				earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

				// as a last resort, try splitting the remaining polygon into two
			} else if (pass === 2) {
				splitEarcut(ear, triangles, dim, minX, minY, invSize);
			}
			break;
		}
	}
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
	const a = ear.prev,
		b = ear,
		c = ear.next;
	if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

	// now make sure we don't have other points inside the potential ear
	const ax = a.x,
		bx = b.x,
		cx = c.x,
		ay = a.y,
		by = b.y,
		cy = c.y;

	// triangle bbox; min & max are calculated like this for speed
	const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx,
		y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy,
		x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx,
		y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
	let p = c.next;
	while (p !== a) {
		if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
		p = p.next;
	}
	return true;
}
function isEarHashed(ear, minX, minY, invSize) {
	const a = ear.prev,
		b = ear,
		c = ear.next;
	if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

	const ax = a.x,
		bx = b.x,
		cx = c.x,
		ay = a.y,
		by = b.y,
		cy = c.y;

	// triangle bbox; min & max are calculated like this for speed
	const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx,
		y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy,
		x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx,
		y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;

	// z-order range for the current triangle bbox;
	const minZ = zOrder(x0, y0, minX, minY, invSize),
		maxZ = zOrder(x1, y1, minX, minY, invSize);
	let p = ear.prevZ,
		n = ear.nextZ;

	// look for points inside the triangle in both directions
	while (p && p.z >= minZ && n && n.z <= maxZ) {
		if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
		p = p.prevZ;
		if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
		n = n.nextZ;
	}

	// look for remaining points in decreasing z-order
	while (p && p.z >= minZ) {
		if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
		p = p.prevZ;
	}

	// look for remaining points in increasing z-order
	while (n && n.z <= maxZ) {
		if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
		n = n.nextZ;
	}
	return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
	let p = start;
	do {
		const a = p.prev,
			b = p.next.next;
		if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
			triangles.push(a.i / dim | 0);
			triangles.push(p.i / dim | 0);
			triangles.push(b.i / dim | 0);

			// remove two nodes involved
			removeNode(p);
			removeNode(p.next);
			p = start = b;
		}
		p = p.next;
	} while (p !== start);
	return filterPoints(p);
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
	// look for a valid diagonal that divides the polygon into two
	let a = start;
	do {
		let b = a.next.next;
		while (b !== a.prev) {
			if (a.i !== b.i && isValidDiagonal(a, b)) {
				// split the polygon in two by the diagonal
				let c = splitPolygon(a, b);

				// filter colinear points around the cuts
				a = filterPoints(a, a.next);
				c = filterPoints(c, c.next);

				// run earcut on each half
				earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
				earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
				return;
			}
			b = b.next;
		}
		a = a.next;
	} while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
	const queue = [];
	let i, len, start, end, list;
	for (i = 0, len = holeIndices.length; i < len; i++) {
		start = holeIndices[i] * dim;
		end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
		list = linkedList(data, start, end, dim, false);
		if (list === list.next) list.steiner = true;
		queue.push(getLeftmost(list));
	}
	queue.sort(compareX);

	// process holes from left to right
	for (i = 0; i < queue.length; i++) {
		outerNode = eliminateHole(queue[i], outerNode);
	}
	return outerNode;
}
function compareX(a, b) {
	return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and link it
function eliminateHole(hole, outerNode) {
	const bridge = findHoleBridge(hole, outerNode);
	if (!bridge) {
		return outerNode;
	}
	const bridgeReverse = splitPolygon(bridge, hole);

	// filter collinear points around the cuts
	filterPoints(bridgeReverse, bridgeReverse.next);
	return filterPoints(bridge, bridge.next);
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
	let p = outerNode,
		qx = -Infinity,
		m;
	const hx = hole.x,
		hy = hole.y;

	// find a segment intersected by a ray from the hole's leftmost point to the left;
	// segment's endpoint with lesser x will be potential connection point
	do {
		if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
			const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
			if (x <= hx && x > qx) {
				qx = x;
				m = p.x < p.next.x ? p : p.next;
				if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint
			}
		}

		p = p.next;
	} while (p !== outerNode);
	if (!m) return null;

	// look for points inside the triangle of hole point, segment intersection and endpoint;
	// if there are no points found, we have a valid connection;
	// otherwise choose the point of the minimum angle with the ray as connection point

	const stop = m,
		mx = m.x,
		my = m.y;
	let tanMin = Infinity,
		tan;
	p = m;
	do {
		if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
			tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

			if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
				m = p;
				tanMin = tan;
			}
		}
		p = p.next;
	} while (p !== stop);
	return m;
}

// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
	return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
	let p = start;
	do {
		if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
		p.prevZ = p.prev;
		p.nextZ = p.next;
		p = p.next;
	} while (p !== start);
	p.prevZ.nextZ = null;
	p.prevZ = null;
	sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
	let i,
		p,
		q,
		e,
		tail,
		numMerges,
		pSize,
		qSize,
		inSize = 1;
	do {
		p = list;
		list = null;
		tail = null;
		numMerges = 0;
		while (p) {
			numMerges++;
			q = p;
			pSize = 0;
			for (i = 0; i < inSize; i++) {
				pSize++;
				q = q.nextZ;
				if (!q) break;
			}
			qSize = inSize;
			while (pSize > 0 || qSize > 0 && q) {
				if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
					e = p;
					p = p.nextZ;
					pSize--;
				} else {
					e = q;
					q = q.nextZ;
					qSize--;
				}
				if (tail) tail.nextZ = e;else list = e;
				e.prevZ = tail;
				tail = e;
			}
			p = q;
		}
		tail.nextZ = null;
		inSize *= 2;
	} while (numMerges > 1);
	return list;
}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
	// coords are transformed into non-negative 15-bit integer range
	x = (x - minX) * invSize | 0;
	y = (y - minY) * invSize | 0;
	x = (x | x << 8) & 0x00FF00FF;
	x = (x | x << 4) & 0x0F0F0F0F;
	x = (x | x << 2) & 0x33333333;
	x = (x | x << 1) & 0x55555555;
	y = (y | y << 8) & 0x00FF00FF;
	y = (y | y << 4) & 0x0F0F0F0F;
	y = (y | y << 2) & 0x33333333;
	y = (y | y << 1) & 0x55555555;
	return x | y << 1;
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
	let p = start,
		leftmost = start;
	do {
		if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
		p = p.next;
	} while (p !== start);
	return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
	return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
	return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (
	// dones't intersect other edges
	locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (
	// locally visible
	area(a.prev, a, b.prev) || area(a, b.prev, b)) ||
	// does not create opposite-facing sectors
	equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
}

// signed area of a triangle
function area(p, q, r) {
	return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
	return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
	const o1 = sign(area(p1, q1, p2));
	const o2 = sign(area(p1, q1, q2));
	const o3 = sign(area(p2, q2, p1));
	const o4 = sign(area(p2, q2, q1));
	if (o1 !== o2 && o3 !== o4) return true; // general case

	if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
	if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
	if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
	if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

	return false;
}

// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r) {
	return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}
function sign(num) {
	return num > 0 ? 1 : num < 0 ? -1 : 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
	let p = a;
	do {
		if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
		p = p.next;
	} while (p !== a);
	return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
	return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
	let p = a,
		inside = false;
	const px = (a.x + b.x) / 2,
		py = (a.y + b.y) / 2;
	do {
		if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
		p = p.next;
	} while (p !== a);
	return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
	const a2 = new Node(a.i, a.x, a.y),
		b2 = new Node(b.i, b.x, b.y),
		an = a.next,
		bp = b.prev;
	a.next = b;
	b.prev = a;
	a2.next = an;
	an.prev = a2;
	b2.next = a2;
	a2.prev = b2;
	bp.next = b2;
	b2.prev = bp;
	return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
	const p = new Node(i, x, y);
	if (!last) {
		p.prev = p;
		p.next = p;
	} else {
		p.next = last.next;
		p.prev = last;
		last.next.prev = p;
		last.next = p;
	}
	return p;
}
function removeNode(p) {
	p.next.prev = p.prev;
	p.prev.next = p.next;
	if (p.prevZ) p.prevZ.nextZ = p.nextZ;
	if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}
function Node(i, x, y) {
	// vertex index in coordinates array
	this.i = i;

	// vertex coordinates
	this.x = x;
	this.y = y;

	// previous and next vertex nodes in a polygon ring
	this.prev = null;
	this.next = null;

	// z-order curve value
	this.z = 0;

	// previous and next nodes in z-order
	this.prevZ = null;
	this.nextZ = null;

	// indicates whether this is a steiner point
	this.steiner = false;
}
function signedArea(data, start, end, dim) {
	let sum = 0;
	for (let i = start, j = end - dim; i < end; i += dim) {
		sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
		j = i;
	}
	return sum;
}

class ShapeUtils {
	// calculate area of the contour polygon

	static area(contour) {
		const n = contour.length;
		let a = 0.0;
		for (let p = n - 1, q = 0; q < n; p = q++) {
			a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
		}
		return a * 0.5;
	}
	static isClockWise(pts) {
		return ShapeUtils.area(pts) < 0;
	}
	static triangulateShape(contour, holes) {
		const vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
		const holeIndices = []; // array of hole indices
		const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

		removeDupEndPts(contour);
		addContour(vertices, contour);

		//

		let holeIndex = contour.length;
		holes.forEach(removeDupEndPts);
		for (let i = 0; i < holes.length; i++) {
			holeIndices.push(holeIndex);
			holeIndex += holes[i].length;
			addContour(vertices, holes[i]);
		}

		//

		const triangles = Earcut.triangulate(vertices, holeIndices);

		//

		for (let i = 0; i < triangles.length; i += 3) {
			faces.push(triangles.slice(i, i + 3));
		}
		return faces;
	}
}
function removeDupEndPts(points) {
	const l = points.length;
	if (l > 2 && points[l - 1].equals(points[0])) {
		points.pop();
	}
}
function addContour(vertices, contour) {
	for (let i = 0; i < contour.length; i++) {
		vertices.push(contour[i].x);
		vertices.push(contour[i].y);
	}
}

/**
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *	curveSegments: <int>, // number of points on the curves
 *	steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *	depth: <float>, // Depth to extrude the shape
 *
 *	bevelEnabled: <bool>, // turn on bevel
 *	bevelThickness: <float>, // how deep into the original shape bevel goes
 *	bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
 *	bevelOffset: <float>, // how far from shape outline does bevel start
 *	bevelSegments: <int>, // number of bevel layers
 *
 *	extrudePath: <THREE.Curve> // curve to extrude shape along
 *
 *	UVGenerator: <Object> // object that provides UV generator functions
 *
 * }
 */
class ExtrudeGeometry extends BufferGeometry {
	constructor(shapes = new Shape([new Vector2(0.5, 0.5), new Vector2(-0.5, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), options = {}) {
		super();
		this.type = 'ExtrudeGeometry';
		this.parameters = {
			shapes: shapes,
			options: options
		};
		shapes = Array.isArray(shapes) ? shapes : [shapes];
		const scope = this;
		const verticesArray = [];
		const uvArray = [];
		for (let i = 0, l = shapes.length; i < l; i++) {
			const shape = shapes[i];
			addShape(shape);
		}

		// build geometry

		this.setAttribute('position', new Float32BufferAttribute(verticesArray, 3));
		this.setAttribute('uv', new Float32BufferAttribute(uvArray, 2));
		this.computeVertexNormals();

		// functions

		function addShape(shape) {
			const placeholder = [];

			// options

			const curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
			const steps = options.steps !== undefined ? options.steps : 1;
			const depth = options.depth !== undefined ? options.depth : 1;
			let bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
			let bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 0.2;
			let bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 0.1;
			let bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
			let bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
			const extrudePath = options.extrudePath;
			const uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;

			//

			let extrudePts,
				extrudeByPath = false;
			let splineTube, binormal, normal, position2;
			if (extrudePath) {
				extrudePts = extrudePath.getSpacedPoints(steps);
				extrudeByPath = true;
				bevelEnabled = false; // bevels not supported for path extrusion

				// SETUP TNB variables

				// TODO1 - have a .isClosed in spline?

				splineTube = extrudePath.computeFrenetFrames(steps, false);

				// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

				binormal = new Vector3();
				normal = new Vector3();
				position2 = new Vector3();
			}

			// Safeguards if bevels are not enabled

			if (!bevelEnabled) {
				bevelSegments = 0;
				bevelThickness = 0;
				bevelSize = 0;
				bevelOffset = 0;
			}

			// Variables initialization

			const shapePoints = shape.extractPoints(curveSegments);
			let vertices = shapePoints.shape;
			const holes = shapePoints.holes;
			const reverse = !ShapeUtils.isClockWise(vertices);
			if (reverse) {
				vertices = vertices.reverse();

				// Maybe we should also check if holes are in the opposite direction, just to be safe ...

				for (let h = 0, hl = holes.length; h < hl; h++) {
					const ahole = holes[h];
					if (ShapeUtils.isClockWise(ahole)) {
						holes[h] = ahole.reverse();
					}
				}
			}
			const faces = ShapeUtils.triangulateShape(vertices, holes);

			/* Vertices */

			const contour = vertices; // vertices has all points but contour has only points of circumference

			for (let h = 0, hl = holes.length; h < hl; h++) {
				const ahole = holes[h];
				vertices = vertices.concat(ahole);
			}
			function scalePt2(pt, vec, size) {
				if (!vec) console.error('THREE.ExtrudeGeometry: vec does not exist');
				return vec.clone().multiplyScalar(size).add(pt);
			}
			const vlen = vertices.length,
				flen = faces.length;

			// Find directions for point movement

			function getBevelVec(inPt, inPrev, inNext) {
				// computes for inPt the corresponding point inPt' on a new contour
				//	 shifted by 1 unit (length of normalized vector) to the left
				// if we walk along contour clockwise, this new contour is outside the old one
				//
				// inPt' is the intersection of the two lines parallel to the two
				//	adjacent edges of inPt at a distance of 1 unit on the left side.

				let v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt

				// good reading for geometry algorithms (here: line-line intersection)
				// http://geomalgorithms.com/a05-_intersect-1.html

				const v_prev_x = inPt.x - inPrev.x,
					v_prev_y = inPt.y - inPrev.y;
				const v_next_x = inNext.x - inPt.x,
					v_next_y = inNext.y - inPt.y;
				const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;

				// check for collinear edges
				const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
				if (Math.abs(collinear0) > Number.EPSILON) {
					// not collinear

					// length of vectors for normalizing

					const v_prev_len = Math.sqrt(v_prev_lensq);
					const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);

					// shift adjacent points by unit vectors to the left

					const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
					const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
					const ptNextShift_x = inNext.x - v_next_y / v_next_len;
					const ptNextShift_y = inNext.y + v_next_x / v_next_len;

					// scaling factor for v_prev to intersection point

					const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);

					// vector from inPt to intersection point

					v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
					v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;

					// Don't normalize!, otherwise sharp corners become ugly
					//	but prevent crazy spikes
					const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
					if (v_trans_lensq <= 2) {
						return new Vector2(v_trans_x, v_trans_y);
					} else {
						shrink_by = Math.sqrt(v_trans_lensq / 2);
					}
				} else {
					// handle special case of collinear edges

					let direction_eq = false; // assumes: opposite

					if (v_prev_x > Number.EPSILON) {
						if (v_next_x > Number.EPSILON) {
							direction_eq = true;
						}
					} else {
						if (v_prev_x < -Number.EPSILON) {
							if (v_next_x < -Number.EPSILON) {
								direction_eq = true;
							}
						} else {
							if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
								direction_eq = true;
							}
						}
					}
					if (direction_eq) {
						// console.log("Warning: lines are a straight sequence");
						v_trans_x = -v_prev_y;
						v_trans_y = v_prev_x;
						shrink_by = Math.sqrt(v_prev_lensq);
					} else {
						// console.log("Warning: lines are a straight spike");
						v_trans_x = v_prev_x;
						v_trans_y = v_prev_y;
						shrink_by = Math.sqrt(v_prev_lensq / 2);
					}
				}
				return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
			}
			const contourMovements = [];
			for (let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
				if (j === il) j = 0;
				if (k === il) k = 0;

				//	(j)---(i)---(k)
				// console.log('i,j,k', i, j , k)

				contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
			}
			const holesMovements = [];
			let oneHoleMovements,
				verticesMovements = contourMovements.concat();
			for (let h = 0, hl = holes.length; h < hl; h++) {
				const ahole = holes[h];
				oneHoleMovements = [];
				for (let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
					if (j === il) j = 0;
					if (k === il) k = 0;

					//	(j)---(i)---(k)
					oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
				}
				holesMovements.push(oneHoleMovements);
				verticesMovements = verticesMovements.concat(oneHoleMovements);
			}

			// Loop bevelSegments, 1 for the front, 1 for the back

			for (let b = 0; b < bevelSegments; b++) {
				//for ( b = bevelSegments; b > 0; b -- ) {

				const t = b / bevelSegments;
				const z = bevelThickness * Math.cos(t * Math.PI / 2);
				const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;

				// contract shape

				for (let i = 0, il = contour.length; i < il; i++) {
					const vert = scalePt2(contour[i], contourMovements[i], bs);
					v(vert.x, vert.y, -z);
				}

				// expand holes

				for (let h = 0, hl = holes.length; h < hl; h++) {
					const ahole = holes[h];
					oneHoleMovements = holesMovements[h];
					for (let i = 0, il = ahole.length; i < il; i++) {
						const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
						v(vert.x, vert.y, -z);
					}
				}
			}
			const bs = bevelSize + bevelOffset;

			// Back facing vertices

			for (let i = 0; i < vlen; i++) {
				const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
				if (!extrudeByPath) {
					v(vert.x, vert.y, 0);
				} else {
					// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

					normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
					binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
					position2.copy(extrudePts[0]).add(normal).add(binormal);
					v(position2.x, position2.y, position2.z);
				}
			}

			// Add stepped vertices...
			// Including front facing vertices

			for (let s = 1; s <= steps; s++) {
				for (let i = 0; i < vlen; i++) {
					const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
					if (!extrudeByPath) {
						v(vert.x, vert.y, depth / steps * s);
					} else {
						// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

						normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
						binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
						position2.copy(extrudePts[s]).add(normal).add(binormal);
						v(position2.x, position2.y, position2.z);
					}
				}
			}

			// Add bevel segments planes

			//for ( b = 1; b <= bevelSegments; b ++ ) {
			for (let b = bevelSegments - 1; b >= 0; b--) {
				const t = b / bevelSegments;
				const z = bevelThickness * Math.cos(t * Math.PI / 2);
				const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;

				// contract shape

				for (let i = 0, il = contour.length; i < il; i++) {
					const vert = scalePt2(contour[i], contourMovements[i], bs);
					v(vert.x, vert.y, depth + z);
				}

				// expand holes

				for (let h = 0, hl = holes.length; h < hl; h++) {
					const ahole = holes[h];
					oneHoleMovements = holesMovements[h];
					for (let i = 0, il = ahole.length; i < il; i++) {
						const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
						if (!extrudeByPath) {
							v(vert.x, vert.y, depth + z);
						} else {
							v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
						}
					}
				}
			}

			/* Faces */

			// Top and bottom faces

			buildLidFaces();

			// Sides faces

			buildSideFaces();

			/////	Internal functions

			function buildLidFaces() {
				const start = verticesArray.length / 3;
				if (bevelEnabled) {
					let layer = 0; // steps + 1
					let offset = vlen * layer;

					// Bottom faces

					for (let i = 0; i < flen; i++) {
						const face = faces[i];
						f3(face[2] + offset, face[1] + offset, face[0] + offset);
					}
					layer = steps + bevelSegments * 2;
					offset = vlen * layer;

					// Top faces

					for (let i = 0; i < flen; i++) {
						const face = faces[i];
						f3(face[0] + offset, face[1] + offset, face[2] + offset);
					}
				} else {
					// Bottom faces

					for (let i = 0; i < flen; i++) {
						const face = faces[i];
						f3(face[2], face[1], face[0]);
					}

					// Top faces

					for (let i = 0; i < flen; i++) {
						const face = faces[i];
						f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
					}
				}
				scope.addGroup(start, verticesArray.length / 3 - start, 0);
			}

			// Create faces for the z-sides of the shape

			function buildSideFaces() {
				const start = verticesArray.length / 3;
				let layeroffset = 0;
				sidewalls(contour, layeroffset);
				layeroffset += contour.length;
				for (let h = 0, hl = holes.length; h < hl; h++) {
					const ahole = holes[h];
					sidewalls(ahole, layeroffset);

					//, true
					layeroffset += ahole.length;
				}
				scope.addGroup(start, verticesArray.length / 3 - start, 1);
			}
			function sidewalls(contour, layeroffset) {
				let i = contour.length;
				while (--i >= 0) {
					const j = i;
					let k = i - 1;
					if (k < 0) k = contour.length - 1;

					//console.log('b', i,j, i-1, k,vertices.length);

					for (let s = 0, sl = steps + bevelSegments * 2; s < sl; s++) {
						const slen1 = vlen * s;
						const slen2 = vlen * (s + 1);
						const a = layeroffset + j + slen1,
							b = layeroffset + k + slen1,
							c = layeroffset + k + slen2,
							d = layeroffset + j + slen2;
						f4(a, b, c, d);
					}
				}
			}
			function v(x, y, z) {
				placeholder.push(x);
				placeholder.push(y);
				placeholder.push(z);
			}
			function f3(a, b, c) {
				addVertex(a);
				addVertex(b);
				addVertex(c);
				const nextIndex = verticesArray.length / 3;
				const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
				addUV(uvs[0]);
				addUV(uvs[1]);
				addUV(uvs[2]);
			}
			function f4(a, b, c, d) {
				addVertex(a);
				addVertex(b);
				addVertex(d);
				addVertex(b);
				addVertex(c);
				addVertex(d);
				const nextIndex = verticesArray.length / 3;
				const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
				addUV(uvs[0]);
				addUV(uvs[1]);
				addUV(uvs[3]);
				addUV(uvs[1]);
				addUV(uvs[2]);
				addUV(uvs[3]);
			}
			function addVertex(index) {
				verticesArray.push(placeholder[index * 3 + 0]);
				verticesArray.push(placeholder[index * 3 + 1]);
				verticesArray.push(placeholder[index * 3 + 2]);
			}
			function addUV(vector2) {
				uvArray.push(vector2.x);
				uvArray.push(vector2.y);
			}
		}
	}
	toJSON() {
		const data = super.toJSON();
		const shapes = this.parameters.shapes;
		const options = this.parameters.options;
		return toJSON$1(shapes, options, data);
	}
	static fromJSON(data, shapes) {
		const geometryShapes = [];
		for (let j = 0, jl = data.shapes.length; j < jl; j++) {
			const shape = shapes[data.shapes[j]];
			geometryShapes.push(shape);
		}
		const extrudePath = data.options.extrudePath;
		if (extrudePath !== undefined) {
			data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
		}
		return new ExtrudeGeometry(geometryShapes, data.options);
	}
}
const WorldUVGenerator = {
	generateTopUV: function (geometry, vertices, indexA, indexB, indexC) {
		const a_x = vertices[indexA * 3];
		const a_y = vertices[indexA * 3 + 1];
		const b_x = vertices[indexB * 3];
		const b_y = vertices[indexB * 3 + 1];
		const c_x = vertices[indexC * 3];
		const c_y = vertices[indexC * 3 + 1];
		return [new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y)];
	},
	generateSideWallUV: function (geometry, vertices, indexA, indexB, indexC, indexD) {
		const a_x = vertices[indexA * 3];
		const a_y = vertices[indexA * 3 + 1];
		const a_z = vertices[indexA * 3 + 2];
		const b_x = vertices[indexB * 3];
		const b_y = vertices[indexB * 3 + 1];
		const b_z = vertices[indexB * 3 + 2];
		const c_x = vertices[indexC * 3];
		const c_y = vertices[indexC * 3 + 1];
		const c_z = vertices[indexC * 3 + 2];
		const d_x = vertices[indexD * 3];
		const d_y = vertices[indexD * 3 + 1];
		const d_z = vertices[indexD * 3 + 2];
		if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
			return [new Vector2(a_x, 1 - a_z), new Vector2(b_x, 1 - b_z), new Vector2(c_x, 1 - c_z), new Vector2(d_x, 1 - d_z)];
		} else {
			return [new Vector2(a_y, 1 - a_z), new Vector2(b_y, 1 - b_z), new Vector2(c_y, 1 - c_z), new Vector2(d_y, 1 - d_z)];
		}
	}
};
function toJSON$1(shapes, options, data) {
	data.shapes = [];
	if (Array.isArray(shapes)) {
		for (let i = 0, l = shapes.length; i < l; i++) {
			const shape = shapes[i];
			data.shapes.push(shape.uuid);
		}
	} else {
		data.shapes.push(shapes.uuid);
	}
	data.options = Object.assign({}, options);
	if (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();
	return data;
}

class IcosahedronGeometry extends PolyhedronGeometry {
	constructor(radius = 1, detail = 0) {
		const t = (1 + Math.sqrt(5)) / 2;
		const vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1];
		const indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
		super(vertices, indices, radius, detail);
		this.type = 'IcosahedronGeometry';
		this.parameters = {
			radius: radius,
			detail: detail
		};
	}
	static fromJSON(data) {
		return new IcosahedronGeometry(data.radius, data.detail);
	}
}

class OctahedronGeometry extends PolyhedronGeometry {
	constructor(radius = 1, detail = 0) {
		const vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];
		const indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
		super(vertices, indices, radius, detail);
		this.type = 'OctahedronGeometry';
		this.parameters = {
			radius: radius,
			detail: detail
		};
	}
	static fromJSON(data) {
		return new OctahedronGeometry(data.radius, data.detail);
	}
}

class RingGeometry extends BufferGeometry {
	constructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2) {
		super();
		this.type = 'RingGeometry';
		this.parameters = {
			innerRadius: innerRadius,
			outerRadius: outerRadius,
			thetaSegments: thetaSegments,
			phiSegments: phiSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
		thetaSegments = Math.max(3, thetaSegments);
		phiSegments = Math.max(1, phiSegments);

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// some helper variables

		let radius = innerRadius;
		const radiusStep = (outerRadius - innerRadius) / phiSegments;
		const vertex = new Vector3();
		const uv = new Vector2();

		// generate vertices, normals and uvs

		for (let j = 0; j <= phiSegments; j++) {
			for (let i = 0; i <= thetaSegments; i++) {
				// values are generate from the inside of the ring to the outside

				const segment = thetaStart + i / thetaSegments * thetaLength;

				// vertex

				vertex.x = radius * Math.cos(segment);
				vertex.y = radius * Math.sin(segment);
				vertices.push(vertex.x, vertex.y, vertex.z);

				// normal

				normals.push(0, 0, 1);

				// uv

				uv.x = (vertex.x / outerRadius + 1) / 2;
				uv.y = (vertex.y / outerRadius + 1) / 2;
				uvs.push(uv.x, uv.y);
			}

			// increase the radius for next row of vertices

			radius += radiusStep;
		}

		// indices

		for (let j = 0; j < phiSegments; j++) {
			const thetaSegmentLevel = j * (thetaSegments + 1);
			for (let i = 0; i < thetaSegments; i++) {
				const segment = i + thetaSegmentLevel;
				const a = segment;
				const b = segment + thetaSegments + 1;
				const c = segment + thetaSegments + 2;
				const d = segment + 1;

				// faces

				indices.push(a, b, d);
				indices.push(b, c, d);
			}
		}

		// build geometry

		this.setIndex(indices);
		this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
		this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
		this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
	}
	static fromJSON(data) {
		return new RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
	}
}

class ShapeGeometry extends BufferGeometry {
	constructor(shapes = new Shape([new Vector2(0, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), curveSegments = 12) {
		super();
		this.type = 'ShapeGeometry';
		this.parameters = {
			shapes: shapes,
			curveSegments: curveSegments
		};

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let groupStart = 0;
		let groupCount = 0;

		// allow single and array values for "shapes" parameter

		if (Array.isArray(shapes) === false) {
			addShape(shapes);
		} else {
			for (let i = 0; i < shapes.length; i++) {
				addShape(shapes[i]);
				this.addGroup(groupStart, groupCount, i); // enables MultiMaterial support

				groupStart += groupCount;
				groupCount = 0;
			}
		}

		// build geometry

		this.setIndex(indices);
		this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
		this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
		this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

		// helper functions

		function addShape(shape) {
			const indexOffset = vertices.length / 3;
			const points = shape.extractPoints(curveSegments);
			let shapeVertices = points.shape;
			const shapeHoles = points.holes;

			// check direction of vertices

			if (ShapeUtils.isClockWise(shapeVertices) === false) {
				shapeVertices = shapeVertices.reverse();
			}
			for (let i = 0, l = shapeHoles.length; i < l; i++) {
				const shapeHole = shapeHoles[i];
				if (ShapeUtils.isClockWise(shapeHole) === true) {
					shapeHoles[i] = shapeHole.reverse();
				}
			}
			const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);

			// join vertices of inner and outer paths to a single array

			for (let i = 0, l = shapeHoles.length; i < l; i++) {
				const shapeHole = shapeHoles[i];
				shapeVertices = shapeVertices.concat(shapeHole);
			}

			// vertices, normals, uvs

			for (let i = 0, l = shapeVertices.length; i < l; i++) {
				const vertex = shapeVertices[i];
				vertices.push(vertex.x, vertex.y, 0);
				normals.push(0, 0, 1);
				uvs.push(vertex.x, vertex.y); // world uvs
			}

			// incides

			for (let i = 0, l = faces.length; i < l; i++) {
				const face = faces[i];
				const a = face[0] + indexOffset;
				const b = face[1] + indexOffset;
				const c = face[2] + indexOffset;
				indices.push(a, b, c);
				groupCount += 3;
			}
		}
	}
	toJSON() {
		const data = super.toJSON();
		const shapes = this.parameters.shapes;
		return toJSON(shapes, data);
	}
	static fromJSON(data, shapes) {
		const geometryShapes = [];
		for (let j = 0, jl = data.shapes.length; j < jl; j++) {
			const shape = shapes[data.shapes[j]];
			geometryShapes.push(shape);
		}
		return new ShapeGeometry(geometryShapes, data.curveSegments);
	}
}
function toJSON(shapes, data) {
	data.shapes = [];
	if (Array.isArray(shapes)) {
		for (let i = 0, l = shapes.length; i < l; i++) {
			const shape = shapes[i];
			data.shapes.push(shape.uuid);
		}
	} else {
		data.shapes.push(shapes.uuid);
	}
	return data;
}

class SphereGeometry extends BufferGeometry {
	constructor(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
		super();
		this.type = 'SphereGeometry';
		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
		widthSegments = Math.max(3, Math.floor(widthSegments));
		heightSegments = Math.max(2, Math.floor(heightSegments));
		const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
		let index = 0;
		const grid = [];
		const vertex = new Vector3();
		const normal = new Vector3();

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// generate vertices, normals and uvs

		for (let iy = 0; iy <= heightSegments; iy++) {
			const verticesRow = [];
			const v = iy / heightSegments;

			// special case for the poles

			let uOffset = 0;
			if (iy == 0 && thetaStart == 0) {
				uOffset = 0.5 / widthSegments;
			} else if (iy == heightSegments && thetaEnd == Math.PI) {
				uOffset = -0.5 / widthSegments;
			}
			for (let ix = 0; ix <= widthSegments; ix++) {
				const u = ix / widthSegments;

				// vertex

				vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
				vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
				vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
				vertices.push(vertex.x, vertex.y, vertex.z);

				// normal

				normal.copy(vertex).normalize();
				normals.push(normal.x, normal.y, normal.z);

				// uv

				uvs.push(u + uOffset, 1 - v);
				verticesRow.push(index++);
			}
			grid.push(verticesRow);
		}

		// indices

		for (let iy = 0; iy < heightSegments; iy++) {
			for (let ix = 0; ix < widthSegments; ix++) {
				const a = grid[iy][ix + 1];
				const b = grid[iy][ix];
				const c = grid[iy + 1][ix];
				const d = grid[iy + 1][ix + 1];
				if (iy !== 0 || thetaStart > 0) indices.push(a, b, d);
				if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);
			}
		}

		// build geometry

		this.setIndex(indices);
		this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
		this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
		this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
	}
	static fromJSON(data) {
		return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
	}
}

class TetrahedronGeometry extends PolyhedronGeometry {
	constructor(radius = 1, detail = 0) {
		const vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];
		const indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
		super(vertices, indices, radius, detail);
		this.type = 'TetrahedronGeometry';
		this.parameters = {
			radius: radius,
			detail: detail
		};
	}
	static fromJSON(data) {
		return new TetrahedronGeometry(data.radius, data.detail);
	}
}

class TorusGeometry extends BufferGeometry {
	constructor(radius = 1, tube = 0.4, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2) {
		super();
		this.type = 'TorusGeometry';
		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};
		radialSegments = Math.floor(radialSegments);
		tubularSegments = Math.floor(tubularSegments);

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		const center = new Vector3();
		const vertex = new Vector3();
		const normal = new Vector3();

		// generate vertices, normals and uvs

		for (let j = 0; j <= radialSegments; j++) {
			for (let i = 0; i <= tubularSegments; i++) {
				const u = i / tubularSegments * arc;
				const v = j / radialSegments * Math.PI * 2;

				// vertex

				vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
				vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
				vertex.z = tube * Math.sin(v);
				vertices.push(vertex.x, vertex.y, vertex.z);

				// normal

				center.x = radius * Math.cos(u);
				center.y = radius * Math.sin(u);
				normal.subVectors(vertex, center).normalize();
				normals.push(normal.x, normal.y, normal.z);

				// uv

				uvs.push(i / tubularSegments);
				uvs.push(j / radialSegments);
			}
		}

		// generate indices

		for (let j = 1; j <= radialSegments; j++) {
			for (let i = 1; i <= tubularSegments; i++) {
				// indices

				const a = (tubularSegments + 1) * j + i - 1;
				const b = (tubularSegments + 1) * (j - 1) + i - 1;
				const c = (tubularSegments + 1) * (j - 1) + i;
				const d = (tubularSegments + 1) * j + i;

				// faces

				indices.push(a, b, d);
				indices.push(b, c, d);
			}
		}

		// build geometry

		this.setIndex(indices);
		this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
		this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
		this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
	}
	static fromJSON(data) {
		return new TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
	}
}

class TorusKnotGeometry extends BufferGeometry {
	constructor(radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3) {
		super();
		this.type = 'TorusKnotGeometry';
		this.parameters = {
			radius: radius,
			tube: tube,
			tubularSegments: tubularSegments,
			radialSegments: radialSegments,
			p: p,
			q: q
		};
		tubularSegments = Math.floor(tubularSegments);
		radialSegments = Math.floor(radialSegments);

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		const vertex = new Vector3();
		const normal = new Vector3();
		const P1 = new Vector3();
		const P2 = new Vector3();
		const B = new Vector3();
		const T = new Vector3();
		const N = new Vector3();

		// generate vertices, normals and uvs

		for (let i = 0; i <= tubularSegments; ++i) {
			// the radian "u" is used to calculate the position on the torus curve of the current tubular segment

			const u = i / tubularSegments * p * Math.PI * 2;

			// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
			// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

			calculatePositionOnCurve(u, p, q, radius, P1);
			calculatePositionOnCurve(u + 0.01, p, q, radius, P2);

			// calculate orthonormal basis

			T.subVectors(P2, P1);
			N.addVectors(P2, P1);
			B.crossVectors(T, N);
			N.crossVectors(B, T);

			// normalize B, N. T can be ignored, we don't use it

			B.normalize();
			N.normalize();
			for (let j = 0; j <= radialSegments; ++j) {
				// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
				// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

				const v = j / radialSegments * Math.PI * 2;
				const cx = -tube * Math.cos(v);
				const cy = tube * Math.sin(v);

				// now calculate the final vertex position.
				// first we orient the extrusion with our basis vectors, then we add it to the current position on the curve

				vertex.x = P1.x + (cx * N.x + cy * B.x);
				vertex.y = P1.y + (cx * N.y + cy * B.y);
				vertex.z = P1.z + (cx * N.z + cy * B.z);
				vertices.push(vertex.x, vertex.y, vertex.z);

				// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

				normal.subVectors(vertex, P1).normalize();
				normals.push(normal.x, normal.y, normal.z);

				// uv

				uvs.push(i / tubularSegments);
				uvs.push(j / radialSegments);
			}
		}

		// generate indices

		for (let j = 1; j <= tubularSegments; j++) {
			for (let i = 1; i <= radialSegments; i++) {
				// indices

				const a = (radialSegments + 1) * (j - 1) + (i - 1);
				const b = (radialSegments + 1) * j + (i - 1);
				const c = (radialSegments + 1) * j + i;
				const d = (radialSegments + 1) * (j - 1) + i;

				// faces

				indices.push(a, b, d);
				indices.push(b, c, d);
			}
		}

		// build geometry

		this.setIndex(indices);
		this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
		this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
		this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

		// this function calculates the current position on the torus curve

		function calculatePositionOnCurve(u, p, q, radius, position) {
			const cu = Math.cos(u);
			const su = Math.sin(u);
			const quOverP = q / p * u;
			const cs = Math.cos(quOverP);
			position.x = radius * (2 + cs) * 0.5 * cu;
			position.y = radius * (2 + cs) * su * 0.5;
			position.z = radius * Math.sin(quOverP) * 0.5;
		}
	}
	static fromJSON(data) {
		return new TorusKnotGeometry(data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
	}
}

class TubeGeometry extends BufferGeometry {
	constructor(path = new QuadraticBezierCurve3(new Vector3(-1, -1, 0), new Vector3(-1, 1, 0), new Vector3(1, 1, 0)), tubularSegments = 64, radius = 1, radialSegments = 8, closed = false) {
		super();
		this.type = 'TubeGeometry';
		this.parameters = {
			path: path,
			tubularSegments: tubularSegments,
			radius: radius,
			radialSegments: radialSegments,
			closed: closed
		};
		const frames = path.computeFrenetFrames(tubularSegments, closed);

		// expose internals

		this.tangents = frames.tangents;
		this.normals = frames.normals;
		this.binormals = frames.binormals;

		// helper variables

		const vertex = new Vector3();
		const normal = new Vector3();
		const uv = new Vector2();
		let P = new Vector3();

		// buffer

		const vertices = [];
		const normals = [];
		const uvs = [];
		const indices = [];

		// create buffer data

		generateBufferData();

		// build geometry

		this.setIndex(indices);
		this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
		this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
		this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

		// functions

		function generateBufferData() {
			for (let i = 0; i < tubularSegments; i++) {
				generateSegment(i);
			}

			// if the geometry is not closed, generate the last row of vertices and normals
			// at the regular position on the given path
			//
			// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

			generateSegment(closed === false ? tubularSegments : 0);

			// uvs are generated in a separate function.
			// this makes it easy compute correct values for closed geometries

			generateUVs();

			// finally create faces

			generateIndices();
		}
		function generateSegment(i) {
			// we use getPointAt to sample evenly distributed points from the given path

			P = path.getPointAt(i / tubularSegments, P);

			// retrieve corresponding normal and binormal

			const N = frames.normals[i];
			const B = frames.binormals[i];

			// generate normals and vertices for the current segment

			for (let j = 0; j <= radialSegments; j++) {
				const v = j / radialSegments * Math.PI * 2;
				const sin = Math.sin(v);
				const cos = -Math.cos(v);

				// normal

				normal.x = cos * N.x + sin * B.x;
				normal.y = cos * N.y + sin * B.y;
				normal.z = cos * N.z + sin * B.z;
				normal.normalize();
				normals.push(normal.x, normal.y, normal.z);

				// vertex

				vertex.x = P.x + radius * normal.x;
				vertex.y = P.y + radius * normal.y;
				vertex.z = P.z + radius * normal.z;
				vertices.push(vertex.x, vertex.y, vertex.z);
			}
		}
		function generateIndices() {
			for (let j = 1; j <= tubularSegments; j++) {
				for (let i = 1; i <= radialSegments; i++) {
					const a = (radialSegments + 1) * (j - 1) + (i - 1);
					const b = (radialSegments + 1) * j + (i - 1);
					const c = (radialSegments + 1) * j + i;
					const d = (radialSegments + 1) * (j - 1) + i;

					// faces

					indices.push(a, b, d);
					indices.push(b, c, d);
				}
			}
		}
		function generateUVs() {
			for (let i = 0; i <= tubularSegments; i++) {
				for (let j = 0; j <= radialSegments; j++) {
					uv.x = i / tubularSegments;
					uv.y = j / radialSegments;
					uvs.push(uv.x, uv.y);
				}
			}
		}
	}
	toJSON() {
		const data = super.toJSON();
		data.path = this.parameters.path.toJSON();
		return data;
	}
	static fromJSON(data) {
		// This only works for built-in curves (e.g. CatmullRomCurve3).
		// User defined curves or instances of CurvePath will not be deserialized.
		return new TubeGeometry(new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);
	}
}

class WireframeGeometry extends BufferGeometry {
	constructor(geometry = null) {
		super();
		this.type = 'WireframeGeometry';
		this.parameters = {
			geometry: geometry
		};
		if (geometry !== null) {
			// buffer

			const vertices = [];
			const edges = new Set();

			// helper variables

			const start = new Vector3();
			const end = new Vector3();
			if (geometry.index !== null) {
				// indexed BufferGeometry

				const position = geometry.attributes.position;
				const indices = geometry.index;
				let groups = geometry.groups;
				if (groups.length === 0) {
					groups = [{
						start: 0,
						count: indices.count,
						materialIndex: 0
					}];
				}

				// create a data structure that contains all edges without duplicates

				for (let o = 0, ol = groups.length; o < ol; ++o) {
					const group = groups[o];
					const groupStart = group.start;
					const groupCount = group.count;
					for (let i = groupStart, l = groupStart + groupCount; i < l; i += 3) {
						for (let j = 0; j < 3; j++) {
							const index1 = indices.getX(i + j);
							const index2 = indices.getX(i + (j + 1) % 3);
							start.fromBufferAttribute(position, index1);
							end.fromBufferAttribute(position, index2);
							if (isUniqueEdge(start, end, edges) === true) {
								vertices.push(start.x, start.y, start.z);
								vertices.push(end.x, end.y, end.z);
							}
						}
					}
				}
			} else {
				// non-indexed BufferGeometry

				const position = geometry.attributes.position;
				for (let i = 0, l = position.count / 3; i < l; i++) {
					for (let j = 0; j < 3; j++) {
						// three edges per triangle, an edge is represented as (index1, index2)
						// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)

						const index1 = 3 * i + j;
						const index2 = 3 * i + (j + 1) % 3;
						start.fromBufferAttribute(position, index1);
						end.fromBufferAttribute(position, index2);
						if (isUniqueEdge(start, end, edges) === true) {
							vertices.push(start.x, start.y, start.z);
							vertices.push(end.x, end.y, end.z);
						}
					}
				}
			}

			// build geometry

			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
		}
	}
}
function isUniqueEdge(start, end, edges) {
	const hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;
	const hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`; // coincident edge

	if (edges.has(hash1) === true || edges.has(hash2) === true) {
		return false;
	} else {
		edges.add(hash1);
		edges.add(hash2);
		return true;
	}
}

var Geometries = /*#__PURE__*/Object.freeze({
	__proto__: null,
	BoxGeometry: BoxGeometry,
	CapsuleGeometry: CapsuleGeometry,
	CircleGeometry: CircleGeometry,
	ConeGeometry: ConeGeometry,
	CylinderGeometry: CylinderGeometry,
	DodecahedronGeometry: DodecahedronGeometry,
	EdgesGeometry: EdgesGeometry,
	ExtrudeGeometry: ExtrudeGeometry,
	IcosahedronGeometry: IcosahedronGeometry,
	LatheGeometry: LatheGeometry,
	OctahedronGeometry: OctahedronGeometry,
	PlaneGeometry: PlaneGeometry,
	PolyhedronGeometry: PolyhedronGeometry,
	RingGeometry: RingGeometry,
	ShapeGeometry: ShapeGeometry,
	SphereGeometry: SphereGeometry,
	TetrahedronGeometry: TetrahedronGeometry,
	TorusGeometry: TorusGeometry,
	TorusKnotGeometry: TorusKnotGeometry,
	TubeGeometry: TubeGeometry,
	WireframeGeometry: WireframeGeometry
});

class ShadowMaterial extends Material {
	constructor(parameters) {
		super();
		this.isShadowMaterial = true;
		this.type = 'ShadowMaterial';
		this.color = new Color(0x000000);
		this.transparent = true;
		this.fog = true;
		this.setValues(parameters);
	}
	copy(source) {
		super.copy(source);
		this.color.copy(source.color);
		this.fog = source.fog;
		return this;
	}
}

class RawShaderMaterial extends ShaderMaterial {
	constructor(parameters) {
		super(parameters);
		this.isRawShaderMaterial = true;
		this.type = 'RawShaderMaterial';
	}
}

class MeshStandardMaterial extends Material {
	constructor(parameters) {
		super();
		this.isMeshStandardMaterial = true;
		this.defines = {
			'STANDARD': ''
		};
		this.type = 'MeshStandardMaterial';
		this.color = new Color(0xffffff); // diffuse
		this.roughness = 1.0;
		this.metalness = 0.0;
		this.map = null;
		this.lightMap = null;
		this.lightMapIntensity = 1.0;
		this.aoMap = null;
		this.aoMapIntensity = 1.0;
		this.emissive = new Color(0x000000);
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;
		this.bumpMap = null;
		this.bumpScale = 1;
		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2(1, 1);
		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
		this.roughnessMap = null;
		this.metalnessMap = null;
		this.alphaMap = null;
		this.envMap = null;
		this.envMapIntensity = 1.0;
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';
		this.flatShading = false;
		this.fog = true;
		this.setValues(parameters);
	}
	copy(source) {
		super.copy(source);
		this.defines = {
			'STANDARD': ''
		};
		this.color.copy(source.color);
		this.roughness = source.roughness;
		this.metalness = source.metalness;
		this.map = source.map;
		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;
		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;
		this.emissive.copy(source.emissive);
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;
		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;
		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy(source.normalScale);
		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
		this.roughnessMap = source.roughnessMap;
		this.metalnessMap = source.metalnessMap;
		this.alphaMap = source.alphaMap;
		this.envMap = source.envMap;
		this.envMapIntensity = source.envMapIntensity;
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;
		this.flatShading = source.flatShading;
		this.fog = source.fog;
		return this;
	}
}

class MeshPhysicalMaterial extends MeshStandardMaterial {
	constructor(parameters) {
		super();
		this.isMeshPhysicalMaterial = true;
		this.defines = {
			'STANDARD': '',
			'PHYSICAL': ''
		};
		this.type = 'MeshPhysicalMaterial';
		this.clearcoatMap = null;
		this.clearcoatRoughness = 0.0;
		this.clearcoatRoughnessMap = null;
		this.clearcoatNormalScale = new Vector2(1, 1);
		this.clearcoatNormalMap = null;
		this.ior = 1.5;
		Object.defineProperty(this, 'reflectivity', {
			get: function () {
				return clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
			},
			set: function (reflectivity) {
				this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);
			}
		});
		this.iridescenceMap = null;
		this.iridescenceIOR = 1.3;
		this.iridescenceThicknessRange = [100, 400];
		this.iridescenceThicknessMap = null;
		this.sheenColor = new Color(0x000000);
		this.sheenColorMap = null;
		this.sheenRoughness = 1.0;
		this.sheenRoughnessMap = null;
		this.transmissionMap = null;
		this.thickness = 0;
		this.thicknessMap = null;
		this.attenuationDistance = Infinity;
		this.attenuationColor = new Color(1, 1, 1);
		this.specularIntensity = 1.0;
		this.specularIntensityMap = null;
		this.specularColor = new Color(1, 1, 1);
		this.specularColorMap = null;
		this._sheen = 0.0;
		this._clearcoat = 0;
		this._iridescence = 0;
		this._transmission = 0;
		this.setValues(parameters);
	}
	get sheen() {
		return this._sheen;
	}
	set sheen(value) {
		if (this._sheen > 0 !== value > 0) {
			this.version++;
		}
		this._sheen = value;
	}
	get clearcoat() {
		return this._clearcoat;
	}
	set clearcoat(value) {
		if (this._clearcoat > 0 !== value > 0) {
			this.version++;
		}
		this._clearcoat = value;
	}
	get iridescence() {
		return this._iridescence;
	}
	set iridescence(value) {
		if (this._iridescence > 0 !== value > 0) {
			this.version++;
		}
		this._iridescence = value;
	}
	get transmission() {
		return this._transmission;
	}
	set transmission(value) {
		if (this._transmission > 0 !== value > 0) {
			this.version++;
		}
		this._transmission = value;
	}
	copy(source) {
		super.copy(source);
		this.defines = {
			'STANDARD': '',
			'PHYSICAL': ''
		};
		this.clearcoat = source.clearcoat;
		this.clearcoatMap = source.clearcoatMap;
		this.clearcoatRoughness = source.clearcoatRoughness;
		this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
		this.clearcoatNormalMap = source.clearcoatNormalMap;
		this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
		this.ior = source.ior;
		this.iridescence = source.iridescence;
		this.iridescenceMap = source.iridescenceMap;
		this.iridescenceIOR = source.iridescenceIOR;
		this.iridescenceThicknessRange = [...source.iridescenceThicknessRange];
		this.iridescenceThicknessMap = source.iridescenceThicknessMap;
		this.sheen = source.sheen;
		this.sheenColor.copy(source.sheenColor);
		this.sheenColorMap = source.sheenColorMap;
		this.sheenRoughness = source.sheenRoughness;
		this.sheenRoughnessMap = source.sheenRoughnessMap;
		this.transmission = source.transmission;
		this.transmissionMap = source.transmissionMap;
		this.thickness = source.thickness;
		this.thicknessMap = source.thicknessMap;
		this.attenuationDistance = source.attenuationDistance;
		this.attenuationColor.copy(source.attenuationColor);
		this.specularIntensity = source.specularIntensity;
		this.specularIntensityMap = source.specularIntensityMap;
		this.specularColor.copy(source.specularColor);
		this.specularColorMap = source.specularColorMap;
		return this;
	}
}

class MeshPhongMaterial extends Material {
	constructor(parameters) {
		super();
		this.isMeshPhongMaterial = true;
		this.type = 'MeshPhongMaterial';
		this.color = new Color(0xffffff); // diffuse
		this.specular = new Color(0x111111);
		this.shininess = 30;
		this.map = null;
		this.lightMap = null;
		this.lightMapIntensity = 1.0;
		this.aoMap = null;
		this.aoMapIntensity = 1.0;
		this.emissive = new Color(0x000000);
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;
		this.bumpMap = null;
		this.bumpScale = 1;
		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2(1, 1);
		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
		this.specularMap = null;
		this.alphaMap = null;
		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';
		this.flatShading = false;
		this.fog = true;
		this.setValues(parameters);
	}
	copy(source) {
		super.copy(source);
		this.color.copy(source.color);
		this.specular.copy(source.specular);
		this.shininess = source.shininess;
		this.map = source.map;
		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;
		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;
		this.emissive.copy(source.emissive);
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;
		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;
		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy(source.normalScale);
		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
		this.specularMap = source.specularMap;
		this.alphaMap = source.alphaMap;
		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;
		this.flatShading = source.flatShading;
		this.fog = source.fog;
		return this;
	}
}

class MeshToonMaterial extends Material {
	constructor(parameters) {
		super();
		this.isMeshToonMaterial = true;
		this.defines = {
			'TOON': ''
		};
		this.type = 'MeshToonMaterial';
		this.color = new Color(0xffffff);
		this.map = null;
		this.gradientMap = null;
		this.lightMap = null;
		this.lightMapIntensity = 1.0;
		this.aoMap = null;
		this.aoMapIntensity = 1.0;
		this.emissive = new Color(0x000000);
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;
		this.bumpMap = null;
		this.bumpScale = 1;
		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2(1, 1);
		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
		this.alphaMap = null;
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';
		this.fog = true;
		this.setValues(parameters);
	}
	copy(source) {
		super.copy(source);
		this.color.copy(source.color);
		this.map = source.map;
		this.gradientMap = source.gradientMap;
		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;
		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;
		this.emissive.copy(source.emissive);
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;
		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;
		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy(source.normalScale);
		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
		this.alphaMap = source.alphaMap;
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;
		this.fog = source.fog;
		return this;
	}
}

class MeshNormalMaterial extends Material {
	constructor(parameters) {
		super();
		this.isMeshNormalMaterial = true;
		this.type = 'MeshNormalMaterial';
		this.bumpMap = null;
		this.bumpScale = 1;
		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2(1, 1);
		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.flatShading = false;
		this.setValues(parameters);
	}
	copy(source) {
		super.copy(source);
		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;
		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy(source.normalScale);
		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.flatShading = source.flatShading;
		return this;
	}
}

class MeshLambertMaterial extends Material {
	constructor(parameters) {
		super();
		this.isMeshLambertMaterial = true;
		this.type = 'MeshLambertMaterial';
		this.color = new Color(0xffffff); // diffuse

		this.map = null;
		this.lightMap = null;
		this.lightMapIntensity = 1.0;
		this.aoMap = null;
		this.aoMapIntensity = 1.0;
		this.emissive = new Color(0x000000);
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;
		this.bumpMap = null;
		this.bumpScale = 1;
		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2(1, 1);
		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
		this.specularMap = null;
		this.alphaMap = null;
		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';
		this.flatShading = false;
		this.fog = true;
		this.setValues(parameters);
	}
	copy(source) {
		super.copy(source);
		this.color.copy(source.color);
		this.map = source.map;
		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;
		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;
		this.emissive.copy(source.emissive);
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;
		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;
		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy(source.normalScale);
		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
		this.specularMap = source.specularMap;
		this.alphaMap = source.alphaMap;
		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;
		this.flatShading = source.flatShading;
		this.fog = source.fog;
		return this;
	}
}

class MeshMatcapMaterial extends Material {
	constructor(parameters) {
		super();
		this.isMeshMatcapMaterial = true;
		this.defines = {
			'MATCAP': ''
		};
		this.type = 'MeshMatcapMaterial';
		this.color = new Color(0xffffff); // diffuse

		this.matcap = null;
		this.map = null;
		this.bumpMap = null;
		this.bumpScale = 1;
		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2(1, 1);
		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
		this.alphaMap = null;
		this.flatShading = false;
		this.fog = true;
		this.setValues(parameters);
	}
	copy(source) {
		super.copy(source);
		this.defines = {
			'MATCAP': ''
		};
		this.color.copy(source.color);
		this.matcap = source.matcap;
		this.map = source.map;
		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;
		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy(source.normalScale);
		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
		this.alphaMap = source.alphaMap;
		this.flatShading = source.flatShading;
		this.fog = source.fog;
		return this;
	}
}

class LineDashedMaterial extends LineBasicMaterial {
	constructor(parameters) {
		super();
		this.isLineDashedMaterial = true;
		this.type = 'LineDashedMaterial';
		this.scale = 1;
		this.dashSize = 3;
		this.gapSize = 1;
		this.setValues(parameters);
	}
	copy(source) {
		super.copy(source);
		this.scale = source.scale;
		this.dashSize = source.dashSize;
		this.gapSize = source.gapSize;
		return this;
	}
}

// same as Array.prototype.slice, but also works on typed arrays
function arraySlice(array, from, to) {
	if (isTypedArray(array)) {
		// in ios9 array.subarray(from, undefined) will return empty array
		// but array.subarray(from) or array.subarray(from, len) is correct
		return new array.constructor(array.subarray(from, to !== undefined ? to : array.length));
	}
	return array.slice(from, to);
}

// converts an array to a specific type
function convertArray(array, type, forceClone) {
	if (!array ||
	// let 'undefined' and 'null' pass
	!forceClone && array.constructor === type) return array;
	if (typeof type.BYTES_PER_ELEMENT === 'number') {
		return new type(array); // create typed array
	}

	return Array.prototype.slice.call(array); // create Array
}

function isTypedArray(object) {
	return ArrayBuffer.isView(object) && !(object instanceof DataView);
}

// returns an array by which times and values can be sorted
function getKeyframeOrder(times) {
	function compareTime(i, j) {
		return times[i] - times[j];
	}
	const n = times.length;
	const result = new Array(n);
	for (let i = 0; i !== n; ++i) result[i] = i;
	result.sort(compareTime);
	return result;
}

// uses the array previously returned by 'getKeyframeOrder' to sort data
function sortedArray(values, stride, order) {
	const nValues = values.length;
	const result = new values.constructor(nValues);
	for (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
		const srcOffset = order[i] * stride;
		for (let j = 0; j !== stride; ++j) {
			result[dstOffset++] = values[srcOffset + j];
		}
	}
	return result;
}

// function for parsing AOS keyframe formats
function flattenJSON(jsonKeys, times, values, valuePropertyName) {
	let i = 1,
		key = jsonKeys[0];
	while (key !== undefined && key[valuePropertyName] === undefined) {
		key = jsonKeys[i++];
	}
	if (key === undefined) return; // no data

	let value = key[valuePropertyName];
	if (value === undefined) return; // no data

	if (Array.isArray(value)) {
		do {
			value = key[valuePropertyName];
			if (value !== undefined) {
				times.push(key.time);
				values.push.apply(values, value); // push all elements
			}

			key = jsonKeys[i++];
		} while (key !== undefined);
	} else if (value.toArray !== undefined) {
		// ...assume THREE.Math-ish

		do {
			value = key[valuePropertyName];
			if (value !== undefined) {
				times.push(key.time);
				value.toArray(values, values.length);
			}
			key = jsonKeys[i++];
		} while (key !== undefined);
	} else {
		// otherwise push as-is

		do {
			value = key[valuePropertyName];
			if (value !== undefined) {
				times.push(key.time);
				values.push(value);
			}
			key = jsonKeys[i++];
		} while (key !== undefined);
	}
}
function subclip(sourceClip, name, startFrame, endFrame, fps = 30) {
	const clip = sourceClip.clone();
	clip.name = name;
	const tracks = [];
	for (let i = 0; i < clip.tracks.length; ++i) {
		const track = clip.tracks[i];
		const valueSize = track.getValueSize();
		const times = [];
		const values = [];
		for (let j = 0; j < track.times.length; ++j) {
			const frame = track.times[j] * fps;
			if (frame < startFrame || frame >= endFrame) continue;
			times.push(track.times[j]);
			for (let k = 0; k < valueSize; ++k) {
				values.push(track.values[j * valueSize + k]);
			}
		}
		if (times.length === 0) continue;
		track.times = convertArray(times, track.times.constructor);
		track.values = convertArray(values, track.values.constructor);
		tracks.push(track);
	}
	clip.tracks = tracks;

	// find minimum .times value across all tracks in the trimmed clip

	let minStartTime = Infinity;
	for (let i = 0; i < clip.tracks.length; ++i) {
		if (minStartTime > clip.tracks[i].times[0]) {
			minStartTime = clip.tracks[i].times[0];
		}
	}

	// shift all tracks such that clip begins at t=0

	for (let i = 0; i < clip.tracks.length; ++i) {
		clip.tracks[i].shift(-1 * minStartTime);
	}
	clip.resetDuration();
	return clip;
}
function makeClipAdditive(targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
	if (fps <= 0) fps = 30;
	const numTracks = referenceClip.tracks.length;
	const referenceTime = referenceFrame / fps;

	// Make each track's values relative to the values at the reference frame
	for (let i = 0; i < numTracks; ++i) {
		const referenceTrack = referenceClip.tracks[i];
		const referenceTrackType = referenceTrack.ValueTypeName;

		// Skip this track if it's non-numeric
		if (referenceTrackType === 'bool' || referenceTrackType === 'string') continue;

		// Find the track in the target clip whose name and type matches the reference track
		const targetTrack = targetClip.tracks.find(function (track) {
			return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
		});
		if (targetTrack === undefined) continue;
		let referenceOffset = 0;
		const referenceValueSize = referenceTrack.getValueSize();
		if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
			referenceOffset = referenceValueSize / 3;
		}
		let targetOffset = 0;
		const targetValueSize = targetTrack.getValueSize();
		if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
			targetOffset = targetValueSize / 3;
		}
		const lastIndex = referenceTrack.times.length - 1;
		let referenceValue;

		// Find the value to subtract out of the track
		if (referenceTime <= referenceTrack.times[0]) {
			// Reference frame is earlier than the first keyframe, so just use the first keyframe
			const startIndex = referenceOffset;
			const endIndex = referenceValueSize - referenceOffset;
			referenceValue = arraySlice(referenceTrack.values, startIndex, endIndex);
		} else if (referenceTime >= referenceTrack.times[lastIndex]) {
			// Reference frame is after the last keyframe, so just use the last keyframe
			const startIndex = lastIndex * referenceValueSize + referenceOffset;
			const endIndex = startIndex + referenceValueSize - referenceOffset;
			referenceValue = arraySlice(referenceTrack.values, startIndex, endIndex);
		} else {
			// Interpolate to the reference value
			const interpolant = referenceTrack.createInterpolant();
			const startIndex = referenceOffset;
			const endIndex = referenceValueSize - referenceOffset;
			interpolant.evaluate(referenceTime);
			referenceValue = arraySlice(interpolant.resultBuffer, startIndex, endIndex);
		}

		// Conjugate the quaternion
		if (referenceTrackType === 'quaternion') {
			const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
			referenceQuat.toArray(referenceValue);
		}

		// Subtract the reference value from all of the track values

		const numTimes = targetTrack.times.length;
		for (let j = 0; j < numTimes; ++j) {
			const valueStart = j * targetValueSize + targetOffset;
			if (referenceTrackType === 'quaternion') {
				// Multiply the conjugate for quaternion track types
				Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
			} else {
				const valueEnd = targetValueSize - targetOffset * 2;

				// Subtract each value for all other numeric track types
				for (let k = 0; k < valueEnd; ++k) {
					targetTrack.values[valueStart + k] -= referenceValue[k];
				}
			}
		}
	}
	targetClip.blendMode = AdditiveAnimationBlendMode;
	return targetClip;
}

var AnimationUtils = /*#__PURE__*/Object.freeze({
	__proto__: null,
	arraySlice: arraySlice,
	convertArray: convertArray,
	isTypedArray: isTypedArray,
	getKeyframeOrder: getKeyframeOrder,
	sortedArray: sortedArray,
	flattenJSON: flattenJSON,
	subclip: subclip,
	makeClipAdditive: makeClipAdditive
});

/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 * 		http://www.oodesign.com/template-method-pattern.html
 *
 */

class Interpolant {
	constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
		this.parameterPositions = parameterPositions;
		this._cachedIndex = 0;
		this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);
		this.sampleValues = sampleValues;
		this.valueSize = sampleSize;
		this.settings = null;
		this.DefaultSettings_ = {};
	}
	evaluate(t) {
		const pp = this.parameterPositions;
		let i1 = this._cachedIndex,
			t1 = pp[i1],
			t0 = pp[i1 - 1];
		validate_interval: {
			seek: {
				let right;
				linear_scan: {
					//- See http://jsperf.com/comparison-to-undefined/3
					//- slower code:
					//-
					//- 				if ( t >= t1 || t1 === undefined ) {
					forward_scan: if (!(t < t1)) {
						for (let giveUpAt = i1 + 2;;) {
							if (t1 === undefined) {
								if (t < t0) break forward_scan;

								// after end

								i1 = pp.length;
								this._cachedIndex = i1;
								return this.copySampleValue_(i1 - 1);
							}
							if (i1 === giveUpAt) break; // this loop

							t0 = t1;
							t1 = pp[++i1];
							if (t < t1) {
								// we have arrived at the sought interval
								break seek;
							}
						}

						// prepare binary search on the right side of the index
						right = pp.length;
						break linear_scan;
					}

					//- slower code:
					//-					if ( t < t0 || t0 === undefined ) {
					if (!(t >= t0)) {
						// looping?

						const t1global = pp[1];
						if (t < t1global) {
							i1 = 2; // + 1, using the scan for the details
							t0 = t1global;
						}

						// linear reverse scan

						for (let giveUpAt = i1 - 2;;) {
							if (t0 === undefined) {
								// before start

								this._cachedIndex = 0;
								return this.copySampleValue_(0);
							}
							if (i1 === giveUpAt) break; // this loop

							t1 = t0;
							t0 = pp[--i1 - 1];
							if (t >= t0) {
								// we have arrived at the sought interval
								break seek;
							}
						}

						// prepare binary search on the left side of the index
						right = i1;
						i1 = 0;
						break linear_scan;
					}

					// the interval is valid

					break validate_interval;
				} // linear scan

				// binary search

				while (i1 < right) {
					const mid = i1 + right >>> 1;
					if (t < pp[mid]) {
						right = mid;
					} else {
						i1 = mid + 1;
					}
				}
				t1 = pp[i1];
				t0 = pp[i1 - 1];

				// check boundary cases, again

				if (t0 === undefined) {
					this._cachedIndex = 0;
					return this.copySampleValue_(0);
				}
				if (t1 === undefined) {
					i1 = pp.length;
					this._cachedIndex = i1;
					return this.copySampleValue_(i1 - 1);
				}
			} // seek

			this._cachedIndex = i1;
			this.intervalChanged_(i1, t0, t1);
		} // validate_interval

		return this.interpolate_(i1, t0, t, t1);
	}
	getSettings_() {
		return this.settings || this.DefaultSettings_;
	}
	copySampleValue_(index) {
		// copies a sample value to the result buffer

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,
			offset = index * stride;
		for (let i = 0; i !== stride; ++i) {
			result[i] = values[offset + i];
		}
		return result;
	}

	// Template methods for derived classes:

	interpolate_() {
		throw new Error('call to abstract method');
		// implementations shall return this.resultBuffer
	}

	intervalChanged_() {

		// empty
	}
}

/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 */

class CubicInterpolant extends Interpolant {
	constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
		super(parameterPositions, sampleValues, sampleSize, resultBuffer);
		this._weightPrev = -0;
		this._offsetPrev = -0;
		this._weightNext = -0;
		this._offsetNext = -0;
		this.DefaultSettings_ = {
			endingStart: ZeroCurvatureEnding,
			endingEnd: ZeroCurvatureEnding
		};
	}
	intervalChanged_(i1, t0, t1) {
		const pp = this.parameterPositions;
		let iPrev = i1 - 2,
			iNext = i1 + 1,
			tPrev = pp[iPrev],
			tNext = pp[iNext];
		if (tPrev === undefined) {
			switch (this.getSettings_().endingStart) {
				case ZeroSlopeEnding:
					// f'(t0) = 0
					iPrev = i1;
					tPrev = 2 * t0 - t1;
					break;
				case WrapAroundEnding:
					// use the other end of the curve
					iPrev = pp.length - 2;
					tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
					break;
				default:
					// ZeroCurvatureEnding

					// f''(t0) = 0 a.k.a. Natural Spline
					iPrev = i1;
					tPrev = t1;
			}
		}
		if (tNext === undefined) {
			switch (this.getSettings_().endingEnd) {
				case ZeroSlopeEnding:
					// f'(tN) = 0
					iNext = i1;
					tNext = 2 * t1 - t0;
					break;
				case WrapAroundEnding:
					// use the other end of the curve
					iNext = 1;
					tNext = t1 + pp[1] - pp[0];
					break;
				default:
					// ZeroCurvatureEnding

					// f''(tN) = 0, a.k.a. Natural Spline
					iNext = i1 - 1;
					tNext = t0;
			}
		}
		const halfDt = (t1 - t0) * 0.5,
			stride = this.valueSize;
		this._weightPrev = halfDt / (t0 - tPrev);
		this._weightNext = halfDt / (tNext - t1);
		this._offsetPrev = iPrev * stride;
		this._offsetNext = iNext * stride;
	}
	interpolate_(i1, t0, t, t1) {
		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,
			o1 = i1 * stride,
			o0 = o1 - stride,
			oP = this._offsetPrev,
			oN = this._offsetNext,
			wP = this._weightPrev,
			wN = this._weightNext,
			p = (t - t0) / (t1 - t0),
			pp = p * p,
			ppp = pp * p;

		// evaluate polynomials

		const sP = -wP * ppp + 2 * wP * pp - wP * p;
		const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
		const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
		const sN = wN * ppp - wN * pp;

		// combine data linearly

		for (let i = 0; i !== stride; ++i) {
			result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
		}
		return result;
	}
}

class LinearInterpolant extends Interpolant {
	constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
		super(parameterPositions, sampleValues, sampleSize, resultBuffer);
	}
	interpolate_(i1, t0, t, t1) {
		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,
			offset1 = i1 * stride,
			offset0 = offset1 - stride,
			weight1 = (t - t0) / (t1 - t0),
			weight0 = 1 - weight1;
		for (let i = 0; i !== stride; ++i) {
			result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
		}
		return result;
	}
}

/**
 *
 * Interpolant that evaluates to the sample value at the position preceding
 * the parameter.
 */

class DiscreteInterpolant extends Interpolant {
	constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
		super(parameterPositions, sampleValues, sampleSize, resultBuffer);
	}
	interpolate_(i1 /*, t0, t, t1 */) {
		return this.copySampleValue_(i1 - 1);
	}
}

class KeyframeTrack {
	constructor(name, times, values, interpolation) {
		if (name === undefined) throw new Error('THREE.KeyframeTrack: track name is undefined');
		if (times === undefined || times.length === 0) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name);
		this.name = name;
		this.times = convertArray(times, this.TimeBufferType);
		this.values = convertArray(values, this.ValueBufferType);
		this.setInterpolation(interpolation || this.DefaultInterpolation);
	}

	// Serialization (in static context, because of constructor invocation
	// and automatic invocation of .toJSON):

	static toJSON(track) {
		const trackType = track.constructor;
		let json;

		// derived classes can define a static toJSON method
		if (trackType.toJSON !== this.toJSON) {
			json = trackType.toJSON(track);
		} else {
			// by default, we assume the data can be serialized as-is
			json = {
				'name': track.name,
				'times': convertArray(track.times, Array),
				'values': convertArray(track.values, Array)
			};
			const interpolation = track.getInterpolation();
			if (interpolation !== track.DefaultInterpolation) {
				json.interpolation = interpolation;
			}
		}
		json.type = track.ValueTypeName; // mandatory

		return json;
	}
	InterpolantFactoryMethodDiscrete(result) {
		return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
	}
	InterpolantFactoryMethodLinear(result) {
		return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
	}
	InterpolantFactoryMethodSmooth(result) {
		return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
	}
	setInterpolation(interpolation) {
		let factoryMethod;
		switch (interpolation) {
			case InterpolateDiscrete:
				factoryMethod = this.InterpolantFactoryMethodDiscrete;
				break;
			case InterpolateLinear:
				factoryMethod = this.InterpolantFactoryMethodLinear;
				break;
			case InterpolateSmooth:
				factoryMethod = this.InterpolantFactoryMethodSmooth;
				break;
		}
		if (factoryMethod === undefined) {
			const message = 'unsupported interpolation for ' + this.ValueTypeName + ' keyframe track named ' + this.name;
			if (this.createInterpolant === undefined) {
				// fall back to default, unless the default itself is messed up
				if (interpolation !== this.DefaultInterpolation) {
					this.setInterpolation(this.DefaultInterpolation);
				} else {
					throw new Error(message); // fatal, in this case
				}
			}

			console.warn('THREE.KeyframeTrack:', message);
			return this;
		}
		this.createInterpolant = factoryMethod;
		return this;
	}
	getInterpolation() {
		switch (this.createInterpolant) {
			case this.InterpolantFactoryMethodDiscrete:
				return InterpolateDiscrete;
			case this.InterpolantFactoryMethodLinear:
				return InterpolateLinear;
			case this.InterpolantFactoryMethodSmooth:
				return InterpolateSmooth;
		}
	}
	getValueSize() {
		return this.values.length / this.times.length;
	}

	// move all keyframes either forwards or backwards in time
	shift(timeOffset) {
		if (timeOffset !== 0.0) {
			const times = this.times;
			for (let i = 0, n = times.length; i !== n; ++i) {
				times[i] += timeOffset;
			}
		}
		return this;
	}

	// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
	scale(timeScale) {
		if (timeScale !== 1.0) {
			const times = this.times;
			for (let i = 0, n = times.length; i !== n; ++i) {
				times[i] *= timeScale;
			}
		}
		return this;
	}

	// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
	// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
	trim(startTime, endTime) {
		const times = this.times,
			nKeys = times.length;
		let from = 0,
			to = nKeys - 1;
		while (from !== nKeys && times[from] < startTime) {
			++from;
		}
		while (to !== -1 && times[to] > endTime) {
			--to;
		}
		++to; // inclusive -> exclusive bound

		if (from !== 0 || to !== nKeys) {
			// empty tracks are forbidden, so keep at least one keyframe
			if (from >= to) {
				to = Math.max(to, 1);
				from = to - 1;
			}
			const stride = this.getValueSize();
			this.times = arraySlice(times, from, to);
			this.values = arraySlice(this.values, from * stride, to * stride);
		}
		return this;
	}

	// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
	validate() {
		let valid = true;
		const valueSize = this.getValueSize();
		if (valueSize - Math.floor(valueSize) !== 0) {
			console.error('THREE.KeyframeTrack: Invalid value size in track.', this);
			valid = false;
		}
		const times = this.times,
			values = this.values,
			nKeys = times.length;
		if (nKeys === 0) {
			console.error('THREE.KeyframeTrack: Track is empty.', this);
			valid = false;
		}
		let prevTime = null;
		for (let i = 0; i !== nKeys; i++) {
			const currTime = times[i];
			if (typeof currTime === 'number' && isNaN(currTime)) {
				console.error('THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime);
				valid = false;
				break;
			}
			if (prevTime !== null && prevTime > currTime) {
				console.error('THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime);
				valid = false;
				break;
			}
			prevTime = currTime;
		}
		if (values !== undefined) {
			if (isTypedArray(values)) {
				for (let i = 0, n = values.length; i !== n; ++i) {
					const value = values[i];
					if (isNaN(value)) {
						console.error('THREE.KeyframeTrack: Value is not a valid number.', this, i, value);
						valid = false;
						break;
					}
				}
			}
		}
		return valid;
	}

	// removes equivalent sequential keys as common in morph target sequences
	// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
	optimize() {
		// times or values may be shared with other tracks, so overwriting is unsafe
		const times = arraySlice(this.times),
			values = arraySlice(this.values),
			stride = this.getValueSize(),
			smoothInterpolation = this.getInterpolation() === InterpolateSmooth,
			lastIndex = times.length - 1;
		let writeIndex = 1;
		for (let i = 1; i < lastIndex; ++i) {
			let keep = false;
			const time = times[i];
			const timeNext = times[i + 1];

			// remove adjacent keyframes scheduled at the same time

			if (time !== timeNext && (i !== 1 || time !== times[0])) {
				if (!smoothInterpolation) {
					// remove unnecessary keyframes same as their neighbors

					const offset = i * stride,
						offsetP = offset - stride,
						offsetN = offset + stride;
					for (let j = 0; j !== stride; ++j) {
						const value = values[offset + j];
						if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
							keep = true;
							break;
						}
					}
				} else {
					keep = true;
				}
			}

			// in-place compaction

			if (keep) {
				if (i !== writeIndex) {
					times[writeIndex] = times[i];
					const readOffset = i * stride,
						writeOffset = writeIndex * stride;
					for (let j = 0; j !== stride; ++j) {
						values[writeOffset + j] = values[readOffset + j];
					}
				}
				++writeIndex;
			}
		}

		// flush last keyframe (compaction looks ahead)

		if (lastIndex > 0) {
			times[writeIndex] = times[lastIndex];
			for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
				values[writeOffset + j] = values[readOffset + j];
			}
			++writeIndex;
		}
		if (writeIndex !== times.length) {
			this.times = arraySlice(times, 0, writeIndex);
			this.values = arraySlice(values, 0, writeIndex * stride);
		} else {
			this.times = times;
			this.values = values;
		}
		return this;
	}
	clone() {
		const times = arraySlice(this.times, 0);
		const values = arraySlice(this.values, 0);
		const TypedKeyframeTrack = this.constructor;
		const track = new TypedKeyframeTrack(this.name, times, values);

		// Interpolant argument to constructor is not saved, so copy the factory method directly.
		track.createInterpolant = this.createInterpolant;
		return track;
	}
}
KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;

/**
 * A Track of Boolean keyframe values.
 */
class BooleanKeyframeTrack extends KeyframeTrack {}
BooleanKeyframeTrack.prototype.ValueTypeName = 'bool';
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

/**
 * A Track of keyframe values that represent color.
 */
class ColorKeyframeTrack extends KeyframeTrack {}
ColorKeyframeTrack.prototype.ValueTypeName = 'color';

/**
 * A Track of numeric keyframe values.
 */
class NumberKeyframeTrack extends KeyframeTrack {}
NumberKeyframeTrack.prototype.ValueTypeName = 'number';

/**
 * Spherical linear unit quaternion interpolant.
 */

class QuaternionLinearInterpolant extends Interpolant {
	constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
		super(parameterPositions, sampleValues, sampleSize, resultBuffer);
	}
	interpolate_(i1, t0, t, t1) {
		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,
			alpha = (t - t0) / (t1 - t0);
		let offset = i1 * stride;
		for (let end = offset + stride; offset !== end; offset += 4) {
			Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
		}
		return result;
	}
}

/**
 * A Track of quaternion keyframe values.
 */
class QuaternionKeyframeTrack extends KeyframeTrack {
	InterpolantFactoryMethodLinear(result) {
		return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
	}
}
QuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion';
// ValueBufferType is inherited
QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

/**
 * A Track that interpolates Strings
 */
class StringKeyframeTrack extends KeyframeTrack {}
StringKeyframeTrack.prototype.ValueTypeName = 'string';
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

/**
 * A Track of vectored keyframe values.
 */
class VectorKeyframeTrack extends KeyframeTrack {}
VectorKeyframeTrack.prototype.ValueTypeName = 'vector';

class AnimationClip {
	constructor(name, duration = -1, tracks, blendMode = NormalAnimationBlendMode) {
		this.name = name;
		this.tracks = tracks;
		this.duration = duration;
		this.blendMode = blendMode;
		this.uuid = generateUUID();

		// this means it should figure out its duration by scanning the tracks
		if (this.duration < 0) {
			this.resetDuration();
		}
	}
	static parse(json) {
		const tracks = [],
			jsonTracks = json.tracks,
			frameTime = 1.0 / (json.fps || 1.0);
		for (let i = 0, n = jsonTracks.length; i !== n; ++i) {
			tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));
		}
		const clip = new this(json.name, json.duration, tracks, json.blendMode);
		clip.uuid = json.uuid;
		return clip;
	}
	static toJSON(clip) {
		const tracks = [],
			clipTracks = clip.tracks;
		const json = {
			'name': clip.name,
			'duration': clip.duration,
			'tracks': tracks,
			'uuid': clip.uuid,
			'blendMode': clip.blendMode
		};
		for (let i = 0, n = clipTracks.length; i !== n; ++i) {
			tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
		}
		return json;
	}
	static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
		const numMorphTargets = morphTargetSequence.length;
		const tracks = [];
		for (let i = 0; i < numMorphTargets; i++) {
			let times = [];
			let values = [];
			times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);
			values.push(0, 1, 0);
			const order = getKeyframeOrder(times);
			times = sortedArray(times, 1, order);
			values = sortedArray(values, 1, order);

			// if there is a key at the first frame, duplicate it as the
			// last frame as well for perfect loop.
			if (!noLoop && times[0] === 0) {
				times.push(numMorphTargets);
				values.push(values[0]);
			}
			tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i].name + ']', times, values).scale(1.0 / fps));
		}
		return new this(name, -1, tracks);
	}
	static findByName(objectOrClipArray, name) {
		let clipArray = objectOrClipArray;
		if (!Array.isArray(objectOrClipArray)) {
			const o = objectOrClipArray;
			clipArray = o.geometry && o.geometry.animations || o.animations;
		}
		for (let i = 0; i < clipArray.length; i++) {
			if (clipArray[i].name === name) {
				return clipArray[i];
			}
		}
		return null;
	}
	static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
		const animationToMorphTargets = {};

		// tested with https://regex101.com/ on trick sequences
		// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
		const pattern = /^([\w-]*?)([\d]+)$/;

		// sort morph target names into animation groups based
		// patterns like Walk_001, Walk_002, Run_001, Run_002
		for (let i = 0, il = morphTargets.length; i < il; i++) {
			const morphTarget = morphTargets[i];
			const parts = morphTarget.name.match(pattern);
			if (parts && parts.length > 1) {
				const name = parts[1];
				let animationMorphTargets = animationToMorphTargets[name];
				if (!animationMorphTargets) {
					animationToMorphTargets[name] = animationMorphTargets = [];
				}
				animationMorphTargets.push(morphTarget);
			}
		}
		const clips = [];
		for (const name in animationToMorphTargets) {
			clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
		}
		return clips;
	}

	// parse the animation.hierarchy format
	static parseAnimation(animation, bones) {
		if (!animation) {
			console.error('THREE.AnimationClip: No animation in JSONLoader data.');
			return null;
		}
		const addNonemptyTrack = function (trackType, trackName, animationKeys, propertyName, destTracks) {
			// only return track if there are actually keys.
			if (animationKeys.length !== 0) {
				const times = [];
				const values = [];
				flattenJSON(animationKeys, times, values, propertyName);

				// empty keys are filtered out, so check again
				if (times.length !== 0) {
					destTracks.push(new trackType(trackName, times, values));
				}
			}
		};
		const tracks = [];
		const clipName = animation.name || 'default';
		const fps = animation.fps || 30;
		const blendMode = animation.blendMode;

		// automatic length determination in AnimationClip.
		let duration = animation.length || -1;
		const hierarchyTracks = animation.hierarchy || [];
		for (let h = 0; h < hierarchyTracks.length; h++) {
			const animationKeys = hierarchyTracks[h].keys;

			// skip empty tracks
			if (!animationKeys || animationKeys.length === 0) continue;

			// process morph targets
			if (animationKeys[0].morphTargets) {
				// figure out all morph targets used in this track
				const morphTargetNames = {};
				let k;
				for (k = 0; k < animationKeys.length; k++) {
					if (animationKeys[k].morphTargets) {
						for (let m = 0; m < animationKeys[k].morphTargets.length; m++) {
							morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
						}
					}
				}

				// create a track for each morph target with all zero
				// morphTargetInfluences except for the keys in which
				// the morphTarget is named.
				for (const morphTargetName in morphTargetNames) {
					const times = [];
					const values = [];
					for (let m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
						const animationKey = animationKeys[k];
						times.push(animationKey.time);
						values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
					}
					tracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));
				}
				duration = morphTargetNames.length * fps;
			} else {
				// ...assume skeletal animation

				const boneName = '.bones[' + bones[h].name + ']';
				addNonemptyTrack(VectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks);
				addNonemptyTrack(QuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks);
				addNonemptyTrack(VectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks);
			}
		}
		if (tracks.length === 0) {
			return null;
		}
		const clip = new this(clipName, duration, tracks, blendMode);
		return clip;
	}
	resetDuration() {
		const tracks = this.tracks;
		let duration = 0;
		for (let i = 0, n = tracks.length; i !== n; ++i) {
			const track = this.tracks[i];
			duration = Math.max(duration, track.times[track.times.length - 1]);
		}
		this.duration = duration;
		return this;
	}
	trim() {
		for (let i = 0; i < this.tracks.length; i++) {
			this.tracks[i].trim(0, this.duration);
		}
		return this;
	}
	validate() {
		let valid = true;
		for (let i = 0; i < this.tracks.length; i++) {
			valid = valid && this.tracks[i].validate();
		}
		return valid;
	}
	optimize() {
		for (let i = 0; i < this.tracks.length; i++) {
			this.tracks[i].optimize();
		}
		return this;
	}
	clone() {
		const tracks = [];
		for (let i = 0; i < this.tracks.length; i++) {
			tracks.push(this.tracks[i].clone());
		}
		return new this.constructor(this.name, this.duration, tracks, this.blendMode);
	}
	toJSON() {
		return this.constructor.toJSON(this);
	}
}
function getTrackTypeForValueTypeName(typeName) {
	switch (typeName.toLowerCase()) {
		case 'scalar':
		case 'double':
		case 'float':
		case 'number':
		case 'integer':
			return NumberKeyframeTrack;
		case 'vector':
		case 'vector2':
		case 'vector3':
		case 'vector4':
			return VectorKeyframeTrack;
		case 'color':
			return ColorKeyframeTrack;
		case 'quaternion':
			return QuaternionKeyframeTrack;
		case 'bool':
		case 'boolean':
			return BooleanKeyframeTrack;
		case 'string':
			return StringKeyframeTrack;
	}
	throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);
}
function parseKeyframeTrack(json) {
	if (json.type === undefined) {
		throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
	}
	const trackType = getTrackTypeForValueTypeName(json.type);
	if (json.times === undefined) {
		const times = [],
			values = [];
		flattenJSON(json.keys, times, values, 'value');
		json.times = times;
		json.values = values;
	}

	// derived classes can define a static parse method
	if (trackType.parse !== undefined) {
		return trackType.parse(json);
	} else {
		// by default, we assume a constructor compatible with the base
		return new trackType(json.name, json.times, json.values, json.interpolation);
	}
}

const Cache = {
	enabled: false,
	files: {},
	add: function (key, file) {
		if (this.enabled === false) return;

		// console.log( 'THREE.Cache', 'Adding key:', key );

		this.files[key] = file;
	},
	get: function (key) {
		if (this.enabled === false) return;

		// console.log( 'THREE.Cache', 'Checking key:', key );

		return this.files[key];
	},
	remove: function (key) {
		delete this.files[key];
	},
	clear: function () {
		this.files = {};
	}
};

class LoadingManager {
	constructor(onLoad, onProgress, onError) {
		const scope = this;
		let isLoading = false;
		let itemsLoaded = 0;
		let itemsTotal = 0;
		let urlModifier = undefined;
		const handlers = [];

		// Refer to #5689 for the reason why we don't set .onStart
		// in the constructor

		this.onStart = undefined;
		this.onLoad = onLoad;
		this.onProgress = onProgress;
		this.onError = onError;
		this.itemStart = function (url) {
			itemsTotal++;
			if (isLoading === false) {
				if (scope.onStart !== undefined) {
					scope.onStart(url, itemsLoaded, itemsTotal);
				}
			}
			isLoading = true;
		};
		this.itemEnd = function (url) {
			itemsLoaded++;
			if (scope.onProgress !== undefined) {
				scope.onProgress(url, itemsLoaded, itemsTotal);
			}
			if (itemsLoaded === itemsTotal) {
				isLoading = false;
				if (scope.onLoad !== undefined) {
					scope.onLoad();
				}
			}
		};
		this.itemError = function (url) {
			if (scope.onError !== undefined) {
				scope.onError(url);
			}
		};
		this.resolveURL = function (url) {
			if (urlModifier) {
				return urlModifier(url);
			}
			return url;
		};
		this.setURLModifier = function (transform) {
			urlModifier = transform;
			return this;
		};
		this.addHandler = function (regex, loader) {
			handlers.push(regex, loader);
			return this;
		};
		this.removeHandler = function (regex) {
			const index = handlers.indexOf(regex);
			if (index !== -1) {
				handlers.splice(index, 2);
			}
			return this;
		};
		this.getHandler = function (file) {
			for (let i = 0, l = handlers.length; i < l; i += 2) {
				const regex = handlers[i];
				const loader = handlers[i + 1];
				if (regex.global) regex.lastIndex = 0; // see #17920

				if (regex.test(file)) {
					return loader;
				}
			}
			return null;
		};
	}
}
const DefaultLoadingManager = /*@__PURE__*/new LoadingManager();

class Loader {
	constructor(manager) {
		this.manager = manager !== undefined ? manager : DefaultLoadingManager;
		this.crossOrigin = 'anonymous';
		this.withCredentials = false;
		this.path = '';
		this.resourcePath = '';
		this.requestHeader = {};
	}
	load() {}
	loadAsync(url, onProgress) {
		const scope = this;
		return new Promise(function (resolve, reject) {
			scope.load(url, resolve, onProgress, reject);
		});
	}
	parse() {}
	setCrossOrigin(crossOrigin) {
		this.crossOrigin = crossOrigin;
		return this;
	}
	setWithCredentials(value) {
		this.withCredentials = value;
		return this;
	}
	setPath(path) {
		this.path = path;
		return this;
	}
	setResourcePath(resourcePath) {
		this.resourcePath = resourcePath;
		return this;
	}
	setRequestHeader(requestHeader) {
		this.requestHeader = requestHeader;
		return this;
	}
}

const loading = {};
class HttpError extends Error {
	constructor(message, response) {
		super(message);
		this.response = response;
	}
}
class FileLoader extends Loader {
	constructor(manager) {
		super(manager);
	}
	load(url, onLoad, onProgress, onError) {
		if (url === undefined) url = '';
		if (this.path !== undefined) url = this.path + url;
		url = this.manager.resolveURL(url);
		const cached = Cache.get(url);
		if (cached !== undefined) {
			this.manager.itemStart(url);
			setTimeout(() => {
				if (onLoad) onLoad(cached);
				this.manager.itemEnd(url);
			}, 0);
			return cached;
		}

		// Check if request is duplicate

		if (loading[url] !== undefined) {
			loading[url].push({
				onLoad: onLoad,
				onProgress: onProgress,
				onError: onError
			});
			return;
		}

		// Initialise array for duplicate requests
		loading[url] = [];
		loading[url].push({
			onLoad: onLoad,
			onProgress: onProgress,
			onError: onError
		});

		// create request
		const req = new Request(url, {
			headers: new Headers(this.requestHeader),
			credentials: this.withCredentials ? 'include' : 'same-origin'
			// An abort controller could be added within a future PR
		});

		// record states ( avoid data race )
		const mimeType = this.mimeType;
		const responseType = this.responseType;

		// start the fetch
		fetch(req).then(response => {
			if (response.status === 200 || response.status === 0) {
				// Some browsers return HTTP Status 0 when using non-http protocol
				// e.g. 'file://' or 'data://'. Handle as success.

				if (response.status === 0) {
					console.warn('THREE.FileLoader: HTTP Status 0 received.');
				}

				// Workaround: Checking if response.body === undefined for Alipay browser #23548

				if (typeof ReadableStream === 'undefined' || response.body === undefined || response.body.getReader === undefined) {
					return response;
				}
				const callbacks = loading[url];
				const reader = response.body.getReader();
				const contentLength = response.headers.get('Content-Length');
				const total = contentLength ? parseInt(contentLength) : 0;
				const lengthComputable = total !== 0;
				let loaded = 0;

				// periodically read data into the new stream tracking while download progress
				const stream = new ReadableStream({
					start(controller) {
						readData();
						function readData() {
							reader.read().then(({
								done,
								value
							}) => {
								if (done) {
									controller.close();
								} else {
									loaded += value.byteLength;
									const event = new ProgressEvent('progress', {
										lengthComputable,
										loaded,
										total
									});
									for (let i = 0, il = callbacks.length; i < il; i++) {
										const callback = callbacks[i];
										if (callback.onProgress) callback.onProgress(event);
									}
									controller.enqueue(value);
									readData();
								}
							});
						}
					}
				});
				return new Response(stream);
			} else {
				throw new HttpError(`fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`, response);
			}
		}).then(response => {
			switch (responseType) {
				case 'arraybuffer':
					return response.arrayBuffer();
				case 'blob':
					return response.blob();
				case 'document':
					return response.text().then(text => {
						const parser = new DOMParser();
						return parser.parseFromString(text, mimeType);
					});
				case 'json':
					return response.json();
				default:
					if (mimeType === undefined) {
						return response.text();
					} else {
						// sniff encoding
						const re = /charset="?([^;"\s]*)"?/i;
						const exec = re.exec(mimeType);
						const label = exec && exec[1] ? exec[1].toLowerCase() : undefined;
						const decoder = new TextDecoder(label);
						return response.arrayBuffer().then(ab => decoder.decode(ab));
					}
			}
		}).then(data => {
			// Add to cache only on HTTP success, so that we do not cache
			// error response bodies as proper responses to requests.
			Cache.add(url, data);
			const callbacks = loading[url];
			delete loading[url];
			for (let i = 0, il = callbacks.length; i < il; i++) {
				const callback = callbacks[i];
				if (callback.onLoad) callback.onLoad(data);
			}
		}).catch(err => {
			// Abort errors and other errors are handled the same

			const callbacks = loading[url];
			if (callbacks === undefined) {
				// When onLoad was called and url was deleted in `loading`
				this.manager.itemError(url);
				throw err;
			}
			delete loading[url];
			for (let i = 0, il = callbacks.length; i < il; i++) {
				const callback = callbacks[i];
				if (callback.onError) callback.onError(err);
			}
			this.manager.itemError(url);
		}).finally(() => {
			this.manager.itemEnd(url);
		});
		this.manager.itemStart(url);
	}
	setResponseType(value) {
		this.responseType = value;
		return this;
	}
	setMimeType(value) {
		this.mimeType = value;
		return this;
	}
}

class AnimationLoader extends Loader {
	constructor(manager) {
		super(manager);
	}
	load(url, onLoad, onProgress, onError) {
		const scope = this;
		const loader = new FileLoader(this.manager);
		loader.setPath(this.path);
		loader.setRequestHeader(this.requestHeader);
		loader.setWithCredentials(this.withCredentials);
		loader.load(url, function (text) {
			try {
				onLoad(scope.parse(JSON.parse(text)));
			} catch (e) {
				if (onError) {
					onError(e);
				} else {
					console.error(e);
				}
				scope.manager.itemError(url);
			}
		}, onProgress, onError);
	}
	parse(json) {
		const animations = [];
		for (let i = 0; i < json.length; i++) {
			const clip = AnimationClip.parse(json[i]);
			animations.push(clip);
		}
		return animations;
	}
}

/**
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */

class CompressedTextureLoader extends Loader {
	constructor(manager) {
		super(manager);
	}
	load(url, onLoad, onProgress, onError) {
		const scope = this;
		const images = [];
		const texture = new CompressedTexture();
		const loader = new FileLoader(this.manager);
		loader.setPath(this.path);
		loader.setResponseType('arraybuffer');
		loader.setRequestHeader(this.requestHeader);
		loader.setWithCredentials(scope.withCredentials);
		let loaded = 0;
		function loadTexture(i) {
			loader.load(url[i], function (buffer) {
				const texDatas = scope.parse(buffer, true);
				images[i] = {
					width: texDatas.width,
					height: texDatas.height,
					format: texDatas.format,
					mipmaps: texDatas.mipmaps
				};
				loaded += 1;
				if (loaded === 6) {
					if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;
					texture.image = images;
					texture.format = texDatas.format;
					texture.needsUpdate = true;
					if (onLoad) onLoad(texture);
				}
			}, onProgress, onError);
		}
		if (Array.isArray(url)) {
			for (let i = 0, il = url.length; i < il; ++i) {
				loadTexture(i);
			}
		} else {
			// compressed cubemap texture stored in a single DDS file

			loader.load(url, function (buffer) {
				const texDatas = scope.parse(buffer, true);
				if (texDatas.isCubemap) {
					const faces = texDatas.mipmaps.length / texDatas.mipmapCount;
					for (let f = 0; f < faces; f++) {
						images[f] = {
							mipmaps: []
						};
						for (let i = 0; i < texDatas.mipmapCount; i++) {
							images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
							images[f].format = texDatas.format;
							images[f].width = texDatas.width;
							images[f].height = texDatas.height;
						}
					}
					texture.image = images;
				} else {
					texture.image.width = texDatas.width;
					texture.image.height = texDatas.height;
					texture.mipmaps = texDatas.mipmaps;
				}
				if (texDatas.mipmapCount === 1) {
					texture.minFilter = LinearFilter;
				}
				texture.format = texDatas.format;
				texture.needsUpdate = true;
				if (onLoad) onLoad(texture);
			}, onProgress, onError);
		}
		return texture;
	}
}

class ImageLoader extends Loader {
	constructor(manager) {
		super(manager);
	}
	load(url, onLoad, onProgress, onError) {
		if (this.path !== undefined) url = this.path + url;
		url = this.manager.resolveURL(url);
		const scope = this;
		const cached = Cache.get(url);
		if (cached !== undefined) {
			scope.manager.itemStart(url);
			setTimeout(function () {
				if (onLoad) onLoad(cached);
				scope.manager.itemEnd(url);
			}, 0);
			return cached;
		}
		const image = createElementNS('img');
		function onImageLoad() {
			removeEventListeners();
			Cache.add(url, this);
			if (onLoad) onLoad(this);
			scope.manager.itemEnd(url);
		}
		function onImageError(event) {
			removeEventListeners();
			if (onError) onError(event);
			scope.manager.itemError(url);
			scope.manager.itemEnd(url);
		}
		function removeEventListeners() {
			image.removeEventListener('load', onImageLoad, false);
			image.removeEventListener('error', onImageError, false);
		}
		image.addEventListener('load', onImageLoad, false);
		image.addEventListener('error', onImageError, false);
		if (url.slice(0, 5) !== 'data:') {
			if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;
		}
		scope.manager.itemStart(url);
		image.src = url;
		return image;
	}
}

class CubeTextureLoader extends Loader {
	constructor(manager) {
		super(manager);
	}
	load(urls, onLoad, onProgress, onError) {
		const texture = new CubeTexture();
		const loader = new ImageLoader(this.manager);
		loader.setCrossOrigin(this.crossOrigin);
		loader.setPath(this.path);
		let loaded = 0;
		function loadTexture(i) {
			loader.load(urls[i], function (image) {
				texture.images[i] = image;
				loaded++;
				if (loaded === 6) {
					texture.needsUpdate = true;
					if (onLoad) onLoad(texture);
				}
			}, undefined, onError);
		}
		for (let i = 0; i < urls.length; ++i) {
			loadTexture(i);
		}
		return texture;
	}
}

/**
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */

class DataTextureLoader extends Loader {
	constructor(manager) {
		super(manager);
	}
	load(url, onLoad, onProgress, onError) {
		const scope = this;
		const texture = new DataTexture();
		const loader = new FileLoader(this.manager);
		loader.setResponseType('arraybuffer');
		loader.setRequestHeader(this.requestHeader);
		loader.setPath(this.path);
		loader.setWithCredentials(scope.withCredentials);
		loader.load(url, function (buffer) {
			const texData = scope.parse(buffer);
			if (!texData) return;
			if (texData.image !== undefined) {
				texture.image = texData.image;
			} else if (texData.data !== undefined) {
				texture.image.width = texData.width;
				texture.image.height = texData.height;
				texture.image.data = texData.data;
			}
			texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
			texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;
			texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
			texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;
			texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;
			if (texData.encoding !== undefined) {
				texture.encoding = texData.encoding;
			}
			if (texData.flipY !== undefined) {
				texture.flipY = texData.flipY;
			}
			if (texData.format !== undefined) {
				texture.format = texData.format;
			}
			if (texData.type !== undefined) {
				texture.type = texData.type;
			}
			if (texData.mipmaps !== undefined) {
				texture.mipmaps = texData.mipmaps;
				texture.minFilter = LinearMipmapLinearFilter; // presumably...
			}

			if (texData.mipmapCount === 1) {
				texture.minFilter = LinearFilter;
			}
			if (texData.generateMipmaps !== undefined) {
				texture.generateMipmaps = texData.generateMipmaps;
			}
			texture.needsUpdate = true;
			if (onLoad) onLoad(texture, texData);
		}, onProgress, onError);
		return texture;
	}
}

class TextureLoader extends Loader {
	constructor(manager) {
		super(manager);
	}
	load(url, onLoad, onProgress, onError) {
		const texture = new Texture();
		const loader = new ImageLoader(this.manager);
		loader.setCrossOrigin(this.crossOrigin);
		loader.setPath(this.path);
		loader.load(url, function (image) {
			texture.image = image;
			texture.needsUpdate = true;
			if (onLoad !== undefined) {
				onLoad(texture);
			}
		}, onProgress, onError);
		return texture;
	}
}

class Light extends Object3D {
	constructor(color, intensity = 1) {
		super();
		this.isLight = true;
		this.type = 'Light';
		this.color = new Color(color);
		this.intensity = intensity;
	}
	dispose() {

		// Empty here in base class; some subclasses override.
	}
	copy(source, recursive) {
		super.copy(source, recursive);
		this.color.copy(source.color);
		this.intensity = source.intensity;
		return this;
	}
	toJSON(meta) {
		const data = super.toJSON(meta);
		data.object.color = this.color.getHex();
		data.object.intensity = this.intensity;
		if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();
		if (this.distance !== undefined) data.object.distance = this.distance;
		if (this.angle !== undefined) data.object.angle = this.angle;
		if (this.decay !== undefined) data.object.decay = this.decay;
		if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;
		if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();
		return data;
	}
}

class HemisphereLight extends Light {
	constructor(skyColor, groundColor, intensity) {
		super(skyColor, intensity);
		this.isHemisphereLight = true;
		this.type = 'HemisphereLight';
		this.position.copy(Object3D.DefaultUp);
		this.updateMatrix();
		this.groundColor = new Color(groundColor);
	}
	copy(source, recursive) {
		super.copy(source, recursive);
		this.groundColor.copy(source.groundColor);
		return this;
	}
}

const _projScreenMatrix$1 = /*@__PURE__*/new Matrix4();
const _lightPositionWorld$1 = /*@__PURE__*/new Vector3();
const _lookTarget$1 = /*@__PURE__*/new Vector3();
class LightShadow {
	constructor(camera) {
		this.camera = camera;
		this.bias = 0;
		this.normalBias = 0;
		this.radius = 1;
		this.blurSamples = 8;
		this.mapSize = new Vector2(512, 512);
		this.map = null;
		this.mapPass = null;
		this.matrix = new Matrix4();
		this.autoUpdate = true;
		this.needsUpdate = false;
		this._frustum = new Frustum();
		this._frameExtents = new Vector2(1, 1);
		this._viewportCount = 1;
		this._viewports = [new Vector4(0, 0, 1, 1)];
	}
	getViewportCount() {
		return this._viewportCount;
	}
	getFrustum() {
		return this._frustum;
	}
	updateMatrices(light) {
		const shadowCamera = this.camera;
		const shadowMatrix = this.matrix;
		_lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
		shadowCamera.position.copy(_lightPositionWorld$1);
		_lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);
		shadowCamera.lookAt(_lookTarget$1);
		shadowCamera.updateMatrixWorld();
		_projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
		this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
		shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
		shadowMatrix.multiply(_projScreenMatrix$1);
	}
	getViewport(viewportIndex) {
		return this._viewports[viewportIndex];
	}
	getFrameExtents() {
		return this._frameExtents;
	}
	dispose() {
		if (this.map) {
			this.map.dispose();
		}
		if (this.mapPass) {
			this.mapPass.dispose();
		}
	}
	copy(source) {
		this.camera = source.camera.clone();
		this.bias = source.bias;
		this.radius = source.radius;
		this.mapSize.copy(source.mapSize);
		return this;
	}
	clone() {
		return new this.constructor().copy(this);
	}
	toJSON() {
		const object = {};
		if (this.bias !== 0) object.bias = this.bias;
		if (this.normalBias !== 0) object.normalBias = this.normalBias;
		if (this.radius !== 1) object.radius = this.radius;
		if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
		object.camera = this.camera.toJSON(false).object;
		delete object.camera.matrix;
		return object;
	}
}

class SpotLightShadow extends LightShadow {
	constructor() {
		super(new PerspectiveCamera(50, 1, 0.5, 500));
		this.isSpotLightShadow = true;
		this.focus = 1;
	}
	updateMatrices(light) {
		const camera = this.camera;
		const fov = RAD2DEG * 2 * light.angle * this.focus;
		const aspect = this.mapSize.width / this.mapSize.height;
		const far = light.distance || camera.far;
		if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {
			camera.fov = fov;
			camera.aspect = aspect;
			camera.far = far;
			camera.updateProjectionMatrix();
		}
		super.updateMatrices(light);
	}
	copy(source) {
		super.copy(source);
		this.focus = source.focus;
		return this;
	}
}

class SpotLight extends Light {
	constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1) {
		super(color, intensity);
		this.isSpotLight = true;
		this.type = 'SpotLight';
		this.position.copy(Object3D.DefaultUp);
		this.updateMatrix();
		this.target = new Object3D();
		this.distance = distance;
		this.angle = angle;
		this.penumbra = penumbra;
		this.decay = decay; // for physically correct lights, should be 2.

		this.map = null;
		this.shadow = new SpotLightShadow();
	}
	get power() {
		// compute the light's luminous power (in lumens) from its intensity (in candela)
		// by convention for a spotlight, luminous power (lm) = π * luminous intensity (cd)
		return this.intensity * Math.PI;
	}
	set power(power) {
		// set the light's intensity (in candela) from the desired luminous power (in lumens)
		this.intensity = power / Math.PI;
	}
	dispose() {
		this.shadow.dispose();
	}
	copy(source, recursive) {
		super.copy(source, recursive);
		this.distance = source.distance;
		this.angle = source.angle;
		this.penumbra = source.penumbra;
		this.decay = source.decay;
		this.target = source.target.clone();
		this.shadow = source.shadow.clone();
		return this;
	}
}

const _projScreenMatrix = /*@__PURE__*/new Matrix4();
const _lightPositionWorld = /*@__PURE__*/new Vector3();
const _lookTarget = /*@__PURE__*/new Vector3();
class PointLightShadow extends LightShadow {
	constructor() {
		super(new PerspectiveCamera(90, 1, 0.5, 500));
		this.isPointLightShadow = true;
		this._frameExtents = new Vector2(4, 2);
		this._viewportCount = 6;
		this._viewports = [
		// These viewports map a cube-map onto a 2D texture with the
		// following orientation:
		//
		//	xzXZ
		//	 y Y
		//
		// X - Positive x direction
		// x - Negative x direction
		// Y - Positive y direction
		// y - Negative y direction
		// Z - Positive z direction
		// z - Negative z direction

		// positive X
		new Vector4(2, 1, 1, 1),
		// negative X
		new Vector4(0, 1, 1, 1),
		// positive Z
		new Vector4(3, 1, 1, 1),
		// negative Z
		new Vector4(1, 1, 1, 1),
		// positive Y
		new Vector4(3, 0, 1, 1),
		// negative Y
		new Vector4(1, 0, 1, 1)];
		this._cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)];
		this._cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)];
	}
	updateMatrices(light, viewportIndex = 0) {
		const camera = this.camera;
		const shadowMatrix = this.matrix;
		const far = light.distance || camera.far;
		if (far !== camera.far) {
			camera.far = far;
			camera.updateProjectionMatrix();
		}
		_lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
		camera.position.copy(_lightPositionWorld);
		_lookTarget.copy(camera.position);
		_lookTarget.add(this._cubeDirections[viewportIndex]);
		camera.up.copy(this._cubeUps[viewportIndex]);
		camera.lookAt(_lookTarget);
		camera.updateMatrixWorld();
		shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
		_projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
		this._frustum.setFromProjectionMatrix(_projScreenMatrix);
	}
}

class PointLight extends Light {
	constructor(color, intensity, distance = 0, decay = 1) {
		super(color, intensity);
		this.isPointLight = true;
		this.type = 'PointLight';
		this.distance = distance;
		this.decay = decay; // for physically correct lights, should be 2.

		this.shadow = new PointLightShadow();
	}
	get power() {
		// compute the light's luminous power (in lumens) from its intensity (in candela)
		// for an isotropic light source, luminous power (lm) = 4 π luminous intensity (cd)
		return this.intensity * 4 * Math.PI;
	}
	set power(power) {
		// set the light's intensity (in candela) from the desired luminous power (in lumens)
		this.intensity = power / (4 * Math.PI);
	}
	dispose() {
		this.shadow.dispose();
	}
	copy(source, recursive) {
		super.copy(source, recursive);
		this.distance = source.distance;
		this.decay = source.decay;
		this.shadow = source.shadow.clone();
		return this;
	}
}

class DirectionalLightShadow extends LightShadow {
	constructor() {
		super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
		this.isDirectionalLightShadow = true;
	}
}

class DirectionalLight extends Light {
	constructor(color, intensity) {
		super(color, intensity);
		this.isDirectionalLight = true;
		this.type = 'DirectionalLight';
		this.position.copy(Object3D.DefaultUp);
		this.updateMatrix();
		this.target = new Object3D();
		this.shadow = new DirectionalLightShadow();
	}
	dispose() {
		this.shadow.dispose();
	}
	copy(source) {
		super.copy(source);
		this.target = source.target.clone();
		this.shadow = source.shadow.clone();
		return this;
	}
}

class AmbientLight extends Light {
	constructor(color, intensity) {
		super(color, intensity);
		this.isAmbientLight = true;
		this.type = 'AmbientLight';
	}
}

class RectAreaLight extends Light {
	constructor(color, intensity, width = 10, height = 10) {
		super(color, intensity);
		this.isRectAreaLight = true;
		this.type = 'RectAreaLight';
		this.width = width;
		this.height = height;
	}
	get power() {
		// compute the light's luminous power (in lumens) from its intensity (in nits)
		return this.intensity * this.width * this.height * Math.PI;
	}
	set power(power) {
		// set the light's intensity (in nits) from the desired luminous power (in lumens)
		this.intensity = power / (this.width * this.height * Math.PI);
	}
	copy(source) {
		super.copy(source);
		this.width = source.width;
		this.height = source.height;
		return this;
	}
	toJSON(meta) {
		const data = super.toJSON(meta);
		data.object.width = this.width;
		data.object.height = this.height;
		return data;
	}
}

/**
 * Primary reference:
 *	 https://graphics.stanford.edu/papers/envmap/envmap.pdf
 *
 * Secondary reference:
 *	 https://www.ppsloan.org/publications/StupidSH36.pdf
 */

// 3-band SH defined by 9 coefficients

class SphericalHarmonics3 {
	constructor() {
		this.isSphericalHarmonics3 = true;
		this.coefficients = [];
		for (let i = 0; i < 9; i++) {
			this.coefficients.push(new Vector3());
		}
	}
	set(coefficients) {
		for (let i = 0; i < 9; i++) {
			this.coefficients[i].copy(coefficients[i]);
		}
		return this;
	}
	zero() {
		for (let i = 0; i < 9; i++) {
			this.coefficients[i].set(0, 0, 0);
		}
		return this;
	}

	// get the radiance in the direction of the normal
	// target is a Vector3
	getAt(normal, target) {
		// normal is assumed to be unit length

		const x = normal.x,
			y = normal.y,
			z = normal.z;
		const coeff = this.coefficients;

		// band 0
		target.copy(coeff[0]).multiplyScalar(0.282095);

		// band 1
		target.addScaledVector(coeff[1], 0.488603 * y);
		target.addScaledVector(coeff[2], 0.488603 * z);
		target.addScaledVector(coeff[3], 0.488603 * x);

		// band 2
		target.addScaledVector(coeff[4], 1.092548 * (x * y));
		target.addScaledVector(coeff[5], 1.092548 * (y * z));
		target.addScaledVector(coeff[6], 0.315392 * (3.0 * z * z - 1.0));
		target.addScaledVector(coeff[7], 1.092548 * (x * z));
		target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));
		return target;
	}

	// get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
	// target is a Vector3
	// https://graphics.stanford.edu/papers/envmap/envmap.pdf
	getIrradianceAt(normal, target) {
		// normal is assumed to be unit length

		const x = normal.x,
			y = normal.y,
			z = normal.z;
		const coeff = this.coefficients;

		// band 0
		target.copy(coeff[0]).multiplyScalar(0.886227); // π * 0.282095

		// band 1
		target.addScaledVector(coeff[1], 2.0 * 0.511664 * y); // ( 2 * π / 3 ) * 0.488603
		target.addScaledVector(coeff[2], 2.0 * 0.511664 * z);
		target.addScaledVector(coeff[3], 2.0 * 0.511664 * x);

		// band 2
		target.addScaledVector(coeff[4], 2.0 * 0.429043 * x * y); // ( π / 4 ) * 1.092548
		target.addScaledVector(coeff[5], 2.0 * 0.429043 * y * z);
		target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708); // ( π / 4 ) * 0.315392 * 3
		target.addScaledVector(coeff[7], 2.0 * 0.429043 * x * z);
		target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y)); // ( π / 4 ) * 0.546274

		return target;
	}
	add(sh) {
		for (let i = 0; i < 9; i++) {
			this.coefficients[i].add(sh.coefficients[i]);
		}
		return this;
	}
	addScaledSH(sh, s) {
		for (let i = 0; i < 9; i++) {
			this.coefficients[i].addScaledVector(sh.coefficients[i], s);
		}
		return this;
	}
	scale(s) {
		for (let i = 0; i < 9; i++) {
			this.coefficients[i].multiplyScalar(s);
		}
		return this;
	}
	lerp(sh, alpha) {
		for (let i = 0; i < 9; i++) {
			this.coefficients[i].lerp(sh.coefficients[i], alpha);
		}
		return this;
	}
	equals(sh) {
		for (let i = 0; i < 9; i++) {
			if (!this.coefficients[i].equals(sh.coefficients[i])) {
				return false;
			}
		}
		return true;
	}
	copy(sh) {
		return this.set(sh.coefficients);
	}
	clone() {
		return new this.constructor().copy(this);
	}
	fromArray(array, offset = 0) {
		const coefficients = this.coefficients;
		for (let i = 0; i < 9; i++) {
			coefficients[i].fromArray(array, offset + i * 3);
		}
		return this;
	}
	toArray(array = [], offset = 0) {
		const coefficients = this.coefficients;
		for (let i = 0; i < 9; i++) {
			coefficients[i].toArray(array, offset + i * 3);
		}
		return array;
	}

	// evaluate the basis functions
	// shBasis is an Array[ 9 ]
	static getBasisAt(normal, shBasis) {
		// normal is assumed to be unit length

		const x = normal.x,
			y = normal.y,
			z = normal.z;

		// band 0
		shBasis[0] = 0.282095;

		// band 1
		shBasis[1] = 0.488603 * y;
		shBasis[2] = 0.488603 * z;
		shBasis[3] = 0.488603 * x;

		// band 2
		shBasis[4] = 1.092548 * x * y;
		shBasis[5] = 1.092548 * y * z;
		shBasis[6] = 0.315392 * (3 * z * z - 1);
		shBasis[7] = 1.092548 * x * z;
		shBasis[8] = 0.546274 * (x * x - y * y);
	}
}

class LightProbe extends Light {
	constructor(sh = new SphericalHarmonics3(), intensity = 1) {
		super(undefined, intensity);
		this.isLightProbe = true;
		this.sh = sh;
	}
	copy(source) {
		super.copy(source);
		this.sh.copy(source.sh);
		return this;
	}
	fromJSON(json) {
		this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();
		this.sh.fromArray(json.sh);
		return this;
	}
	toJSON(meta) {
		const data = super.toJSON(meta);
		data.object.sh = this.sh.toArray();
		return data;
	}
}

class MaterialLoader extends Loader {
	constructor(manager) {
		super(manager);
		this.textures = {};
	}
	load(url, onLoad, onProgress, onError) {
		const scope = this;
		const loader = new FileLoader(scope.manager);
		loader.setPath(scope.path);
		loader.setRequestHeader(scope.requestHeader);
		loader.setWithCredentials(scope.withCredentials);
		loader.load(url, function (text) {
			try {
				onLoad(scope.parse(JSON.parse(text)));
			} catch (e) {
				if (onError) {
					onError(e);
				} else {
					console.error(e);
				}
				scope.manager.itemError(url);
			}
		}, onProgress, onError);
	}
	parse(json) {
		const textures = this.textures;
		function getTexture(name) {
			if (textures[name] === undefined) {
				console.warn('THREE.MaterialLoader: Undefined texture', name);
			}
			return textures[name];
		}
		const material = MaterialLoader.createMaterialFromType(json.type);
		if (json.uuid !== undefined) material.uuid = json.uuid;
		if (json.name !== undefined) material.name = json.name;
		if (json.color !== undefined && material.color !== undefined) material.color.setHex(json.color);
		if (json.roughness !== undefined) material.roughness = json.roughness;
		if (json.metalness !== undefined) material.metalness = json.metalness;
		if (json.sheen !== undefined) material.sheen = json.sheen;
		if (json.sheenColor !== undefined) material.sheenColor = new Color().setHex(json.sheenColor);
		if (json.sheenRoughness !== undefined) material.sheenRoughness = json.sheenRoughness;
		if (json.emissive !== undefined && material.emissive !== undefined) material.emissive.setHex(json.emissive);
		if (json.specular !== undefined && material.specular !== undefined) material.specular.setHex(json.specular);
		if (json.specularIntensity !== undefined) material.specularIntensity = json.specularIntensity;
		if (json.specularColor !== undefined && material.specularColor !== undefined) material.specularColor.setHex(json.specularColor);
		if (json.shininess !== undefined) material.shininess = json.shininess;
		if (json.clearcoat !== undefined) material.clearcoat = json.clearcoat;
		if (json.clearcoatRoughness !== undefined) material.clearcoatRoughness = json.clearcoatRoughness;
		if (json.iridescence !== undefined) material.iridescence = json.iridescence;
		if (json.iridescenceIOR !== undefined) material.iridescenceIOR = json.iridescenceIOR;
		if (json.iridescenceThicknessRange !== undefined) material.iridescenceThicknessRange = json.iridescenceThicknessRange;
		if (json.transmission !== undefined) material.transmission = json.transmission;
		if (json.thickness !== undefined) material.thickness = json.thickness;
		if (json.attenuationDistance !== undefined) material.attenuationDistance = json.attenuationDistance;
		if (json.attenuationColor !== undefined && material.attenuationColor !== undefined) material.attenuationColor.setHex(json.attenuationColor);
		if (json.fog !== undefined) material.fog = json.fog;
		if (json.flatShading !== undefined) material.flatShading = json.flatShading;
		if (json.blending !== undefined) material.blending = json.blending;
		if (json.combine !== undefined) material.combine = json.combine;
		if (json.side !== undefined) material.side = json.side;
		if (json.shadowSide !== undefined) material.shadowSide = json.shadowSide;
		if (json.opacity !== undefined) material.opacity = json.opacity;
		if (json.transparent !== undefined) material.transparent = json.transparent;
		if (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;
		if (json.depthTest !== undefined) material.depthTest = json.depthTest;
		if (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;
		if (json.colorWrite !== undefined) material.colorWrite = json.colorWrite;
		if (json.stencilWrite !== undefined) material.stencilWrite = json.stencilWrite;
		if (json.stencilWriteMask !== undefined) material.stencilWriteMask = json.stencilWriteMask;
		if (json.stencilFunc !== undefined) material.stencilFunc = json.stencilFunc;
		if (json.stencilRef !== undefined) material.stencilRef = json.stencilRef;
		if (json.stencilFuncMask !== undefined) material.stencilFuncMask = json.stencilFuncMask;
		if (json.stencilFail !== undefined) material.stencilFail = json.stencilFail;
		if (json.stencilZFail !== undefined) material.stencilZFail = json.stencilZFail;
		if (json.stencilZPass !== undefined) material.stencilZPass = json.stencilZPass;
		if (json.wireframe !== undefined) material.wireframe = json.wireframe;
		if (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth;
		if (json.wireframeLinecap !== undefined) material.wireframeLinecap = json.wireframeLinecap;
		if (json.wireframeLinejoin !== undefined) material.wireframeLinejoin = json.wireframeLinejoin;
		if (json.rotation !== undefined) material.rotation = json.rotation;
		if (json.linewidth !== 1) material.linewidth = json.linewidth;
		if (json.dashSize !== undefined) material.dashSize = json.dashSize;
		if (json.gapSize !== undefined) material.gapSize = json.gapSize;
		if (json.scale !== undefined) material.scale = json.scale;
		if (json.polygonOffset !== undefined) material.polygonOffset = json.polygonOffset;
		if (json.polygonOffsetFactor !== undefined) material.polygonOffsetFactor = json.polygonOffsetFactor;
		if (json.polygonOffsetUnits !== undefined) material.polygonOffsetUnits = json.polygonOffsetUnits;
		if (json.dithering !== undefined) material.dithering = json.dithering;
		if (json.alphaToCoverage !== undefined) material.alphaToCoverage = json.alphaToCoverage;
		if (json.premultipliedAlpha !== undefined) material.premultipliedAlpha = json.premultipliedAlpha;
		if (json.visible !== undefined) material.visible = json.visible;
		if (json.toneMapped !== undefined) material.toneMapped = json.toneMapped;
		if (json.userData !== undefined) material.userData = json.userData;
		if (json.vertexColors !== undefined) {
			if (typeof json.vertexColors === 'number') {
				material.vertexColors = json.vertexColors > 0 ? true : false;
			} else {
				material.vertexColors = json.vertexColors;
			}
		}

		// Shader Material

		if (json.uniforms !== undefined) {
			for (const name in json.uniforms) {
				const uniform = json.uniforms[name];
				material.uniforms[name] = {};
				switch (uniform.type) {
					case 't':
						material.uniforms[name].value = getTexture(uniform.value);
						break;
					case 'c':
						material.uniforms[name].value = new Color().setHex(uniform.value);
						break;
					case 'v2':
						material.uniforms[name].value = new Vector2().fromArray(uniform.value);
						break;
					case 'v3':
						material.uniforms[name].value = new Vector3().fromArray(uniform.value);
						break;
					case 'v4':
						material.uniforms[name].value = new Vector4().fromArray(uniform.value);
						break;
					case 'm3':
						material.uniforms[name].value = new Matrix3().fromArray(uniform.value);
						break;
					case 'm4':
						material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
						break;
					default:
						material.uniforms[name].value = uniform.value;
				}
			}
		}
		if (json.defines !== undefined) material.defines = json.defines;
		if (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;
		if (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;
		if (json.glslVersion !== undefined) material.glslVersion = json.glslVersion;
		if (json.extensions !== undefined) {
			for (const key in json.extensions) {
				material.extensions[key] = json.extensions[key];
			}
		}

		// for PointsMaterial

		if (json.size !== undefined) material.size = json.size;
		if (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation;

		// maps

		if (json.map !== undefined) material.map = getTexture(json.map);
		if (json.matcap !== undefined) material.matcap = getTexture(json.matcap);
		if (json.alphaMap !== undefined) material.alphaMap = getTexture(json.alphaMap);
		if (json.bumpMap !== undefined) material.bumpMap = getTexture(json.bumpMap);
		if (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;
		if (json.normalMap !== undefined) material.normalMap = getTexture(json.normalMap);
		if (json.normalMapType !== undefined) material.normalMapType = json.normalMapType;
		if (json.normalScale !== undefined) {
			let normalScale = json.normalScale;
			if (Array.isArray(normalScale) === false) {
				// Blender exporter used to export a scalar. See #7459

				normalScale = [normalScale, normalScale];
			}
			material.normalScale = new Vector2().fromArray(normalScale);
		}
		if (json.displacementMap !== undefined) material.displacementMap = getTexture(json.displacementMap);
		if (json.displacementScale !== undefined) material.displacementScale = json.displacementScale;
		if (json.displacementBias !== undefined) material.displacementBias = json.displacementBias;
		if (json.roughnessMap !== undefined) material.roughnessMap = getTexture(json.roughnessMap);
		if (json.metalnessMap !== undefined) material.metalnessMap = getTexture(json.metalnessMap);
		if (json.emissiveMap !== undefined) material.emissiveMap = getTexture(json.emissiveMap);
		if (json.emissiveIntensity !== undefined) material.emissiveIntensity = json.emissiveIntensity;
		if (json.specularMap !== undefined) material.specularMap = getTexture(json.specularMap);
		if (json.specularIntensityMap !== undefined) material.specularIntensityMap = getTexture(json.specularIntensityMap);
		if (json.specularColorMap !== undefined) material.specularColorMap = getTexture(json.specularColorMap);
		if (json.envMap !== undefined) material.envMap = getTexture(json.envMap);
		if (json.envMapIntensity !== undefined) material.envMapIntensity = json.envMapIntensity;
		if (json.reflectivity !== undefined) material.reflectivity = json.reflectivity;
		if (json.refractionRatio !== undefined) material.refractionRatio = json.refractionRatio;
		if (json.lightMap !== undefined) material.lightMap = getTexture(json.lightMap);
		if (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity;
		if (json.aoMap !== undefined) material.aoMap = getTexture(json.aoMap);
		if (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity;
		if (json.gradientMap !== undefined) material.gradientMap = getTexture(json.gradientMap);
		if (json.clearcoatMap !== undefined) material.clearcoatMap = getTexture(json.clearcoatMap);
		if (json.clearcoatRoughnessMap !== undefined) material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
		if (json.clearcoatNormalMap !== undefined) material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
		if (json.clearcoatNormalScale !== undefined) material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);
		if (json.iridescenceMap !== undefined) material.iridescenceMap = getTexture(json.iridescenceMap);
		if (json.iridescenceThicknessMap !== undefined) material.iridescenceThicknessMap = getTexture(json.iridescenceThicknessMap);
		if (json.transmissionMap !== undefined) material.transmissionMap = getTexture(json.transmissionMap);
		if (json.thicknessMap !== undefined) material.thicknessMap = getTexture(json.thicknessMap);
		if (json.sheenColorMap !== undefined) material.sheenColorMap = getTexture(json.sheenColorMap);
		if (json.sheenRoughnessMap !== undefined) material.sheenRoughnessMap = getTexture(json.sheenRoughnessMap);
		return material;
	}
	setTextures(value) {
		this.textures = value;
		return this;
	}
	static createMaterialFromType(type) {
		const materialLib = {
			ShadowMaterial,
			SpriteMaterial,
			RawShaderMaterial,
			ShaderMaterial,
			PointsMaterial,
			MeshPhysicalMaterial,
			MeshStandardMaterial,
			MeshPhongMaterial,
			MeshToonMaterial,
			MeshNormalMaterial,
			MeshLambertMaterial,
			MeshDepthMaterial,
			MeshDistanceMaterial,
			MeshBasicMaterial,
			MeshMatcapMaterial,
			LineDashedMaterial,
			LineBasicMaterial,
			Material
		};
		return new materialLib[type]();
	}
}

class LoaderUtils {
	static decodeText(array) {
		if (typeof TextDecoder !== 'undefined') {
			return new TextDecoder().decode(array);
		}

		// Avoid the String.fromCharCode.apply(null, array) shortcut, which
		// throws a "maximum call stack size exceeded" error for large arrays.

		let s = '';
		for (let i = 0, il = array.length; i < il; i++) {
			// Implicitly assumes little-endian.
			s += String.fromCharCode(array[i]);
		}
		try {
			// merges multi-byte utf-8 characters.

			return decodeURIComponent(escape(s));
		} catch (e) {
			// see #16358

			return s;
		}
	}
	static extractUrlBase(url) {
		const index = url.lastIndexOf('/');
		if (index === -1) return './';
		return url.slice(0, index + 1);
	}
	static resolveURL(url, path) {
		// Invalid URL
		if (typeof url !== 'string' || url === '') return '';

		// Host Relative URL
		if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
			path = path.replace(/(^https?:\/\/[^\/]+).*/i, '$1');
		}

		// Absolute URL http://,https://,//
		if (/^(https?:)?\/\//i.test(url)) return url;

		// Data URI
		if (/^data:.*,.*$/i.test(url)) return url;

		// Blob URL
		if (/^blob:.*$/i.test(url)) return url;

		// Relative URL
		return path + url;
	}
}

class InstancedBufferGeometry extends BufferGeometry {
	constructor() {
		super();
		this.isInstancedBufferGeometry = true;
		this.type = 'InstancedBufferGeometry';
		this.instanceCount = Infinity;
	}
	copy(source) {
		super.copy(source);
		this.instanceCount = source.instanceCount;
		return this;
	}
	clone() {
		return new this.constructor().copy(this);
	}
	toJSON() {
		const data = super.toJSON(this);
		data.instanceCount = this.instanceCount;
		data.isInstancedBufferGeometry = true;
		return data;
	}
}

class BufferGeometryLoader extends Loader {
	constructor(manager) {
		super(manager);
	}
	load(url, onLoad, onProgress, onError) {
		const scope = this;
		const loader = new FileLoader(scope.manager);
		loader.setPath(scope.path);
		loader.setRequestHeader(scope.requestHeader);
		loader.setWithCredentials(scope.withCredentials);
		loader.load(url, function (text) {
			try {
				onLoad(scope.parse(JSON.parse(text)));
			} catch (e) {
				if (onError) {
					onError(e);
				} else {
					console.error(e);
				}
				scope.manager.itemError(url);
			}
		}, onProgress, onError);
	}
	parse(json) {
		const interleavedBufferMap = {};
		const arrayBufferMap = {};
		function getInterleavedBuffer(json, uuid) {
			if (interleavedBufferMap[uuid] !== undefined) return interleavedBufferMap[uuid];
			const interleavedBuffers = json.interleavedBuffers;
			const interleavedBuffer = interleavedBuffers[uuid];
			const buffer = getArrayBuffer(json, interleavedBuffer.buffer);
			const array = getTypedArray(interleavedBuffer.type, buffer);
			const ib = new InterleavedBuffer(array, interleavedBuffer.stride);
			ib.uuid = interleavedBuffer.uuid;
			interleavedBufferMap[uuid] = ib;
			return ib;
		}
		function getArrayBuffer(json, uuid) {
			if (arrayBufferMap[uuid] !== undefined) return arrayBufferMap[uuid];
			const arrayBuffers = json.arrayBuffers;
			const arrayBuffer = arrayBuffers[uuid];
			const ab = new Uint32Array(arrayBuffer).buffer;
			arrayBufferMap[uuid] = ab;
			return ab;
		}
		const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
		const index = json.data.index;
		if (index !== undefined) {
			const typedArray = getTypedArray(index.type, index.array);
			geometry.setIndex(new BufferAttribute(typedArray, 1));
		}
		const attributes = json.data.attributes;
		for (const key in attributes) {
			const attribute = attributes[key];
			let bufferAttribute;
			if (attribute.isInterleavedBufferAttribute) {
				const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
				bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
			} else {
				const typedArray = getTypedArray(attribute.type, attribute.array);
				const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
				bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);
			}
			if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
			if (attribute.usage !== undefined) bufferAttribute.setUsage(attribute.usage);
			if (attribute.updateRange !== undefined) {
				bufferAttribute.updateRange.offset = attribute.updateRange.offset;
				bufferAttribute.updateRange.count = attribute.updateRange.count;
			}
			geometry.setAttribute(key, bufferAttribute);
		}
		const morphAttributes = json.data.morphAttributes;
		if (morphAttributes) {
			for (const key in morphAttributes) {
				const attributeArray = morphAttributes[key];
				const array = [];
				for (let i = 0, il = attributeArray.length; i < il; i++) {
					const attribute = attributeArray[i];
					let bufferAttribute;
					if (attribute.isInterleavedBufferAttribute) {
						const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
						bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
					} else {
						const typedArray = getTypedArray(attribute.type, attribute.array);
						bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);
					}
					if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
					array.push(bufferAttribute);
				}
				geometry.morphAttributes[key] = array;
			}
		}
		const morphTargetsRelative = json.data.morphTargetsRelative;
		if (morphTargetsRelative) {
			geometry.morphTargetsRelative = true;
		}
		const groups = json.data.groups || json.data.drawcalls || json.data.offsets;
		if (groups !== undefined) {
			for (let i = 0, n = groups.length; i !== n; ++i) {
				const group = groups[i];
				geometry.addGroup(group.start, group.count, group.materialIndex);
			}
		}
		const boundingSphere = json.data.boundingSphere;
		if (boundingSphere !== undefined) {
			const center = new Vector3();
			if (boundingSphere.center !== undefined) {
				center.fromArray(boundingSphere.center);
			}
			geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
		}
		if (json.name) geometry.name = json.name;
		if (json.userData) geometry.userData = json.userData;
		return geometry;
	}
}

class ObjectLoader extends Loader {
	constructor(manager) {
		super(manager);
	}
	load(url, onLoad, onProgress, onError) {
		const scope = this;
		const path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;
		this.resourcePath = this.resourcePath || path;
		const loader = new FileLoader(this.manager);
		loader.setPath(this.path);
		loader.setRequestHeader(this.requestHeader);
		loader.setWithCredentials(this.withCredentials);
		loader.load(url, function (text) {
			let json = null;
			try {
				json = JSON.parse(text);
			} catch (error) {
				if (onError !== undefined) onError(error);
				console.error('THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message);
				return;
			}
			const metadata = json.metadata;
			if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {
				console.error('THREE.ObjectLoader: Can\'t load ' + url);
				return;
			}
			scope.parse(json, onLoad);
		}, onProgress, onError);
	}
	async loadAsync(url, onProgress) {
		const scope = this;
		const path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;
		this.resourcePath = this.resourcePath || path;
		const loader = new FileLoader(this.manager);
		loader.setPath(this.path);
		loader.setRequestHeader(this.requestHeader);
		loader.setWithCredentials(this.withCredentials);
		const text = await loader.loadAsync(url, onProgress);
		const json = JSON.parse(text);
		const metadata = json.metadata;
		if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {
			throw new Error('THREE.ObjectLoader: Can\'t load ' + url);
		}
		return await scope.parseAsync(json);
	}
	parse(json, onLoad) {
		const animations = this.parseAnimations(json.animations);
		const shapes = this.parseShapes(json.shapes);
		const geometries = this.parseGeometries(json.geometries, shapes);
		const images = this.parseImages(json.images, function () {
			if (onLoad !== undefined) onLoad(object);
		});
		const textures = this.parseTextures(json.textures, images);
		const materials = this.parseMaterials(json.materials, textures);
		const object = this.parseObject(json.object, geometries, materials, textures, animations);
		const skeletons = this.parseSkeletons(json.skeletons, object);
		this.bindSkeletons(object, skeletons);

		//

		if (onLoad !== undefined) {
			let hasImages = false;
			for (const uuid in images) {
				if (images[uuid].data instanceof HTMLImageElement) {
					hasImages = true;
					break;
				}
			}
			if (hasImages === false) onLoad(object);
		}
		return object;
	}
	async parseAsync(json) {
		const animations = this.parseAnimations(json.animations);
		const shapes = this.parseShapes(json.shapes);
		const geometries = this.parseGeometries(json.geometries, shapes);
		const images = await this.parseImagesAsync(json.images);
		const textures = this.parseTextures(json.textures, images);
		const materials = this.parseMaterials(json.materials, textures);
		const object = this.parseObject(json.object, geometries, materials, textures, animations);
		const skeletons = this.parseSkeletons(json.skeletons, object);
		this.bindSkeletons(object, skeletons);
		return object;
	}
	parseShapes(json) {
		const shapes = {};
		if (json !== undefined) {
			for (let i = 0, l = json.length; i < l; i++) {
				const shape = new Shape().fromJSON(json[i]);
				shapes[shape.uuid] = shape;
			}
		}
		return shapes;
	}
	parseSkeletons(json, object) {
		const skeletons = {};
		const bones = {};

		// generate bone lookup table

		object.traverse(function (child) {
			if (child.isBone) bones[child.uuid] = child;
		});

		// create skeletons

		if (json !== undefined) {
			for (let i = 0, l = json.length; i < l; i++) {
				const skeleton = new Skeleton().fromJSON(json[i], bones);
				skeletons[skeleton.uuid] = skeleton;
			}
		}
		return skeletons;
	}
	parseGeometries(json, shapes) {
		const geometries = {};
		if (json !== undefined) {
			const bufferGeometryLoader = new BufferGeometryLoader();
			for (let i = 0, l = json.length; i < l; i++) {
				let geometry;
				const data = json[i];
				switch (data.type) {
					case 'BufferGeometry':
					case 'InstancedBufferGeometry':
						geometry = bufferGeometryLoader.parse(data);
						break;
					default:
						if (data.type in Geometries) {
							geometry = Geometries[data.type].fromJSON(data, shapes);
						} else {
							console.warn(`THREE.ObjectLoader: Unsupported geometry type "${data.type}"`);
						}
				}
				geometry.uuid = data.uuid;
				if (data.name !== undefined) geometry.name = data.name;
				if (geometry.isBufferGeometry === true && data.userData !== undefined) geometry.userData = data.userData;
				geometries[data.uuid] = geometry;
			}
		}
		return geometries;
	}
	parseMaterials(json, textures) {
		const cache = {}; // MultiMaterial
		const materials = {};
		if (json !== undefined) {
			const loader = new MaterialLoader();
			loader.setTextures(textures);
			for (let i = 0, l = json.length; i < l; i++) {
				const data = json[i];
				if (cache[data.uuid] === undefined) {
					cache[data.uuid] = loader.parse(data);
				}
				materials[data.uuid] = cache[data.uuid];
			}
		}
		return materials;
	}
	parseAnimations(json) {
		const animations = {};
		if (json !== undefined) {
			for (let i = 0; i < json.length; i++) {
				const data = json[i];
				const clip = AnimationClip.parse(data);
				animations[clip.uuid] = clip;
			}
		}
		return animations;
	}
	parseImages(json, onLoad) {
		const scope = this;
		const images = {};
		let loader;
		function loadImage(url) {
			scope.manager.itemStart(url);
			return loader.load(url, function () {
				scope.manager.itemEnd(url);
			}, undefined, function () {
				scope.manager.itemError(url);
				scope.manager.itemEnd(url);
			});
		}
		function deserializeImage(image) {
			if (typeof image === 'string') {
				const url = image;
				const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
				return loadImage(path);
			} else {
				if (image.data) {
					return {
						data: getTypedArray(image.type, image.data),
						width: image.width,
						height: image.height
					};
				} else {
					return null;
				}
			}
		}
		if (json !== undefined && json.length > 0) {
			const manager = new LoadingManager(onLoad);
			loader = new ImageLoader(manager);
			loader.setCrossOrigin(this.crossOrigin);
			for (let i = 0, il = json.length; i < il; i++) {
				const image = json[i];
				const url = image.url;
				if (Array.isArray(url)) {
					// load array of images e.g CubeTexture

					const imageArray = [];
					for (let j = 0, jl = url.length; j < jl; j++) {
						const currentUrl = url[j];
						const deserializedImage = deserializeImage(currentUrl);
						if (deserializedImage !== null) {
							if (deserializedImage instanceof HTMLImageElement) {
								imageArray.push(deserializedImage);
							} else {
								// special case: handle array of data textures for cube textures

								imageArray.push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
							}
						}
					}
					images[image.uuid] = new Source(imageArray);
				} else {
					// load single image

					const deserializedImage = deserializeImage(image.url);
					images[image.uuid] = new Source(deserializedImage);
				}
			}
		}
		return images;
	}
	async parseImagesAsync(json) {
		const scope = this;
		const images = {};
		let loader;
		async function deserializeImage(image) {
			if (typeof image === 'string') {
				const url = image;
				const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
				return await loader.loadAsync(path);
			} else {
				if (image.data) {
					return {
						data: getTypedArray(image.type, image.data),
						width: image.width,
						height: image.height
					};
				} else {
					return null;
				}
			}
		}
		if (json !== undefined && json.length > 0) {
			loader = new ImageLoader(this.manager);
			loader.setCrossOrigin(this.crossOrigin);
			for (let i = 0, il = json.length; i < il; i++) {
				const image = json[i];
				const url = image.url;
				if (Array.isArray(url)) {
					// load array of images e.g CubeTexture

					const imageArray = [];
					for (let j = 0, jl = url.length; j < jl; j++) {
						const currentUrl = url[j];
						const deserializedImage = await deserializeImage(currentUrl);
						if (deserializedImage !== null) {
							if (deserializedImage instanceof HTMLImageElement) {
								imageArray.push(deserializedImage);
							} else {
								// special case: handle array of data textures for cube textures

								imageArray.push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
							}
						}
					}
					images[image.uuid] = new Source(imageArray);
				} else {
					// load single image

					const deserializedImage = await deserializeImage(image.url);
					images[image.uuid] = new Source(deserializedImage);
				}
			}
		}
		return images;
	}
	parseTextures(json, images) {
		function parseConstant(value, type) {
			if (typeof value === 'number') return value;
			console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);
			return type[value];
		}
		const textures = {};
		if (json !== undefined) {
			for (let i = 0, l = json.length; i < l; i++) {
				const data = json[i];
				if (data.image === undefined) {
					console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
				}
				if (images[data.image] === undefined) {
					console.warn('THREE.ObjectLoader: Undefined image', data.image);
				}
				const source = images[data.image];
				const image = source.data;
				let texture;
				if (Array.isArray(image)) {
					texture = new CubeTexture();
					if (image.length === 6) texture.needsUpdate = true;
				} else {
					if (image && image.data) {
						texture = new DataTexture();
					} else {
						texture = new Texture();
					}
					if (image) texture.needsUpdate = true; // textures can have undefined image data
				}

				texture.source = source;
				texture.uuid = data.uuid;
				if (data.name !== undefined) texture.name = data.name;
				if (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
				if (data.offset !== undefined) texture.offset.fromArray(data.offset);
				if (data.repeat !== undefined) texture.repeat.fromArray(data.repeat);
				if (data.center !== undefined) texture.center.fromArray(data.center);
				if (data.rotation !== undefined) texture.rotation = data.rotation;
				if (data.wrap !== undefined) {
					texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
					texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
				}
				if (data.format !== undefined) texture.format = data.format;
				if (data.type !== undefined) texture.type = data.type;
				if (data.encoding !== undefined) texture.encoding = data.encoding;
				if (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
				if (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
				if (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;
				if (data.flipY !== undefined) texture.flipY = data.flipY;
				if (data.premultiplyAlpha !== undefined) texture.premultiplyAlpha = data.premultiplyAlpha;
				if (data.unpackAlignment !== undefined) texture.unpackAlignment = data.unpackAlignment;
				if (data.userData !== undefined) texture.userData = data.userData;
				textures[data.uuid] = texture;
			}
		}
		return textures;
	}
	parseObject(data, geometries, materials, textures, animations) {
		let object;
		function getGeometry(name) {
			if (geometries[name] === undefined) {
				console.warn('THREE.ObjectLoader: Undefined geometry', name);
			}
			return geometries[name];
		}
		function getMaterial(name) {
			if (name === undefined) return undefined;
			if (Array.isArray(name)) {
				const array = [];
				for (let i = 0, l = name.length; i < l; i++) {
					const uuid = name[i];
					if (materials[uuid] === undefined) {
						console.warn('THREE.ObjectLoader: Undefined material', uuid);
					}
					array.push(materials[uuid]);
				}
				return array;
			}
			if (materials[name] === undefined) {
				console.warn('THREE.ObjectLoader: Undefined material', name);
			}
			return materials[name];
		}
		function getTexture(uuid) {
			if (textures[uuid] === undefined) {
				console.warn('THREE.ObjectLoader: Undefined texture', uuid);
			}
			return textures[uuid];
		}
		let geometry, material;
		switch (data.type) {
			case 'Scene':
				object = new Scene();
				if (data.background !== undefined) {
					if (Number.isInteger(data.background)) {
						object.background = new Color(data.background);
					} else {
						object.background = getTexture(data.background);
					}
				}
				if (data.environment !== undefined) {
					object.environment = getTexture(data.environment);
				}
				if (data.fog !== undefined) {
					if (data.fog.type === 'Fog') {
						object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
					} else if (data.fog.type === 'FogExp2') {
						object.fog = new FogExp2(data.fog.color, data.fog.density);
					}
				}
				if (data.backgroundBlurriness !== undefined) object.backgroundBlurriness = data.backgroundBlurriness;
				break;
			case 'PerspectiveCamera':
				object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
				if (data.focus !== undefined) object.focus = data.focus;
				if (data.zoom !== undefined) object.zoom = data.zoom;
				if (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;
				if (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;
				if (data.view !== undefined) object.view = Object.assign({}, data.view);
				break;
			case 'OrthographicCamera':
				object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
				if (data.zoom !== undefined) object.zoom = data.zoom;
				if (data.view !== undefined) object.view = Object.assign({}, data.view);
				break;
			case 'AmbientLight':
				object = new AmbientLight(data.color, data.intensity);
				break;
			case 'DirectionalLight':
				object = new DirectionalLight(data.color, data.intensity);
				break;
			case 'PointLight':
				object = new PointLight(data.color, data.intensity, data.distance, data.decay);
				break;
			case 'RectAreaLight':
				object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
				break;
			case 'SpotLight':
				object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
				break;
			case 'HemisphereLight':
				object = new HemisphereLight(data.color, data.groundColor, data.intensity);
				break;
			case 'LightProbe':
				object = new LightProbe().fromJSON(data);
				break;
			case 'SkinnedMesh':
				geometry = getGeometry(data.geometry);
				material = getMaterial(data.material);
				object = new SkinnedMesh(geometry, material);
				if (data.bindMode !== undefined) object.bindMode = data.bindMode;
				if (data.bindMatrix !== undefined) object.bindMatrix.fromArray(data.bindMatrix);
				if (data.skeleton !== undefined) object.skeleton = data.skeleton;
				break;
			case 'Mesh':
				geometry = getGeometry(data.geometry);
				material = getMaterial(data.material);
				object = new Mesh(geometry, material);
				break;
			case 'InstancedMesh':
				geometry = getGeometry(data.geometry);
				material = getMaterial(data.material);
				const count = data.count;
				const instanceMatrix = data.instanceMatrix;
				const instanceColor = data.instanceColor;
				object = new InstancedMesh(geometry, material, count);
				object.instanceMatrix = new InstancedBufferAttribute(new Float32Array(instanceMatrix.array), 16);
				if (instanceColor !== undefined) object.instanceColor = new InstancedBufferAttribute(new Float32Array(instanceColor.array), instanceColor.itemSize);
				break;
			case 'LOD':
				object = new LOD();
				break;
			case 'Line':
				object = new Line(getGeometry(data.geometry), getMaterial(data.material));
				break;
			case 'LineLoop':
				object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
				break;
			case 'LineSegments':
				object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
				break;
			case 'PointCloud':
			case 'Points':
				object = new Points(getGeometry(data.geometry), getMaterial(data.material));
				break;
			case 'Sprite':
				object = new Sprite(getMaterial(data.material));
				break;
			case 'Group':
				object = new Group();
				break;
			case 'Bone':
				object = new Bone();
				break;
			default:
				object = new Object3D();
		}
		object.uuid = data.uuid;
		if (data.name !== undefined) object.name = data.name;
		if (data.matrix !== undefined) {
			object.matrix.fromArray(data.matrix);
			if (data.matrixAutoUpdate !== undefined) object.matrixAutoUpdate = data.matrixAutoUpdate;
			if (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale);
		} else {
			if (data.position !== undefined) object.position.fromArray(data.position);
			if (data.rotation !== undefined) object.rotation.fromArray(data.rotation);
			if (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion);
			if (data.scale !== undefined) object.scale.fromArray(data.scale);
		}
		if (data.castShadow !== undefined) object.castShadow = data.castShadow;
		if (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;
		if (data.shadow) {
			if (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias;
			if (data.shadow.normalBias !== undefined) object.shadow.normalBias = data.shadow.normalBias;
			if (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius;
			if (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize);
			if (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera);
		}
		if (data.visible !== undefined) object.visible = data.visible;
		if (data.frustumCulled !== undefined) object.frustumCulled = data.frustumCulled;
		if (data.renderOrder !== undefined) object.renderOrder = data.renderOrder;
		if (data.userData !== undefined) object.userData = data.userData;
		if (data.layers !== undefined) object.layers.mask = data.layers;
		if (data.children !== undefined) {
			const children = data.children;
			for (let i = 0; i < children.length; i++) {
				object.add(this.parseObject(children[i], geometries, materials, textures, animations));
			}
		}
		if (data.animations !== undefined) {
			const objectAnimations = data.animations;
			for (let i = 0; i < objectAnimations.length; i++) {
				const uuid = objectAnimations[i];
				object.animations.push(animations[uuid]);
			}
		}
		if (data.type === 'LOD') {
			if (data.autoUpdate !== undefined) object.autoUpdate = data.autoUpdate;
			const levels = data.levels;
			for (let l = 0; l < levels.length; l++) {
				const level = levels[l];
				const child = object.getObjectByProperty('uuid', level.object);
				if (child !== undefined) {
					object.addLevel(child, level.distance);
				}
			}
		}
		return object;
	}
	bindSkeletons(object, skeletons) {
		if (Object.keys(skeletons).length === 0) return;
		object.traverse(function (child) {
			if (child.isSkinnedMesh === true && child.skeleton !== undefined) {
				const skeleton = skeletons[child.skeleton];
				if (skeleton === undefined) {
					console.warn('THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton);
				} else {
					child.bind(skeleton, child.bindMatrix);
				}
			}
		});
	}
}
const TEXTURE_MAPPING = {
	UVMapping: UVMapping,
	CubeReflectionMapping: CubeReflectionMapping,
	CubeRefractionMapping: CubeRefractionMapping,
	EquirectangularReflectionMapping: EquirectangularReflectionMapping,
	EquirectangularRefractionMapping: EquirectangularRefractionMapping,
	CubeUVReflectionMapping: CubeUVReflectionMapping
};
const TEXTURE_WRAPPING = {
	RepeatWrapping: RepeatWrapping,
	ClampToEdgeWrapping: ClampToEdgeWrapping,
	MirroredRepeatWrapping: MirroredRepeatWrapping
};
const TEXTURE_FILTER = {
	NearestFilter: NearestFilter,
	NearestMipmapNearestFilter: NearestMipmapNearestFilter,
	NearestMipmapLinearFilter: NearestMipmapLinearFilter,
	LinearFilter: LinearFilter,
	LinearMipmapNearestFilter: LinearMipmapNearestFilter,
	LinearMipmapLinearFilter: LinearMipmapLinearFilter
};

class ImageBitmapLoader extends Loader {
	constructor(manager) {
		super(manager);
		this.isImageBitmapLoader = true;
		if (typeof createImageBitmap === 'undefined') {
			console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');
		}
		if (typeof fetch === 'undefined') {
			console.warn('THREE.ImageBitmapLoader: fetch() not supported.');
		}
		this.options = {
			premultiplyAlpha: 'none'
		};
	}
	setOptions(options) {
		this.options = options;
		return this;
	}
	load(url, onLoad, onProgress, onError) {
		if (url === undefined) url = '';
		if (this.path !== undefined) url = this.path + url;
		url = this.manager.resolveURL(url);
		const scope = this;
		const cached = Cache.get(url);
		if (cached !== undefined) {
			scope.manager.itemStart(url);
			setTimeout(function () {
				if (onLoad) onLoad(cached);
				scope.manager.itemEnd(url);
			}, 0);
			return cached;
		}
		const fetchOptions = {};
		fetchOptions.credentials = this.crossOrigin === 'anonymous' ? 'same-origin' : 'include';
		fetchOptions.headers = this.requestHeader;
		fetch(url, fetchOptions).then(function (res) {
			return res.blob();
		}).then(function (blob) {
			return createImageBitmap(blob, Object.assign(scope.options, {
				colorSpaceConversion: 'none'
			}));
		}).then(function (imageBitmap) {
			Cache.add(url, imageBitmap);
			if (onLoad) onLoad(imageBitmap);
			scope.manager.itemEnd(url);
		}).catch(function (e) {
			if (onError) onError(e);
			scope.manager.itemError(url);
			scope.manager.itemEnd(url);
		});
		scope.manager.itemStart(url);
	}
}

let _context;
class AudioContext {
	static getContext() {
		if (_context === undefined) {
			_context = new (window.AudioContext || window.webkitAudioContext)();
		}
		return _context;
	}
	static setContext(value) {
		_context = value;
	}
}

class AudioLoader extends Loader {
	constructor(manager) {
		super(manager);
	}
	load(url, onLoad, onProgress, onError) {
		const scope = this;
		const loader = new FileLoader(this.manager);
		loader.setResponseType('arraybuffer');
		loader.setPath(this.path);
		loader.setRequestHeader(this.requestHeader);
		loader.setWithCredentials(this.withCredentials);
		loader.load(url, function (buffer) {
			try {
				// Create a copy of the buffer. The `decodeAudioData` method
				// detaches the buffer when complete, preventing reuse.
				const bufferCopy = buffer.slice(0);
				const context = AudioContext.getContext();
				context.decodeAudioData(bufferCopy, function (audioBuffer) {
					onLoad(audioBuffer);
				});
			} catch (e) {
				if (onError) {
					onError(e);
				} else {
					console.error(e);
				}
				scope.manager.itemError(url);
			}
		}, onProgress, onError);
	}
}

class HemisphereLightProbe extends LightProbe {
	constructor(skyColor, groundColor, intensity = 1) {
		super(undefined, intensity);
		this.isHemisphereLightProbe = true;
		const color1 = new Color().set(skyColor);
		const color2 = new Color().set(groundColor);
		const sky = new Vector3(color1.r, color1.g, color1.b);
		const ground = new Vector3(color2.r, color2.g, color2.b);

		// without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );
		const c0 = Math.sqrt(Math.PI);
		const c1 = c0 * Math.sqrt(0.75);
		this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
		this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
	}
}

class AmbientLightProbe extends LightProbe {
	constructor(color, intensity = 1) {
		super(undefined, intensity);
		this.isAmbientLightProbe = true;
		const color1 = new Color().set(color);

		// without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );
		this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
	}
}

const _eyeRight = /*@__PURE__*/new Matrix4();
const _eyeLeft = /*@__PURE__*/new Matrix4();
const _projectionMatrix = /*@__PURE__*/new Matrix4();
class StereoCamera {
	constructor() {
		this.type = 'StereoCamera';
		this.aspect = 1;
		this.eyeSep = 0.064;
		this.cameraL = new PerspectiveCamera();
		this.cameraL.layers.enable(1);
		this.cameraL.matrixAutoUpdate = false;
		this.cameraR = new PerspectiveCamera();
		this.cameraR.layers.enable(2);
		this.cameraR.matrixAutoUpdate = false;
		this._cache = {
			focus: null,
			fov: null,
			aspect: null,
			near: null,
			far: null,
			zoom: null,
			eyeSep: null
		};
	}
	update(camera) {
		const cache = this._cache;
		const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;
		if (needsUpdate) {
			cache.focus = camera.focus;
			cache.fov = camera.fov;
			cache.aspect = camera.aspect * this.aspect;
			cache.near = camera.near;
			cache.far = camera.far;
			cache.zoom = camera.zoom;
			cache.eyeSep = this.eyeSep;

			// Off-axis stereoscopic effect based on
			// http://paulbourke.net/stereographics/stereorender/

			_projectionMatrix.copy(camera.projectionMatrix);
			const eyeSepHalf = cache.eyeSep / 2;
			const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
			const ymax = cache.near * Math.tan(DEG2RAD * cache.fov * 0.5) / cache.zoom;
			let xmin, xmax;

			// translate xOffset

			_eyeLeft.elements[12] = -eyeSepHalf;
			_eyeRight.elements[12] = eyeSepHalf;

			// for left eye

			xmin = -ymax * cache.aspect + eyeSepOnProjection;
			xmax = ymax * cache.aspect + eyeSepOnProjection;
			_projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
			_projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
			this.cameraL.projectionMatrix.copy(_projectionMatrix);

			// for right eye

			xmin = -ymax * cache.aspect - eyeSepOnProjection;
			xmax = ymax * cache.aspect - eyeSepOnProjection;
			_projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
			_projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
			this.cameraR.projectionMatrix.copy(_projectionMatrix);
		}
		this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
		this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
	}
}

class Clock {
	constructor(autoStart = true) {
		this.autoStart = autoStart;
		this.startTime = 0;
		this.oldTime = 0;
		this.elapsedTime = 0;
		this.running = false;
	}
	start() {
		this.startTime = now();
		this.oldTime = this.startTime;
		this.elapsedTime = 0;
		this.running = true;
	}
	stop() {
		this.getElapsedTime();
		this.running = false;
		this.autoStart = false;
	}
	getElapsedTime() {
		this.getDelta();
		return this.elapsedTime;
	}
	getDelta() {
		let diff = 0;
		if (this.autoStart && !this.running) {
			this.start();
			return 0;
		}
		if (this.running) {
			const newTime = now();
			diff = (newTime - this.oldTime) / 1000;
			this.oldTime = newTime;
			this.elapsedTime += diff;
		}
		return diff;
	}
}
function now() {
	return (typeof performance === 'undefined' ? Date : performance).now(); // see #10732
}

const _position$1 = /*@__PURE__*/new Vector3();
const _quaternion$1 = /*@__PURE__*/new Quaternion();
const _scale$1 = /*@__PURE__*/new Vector3();
const _orientation$1 = /*@__PURE__*/new Vector3();
class AudioListener extends Object3D {
	constructor() {
		super();
		this.type = 'AudioListener';
		this.context = AudioContext.getContext();
		this.gain = this.context.createGain();
		this.gain.connect(this.context.destination);
		this.filter = null;
		this.timeDelta = 0;

		// private

		this._clock = new Clock();
	}
	getInput() {
		return this.gain;
	}
	removeFilter() {
		if (this.filter !== null) {
			this.gain.disconnect(this.filter);
			this.filter.disconnect(this.context.destination);
			this.gain.connect(this.context.destination);
			this.filter = null;
		}
		return this;
	}
	getFilter() {
		return this.filter;
	}
	setFilter(value) {
		if (this.filter !== null) {
			this.gain.disconnect(this.filter);
			this.filter.disconnect(this.context.destination);
		} else {
			this.gain.disconnect(this.context.destination);
		}
		this.filter = value;
		this.gain.connect(this.filter);
		this.filter.connect(this.context.destination);
		return this;
	}
	getMasterVolume() {
		return this.gain.gain.value;
	}
	setMasterVolume(value) {
		this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
		return this;
	}
	updateMatrixWorld(force) {
		super.updateMatrixWorld(force);
		const listener = this.context.listener;
		const up = this.up;
		this.timeDelta = this._clock.getDelta();
		this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1);
		_orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1);
		if (listener.positionX) {
			// code path for Chrome (see #14393)

			const endTime = this.context.currentTime + this.timeDelta;
			listener.positionX.linearRampToValueAtTime(_position$1.x, endTime);
			listener.positionY.linearRampToValueAtTime(_position$1.y, endTime);
			listener.positionZ.linearRampToValueAtTime(_position$1.z, endTime);
			listener.forwardX.linearRampToValueAtTime(_orientation$1.x, endTime);
			listener.forwardY.linearRampToValueAtTime(_orientation$1.y, endTime);
			listener.forwardZ.linearRampToValueAtTime(_orientation$1.z, endTime);
			listener.upX.linearRampToValueAtTime(up.x, endTime);
			listener.upY.linearRampToValueAtTime(up.y, endTime);
			listener.upZ.linearRampToValueAtTime(up.z, endTime);
		} else {
			listener.setPosition(_position$1.x, _position$1.y, _position$1.z);
			listener.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z);
		}
	}
}

class Audio extends Object3D {
	constructor(listener) {
		super();
		this.type = 'Audio';
		this.listener = listener;
		this.context = listener.context;
		this.gain = this.context.createGain();
		this.gain.connect(listener.getInput());
		this.autoplay = false;
		this.buffer = null;
		this.detune = 0;
		this.loop = false;
		this.loopStart = 0;
		this.loopEnd = 0;
		this.offset = 0;
		this.duration = undefined;
		this.playbackRate = 1;
		this.isPlaying = false;
		this.hasPlaybackControl = true;
		this.source = null;
		this.sourceType = 'empty';
		this._startedAt = 0;
		this._progress = 0;
		this._connected = false;
		this.filters = [];
	}
	getOutput() {
		return this.gain;
	}
	setNodeSource(audioNode) {
		this.hasPlaybackControl = false;
		this.sourceType = 'audioNode';
		this.source = audioNode;
		this.connect();
		return this;
	}
	setMediaElementSource(mediaElement) {
		this.hasPlaybackControl = false;
		this.sourceType = 'mediaNode';
		this.source = this.context.createMediaElementSource(mediaElement);
		this.connect();
		return this;
	}
	setMediaStreamSource(mediaStream) {
		this.hasPlaybackControl = false;
		this.sourceType = 'mediaStreamNode';
		this.source = this.context.createMediaStreamSource(mediaStream);
		this.connect();
		return this;
	}
	setBuffer(audioBuffer) {
		this.buffer = audioBuffer;
		this.sourceType = 'buffer';
		if (this.autoplay) this.play();
		return this;
	}
	play(delay = 0) {
		if (this.isPlaying === true) {
			console.warn('THREE.Audio: Audio is already playing.');
			return;
		}
		if (this.hasPlaybackControl === false) {
			console.warn('THREE.Audio: this Audio has no playback control.');
			return;
		}
		this._startedAt = this.context.currentTime + delay;
		const source = this.context.createBufferSource();
		source.buffer = this.buffer;
		source.loop = this.loop;
		source.loopStart = this.loopStart;
		source.loopEnd = this.loopEnd;
		source.onended = this.onEnded.bind(this);
		source.start(this._startedAt, this._progress + this.offset, this.duration);
		this.isPlaying = true;
		this.source = source;
		this.setDetune(this.detune);
		this.setPlaybackRate(this.playbackRate);
		return this.connect();
	}
	pause() {
		if (this.hasPlaybackControl === false) {
			console.warn('THREE.Audio: this Audio has no playback control.');
			return;
		}
		if (this.isPlaying === true) {
			// update current progress

			this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
			if (this.loop === true) {
				// ensure _progress does not exceed duration with looped audios

				this._progress = this._progress % (this.duration || this.buffer.duration);
			}
			this.source.stop();
			this.source.onended = null;
			this.isPlaying = false;
		}
		return this;
	}
	stop() {
		if (this.hasPlaybackControl === false) {
			console.warn('THREE.Audio: this Audio has no playback control.');
			return;
		}
		this._progress = 0;
		this.source.stop();
		this.source.onended = null;
		this.isPlaying = false;
		return this;
	}
	connect() {
		if (this.filters.length > 0) {
			this.source.connect(this.filters[0]);
			for (let i = 1, l = this.filters.length; i < l; i++) {
				this.filters[i - 1].connect(this.filters[i]);
			}
			this.filters[this.filters.length - 1].connect(this.getOutput());
		} else {
			this.source.connect(this.getOutput());
		}
		this._connected = true;
		return this;
	}
	disconnect() {
		if (this.filters.length > 0) {
			this.source.disconnect(this.filters[0]);
			for (let i = 1, l = this.filters.length; i < l; i++) {
				this.filters[i - 1].disconnect(this.filters[i]);
			}
			this.filters[this.filters.length - 1].disconnect(this.getOutput());
		} else {
			this.source.disconnect(this.getOutput());
		}
		this._connected = false;
		return this;
	}
	getFilters() {
		return this.filters;
	}
	setFilters(value) {
		if (!value) value = [];
		if (this._connected === true) {
			this.disconnect();
			this.filters = value.slice();
			this.connect();
		} else {
			this.filters = value.slice();
		}
		return this;
	}
	setDetune(value) {
		this.detune = value;
		if (this.source.detune === undefined) return; // only set detune when available

		if (this.isPlaying === true) {
			this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
		}
		return this;
	}
	getDetune() {
		return this.detune;
	}
	getFilter() {
		return this.getFilters()[0];
	}
	setFilter(filter) {
		return this.setFilters(filter ? [filter] : []);
	}
	setPlaybackRate(value) {
		if (this.hasPlaybackControl === false) {
			console.warn('THREE.Audio: this Audio has no playback control.');
			return;
		}
		this.playbackRate = value;
		if (this.isPlaying === true) {
			this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
		}
		return this;
	}
	getPlaybackRate() {
		return this.playbackRate;
	}
	onEnded() {
		this.isPlaying = false;
	}
	getLoop() {
		if (this.hasPlaybackControl === false) {
			console.warn('THREE.Audio: this Audio has no playback control.');
			return false;
		}
		return this.loop;
	}
	setLoop(value) {
		if (this.hasPlaybackControl === false) {
			console.warn('THREE.Audio: this Audio has no playback control.');
			return;
		}
		this.loop = value;
		if (this.isPlaying === true) {
			this.source.loop = this.loop;
		}
		return this;
	}
	setLoopStart(value) {
		this.loopStart = value;
		return this;
	}
	setLoopEnd(value) {
		this.loopEnd = value;
		return this;
	}
	getVolume() {
		return this.gain.gain.value;
	}
	setVolume(value) {
		this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
		return this;
	}
}

const _position = /*@__PURE__*/new Vector3();
const _quaternion = /*@__PURE__*/new Quaternion();
const _scale = /*@__PURE__*/new Vector3();
const _orientation = /*@__PURE__*/new Vector3();
class PositionalAudio extends Audio {
	constructor(listener) {
		super(listener);
		this.panner = this.context.createPanner();
		this.panner.panningModel = 'HRTF';
		this.panner.connect(this.gain);
	}
	disconnect() {
		super.disconnect();
		this.panner.disconnect(this.gain);
	}
	getOutput() {
		return this.panner;
	}
	getRefDistance() {
		return this.panner.refDistance;
	}
	setRefDistance(value) {
		this.panner.refDistance = value;
		return this;
	}
	getRolloffFactor() {
		return this.panner.rolloffFactor;
	}
	setRolloffFactor(value) {
		this.panner.rolloffFactor = value;
		return this;
	}
	getDistanceModel() {
		return this.panner.distanceModel;
	}
	setDistanceModel(value) {
		this.panner.distanceModel = value;
		return this;
	}
	getMaxDistance() {
		return this.panner.maxDistance;
	}
	setMaxDistance(value) {
		this.panner.maxDistance = value;
		return this;
	}
	setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
		this.panner.coneInnerAngle = coneInnerAngle;
		this.panner.coneOuterAngle = coneOuterAngle;
		this.panner.coneOuterGain = coneOuterGain;
		return this;
	}
	updateMatrixWorld(force) {
		super.updateMatrixWorld(force);
		if (this.hasPlaybackControl === true && this.isPlaying === false) return;
		this.matrixWorld.decompose(_position, _quaternion, _scale);
		_orientation.set(0, 0, 1).applyQuaternion(_quaternion);
		const panner = this.panner;
		if (panner.positionX) {
			// code path for Chrome and Firefox (see #14393)

			const endTime = this.context.currentTime + this.listener.timeDelta;
			panner.positionX.linearRampToValueAtTime(_position.x, endTime);
			panner.positionY.linearRampToValueAtTime(_position.y, endTime);
			panner.positionZ.linearRampToValueAtTime(_position.z, endTime);
			panner.orientationX.linearRampToValueAtTime(_orientation.x, endTime);
			panner.orientationY.linearRampToValueAtTime(_orientation.y, endTime);
			panner.orientationZ.linearRampToValueAtTime(_orientation.z, endTime);
		} else {
			panner.setPosition(_position.x, _position.y, _position.z);
			panner.setOrientation(_orientation.x, _orientation.y, _orientation.z);
		}
	}
}

class AudioAnalyser {
	constructor(audio, fftSize = 2048) {
		this.analyser = audio.context.createAnalyser();
		this.analyser.fftSize = fftSize;
		this.data = new Uint8Array(this.analyser.frequencyBinCount);
		audio.getOutput().connect(this.analyser);
	}
	getFrequencyData() {
		this.analyser.getByteFrequencyData(this.data);
		return this.data;
	}
	getAverageFrequency() {
		let value = 0;
		const data = this.getFrequencyData();
		for (let i = 0; i < data.length; i++) {
			value += data[i];
		}
		return value / data.length;
	}
}

class PropertyMixer {
	constructor(binding, typeName, valueSize) {
		this.binding = binding;
		this.valueSize = valueSize;
		let mixFunction, mixFunctionAdditive, setIdentity;

		// buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
		//
		// interpolators can use .buffer as their .result
		// the data then goes to 'incoming'
		//
		// 'accu0' and 'accu1' are used frame-interleaved for
		// the cumulative result and are compared to detect
		// changes
		//
		// 'orig' stores the original state of the property
		//
		// 'add' is used for additive cumulative results
		//
		// 'work' is optional and is only present for quaternion types. It is used
		// to store intermediate quaternion multiplication results

		switch (typeName) {
			case 'quaternion':
				mixFunction = this._slerp;
				mixFunctionAdditive = this._slerpAdditive;
				setIdentity = this._setAdditiveIdentityQuaternion;
				this.buffer = new Float64Array(valueSize * 6);
				this._workIndex = 5;
				break;
			case 'string':
			case 'bool':
				mixFunction = this._select;

				// Use the regular mix function and for additive on these types,
				// additive is not relevant for non-numeric types
				mixFunctionAdditive = this._select;
				setIdentity = this._setAdditiveIdentityOther;
				this.buffer = new Array(valueSize * 5);
				break;
			default:
				mixFunction = this._lerp;
				mixFunctionAdditive = this._lerpAdditive;
				setIdentity = this._setAdditiveIdentityNumeric;
				this.buffer = new Float64Array(valueSize * 5);
		}
		this._mixBufferRegion = mixFunction;
		this._mixBufferRegionAdditive = mixFunctionAdditive;
		this._setIdentity = setIdentity;
		this._origIndex = 3;
		this._addIndex = 4;
		this.cumulativeWeight = 0;
		this.cumulativeWeightAdditive = 0;
		this.useCount = 0;
		this.referenceCount = 0;
	}

	// accumulate data in the 'incoming' region into 'accu<i>'
	accumulate(accuIndex, weight) {
		// note: happily accumulating nothing when weight = 0, the caller knows
		// the weight and shouldn't have made the call in the first place

		const buffer = this.buffer,
			stride = this.valueSize,
			offset = accuIndex * stride + stride;
		let currentWeight = this.cumulativeWeight;
		if (currentWeight === 0) {
			// accuN := incoming * weight

			for (let i = 0; i !== stride; ++i) {
				buffer[offset + i] = buffer[i];
			}
			currentWeight = weight;
		} else {
			// accuN := accuN + incoming * weight

			currentWeight += weight;
			const mix = weight / currentWeight;
			this._mixBufferRegion(buffer, offset, 0, mix, stride);
		}
		this.cumulativeWeight = currentWeight;
	}

	// accumulate data in the 'incoming' region into 'add'
	accumulateAdditive(weight) {
		const buffer = this.buffer,
			stride = this.valueSize,
			offset = stride * this._addIndex;
		if (this.cumulativeWeightAdditive === 0) {
			// add = identity

			this._setIdentity();
		}

		// add := add + incoming * weight

		this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
		this.cumulativeWeightAdditive += weight;
	}

	// apply the state of 'accu<i>' to the binding when accus differ
	apply(accuIndex) {
		const stride = this.valueSize,
			buffer = this.buffer,
			offset = accuIndex * stride + stride,
			weight = this.cumulativeWeight,
			weightAdditive = this.cumulativeWeightAdditive,
			binding = this.binding;
		this.cumulativeWeight = 0;
		this.cumulativeWeightAdditive = 0;
		if (weight < 1) {
			// accuN := accuN + original * ( 1 - cumulativeWeight )

			const originalValueOffset = stride * this._origIndex;
			this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
		}
		if (weightAdditive > 0) {
			// accuN := accuN + additive accuN

			this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
		}
		for (let i = stride, e = stride + stride; i !== e; ++i) {
			if (buffer[i] !== buffer[i + stride]) {
				// value has changed -> update scene graph

				binding.setValue(buffer, offset);
				break;
			}
		}
	}

	// remember the state of the bound property and copy it to both accus
	saveOriginalState() {
		const binding = this.binding;
		const buffer = this.buffer,
			stride = this.valueSize,
			originalValueOffset = stride * this._origIndex;
		binding.getValue(buffer, originalValueOffset);

		// accu[0..1] := orig -- initially detect changes against the original
		for (let i = stride, e = originalValueOffset; i !== e; ++i) {
			buffer[i] = buffer[originalValueOffset + i % stride];
		}

		// Add to identity for additive
		this._setIdentity();
		this.cumulativeWeight = 0;
		this.cumulativeWeightAdditive = 0;
	}

	// apply the state previously taken via 'saveOriginalState' to the binding
	restoreOriginalState() {
		const originalValueOffset = this.valueSize * 3;
		this.binding.setValue(this.buffer, originalValueOffset);
	}
	_setAdditiveIdentityNumeric() {
		const startIndex = this._addIndex * this.valueSize;
		const endIndex = startIndex + this.valueSize;
		for (let i = startIndex; i < endIndex; i++) {
			this.buffer[i] = 0;
		}
	}
	_setAdditiveIdentityQuaternion() {
		this._setAdditiveIdentityNumeric();
		this.buffer[this._addIndex * this.valueSize + 3] = 1;
	}
	_setAdditiveIdentityOther() {
		const startIndex = this._origIndex * this.valueSize;
		const targetIndex = this._addIndex * this.valueSize;
		for (let i = 0; i < this.valueSize; i++) {
			this.buffer[targetIndex + i] = this.buffer[startIndex + i];
		}
	}

	// mix functions

	_select(buffer, dstOffset, srcOffset, t, stride) {
		if (t >= 0.5) {
			for (let i = 0; i !== stride; ++i) {
				buffer[dstOffset + i] = buffer[srcOffset + i];
			}
		}
	}
	_slerp(buffer, dstOffset, srcOffset, t) {
		Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
	}
	_slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
		const workOffset = this._workIndex * stride;

		// Store result in intermediate buffer offset
		Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);

		// Slerp to the intermediate result
		Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);
	}
	_lerp(buffer, dstOffset, srcOffset, t, stride) {
		const s = 1 - t;
		for (let i = 0; i !== stride; ++i) {
			const j = dstOffset + i;
			buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
		}
	}
	_lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
		for (let i = 0; i !== stride; ++i) {
			const j = dstOffset + i;
			buffer[j] = buffer[j] + buffer[srcOffset + i] * t;
		}
	}
}

// Characters [].:/ are reserved for track binding syntax.
const _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
const _reservedRe = new RegExp('[' + _RESERVED_CHARS_RE + ']', 'g');

// Attempts to allow node names from any language. ES5's `\w` regexp matches
// only latin characters, and the unicode \p{L} is not yet supported. So
// instead, we exclude reserved characters and match everything else.
const _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
const _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace('\\.', '') + ']';

// Parent directories, delimited by '/' or ':'. Currently unused, but must
// be matched to parse the rest of the track name.
const _directoryRe = /*@__PURE__*/ /((?:WC+[\/:])*)/.source.replace('WC', _wordChar);

// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
const _nodeRe = /*@__PURE__*/ /(WCOD+)?/.source.replace('WCOD', _wordCharOrDot);

// Object on target node, and accessor. May not contain reserved
// characters. Accessor may contain any character except closing bracket.
const _objectRe = /*@__PURE__*/ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', _wordChar);

// Property and accessor. May not contain reserved characters. Accessor may
// contain any non-bracket characters.
const _propertyRe = /*@__PURE__*/ /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', _wordChar);
const _trackRe = new RegExp('' + '^' + _directoryRe + _nodeRe + _objectRe + _propertyRe + '$');
const _supportedObjectNames = ['material', 'materials', 'bones', 'map'];
class Composite {
	constructor(targetGroup, path, optionalParsedPath) {
		const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
		this._targetGroup = targetGroup;
		this._bindings = targetGroup.subscribe_(path, parsedPath);
	}
	getValue(array, offset) {
		this.bind(); // bind all binding

		const firstValidIndex = this._targetGroup.nCachedObjects_,
			binding = this._bindings[firstValidIndex];

		// and only call .getValue on the first
		if (binding !== undefined) binding.getValue(array, offset);
	}
	setValue(array, offset) {
		const bindings = this._bindings;
		for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
			bindings[i].setValue(array, offset);
		}
	}
	bind() {
		const bindings = this._bindings;
		for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
			bindings[i].bind();
		}
	}
	unbind() {
		const bindings = this._bindings;
		for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
			bindings[i].unbind();
		}
	}
}

// Note: This class uses a State pattern on a per-method basis:
// 'bind' sets 'this.getValue' / 'setValue' and shadows the
// prototype version of these methods with one that represents
// the bound state. When the property is not found, the methods
// become no-ops.
class PropertyBinding {
	constructor(rootNode, path, parsedPath) {
		this.path = path;
		this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
		this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
		this.rootNode = rootNode;

		// initial state of these methods that calls 'bind'
		this.getValue = this._getValue_unbound;
		this.setValue = this._setValue_unbound;
	}
	static create(root, path, parsedPath) {
		if (!(root && root.isAnimationObjectGroup)) {
			return new PropertyBinding(root, path, parsedPath);
		} else {
			return new PropertyBinding.Composite(root, path, parsedPath);
		}
	}

	/**
	 * Replaces spaces with underscores and removes unsupported characters from
	 * node names, to ensure compatibility with parseTrackName().
	 *
	 * @param {string} name Node name to be sanitized.
	 * @return {string}
	 */
	static sanitizeNodeName(name) {
		return name.replace(/\s/g, '_').replace(_reservedRe, '');
	}
	static parseTrackName(trackName) {
		const matches = _trackRe.exec(trackName);
		if (matches === null) {
			throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName);
		}
		const results = {
			// directoryName: matches[ 1 ], // (tschw) currently unused
			nodeName: matches[2],
			objectName: matches[3],
			objectIndex: matches[4],
			propertyName: matches[5],
			// required
			propertyIndex: matches[6]
		};
		const lastDot = results.nodeName && results.nodeName.lastIndexOf('.');
		if (lastDot !== undefined && lastDot !== -1) {
			const objectName = results.nodeName.substring(lastDot + 1);

			// Object names must be checked against an allowlist. Otherwise, there
			// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
			// 'bar' could be the objectName, or part of a nodeName (which can
			// include '.' characters).
			if (_supportedObjectNames.indexOf(objectName) !== -1) {
				results.nodeName = results.nodeName.substring(0, lastDot);
				results.objectName = objectName;
			}
		}
		if (results.propertyName === null || results.propertyName.length === 0) {
			throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);
		}
		return results;
	}
	static findNode(root, nodeName) {
		if (nodeName === undefined || nodeName === '' || nodeName === '.' || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
			return root;
		}

		// search into skeleton bones.
		if (root.skeleton) {
			const bone = root.skeleton.getBoneByName(nodeName);
			if (bone !== undefined) {
				return bone;
			}
		}

		// search into node subtree.
		if (root.children) {
			const searchNodeSubtree = function (children) {
				for (let i = 0; i < children.length; i++) {
					const childNode = children[i];
					if (childNode.name === nodeName || childNode.uuid === nodeName) {
						return childNode;
					}
					const result = searchNodeSubtree(childNode.children);
					if (result) return result;
				}
				return null;
			};
			const subTreeNode = searchNodeSubtree(root.children);
			if (subTreeNode) {
				return subTreeNode;
			}
		}
		return null;
	}

	// these are used to "bind" a nonexistent property
	_getValue_unavailable() {}
	_setValue_unavailable() {}

	// Getters

	_getValue_direct(buffer, offset) {
		buffer[offset] = this.targetObject[this.propertyName];
	}
	_getValue_array(buffer, offset) {
		const source = this.resolvedProperty;
		for (let i = 0, n = source.length; i !== n; ++i) {
			buffer[offset++] = source[i];
		}
	}
	_getValue_arrayElement(buffer, offset) {
		buffer[offset] = this.resolvedProperty[this.propertyIndex];
	}
	_getValue_toArray(buffer, offset) {
		this.resolvedProperty.toArray(buffer, offset);
	}

	// Direct

	_setValue_direct(buffer, offset) {
		this.targetObject[this.propertyName] = buffer[offset];
	}
	_setValue_direct_setNeedsUpdate(buffer, offset) {
		this.targetObject[this.propertyName] = buffer[offset];
		this.targetObject.needsUpdate = true;
	}
	_setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
		this.targetObject[this.propertyName] = buffer[offset];
		this.targetObject.matrixWorldNeedsUpdate = true;
	}

	// EntireArray

	_setValue_array(buffer, offset) {
		const dest = this.resolvedProperty;
		for (let i = 0, n = dest.length; i !== n; ++i) {
			dest[i] = buffer[offset++];
		}
	}
	_setValue_array_setNeedsUpdate(buffer, offset) {
		const dest = this.resolvedProperty;
		for (let i = 0, n = dest.length; i !== n; ++i) {
			dest[i] = buffer[offset++];
		}
		this.targetObject.needsUpdate = true;
	}
	_setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
		const dest = this.resolvedProperty;
		for (let i = 0, n = dest.length; i !== n; ++i) {
			dest[i] = buffer[offset++];
		}
		this.targetObject.matrixWorldNeedsUpdate = true;
	}

	// ArrayElement

	_setValue_arrayElement(buffer, offset) {
		this.resolvedProperty[this.propertyIndex] = buffer[offset];
	}
	_setValue_arrayElement_setNeedsUpdate(buffer, offset) {
		this.resolvedProperty[this.propertyIndex] = buffer[offset];
		this.targetObject.needsUpdate = true;
	}
	_setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
		this.resolvedProperty[this.propertyIndex] = buffer[offset];
		this.targetObject.matrixWorldNeedsUpdate = true;
	}

	// HasToFromArray

	_setValue_fromArray(buffer, offset) {
		this.resolvedProperty.fromArray(buffer, offset);
	}
	_setValue_fromArray_setNeedsUpdate(buffer, offset) {
		this.resolvedProperty.fromArray(buffer, offset);
		this.targetObject.needsUpdate = true;
	}
	_setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
		this.resolvedProperty.fromArray(buffer, offset);
		this.targetObject.matrixWorldNeedsUpdate = true;
	}
	_getValue_unbound(targetArray, offset) {
		this.bind();
		this.getValue(targetArray, offset);
	}
	_setValue_unbound(sourceArray, offset) {
		this.bind();
		this.setValue(sourceArray, offset);
	}

	// create getter / setter pair for a property in the scene graph
	bind() {
		let targetObject = this.node;
		const parsedPath = this.parsedPath;
		const objectName = parsedPath.objectName;
		const propertyName = parsedPath.propertyName;
		let propertyIndex = parsedPath.propertyIndex;
		if (!targetObject) {
			targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
			this.node = targetObject;
		}

		// set fail state so we can just 'return' on error
		this.getValue = this._getValue_unavailable;
		this.setValue = this._setValue_unavailable;

		// ensure there is a value node
		if (!targetObject) {
			console.error('THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.');
			return;
		}
		if (objectName) {
			let objectIndex = parsedPath.objectIndex;

			// special cases were we need to reach deeper into the hierarchy to get the face materials....
			switch (objectName) {
				case 'materials':
					if (!targetObject.material) {
						console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
						return;
					}
					if (!targetObject.material.materials) {
						console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);
						return;
					}
					targetObject = targetObject.material.materials;
					break;
				case 'bones':
					if (!targetObject.skeleton) {
						console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);
						return;
					}

					// potential future optimization: skip this if propertyIndex is already an integer
					// and convert the integer string to a true integer.

					targetObject = targetObject.skeleton.bones;

					// support resolving morphTarget names into indices.
					for (let i = 0; i < targetObject.length; i++) {
						if (targetObject[i].name === objectIndex) {
							objectIndex = i;
							break;
						}
					}
					break;
				case 'map':
					if ('map' in targetObject) {
						targetObject = targetObject.map;
						break;
					}
					if (!targetObject.material) {
						console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
						return;
					}
					if (!targetObject.material.map) {
						console.error('THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.', this);
						return;
					}
					targetObject = targetObject.material.map;
					break;
				default:
					if (targetObject[objectName] === undefined) {
						console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);
						return;
					}
					targetObject = targetObject[objectName];
			}
			if (objectIndex !== undefined) {
				if (targetObject[objectIndex] === undefined) {
					console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);
					return;
				}
				targetObject = targetObject[objectIndex];
			}
		}

		// resolve property
		const nodeProperty = targetObject[propertyName];
		if (nodeProperty === undefined) {
			const nodeName = parsedPath.nodeName;
			console.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName + '.' + propertyName + ' but it wasn\'t found.', targetObject);
			return;
		}

		// determine versioning scheme
		let versioning = this.Versioning.None;
		this.targetObject = targetObject;
		if (targetObject.needsUpdate !== undefined) {
			// material

			versioning = this.Versioning.NeedsUpdate;
		} else if (targetObject.matrixWorldNeedsUpdate !== undefined) {
			// node transform

			versioning = this.Versioning.MatrixWorldNeedsUpdate;
		}

		// determine how the property gets bound
		let bindingType = this.BindingType.Direct;
		if (propertyIndex !== undefined) {
			// access a sub element of the property array (only primitives are supported right now)

			if (propertyName === 'morphTargetInfluences') {
				// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

				// support resolving morphTarget names into indices.
				if (!targetObject.geometry) {
					console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);
					return;
				}
				if (!targetObject.geometry.morphAttributes) {
					console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);
					return;
				}
				if (targetObject.morphTargetDictionary[propertyIndex] !== undefined) {
					propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
				}
			}
			bindingType = this.BindingType.ArrayElement;
			this.resolvedProperty = nodeProperty;
			this.propertyIndex = propertyIndex;
		} else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
			// must use copy for Object3D.Euler/Quaternion

			bindingType = this.BindingType.HasFromToArray;
			this.resolvedProperty = nodeProperty;
		} else if (Array.isArray(nodeProperty)) {
			bindingType = this.BindingType.EntireArray;
			this.resolvedProperty = nodeProperty;
		} else {
			this.propertyName = propertyName;
		}

		// select getter / setter
		this.getValue = this.GetterByBindingType[bindingType];
		this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
	}
	unbind() {
		this.node = null;

		// back to the prototype version of getValue / setValue
		// note: avoiding to mutate the shape of 'this' via 'delete'
		this.getValue = this._getValue_unbound;
		this.setValue = this._setValue_unbound;
	}
}
PropertyBinding.Composite = Composite;
PropertyBinding.prototype.BindingType = {
	Direct: 0,
	EntireArray: 1,
	ArrayElement: 2,
	HasFromToArray: 3
};
PropertyBinding.prototype.Versioning = {
	None: 0,
	NeedsUpdate: 1,
	MatrixWorldNeedsUpdate: 2
};
PropertyBinding.prototype.GetterByBindingType = [PropertyBinding.prototype._getValue_direct, PropertyBinding.prototype._getValue_array, PropertyBinding.prototype._getValue_arrayElement, PropertyBinding.prototype._getValue_toArray];
PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [[
// Direct
PropertyBinding.prototype._setValue_direct, PropertyBinding.prototype._setValue_direct_setNeedsUpdate, PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [
// EntireArray

PropertyBinding.prototype._setValue_array, PropertyBinding.prototype._setValue_array_setNeedsUpdate, PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate], [
// ArrayElement
PropertyBinding.prototype._setValue_arrayElement, PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate, PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [
// HasToFromArray
PropertyBinding.prototype._setValue_fromArray, PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate, PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];

/**
 *
 * A group of objects that receives a shared animation state.
 *
 * Usage:
 *
 *	- Add objects you would otherwise pass as 'root' to the
 *		constructor or the .clipAction method of AnimationMixer.
 *
 *	- Instead pass this object as 'root'.
 *
 *	- You can also add and remove objects later when the mixer
 *		is running.
 *
 * Note:
 *
 *		Objects of this class appear as one object to the mixer,
 *		so cache control of the individual objects must be done
 *		on the group.
 *
 * Limitation:
 *
 *	- The animated properties must be compatible among the
 *		all objects in the group.
 *
 *	- A single property can either be controlled through a
 *		target group or directly, but not both.
 */

class AnimationObjectGroup {
	constructor() {
		this.isAnimationObjectGroup = true;
		this.uuid = generateUUID();

		// cached objects followed by the active ones
		this._objects = Array.prototype.slice.call(arguments);
		this.nCachedObjects_ = 0; // threshold
		// note: read by PropertyBinding.Composite

		const indices = {};
		this._indicesByUUID = indices; // for bookkeeping

		for (let i = 0, n = arguments.length; i !== n; ++i) {
			indices[arguments[i].uuid] = i;
		}
		this._paths = []; // inside: string
		this._parsedPaths = []; // inside: { we don't care, here }
		this._bindings = []; // inside: Array< PropertyBinding >
		this._bindingsIndicesByPath = {}; // inside: indices in these arrays

		const scope = this;
		this.stats = {
			objects: {
				get total() {
					return scope._objects.length;
				},
				get inUse() {
					return this.total - scope.nCachedObjects_;
				}
			},
			get bindingsPerObject() {
				return scope._bindings.length;
			}
		};
	}
	add() {
		const objects = this._objects,
			indicesByUUID = this._indicesByUUID,
			paths = this._paths,
			parsedPaths = this._parsedPaths,
			bindings = this._bindings,
			nBindings = bindings.length;
		let knownObject = undefined,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_;
		for (let i = 0, n = arguments.length; i !== n; ++i) {
			const object = arguments[i],
				uuid = object.uuid;
			let index = indicesByUUID[uuid];
			if (index === undefined) {
				// unknown object -> add it to the ACTIVE region

				index = nObjects++;
				indicesByUUID[uuid] = index;
				objects.push(object);

				// accounting is done, now do the same for all bindings

				for (let j = 0, m = nBindings; j !== m; ++j) {
					bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
				}
			} else if (index < nCachedObjects) {
				knownObject = objects[index];

				// move existing object to the ACTIVE region

				const firstActiveIndex = --nCachedObjects,
					lastCachedObject = objects[firstActiveIndex];
				indicesByUUID[lastCachedObject.uuid] = index;
				objects[index] = lastCachedObject;
				indicesByUUID[uuid] = firstActiveIndex;
				objects[firstActiveIndex] = object;

				// accounting is done, now do the same for all bindings

				for (let j = 0, m = nBindings; j !== m; ++j) {
					const bindingsForPath = bindings[j],
						lastCached = bindingsForPath[firstActiveIndex];
					let binding = bindingsForPath[index];
					bindingsForPath[index] = lastCached;
					if (binding === undefined) {
						// since we do not bother to create new bindings
						// for objects that are cached, the binding may
						// or may not exist

						binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
					}
					bindingsForPath[firstActiveIndex] = binding;
				}
			} else if (objects[index] !== knownObject) {
				console.error('THREE.AnimationObjectGroup: Different objects with the same UUID ' + 'detected. Clean the caches or recreate your infrastructure when reloading scenes.');
			} // else the object is already where we want it to be
		} // for arguments

		this.nCachedObjects_ = nCachedObjects;
	}
	remove() {
		const objects = this._objects,
			indicesByUUID = this._indicesByUUID,
			bindings = this._bindings,
			nBindings = bindings.length;
		let nCachedObjects = this.nCachedObjects_;
		for (let i = 0, n = arguments.length; i !== n; ++i) {
			const object = arguments[i],
				uuid = object.uuid,
				index = indicesByUUID[uuid];
			if (index !== undefined && index >= nCachedObjects) {
				// move existing object into the CACHED region

				const lastCachedIndex = nCachedObjects++,
					firstActiveObject = objects[lastCachedIndex];
				indicesByUUID[firstActiveObject.uuid] = index;
				objects[index] = firstActiveObject;
				indicesByUUID[uuid] = lastCachedIndex;
				objects[lastCachedIndex] = object;

				// accounting is done, now do the same for all bindings

				for (let j = 0, m = nBindings; j !== m; ++j) {
					const bindingsForPath = bindings[j],
						firstActive = bindingsForPath[lastCachedIndex],
						binding = bindingsForPath[index];
					bindingsForPath[index] = firstActive;
					bindingsForPath[lastCachedIndex] = binding;
				}
			}
		} // for arguments

		this.nCachedObjects_ = nCachedObjects;
	}

	// remove & forget
	uncache() {
		const objects = this._objects,
			indicesByUUID = this._indicesByUUID,
			bindings = this._bindings,
			nBindings = bindings.length;
		let nCachedObjects = this.nCachedObjects_,
			nObjects = objects.length;
		for (let i = 0, n = arguments.length; i !== n; ++i) {
			const object = arguments[i],
				uuid = object.uuid,
				index = indicesByUUID[uuid];
			if (index !== undefined) {
				delete indicesByUUID[uuid];
				if (index < nCachedObjects) {
					// object is cached, shrink the CACHED region

					const firstActiveIndex = --nCachedObjects,
						lastCachedObject = objects[firstActiveIndex],
						lastIndex = --nObjects,
						lastObject = objects[lastIndex];

					// last cached object takes this object's place
					indicesByUUID[lastCachedObject.uuid] = index;
					objects[index] = lastCachedObject;

					// last object goes to the activated slot and pop
					indicesByUUID[lastObject.uuid] = firstActiveIndex;
					objects[firstActiveIndex] = lastObject;
					objects.pop();

					// accounting is done, now do the same for all bindings

					for (let j = 0, m = nBindings; j !== m; ++j) {
						const bindingsForPath = bindings[j],
							lastCached = bindingsForPath[firstActiveIndex],
							last = bindingsForPath[lastIndex];
						bindingsForPath[index] = lastCached;
						bindingsForPath[firstActiveIndex] = last;
						bindingsForPath.pop();
					}
				} else {
					// object is active, just swap with the last and pop

					const lastIndex = --nObjects,
						lastObject = objects[lastIndex];
					if (lastIndex > 0) {
						indicesByUUID[lastObject.uuid] = index;
					}
					objects[index] = lastObject;
					objects.pop();

					// accounting is done, now do the same for all bindings

					for (let j = 0, m = nBindings; j !== m; ++j) {
						const bindingsForPath = bindings[j];
						bindingsForPath[index] = bindingsForPath[lastIndex];
						bindingsForPath.pop();
					}
				} // cached or active
			} // if object is known
		} // for arguments

		this.nCachedObjects_ = nCachedObjects;
	}

	// Internal interface used by befriended PropertyBinding.Composite:

	subscribe_(path, parsedPath) {
		// returns an array of bindings for the given path that is changed
		// according to the contained objects in the group

		const indicesByPath = this._bindingsIndicesByPath;
		let index = indicesByPath[path];
		const bindings = this._bindings;
		if (index !== undefined) return bindings[index];
		const paths = this._paths,
			parsedPaths = this._parsedPaths,
			objects = this._objects,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_,
			bindingsForPath = new Array(nObjects);
		index = bindings.length;
		indicesByPath[path] = index;
		paths.push(path);
		parsedPaths.push(parsedPath);
		bindings.push(bindingsForPath);
		for (let i = nCachedObjects, n = objects.length; i !== n; ++i) {
			const object = objects[i];
			bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
		}
		return bindingsForPath;
	}
	unsubscribe_(path) {
		// tells the group to forget about a property path and no longer
		// update the array previously obtained with 'subscribe_'

		const indicesByPath = this._bindingsIndicesByPath,
			index = indicesByPath[path];
		if (index !== undefined) {
			const paths = this._paths,
				parsedPaths = this._parsedPaths,
				bindings = this._bindings,
				lastBindingsIndex = bindings.length - 1,
				lastBindings = bindings[lastBindingsIndex],
				lastBindingsPath = path[lastBindingsIndex];
			indicesByPath[lastBindingsPath] = index;
			bindings[index] = lastBindings;
			bindings.pop();
			parsedPaths[index] = parsedPaths[lastBindingsIndex];
			parsedPaths.pop();
			paths[index] = paths[lastBindingsIndex];
			paths.pop();
		}
	}
}

class AnimationAction {
	constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
		this._mixer = mixer;
		this._clip = clip;
		this._localRoot = localRoot;
		this.blendMode = blendMode;
		const tracks = clip.tracks,
			nTracks = tracks.length,
			interpolants = new Array(nTracks);
		const interpolantSettings = {
			endingStart: ZeroCurvatureEnding,
			endingEnd: ZeroCurvatureEnding
		};
		for (let i = 0; i !== nTracks; ++i) {
			const interpolant = tracks[i].createInterpolant(null);
			interpolants[i] = interpolant;
			interpolant.settings = interpolantSettings;
		}
		this._interpolantSettings = interpolantSettings;
		this._interpolants = interpolants; // bound by the mixer

		// inside: PropertyMixer (managed by the mixer)
		this._propertyBindings = new Array(nTracks);
		this._cacheIndex = null; // for the memory manager
		this._byClipCacheIndex = null; // for the memory manager

		this._timeScaleInterpolant = null;
		this._weightInterpolant = null;
		this.loop = LoopRepeat;
		this._loopCount = -1;

		// global mixer time when the action is to be started
		// it's set back to 'null' upon start of the action
		this._startTime = null;

		// scaled local time of the action
		// gets clamped or wrapped to 0..clip.duration according to loop
		this.time = 0;
		this.timeScale = 1;
		this._effectiveTimeScale = 1;
		this.weight = 1;
		this._effectiveWeight = 1;
		this.repetitions = Infinity; // no. of repetitions when looping

		this.paused = false; // true -> zero effective time scale
		this.enabled = true; // false -> zero effective weight

		this.clampWhenFinished = false; // keep feeding the last frame?

		this.zeroSlopeAtStart = true; // for smooth interpolation w/o separate
		this.zeroSlopeAtEnd = true; // clips for start, loop and end
	}

	// State & Scheduling

	play() {
		this._mixer._activateAction(this);
		return this;
	}
	stop() {
		this._mixer._deactivateAction(this);
		return this.reset();
	}
	reset() {
		this.paused = false;
		this.enabled = true;
		this.time = 0; // restart clip
		this._loopCount = -1; // forget previous loops
		this._startTime = null; // forget scheduling

		return this.stopFading().stopWarping();
	}
	isRunning() {
		return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
	}

	// return true when play has been called
	isScheduled() {
		return this._mixer._isActiveAction(this);
	}
	startAt(time) {
		this._startTime = time;
		return this;
	}
	setLoop(mode, repetitions) {
		this.loop = mode;
		this.repetitions = repetitions;
		return this;
	}

	// Weight

	// set the weight stopping any scheduled fading
	// although .enabled = false yields an effective weight of zero, this
	// method does *not* change .enabled, because it would be confusing
	setEffectiveWeight(weight) {
		this.weight = weight;

		// note: same logic as when updated at runtime
		this._effectiveWeight = this.enabled ? weight : 0;
		return this.stopFading();
	}

	// return the weight considering fading and .enabled
	getEffectiveWeight() {
		return this._effectiveWeight;
	}
	fadeIn(duration) {
		return this._scheduleFading(duration, 0, 1);
	}
	fadeOut(duration) {
		return this._scheduleFading(duration, 1, 0);
	}
	crossFadeFrom(fadeOutAction, duration, warp) {
		fadeOutAction.fadeOut(duration);
		this.fadeIn(duration);
		if (warp) {
			const fadeInDuration = this._clip.duration,
				fadeOutDuration = fadeOutAction._clip.duration,
				startEndRatio = fadeOutDuration / fadeInDuration,
				endStartRatio = fadeInDuration / fadeOutDuration;
			fadeOutAction.warp(1.0, startEndRatio, duration);
			this.warp(endStartRatio, 1.0, duration);
		}
		return this;
	}
	crossFadeTo(fadeInAction, duration, warp) {
		return fadeInAction.crossFadeFrom(this, duration, warp);
	}
	stopFading() {
		const weightInterpolant = this._weightInterpolant;
		if (weightInterpolant !== null) {
			this._weightInterpolant = null;
			this._mixer._takeBackControlInterpolant(weightInterpolant);
		}
		return this;
	}

	// Time Scale Control

	// set the time scale stopping any scheduled warping
	// although .paused = true yields an effective time scale of zero, this
	// method does *not* change .paused, because it would be confusing
	setEffectiveTimeScale(timeScale) {
		this.timeScale = timeScale;
		this._effectiveTimeScale = this.paused ? 0 : timeScale;
		return this.stopWarping();
	}

	// return the time scale considering warping and .paused
	getEffectiveTimeScale() {
		return this._effectiveTimeScale;
	}
	setDuration(duration) {
		this.timeScale = this._clip.duration / duration;
		return this.stopWarping();
	}
	syncWith(action) {
		this.time = action.time;
		this.timeScale = action.timeScale;
		return this.stopWarping();
	}
	halt(duration) {
		return this.warp(this._effectiveTimeScale, 0, duration);
	}
	warp(startTimeScale, endTimeScale, duration) {
		const mixer = this._mixer,
			now = mixer.time,
			timeScale = this.timeScale;
		let interpolant = this._timeScaleInterpolant;
		if (interpolant === null) {
			interpolant = mixer._lendControlInterpolant();
			this._timeScaleInterpolant = interpolant;
		}
		const times = interpolant.parameterPositions,
			values = interpolant.sampleValues;
		times[0] = now;
		times[1] = now + duration;
		values[0] = startTimeScale / timeScale;
		values[1] = endTimeScale / timeScale;
		return this;
	}
	stopWarping() {
		const timeScaleInterpolant = this._timeScaleInterpolant;
		if (timeScaleInterpolant !== null) {
			this._timeScaleInterpolant = null;
			this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
		}
		return this;
	}

	// Object Accessors

	getMixer() {
		return this._mixer;
	}
	getClip() {
		return this._clip;
	}
	getRoot() {
		return this._localRoot || this._mixer._root;
	}

	// Interna

	_update(time, deltaTime, timeDirection, accuIndex) {
		// called by the mixer

		if (!this.enabled) {
			// call ._updateWeight() to update ._effectiveWeight

			this._updateWeight(time);
			return;
		}
		const startTime = this._startTime;
		if (startTime !== null) {
			// check for scheduled start of action

			const timeRunning = (time - startTime) * timeDirection;
			if (timeRunning < 0 || timeDirection === 0) {
				deltaTime = 0;
			} else {
				this._startTime = null; // unschedule
				deltaTime = timeDirection * timeRunning;
			}
		}

		// apply time scale and advance time

		deltaTime *= this._updateTimeScale(time);
		const clipTime = this._updateTime(deltaTime);

		// note: _updateTime may disable the action resulting in
		// an effective weight of 0

		const weight = this._updateWeight(time);
		if (weight > 0) {
			const interpolants = this._interpolants;
			const propertyMixers = this._propertyBindings;
			switch (this.blendMode) {
				case AdditiveAnimationBlendMode:
					for (let j = 0, m = interpolants.length; j !== m; ++j) {
						interpolants[j].evaluate(clipTime);
						propertyMixers[j].accumulateAdditive(weight);
					}
					break;
				case NormalAnimationBlendMode:
				default:
					for (let j = 0, m = interpolants.length; j !== m; ++j) {
						interpolants[j].evaluate(clipTime);
						propertyMixers[j].accumulate(accuIndex, weight);
					}
			}
		}
	}
	_updateWeight(time) {
		let weight = 0;
		if (this.enabled) {
			weight = this.weight;
			const interpolant = this._weightInterpolant;
			if (interpolant !== null) {
				const interpolantValue = interpolant.evaluate(time)[0];
				weight *= interpolantValue;
				if (time > interpolant.parameterPositions[1]) {
					this.stopFading();
					if (interpolantValue === 0) {
						// faded out, disable
						this.enabled = false;
					}
				}
			}
		}
		this._effectiveWeight = weight;
		return weight;
	}
	_updateTimeScale(time) {
		let timeScale = 0;
		if (!this.paused) {
			timeScale = this.timeScale;
			const interpolant = this._timeScaleInterpolant;
			if (interpolant !== null) {
				const interpolantValue = interpolant.evaluate(time)[0];
				timeScale *= interpolantValue;
				if (time > interpolant.parameterPositions[1]) {
					this.stopWarping();
					if (timeScale === 0) {
						// motion has halted, pause
						this.paused = true;
					} else {
						// warp done - apply final time scale
						this.timeScale = timeScale;
					}
				}
			}
		}
		this._effectiveTimeScale = timeScale;
		return timeScale;
	}
	_updateTime(deltaTime) {
		const duration = this._clip.duration;
		const loop = this.loop;
		let time = this.time + deltaTime;
		let loopCount = this._loopCount;
		const pingPong = loop === LoopPingPong;
		if (deltaTime === 0) {
			if (loopCount === -1) return time;
			return pingPong && (loopCount & 1) === 1 ? duration - time : time;
		}
		if (loop === LoopOnce) {
			if (loopCount === -1) {
				// just started

				this._loopCount = 0;
				this._setEndings(true, true, false);
			}
			handle_stop: {
				if (time >= duration) {
					time = duration;
				} else if (time < 0) {
					time = 0;
				} else {
					this.time = time;
					break handle_stop;
				}
				if (this.clampWhenFinished) this.paused = true;else this.enabled = false;
				this.time = time;
				this._mixer.dispatchEvent({
					type: 'finished',
					action: this,
					direction: deltaTime < 0 ? -1 : 1
				});
			}
		} else {
			// repetitive Repeat or PingPong

			if (loopCount === -1) {
				// just started

				if (deltaTime >= 0) {
					loopCount = 0;
					this._setEndings(true, this.repetitions === 0, pingPong);
				} else {
					// when looping in reverse direction, the initial
					// transition through zero counts as a repetition,
					// so leave loopCount at -1

					this._setEndings(this.repetitions === 0, true, pingPong);
				}
			}
			if (time >= duration || time < 0) {
				// wrap around

				const loopDelta = Math.floor(time / duration); // signed
				time -= duration * loopDelta;
				loopCount += Math.abs(loopDelta);
				const pending = this.repetitions - loopCount;
				if (pending <= 0) {
					// have to stop (switch state, clamp time, fire event)

					if (this.clampWhenFinished) this.paused = true;else this.enabled = false;
					time = deltaTime > 0 ? duration : 0;
					this.time = time;
					this._mixer.dispatchEvent({
						type: 'finished',
						action: this,
						direction: deltaTime > 0 ? 1 : -1
					});
				} else {
					// keep running

					if (pending === 1) {
						// entering the last round

						const atStart = deltaTime < 0;
						this._setEndings(atStart, !atStart, pingPong);
					} else {
						this._setEndings(false, false, pingPong);
					}
					this._loopCount = loopCount;
					this.time = time;
					this._mixer.dispatchEvent({
						type: 'loop',
						action: this,
						loopDelta: loopDelta
					});
				}
			} else {
				this.time = time;
			}
			if (pingPong && (loopCount & 1) === 1) {
				// invert time for the "pong round"

				return duration - time;
			}
		}
		return time;
	}
	_setEndings(atStart, atEnd, pingPong) {
		const settings = this._interpolantSettings;
		if (pingPong) {
			settings.endingStart = ZeroSlopeEnding;
			settings.endingEnd = ZeroSlopeEnding;
		} else {
			// assuming for LoopOnce atStart == atEnd == true

			if (atStart) {
				settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
			} else {
				settings.endingStart = WrapAroundEnding;
			}
			if (atEnd) {
				settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
			} else {
				settings.endingEnd = WrapAroundEnding;
			}
		}
	}
	_scheduleFading(duration, weightNow, weightThen) {
		const mixer = this._mixer,
			now = mixer.time;
		let interpolant = this._weightInterpolant;
		if (interpolant === null) {
			interpolant = mixer._lendControlInterpolant();
			this._weightInterpolant = interpolant;
		}
		const times = interpolant.parameterPositions,
			values = interpolant.sampleValues;
		times[0] = now;
		values[0] = weightNow;
		times[1] = now + duration;
		values[1] = weightThen;
		return this;
	}
}

const _controlInterpolantsResultBuffer = new Float32Array(1);
class AnimationMixer extends EventDispatcher {
	constructor(root) {
		super();
		this._root = root;
		this._initMemoryManager();
		this._accuIndex = 0;
		this.time = 0;
		this.timeScale = 1.0;
	}
	_bindAction(action, prototypeAction) {
		const root = action._localRoot || this._root,
			tracks = action._clip.tracks,
			nTracks = tracks.length,
			bindings = action._propertyBindings,
			interpolants = action._interpolants,
			rootUuid = root.uuid,
			bindingsByRoot = this._bindingsByRootAndName;
		let bindingsByName = bindingsByRoot[rootUuid];
		if (bindingsByName === undefined) {
			bindingsByName = {};
			bindingsByRoot[rootUuid] = bindingsByName;
		}
		for (let i = 0; i !== nTracks; ++i) {
			const track = tracks[i],
				trackName = track.name;
			let binding = bindingsByName[trackName];
			if (binding !== undefined) {
				++binding.referenceCount;
				bindings[i] = binding;
			} else {
				binding = bindings[i];
				if (binding !== undefined) {
					// existing binding, make sure the cache knows

					if (binding._cacheIndex === null) {
						++binding.referenceCount;
						this._addInactiveBinding(binding, rootUuid, trackName);
					}
					continue;
				}
				const path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
				binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
				++binding.referenceCount;
				this._addInactiveBinding(binding, rootUuid, trackName);
				bindings[i] = binding;
			}
			interpolants[i].resultBuffer = binding.buffer;
		}
	}
	_activateAction(action) {
		if (!this._isActiveAction(action)) {
			if (action._cacheIndex === null) {
				// this action has been forgotten by the cache, but the user
				// appears to be still using it -> rebind

				const rootUuid = (action._localRoot || this._root).uuid,
					clipUuid = action._clip.uuid,
					actionsForClip = this._actionsByClip[clipUuid];
				this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
				this._addInactiveAction(action, clipUuid, rootUuid);
			}
			const bindings = action._propertyBindings;

			// increment reference counts / sort out state
			for (let i = 0, n = bindings.length; i !== n; ++i) {
				const binding = bindings[i];
				if (binding.useCount++ === 0) {
					this._lendBinding(binding);
					binding.saveOriginalState();
				}
			}
			this._lendAction(action);
		}
	}
	_deactivateAction(action) {
		if (this._isActiveAction(action)) {
			const bindings = action._propertyBindings;

			// decrement reference counts / sort out state
			for (let i = 0, n = bindings.length; i !== n; ++i) {
				const binding = bindings[i];
				if (--binding.useCount === 0) {
					binding.restoreOriginalState();
					this._takeBackBinding(binding);
				}
			}
			this._takeBackAction(action);
		}
	}

	// Memory manager

	_initMemoryManager() {
		this._actions = []; // 'nActiveActions' followed by inactive ones
		this._nActiveActions = 0;
		this._actionsByClip = {};
		// inside:
		// {
		// 	knownActions: Array< AnimationAction > - used as prototypes
		// 	actionByRoot: AnimationAction - lookup
		// }

		this._bindings = []; // 'nActiveBindings' followed by inactive ones
		this._nActiveBindings = 0;
		this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >

		this._controlInterpolants = []; // same game as above
		this._nActiveControlInterpolants = 0;
		const scope = this;
		this.stats = {
			actions: {
				get total() {
					return scope._actions.length;
				},
				get inUse() {
					return scope._nActiveActions;
				}
			},
			bindings: {
				get total() {
					return scope._bindings.length;
				},
				get inUse() {
					return scope._nActiveBindings;
				}
			},
			controlInterpolants: {
				get total() {
					return scope._controlInterpolants.length;
				},
				get inUse() {
					return scope._nActiveControlInterpolants;
				}
			}
		};
	}

	// Memory management for AnimationAction objects

	_isActiveAction(action) {
		const index = action._cacheIndex;
		return index !== null && index < this._nActiveActions;
	}
	_addInactiveAction(action, clipUuid, rootUuid) {
		const actions = this._actions,
			actionsByClip = this._actionsByClip;
		let actionsForClip = actionsByClip[clipUuid];
		if (actionsForClip === undefined) {
			actionsForClip = {
				knownActions: [action],
				actionByRoot: {}
			};
			action._byClipCacheIndex = 0;
			actionsByClip[clipUuid] = actionsForClip;
		} else {
			const knownActions = actionsForClip.knownActions;
			action._byClipCacheIndex = knownActions.length;
			knownActions.push(action);
		}
		action._cacheIndex = actions.length;
		actions.push(action);
		actionsForClip.actionByRoot[rootUuid] = action;
	}
	_removeInactiveAction(action) {
		const actions = this._actions,
			lastInactiveAction = actions[actions.length - 1],
			cacheIndex = action._cacheIndex;
		lastInactiveAction._cacheIndex = cacheIndex;
		actions[cacheIndex] = lastInactiveAction;
		actions.pop();
		action._cacheIndex = null;
		const clipUuid = action._clip.uuid,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[clipUuid],
			knownActionsForClip = actionsForClip.knownActions,
			lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1],
			byClipCacheIndex = action._byClipCacheIndex;
		lastKnownAction._byClipCacheIndex = byClipCacheIndex;
		knownActionsForClip[byClipCacheIndex] = lastKnownAction;
		knownActionsForClip.pop();
		action._byClipCacheIndex = null;
		const actionByRoot = actionsForClip.actionByRoot,
			rootUuid = (action._localRoot || this._root).uuid;
		delete actionByRoot[rootUuid];
		if (knownActionsForClip.length === 0) {
			delete actionsByClip[clipUuid];
		}
		this._removeInactiveBindingsForAction(action);
	}
	_removeInactiveBindingsForAction(action) {
		const bindings = action._propertyBindings;
		for (let i = 0, n = bindings.length; i !== n; ++i) {
			const binding = bindings[i];
			if (--binding.referenceCount === 0) {
				this._removeInactiveBinding(binding);
			}
		}
	}
	_lendAction(action) {
		// [ active actions |	inactive actions	]
		// [	active actions >| inactive actions ]
		//								 s				a
		//									<-swap->
		//								 a				s

		const actions = this._actions,
			prevIndex = action._cacheIndex,
			lastActiveIndex = this._nActiveActions++,
			firstInactiveAction = actions[lastActiveIndex];
		action._cacheIndex = lastActiveIndex;
		actions[lastActiveIndex] = action;
		firstInactiveAction._cacheIndex = prevIndex;
		actions[prevIndex] = firstInactiveAction;
	}
	_takeBackAction(action) {
		// [	active actions	| inactive actions ]
		// [ active actions |< inactive actions	]
		//				a				s
		//				 <-swap->
		//				s				a

		const actions = this._actions,
			prevIndex = action._cacheIndex,
			firstInactiveIndex = --this._nActiveActions,
			lastActiveAction = actions[firstInactiveIndex];
		action._cacheIndex = firstInactiveIndex;
		actions[firstInactiveIndex] = action;
		lastActiveAction._cacheIndex = prevIndex;
		actions[prevIndex] = lastActiveAction;
	}

	// Memory management for PropertyMixer objects

	_addInactiveBinding(binding, rootUuid, trackName) {
		const bindingsByRoot = this._bindingsByRootAndName,
			bindings = this._bindings;
		let bindingByName = bindingsByRoot[rootUuid];
		if (bindingByName === undefined) {
			bindingByName = {};
			bindingsByRoot[rootUuid] = bindingByName;
		}
		bindingByName[trackName] = binding;
		binding._cacheIndex = bindings.length;
		bindings.push(binding);
	}
	_removeInactiveBinding(binding) {
		const bindings = this._bindings,
			propBinding = binding.binding,
			rootUuid = propBinding.rootNode.uuid,
			trackName = propBinding.path,
			bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[rootUuid],
			lastInactiveBinding = bindings[bindings.length - 1],
			cacheIndex = binding._cacheIndex;
		lastInactiveBinding._cacheIndex = cacheIndex;
		bindings[cacheIndex] = lastInactiveBinding;
		bindings.pop();
		delete bindingByName[trackName];
		if (Object.keys(bindingByName).length === 0) {
			delete bindingsByRoot[rootUuid];
		}
	}
	_lendBinding(binding) {
		const bindings = this._bindings,
			prevIndex = binding._cacheIndex,
			lastActiveIndex = this._nActiveBindings++,
			firstInactiveBinding = bindings[lastActiveIndex];
		binding._cacheIndex = lastActiveIndex;
		bindings[lastActiveIndex] = binding;
		firstInactiveBinding._cacheIndex = prevIndex;
		bindings[prevIndex] = firstInactiveBinding;
	}
	_takeBackBinding(binding) {
		const bindings = this._bindings,
			prevIndex = binding._cacheIndex,
			firstInactiveIndex = --this._nActiveBindings,
			lastActiveBinding = bindings[firstInactiveIndex];
		binding._cacheIndex = firstInactiveIndex;
		bindings[firstInactiveIndex] = binding;
		lastActiveBinding._cacheIndex = prevIndex;
		bindings[prevIndex] = lastActiveBinding;
	}

	// Memory management of Interpolants for weight and time scale

	_lendControlInterpolant() {
		const interpolants = this._controlInterpolants,
			lastActiveIndex = this._nActiveControlInterpolants++;
		let interpolant = interpolants[lastActiveIndex];
		if (interpolant === undefined) {
			interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, _controlInterpolantsResultBuffer);
			interpolant.__cacheIndex = lastActiveIndex;
			interpolants[lastActiveIndex] = interpolant;
		}
		return interpolant;
	}
	_takeBackControlInterpolant(interpolant) {
		const interpolants = this._controlInterpolants,
			prevIndex = interpolant.__cacheIndex,
			firstInactiveIndex = --this._nActiveControlInterpolants,
			lastActiveInterpolant = interpolants[firstInactiveIndex];
		interpolant.__cacheIndex = firstInactiveIndex;
		interpolants[firstInactiveIndex] = interpolant;
		lastActiveInterpolant.__cacheIndex = prevIndex;
		interpolants[prevIndex] = lastActiveInterpolant;
	}

	// return an action for a clip optionally using a custom root target
	// object (this method allocates a lot of dynamic memory in case a
	// previously unknown clip/root combination is specified)
	clipAction(clip, optionalRoot, blendMode) {
		const root = optionalRoot || this._root,
			rootUuid = root.uuid;
		let clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip;
		const clipUuid = clipObject !== null ? clipObject.uuid : clip;
		const actionsForClip = this._actionsByClip[clipUuid];
		let prototypeAction = null;
		if (blendMode === undefined) {
			if (clipObject !== null) {
				blendMode = clipObject.blendMode;
			} else {
				blendMode = NormalAnimationBlendMode;
			}
		}
		if (actionsForClip !== undefined) {
			const existingAction = actionsForClip.actionByRoot[rootUuid];
			if (existingAction !== undefined && existingAction.blendMode === blendMode) {
				return existingAction;
			}

			// we know the clip, so we don't have to parse all
			// the bindings again but can just copy
			prototypeAction = actionsForClip.knownActions[0];

			// also, take the clip from the prototype action
			if (clipObject === null) clipObject = prototypeAction._clip;
		}

		// clip must be known when specified via string
		if (clipObject === null) return null;

		// allocate all resources required to run it
		const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
		this._bindAction(newAction, prototypeAction);

		// and make the action known to the memory manager
		this._addInactiveAction(newAction, clipUuid, rootUuid);
		return newAction;
	}

	// get an existing action
	existingAction(clip, optionalRoot) {
		const root = optionalRoot || this._root,
			rootUuid = root.uuid,
			clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip,
			clipUuid = clipObject ? clipObject.uuid : clip,
			actionsForClip = this._actionsByClip[clipUuid];
		if (actionsForClip !== undefined) {
			return actionsForClip.actionByRoot[rootUuid] || null;
		}
		return null;
	}

	// deactivates all previously scheduled actions
	stopAllAction() {
		const actions = this._actions,
			nActions = this._nActiveActions;
		for (let i = nActions - 1; i >= 0; --i) {
			actions[i].stop();
		}
		return this;
	}

	// advance the time and update apply the animation
	update(deltaTime) {
		deltaTime *= this.timeScale;
		const actions = this._actions,
			nActions = this._nActiveActions,
			time = this.time += deltaTime,
			timeDirection = Math.sign(deltaTime),
			accuIndex = this._accuIndex ^= 1;

		// run active actions

		for (let i = 0; i !== nActions; ++i) {
			const action = actions[i];
			action._update(time, deltaTime, timeDirection, accuIndex);
		}

		// update scene graph

		const bindings = this._bindings,
			nBindings = this._nActiveBindings;
		for (let i = 0; i !== nBindings; ++i) {
			bindings[i].apply(accuIndex);
		}
		return this;
	}

	// Allows you to seek to a specific time in an animation.
	setTime(timeInSeconds) {
		this.time = 0; // Zero out time attribute for AnimationMixer object;
		for (let i = 0; i < this._actions.length; i++) {
			this._actions[i].time = 0; // Zero out time attribute for all associated AnimationAction objects.
		}

		return this.update(timeInSeconds); // Update used to set exact time. Returns "this" AnimationMixer object.
	}

	// return this mixer's root target object
	getRoot() {
		return this._root;
	}

	// free all resources specific to a particular clip
	uncacheClip(clip) {
		const actions = this._actions,
			clipUuid = clip.uuid,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[clipUuid];
		if (actionsForClip !== undefined) {
			// note: just calling _removeInactiveAction would mess up the
			// iteration state and also require updating the state we can
			// just throw away

			const actionsToRemove = actionsForClip.knownActions;
			for (let i = 0, n = actionsToRemove.length; i !== n; ++i) {
				const action = actionsToRemove[i];
				this._deactivateAction(action);
				const cacheIndex = action._cacheIndex,
					lastInactiveAction = actions[actions.length - 1];
				action._cacheIndex = null;
				action._byClipCacheIndex = null;
				lastInactiveAction._cacheIndex = cacheIndex;
				actions[cacheIndex] = lastInactiveAction;
				actions.pop();
				this._removeInactiveBindingsForAction(action);
			}
			delete actionsByClip[clipUuid];
		}
	}

	// free all resources specific to a particular root target object
	uncacheRoot(root) {
		const rootUuid = root.uuid,
			actionsByClip = this._actionsByClip;
		for (const clipUuid in actionsByClip) {
			const actionByRoot = actionsByClip[clipUuid].actionByRoot,
				action = actionByRoot[rootUuid];
			if (action !== undefined) {
				this._deactivateAction(action);
				this._removeInactiveAction(action);
			}
		}
		const bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[rootUuid];
		if (bindingByName !== undefined) {
			for (const trackName in bindingByName) {
				const binding = bindingByName[trackName];
				binding.restoreOriginalState();
				this._removeInactiveBinding(binding);
			}
		}
	}

	// remove a targeted clip from the cache
	uncacheAction(clip, optionalRoot) {
		const action = this.existingAction(clip, optionalRoot);
		if (action !== null) {
			this._deactivateAction(action);
			this._removeInactiveAction(action);
		}
	}
}

class Uniform {
	constructor(value) {
		this.value = value;
	}
	clone() {
		return new Uniform(this.value.clone === undefined ? this.value : this.value.clone());
	}
}

let id = 0;
class UniformsGroup extends EventDispatcher {
	constructor() {
		super();
		this.isUniformsGroup = true;
		Object.defineProperty(this, 'id', {
			value: id++
		});
		this.name = '';
		this.usage = StaticDrawUsage;
		this.uniforms = [];
	}
	add(uniform) {
		this.uniforms.push(uniform);
		return this;
	}
	remove(uniform) {
		const index = this.uniforms.indexOf(uniform);
		if (index !== -1) this.uniforms.splice(index, 1);
		return this;
	}
	setName(name) {
		this.name = name;
		return this;
	}
	setUsage(value) {
		this.usage = value;
		return this;
	}
	dispose() {
		this.dispatchEvent({
			type: 'dispose'
		});
		return this;
	}
	copy(source) {
		this.name = source.name;
		this.usage = source.usage;
		const uniformsSource = source.uniforms;
		this.uniforms.length = 0;
		for (let i = 0, l = uniformsSource.length; i < l; i++) {
			this.uniforms.push(uniformsSource[i].clone());
		}
		return this;
	}
	clone() {
		return new this.constructor().copy(this);
	}
}

class InstancedInterleavedBuffer extends InterleavedBuffer {
	constructor(array, stride, meshPerAttribute = 1) {
		super(array, stride);
		this.isInstancedInterleavedBuffer = true;
		this.meshPerAttribute = meshPerAttribute;
	}
	copy(source) {
		super.copy(source);
		this.meshPerAttribute = source.meshPerAttribute;
		return this;
	}
	clone(data) {
		const ib = super.clone(data);
		ib.meshPerAttribute = this.meshPerAttribute;
		return ib;
	}
	toJSON(data) {
		const json = super.toJSON(data);
		json.isInstancedInterleavedBuffer = true;
		json.meshPerAttribute = this.meshPerAttribute;
		return json;
	}
}

class GLBufferAttribute {
	constructor(buffer, type, itemSize, elementSize, count) {
		this.isGLBufferAttribute = true;
		this.buffer = buffer;
		this.type = type;
		this.itemSize = itemSize;
		this.elementSize = elementSize;
		this.count = count;
		this.version = 0;
	}
	set needsUpdate(value) {
		if (value === true) this.version++;
	}
	setBuffer(buffer) {
		this.buffer = buffer;
		return this;
	}
	setType(type, elementSize) {
		this.type = type;
		this.elementSize = elementSize;
		return this;
	}
	setItemSize(itemSize) {
		this.itemSize = itemSize;
		return this;
	}
	setCount(count) {
		this.count = count;
		return this;
	}
}

class Raycaster {
	constructor(origin, direction, near = 0, far = Infinity) {
		this.ray = new Ray(origin, direction);
		// direction is assumed to be normalized (for accurate distance calculations)

		this.near = near;
		this.far = far;
		this.camera = null;
		this.layers = new Layers();
		this.params = {
			Mesh: {},
			Line: {
				threshold: 1
			},
			LOD: {},
			Points: {
				threshold: 1
			},
			Sprite: {}
		};
	}
	set(origin, direction) {
		// direction is assumed to be normalized (for accurate distance calculations)

		this.ray.set(origin, direction);
	}
	setFromCamera(coords, camera) {
		if (camera.isPerspectiveCamera) {
			this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
			this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
			this.camera = camera;
		} else if (camera.isOrthographicCamera) {
			this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera
			this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
			this.camera = camera;
		} else {
			console.error('THREE.Raycaster: Unsupported camera type: ' + camera.type);
		}
	}
	intersectObject(object, recursive = true, intersects = []) {
		intersectObject(object, this, intersects, recursive);
		intersects.sort(ascSort);
		return intersects;
	}
	intersectObjects(objects, recursive = true, intersects = []) {
		for (let i = 0, l = objects.length; i < l; i++) {
			intersectObject(objects[i], this, intersects, recursive);
		}
		intersects.sort(ascSort);
		return intersects;
	}
}
function ascSort(a, b) {
	return a.distance - b.distance;
}
function intersectObject(object, raycaster, intersects, recursive) {
	if (object.layers.test(raycaster.layers)) {
		object.raycast(raycaster, intersects);
	}
	if (recursive === true) {
		const children = object.children;
		for (let i = 0, l = children.length; i < l; i++) {
			intersectObject(children[i], raycaster, intersects, true);
		}
	}
}

/**
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
 * The azimuthal angle (theta) is measured from the positive z-axis.
 */
class Spherical {
	constructor(radius = 1, phi = 0, theta = 0) {
		this.radius = radius;
		this.phi = phi; // polar angle
		this.theta = theta; // azimuthal angle

		return this;
	}
	set(radius, phi, theta) {
		this.radius = radius;
		this.phi = phi;
		this.theta = theta;
		return this;
	}
	copy(other) {
		this.radius = other.radius;
		this.phi = other.phi;
		this.theta = other.theta;
		return this;
	}

	// restrict phi to be between EPS and PI-EPS
	makeSafe() {
		const EPS = 0.000001;
		this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
		return this;
	}
	setFromVector3(v) {
		return this.setFromCartesianCoords(v.x, v.y, v.z);
	}
	setFromCartesianCoords(x, y, z) {
		this.radius = Math.sqrt(x * x + y * y + z * z);
		if (this.radius === 0) {
			this.theta = 0;
			this.phi = 0;
		} else {
			this.theta = Math.atan2(x, z);
			this.phi = Math.acos(clamp(y / this.radius, -1, 1));
		}
		return this;
	}
	clone() {
		return new this.constructor().copy(this);
	}
}

/**
 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
 */

class Cylindrical {
	constructor(radius = 1, theta = 0, y = 0) {
		this.radius = radius; // distance from the origin to a point in the x-z plane
		this.theta = theta; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
		this.y = y; // height above the x-z plane

		return this;
	}
	set(radius, theta, y) {
		this.radius = radius;
		this.theta = theta;
		this.y = y;
		return this;
	}
	copy(other) {
		this.radius = other.radius;
		this.theta = other.theta;
		this.y = other.y;
		return this;
	}
	setFromVector3(v) {
		return this.setFromCartesianCoords(v.x, v.y, v.z);
	}
	setFromCartesianCoords(x, y, z) {
		this.radius = Math.sqrt(x * x + z * z);
		this.theta = Math.atan2(x, z);
		this.y = y;
		return this;
	}
	clone() {
		return new this.constructor().copy(this);
	}
}

const _vector$4 = /*@__PURE__*/new Vector2();
class Box2 {
	constructor(min = new Vector2(+Infinity, +Infinity), max = new Vector2(-Infinity, -Infinity)) {
		this.isBox2 = true;
		this.min = min;
		this.max = max;
	}
	set(min, max) {
		this.min.copy(min);
		this.max.copy(max);
		return this;
	}
	setFromPoints(points) {
		this.makeEmpty();
		for (let i = 0, il = points.length; i < il; i++) {
			this.expandByPoint(points[i]);
		}
		return this;
	}
	setFromCenterAndSize(center, size) {
		const halfSize = _vector$4.copy(size).multiplyScalar(0.5);
		this.min.copy(center).sub(halfSize);
		this.max.copy(center).add(halfSize);
		return this;
	}
	clone() {
		return new this.constructor().copy(this);
	}
	copy(box) {
		this.min.copy(box.min);
		this.max.copy(box.max);
		return this;
	}
	makeEmpty() {
		this.min.x = this.min.y = +Infinity;
		this.max.x = this.max.y = -Infinity;
		return this;
	}
	isEmpty() {
		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return this.max.x < this.min.x || this.max.y < this.min.y;
	}
	getCenter(target) {
		return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
	}
	getSize(target) {
		return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
	}
	expandByPoint(point) {
		this.min.min(point);
		this.max.max(point);
		return this;
	}
	expandByVector(vector) {
		this.min.sub(vector);
		this.max.add(vector);
		return this;
	}
	expandByScalar(scalar) {
		this.min.addScalar(-scalar);
		this.max.addScalar(scalar);
		return this;
	}
	containsPoint(point) {
		return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
	}
	containsBox(box) {
		return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
	}
	getParameter(point, target) {
		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
	}
	intersectsBox(box) {
		// using 4 splitting planes to rule out intersections

		return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
	}
	clampPoint(point, target) {
		return target.copy(point).clamp(this.min, this.max);
	}
	distanceToPoint(point) {
		const clampedPoint = _vector$4.copy(point).clamp(this.min, this.max);
		return clampedPoint.sub(point).length();
	}
	intersect(box) {
		this.min.max(box.min);
		this.max.min(box.max);
		return this;
	}
	union(box) {
		this.min.min(box.min);
		this.max.max(box.max);
		return this;
	}
	translate(offset) {
		this.min.add(offset);
		this.max.add(offset);
		return this;
	}
	equals(box) {
		return box.min.equals(this.min) && box.max.equals(this.max);
	}
}

const _startP = /*@__PURE__*/new Vector3();
const _startEnd = /*@__PURE__*/new Vector3();
class Line3 {
	constructor(start = new Vector3(), end = new Vector3()) {
		this.start = start;
		this.end = end;
	}
	set(start, end) {
		this.start.copy(start);
		this.end.copy(end);
		return this;
	}
	copy(line) {
		this.start.copy(line.start);
		this.end.copy(line.end);
		return this;
	}
	getCenter(target) {
		return target.addVectors(this.start, this.end).multiplyScalar(0.5);
	}
	delta(target) {
		return target.subVectors(this.end, this.start);
	}
	distanceSq() {
		return this.start.distanceToSquared(this.end);
	}
	distance() {
		return this.start.distanceTo(this.end);
	}
	at(t, target) {
		return this.delta(target).multiplyScalar(t).add(this.start);
	}
	closestPointToPointParameter(point, clampToLine) {
		_startP.subVectors(point, this.start);
		_startEnd.subVectors(this.end, this.start);
		const startEnd2 = _startEnd.dot(_startEnd);
		const startEnd_startP = _startEnd.dot(_startP);
		let t = startEnd_startP / startEnd2;
		if (clampToLine) {
			t = clamp(t, 0, 1);
		}
		return t;
	}
	closestPointToPoint(point, clampToLine, target) {
		const t = this.closestPointToPointParameter(point, clampToLine);
		return this.delta(target).multiplyScalar(t).add(this.start);
	}
	applyMatrix4(matrix) {
		this.start.applyMatrix4(matrix);
		this.end.applyMatrix4(matrix);
		return this;
	}
	equals(line) {
		return line.start.equals(this.start) && line.end.equals(this.end);
	}
	clone() {
		return new this.constructor().copy(this);
	}
}

const _vector$3 = /*@__PURE__*/new Vector3();
class SpotLightHelper extends Object3D {
	constructor(light, color) {
		super();
		this.light = light;
		this.light.updateMatrixWorld();
		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;
		this.color = color;
		const geometry = new BufferGeometry();
		const positions = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
		for (let i = 0, j = 1, l = 32; i < l; i++, j++) {
			const p1 = i / l * Math.PI * 2;
			const p2 = j / l * Math.PI * 2;
			positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
		}
		geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
		const material = new LineBasicMaterial({
			fog: false,
			toneMapped: false
		});
		this.cone = new LineSegments(geometry, material);
		this.add(this.cone);
		this.update();
	}
	dispose() {
		this.cone.geometry.dispose();
		this.cone.material.dispose();
	}
	update() {
		this.light.updateMatrixWorld();
		const coneLength = this.light.distance ? this.light.distance : 1000;
		const coneWidth = coneLength * Math.tan(this.light.angle);
		this.cone.scale.set(coneWidth, coneWidth, coneLength);
		_vector$3.setFromMatrixPosition(this.light.target.matrixWorld);
		this.cone.lookAt(_vector$3);
		if (this.color !== undefined) {
			this.cone.material.color.set(this.color);
		} else {
			this.cone.material.color.copy(this.light.color);
		}
	}
}

const _vector$2 = /*@__PURE__*/new Vector3();
const _boneMatrix = /*@__PURE__*/new Matrix4();
const _matrixWorldInv = /*@__PURE__*/new Matrix4();
class SkeletonHelper extends LineSegments {
	constructor(object) {
		const bones = getBoneList(object);
		const geometry = new BufferGeometry();
		const vertices = [];
		const colors = [];
		const color1 = new Color(0, 0, 1);
		const color2 = new Color(0, 1, 0);
		for (let i = 0; i < bones.length; i++) {
			const bone = bones[i];
			if (bone.parent && bone.parent.isBone) {
				vertices.push(0, 0, 0);
				vertices.push(0, 0, 0);
				colors.push(color1.r, color1.g, color1.b);
				colors.push(color2.r, color2.g, color2.b);
			}
		}
		geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
		geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
		const material = new LineBasicMaterial({
			vertexColors: true,
			depthTest: false,
			depthWrite: false,
			toneMapped: false,
			transparent: true
		});
		super(geometry, material);
		this.isSkeletonHelper = true;
		this.type = 'SkeletonHelper';
		this.root = object;
		this.bones = bones;
		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;
	}
	updateMatrixWorld(force) {
		const bones = this.bones;
		const geometry = this.geometry;
		const position = geometry.getAttribute('position');
		_matrixWorldInv.copy(this.root.matrixWorld).invert();
		for (let i = 0, j = 0; i < bones.length; i++) {
			const bone = bones[i];
			if (bone.parent && bone.parent.isBone) {
				_boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
				_vector$2.setFromMatrixPosition(_boneMatrix);
				position.setXYZ(j, _vector$2.x, _vector$2.y, _vector$2.z);
				_boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
				_vector$2.setFromMatrixPosition(_boneMatrix);
				position.setXYZ(j + 1, _vector$2.x, _vector$2.y, _vector$2.z);
				j += 2;
			}
		}
		geometry.getAttribute('position').needsUpdate = true;
		super.updateMatrixWorld(force);
	}
	dispose() {
		this.geometry.dispose();
		this.material.dispose();
	}
}
function getBoneList(object) {
	const boneList = [];
	if (object.isBone === true) {
		boneList.push(object);
	}
	for (let i = 0; i < object.children.length; i++) {
		boneList.push.apply(boneList, getBoneList(object.children[i]));
	}
	return boneList;
}

class PointLightHelper extends Mesh {
	constructor(light, sphereSize, color) {
		const geometry = new SphereGeometry(sphereSize, 4, 2);
		const material = new MeshBasicMaterial({
			wireframe: true,
			fog: false,
			toneMapped: false
		});
		super(geometry, material);
		this.light = light;
		this.light.updateMatrixWorld();
		this.color = color;
		this.type = 'PointLightHelper';
		this.matrix = this.light.matrixWorld;
		this.matrixAutoUpdate = false;
		this.update();

		/*
		// TODO: delete this comment?
		const distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
		const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );
		this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
		this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );
		const d = light.distance;
		if ( d === 0.0 ) {
			this.lightDistance.visible = false;
		} else {
			this.lightDistance.scale.set( d, d, d );
		}
		this.add( this.lightDistance );
		*/
	}

	dispose() {
		this.geometry.dispose();
		this.material.dispose();
	}
	update() {
		if (this.color !== undefined) {
			this.material.color.set(this.color);
		} else {
			this.material.color.copy(this.light.color);
		}

		/*
		const d = this.light.distance;
			if ( d === 0.0 ) {
				this.lightDistance.visible = false;
			} else {
				this.lightDistance.visible = true;
			this.lightDistance.scale.set( d, d, d );
			}
		*/
	}
}

const _vector$1 = /*@__PURE__*/new Vector3();
const _color1 = /*@__PURE__*/new Color();
const _color2 = /*@__PURE__*/new Color();
class HemisphereLightHelper extends Object3D {
	constructor(light, size, color) {
		super();
		this.light = light;
		this.light.updateMatrixWorld();
		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;
		this.color = color;
		const geometry = new OctahedronGeometry(size);
		geometry.rotateY(Math.PI * 0.5);
		this.material = new MeshBasicMaterial({
			wireframe: true,
			fog: false,
			toneMapped: false
		});
		if (this.color === undefined) this.material.vertexColors = true;
		const position = geometry.getAttribute('position');
		const colors = new Float32Array(position.count * 3);
		geometry.setAttribute('color', new BufferAttribute(colors, 3));
		this.add(new Mesh(geometry, this.material));
		this.update();
	}
	dispose() {
		this.children[0].geometry.dispose();
		this.children[0].material.dispose();
	}
	update() {
		const mesh = this.children[0];
		if (this.color !== undefined) {
			this.material.color.set(this.color);
		} else {
			const colors = mesh.geometry.getAttribute('color');
			_color1.copy(this.light.color);
			_color2.copy(this.light.groundColor);
			for (let i = 0, l = colors.count; i < l; i++) {
				const color = i < l / 2 ? _color1 : _color2;
				colors.setXYZ(i, color.r, color.g, color.b);
			}
			colors.needsUpdate = true;
		}
		mesh.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate());
	}
}

class GridHelper extends LineSegments {
	constructor(size = 10, divisions = 10, color1 = 0x444444, color2 = 0x888888) {
		color1 = new Color(color1);
		color2 = new Color(color2);
		const center = divisions / 2;
		const step = size / divisions;
		const halfSize = size / 2;
		const vertices = [],
			colors = [];
		for (let i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {
			vertices.push(-halfSize, 0, k, halfSize, 0, k);
			vertices.push(k, 0, -halfSize, k, 0, halfSize);
			const color = i === center ? color1 : color2;
			color.toArray(colors, j);
			j += 3;
			color.toArray(colors, j);
			j += 3;
			color.toArray(colors, j);
			j += 3;
			color.toArray(colors, j);
			j += 3;
		}
		const geometry = new BufferGeometry();
		geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
		geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
		const material = new LineBasicMaterial({
			vertexColors: true,
			toneMapped: false
		});
		super(geometry, material);
		this.type = 'GridHelper';
	}
	dispose() {
		this.geometry.dispose();
		this.material.dispose();
	}
}

class PolarGridHelper extends LineSegments {
	constructor(radius = 10, sectors = 16, rings = 8, divisions = 64, color1 = 0x444444, color2 = 0x888888) {
		color1 = new Color(color1);
		color2 = new Color(color2);
		const vertices = [];
		const colors = [];

		// create the sectors

		if (sectors > 1) {
			for (let i = 0; i < sectors; i++) {
				const v = i / sectors * (Math.PI * 2);
				const x = Math.sin(v) * radius;
				const z = Math.cos(v) * radius;
				vertices.push(0, 0, 0);
				vertices.push(x, 0, z);
				const color = i & 1 ? color1 : color2;
				colors.push(color.r, color.g, color.b);
				colors.push(color.r, color.g, color.b);
			}
		}

		// create the rings

		for (let i = 0; i < rings; i++) {
			const color = i & 1 ? color1 : color2;
			const r = radius - radius / rings * i;
			for (let j = 0; j < divisions; j++) {
				// first vertex

				let v = j / divisions * (Math.PI * 2);
				let x = Math.sin(v) * r;
				let z = Math.cos(v) * r;
				vertices.push(x, 0, z);
				colors.push(color.r, color.g, color.b);

				// second vertex

				v = (j + 1) / divisions * (Math.PI * 2);
				x = Math.sin(v) * r;
				z = Math.cos(v) * r;
				vertices.push(x, 0, z);
				colors.push(color.r, color.g, color.b);
			}
		}
		const geometry = new BufferGeometry();
		geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
		geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
		const material = new LineBasicMaterial({
			vertexColors: true,
			toneMapped: false
		});
		super(geometry, material);
		this.type = 'PolarGridHelper';
	}
	dispose() {
		this.geometry.dispose();
		this.material.dispose();
	}
}

const _v1 = /*@__PURE__*/new Vector3();
const _v2 = /*@__PURE__*/new Vector3();
const _v3 = /*@__PURE__*/new Vector3();
class DirectionalLightHelper extends Object3D {
	constructor(light, size, color) {
		super();
		this.light = light;
		this.light.updateMatrixWorld();
		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;
		this.color = color;
		if (size === undefined) size = 1;
		let geometry = new BufferGeometry();
		geometry.setAttribute('position', new Float32BufferAttribute([-size, size, 0, size, size, 0, size, -size, 0, -size, -size, 0, -size, size, 0], 3));
		const material = new LineBasicMaterial({
			fog: false,
			toneMapped: false
		});
		this.lightPlane = new Line(geometry, material);
		this.add(this.lightPlane);
		geometry = new BufferGeometry();
		geometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
		this.targetLine = new Line(geometry, material);
		this.add(this.targetLine);
		this.update();
	}
	dispose() {
		this.lightPlane.geometry.dispose();
		this.lightPlane.material.dispose();
		this.targetLine.geometry.dispose();
		this.targetLine.material.dispose();
	}
	update() {
		_v1.setFromMatrixPosition(this.light.matrixWorld);
		_v2.setFromMatrixPosition(this.light.target.matrixWorld);
		_v3.subVectors(_v2, _v1);
		this.lightPlane.lookAt(_v2);
		if (this.color !== undefined) {
			this.lightPlane.material.color.set(this.color);
			this.targetLine.material.color.set(this.color);
		} else {
			this.lightPlane.material.color.copy(this.light.color);
			this.targetLine.material.color.copy(this.light.color);
		}
		this.targetLine.lookAt(_v2);
		this.targetLine.scale.z = _v3.length();
	}
}

const _vector = /*@__PURE__*/new Vector3();
const _camera = /*@__PURE__*/new Camera();

/**
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		https://github.com/evanw/lightgl.js/blob/master/tests/shadowmap.html
 */

class CameraHelper extends LineSegments {
	constructor(camera) {
		const geometry = new BufferGeometry();
		const material = new LineBasicMaterial({
			color: 0xffffff,
			vertexColors: true,
			toneMapped: false
		});
		const vertices = [];
		const colors = [];
		const pointMap = {};

		// near

		addLine('n1', 'n2');
		addLine('n2', 'n4');
		addLine('n4', 'n3');
		addLine('n3', 'n1');

		// far

		addLine('f1', 'f2');
		addLine('f2', 'f4');
		addLine('f4', 'f3');
		addLine('f3', 'f1');

		// sides

		addLine('n1', 'f1');
		addLine('n2', 'f2');
		addLine('n3', 'f3');
		addLine('n4', 'f4');

		// cone

		addLine('p', 'n1');
		addLine('p', 'n2');
		addLine('p', 'n3');
		addLine('p', 'n4');

		// up

		addLine('u1', 'u2');
		addLine('u2', 'u3');
		addLine('u3', 'u1');

		// target

		addLine('c', 't');
		addLine('p', 'c');

		// cross

		addLine('cn1', 'cn2');
		addLine('cn3', 'cn4');
		addLine('cf1', 'cf2');
		addLine('cf3', 'cf4');
		function addLine(a, b) {
			addPoint(a);
			addPoint(b);
		}
		function addPoint(id) {
			vertices.push(0, 0, 0);
			colors.push(0, 0, 0);
			if (pointMap[id] === undefined) {
				pointMap[id] = [];
			}
			pointMap[id].push(vertices.length / 3 - 1);
		}
		geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
		geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
		super(geometry, material);
		this.type = 'CameraHelper';
		this.camera = camera;
		if (this.camera.updateProjectionMatrix) this.camera.updateProjectionMatrix();
		this.matrix = camera.matrixWorld;
		this.matrixAutoUpdate = false;
		this.pointMap = pointMap;
		this.update();

		// colors

		const colorFrustum = new Color(0xffaa00);
		const colorCone = new Color(0xff0000);
		const colorUp = new Color(0x00aaff);
		const colorTarget = new Color(0xffffff);
		const colorCross = new Color(0x333333);
		this.setColors(colorFrustum, colorCone, colorUp, colorTarget, colorCross);
	}
	setColors(frustum, cone, up, target, cross) {
		const geometry = this.geometry;
		const colorAttribute = geometry.getAttribute('color');

		// near

		colorAttribute.setXYZ(0, frustum.r, frustum.g, frustum.b);
		colorAttribute.setXYZ(1, frustum.r, frustum.g, frustum.b); // n1, n2
		colorAttribute.setXYZ(2, frustum.r, frustum.g, frustum.b);
		colorAttribute.setXYZ(3, frustum.r, frustum.g, frustum.b); // n2, n4
		colorAttribute.setXYZ(4, frustum.r, frustum.g, frustum.b);
		colorAttribute.setXYZ(5, frustum.r, frustum.g, frustum.b); // n4, n3
		colorAttribute.setXYZ(6, frustum.r, frustum.g, frustum.b);
		colorAttribute.setXYZ(7, frustum.r, frustum.g, frustum.b); // n3, n1

		// far

		colorAttribute.setXYZ(8, frustum.r, frustum.g, frustum.b);
		colorAttribute.setXYZ(9, frustum.r, frustum.g, frustum.b); // f1, f2
		colorAttribute.setXYZ(10, frustum.r, frustum.g, frustum.b);
		colorAttribute.setXYZ(11, frustum.r, frustum.g, frustum.b); // f2, f4
		colorAttribute.setXYZ(12, frustum.r, frustum.g, frustum.b);
		colorAttribute.setXYZ(13, frustum.r, frustum.g, frustum.b); // f4, f3
		colorAttribute.setXYZ(14, frustum.r, frustum.g, frustum.b);
		colorAttribute.setXYZ(15, frustum.r, frustum.g, frustum.b); // f3, f1

		// sides

		colorAttribute.setXYZ(16, frustum.r, frustum.g, frustum.b);
		colorAttribute.setXYZ(17, frustum.r, frustum.g, frustum.b); // n1, f1
		colorAttribute.setXYZ(18, frustum.r, frustum.g, frustum.b);
		colorAttribute.setXYZ(19, frustum.r, frustum.g, frustum.b); // n2, f2
		colorAttribute.setXYZ(20, frustum.r, frustum.g, frustum.b);
		colorAttribute.setXYZ(21, frustum.r, frustum.g, frustum.b); // n3, f3
		colorAttribute.setXYZ(22, frustum.r, frustum.g, frustum.b);
		colorAttribute.setXYZ(23, frustum.r, frustum.g, frustum.b); // n4, f4

		// cone

		colorAttribute.setXYZ(24, cone.r, cone.g, cone.b);
		colorAttribute.setXYZ(25, cone.r, cone.g, cone.b); // p, n1
		colorAttribute.setXYZ(26, cone.r, cone.g, cone.b);
		colorAttribute.setXYZ(27, cone.r, cone.g, cone.b); // p, n2
		colorAttribute.setXYZ(28, cone.r, cone.g, cone.b);
		colorAttribute.setXYZ(29, cone.r, cone.g, cone.b); // p, n3
		colorAttribute.setXYZ(30, cone.r, cone.g, cone.b);
		colorAttribute.setXYZ(31, cone.r, cone.g, cone.b); // p, n4

		// up

		colorAttribute.setXYZ(32, up.r, up.g, up.b);
		colorAttribute.setXYZ(33, up.r, up.g, up.b); // u1, u2
		colorAttribute.setXYZ(34, up.r, up.g, up.b);
		colorAttribute.setXYZ(35, up.r, up.g, up.b); // u2, u3
		colorAttribute.setXYZ(36, up.r, up.g, up.b);
		colorAttribute.setXYZ(37, up.r, up.g, up.b); // u3, u1

		// target

		colorAttribute.setXYZ(38, target.r, target.g, target.b);
		colorAttribute.setXYZ(39, target.r, target.g, target.b); // c, t
		colorAttribute.setXYZ(40, cross.r, cross.g, cross.b);
		colorAttribute.setXYZ(41, cross.r, cross.g, cross.b); // p, c

		// cross

		colorAttribute.setXYZ(42, cross.r, cross.g, cross.b);
		colorAttribute.setXYZ(43, cross.r, cross.g, cross.b); // cn1, cn2
		colorAttribute.setXYZ(44, cross.r, cross.g, cross.b);
		colorAttribute.setXYZ(45, cross.r, cross.g, cross.b); // cn3, cn4

		colorAttribute.setXYZ(46, cross.r, cross.g, cross.b);
		colorAttribute.setXYZ(47, cross.r, cross.g, cross.b); // cf1, cf2
		colorAttribute.setXYZ(48, cross.r, cross.g, cross.b);
		colorAttribute.setXYZ(49, cross.r, cross.g, cross.b); // cf3, cf4

		colorAttribute.needsUpdate = true;
	}
	update() {
		const geometry = this.geometry;
		const pointMap = this.pointMap;
		const w = 1,
			h = 1;

		// we need just camera projection matrix inverse
		// world matrix must be identity

		_camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);

		// center / target

		setPoint('c', pointMap, geometry, _camera, 0, 0, -1);
		setPoint('t', pointMap, geometry, _camera, 0, 0, 1);

		// near

		setPoint('n1', pointMap, geometry, _camera, -w, -h, -1);
		setPoint('n2', pointMap, geometry, _camera, w, -h, -1);
		setPoint('n3', pointMap, geometry, _camera, -w, h, -1);
		setPoint('n4', pointMap, geometry, _camera, w, h, -1);

		// far

		setPoint('f1', pointMap, geometry, _camera, -w, -h, 1);
		setPoint('f2', pointMap, geometry, _camera, w, -h, 1);
		setPoint('f3', pointMap, geometry, _camera, -w, h, 1);
		setPoint('f4', pointMap, geometry, _camera, w, h, 1);

		// up

		setPoint('u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, -1);
		setPoint('u2', pointMap, geometry, _camera, -w * 0.7, h * 1.1, -1);
		setPoint('u3', pointMap, geometry, _camera, 0, h * 2, -1);

		// cross

		setPoint('cf1', pointMap, geometry, _camera, -w, 0, 1);
		setPoint('cf2', pointMap, geometry, _camera, w, 0, 1);
		setPoint('cf3', pointMap, geometry, _camera, 0, -h, 1);
		setPoint('cf4', pointMap, geometry, _camera, 0, h, 1);
		setPoint('cn1', pointMap, geometry, _camera, -w, 0, -1);
		setPoint('cn2', pointMap, geometry, _camera, w, 0, -1);
		setPoint('cn3', pointMap, geometry, _camera, 0, -h, -1);
		setPoint('cn4', pointMap, geometry, _camera, 0, h, -1);
		geometry.getAttribute('position').needsUpdate = true;
	}
	dispose() {
		this.geometry.dispose();
		this.material.dispose();
	}
}
function setPoint(point, pointMap, geometry, camera, x, y, z) {
	_vector.set(x, y, z).unproject(camera);
	const points = pointMap[point];
	if (points !== undefined) {
		const position = geometry.getAttribute('position');
		for (let i = 0, l = points.length; i < l; i++) {
			position.setXYZ(points[i], _vector.x, _vector.y, _vector.z);
		}
	}
}

const _box = /*@__PURE__*/new Box3();
class BoxHelper extends LineSegments {
	constructor(object, color = 0xffff00) {
		const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
		const positions = new Float32Array(8 * 3);
		const geometry = new BufferGeometry();
		geometry.setIndex(new BufferAttribute(indices, 1));
		geometry.setAttribute('position', new BufferAttribute(positions, 3));
		super(geometry, new LineBasicMaterial({
			color: color,
			toneMapped: false
		}));
		this.object = object;
		this.type = 'BoxHelper';
		this.matrixAutoUpdate = false;
		this.update();
	}
	update(object) {
		if (object !== undefined) {
			console.warn('THREE.BoxHelper: .update() has no longer arguments.');
		}
		if (this.object !== undefined) {
			_box.setFromObject(this.object);
		}
		if (_box.isEmpty()) return;
		const min = _box.min;
		const max = _box.max;

		/*
			5____4
		1/___0/|
		| 6__|_7
		2/___3/
			0: max.x, max.y, max.z
		1: min.x, max.y, max.z
		2: min.x, min.y, max.z
		3: max.x, min.y, max.z
		4: max.x, max.y, min.z
		5: min.x, max.y, min.z
		6: min.x, min.y, min.z
		7: max.x, min.y, min.z
		*/

		const position = this.geometry.attributes.position;
		const array = position.array;
		array[0] = max.x;
		array[1] = max.y;
		array[2] = max.z;
		array[3] = min.x;
		array[4] = max.y;
		array[5] = max.z;
		array[6] = min.x;
		array[7] = min.y;
		array[8] = max.z;
		array[9] = max.x;
		array[10] = min.y;
		array[11] = max.z;
		array[12] = max.x;
		array[13] = max.y;
		array[14] = min.z;
		array[15] = min.x;
		array[16] = max.y;
		array[17] = min.z;
		array[18] = min.x;
		array[19] = min.y;
		array[20] = min.z;
		array[21] = max.x;
		array[22] = min.y;
		array[23] = min.z;
		position.needsUpdate = true;
		this.geometry.computeBoundingSphere();
	}
	setFromObject(object) {
		this.object = object;
		this.update();
		return this;
	}
	copy(source, recursive) {
		super.copy(source, recursive);
		this.object = source.object;
		return this;
	}
	dispose() {
		this.geometry.dispose();
		this.material.dispose();
	}
}

class Box3Helper extends LineSegments {
	constructor(box, color = 0xffff00) {
		const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
		const positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
		const geometry = new BufferGeometry();
		geometry.setIndex(new BufferAttribute(indices, 1));
		geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
		super(geometry, new LineBasicMaterial({
			color: color,
			toneMapped: false
		}));
		this.box = box;
		this.type = 'Box3Helper';
		this.geometry.computeBoundingSphere();
	}
	updateMatrixWorld(force) {
		const box = this.box;
		if (box.isEmpty()) return;
		box.getCenter(this.position);
		box.getSize(this.scale);
		this.scale.multiplyScalar(0.5);
		super.updateMatrixWorld(force);
	}
	dispose() {
		this.geometry.dispose();
		this.material.dispose();
	}
}

class PlaneHelper extends Line {
	constructor(plane, size = 1, hex = 0xffff00) {
		const color = hex;
		const positions = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0];
		const geometry = new BufferGeometry();
		geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
		geometry.computeBoundingSphere();
		super(geometry, new LineBasicMaterial({
			color: color,
			toneMapped: false
		}));
		this.type = 'PlaneHelper';
		this.plane = plane;
		this.size = size;
		const positions2 = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0];
		const geometry2 = new BufferGeometry();
		geometry2.setAttribute('position', new Float32BufferAttribute(positions2, 3));
		geometry2.computeBoundingSphere();
		this.add(new Mesh(geometry2, new MeshBasicMaterial({
			color: color,
			opacity: 0.2,
			transparent: true,
			depthWrite: false,
			toneMapped: false
		})));
	}
	updateMatrixWorld(force) {
		this.position.set(0, 0, 0);
		this.scale.set(0.5 * this.size, 0.5 * this.size, 1);
		this.lookAt(this.plane.normal);
		this.translateZ(-this.plane.constant);
		super.updateMatrixWorld(force);
	}
	dispose() {
		this.geometry.dispose();
		this.material.dispose();
		this.children[0].geometry.dispose();
		this.children[0].material.dispose();
	}
}

const _axis = /*@__PURE__*/new Vector3();
let _lineGeometry, _coneGeometry;
class ArrowHelper extends Object3D {
	// dir is assumed to be normalized

	constructor(dir = new Vector3(0, 0, 1), origin = new Vector3(0, 0, 0), length = 1, color = 0xffff00, headLength = length * 0.2, headWidth = headLength * 0.2) {
		super();
		this.type = 'ArrowHelper';
		if (_lineGeometry === undefined) {
			_lineGeometry = new BufferGeometry();
			_lineGeometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));
			_coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1);
			_coneGeometry.translate(0, -0.5, 0);
		}
		this.position.copy(origin);
		this.line = new Line(_lineGeometry, new LineBasicMaterial({
			color: color,
			toneMapped: false
		}));
		this.line.matrixAutoUpdate = false;
		this.add(this.line);
		this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({
			color: color,
			toneMapped: false
		}));
		this.cone.matrixAutoUpdate = false;
		this.add(this.cone);
		this.setDirection(dir);
		this.setLength(length, headLength, headWidth);
	}
	setDirection(dir) {
		// dir is assumed to be normalized

		if (dir.y > 0.99999) {
			this.quaternion.set(0, 0, 0, 1);
		} else if (dir.y < -0.99999) {
			this.quaternion.set(1, 0, 0, 0);
		} else {
			_axis.set(dir.z, 0, -dir.x).normalize();
			const radians = Math.acos(dir.y);
			this.quaternion.setFromAxisAngle(_axis, radians);
		}
	}
	setLength(length, headLength = length * 0.2, headWidth = headLength * 0.2) {
		this.line.scale.set(1, Math.max(0.0001, length - headLength), 1); // see #17458
		this.line.updateMatrix();
		this.cone.scale.set(headWidth, headLength, headWidth);
		this.cone.position.y = length;
		this.cone.updateMatrix();
	}
	setColor(color) {
		this.line.material.color.set(color);
		this.cone.material.color.set(color);
	}
	copy(source) {
		super.copy(source, false);
		this.line.copy(source.line);
		this.cone.copy(source.cone);
		return this;
	}
	dispose() {
		this.line.geometry.dispose();
		this.line.material.dispose();
		this.cone.geometry.dispose();
		this.cone.material.dispose();
	}
}

class AxesHelper extends LineSegments {
	constructor(size = 1) {
		const vertices = [0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size];
		const colors = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1];
		const geometry = new BufferGeometry();
		geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
		geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
		const material = new LineBasicMaterial({
			vertexColors: true,
			toneMapped: false
		});
		super(geometry, material);
		this.type = 'AxesHelper';
	}
	setColors(xAxisColor, yAxisColor, zAxisColor) {
		const color = new Color();
		const array = this.geometry.attributes.color.array;
		color.set(xAxisColor);
		color.toArray(array, 0);
		color.toArray(array, 3);
		color.set(yAxisColor);
		color.toArray(array, 6);
		color.toArray(array, 9);
		color.set(zAxisColor);
		color.toArray(array, 12);
		color.toArray(array, 15);
		this.geometry.attributes.color.needsUpdate = true;
		return this;
	}
	dispose() {
		this.geometry.dispose();
		this.material.dispose();
	}
}

class ShapePath {
	constructor() {
		this.type = 'ShapePath';
		this.color = new Color();
		this.subPaths = [];
		this.currentPath = null;
	}
	moveTo(x, y) {
		this.currentPath = new Path();
		this.subPaths.push(this.currentPath);
		this.currentPath.moveTo(x, y);
		return this;
	}
	lineTo(x, y) {
		this.currentPath.lineTo(x, y);
		return this;
	}
	quadraticCurveTo(aCPx, aCPy, aX, aY) {
		this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
		return this;
	}
	bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
		this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
		return this;
	}
	splineThru(pts) {
		this.currentPath.splineThru(pts);
		return this;
	}
	toShapes(isCCW) {
		function toShapesNoHoles(inSubpaths) {
			const shapes = [];
			for (let i = 0, l = inSubpaths.length; i < l; i++) {
				const tmpPath = inSubpaths[i];
				const tmpShape = new Shape();
				tmpShape.curves = tmpPath.curves;
				shapes.push(tmpShape);
			}
			return shapes;
		}
		function isPointInsidePolygon(inPt, inPolygon) {
			const polyLen = inPolygon.length;

			// inPt on polygon contour => immediate success		or
			// toggling of inside/outside at every single! intersection point of an edge
			//	with the horizontal line through inPt, left of inPt
			//	not counting lowerY endpoints of edges and whole edges on that line
			let inside = false;
			for (let p = polyLen - 1, q = 0; q < polyLen; p = q++) {
				let edgeLowPt = inPolygon[p];
				let edgeHighPt = inPolygon[q];
				let edgeDx = edgeHighPt.x - edgeLowPt.x;
				let edgeDy = edgeHighPt.y - edgeLowPt.y;
				if (Math.abs(edgeDy) > Number.EPSILON) {
					// not parallel
					if (edgeDy < 0) {
						edgeLowPt = inPolygon[q];
						edgeDx = -edgeDx;
						edgeHighPt = inPolygon[p];
						edgeDy = -edgeDy;
					}
					if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;
					if (inPt.y === edgeLowPt.y) {
						if (inPt.x === edgeLowPt.x) return true; // inPt is on contour ?
						// continue;				// no intersection or edgeLowPt => doesn't count !!!
					} else {
						const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
						if (perpEdge === 0) return true; // inPt is on contour ?
						if (perpEdge < 0) continue;
						inside = !inside; // true intersection left of inPt
					}
				} else {
					// parallel or collinear
					if (inPt.y !== edgeLowPt.y) continue; // parallel
					// edge lies on the same horizontal line as inPt
					if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true; // inPt: Point on contour !
					// continue;
				}
			}

			return inside;
		}
		const isClockWise = ShapeUtils.isClockWise;
		const subPaths = this.subPaths;
		if (subPaths.length === 0) return [];
		let solid, tmpPath, tmpShape;
		const shapes = [];
		if (subPaths.length === 1) {
			tmpPath = subPaths[0];
			tmpShape = new Shape();
			tmpShape.curves = tmpPath.curves;
			shapes.push(tmpShape);
			return shapes;
		}
		let holesFirst = !isClockWise(subPaths[0].getPoints());
		holesFirst = isCCW ? !holesFirst : holesFirst;

		// console.log("Holes first", holesFirst);

		const betterShapeHoles = [];
		const newShapes = [];
		let newShapeHoles = [];
		let mainIdx = 0;
		let tmpPoints;
		newShapes[mainIdx] = undefined;
		newShapeHoles[mainIdx] = [];
		for (let i = 0, l = subPaths.length; i < l; i++) {
			tmpPath = subPaths[i];
			tmpPoints = tmpPath.getPoints();
			solid = isClockWise(tmpPoints);
			solid = isCCW ? !solid : solid;
			if (solid) {
				if (!holesFirst && newShapes[mainIdx]) mainIdx++;
				newShapes[mainIdx] = {
					s: new Shape(),
					p: tmpPoints
				};
				newShapes[mainIdx].s.curves = tmpPath.curves;
				if (holesFirst) mainIdx++;
				newShapeHoles[mainIdx] = [];

				//console.log('cw', i);
			} else {
				newShapeHoles[mainIdx].push({
					h: tmpPath,
					p: tmpPoints[0]
				});

				//console.log('ccw', i);
			}
		}

		// only Holes? -> probably all Shapes with wrong orientation
		if (!newShapes[0]) return toShapesNoHoles(subPaths);
		if (newShapes.length > 1) {
			let ambiguous = false;
			let toChange = 0;
			for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
				betterShapeHoles[sIdx] = [];
			}
			for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
				const sho = newShapeHoles[sIdx];
				for (let hIdx = 0; hIdx < sho.length; hIdx++) {
					const ho = sho[hIdx];
					let hole_unassigned = true;
					for (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
						if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
							if (sIdx !== s2Idx) toChange++;
							if (hole_unassigned) {
								hole_unassigned = false;
								betterShapeHoles[s2Idx].push(ho);
							} else {
								ambiguous = true;
							}
						}
					}
					if (hole_unassigned) {
						betterShapeHoles[sIdx].push(ho);
					}
				}
			}
			if (toChange > 0 && ambiguous === false) {
				newShapeHoles = betterShapeHoles;
			}
		}
		let tmpHoles;
		for (let i = 0, il = newShapes.length; i < il; i++) {
			tmpShape = newShapes[i].s;
			shapes.push(tmpShape);
			tmpHoles = newShapeHoles[i];
			for (let j = 0, jl = tmpHoles.length; j < jl; j++) {
				tmpShape.holes.push(tmpHoles[j].h);
			}
		}

		//console.log("shape", shapes);

		return shapes;
	}
}

// Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf

const _tables = /*@__PURE__*/_generateTables();
function _generateTables() {
	// float32 to float16 helpers

	const buffer = new ArrayBuffer(4);
	const floatView = new Float32Array(buffer);
	const uint32View = new Uint32Array(buffer);
	const baseTable = new Uint32Array(512);
	const shiftTable = new Uint32Array(512);
	for (let i = 0; i < 256; ++i) {
		const e = i - 127;

		// very small number (0, -0)

		if (e < -27) {
			baseTable[i] = 0x0000;
			baseTable[i | 0x100] = 0x8000;
			shiftTable[i] = 24;
			shiftTable[i | 0x100] = 24;

			// small number (denorm)
		} else if (e < -14) {
			baseTable[i] = 0x0400 >> -e - 14;
			baseTable[i | 0x100] = 0x0400 >> -e - 14 | 0x8000;
			shiftTable[i] = -e - 1;
			shiftTable[i | 0x100] = -e - 1;

			// normal number
		} else if (e <= 15) {
			baseTable[i] = e + 15 << 10;
			baseTable[i | 0x100] = e + 15 << 10 | 0x8000;
			shiftTable[i] = 13;
			shiftTable[i | 0x100] = 13;

			// large number (Infinity, -Infinity)
		} else if (e < 128) {
			baseTable[i] = 0x7c00;
			baseTable[i | 0x100] = 0xfc00;
			shiftTable[i] = 24;
			shiftTable[i | 0x100] = 24;

			// stay (NaN, Infinity, -Infinity)
		} else {
			baseTable[i] = 0x7c00;
			baseTable[i | 0x100] = 0xfc00;
			shiftTable[i] = 13;
			shiftTable[i | 0x100] = 13;
		}
	}

	// float16 to float32 helpers

	const mantissaTable = new Uint32Array(2048);
	const exponentTable = new Uint32Array(64);
	const offsetTable = new Uint32Array(64);
	for (let i = 1; i < 1024; ++i) {
		let m = i << 13; // zero pad mantissa bits
		let e = 0; // zero exponent

		// normalized
		while ((m & 0x00800000) === 0) {
			m <<= 1;
			e -= 0x00800000; // decrement exponent
		}

		m &= ~0x00800000; // clear leading 1 bit
		e += 0x38800000; // adjust bias

		mantissaTable[i] = m | e;
	}
	for (let i = 1024; i < 2048; ++i) {
		mantissaTable[i] = 0x38000000 + (i - 1024 << 13);
	}
	for (let i = 1; i < 31; ++i) {
		exponentTable[i] = i << 23;
	}
	exponentTable[31] = 0x47800000;
	exponentTable[32] = 0x80000000;
	for (let i = 33; i < 63; ++i) {
		exponentTable[i] = 0x80000000 + (i - 32 << 23);
	}
	exponentTable[63] = 0xc7800000;
	for (let i = 1; i < 64; ++i) {
		if (i !== 32) {
			offsetTable[i] = 1024;
		}
	}
	return {
		floatView: floatView,
		uint32View: uint32View,
		baseTable: baseTable,
		shiftTable: shiftTable,
		mantissaTable: mantissaTable,
		exponentTable: exponentTable,
		offsetTable: offsetTable
	};
}

// float32 to float16

function toHalfFloat(val) {
	if (Math.abs(val) > 65504) console.warn('THREE.DataUtils.toHalfFloat(): Value out of range.');
	val = clamp(val, -65504, 65504);
	_tables.floatView[0] = val;
	const f = _tables.uint32View[0];
	const e = f >> 23 & 0x1ff;
	return _tables.baseTable[e] + ((f & 0x007fffff) >> _tables.shiftTable[e]);
}

// float16 to float32

function fromHalfFloat(val) {
	const m = val >> 10;
	_tables.uint32View[0] = _tables.mantissaTable[_tables.offsetTable[m] + (val & 0x3ff)] + _tables.exponentTable[m];
	return _tables.floatView[0];
}

var DataUtils = /*#__PURE__*/Object.freeze({
	__proto__: null,
	toHalfFloat: toHalfFloat,
	fromHalfFloat: fromHalfFloat
});

// r134, d65e0af06644fe5a84a6fc0e372f4318f95a04c0

function ImmediateRenderObject() {
	console.error('THREE.ImmediateRenderObject has been removed.');
}

// r138, 48b05d3500acc084df50be9b4c90781ad9b8cb17

class WebGLMultisampleRenderTarget extends WebGLRenderTarget {
	constructor(width, height, options) {
		console.error('THREE.WebGLMultisampleRenderTarget has been removed. Use a normal render target and set the "samples" property to greater 0 to enable multisampling.');
		super(width, height, options);
		this.samples = 4;
	}
}

// r138, f9cd9cab03b7b64244e304900a3a2eeaa3a588ce

class DataTexture2DArray extends DataArrayTexture {
	constructor(data, width, height, depth) {
		console.warn('THREE.DataTexture2DArray has been renamed to DataArrayTexture.');
		super(data, width, height, depth);
	}
}

// r138, f9cd9cab03b7b64244e304900a3a2eeaa3a588ce

class DataTexture3D extends Data3DTexture {
	constructor(data, width, height, depth) {
		console.warn('THREE.DataTexture3D has been renamed to Data3DTexture.');
		super(data, width, height, depth);
	}
}

// r144

class BoxBufferGeometry extends BoxGeometry {
	constructor(width, height, depth, widthSegments, heightSegments, depthSegments) {
		console.warn('THREE.BoxBufferGeometry has been renamed to THREE.BoxGeometry.');
		super(width, height, depth, widthSegments, heightSegments, depthSegments);
	}
}

// r144

class CapsuleBufferGeometry extends CapsuleGeometry {
	constructor(radius, length, capSegments, radialSegments) {
		console.warn('THREE.CapsuleBufferGeometry has been renamed to THREE.CapsuleGeometry.');
		super(radius, length, capSegments, radialSegments);
	}
}

// r144

class CircleBufferGeometry extends CircleGeometry {
	constructor(radius, segments, thetaStart, thetaLength) {
		console.warn('THREE.CircleBufferGeometry has been renamed to THREE.CircleGeometry.');
		super(radius, segments, thetaStart, thetaLength);
	}
}

// r144

class ConeBufferGeometry extends ConeGeometry {
	constructor(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
		console.warn('THREE.ConeBufferGeometry has been renamed to THREE.ConeGeometry.');
		super(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
	}
}

// r144

class CylinderBufferGeometry extends CylinderGeometry {
	constructor(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
		console.warn('THREE.CylinderBufferGeometry has been renamed to THREE.CylinderGeometry.');
		super(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
	}
}

// r144

class DodecahedronBufferGeometry extends DodecahedronGeometry {
	constructor(radius, detail) {
		console.warn('THREE.DodecahedronBufferGeometry has been renamed to THREE.DodecahedronGeometry.');
		super(radius, detail);
	}
}

// r144

class ExtrudeBufferGeometry extends ExtrudeGeometry {
	constructor(shapes, options) {
		console.warn('THREE.ExtrudeBufferGeometry has been renamed to THREE.ExtrudeGeometry.');
		super(shapes, options);
	}
}

// r144

class IcosahedronBufferGeometry extends IcosahedronGeometry {
	constructor(radius, detail) {
		console.warn('THREE.IcosahedronBufferGeometry has been renamed to THREE.IcosahedronGeometry.');
		super(radius, detail);
	}
}

// r144

class LatheBufferGeometry extends LatheGeometry {
	constructor(points, segments, phiStart, phiLength) {
		console.warn('THREE.LatheBufferGeometry has been renamed to THREE.LatheGeometry.');
		super(points, segments, phiStart, phiLength);
	}
}

// r144

class OctahedronBufferGeometry extends OctahedronGeometry {
	constructor(radius, detail) {
		console.warn('THREE.OctahedronBufferGeometry has been renamed to THREE.OctahedronGeometry.');
		super(radius, detail);
	}
}

// r144

class PlaneBufferGeometry extends PlaneGeometry {
	constructor(width, height, widthSegments, heightSegments) {
		console.warn('THREE.PlaneBufferGeometry has been renamed to THREE.PlaneGeometry.');
		super(width, height, widthSegments, heightSegments);
	}
}

// r144

class PolyhedronBufferGeometry extends PolyhedronGeometry {
	constructor(vertices, indices, radius, detail) {
		console.warn('THREE.PolyhedronBufferGeometry has been renamed to THREE.PolyhedronGeometry.');
		super(vertices, indices, radius, detail);
	}
}

// r144

class RingBufferGeometry extends RingGeometry {
	constructor(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
		console.warn('THREE.RingBufferGeometry has been renamed to THREE.RingGeometry.');
		super(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength);
	}
}

// r144

class ShapeBufferGeometry extends ShapeGeometry {
	constructor(shapes, curveSegments) {
		console.warn('THREE.ShapeBufferGeometry has been renamed to THREE.ShapeGeometry.');
		super(shapes, curveSegments);
	}
}

// r144

class SphereBufferGeometry extends SphereGeometry {
	constructor(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
		console.warn('THREE.SphereBufferGeometry has been renamed to THREE.SphereGeometry.');
		super(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength);
	}
}

// r144

class TetrahedronBufferGeometry extends TetrahedronGeometry {
	constructor(radius, detail) {
		console.warn('THREE.TetrahedronBufferGeometry has been renamed to THREE.TetrahedronGeometry.');
		super(radius, detail);
	}
}

// r144

class TorusBufferGeometry extends TorusGeometry {
	constructor(radius, tube, radialSegments, tubularSegments, arc) {
		console.warn('THREE.TorusBufferGeometry has been renamed to THREE.TorusGeometry.');
		super(radius, tube, radialSegments, tubularSegments, arc);
	}
}

// r144

class TorusKnotBufferGeometry extends TorusKnotGeometry {
	constructor(radius, tube, tubularSegments, radialSegments, p, q) {
		console.warn('THREE.TorusKnotBufferGeometry has been renamed to THREE.TorusKnotGeometry.');
		super(radius, tube, tubularSegments, radialSegments, p, q);
	}
}

// r144

class TubeBufferGeometry extends TubeGeometry {
	constructor(path, tubularSegments, radius, radialSegments, closed) {
		console.warn('THREE.TubeBufferGeometry has been renamed to THREE.TubeGeometry.');
		super(path, tubularSegments, radius, radialSegments, closed);
	}
}

if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
	__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', {
		detail: {
			revision: REVISION
		}
	}));
}
if (typeof window !== 'undefined') {
	if (window.__THREE__) {
		console.warn('WARNING: Multiple instances of Three.js being imported.');
	} else {
		window.__THREE__ = REVISION;
	}
}

exports.ACESFilmicToneMapping = ACESFilmicToneMapping;
exports.AddEquation = AddEquation;
exports.AddOperation = AddOperation;
exports.AdditiveAnimationBlendMode = AdditiveAnimationBlendMode;
exports.AdditiveBlending = AdditiveBlending;
exports.AlphaFormat = AlphaFormat;
exports.AlwaysDepth = AlwaysDepth;
exports.AlwaysStencilFunc = AlwaysStencilFunc;
exports.AmbientLight = AmbientLight;
exports.AmbientLightProbe = AmbientLightProbe;
exports.AnimationClip = AnimationClip;
exports.AnimationLoader = AnimationLoader;
exports.AnimationMixer = AnimationMixer;
exports.AnimationObjectGroup = AnimationObjectGroup;
exports.AnimationUtils = AnimationUtils;
exports.ArcCurve = ArcCurve;
exports.ArrayCamera = ArrayCamera;
exports.ArrowHelper = ArrowHelper;
exports.Audio = Audio;
exports.AudioAnalyser = AudioAnalyser;
exports.AudioContext = AudioContext;
exports.AudioListener = AudioListener;
exports.AudioLoader = AudioLoader;
exports.AxesHelper = AxesHelper;
exports.BackSide = BackSide;
exports.BasicDepthPacking = BasicDepthPacking;
exports.BasicShadowMap = BasicShadowMap;
exports.Bone = Bone;
exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
exports.Box2 = Box2;
exports.Box3 = Box3;
exports.Box3Helper = Box3Helper;
exports.BoxBufferGeometry = BoxBufferGeometry;
exports.BoxGeometry = BoxGeometry;
exports.BoxHelper = BoxHelper;
exports.BufferAttribute = BufferAttribute;
exports.BufferGeometry = BufferGeometry;
exports.BufferGeometryLoader = BufferGeometryLoader;
exports.ByteType = ByteType;
exports.Cache = Cache;
exports.Camera = Camera;
exports.CameraHelper = CameraHelper;
exports.CanvasTexture = CanvasTexture;
exports.CapsuleBufferGeometry = CapsuleBufferGeometry;
exports.CapsuleGeometry = CapsuleGeometry;
exports.CatmullRomCurve3 = CatmullRomCurve3;
exports.CineonToneMapping = CineonToneMapping;
exports.CircleBufferGeometry = CircleBufferGeometry;
exports.CircleGeometry = CircleGeometry;
exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
exports.Clock = Clock;
exports.Color = Color;
exports.ColorKeyframeTrack = ColorKeyframeTrack;
exports.ColorManagement = ColorManagement;
exports.CompressedArrayTexture = CompressedArrayTexture;
exports.CompressedTexture = CompressedTexture;
exports.CompressedTextureLoader = CompressedTextureLoader;
exports.ConeBufferGeometry = ConeBufferGeometry;
exports.ConeGeometry = ConeGeometry;
exports.CubeCamera = CubeCamera;
exports.CubeReflectionMapping = CubeReflectionMapping;
exports.CubeRefractionMapping = CubeRefractionMapping;
exports.CubeTexture = CubeTexture;
exports.CubeTextureLoader = CubeTextureLoader;
exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
exports.CubicBezierCurve = CubicBezierCurve;
exports.CubicBezierCurve3 = CubicBezierCurve3;
exports.CubicInterpolant = CubicInterpolant;
exports.CullFaceBack = CullFaceBack;
exports.CullFaceFront = CullFaceFront;
exports.CullFaceFrontBack = CullFaceFrontBack;
exports.CullFaceNone = CullFaceNone;
exports.Curve = Curve;
exports.CurvePath = CurvePath;
exports.CustomBlending = CustomBlending;
exports.CustomToneMapping = CustomToneMapping;
exports.CylinderBufferGeometry = CylinderBufferGeometry;
exports.CylinderGeometry = CylinderGeometry;
exports.Cylindrical = Cylindrical;
exports.Data3DTexture = Data3DTexture;
exports.DataArrayTexture = DataArrayTexture;
exports.DataTexture = DataTexture;
exports.DataTexture2DArray = DataTexture2DArray;
exports.DataTexture3D = DataTexture3D;
exports.DataTextureLoader = DataTextureLoader;
exports.DataUtils = DataUtils;
exports.DecrementStencilOp = DecrementStencilOp;
exports.DecrementWrapStencilOp = DecrementWrapStencilOp;
exports.DefaultLoadingManager = DefaultLoadingManager;
exports.DepthFormat = DepthFormat;
exports.DepthStencilFormat = DepthStencilFormat;
exports.DepthTexture = DepthTexture;
exports.DirectionalLight = DirectionalLight;
exports.DirectionalLightHelper = DirectionalLightHelper;
exports.DiscreteInterpolant = DiscreteInterpolant;
exports.DodecahedronBufferGeometry = DodecahedronBufferGeometry;
exports.DodecahedronGeometry = DodecahedronGeometry;
exports.DoubleSide = DoubleSide;
exports.DstAlphaFactor = DstAlphaFactor;
exports.DstColorFactor = DstColorFactor;
exports.DynamicCopyUsage = DynamicCopyUsage;
exports.DynamicDrawUsage = DynamicDrawUsage;
exports.DynamicReadUsage = DynamicReadUsage;
exports.EdgesGeometry = EdgesGeometry;
exports.EllipseCurve = EllipseCurve;
exports.EqualDepth = EqualDepth;
exports.EqualStencilFunc = EqualStencilFunc;
exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
exports.Euler = Euler;
exports.EventDispatcher = EventDispatcher;
exports.ExtrudeBufferGeometry = ExtrudeBufferGeometry;
exports.ExtrudeGeometry = ExtrudeGeometry;
exports.FileLoader = FileLoader;
exports.Float16BufferAttribute = Float16BufferAttribute;
exports.Float32BufferAttribute = Float32BufferAttribute;
exports.Float64BufferAttribute = Float64BufferAttribute;
exports.FloatType = FloatType;
exports.Fog = Fog;
exports.FogExp2 = FogExp2;
exports.FramebufferTexture = FramebufferTexture;
exports.FrontSide = FrontSide;
exports.Frustum = Frustum;
exports.GLBufferAttribute = GLBufferAttribute;
exports.GLSL1 = GLSL1;
exports.GLSL3 = GLSL3;
exports.GreaterDepth = GreaterDepth;
exports.GreaterEqualDepth = GreaterEqualDepth;
exports.GreaterEqualStencilFunc = GreaterEqualStencilFunc;
exports.GreaterStencilFunc = GreaterStencilFunc;
exports.GridHelper = GridHelper;
exports.Group = Group;
exports.HalfFloatType = HalfFloatType;
exports.HemisphereLight = HemisphereLight;
exports.HemisphereLightHelper = HemisphereLightHelper;
exports.HemisphereLightProbe = HemisphereLightProbe;
exports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;
exports.IcosahedronGeometry = IcosahedronGeometry;
exports.ImageBitmapLoader = ImageBitmapLoader;
exports.ImageLoader = ImageLoader;
exports.ImageUtils = ImageUtils;
exports.ImmediateRenderObject = ImmediateRenderObject;
exports.IncrementStencilOp = IncrementStencilOp;
exports.IncrementWrapStencilOp = IncrementWrapStencilOp;
exports.InstancedBufferAttribute = InstancedBufferAttribute;
exports.InstancedBufferGeometry = InstancedBufferGeometry;
exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
exports.InstancedMesh = InstancedMesh;
exports.Int16BufferAttribute = Int16BufferAttribute;
exports.Int32BufferAttribute = Int32BufferAttribute;
exports.Int8BufferAttribute = Int8BufferAttribute;
exports.IntType = IntType;
exports.InterleavedBuffer = InterleavedBuffer;
exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
exports.Interpolant = Interpolant;
exports.InterpolateDiscrete = InterpolateDiscrete;
exports.InterpolateLinear = InterpolateLinear;
exports.InterpolateSmooth = InterpolateSmooth;
exports.InvertStencilOp = InvertStencilOp;
exports.KeepStencilOp = KeepStencilOp;
exports.KeyframeTrack = KeyframeTrack;
exports.LOD = LOD;
exports.LatheBufferGeometry = LatheBufferGeometry;
exports.LatheGeometry = LatheGeometry;
exports.Layers = Layers;
exports.LessDepth = LessDepth;
exports.LessEqualDepth = LessEqualDepth;
exports.LessEqualStencilFunc = LessEqualStencilFunc;
exports.LessStencilFunc = LessStencilFunc;
exports.Light = Light;
exports.LightProbe = LightProbe;
exports.Line = Line;
exports.Line3 = Line3;
exports.LineBasicMaterial = LineBasicMaterial;
exports.LineCurve = LineCurve;
exports.LineCurve3 = LineCurve3;
exports.LineDashedMaterial = LineDashedMaterial;
exports.LineLoop = LineLoop;
exports.LineSegments = LineSegments;
exports.LinearEncoding = LinearEncoding;
exports.LinearFilter = LinearFilter;
exports.LinearInterpolant = LinearInterpolant;
exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
exports.LinearMipmapLinearFilter = LinearMipmapLinearFilter;
exports.LinearMipmapNearestFilter = LinearMipmapNearestFilter;
exports.LinearSRGBColorSpace = LinearSRGBColorSpace;
exports.LinearToneMapping = LinearToneMapping;
exports.Loader = Loader;
exports.LoaderUtils = LoaderUtils;
exports.LoadingManager = LoadingManager;
exports.LoopOnce = LoopOnce;
exports.LoopPingPong = LoopPingPong;
exports.LoopRepeat = LoopRepeat;
exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
exports.LuminanceFormat = LuminanceFormat;
exports.MOUSE = MOUSE;
exports.Material = Material;
exports.MaterialLoader = MaterialLoader;
exports.MathUtils = MathUtils;
exports.Matrix3 = Matrix3;
exports.Matrix4 = Matrix4;
exports.MaxEquation = MaxEquation;
exports.Mesh = Mesh;
exports.MeshBasicMaterial = MeshBasicMaterial;
exports.MeshDepthMaterial = MeshDepthMaterial;
exports.MeshDistanceMaterial = MeshDistanceMaterial;
exports.MeshLambertMaterial = MeshLambertMaterial;
exports.MeshMatcapMaterial = MeshMatcapMaterial;
exports.MeshNormalMaterial = MeshNormalMaterial;
exports.MeshPhongMaterial = MeshPhongMaterial;
exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
exports.MeshStandardMaterial = MeshStandardMaterial;
exports.MeshToonMaterial = MeshToonMaterial;
exports.MinEquation = MinEquation;
exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
exports.MixOperation = MixOperation;
exports.MultiplyBlending = MultiplyBlending;
exports.MultiplyOperation = MultiplyOperation;
exports.NearestFilter = NearestFilter;
exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
exports.NearestMipmapLinearFilter = NearestMipmapLinearFilter;
exports.NearestMipmapNearestFilter = NearestMipmapNearestFilter;
exports.NeverDepth = NeverDepth;
exports.NeverStencilFunc = NeverStencilFunc;
exports.NoBlending = NoBlending;
exports.NoColorSpace = NoColorSpace;
exports.NoToneMapping = NoToneMapping;
exports.NormalAnimationBlendMode = NormalAnimationBlendMode;
exports.NormalBlending = NormalBlending;
exports.NotEqualDepth = NotEqualDepth;
exports.NotEqualStencilFunc = NotEqualStencilFunc;
exports.NumberKeyframeTrack = NumberKeyframeTrack;
exports.Object3D = Object3D;
exports.ObjectLoader = ObjectLoader;
exports.ObjectSpaceNormalMap = ObjectSpaceNormalMap;
exports.OctahedronBufferGeometry = OctahedronBufferGeometry;
exports.OctahedronGeometry = OctahedronGeometry;
exports.OneFactor = OneFactor;
exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
exports.OrthographicCamera = OrthographicCamera;
exports.PCFShadowMap = PCFShadowMap;
exports.PCFSoftShadowMap = PCFSoftShadowMap;
exports.PMREMGenerator = PMREMGenerator;
exports.Path = Path;
exports.PerspectiveCamera = PerspectiveCamera;
exports.Plane = Plane;
exports.PlaneBufferGeometry = PlaneBufferGeometry;
exports.PlaneGeometry = PlaneGeometry;
exports.PlaneHelper = PlaneHelper;
exports.PointLight = PointLight;
exports.PointLightHelper = PointLightHelper;
exports.Points = Points;
exports.PointsMaterial = PointsMaterial;
exports.PolarGridHelper = PolarGridHelper;
exports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;
exports.PolyhedronGeometry = PolyhedronGeometry;
exports.PositionalAudio = PositionalAudio;
exports.PropertyBinding = PropertyBinding;
exports.PropertyMixer = PropertyMixer;
exports.QuadraticBezierCurve = QuadraticBezierCurve;
exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;
exports.Quaternion = Quaternion;
exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
exports.REVISION = REVISION;
exports.RGBADepthPacking = RGBADepthPacking;
exports.RGBAFormat = RGBAFormat;
exports.RGBAIntegerFormat = RGBAIntegerFormat;
exports.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format;
exports.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format;
exports.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format;
exports.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format;
exports.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format;
exports.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format;
exports.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format;
exports.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format;
exports.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format;
exports.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format;
exports.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format;
exports.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format;
exports.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format;
exports.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format;
exports.RGBA_BPTC_Format = RGBA_BPTC_Format;
exports.RGBA_ETC2_EAC_Format = RGBA_ETC2_EAC_Format;
exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
exports.RGBFormat = RGBFormat;
exports.RGB_ETC1_Format = RGB_ETC1_Format;
exports.RGB_ETC2_Format = RGB_ETC2_Format;
exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
exports.RGFormat = RGFormat;
exports.RGIntegerFormat = RGIntegerFormat;
exports.RawShaderMaterial = RawShaderMaterial;
exports.Ray = Ray;
exports.Raycaster = Raycaster;
exports.RectAreaLight = RectAreaLight;
exports.RedFormat = RedFormat;
exports.RedIntegerFormat = RedIntegerFormat;
exports.ReinhardToneMapping = ReinhardToneMapping;
exports.RepeatWrapping = RepeatWrapping;
exports.ReplaceStencilOp = ReplaceStencilOp;
exports.ReverseSubtractEquation = ReverseSubtractEquation;
exports.RingBufferGeometry = RingBufferGeometry;
exports.RingGeometry = RingGeometry;
exports.SRGBColorSpace = SRGBColorSpace;
exports.Scene = Scene;
exports.ShaderChunk = ShaderChunk;
exports.ShaderLib = ShaderLib;
exports.ShaderMaterial = ShaderMaterial;
exports.ShadowMaterial = ShadowMaterial;
exports.Shape = Shape;
exports.ShapeBufferGeometry = ShapeBufferGeometry;
exports.ShapeGeometry = ShapeGeometry;
exports.ShapePath = ShapePath;
exports.ShapeUtils = ShapeUtils;
exports.ShortType = ShortType;
exports.Skeleton = Skeleton;
exports.SkeletonHelper = SkeletonHelper;
exports.SkinnedMesh = SkinnedMesh;
exports.Source = Source;
exports.Sphere = Sphere;
exports.SphereBufferGeometry = SphereBufferGeometry;
exports.SphereGeometry = SphereGeometry;
exports.Spherical = Spherical;
exports.SphericalHarmonics3 = SphericalHarmonics3;
exports.SplineCurve = SplineCurve;
exports.SpotLight = SpotLight;
exports.SpotLightHelper = SpotLightHelper;
exports.Sprite = Sprite;
exports.SpriteMaterial = SpriteMaterial;
exports.SrcAlphaFactor = SrcAlphaFactor;
exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
exports.SrcColorFactor = SrcColorFactor;
exports.StaticCopyUsage = StaticCopyUsage;
exports.StaticDrawUsage = StaticDrawUsage;
exports.StaticReadUsage = StaticReadUsage;
exports.StereoCamera = StereoCamera;
exports.StreamCopyUsage = StreamCopyUsage;
exports.StreamDrawUsage = StreamDrawUsage;
exports.StreamReadUsage = StreamReadUsage;
exports.StringKeyframeTrack = StringKeyframeTrack;
exports.SubtractEquation = SubtractEquation;
exports.SubtractiveBlending = SubtractiveBlending;
exports.TOUCH = TOUCH;
exports.TangentSpaceNormalMap = TangentSpaceNormalMap;
exports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;
exports.TetrahedronGeometry = TetrahedronGeometry;
exports.Texture = Texture;
exports.TextureLoader = TextureLoader;
exports.TorusBufferGeometry = TorusBufferGeometry;
exports.TorusGeometry = TorusGeometry;
exports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;
exports.TorusKnotGeometry = TorusKnotGeometry;
exports.Triangle = Triangle;
exports.TriangleFanDrawMode = TriangleFanDrawMode;
exports.TriangleStripDrawMode = TriangleStripDrawMode;
exports.TrianglesDrawMode = TrianglesDrawMode;
exports.TubeBufferGeometry = TubeBufferGeometry;
exports.TubeGeometry = TubeGeometry;
exports.UVMapping = UVMapping;
exports.Uint16BufferAttribute = Uint16BufferAttribute;
exports.Uint32BufferAttribute = Uint32BufferAttribute;
exports.Uint8BufferAttribute = Uint8BufferAttribute;
exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;
exports.Uniform = Uniform;
exports.UniformsGroup = UniformsGroup;
exports.UniformsLib = UniformsLib;
exports.UniformsUtils = UniformsUtils;
exports.UnsignedByteType = UnsignedByteType;
exports.UnsignedInt248Type = UnsignedInt248Type;
exports.UnsignedIntType = UnsignedIntType;
exports.UnsignedShort4444Type = UnsignedShort4444Type;
exports.UnsignedShort5551Type = UnsignedShort5551Type;
exports.UnsignedShortType = UnsignedShortType;
exports.VSMShadowMap = VSMShadowMap;
exports.Vector2 = Vector2;
exports.Vector3 = Vector3;
exports.Vector4 = Vector4;
exports.VectorKeyframeTrack = VectorKeyframeTrack;
exports.VideoTexture = VideoTexture;
exports.WebGL1Renderer = WebGL1Renderer;
exports.WebGL3DRenderTarget = WebGL3DRenderTarget;
exports.WebGLArrayRenderTarget = WebGLArrayRenderTarget;
exports.WebGLCubeRenderTarget = WebGLCubeRenderTarget;
exports.WebGLMultipleRenderTargets = WebGLMultipleRenderTargets;
exports.WebGLMultisampleRenderTarget = WebGLMultisampleRenderTarget;
exports.WebGLRenderTarget = WebGLRenderTarget;
exports.WebGLRenderer = WebGLRenderer;
exports.WebGLUtils = WebGLUtils;
exports.WireframeGeometry = WireframeGeometry;
exports.WrapAroundEnding = WrapAroundEnding;
exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
exports.ZeroFactor = ZeroFactor;
exports.ZeroSlopeEnding = ZeroSlopeEnding;
exports.ZeroStencilOp = ZeroStencilOp;
exports._SRGBAFormat = _SRGBAFormat;
exports.sRGBEncoding = sRGBEncoding;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "init": () => (/* binding */ init)
/* harmony export */ });
/* harmony import */ var photo_sphere_viewer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! photo-sphere-viewer */ "./node_modules/photo-sphere-viewer/dist/photo-sphere-viewer.js");
/* harmony import */ var photo_sphere_viewer__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(photo_sphere_viewer__WEBPACK_IMPORTED_MODULE_0__);
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};

function requireElementIdType(id, constructor) {
    var elt = document.getElementById(id);
    if (!elt) {
        throw Error("Required dom element id=".concat(id, " not found"));
    }
    if (!(elt instanceof constructor)) {
        throw Error("Dom element id=".concat(id, " required to be of type ").concat(constructor.name, " but is ").concat(elt.constructor.name));
    }
    return elt;
}
// Wait for button to be clicked, and return the MouseEvent
function awaitButtonClick(button) {
    return new Promise(function (resolve, reject) {
        var listener = function (event) {
            button.removeEventListener("click", listener);
            resolve(event);
        };
        button.addEventListener("click", listener);
    });
}
// Wait for first button of buttons to be clicked, and return that button
function awaitFirstButtonClick(buttons) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, Promise.race(buttons.map(awaitButtonClick))];
                case 1: return [2 /*return*/, (_a.sent()).target];
            }
        });
    });
}
function readFileAsDataUrlAsync(file) {
    return new Promise(function (resolve, reject) {
        var reader = new FileReader();
        reader.onload = function () {
            resolve(reader.result);
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
    });
}
var barf2;
function upload() {
    return __awaiter(this, void 0, void 0, function () {
        var uploadDialog, fileInput, nameInput, cancelButton, uploadButton, clickedButton, minNameLen, name, file, uri, base64content, mimeType, upload, response;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    uploadDialog = requireElementIdType("uploadDialog", HTMLDivElement);
                    // Abort if the dialog is already up
                    if (uploadDialog.style.visibility == "visible")
                        return [2 /*return*/];
                    uploadDialog.style.visibility = "visible";
                    fileInput = requireElementIdType("panoramaFile", HTMLInputElement);
                    nameInput = requireElementIdType("uploadPanoramaName", HTMLInputElement);
                    cancelButton = requireElementIdType("uploadCancelButton", HTMLButtonElement);
                    uploadButton = requireElementIdType("uploadUploadButton", HTMLButtonElement);
                    fileInput.value = "";
                    nameInput.value = "";
                    _a.label = 1;
                case 1:
                    _a.trys.push([1, , 8, 9]);
                    _a.label = 2;
                case 2:
                    if (false) {}
                    return [4 /*yield*/, awaitFirstButtonClick([cancelButton, uploadButton])];
                case 3:
                    clickedButton = _a.sent();
                    if (clickedButton == cancelButton)
                        return [3 /*break*/, 7];
                    minNameLen = 4;
                    name = nameInput.value.trim();
                    if (!name || name.length < minNameLen) {
                        alert("Name must be at least ".concat(minNameLen, " characters long"));
                    }
                    console.log(fileInput);
                    file = fileInput.files[0];
                    if (!file) {
                        alert("Please select a panorama file to upload");
                        return [3 /*break*/, 2];
                    }
                    return [4 /*yield*/, readFileAsDataUrlAsync(file)];
                case 4:
                    uri = _a.sent();
                    base64content = uri.split(",")[1];
                    mimeType = uri.split(",")[0].split(":")[1].split(";")[0];
                    console.log("mimeType ".concat(mimeType));
                    if (!base64content || !mimeType) {
                        alert("Could not read your panorama file");
                        return [3 /*break*/, 2];
                    }
                    upload = {
                        name: name,
                        image: base64content,
                        mimeType: mimeType
                    };
                    console.log(upload);
                    return [4 /*yield*/, fetch("/upload", {
                            method: "POST",
                            body: JSON.stringify(upload),
                            headers: {
                                "Content-Type": "application/json"
                            }
                        })];
                case 5: return [4 /*yield*/, (_a.sent()).json()];
                case 6:
                    response = _a.sent();
                    console.log(response);
                    if (response && response["success"] == true) {
                        alert("Panorama uploaded successfully");
                        return [2 /*return*/];
                    }
                    else {
                        alert("Panorama not uploaded: ".concat(JSON.stringify(response)));
                    }
                    return [3 /*break*/, 2];
                case 7: return [3 /*break*/, 9];
                case 8:
                    uploadDialog.style.visibility = "hidden";
                    return [7 /*endfinally*/];
                case 9: return [2 /*return*/];
            }
        });
    });
}
function init(panorama) {
    requireElementIdType("upload", HTMLButtonElement).addEventListener("click", upload);
    console.log("the pano is", panorama);
    if (panorama) {
        var viewer = new photo_sphere_viewer__WEBPACK_IMPORTED_MODULE_0__.Viewer({
            container: requireElementIdType("panoviewer", HTMLDivElement),
            panorama: panorama.image_url
        });
        // @ts-ignore
        globalThis.viewer = viewer;
        //     panorama: 'path/to/panorama.jpg',
        //   });
    }
}
// @ts-ignore
globalThis.index_ts_init = init;

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxLQUE0RCxvQkFBb0IsbUJBQU8sQ0FBQyxtREFBTyxHQUFHLG1CQUFPLENBQUMsZ0RBQVE7QUFDcEgsRUFBRSxDQUMrSTtBQUNqSixDQUFDLDZDQUE2Qzs7QUFFOUM7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixlQUFlLHFDQUFxQztBQUNwRCxlQUFlLFNBQVM7QUFDeEIsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEMsZUFBZSxpQkFBaUI7QUFDaEMsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEMsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEMsZUFBZSxpQkFBaUI7QUFDaEMsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1QztBQUN2QztBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLHFDQUFxQztBQUNsRTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxrRUFBa0UsaUJBQWlCLGFBQWEsOEVBQThFLEdBQUc7QUFDakwsK0ZBQStGLHFFQUFxRSx1RUFBdUUsd0VBQXdFLHFCQUFxQixpQkFBaUIsdUZBQXVGLHNGQUFzRixxTUFBcU0sR0FBRztBQUM5c0IsT0FBTztBQUNQOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixlQUFlLHdCQUF3QjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QixnQkFBZ0IsVUFBVTtBQUMxQixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsU0FBUztBQUN6QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsVUFBVTtBQUMxQixpQkFBaUIsOENBQThDO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsV0FBVztBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHdCQUF3QjtBQUNyQyxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLFFBQVE7QUFDckI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsYUFBYSxhQUFhO0FBQzFCLGVBQWU7QUFDZjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx3QkFBd0I7QUFDckMsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEIsYUFBYSxXQUFXO0FBQ3hCLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCLGFBQWEsY0FBYztBQUMzQixlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGFBQWEsVUFBVTtBQUN2QixhQUFhLFVBQVU7QUFDdkIsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0QsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sYUFBYSxHQUFHO0FBQ2hCLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7O0FBR0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsZUFBZSxRQUFRO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEdBQUc7QUFDaEIsY0FBYztBQUNkOztBQUVBO0FBQ0EsMEVBQTBFLGFBQWE7QUFDdkY7QUFDQTs7QUFFQSx1Q0FBdUMscUJBQXFCO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBLDBEQUEwRCwyQkFBMkI7QUFDckY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhFQUE4RSxrQkFBa0I7QUFDaEc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHFCQUFxQjtBQUM3RDtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixhQUFhLGtCQUFrQjtBQUMvQixlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QixjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCLGVBQWUsUUFBUTtBQUN2QixjQUFjLGNBQWM7QUFDNUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDhDQUE4Qzs7QUFFOUM7QUFDQSxvRkFBb0Y7O0FBRXBGO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCLGVBQWU7QUFDZixjQUFjLGNBQWM7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzQ0FBc0M7QUFDbkQsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHdCQUF3QjtBQUNyQyxhQUFhLHNCQUFzQjtBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDLGFBQWEsT0FBTztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsVUFBVTtBQUNWO0FBQ0EsMERBQTBELGlCQUFpQjtBQUMzRSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUseUJBQXlCO0FBQ3hDLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSw0QkFBNEI7QUFDM0M7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7OztBQUdSOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFROzs7QUFHUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyx5QkFBeUI7QUFDN0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxtQ0FBbUM7QUFDbEQsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdCQUF3QjtBQUN2QyxlQUFlLFFBQVE7QUFDdkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0JBQXdCO0FBQ3ZDLGVBQWUsUUFBUTtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5QkFBeUI7QUFDeEMsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdCQUF3QjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxvQkFBb0IsU0FBUztBQUM3QixvQkFBb0IsUUFBUTtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGVBQWUsNkNBQTZDO0FBQzVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUscUNBQXFDO0FBQ3BELGVBQWUsU0FBUztBQUN4QixpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsa0JBQWtCO0FBQ2pDLGlCQUFpQjtBQUNqQixnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsY0FBYztBQUM3QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUJBQXFCO0FBQ3BDLGVBQWUsUUFBUTtBQUN2QixlQUFlLEdBQUc7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsK0NBQStDO0FBQzlELGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxvQkFBb0IsU0FBUztBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QyxlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUIsb0JBQW9CLFNBQVM7QUFDN0Isb0JBQW9CLFNBQVM7QUFDN0Isb0JBQW9CLFNBQVM7QUFDN0Isb0JBQW9CLFNBQVM7QUFDN0Isb0JBQW9CLFFBQVE7QUFDNUI7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBOztBQUVBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEM7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RDLGVBQWUsd0JBQXdCO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0EsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakMsZUFBZSxZQUFZO0FBQzNCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7O0FBRUE7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QyxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdDQUF3QztBQUM3RCxvQkFBb0IsY0FBYztBQUNsQzs7QUFFQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEMsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QixvQkFBb0IsY0FBYztBQUNsQzs7QUFFQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0EsT0FBTztBQUNQO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEMsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QixvQkFBb0IsU0FBUztBQUM3QixvQkFBb0IsUUFBUTtBQUM1QixvQkFBb0IsUUFBUTtBQUM1Qjs7QUFFQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQ0FBbUM7QUFDaEQsYUFBYSw4Q0FBOEM7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZDQUE2QztBQUM1RCxnQkFBZ0IsY0FBYztBQUM5Qjs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLHlEQUF5RDs7O0FBR3pEO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCLG9CQUFvQixRQUFRO0FBQzVCOzs7QUFHQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLEdBQUc7QUFDdkI7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHVDQUF1QztBQUN4RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QixvQkFBb0IsU0FBUztBQUM3Qjs7QUFFQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QixvQkFBb0IsUUFBUTtBQUM1QixvQkFBb0IsUUFBUTtBQUM1QixvQkFBb0IsU0FBUztBQUM3QixvQkFBb0IsVUFBVTtBQUM5QixvQkFBb0IsVUFBVTtBQUM5Qjs7QUFFQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQSxrREFBa0Q7OztBQUdsRDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTyxHQUFHOztBQUVWO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdFQUF3RTs7QUFFeEU7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7O0FBRTdFO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsaUJBQWlCO0FBQ2pCLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGlCQUFpQjtBQUNqQixnQkFBZ0IsY0FBYztBQUM5QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSx3QkFBd0I7QUFDdkMsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdCQUF3QjtBQUN2QyxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0JBQXdCO0FBQ3ZDLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckMsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixvQkFBb0IsUUFBUTtBQUM1QixvQkFBb0IsUUFBUTtBQUM1QixvQkFBb0IsU0FBUztBQUM3QixvQkFBb0IsUUFBUTtBQUM1QixvQkFBb0IsUUFBUTtBQUM1QixvQkFBb0IsUUFBUTtBQUM1QixvQkFBb0IsUUFBUTtBQUM1QixvQkFBb0IsWUFBWTtBQUNoQyxvQkFBb0IsUUFBUTtBQUM1QixvQkFBb0IsY0FBYztBQUNsQyxvQkFBb0IsU0FBUztBQUM3QixvQkFBb0IsZUFBZTtBQUNuQyxvQkFBb0IsUUFBUTtBQUM1QixvQkFBb0IsUUFBUTtBQUM1QixvQkFBb0IsUUFBUTtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQixlQUFlLEtBQUs7QUFDcEIsZUFBZSxhQUFhO0FBQzVCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEIsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQixlQUFlLEtBQUs7QUFDcEIsZUFBZSxhQUFhO0FBQzVCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEIsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkhBQTZIOztBQUU3SDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTs7QUFFQSxzQkFBc0IsbUNBQW1DO0FBQ3pEO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUMsMENBQTBDOzs7QUFHMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RCxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsOEJBQThCLElBQUksOEJBQThCO0FBQ3hFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUscUJBQXFCO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDLGVBQWUscUJBQXFCO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEMsZUFBZSxxQkFBcUI7QUFDcEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFOztBQUVqRTtBQUNBO0FBQ0Esc0RBQXNEOztBQUV0RDtBQUNBLG9HQUFvRzs7QUFFcEc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsZ0VBQWdFOzs7QUFHaEU7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseUJBQXlCO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsa0JBQWtCO0FBQ2pDLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGtCQUFrQjtBQUNqQyxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEI7O0FBRUE7QUFDQSxlQUFlLGlDQUFpQztBQUNoRDtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixHQUFHO0FBQ25COztBQUVBO0FBQ0E7QUFDQSwyREFBMkQsb0NBQW9DO0FBQy9GO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGdCQUFnQixnQ0FBZ0M7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCLG9CQUFvQixRQUFRO0FBQzVCLG9CQUFvQixRQUFRO0FBQzVCLG9CQUFvQixRQUFRO0FBQzVCLG9CQUFvQixRQUFRO0FBQzVCLG9CQUFvQixRQUFRO0FBQzVCLG9CQUFvQixHQUFHO0FBQ3ZCOztBQUVBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxvQ0FBb0M7QUFDbEYsZUFBZSwrQkFBK0I7QUFDOUM7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlDQUFpQztBQUNoRDtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQsb0RBQW9EOzs7QUFHcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLG9CQUFvQixRQUFRO0FBQzVCLG9CQUFvQixRQUFRO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrQkFBK0I7QUFDOUMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0EsK0JBQStCLHVFQUF1RTtBQUN0RztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLGFBQWE7QUFDNUI7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0Isb0JBQW9CLFNBQVM7QUFDN0Isb0JBQW9CLFNBQVM7QUFDN0Isb0JBQW9CLFNBQVM7QUFDN0Isb0JBQW9CLHdCQUF3QjtBQUM1QyxvQkFBb0IsUUFBUTtBQUM1QixvQkFBb0IsUUFBUTtBQUM1QixvQkFBb0IsUUFBUTtBQUM1QixvQkFBb0IsU0FBUztBQUM3QixvQkFBb0IscUJBQXFCO0FBQ3pDLG9CQUFvQixTQUFTO0FBQzdCLG9CQUFvQixTQUFTO0FBQzdCLG9CQUFvQixRQUFRO0FBQzVCLG9CQUFvQixRQUFRO0FBQzVCLG9CQUFvQixVQUFVO0FBQzlCLG9CQUFvQixjQUFjO0FBQ2xDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOzs7QUFHQSwyR0FBMkc7O0FBRTNHO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU8sUUFBUTs7QUFFZix1Q0FBdUM7OztBQUd2QztBQUNBO0FBQ0E7QUFDQSxvRkFBb0Y7QUFDcEYsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTyxHQUFHOztBQUVWLG9EQUFvRDs7O0FBR3BEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLEdBQUc7O0FBRVY7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EseURBQXlELE9BQU87QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1IscUNBQXFDOztBQUVyQztBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQ0FBMEM7QUFDekQsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsZUFBZSxxQkFBcUI7QUFDcEMsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpSEFBaUg7O0FBRWpIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLEtBQUs7QUFDcEI7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQyxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBLGtEQUFrRDs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsZUFBZTtBQUM5QixnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQsYUFBYTs7QUFFOUQsQ0FBQztBQUNEOzs7Ozs7Ozs7OztBQ2hyVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxLQUE0RDtBQUNoRSxJQUFJLENBQ3VHO0FBQzNHLENBQUMsOEJBQThCOztBQUUvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsR0FBRztBQUNwQixpQkFBaUIsUUFBUTtBQUN6QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isa0NBQWtDO0FBQ2xDO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixrQ0FBa0M7QUFDbEM7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLGlCQUFpQiwyQkFBMkI7QUFDNUM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQ0FBc0M7QUFDekQ7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DLGlCQUFpQixVQUFVO0FBQzNCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNDQUFzQztBQUMxRDtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQyxpQkFBaUIsVUFBVTtBQUMzQixrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNDQUFzQztBQUMzRDtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkMsaUJBQWlCLFVBQVU7QUFDM0Isa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekIsaUJBQWlCLE1BQU07QUFDdkIsa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJEQUEyRCxPQUFPO0FBQ2xFOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkRBQTJELFNBQVM7QUFDcEU7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCLGlCQUFpQixHQUFHO0FBQ3BCLGlCQUFpQixNQUFNO0FBQ3ZCLGtCQUFrQixHQUFHO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkRBQTJELE9BQU87QUFDbEU7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1EQUFtRCxhQUFhOztBQUVoRSxDQUFDO0FBQ0Q7Ozs7Ozs7Ozs7OztBQzVVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsOENBQTZDLEVBQUUsYUFBYSxFQUFDOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxnQ0FBZ0MsUUFBUTtBQUN4QyxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixZQUFZLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxPQUFPO0FBQzVEO0FBQ0EsZ0JBQWdCLGlCQUFpQixHQUFHLGlCQUFpQixHQUFHLGlCQUFpQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsaUNBQWlDO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7O0FBRUEsd0dBQXdHOztBQUV4Rzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFdBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJFQUEyRTtBQUMzRSwyRUFBMkU7QUFDM0UsMkVBQTJFO0FBQzNFLDJFQUEyRTtBQUMzRSwyRUFBMkU7QUFDM0UsMkVBQTJFO0FBQzNFLDJFQUEyRTtBQUMzRSwyRUFBMkU7O0FBRTNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFOztBQUV0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwQkFBMEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGlCQUFpQjtBQUNqQixnQkFBZ0I7QUFDaEIsY0FBYztBQUNkLGNBQWM7QUFDZCxpQkFBaUI7QUFDakIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE9BQU87QUFDckQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLDBCQUEwQjtBQUM3QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixtREFBbUQ7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDOztBQUUzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHlEQUF5RCxRQUFRO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHlEQUF5RCxRQUFRO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EseURBQXlELFFBQVE7QUFDakU7QUFDQTtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSxrREFBa0QsUUFBUTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaURBQWlEOztBQUVqRCwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7O0FBRWpELDhDQUE4QyxPQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSw2RkFBNkY7QUFDN0YsNkZBQTZGO0FBQzdGLDBGQUEwRjtBQUMxRiw0RkFBNEY7QUFDNUYsNEZBQTRGO0FBQzVGLDhGQUE4Rjs7QUFFOUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0EscUJBQXFCLGFBQWE7QUFDbEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFlBQVk7QUFDaEMscUJBQXFCLFlBQVk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsNkVBQTZFLEdBQUc7O0FBRW5ILHFDQUFxQyw4Q0FBOEMsR0FBRzs7QUFFdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsdUJBQXVCO0FBQ3ZCLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlFQUF5RTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsYUFBYTtBQUNoQztBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0Isb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrRkFBK0Y7O0FBRS9GLGdGQUFnRjs7QUFFaEYsNEZBQTRGOztBQUU1RiwrRUFBK0U7O0FBRS9FLCtIQUErSCx1REFBdUQsNkhBQTZILGlIQUFpSDs7QUFFcGEsdUVBQXVFLGlDQUFpQzs7QUFFeEcsd0RBQXdEOztBQUV4RCw2REFBNkQsaUVBQWlFOztBQUU5SCw4REFBOEQsd0NBQXdDLEdBQUcsZ0ZBQWdGLG9FQUFvRSxzREFBc0QsR0FBRyxrRkFBa0Ysb0VBQW9FLHNEQUFzRCxHQUFHLG1GQUFtRiw2Q0FBNkMscUJBQXFCLGlEQUFpRCxtREFBbUQsR0FBRyxtR0FBbUcsNkJBQTZCLGlFQUFpRSxpRUFBaUUseUNBQXlDLEdBQUcsNkRBQTZELDZCQUE2QixxREFBcUQsOENBQThDLEdBQUcsd0pBQXdKLG9DQUFvQyxtREFBbUQsc0RBQXNELHFEQUFxRCxxREFBcUQsc0RBQXNELHlDQUF5QywyREFBMkQsb0NBQW9DLHlCQUF5QixHQUFHLDRQQUE0UCxzQ0FBc0MscURBQXFELHdEQUF3RCx1REFBdUQsdURBQXVELHdEQUF3RCxtRkFBbUYsNkRBQTZELHNDQUFzQywyQkFBMkIsS0FBSyxxRkFBcUYsZ0NBQWdDLDBEQUEwRCwwQ0FBMEMsMENBQTBDLHFEQUFxRCxtQ0FBbUMsY0FBYyxHQUFHLHdEQUF3RCwwQkFBMEIscURBQXFELEdBQUcsdUVBQXVFLDRCQUE0Qix1QkFBdUIsNERBQTRELGdEQUFnRCxvQkFBb0IsK0ZBQStGLDRDQUE0QyxHQUFHLDZIQUE2SCxnREFBZ0QsZ0RBQWdELHVDQUF1QywyRUFBMkUsZ0JBQWdCLDBDQUEwQywwQkFBMEIseURBQXlELHFCQUFxQixnREFBZ0QsZ0RBQWdELGdEQUFnRCxnREFBZ0QsMkNBQTJDLDJDQUEyQywyQ0FBMkMsMkNBQTJDLHdDQUF3Qyw2RUFBNkUsNkVBQTZFLDZFQUE2RSw2RUFBNkUsbUVBQW1FLDBCQUEwQixHQUFHLGtDQUFrQyxnQkFBZ0IsR0FBRyx3RUFBd0UsK0VBQStFLEdBQUcsc0pBQXNKLG1EQUFtRCxxREFBcUQsc0RBQXNELG9EQUFvRCx1Q0FBdUMsK0NBQStDLHlCQUF5QixHQUFHLDZFQUE2RSxvQ0FBb0MsaUNBQWlDLGdDQUFnQyxnREFBZ0QsNEVBQTRFLEdBQUcsK0NBQStDLHlFQUF5RSxHQUFHLDBJQUEwSSxtREFBbUQsc0RBQXNELHFEQUFxRCxxREFBcUQsaURBQWlELHdDQUF3QyxrQ0FBa0MsR0FBRzs7QUFFMXlNLGtOQUFrTix5Q0FBeUMscUNBQXFDLGlFQUFpRSxLQUFLLGtFQUFrRSx5R0FBeUcsS0FBSyxvRUFBb0Usd0ZBQXdGLEtBQUssbURBQW1ELDRDQUE0Qyw0REFBNEQsNERBQTRELDREQUE0RCwwR0FBMEcseUlBQXlJLHVCQUF1QixxQ0FBcUMsaUJBQWlCLEtBQUssaUhBQWlILGFBQWEsaUdBQWlHLDRGQUE0Riw0Q0FBNEMsZ0NBQWdDLDRCQUE0QixPQUFPLDRDQUE0Qyw2REFBNkQsa0RBQWtELHNCQUFzQiw2QkFBNkIsd0JBQXdCLG9EQUFvRCwrQkFBK0IsbUVBQW1FLHVEQUF1RCxpREFBaUQsK0JBQStCLDJEQUEyRCwyREFBMkQsMkRBQTJELHVFQUF1RSx1Q0FBdUMsbURBQW1ELCtCQUErQiw0REFBNEQseUJBQXlCLGFBQWEsMEJBQTBCLHVCQUF1QixRQUFRLFFBQVEsbUJBQW1CLDhFQUE4RSxxQkFBcUIsT0FBTyxtQ0FBbUMsS0FBSzs7QUFFcjNGLDZFQUE2RSw0QkFBNEIsc0JBQXNCLCtCQUErQiwrQkFBK0IsMERBQTBELHdFQUF3RSx3RUFBd0UsOEJBQThCLEtBQUssNkZBQTZGLDBDQUEwQywwQ0FBMEMsMEJBQTBCLHFDQUFxQyxxQ0FBcUMsc0RBQXNELGtFQUFrRSwwREFBMEQsS0FBSzs7QUFFdDNCLDBFQUEwRSxrREFBa0QsMkJBQTJCLFFBQVEsa0NBQWtDLCtEQUErRCxLQUFLLHdHQUF3RywwRUFBMEUseUJBQXlCLFFBQVEsb0NBQW9DLDJFQUEyRSxPQUFPLDBEQUEwRDs7QUFFeG9CLCtGQUErRix1REFBdUQ7O0FBRXRKLDZGQUE2Rjs7QUFFN0YsOEZBQThGOztBQUU5RiwrRUFBK0UsMkRBQTJEOztBQUUxSSxpRkFBaUYsb0RBQW9EOztBQUVySSwrRUFBK0UsdUZBQXVGOztBQUV0SywyRUFBMkUsd0ZBQXdGLDhDQUE4Qyx5RUFBeUU7O0FBRTFSLHdYQUF3WCxhQUFhLGlDQUFpQyxhQUFhLG1DQUFtQyxlQUFlLG1DQUFtQyxnQkFBZ0IsZUFBZSxrQ0FBa0MscUNBQXFDLHFDQUFxQyxxQ0FBcUMsd0NBQXdDLDhEQUE4RCxtRUFBbUUsa0NBQWtDLEdBQUcsaUVBQWlFLHFCQUFxQixnREFBZ0QsNENBQTRDLHVEQUF1RCxLQUFLLGdDQUFnQyxlQUFlLG1CQUFtQixpQkFBaUIsSUFBSSx5QkFBeUIsdUJBQXVCLHdCQUF3Qix5QkFBeUIsMEJBQTBCLElBQUksMkJBQTJCLGtCQUFrQixnQkFBZ0IsaUJBQWlCLCtDQUErQyxZQUFZLDBEQUEwRCwwREFBMEQsR0FBRyxpRUFBaUUsMERBQTBELEdBQUcseUNBQXlDLGFBQWEsb0RBQW9ELG9EQUFvRCxvREFBb0QsZUFBZSxHQUFHLHdDQUF3QyxpRUFBaUUsK0JBQStCLEdBQUcsc0NBQXNDLGdDQUFnQyxHQUFHLGtDQUFrQywwREFBMEQsdUVBQXVFLHdCQUF3QixHQUFHOztBQUU5ekUsdUtBQXVLLDJDQUEyQyx5QkFBeUIsOENBQThDLDZGQUE2RiwyREFBMkQsUUFBUSxNQUFNLDZGQUE2RiwyREFBMkQsT0FBTyxrQkFBa0IsS0FBSyw4Q0FBOEMsY0FBYywwQkFBMEIsbUVBQW1FLFFBQVEseUJBQXlCLHVFQUF1RSxRQUFRLHlCQUF5QixxRUFBcUUsUUFBUSx5QkFBeUIscUVBQXFFLFFBQVEseUJBQXlCLHFFQUFxRSxRQUFRLE1BQU0sbUVBQW1FLE9BQU8sZ0NBQWdDLEtBQUssMkVBQTJFLHdDQUF3QyxnRUFBZ0UsaURBQWlELHNDQUFzQyxvRUFBb0UseUJBQXlCLHlCQUF5QixvQkFBb0IsT0FBTyw4QkFBOEIsbURBQW1ELDBEQUEwRCxpQ0FBaUMsa0NBQWtDLHlHQUF5RyxzREFBc0QsaUJBQWlCLHNiQUFzYixzQkFBc0IscUNBQXFDLDRHQUE0RyxRQUFRLG9DQUFvQyw0R0FBNEcsUUFBUSxvQ0FBb0MsNEdBQTRHLFFBQVEsb0NBQW9DLDRHQUE0RyxRQUFRLE1BQU0sK0NBQStDLEtBQUssaUJBQWlCLEtBQUssNkVBQTZFLGtGQUFrRixnQ0FBZ0Msa0NBQWtDLGdFQUFnRSwwQkFBMEIsbUNBQW1DLFFBQVEsTUFBTSx3RUFBd0Usd0RBQXdELE9BQU8sS0FBSzs7QUFFbnJILGtFQUFrRSwyREFBMkQscUdBQXFHLDhDQUE4QywrREFBK0QsK0RBQStELCtHQUErRyxxRUFBcUU7O0FBRWxrQixtR0FBbUcsb0NBQW9DLG1DQUFtQzs7QUFFMUssc0xBQXNMOztBQUV0TCx5R0FBeUcsK0NBQStDOztBQUV4Six5RkFBeUY7O0FBRXpGLDZFQUE2RTs7QUFFN0UscUVBQXFFLGlCQUFpQixHQUFHLHNDQUFzQyx1S0FBdUssR0FBRzs7QUFFelMsdUZBQXVGLDZCQUE2QixtSEFBbUgsUUFBUSxNQUFNLG9FQUFvRSxPQUFPLHlFQUF5RSxrR0FBa0csMkZBQTJGLHNEQUFzRCxtSUFBbUksMkNBQTJDLHVKQUF1SixrSUFBa0ksOEdBQThHOztBQUVqckMsc0ZBQXNGLDZCQUE2Qiw0REFBNEQsd0NBQXdDOztBQUV2Tiw0RUFBNEUsaU1BQWlNLG9DQUFvQyxxQ0FBcUM7O0FBRXRWLGtQQUFrUCxxQ0FBcUMsb0NBQW9DOztBQUUzVCxzR0FBc0csbUNBQW1DLDZCQUE2QixxSEFBcUgsUUFBUSxNQUFNLHlFQUF5RSxPQUFPLG9GQUFvRiw2RkFBNkYsc0ZBQXNGOztBQUVob0IsK0RBQStEOztBQUUvRCxpRUFBaUU7O0FBRWpFLDRJQUE0SSwwRUFBMEUsOEVBQThFOztBQUVwUyxpRUFBaUUsNEJBQTRCLGtEQUFrRCxxQ0FBcUMsMkJBQTJCOztBQUUvTSx5RkFBeUYsMEVBQTBFLGdEQUFnRCxnREFBZ0QsaUZBQWlGLCtDQUErQyw0RkFBNEYsYUFBYTs7QUFFNWUsaUdBQWlHLG9FQUFvRSx5REFBeUQ7O0FBRTlOLGdGQUFnRixvQ0FBb0M7O0FBRXBILHdEQUF3RCwyQ0FBMkMsK0NBQStDOztBQUVsSiwrREFBK0QsMEJBQTBCLHNCQUFzQiwyQkFBMkIsSUFBSSw0S0FBNEssNEVBQTRFLGdEQUFnRCx1RkFBdUYsR0FBRywyS0FBMksseUZBQXlGLEdBQUc7O0FBRXZ4QixvREFBb0QsaUNBQWlDLCtCQUErQix5RUFBeUUsbURBQW1ELGlEQUFpRCx1REFBdUQsdURBQXVELHVEQUF1RCwyREFBMkQsMkRBQTJELG9FQUFvRSwyREFBMkQsaUVBQWlFLGtCQUFrQixHQUFHLHVGQUF1Rix1RUFBdUUsbUVBQW1FLHNCQUFzQixHQUFHLHFFQUFxRSx3Q0FBd0Msc0JBQXNCLEdBQUcsNkhBQTZILGtJQUFrSSxtQ0FBbUMsNEZBQTRGLE9BQU8sNkJBQTZCLG1FQUFtRSx3RkFBd0YsT0FBTyxpQkFBaUIsYUFBYSxvSEFBb0gsaUVBQWlFLEdBQUcscURBQXFELHFCQUFxQixpQkFBaUIsTUFBTSxpRUFBaUUsNklBQTZJLDJDQUEyQyxtREFBbUQsMkJBQTJCLEtBQUsseURBQXlELG9CQUFvQixpQkFBaUIscUJBQXFCLGtCQUFrQixNQUFNLHVEQUF1RCwySEFBMkgsNkRBQTZELDZDQUE2Qyw4Q0FBOEMscUNBQXFDLG9HQUFvRyxxREFBcUQsS0FBSyx1REFBdUQsb0JBQW9CLHFCQUFxQixpQkFBaUIscUJBQXFCLGtCQUFrQixvQkFBb0Isd0JBQXdCLE1BQU0sb0RBQW9ELHdIQUF3SCw0REFBNEQsNkNBQTZDLG1FQUFtRSx1R0FBdUcsb0NBQW9DLGdEQUFnRCx3REFBd0Qsb0dBQW9HLHVEQUF1RCxRQUFRLE1BQU0sa0NBQWtDLDhCQUE4QixPQUFPLEtBQUssZ0VBQWdFLGlCQUFpQixvQkFBb0IscUJBQXFCLHNCQUFzQixNQUFNLDRCQUE0QiwwQkFBMEIsaUVBQWlFLDZEQUE2RCxxQkFBcUIsb0JBQW9CLHVCQUF1QixNQUFNLGdFQUFnRSxtR0FBbUcsdURBQXVELGtEQUFrRCw0RkFBNEYsd0JBQXdCLEtBQUs7O0FBRS93SixpSEFBaUgsbUhBQW1ILHFFQUFxRSxzREFBc0Qsc0NBQXNDLGlCQUFpQixrR0FBa0csK0ZBQStGLGtGQUFrRix5RUFBeUUsMEVBQTBFLGlEQUFpRCxzQ0FBc0MsaUJBQWlCOztBQUVwNkIsa0RBQWtELDJDQUEyQzs7QUFFN0YsNERBQTRELHVCQUF1QixzQkFBc0IsSUFBSSxzS0FBc0ssMEdBQTBHLHVGQUF1RixHQUFHLHFLQUFxSyx5RkFBeUYsR0FBRzs7QUFFeHRCLHlEQUF5RCwyQ0FBMkMsb0NBQW9DLHlDQUF5QywrQ0FBK0M7O0FBRWhPLDZEQUE2RCw2QkFBNkIsc0JBQXNCLHVCQUF1Qiw0QkFBNEIsMkJBQTJCLElBQUksa0xBQWtMLDRFQUE0RSxnREFBZ0QsdUZBQXVGLDhNQUE4TSxHQUFHLGlMQUFpTCx5RkFBeUYsR0FBRzs7QUFFcmlDLDBEQUEwRCx1RUFBdUUsaUZBQWlGLDhEQUE4RCxzREFBc0Qsd0NBQXdDLHNEQUFzRCxtQ0FBbUMsMkVBQTJFLCtDQUErQyxpSEFBaUgsbUhBQW1ILDhGQUE4RixtREFBbUQsNkNBQTZDLGlDQUFpQyw2TUFBNk0sMkZBQTJGLCtCQUErQixpRUFBaUUscURBQXFELHdDQUF3QyxnQ0FBZ0Msd0ZBQXdGLDhIQUE4SCxrRUFBa0UsMkVBQTJFLHFEQUFxRCwwRUFBMEUsdUVBQXVFLDZDQUE2Qyw4RkFBOEYsK05BQStOLDJFQUEyRSx5RUFBeUUsNkZBQTZGLDJFQUEyRSx1R0FBdUc7O0FBRS96Riw4REFBOEQsc0JBQXNCLG9CQUFvQix1QkFBdUIsc0JBQXNCLDhDQUE4QywrQkFBK0IsdUJBQXVCLHlCQUF5Qiw0REFBNEQsMkJBQTJCLGlDQUFpQyw4QkFBOEIseUJBQXlCLG9EQUFvRCwyQkFBMkIsd0NBQXdDLDhEQUE4RCw4QkFBOEIsc0JBQXNCLGdDQUFnQyw0QkFBNEIsY0FBYyx1Q0FBdUMsbUNBQW1DLCtGQUErRixxREFBcUQscUNBQXFDLCtHQUErRywyR0FBMkcsOEZBQThGLDBDQUEwQyxHQUFHLDJGQUEyRixxREFBcUQsMERBQTBELG9EQUFvRCxpQ0FBaUMsc0VBQXNFLGtEQUFrRCxlQUFlLEdBQUcsMEpBQTBKLHVEQUF1RCx1REFBdUQsR0FBRyxnVEFBZ1QsMk5BQTJOLCtEQUErRCwyRkFBMkYsdUNBQXVDLDZEQUE2RCw4QkFBOEIsMEJBQTBCLDZDQUE2QyxrREFBa0QsNEJBQTRCLDhCQUE4QixHQUFHLHlOQUF5TixvQ0FBb0Msc0NBQXNDLHdDQUF3Qyw2Q0FBNkMsK0NBQStDLGlEQUFpRCw0Q0FBNEMsMkNBQTJDLDJCQUEyQiwwREFBMEQsd0RBQXdELDBEQUEwRCwwREFBMEQscURBQXFELHVDQUF1Qyx1Q0FBdUMsb0hBQW9ILHlHQUF5RywwSEFBMEgsOElBQThJLEtBQUssc0xBQXNMLDRFQUE0RSxnREFBZ0QsaUhBQWlILHNEQUFzRCxrTUFBa00sdUxBQXVMLDhSQUE4UixvTUFBb00saUdBQWlHLEdBQUcsNktBQTZLLHlGQUF5RixHQUFHLHNPQUFzTywrTUFBK00sbUtBQW1LLGtEQUFrRCx1Q0FBdUMsK0RBQStELCtQQUErUCxnTEFBZ0wsd0VBQXdFLDJIQUEySCxtRUFBbUUsa0ZBQWtGLHlFQUF5RSxHQUFHLHFWQUFxVixrSEFBa0gsR0FBRzs7QUFFeGpRLHlEQUF5RCxzQ0FBc0MsMkJBQTJCLHVGQUF1RixxRUFBcUUsK0ZBQStGLGlEQUFpRCxpQ0FBaUMsTUFBTSxNQUFNLDhEQUE4RCxLQUFLLHVDQUF1QyxtSkFBbUoseUZBQXlGLEtBQUssb0NBQW9DLGdGQUFnRixxR0FBcUcsNERBQTRELHNCQUFzQixRQUFRLG9DQUFvQyw2REFBNkQsdUlBQXVJLHFUQUFxVCwrRUFBK0UsS0FBSyxnSEFBZ0gsbUJBQW1CLHdCQUF3Qix3QkFBd0Isa0dBQWtHLDREQUE0RCxxQkFBcUIsUUFBUSxrQ0FBa0MsMkRBQTJELDRmQUE0Zix5RkFBeUYseUZBQXlGLG1HQUFtRyxpTEFBaUwscU9BQXFPLCtFQUErRSxLQUFLLDZIQUE2SCwrR0FBK0csNERBQTRELG9CQUFvQixRQUFRLGdEQUFnRCx5RUFBeUUsaUpBQWlKLHlRQUF5USwrRUFBK0UsS0FBSyxzSUFBc0ksa0RBQWtELDBCQUEwQixRQUFRLDBDQUEwQyw4RUFBOEUsS0FBSywyR0FBMkcscUVBQXFFLHlFQUF5RSxxRkFBcUYscUJBQXFCLFFBQVEsNkZBQTZGLE9BQU8sbUhBQW1ILHlDQUF5Qzs7QUFFcndLLDJJQUEySSxzRUFBc0UsdUNBQXVDLDJKQUEySix1S0FBdUssNklBQTZJOztBQUV2c0IscUlBQXFJLHNKQUFzSjs7QUFFM1Isb01BQW9NOztBQUVwTSxpSUFBaUksNkJBQTZCLGlDQUFpQzs7QUFFL0wsa0hBQWtILG1DQUFtQywyQ0FBMkM7O0FBRWhNLHFIQUFxSCx3RUFBd0UsK0RBQStELDBGQUEwRix1Q0FBdUMsT0FBTzs7QUFFcFksdUZBQXVGLDhSQUE4UixrREFBa0Q7O0FBRXZhLGlFQUFpRTs7QUFFakUsbUtBQW1LLGlFQUFpRSwrRUFBK0U7O0FBRW5ULGdIQUFnSCxrREFBa0QsNERBQTREOztBQUU5TiwrREFBK0Qsa0ZBQWtGLHdDQUF3Qzs7QUFFekwsNEZBQTRGOztBQUU1RixpSUFBaUkscUJBQXFCLHdCQUF3QixRQUFRLDBKQUEwSiwwSkFBMEosaUJBQWlCOztBQUUzZiw4RkFBOEYsc0RBQXNELHdCQUF3QixRQUFRLGdJQUFnSSxPQUFPLHlFQUF5RSxnRUFBZ0UsZ0VBQWdFLGdFQUFnRTs7QUFFcGtCLGlHQUFpRywrRkFBK0YsaURBQWlELDRDQUE0QyxxR0FBcUcsNEVBQTRFLHVEQUF1RCwyREFBMkQsd0RBQXdELDZEQUE2RCxPQUFPLHdGQUF3Riw0REFBNEQ7O0FBRWgxQiw2RkFBNkYsc0RBQXNELHdCQUF3QixRQUFRLCtIQUErSCxPQUFPLHdFQUF3RSwrREFBK0QsK0RBQStELCtEQUErRCwrRkFBK0YsaUVBQWlFLGlFQUFpRSxpRUFBaUU7O0FBRWgyQixnRkFBZ0YseURBQXlELHFDQUFxQyxpREFBaUQsOENBQThDLDZEQUE2RCwyRUFBMkUsK0NBQStDLG1FQUFtRSw4Q0FBOEMsb0pBQW9KLDZEQUE2RDs7QUFFdHdCLGlIQUFpSCw2Q0FBNkMsdUVBQXVFLDBEQUEwRCxxR0FBcUcsMkJBQTJCLDhEQUE4RCwwRkFBMEYsNkhBQTZIOztBQUVwckIsd0VBQXdFLGtEQUFrRCw4QkFBOEI7O0FBRXhKLHNFQUFzRSxrREFBa0QsOEJBQThCOztBQUV0SixxRkFBcUYsdUVBQXVFLHVFQUF1RTs7QUFFbk8sbUZBQW1GLDZCQUE2QixvRUFBb0Usb05BQW9OLG9DQUFvQyxvQ0FBb0MsZ0NBQWdDLGdDQUFnQyx5QkFBeUIsbUNBQW1DLG1DQUFtQywrQ0FBK0MsK0NBQStDLGtEQUFrRCw4RUFBOEUsdUZBQXVGLEtBQUs7O0FBRXo2QixxR0FBcUc7O0FBRXJHLGtKQUFrSiw2Q0FBNkMsZ0ZBQWdGLHFIQUFxSDs7QUFFcFkseUZBQXlGLHVGQUF1RixpRkFBaUYsc0NBQXNDOztBQUV2UywrRkFBK0YsMkZBQTJGOztBQUUxTCwyREFBMkQsc0ZBQXNGLCtEQUErRDs7QUFFaE4sNkRBQTZELDJDQUEyQyxHQUFHLCtDQUErQywrQkFBK0IsR0FBRyx3Q0FBd0MsMENBQTBDLHlFQUF5RSx1RUFBdUUsc0NBQXNDLDRDQUE0QyxpREFBaUQsaUNBQWlDLHlCQUF5QixHQUFHLDhDQUE4QyxtQ0FBbUMsR0FBRywwQ0FBMEMsbUNBQW1DLEdBQUcsa0RBQWtELHVEQUF1RCxHQUFHLGtDQUFrQywwRUFBMEUsa0VBQWtFLEdBQUcsb0NBQW9DLGdFQUFnRSxHQUFHLG1HQUFtRyw2Q0FBNkMsR0FBRyx5R0FBeUcsK0NBQStDLEdBQUcsa0dBQWtHLG1FQUFtRSxHQUFHLHFHQUFxRyxnRUFBZ0UsR0FBRzs7QUFFcHdELHFHQUFxRzs7QUFFckcsaUVBQWlFLG9FQUFvRSxvREFBb0QsOENBQThDOztBQUV2TywrRkFBK0Y7O0FBRS9GLGlGQUFpRixvREFBb0QsZ0ZBQWdGLCtGQUErRixzQ0FBc0MsS0FBSzs7QUFFL1YsK0RBQStELGtGQUFrRix3Q0FBd0M7O0FBRXpMLDRGQUE0Rjs7QUFFNUYscUhBQXFILDhGQUE4RixxSUFBcUksb0VBQW9FLHFDQUFxQyx5QkFBeUIsK0JBQStCLDJCQUEyQiwyQkFBMkIsUUFBUSxzRkFBc0YsNEdBQTRHLDhCQUE4Qix5QkFBeUIsK0JBQStCLDJCQUEyQiwyQkFBMkIsUUFBUSx5RUFBeUUsK0dBQStHLGdFQUFnRSwrQkFBK0IseUJBQXlCLCtCQUErQiwyQkFBMkIsMkJBQTJCLCtCQUErQiw4QkFBOEIsUUFBUSw0RUFBNEUsa0ZBQWtGLDJFQUEyRSxLQUFLLDZEQUE2RCwwREFBMEQsS0FBSyxnRUFBZ0UsNEJBQTRCLDhEQUE4RCwyREFBMkQsZ0NBQWdDLG1EQUFtRCx5RUFBeUUsa0ZBQWtGLGdHQUFnRyw4RUFBOEUsT0FBTyx1QkFBdUIsS0FBSyx3SEFBd0gseUJBQXlCLHVDQUF1QyxrQ0FBa0MsNEhBQTRILDJDQUEyQyxzRUFBc0UsK0NBQStDLDBCQUEwQiw0RkFBNEYsaURBQWlELGlEQUFpRCxpREFBaUQsaURBQWlELDhCQUE4Qiw4QkFBOEIsOEJBQThCLDhCQUE4QixtaURBQW1pRCxtR0FBbUcsK0JBQStCLCtCQUErQixpQ0FBaUMsbURBQW1ELDRCQUE0QixnK0NBQWcrQyxnSEFBZ0gseUZBQXlGLG1CQUFtQixvQkFBb0IsS0FBSywrQ0FBK0MsMkJBQTJCLHFFQUFxRSwwQkFBMEIsb0RBQW9ELHlCQUF5Qiw0Q0FBNEMsMkNBQTJDLGtDQUFrQyx1REFBdUQsUUFBUSxpQ0FBaUMsa0NBQWtDLDZDQUE2QyxRQUFRLGlDQUFpQyxrQ0FBa0MsMkNBQTJDLHFDQUFxQyxPQUFPLGdFQUFnRSxLQUFLLDRLQUE0SywwRUFBMEUsNkNBQTZDLDJHQUEyRyxxQkFBcUIsK0NBQStDLGdMQUFnTCw0ekJBQTR6QiwyRkFBMkYsaUJBQWlCOztBQUVyalMsbUhBQW1ILHlEQUF5RCxtSUFBbUksb0VBQW9FLHFDQUFxQyx5QkFBeUIsK0JBQStCLDJCQUEyQiwyQkFBMkIsUUFBUSxzRkFBc0YsMEVBQTBFLHlCQUF5QiwrQkFBK0IsMkJBQTJCLDJCQUEyQixRQUFRLHlFQUF5RSw2R0FBNkcsZ0VBQWdFLCtCQUErQix5QkFBeUIsK0JBQStCLDJCQUEyQiwyQkFBMkIsK0JBQStCLDhCQUE4QixRQUFRLDRFQUE0RTs7QUFFeHpDLDRRQUE0USwrQkFBK0IsNkZBQTZGLDJCQUEyQixRQUFRLHlIQUF5SCx3RkFBd0YsS0FBSyx3SEFBd0gsMkJBQTJCLFFBQVEsMENBQTBDLG9MQUFvTCxvRkFBb0YsS0FBSywwSEFBMEgsNkJBQTZCLFFBQVEsbUhBQW1ILDRFQUE0RSxLQUFLOztBQUV0N0MsdURBQXVELHVCQUF1QixxR0FBcUcsa0RBQWtELDJCQUEyQixRQUFRLHNEQUFzRCx1TUFBdU0sS0FBSyxxR0FBcUcsa0RBQWtELDRCQUE0QixRQUFRLHdDQUF3QyxtS0FBbUssS0FBSyx3R0FBd0csa0RBQWtELDZCQUE2QixRQUFRLDBDQUEwQyx1T0FBdU8sS0FBSyxpRUFBaUUsR0FBRzs7QUFFOTZDLDJGQUEyRixpREFBaUQsaURBQWlELGlEQUFpRDs7QUFFOU8sMkVBQTJFLG1DQUFtQyx3Q0FBd0MsZ0NBQWdDLDRDQUE0Qyx3QkFBd0IsbURBQW1ELHNEQUFzRCxnREFBZ0QsZ0RBQWdELDJCQUEyQixzRUFBc0Usc0VBQXNFLHNFQUFzRSxzRUFBc0UseUNBQXlDLGtCQUFrQixLQUFLOztBQUV0ekIsc0dBQXNHLCtCQUErQixvREFBb0Qsb0RBQW9ELG9EQUFvRCxvREFBb0Qsc0RBQXNEOztBQUUzWSw4RUFBOEUsMENBQTBDLDBDQUEwQywwQ0FBMEMsMENBQTBDLDZEQUE2RCxzRUFBc0UsZ0dBQWdHOztBQUV6ZCxtREFBbUQsK0VBQStFLHVDQUF1QyxrQ0FBa0M7O0FBRTNNLHlGQUF5Rjs7QUFFekYsOEdBQThHOztBQUU5Ryx5SUFBeUksd0NBQXdDLHVDQUF1QyxHQUFHLDBDQUEwQyxpQ0FBaUMsdURBQXVELEdBQUcsaURBQWlELGlDQUFpQyw4Q0FBOEMsNEdBQTRHLEdBQUcsK0JBQStCLGlEQUFpRCx5REFBeUQsaUJBQWlCLEdBQUcsNENBQTRDLDhKQUE4SixxS0FBcUssdUNBQXVDLGlDQUFpQyxrQ0FBa0Msa0NBQWtDLDZCQUE2QixHQUFHLHlDQUF5QyxlQUFlOztBQUUvekMsNkZBQTZGLHFDQUFxQyxtQ0FBbUMsdURBQXVELGlEQUFpRCxpR0FBaUcsa0dBQWtHLHdDQUF3QywrQ0FBK0MsNkRBQTZELDBTQUEwUywwR0FBMEcsZ0ZBQWdGOztBQUV4a0Msd0ZBQXdGLDRCQUE0QixzQ0FBc0Msa0NBQWtDLHNFQUFzRSwwRUFBMEUsbURBQW1ELDZDQUE2Qyw2QkFBNkIsa0NBQWtDLGdDQUFnQyxnSkFBZ0osd0VBQXdFLHNCQUFzQiw0REFBNEQsNERBQTRELDREQUE0RCxvRUFBb0UsS0FBSywrRUFBK0UsNERBQTRELEtBQUsseUdBQXlHLHVHQUF1RyxtSEFBbUgsNEZBQTRGLGlCQUFpQixvS0FBb0ssMkNBQTJDLHdCQUF3QixRQUFRLE1BQU0scUZBQXFGLG9GQUFvRixzQ0FBc0MsT0FBTyxLQUFLLDRaQUE0WiwyRkFBMkYseURBQXlELDRFQUE0RSxtREFBbUQsOEJBQThCLDhCQUE4Qix3RkFBd0YsOElBQThJLDhFQUE4RSxzRkFBc0YsS0FBSzs7QUFFaG9HLHNHQUFzRzs7QUFFdEcsNEVBQTRFLGdDQUFnQyx1Q0FBdUM7O0FBRW5KLDJFQUEyRTs7QUFFM0Usa0dBQWtHOztBQUVsRyxpR0FBaUcsc0JBQXNCLDhCQUE4Qjs7QUFFckoscUhBQXFIOztBQUVySCxtTkFBbU4sOEVBQThFLDBEQUEwRDs7QUFFM1YsbUNBQW1DLDJCQUEyQixlQUFlLDZDQUE2QyxnREFBZ0QsR0FBRztBQUM3SywwQ0FBMEMsbUJBQW1CLGVBQWUseUNBQXlDLDJQQUEyUCxpRkFBaUY7O0FBRWpjLCtDQUErQyxrQ0FBa0Msa0VBQWtFLDBGQUEwRixHQUFHO0FBQ2hQLDBFQUEwRSxtRUFBbUUsbUNBQW1DLHFDQUFxQywrQkFBK0IsdURBQXVELG1JQUFtSSw2SEFBNkgsMERBQTBELHNDQUFzQyx1RUFBdUU7O0FBRWx0QiwrQ0FBK0Msa0NBQWtDLGtFQUFrRSwwRkFBMEYsR0FBRztBQUNoUCw4Q0FBOEMsc0JBQXNCLHdCQUF3QiwrQkFBK0IsZUFBZSxnR0FBZ0csNEJBQTRCLDhCQUE4Qix1RUFBdUU7O0FBRTNXLHVSQUF1UixlQUFlLDhjQUE4YyxHQUFHO0FBQ3Z2Qix1RUFBdUUsaVNBQWlTLGVBQWUsMkVBQTJFLDREQUE0RCxzTkFBc04sNEZBQTRGLGtGQUFrRixhQUFhOztBQUUvNEIsZ0VBQWdFLGtOQUFrTiw0Y0FBNGMsR0FBRztBQUNqdUIscUVBQXFFLDZCQUE2Qiw0QkFBNEIsOEJBQThCLG1PQUFtTywyRUFBMkUsMEpBQTBKLG9FQUFvRSw0QkFBNEIsMkNBQTJDLEdBQUc7O0FBRWx2QiwrQ0FBK0Msa0NBQWtDLGtFQUFrRSwyREFBMkQ7QUFDOU0sZ0RBQWdELCtCQUErQixrQ0FBa0Msa0RBQWtELDRDQUE0QyxvREFBb0QsdUVBQXVFOztBQUUxVSxzQ0FBc0MsK0JBQStCLDhCQUE4Qiw0TUFBNE0seUNBQXlDLHNQQUFzUDtBQUM5a0IseUNBQXlDLHdCQUF3Qix5QkFBeUIsMEJBQTBCLDhCQUE4QixnTEFBZ0wsOEZBQThGLGNBQWMsS0FBSyxxQ0FBcUMsaURBQWlELHFHQUFxRywyS0FBMks7O0FBRXp4QixtVkFBbVYsZ25CQUFnbkI7QUFDbjhCLHlDQUF5Qyx3QkFBd0IsOENBQThDLDhpQkFBOGlCLHdGQUF3Rix3U0FBd1MsOEVBQThFLDhGQUE4Riw2REFBNkQsOEZBQThGLHdEQUF3RCwwT0FBME87O0FBRXRvRCw4REFBOEQsNGFBQTRhLGtqQkFBa2pCLHFIQUFxSDtBQUNqcEMsMERBQTBELHdCQUF3Qix3QkFBd0IsbzBCQUFvMEIsd0ZBQXdGLHlHQUF5RywwQ0FBMEMsb2tCQUFva0IsME9BQTBPOztBQUV2OEQsNkRBQTZELCtVQUErVSxrakJBQWtqQixHQUFHO0FBQ2o4Qix5REFBeUQsd0JBQXdCLDJCQUEyQiw2QkFBNkIsNmJBQTZiLHdGQUF3RixpUkFBaVIsOERBQThELGlDQUFpQyx1RUFBdUUsc0VBQXNFLDZFQUE2RSxzRUFBc0UsNE1BQTRNOztBQUUxL0MsMEpBQTBKLDZSQUE2Uix5akJBQXlqQixXQUFXO0FBQzMvQiwwREFBMEQsMEhBQTBILCtQQUErUCwrTUFBK00sNENBQTRDLGFBQWE7O0FBRTNyQiw0REFBNEQsNGFBQTRhLGtqQkFBa2pCLHFIQUFxSDtBQUMvb0Msd0RBQXdELHdCQUF3Qix3QkFBd0IsMEJBQTBCLHdCQUF3QixrMEJBQWswQix3RkFBd0YseUdBQXlHLDBDQUEwQyxvb0JBQW9vQiwwT0FBME87O0FBRXJqRSwrREFBK0QseURBQXlELHFaQUFxWixrakJBQWtqQixzSkFBc0osV0FBVztBQUNodUMsdUhBQXVILHdCQUF3QiwwQkFBMEIsMEJBQTBCLHdCQUF3QixrQ0FBa0MsNkRBQTZELCtCQUErQixnRkFBZ0Ysa0ZBQWtGLG9FQUFvRSxxQ0FBcUMsOERBQThELGlDQUFpQyw4Q0FBOEMsOENBQThDLHNEQUFzRCxpQ0FBaUMsa0VBQWtFLG9GQUFvRiwrQ0FBK0MsZ2pDQUFnakMsd0ZBQXdGLHlHQUF5RywwQ0FBMEMsNHFCQUE0cUIseUZBQXlGLGtIQUFrSCw0RkFBNEYsc0VBQXNFLHNIQUFzSCxtRkFBbUYsa0hBQWtILHNOQUFzTjs7QUFFaDRILDJEQUEyRCw2WUFBNlksa2pCQUFrakIseUZBQXlGO0FBQ25sQyx1REFBdUQsd0JBQXdCLHdCQUF3Qix3dkJBQXd2Qix3RkFBd0YseUdBQXlHLDBDQUEwQyw4aEJBQThoQiw0TUFBNE07O0FBRXB6RCxxQ0FBcUMsc0JBQXNCLDRNQUE0TSw0S0FBNEssaUdBQWlHLHNFQUFzRSwwSUFBMEk7QUFDcHVCLHlDQUF5Qyx3QkFBd0IsMlBBQTJQLDRFQUE0RSxpREFBaUQsMEtBQTBLLDJLQUEySzs7QUFFOXdCLHFMQUFxTCxtWEFBbVg7QUFDeGlCLHVDQUF1Qyx3QkFBd0IsNk1BQTZNLHNFQUFzRSxrR0FBa0c7O0FBRXBiLHlDQUF5QyxzQkFBc0IscUtBQXFLLDJGQUEyRixlQUFlLDJGQUEyRiwyRkFBMkYsa0dBQWtHLG1EQUFtRCx3RkFBd0YseUJBQXlCLGtHQUFrRyxrR0FBa0cscUNBQXFDLGdEQUFnRCxrR0FBa0c7QUFDcm9DLHlDQUF5Qyx3QkFBd0Isa1JBQWtSLDRFQUE0RSxpREFBaUQsb0tBQW9LLGdJQUFnSTs7QUFFcHZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQix3QkFBd0I7QUFDeEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCLGdCQUFnQjtBQUNoQixlQUFlO0FBQ2YsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLHdCQUF3QjtBQUN4QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsZ0JBQWdCO0FBQ2hCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQix3QkFBd0I7QUFDeEIsb0JBQW9CO0FBQ3BCLHFCQUFxQjtBQUNyQix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGdCQUFnQjtBQUNoQixhQUFhO0FBQ2I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1DQUFtQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHVCQUF1QixtQ0FBbUM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUNBQW1DO0FBQ3pEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSx1QkFBdUIsbUNBQW1DO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsdUJBQXVCLG1DQUFtQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQ0FBbUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsZUFBZTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNEJBQTRCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRCQUE0QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxhQUFhLGdEQUFnRCxTQUFTLHFDQUFxQyxZQUFZO0FBQ3hKO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZUFBZTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQixPQUFPOztBQUU1Qjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsMkJBQTJCO0FBQzNCOztBQUVBOztBQUVBOztBQUVBOztBQUVBLCtCQUErQjs7QUFFL0IsS0FBSzs7QUFFTDtBQUNBLDBCQUEwQjs7QUFFMUIsS0FBSzs7QUFFTCx5QkFBeUI7O0FBRXpCLEtBQUs7O0FBRUw7QUFDQSwwQkFBMEI7O0FBRTFCLEtBQUs7O0FBRUw7QUFDQSwwQkFBMEI7O0FBRTFCLEtBQUs7O0FBRUwseUJBQXlCOztBQUV6Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUJBQW1CLDZCQUE2QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGVBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQSxpQkFBaUIsZ0NBQWdDLEVBQUUsS0FBSyxJQUFJLFNBQVM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHVEQUF1RDtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHFEQUFxRDtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHlGQUF5RixvQkFBb0Isb0JBQW9CLFdBQVc7QUFDNUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQkFBbUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxRUFBcUUsNkNBQTZDO0FBQ2xIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsNmlIQUE2aUgsaUNBQWlDLGtDQUFrQyw0QkFBNEIsOEJBQThCLGdDQUFnQyxnQ0FBZ0MsNERBQTRELDJFQUEyRSxzQ0FBc0MsMEJBQTBCLHNCQUFzQixrREFBa0Qsc0VBQXNFLHdEQUF3RCx1SEFBdUgsaUNBQWlDLGlDQUFpQyxpQ0FBaUMsOERBQThELGtDQUFrQyxrQ0FBa0Msa0NBQWtDLDRDQUE0QyxrQ0FBa0Msa0NBQWtDLGtDQUFrQywwRUFBMEUsK0JBQStCO0FBQ2h2Siw4L0dBQTgvRyxnQ0FBZ0MsZ0NBQWdDO0FBQzlqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvREFBb0Q7QUFDcEQsb0lBQW9JO0FBQ3BJO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBEQUEwRCxRQUFRO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsd0NBQXdDLEdBQUc7QUFDeEUsZ0RBQWdELDBCQUEwQix1QkFBdUIsbUNBQW1DLCtDQUErQyxxQkFBcUIsNkJBQTZCLG9FQUFvRSxpREFBaUQseUJBQXlCLGFBQWEsUUFBUSw4Q0FBOEMseUtBQXlLLCtCQUErQiwwRkFBMEYsa0pBQWtKLHNCQUFzQixzQ0FBc0MsaUJBQWlCLDBCQUEwQiwwQ0FBMEMsdURBQXVELDREQUE0RCxHQUFHOztBQUVqbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0REFBNEQ7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUc7QUFDbkcsa0lBQWtJOztBQUVsSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxnREFBZ0Q7QUFDaEQ7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQSxxQkFBcUIsb0JBQW9CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsMEJBQTBCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsd0JBQXdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0osd0NBQXdDO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVHQUF1Rzs7QUFFdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQix3QkFBd0I7QUFDeEIsdUJBQXVCOztBQUV2Qix1Q0FBdUMsT0FBTztBQUM5QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBLHNCQUFzQjtBQUN0QixJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLHlCQUF5QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0ZBQWtGLFNBQVM7O0FBRTNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLCtDQUErQzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUIsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUNBQXFDLFFBQVE7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDQUErQztBQUMvQztBQUNBO0FBQ0EsMERBQTBEO0FBQzFELHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDJCQUEyQjtBQUN0RDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsbURBQW1ELE9BQU87QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEtBQUsseUJBQXlCO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTs7QUFFN0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxtQkFBbUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBLDhDQUE4Qzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQix3QkFBd0I7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLGNBQWM7QUFDaEMsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixlQUFlO0FBQ3hDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLG9CQUFvQjtBQUN2QyxvQkFBb0Isb0JBQW9CO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIscUJBQXFCO0FBQ3hDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsSUFBSTtBQUNKLDRCQUE0QjtBQUM1Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsVUFBVTtBQUM3QixvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixxQkFBcUI7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIseUJBQXlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsNEJBQTRCLEdBQUcsNEJBQTRCLEdBQUcsNEJBQTRCO0FBQzdHLG1CQUFtQiw0QkFBNEIsR0FBRyw0QkFBNEIsR0FBRyw0QkFBNEI7QUFDN0csbUJBQW1CLDRCQUE0QixHQUFHLDRCQUE0QixHQUFHLDRCQUE0Qjs7QUFFN0c7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUyxHQUFHLFNBQVM7QUFDMUMsNEJBQTRCLFNBQVMsR0FBRyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGNBQWM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCLEdBQUc7QUFDSCxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0JBQStCO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDLHFEQUFxRDtBQUNyRCxxREFBcUQ7QUFDckQscURBQXFEO0FBQ3JELHFEQUFxRDs7QUFFckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsT0FBTztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLDBCQUEwQjtBQUMxQixvQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0lBQStJO0FBQy9JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw2QkFBNkI7O0FBRTdCLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELFFBQVE7QUFDdkU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0EsOERBQThELFFBQVE7QUFDdEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLG1CQUFtQjtBQUN0QywrQkFBK0IsT0FBTzs7QUFFdEM7QUFDQTtBQUNBOztBQUVBOztBQUVBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsWUFBWTtBQUMvQixvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLG9CQUFvQjtBQUN0QyxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBOztBQUVBOztBQUVBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUE7O0FBRUEscUJBQXFCLFVBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxQkFBcUIsVUFBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUEscUJBQXFCLFVBQVU7QUFDL0I7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFCQUFxQixVQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFEQUFxRCxRQUFRO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0Isa0JBQWtCO0FBQ3BDLG1CQUFtQixvQkFBb0I7QUFDdkM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBLDhDQUE4Qzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBOztBQUVBOztBQUVBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQzs7QUFFQTs7QUFFQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQixxQkFBcUI7QUFDeEMsb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixxQkFBcUI7QUFDdkMsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixxQkFBcUI7QUFDdkMsbUJBQW1CLHNCQUFzQjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0Isc0JBQXNCO0FBQ3hDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLHNCQUFzQjtBQUN4QyxtQkFBbUIscUJBQXFCO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekMsb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7O0FBRUEsd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELE9BQU87QUFDbEUsc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25ELHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVEsR0FBRyxRQUFRLEdBQUcsUUFBUSxHQUFHLE1BQU0sR0FBRyxNQUFNLEdBQUcsTUFBTTtBQUMzRSxrQkFBa0IsTUFBTSxHQUFHLE1BQU0sR0FBRyxNQUFNLEdBQUcsUUFBUSxHQUFHLFFBQVEsR0FBRyxRQUFRLEdBQUc7O0FBRTlFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCOztBQUVBLDJDQUEyQztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsdUJBQXVCO0FBQ3ZEO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxpQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlCQUFpQix3QkFBd0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBOztBQUVBLGtDQUFrQztBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLE1BQU07O0FBRU47O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiwrQkFBK0I7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsU0FBUztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsYUFBYTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHVGQUF1RixjQUFjO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZ0JBQWdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRCQUE0QjtBQUM5Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMEJBQTBCO0FBQzFDO0FBQ0Esc0JBQXNCLDBDQUEwQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNENBQTRDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix3QkFBd0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixnREFBZ0QsUUFBUTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxzQ0FBc0MsYUFBYSxtQkFBbUIsZ0JBQWdCLElBQUksb0JBQW9CO0FBQzlHO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsV0FBVztBQUNoQztBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMEJBQTBCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0Q7O0FBRWxEO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQSxpRUFBaUU7QUFDakU7QUFDQSxnRUFBZ0U7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixzRUFBc0UsVUFBVTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNkJBQTZCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRCxTQUFTO0FBQ3pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QyxHQUFHO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsU0FBUztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLFNBQVM7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxTQUFTO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsU0FBUztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLFNBQVM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxQkFBcUIseUJBQXlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQSxpQ0FBaUM7O0FBRWpDLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsMEJBQTBCLGFBQWE7QUFDdkMsdUJBQXVCO0FBQ3ZCLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUNBQW1DLFNBQVM7QUFDNUM7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUNBQW1DLFNBQVM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQ0FBbUMsU0FBUztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTCxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxTQUFTO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQix1QkFBdUI7QUFDdkIsdUJBQXVCOztBQUV2QixrQ0FBa0M7O0FBRWxDLGdDQUFnQztBQUNoQyw4QkFBOEI7QUFDOUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQix3QkFBd0I7QUFDeEIsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sTUFBTTtBQUNOOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCO0FBQ0Esb0NBQW9DOztBQUVwQyxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGtCQUFrQiwwQkFBMEI7QUFDNUMsOEJBQThCO0FBQzlCOztBQUVBLHFDQUFxQztBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLElBQUk7QUFDSixVQUFVO0FBQ1Y7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHVIQUF1SDtBQUN2SDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsc0JBQXNCO0FBQ3RCLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxPQUFPO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrQkFBa0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDRCQUE0QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxnRkFBZ0Y7QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGdCQUFnQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxtQkFBbUIsYUFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0IsV0FBVztBQUM3QjtBQUNBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQSw2REFBNkQ7O0FBRTdEOztBQUVBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0EsOERBQThEOztBQUU5RDs7QUFFQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBLDhEQUE4RDs7QUFFOUQ7O0FBRUE7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQSxxREFBcUQ7O0FBRXJEOztBQUVBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0EsK0NBQStDOztBQUUvQzs7QUFFQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBLHdEQUF3RDs7QUFFeEQ7O0FBRUE7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQSx3REFBd0Q7O0FBRXhEO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0Esd0RBQXdEOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxhQUFhO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0Msc0JBQXNCO0FBQ3RCLE9BQU87QUFDUDtBQUNBLHVDQUF1QztBQUN2QztBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLE1BQU07QUFDTjtBQUNBLDJDQUEyQztBQUMzQztBQUNBLDBIQUEwSDtBQUMxSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGFBQWE7QUFDNUQ7QUFDQTtBQUNBLCtDQUErQyxhQUFhO0FBQzVEO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0EseUJBQXlCLDBCQUEwQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0IsbUJBQW1CO0FBQ25CLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBLG9CQUFvQjtBQUNwQixtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLDZCQUE2QjtBQUM3QixtQkFBbUI7QUFDbkIsb0JBQW9CO0FBQ3BCLGtDQUFrQztBQUNsQyx3QkFBd0I7QUFDeEIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQix5QkFBeUI7QUFDekIsb0JBQW9CO0FBQ3BCLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsdUJBQXVCO0FBQ3ZCLHNCQUFzQjtBQUN0Qiw0QkFBNEI7QUFDNUIsc0JBQXNCO0FBQ3RCLGdCQUFnQjtBQUNoQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLGFBQWE7QUFDYixxQkFBcUI7QUFDckIsb0JBQW9CO0FBQ3BCLHFCQUFxQjtBQUNyQixtQkFBbUI7QUFDbkIsa0JBQWtCO0FBQ2xCLGdCQUFnQjtBQUNoQix5QkFBeUI7QUFDekIsc0JBQXNCO0FBQ3RCLFlBQVk7QUFDWiw0QkFBNEI7QUFDNUIsWUFBWTtBQUNaLFlBQVk7QUFDWixrQkFBa0I7QUFDbEIseUJBQXlCO0FBQ3pCLG1CQUFtQjtBQUNuQixpQkFBaUI7QUFDakIsdUJBQXVCO0FBQ3ZCLHNCQUFzQjtBQUN0Qiw0QkFBNEI7QUFDNUIsZ0JBQWdCO0FBQ2hCLGFBQWE7QUFDYixjQUFjO0FBQ2Qsb0JBQW9CO0FBQ3BCLHFCQUFxQjtBQUNyQiw2QkFBNkI7QUFDN0IsdUJBQXVCO0FBQ3ZCLHdCQUF3QjtBQUN4Qix5QkFBeUI7QUFDekIsNEJBQTRCO0FBQzVCLHNCQUFzQjtBQUN0QiwyQkFBMkI7QUFDM0IsYUFBYTtBQUNiLGFBQWE7QUFDYiwwQkFBMEI7QUFDMUIsdUJBQXVCO0FBQ3ZCLDhCQUE4QjtBQUM5Qix5QkFBeUI7QUFDekIsK0JBQStCO0FBQy9CLDBCQUEwQjtBQUMxQixvQkFBb0I7QUFDcEIsa0JBQWtCO0FBQ2xCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsbUJBQW1CO0FBQ25CLHlCQUF5QjtBQUN6QiwrQkFBK0I7QUFDL0Isd0JBQXdCO0FBQ3hCLHlCQUF5QjtBQUN6Qix3QkFBd0I7QUFDeEIsb0JBQW9CO0FBQ3BCLHFCQUFxQjtBQUNyQix5QkFBeUI7QUFDekIsb0JBQW9CO0FBQ3BCLGFBQWE7QUFDYixpQkFBaUI7QUFDakIsc0JBQXNCO0FBQ3RCLHlCQUF5QjtBQUN6Qiw4QkFBOEI7QUFDOUIsd0JBQXdCO0FBQ3hCLG1CQUFtQjtBQUNuQixxQkFBcUI7QUFDckIsd0JBQXdCO0FBQ3hCLG1CQUFtQjtBQUNuQiwwQkFBMEI7QUFDMUIscUJBQXFCO0FBQ3JCLHlCQUF5QjtBQUN6QixpQkFBaUI7QUFDakIsMEJBQTBCO0FBQzFCLDhCQUE4QjtBQUM5Qiw2QkFBNkI7QUFDN0IsbUJBQW1CO0FBQ25CLDBCQUEwQjtBQUMxQixvQkFBb0I7QUFDcEIsd0JBQXdCO0FBQ3hCLDhCQUE4QjtBQUM5QiwyQkFBMkI7QUFDM0Isa0NBQWtDO0FBQ2xDLDRCQUE0QjtBQUM1QixrQkFBa0I7QUFDbEIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0Qix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4QixxQkFBcUI7QUFDckIsb0JBQW9CO0FBQ3BCLGtCQUFrQjtBQUNsQix3QkFBd0I7QUFDeEIsd0NBQXdDO0FBQ3hDLHdDQUF3QztBQUN4QyxhQUFhO0FBQ2IsdUJBQXVCO0FBQ3ZCLDZCQUE2QjtBQUM3Qix1QkFBdUI7QUFDdkIsa0JBQWtCO0FBQ2xCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLGlCQUFpQjtBQUNqQixXQUFXO0FBQ1gsZUFBZTtBQUNmLDBCQUEwQjtBQUMxQixpQkFBaUI7QUFDakIsZUFBZTtBQUNmLHlCQUF5QjtBQUN6QixhQUFhO0FBQ2IsYUFBYTtBQUNiLG9CQUFvQjtBQUNwQix5QkFBeUI7QUFDekIsK0JBQStCO0FBQy9CLDBCQUEwQjtBQUMxQixrQkFBa0I7QUFDbEIsYUFBYTtBQUNiLHFCQUFxQjtBQUNyQix1QkFBdUI7QUFDdkIsNkJBQTZCO0FBQzdCLDRCQUE0QjtBQUM1QixpQ0FBaUM7QUFDakMsMkJBQTJCO0FBQzNCLHlCQUF5QjtBQUN6QixtQkFBbUI7QUFDbkIsa0JBQWtCO0FBQ2xCLDZCQUE2QjtBQUM3QiwwQkFBMEI7QUFDMUIsOEJBQThCO0FBQzlCLGdDQUFnQztBQUNoQywrQkFBK0I7QUFDL0Isa0NBQWtDO0FBQ2xDLHFCQUFxQjtBQUNyQiw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCLDJCQUEyQjtBQUMzQixlQUFlO0FBQ2YseUJBQXlCO0FBQ3pCLGtDQUFrQztBQUNsQyxtQkFBbUI7QUFDbkIsMkJBQTJCO0FBQzNCLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIsdUJBQXVCO0FBQ3ZCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIsV0FBVztBQUNYLDJCQUEyQjtBQUMzQixxQkFBcUI7QUFDckIsY0FBYztBQUNkLGlCQUFpQjtBQUNqQixzQkFBc0I7QUFDdEIsNEJBQTRCO0FBQzVCLHVCQUF1QjtBQUN2QixhQUFhO0FBQ2Isa0JBQWtCO0FBQ2xCLFlBQVk7QUFDWixhQUFhO0FBQ2IseUJBQXlCO0FBQ3pCLGlCQUFpQjtBQUNqQixrQkFBa0I7QUFDbEIsMEJBQTBCO0FBQzFCLGdCQUFnQjtBQUNoQixvQkFBb0I7QUFDcEIsc0JBQXNCO0FBQ3RCLG9CQUFvQjtBQUNwQix5QkFBeUI7QUFDekIsZ0NBQWdDO0FBQ2hDLGlDQUFpQztBQUNqQyxnQ0FBZ0M7QUFDaEMsaUNBQWlDO0FBQ2pDLDRCQUE0QjtBQUM1Qix5QkFBeUI7QUFDekIsY0FBYztBQUNkLG1CQUFtQjtBQUNuQixzQkFBc0I7QUFDdEIsZ0JBQWdCO0FBQ2hCLG9CQUFvQjtBQUNwQixrQkFBa0I7QUFDbEIsNEJBQTRCO0FBQzVCLHVCQUF1QjtBQUN2QixhQUFhO0FBQ2IsZ0JBQWdCO0FBQ2hCLHNCQUFzQjtBQUN0QixpQkFBaUI7QUFDakIsZUFBZTtBQUNmLGVBQWU7QUFDZixtQkFBbUI7QUFDbkIsWUFBWTtBQUNaLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIsNEJBQTRCO0FBQzVCLDJCQUEyQjtBQUMzQiwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLHlCQUF5QjtBQUN6Qiw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCLHdCQUF3QjtBQUN4QixtQkFBbUI7QUFDbkIsOEJBQThCO0FBQzlCLG9CQUFvQjtBQUNwQix3QkFBd0I7QUFDeEIseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQixpQ0FBaUM7QUFDakMsa0NBQWtDO0FBQ2xDLGlDQUFpQztBQUNqQyxrQ0FBa0M7QUFDbEMsa0JBQWtCO0FBQ2xCLHdCQUF3QjtBQUN4QixrQkFBa0I7QUFDbEIsb0JBQW9CO0FBQ3BCLHFCQUFxQjtBQUNyQixnQ0FBZ0M7QUFDaEMsc0JBQXNCO0FBQ3RCLHFCQUFxQjtBQUNyQiwyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCLGdCQUFnQjtBQUNoQixvQkFBb0I7QUFDcEIsNEJBQTRCO0FBQzVCLGdDQUFnQztBQUNoQywwQkFBMEI7QUFDMUIsaUJBQWlCO0FBQ2pCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5QiwwQkFBMEI7QUFDMUIsb0JBQW9CO0FBQ3BCLHdCQUF3QjtBQUN4QixzQkFBc0I7QUFDdEIsWUFBWTtBQUNaLHlCQUF5QjtBQUN6QixhQUFhO0FBQ2IsMkJBQTJCO0FBQzNCLHFCQUFxQjtBQUNyQixtQkFBbUI7QUFDbkIsa0JBQWtCO0FBQ2xCLHdCQUF3QjtBQUN4QixjQUFjO0FBQ2Qsc0JBQXNCO0FBQ3RCLHVCQUF1QjtBQUN2QixnQ0FBZ0M7QUFDaEMsMEJBQTBCO0FBQzFCLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkIscUJBQXFCO0FBQ3JCLDRCQUE0QjtBQUM1Qiw2QkFBNkI7QUFDN0Isa0JBQWtCO0FBQ2xCLCtCQUErQjtBQUMvQixtQ0FBbUM7QUFDbkMsZ0JBQWdCO0FBQ2hCLHdCQUF3QjtBQUN4QixrQkFBa0I7QUFDbEIseUJBQXlCO0FBQ3pCLDhCQUE4QjtBQUM5Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUIsd0JBQXdCO0FBQ3hCLDRCQUE0QjtBQUM1QixnQ0FBZ0M7QUFDaEMsZ0NBQWdDO0FBQ2hDLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLGlCQUFpQjtBQUNqQix1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCLCtCQUErQjtBQUMvQiwrQkFBK0I7QUFDL0IsNEJBQTRCO0FBQzVCLGdCQUFnQjtBQUNoQix1QkFBdUI7QUFDdkIseUJBQXlCO0FBQ3pCLFdBQVc7QUFDWCxpQkFBaUI7QUFDakIscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQix3QkFBd0I7QUFDeEIsMkJBQTJCO0FBQzNCLHNCQUFzQjtBQUN0Qix3QkFBd0I7QUFDeEIsK0JBQStCO0FBQy9CLDBCQUEwQjtBQUMxQixvQkFBb0I7QUFDcEIsc0JBQXNCO0FBQ3RCLGFBQWE7QUFDYixtQkFBbUI7QUFDbkIsaUJBQWlCO0FBQ2pCLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsYUFBYTtBQUNiLDJCQUEyQjtBQUMzQixxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGtCQUFrQjtBQUNsQixpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCLHNCQUFzQjtBQUN0QixtQkFBbUI7QUFDbkIsY0FBYztBQUNkLGNBQWM7QUFDZCw0QkFBNEI7QUFDNUIsc0JBQXNCO0FBQ3RCLGlCQUFpQjtBQUNqQiwyQkFBMkI7QUFDM0IsbUJBQW1CO0FBQ25CLGlCQUFpQjtBQUNqQix1QkFBdUI7QUFDdkIsY0FBYztBQUNkLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsOEJBQThCO0FBQzlCLHNCQUFzQjtBQUN0Qix1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2QixvQkFBb0I7QUFDcEIsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkIsMkJBQTJCO0FBQzNCLHdCQUF3QjtBQUN4QiwyQkFBMkI7QUFDM0IsYUFBYTtBQUNiLDZCQUE2QjtBQUM3QixpQ0FBaUM7QUFDakMsMkJBQTJCO0FBQzNCLGVBQWU7QUFDZixxQkFBcUI7QUFDckIsMkJBQTJCO0FBQzNCLHFCQUFxQjtBQUNyQiwrQkFBK0I7QUFDL0IseUJBQXlCO0FBQ3pCLGdCQUFnQjtBQUNoQiwyQkFBMkI7QUFDM0IsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QiwwQkFBMEI7QUFDMUIsb0JBQW9CO0FBQ3BCLGlCQUFpQjtBQUNqQiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDRCQUE0QjtBQUM1QixtQ0FBbUM7QUFDbkMsZUFBZTtBQUNmLHFCQUFxQjtBQUNyQixtQkFBbUI7QUFDbkIscUJBQXFCO0FBQ3JCLHdCQUF3QjtBQUN4QiwwQkFBMEI7QUFDMUIsdUJBQXVCO0FBQ3ZCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCLG9CQUFvQjtBQUNwQixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZiwyQkFBMkI7QUFDM0Isb0JBQW9CO0FBQ3BCLHNCQUFzQjtBQUN0QiwyQkFBMkI7QUFDM0IsOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3QixrQ0FBa0M7QUFDbEMsb0NBQW9DO0FBQ3BDLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsa0JBQWtCO0FBQ2xCLHlCQUF5QjtBQUN6Qix3QkFBd0I7QUFDeEIsMkJBQTJCO0FBQzNCLGtCQUFrQjtBQUNsQix1QkFBdUI7QUFDdkIscUJBQXFCO0FBQ3JCLG9CQUFvQjtBQUNwQixvQkFBb0I7Ozs7Ozs7VUMxMC9CcEI7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTs7Ozs7V0N0QkE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLGlDQUFpQyxXQUFXO1dBQzVDO1dBQ0E7Ozs7O1dDUEE7V0FDQTtXQUNBO1dBQ0E7V0FDQSx5Q0FBeUMsd0NBQXdDO1dBQ2pGO1dBQ0E7V0FDQTs7Ozs7V0NQQTs7Ozs7V0NBQTtXQUNBO1dBQ0E7V0FDQSx1REFBdUQsaUJBQWlCO1dBQ3hFO1dBQ0EsZ0RBQWdELGFBQWE7V0FDN0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTjZDO0FBbUI3QyxTQUFTLG9CQUFvQixDQUE4QixFQUFVLEVBQUUsV0FBMkI7SUFDOUYsSUFBSSxHQUFHLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUN0QyxJQUFJLENBQUMsR0FBRyxFQUFFO1FBQ04sTUFBTSxLQUFLLENBQUMsa0NBQTJCLEVBQUUsZUFBWSxDQUFDLENBQUM7S0FDMUQ7SUFDRCxJQUFJLENBQUMsQ0FBQyxHQUFHLFlBQVksV0FBVyxDQUFDLEVBQUU7UUFDL0IsTUFBTSxLQUFLLENBQUMseUJBQWtCLEVBQUUscUNBQTJCLFdBQVcsQ0FBQyxJQUFJLHFCQUFXLEdBQUcsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFFLENBQUMsQ0FBQztLQUNqSDtJQUNELE9BQU8sR0FBRyxDQUFDO0FBQ2YsQ0FBQztBQUVELDJEQUEyRDtBQUMzRCxTQUFTLGdCQUFnQixDQUFDLE1BQXlCO0lBQy9DLE9BQU8sSUFBSSxPQUFPLENBQUMsVUFBVSxPQUFPLEVBQUUsTUFBTTtRQUN4QyxJQUFJLFFBQVEsR0FBRyxVQUFDLEtBQWlCO1lBQzdCLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLEVBQUUsUUFBUSxDQUFDLENBQUM7WUFDOUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ25CLENBQUMsQ0FBQztRQUNGLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDL0MsQ0FBQyxDQUFDLENBQUM7QUFDUCxDQUFDO0FBRUQseUVBQXlFO0FBQ3pFLFNBQWUscUJBQXFCLENBQUMsT0FBNEI7Ozs7d0JBQ3RELHFCQUFNLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO3dCQUF6RCxzQkFBTyxDQUFDLFNBQWlELENBQUMsQ0FBQyxNQUEyQixFQUFDOzs7O0NBQ3pGO0FBRUQsU0FBUyxzQkFBc0IsQ0FBQyxJQUFVO0lBQ3RDLE9BQU8sSUFBSSxPQUFPLENBQUMsVUFBQyxPQUFPLEVBQUUsTUFBTTtRQUNqQyxJQUFJLE1BQU0sR0FBRyxJQUFJLFVBQVUsRUFBRSxDQUFDO1FBRTlCLE1BQU0sQ0FBQyxNQUFNLEdBQUc7WUFDZCxPQUFPLENBQUMsTUFBTSxDQUFDLE1BQWdCLENBQUMsQ0FBQztRQUNuQyxDQUFDLENBQUM7UUFFRixNQUFNLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQztRQUV4QixNQUFNLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzdCLENBQUMsQ0FBQztBQUNKLENBQUM7QUFFRCxJQUFJLEtBQUssQ0FBQztBQUVWLFNBQWUsTUFBTTs7Ozs7O29CQUNmLFlBQVksR0FBRyxvQkFBb0IsQ0FBQyxjQUFjLEVBQUUsY0FBYyxDQUFDLENBQUM7b0JBRXhFLG9DQUFvQztvQkFDcEMsSUFBSSxZQUFZLENBQUMsS0FBSyxDQUFDLFVBQVUsSUFBSSxTQUFTO3dCQUFFLHNCQUFPO29CQUV2RCxZQUFZLENBQUMsS0FBSyxDQUFDLFVBQVUsR0FBRyxTQUFTLENBQUM7b0JBQ3RDLFNBQVMsR0FBRyxvQkFBb0IsQ0FBQyxjQUFjLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztvQkFDbkUsU0FBUyxHQUFHLG9CQUFvQixDQUFDLG9CQUFvQixFQUFFLGdCQUFnQixDQUFDLENBQUM7b0JBQ3pFLFlBQVksR0FBRyxvQkFBb0IsQ0FBQyxvQkFBb0IsRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO29CQUM3RSxZQUFZLEdBQUcsb0JBQW9CLENBQUMsb0JBQW9CLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztvQkFDakYsU0FBUyxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUM7b0JBQ3JCLFNBQVMsQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDOzs7Ozs7NkJBR1QsRUFBRTtvQkFDYyxxQkFBTSxxQkFBcUIsQ0FBQyxDQUFDLFlBQVksRUFBRSxZQUFZLENBQUMsQ0FBQzs7b0JBQXpFLGFBQWEsR0FBRyxTQUF5RDtvQkFDN0UsSUFBSSxhQUFhLElBQUksWUFBWTt3QkFBRSx3QkFBTTtvQkFDckMsVUFBVSxHQUFHLENBQUMsQ0FBQztvQkFDZixJQUFJLEdBQUcsU0FBUyxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsQ0FBQztvQkFDbEMsSUFBSSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsTUFBTSxHQUFHLFVBQVUsRUFBRTt3QkFDbkMsS0FBSyxDQUFDLGdDQUF5QixVQUFVLHFCQUFrQixDQUFDLENBQUM7cUJBQ2hFO29CQUVELE9BQU8sQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7b0JBQ25CLElBQUksR0FBRyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUM5QixJQUFJLENBQUMsSUFBSSxFQUFFO3dCQUNQLEtBQUssQ0FBQyx5Q0FBeUMsQ0FBQyxDQUFDO3dCQUNqRCx3QkFBUztxQkFDWjtvQkFDUyxxQkFBTSxzQkFBc0IsQ0FBQyxJQUFJLENBQUM7O29CQUF4QyxHQUFHLEdBQUcsU0FBa0M7b0JBQ3hDLGFBQWEsR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUNsQyxRQUFRLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDNUQsT0FBTyxDQUFDLEdBQUcsQ0FBQyxtQkFBWSxRQUFRLENBQUUsQ0FBQztvQkFFbkMsSUFBSSxDQUFDLGFBQWEsSUFBSSxDQUFDLFFBQVEsRUFBRTt3QkFDN0IsS0FBSyxDQUFDLG1DQUFtQyxDQUFDLENBQUM7d0JBQzNDLHdCQUFTO3FCQUNaO29CQUNHLE1BQU0sR0FBRzt3QkFDVCxJQUFJLEVBQUUsSUFBSTt3QkFDVixLQUFLLEVBQUUsYUFBYTt3QkFDcEIsUUFBUSxFQUFFLFFBQVE7cUJBQ3JCLENBQUM7b0JBQ0YsT0FBTyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztvQkFDRSxxQkFBTSxLQUFLLENBQUMsU0FBUyxFQUFFOzRCQUN6QyxNQUFNLEVBQUUsTUFBTTs0QkFDZCxJQUFJLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUM7NEJBQzVCLE9BQU8sRUFBRTtnQ0FDVCxjQUFjLEVBQUUsa0JBQWtCOzZCQUNqQzt5QkFDSixDQUFDO3dCQU5hLHFCQUFNLENBQUMsU0FNcEIsQ0FBQyxDQUFDLElBQUksRUFBRTs7b0JBTk4sUUFBUSxHQUFHLFNBTUw7b0JBRVYsT0FBTyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQztvQkFDdEIsSUFBSSxRQUFRLElBQUksUUFBUSxDQUFDLFNBQVMsQ0FBQyxJQUFJLElBQUksRUFBRTt3QkFDekMsS0FBSyxDQUFDLGdDQUFnQyxDQUFDLENBQUM7d0JBQ3hDLHNCQUFPO3FCQUNWO3lCQUFNO3dCQUNILEtBQUssQ0FBQyxpQ0FBMEIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsQ0FBRSxDQUFDLENBQUM7cUJBQy9EOzs7O29CQUdMLFlBQVksQ0FBQyxLQUFLLENBQUMsVUFBVSxHQUFHLFFBQVEsQ0FBQzs7Ozs7O0NBRWhEO0FBR00sU0FBUyxJQUFJLENBQUMsUUFBZ0M7SUFDakQsb0JBQW9CLENBQUMsUUFBUSxFQUFFLGlCQUFpQixDQUFDLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQ3BGLE9BQU8sQ0FBQyxHQUFHLENBQUMsYUFBYSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQ3JDLElBQUksUUFBUSxFQUFFO1FBQ1YsSUFBSSxNQUFNLEdBQUcsSUFBSSx1REFBTSxDQUFDO1lBQ3BCLFNBQVMsRUFBRSxvQkFBb0IsQ0FBQyxZQUFZLEVBQUUsY0FBYyxDQUFDO1lBQzdELFFBQVEsRUFBRSxRQUFRLENBQUMsU0FBUztTQUMvQixDQUFDO1FBQ0YsYUFBYTtRQUNiLFVBQVUsQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO1FBRW5DLHdDQUF3QztRQUN4QyxRQUFRO0tBRUg7QUFDTCxDQUFDO0FBRUQsYUFBYTtBQUNiLFVBQVUsQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bob3RvLXNwaGVyZS12aWV3ZXIvZGlzdC9waG90by1zcGhlcmUtdmlld2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91ZXZlbnQvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGhyZWUvYnVpbGQvdGhyZWUuY2pzIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4qIFBob3RvIFNwaGVyZSBWaWV3ZXIgNC44LjBcbiogQGNvcHlyaWdodCAyMDE0LTIwMTUgSsOpcsOpbXkgSGVsZWluZVxuKiBAY29weXJpZ2h0IDIwMTUtMjAyMiBEYW1pZW4gXCJNaXN0aWNcIiBTb3JlbFxuKiBAbGljZW5jZSBNSVQgKGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgndGhyZWUnKSwgcmVxdWlyZSgndWV2ZW50JykpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICd0aHJlZScsICd1ZXZlbnQnXSwgZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5QaG90b1NwaGVyZVZpZXdlciA9IHt9LCBnbG9iYWwuVEhSRUUsIGdsb2JhbC51RXZlbnQpKTtcbn0pKHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cywgdGhyZWUsIHVldmVudCkgeyAndXNlIHN0cmljdCc7XG5cbiAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7XG4gICAgICB3cml0YWJsZTogZmFsc2VcbiAgICB9KTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH1cblxuICBmdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG4gICAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBmdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICAgIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuXG4gICAgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG4gIH1cblxuICBmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cblxuICAvKipcbiAgICogQHN1bW1hcnkgQ3VzdG9tIGVycm9yIHVzZWQgaW4gdGhlIGxpYlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQG1lbWJlck9mIFBTVlxuICAgKi9cbiAgZnVuY3Rpb24gUFNWRXJyb3IobWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7IC8vIFVzZSBWOCdzIG5hdGl2ZSBtZXRob2QgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgZmFsbGJhY2tcblxuICAgIGlmICgnY2FwdHVyZVN0YWNrVHJhY2UnIGluIEVycm9yKSB7XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBQU1ZFcnJvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgICB9XG4gIH1cblxuICBQU1ZFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG4gIFBTVkVycm9yLnByb3RvdHlwZS5uYW1lID0gJ1BTVkVycm9yJztcbiAgUFNWRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUFNWRXJyb3I7XG5cbiAgLyoqXG4gICAqIEBuYW1lc3BhY2UgUFNWLmFkYXB0ZXJzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAc3VtbWFyeSBCYXNlIGFkYXB0ZXJzIGNsYXNzXG4gICAqIEBtZW1iZXJvZiBQU1YuYWRhcHRlcnNcbiAgICogQGFic3RyYWN0XG4gICAqL1xuXG4gIHZhciBBYnN0cmFjdEFkYXB0ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBhZGFwdGVyXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEluZGljYXRlcyBpZiB0aGUgYWRhcHRlciBzdXBwb3J0cyBwYW5vcmFtYSBkb3dubG9hZCBuYXRpdmVseVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEluZGljYXRlZCBpZiB0aGUgYWRhcHRlciBjYW4gZGlzcGxheSBhbiBhZGRpdGlvbmFsIHRyYW5zcGFyZW50IGltYWdlIGFib3ZlIHRoZSBwYW5vcmFtYVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQU1YuVmlld2VyfSBwc3ZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBYnN0cmFjdEFkYXB0ZXIocHN2KSB7XG4gICAgICAvKipcbiAgICAgICAqIEBzdW1tYXJ5IFJlZmVyZW5jZSB0byBtYWluIGNvbnRyb2xsZXJcbiAgICAgICAqIEB0eXBlIHtQU1YuVmlld2VyfVxuICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgKi9cbiAgICAgIHRoaXMucHN2ID0gcHN2O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBEZXN0cm95cyB0aGUgYWRhcHRlclxuICAgICAqL1xuXG5cbiAgICB2YXIgX3Byb3RvID0gQWJzdHJhY3RBZGFwdGVyLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnBzdjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgSW5kaWNhdGVzIGlmIHRoZSBhZGFwdGVyIHN1cHBvcnRzIHRyYW5zaXRpb25zIGJldHdlZW4gcGFub3JhbWFzXG4gICAgICogQHBhcmFtIHsqfSBwYW5vcmFtYVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLnN1cHBvcnRzVHJhbnNpdGlvbiA9IGZ1bmN0aW9uIHN1cHBvcnRzVHJhbnNpdGlvbihwYW5vcmFtYSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBJbmRpY2F0ZXMgaWYgdGhlIGFkYXB0ZXIgc3VwcG9ydHMgcHJlbG9hZCBvZiBhIHBhbm9yYW1hXG4gICAgICogQHBhcmFtIHsqfSBwYW5vcmFtYVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLnN1cHBvcnRzUHJlbG9hZCA9IGZ1bmN0aW9uIHN1cHBvcnRzUHJlbG9hZChwYW5vcmFtYSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAc3VtbWFyeSBMb2FkcyB0aGUgcGFub3JhbWEgdGV4dHVyZShzKVxuICAgICAqIEBwYXJhbSB7Kn0gcGFub3JhbWFcbiAgICAgKiBAcGFyYW0ge1BTVi5QYW5vRGF0YSB8IFBTVi5QYW5vRGF0YVByb3ZpZGVyfSBbbmV3UGFub0RhdGFdXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbdXNlWG1wUGFub0RhdGFdXG4gICAgICogQHJldHVybnMge1Byb21pc2UuPFBTVi5UZXh0dXJlRGF0YT59XG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLmxvYWRUZXh0dXJlID0gZnVuY3Rpb24gbG9hZFRleHR1cmUocGFub3JhbWEsIG5ld1Bhbm9EYXRhLCB1c2VYbXBQYW5vRGF0YSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgdGhyb3cgbmV3IFBTVkVycm9yKCdsb2FkVGV4dHVyZSBub3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHN1bW1hcnkgQ3JlYXRlcyB0aGUgY3ViZSBtZXNoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzY2FsZT0xXVxuICAgICAqIEByZXR1cm5zIHtleHRlcm5hbDpUSFJFRS5NZXNofVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5jcmVhdGVNZXNoID0gZnVuY3Rpb24gY3JlYXRlTWVzaChzY2FsZSkge1xuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICB0aHJvdyBuZXcgUFNWRXJyb3IoJ2NyZWF0ZU1lc2ggbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBzdW1tYXJ5IEFwcGxpZXMgdGhlIHRleHR1cmUgdG8gdGhlIG1lc2hcbiAgICAgKiBAcGFyYW0ge2V4dGVybmFsOlRIUkVFLk1lc2h9IG1lc2hcbiAgICAgKiBAcGFyYW0ge1BTVi5UZXh0dXJlRGF0YX0gdGV4dHVyZURhdGFcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt0cmFuc2l0aW9uPWZhbHNlXVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5zZXRUZXh0dXJlID0gZnVuY3Rpb24gc2V0VGV4dHVyZShtZXNoLCB0ZXh0dXJlRGF0YSwgdHJhbnNpdGlvbikge1xuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICB0aHJvdyBuZXcgUFNWRXJyb3IoJ3NldFRleHR1cmUgbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBzdW1tYXJ5IENoYW5nZXMgdGhlIG9wYWNpdHkgb2YgdGhlIG1lc2hcbiAgICAgKiBAcGFyYW0ge2V4dGVybmFsOlRIUkVFLk1lc2h9IG1lc2hcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3BhY2l0eVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5zZXRUZXh0dXJlT3BhY2l0eSA9IGZ1bmN0aW9uIHNldFRleHR1cmVPcGFjaXR5KG1lc2gsIG9wYWNpdHkpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHRocm93IG5ldyBQU1ZFcnJvcignc2V0VGV4dHVyZU9wYWNpdHkgbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBzdW1tYXJ5IENsZWFyIGEgbG9hZGVkIHRleHR1cmUgZnJvbSBtZW1vcnlcbiAgICAgKiBAcGFyYW0ge1BTVi5UZXh0dXJlRGF0YX0gdGV4dHVyZURhdGFcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uZGlzcG9zZVRleHR1cmUgPSBmdW5jdGlvbiBkaXNwb3NlVGV4dHVyZSh0ZXh0dXJlRGF0YSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgdGhyb3cgbmV3IFBTVkVycm9yKCdkaXNwb3NlVGV4dHVyZSBub3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHN1bW1hcnkgQXBwbGllcyB0aGUgb3ZlcmxheSB0byB0aGUgbWVzaFxuICAgICAqIEBwYXJhbSB7ZXh0ZXJuYWw6VEhSRUUuTWVzaH0gbWVzaFxuICAgICAqIEBwYXJhbSB7UFNWLlRleHR1cmVEYXRhfSB0ZXh0dXJlRGF0YVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcGFjaXR5XG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLnNldE92ZXJsYXkgPSBmdW5jdGlvbiBzZXRPdmVybGF5KG1lc2gsIHRleHR1cmVEYXRhLCBvcGFjaXR5KSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICB0aHJvdyBuZXcgUFNWRXJyb3IoJ3NldE92ZXJsYXkgbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIDtcblxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIEFic3RyYWN0QWRhcHRlci5jcmVhdGVPdmVybGF5TWF0ZXJpYWwgPSBmdW5jdGlvbiBjcmVhdGVPdmVybGF5TWF0ZXJpYWwoX3RlbXApIHtcbiAgICAgIHZhciBfZXh0ZW5kczI7XG5cbiAgICAgIHZhciBfcmVmID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAsXG4gICAgICAgICAgYWRkaXRpb25hbFVuaWZvcm1zID0gX3JlZi5hZGRpdGlvbmFsVW5pZm9ybXMsXG4gICAgICAgICAgb3ZlcnJpZGVWZXJ0ZXhTaGFkZXIgPSBfcmVmLm92ZXJyaWRlVmVydGV4U2hhZGVyO1xuXG4gICAgICByZXR1cm4gbmV3IHRocmVlLlNoYWRlck1hdGVyaWFsKHtcbiAgICAgICAgdW5pZm9ybXM6IF9leHRlbmRzKHt9LCBhZGRpdGlvbmFsVW5pZm9ybXMsIChfZXh0ZW5kczIgPSB7fSwgX2V4dGVuZHMyW0Fic3RyYWN0QWRhcHRlci5PVkVSTEFZX1VOSUZPUk1TLnBhbm9yYW1hXSA9IHtcbiAgICAgICAgICB2YWx1ZTogbmV3IHRocmVlLlRleHR1cmUoKVxuICAgICAgICB9LCBfZXh0ZW5kczJbQWJzdHJhY3RBZGFwdGVyLk9WRVJMQVlfVU5JRk9STVMub3ZlcmxheV0gPSB7XG4gICAgICAgICAgdmFsdWU6IG5ldyB0aHJlZS5UZXh0dXJlKClcbiAgICAgICAgfSwgX2V4dGVuZHMyW0Fic3RyYWN0QWRhcHRlci5PVkVSTEFZX1VOSUZPUk1TLmdsb2JhbE9wYWNpdHldID0ge1xuICAgICAgICAgIHZhbHVlOiAxLjBcbiAgICAgICAgfSwgX2V4dGVuZHMyW0Fic3RyYWN0QWRhcHRlci5PVkVSTEFZX1VOSUZPUk1TLm92ZXJsYXlPcGFjaXR5XSA9IHtcbiAgICAgICAgICB2YWx1ZTogMS4wXG4gICAgICAgIH0sIF9leHRlbmRzMikpLFxuICAgICAgICB2ZXJ0ZXhTaGFkZXI6IG92ZXJyaWRlVmVydGV4U2hhZGVyIHx8IFwiXFxudmFyeWluZyB2ZWMyIHZVdjtcXG5cXG52b2lkIG1haW4oKSB7XFxuICB2VXYgPSB1djtcXG4gIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqICBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XFxufVwiLFxuICAgICAgICBmcmFnbWVudFNoYWRlcjogXCJcXG51bmlmb3JtIHNhbXBsZXIyRCBcIiArIEFic3RyYWN0QWRhcHRlci5PVkVSTEFZX1VOSUZPUk1TLnBhbm9yYW1hICsgXCI7XFxudW5pZm9ybSBzYW1wbGVyMkQgXCIgKyBBYnN0cmFjdEFkYXB0ZXIuT1ZFUkxBWV9VTklGT1JNUy5vdmVybGF5ICsgXCI7XFxudW5pZm9ybSBmbG9hdCBcIiArIEFic3RyYWN0QWRhcHRlci5PVkVSTEFZX1VOSUZPUk1TLmdsb2JhbE9wYWNpdHkgKyBcIjtcXG51bmlmb3JtIGZsb2F0IFwiICsgQWJzdHJhY3RBZGFwdGVyLk9WRVJMQVlfVU5JRk9STVMub3ZlcmxheU9wYWNpdHkgKyBcIjtcXG5cXG52YXJ5aW5nIHZlYzIgdlV2O1xcblxcbnZvaWQgbWFpbigpIHtcXG4gIHZlYzQgdENvbG9yMSA9IHRleHR1cmUyRCggXCIgKyBBYnN0cmFjdEFkYXB0ZXIuT1ZFUkxBWV9VTklGT1JNUy5wYW5vcmFtYSArIFwiLCB2VXYgKTtcXG4gIHZlYzQgdENvbG9yMiA9IHRleHR1cmUyRCggXCIgKyBBYnN0cmFjdEFkYXB0ZXIuT1ZFUkxBWV9VTklGT1JNUy5vdmVybGF5ICsgXCIsIHZVdiApO1xcbiAgZ2xfRnJhZ0NvbG9yID0gdmVjNChcXG4gICAgbWl4KCB0Q29sb3IxLnJnYiwgdENvbG9yMi5yZ2IsIHRDb2xvcjIuYSAqIFwiICsgQWJzdHJhY3RBZGFwdGVyLk9WRVJMQVlfVU5JRk9STVMub3ZlcmxheU9wYWNpdHkgKyBcIiApLFxcbiAgICBcIiArIEFic3RyYWN0QWRhcHRlci5PVkVSTEFZX1VOSUZPUk1TLmdsb2JhbE9wYWNpdHkgKyBcIlxcbiAgKTtcXG59XCJcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gQWJzdHJhY3RBZGFwdGVyO1xuICB9KCk7XG4gIEFic3RyYWN0QWRhcHRlci5pZCA9IG51bGw7XG4gIEFic3RyYWN0QWRhcHRlci5zdXBwb3J0c0Rvd25sb2FkID0gZmFsc2U7XG4gIEFic3RyYWN0QWRhcHRlci5zdXBwb3J0c092ZXJsYXkgPSBmYWxzZTtcbiAgQWJzdHJhY3RBZGFwdGVyLk9WRVJMQVlfVU5JRk9STVMgPSB7XG4gICAgcGFub3JhbWE6ICdwYW5vcmFtYScsXG4gICAgb3ZlcmxheTogJ292ZXJsYXknLFxuICAgIGdsb2JhbE9wYWNpdHk6ICdnbG9iYWxPcGFjaXR5JyxcbiAgICBvdmVybGF5T3BhY2l0eTogJ292ZXJsYXlPcGFjaXR5J1xuICB9O1xuXG4gIC8qKlxuICAgKiBAbmFtZXNwYWNlIFBTVi5jb25zdGFudHNcbiAgICovXG5cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IERlZmF1bHQgZHVyYXRpb24gb2YgdGhlIHRyYW5zaXRpb24gYmV0d2VlbiBwYW5vcmFtYXNcbiAgICogQG1lbWJlck9mIFBTVi5jb25zdGFudHNcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGNvbnN0YW50XG4gICAqL1xuICB2YXIgREVGQVVMVF9UUkFOU0lUSU9OID0gMTUwMDtcbiAgLyoqXG4gICAqIEBzdW1tYXJ5IE51bWJlciBvZiBwaXhlbHMgYmVsbG93IHdoaWNoIGEgbW91c2UgbW92ZSB3aWxsIGJlIGNvbnNpZGVyZWQgYXMgYSBjbGlja1xuICAgKiBAbWVtYmVyT2YgUFNWLmNvbnN0YW50c1xuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAY29uc3RhbnRcbiAgICovXG5cbiAgdmFyIE1PVkVfVEhSRVNIT0xEID0gNDtcbiAgLyoqXG4gICAqIEBzdW1tYXJ5IERlbGF5IGluIG1pbGxpc2Vjb25kcyBiZXR3ZWVuIHR3byBjbGlja3MgdG8gY29uc2lkZXIgYSBkb3VibGUgY2xpY2tcbiAgICogQG1lbWJlck9mIFBTVi5jb25zdGFudHNcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGNvbnN0YW50XG4gICAqL1xuXG4gIHZhciBEQkxDTElDS19ERUxBWSA9IDMwMDtcbiAgLyoqXG4gICAqIEBzdW1tYXJ5IERlbGF5IGluIG1pbGxpc2Vjb25kcyB0byBlbXVsYXRlIGEgbG9uZyB0b3VjaFxuICAgKiBAbWVtYmVyT2YgUFNWLmNvbnN0YW50c1xuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAY29uc3RhbnRcbiAgICovXG5cbiAgdmFyIExPTkdUT1VDSF9ERUxBWSA9IDUwMDtcbiAgLyoqXG4gICAqIEBzdW1tYXJ5IERlbGF5IGluIG1pbGxpc2Vjb25kcyB0byBmb3IgdGhlIHR3byBmaW5nZXJzIG92ZXJsYXkgdG8gYXBwZWFyXG4gICAqIEBtZW1iZXJPZiBQU1YuY29uc3RhbnRzXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBjb25zdGFudFxuICAgKi9cblxuICB2YXIgVFdPRklOR0VSU09WRVJMQVlfREVMQVkgPSAxMDA7XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBEdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgb2YgdGhlIFwiY3RybCB6b29tXCIgb3ZlcmxheVxuICAgKiBAbWVtYmVyT2YgUFNWLmNvbnN0YW50c1xuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAY29uc3RhbnRcbiAgICovXG5cbiAgdmFyIENUUkxaT09NX1RJTUVPVVQgPSAyMDAwO1xuICAvKipcbiAgICogQHN1bW1hcnkgVGltZSBzaXplIG9mIHRoZSBtb3VzZSBwb3NpdGlvbiBoaXN0b3J5IHVzZWQgdG8gY29tcHV0ZSBpbmVydGlhXG4gICAqIEBtZW1iZXJPZiBQU1YuY29uc3RhbnRzXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBjb25zdGFudFxuICAgKi9cblxuICB2YXIgSU5FUlRJQV9XSU5ET1cgPSAzMDA7XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBSYWRpdXMgb2YgdGhlIFRIUkVFLlNwaGVyZUdlb21ldHJ5LCBIYWxmLWxlbmd0aCBvZiB0aGUgVEhSRUUuQm94R2VvbWV0cnlcbiAgICogQG1lbWJlck9mIFBTVi5jb25zdGFudHNcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGNvbnN0YW50XG4gICAqL1xuXG4gIHZhciBTUEhFUkVfUkFESVVTID0gMTA7XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBQcm9wZXJ0eSBuYW1lIGFkZGVkIHRvIHZpZXdlciBlbGVtZW50XG4gICAqIEBtZW1iZXJPZiBQU1YuY29uc3RhbnRzXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBjb25zdGFudFxuICAgKi9cblxuICB2YXIgVklFV0VSX0RBVEEgPSAncGhvdG9TcGhlcmVWaWV3ZXInO1xuICAvKipcbiAgICogQHN1bW1hcnkgUHJvcGVydHkgYWRkZWQgdGhlIHRoZSBtYWluIE1lc2ggb2JqZWN0XG4gICAqIEBtZW1iZXJPZiBQU1YuY29uc3RhbnRzXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBjb25zdGFudFxuICAgKi9cblxuICB2YXIgTUVTSF9VU0VSX0RBVEEgPSAncHN2U3BoZXJlJztcbiAgLyoqXG4gICAqIEBzdW1tYXJ5IEF2YWlsYWJsZSBhY3Rpb25zXG4gICAqIEBtZW1iZXJPZiBQU1YuY29uc3RhbnRzXG4gICAqIEBlbnVtIHtzdHJpbmd9XG4gICAqIEBjb25zdGFudFxuICAgKi9cblxuICB2YXIgQUNUSU9OUyA9IHtcbiAgICBST1RBVEVfTEFUX1VQOiAncm90YXRlTGF0aXR1ZGVVcCcsXG4gICAgUk9UQVRFX0xBVF9ET1dOOiAncm90YXRlTGF0aXR1ZGVEb3duJyxcbiAgICBST1RBVEVfTE9OR19SSUdIVDogJ3JvdGF0ZUxvbmdpdHVkZVJpZ2h0JyxcbiAgICBST1RBVEVfTE9OR19MRUZUOiAncm90YXRlTG9uZ2l0dWRlTGVmdCcsXG4gICAgWk9PTV9JTjogJ3pvb21JbicsXG4gICAgWk9PTV9PVVQ6ICd6b29tT3V0JyxcbiAgICBUT0dHTEVfQVVUT1JPVEFURTogJ3RvZ2dsZUF1dG9yb3RhdGUnXG4gIH07XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBBdmFpbGFibGUgZXZlbnRzIG5hbWVzXG4gICAqIEBtZW1iZXJPZiBQU1YuY29uc3RhbnRzXG4gICAqIEBlbnVtIHtzdHJpbmd9XG4gICAqIEBjb25zdGFudFxuICAgKi9cblxuICB2YXIgRVZFTlRTID0ge1xuICAgIC8qKlxuICAgICAqIEBldmVudCBhdXRvcm90YXRlXG4gICAgICogQG1lbWJlcm9mIFBTVlxuICAgICAqIEBzdW1tYXJ5IFRyaWdnZXJlZCB3aGVuIHRoZSBhdXRvbWF0aWMgcm90YXRpb24gaXMgZW5hYmxlZC9kaXNhYmxlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZFxuICAgICAqL1xuICAgIEFVVE9ST1RBVEU6ICdhdXRvcm90YXRlJyxcblxuICAgIC8qKlxuICAgICAqIEBldmVudCBiZWZvcmUtcmVuZGVyXG4gICAgICogQG1lbWJlcm9mIFBTVlxuICAgICAqIEBzdW1tYXJ5IFRyaWdnZXJlZCBiZWZvcmUgYSByZW5kZXIsIHVzZWQgdG8gbW9kaWZ5IHRoZSB2aWV3XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVzdGFtcCAtIHRpbWUgcHJvdmlkZWQgYnkgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVsYXBzZWQgLSB0aW1lIGVsYXBzZWQgZnJvbSB0aGUgcHJldmlvdXMgZnJhbWVcbiAgICAgKi9cbiAgICBCRUZPUkVfUkVOREVSOiAnYmVmb3JlLXJlbmRlcicsXG5cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgYmVmb3JlLXJvdGF0ZVxuICAgICAqIEBtZW1iZXJPZiBQU1ZcbiAgICAgKiBAc3VtbWFyeSBUcmlnZ2VyZWQgYmVmb3JlIGEgcm90YXRlIG9wZXJhdGlvbiwgY2FuIGJlIGNhbmNlbGxlZFxuICAgICAqIEBwYXJhbSB7UFNWLkV4dGVuZGVkUG9zaXRpb259XG4gICAgICovXG4gICAgQkVGT1JFX1JPVEFURTogJ2JlZm9yZS1yb3RhdGUnLFxuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IGNsaWNrXG4gICAgICogQG1lbWJlcm9mIFBTVlxuICAgICAqIEBzdW1tYXJ5IFRyaWdnZXJlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGUgdmlld2VyIChldmVyeXdoZXJlIGV4Y2x1ZGluZyB0aGUgbmF2YmFyIGFuZCB0aGUgc2lkZSBwYW5lbClcbiAgICAgKiBAcGFyYW0ge1BTVi5DbGlja0RhdGF9IGRhdGFcbiAgICAgKi9cbiAgICBDTElDSzogJ2NsaWNrJyxcblxuICAgIC8qKlxuICAgICAqIEBldmVudCBjbG9zZS1wYW5lbFxuICAgICAqIEBtZW1iZXJvZiBQU1ZcbiAgICAgKiBAc3VtbWFyeSBUcmlnZ2VyZWQgd2hlbiB0aGUgcGFuZWwgaXMgY2xvc2VkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtpZF1cbiAgICAgKi9cbiAgICBDTE9TRV9QQU5FTDogJ2Nsb3NlLXBhbmVsJyxcblxuICAgIC8qKlxuICAgICAqIEBldmVudCBjb25maWctY2hhbmdlZFxuICAgICAqIEBtZW1iZXJPZiBQU1ZcbiAgICAgKiBAc3VtbWFyeSBUcmlnZ2VyZWQgYWZ0ZXIgYSBjYWxsIHRvIHNldE9wdGlvbi9zZXRPcHRpb25zXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gbmFtZSBvZiBjaGFuZ2VkIG9wdGlvbnNcbiAgICAgKi9cbiAgICBDT05GSUdfQ0hBTkdFRDogJ2NvbmZpZy1jaGFuZ2VkJyxcblxuICAgIC8qKlxuICAgICAqIEBldmVudCBkYmxjbGlja1xuICAgICAqIEBtZW1iZXJvZiBQU1ZcbiAgICAgKiBAc3VtbWFyeSBUcmlnZ2VyZWQgd2hlbiB0aGUgdXNlciBkb3VibGUgY2xpY2tzIG9uIHRoZSB2aWV3ZXIuIFRoZSBzaW1wbGUgYGNsaWNrYCBldmVudCBpcyBhbHdheXMgZmlyZWQgYmVmb3JlIGBkYmxjbGlja2BcbiAgICAgKiBAcGFyYW0ge1BTVi5DbGlja0RhdGF9IGRhdGFcbiAgICAgKi9cbiAgICBET1VCTEVfQ0xJQ0s6ICdkYmxjbGljaycsXG5cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgZnVsbHNjcmVlbi11cGRhdGVkXG4gICAgICogQG1lbWJlcm9mIFBTVlxuICAgICAqIEBzdW1tYXJ5IFRyaWdnZXJlZCB3aGVuIHRoZSBmdWxsc2NyZWVuIG1vZGUgaXMgZW5hYmxlZC9kaXNhYmxlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZFxuICAgICAqL1xuICAgIEZVTExTQ1JFRU5fVVBEQVRFRDogJ2Z1bGxzY3JlZW4tdXBkYXRlZCcsXG5cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgaGlkZS1ub3RpZmljYXRpb25cbiAgICAgKiBAbWVtYmVyb2YgUFNWXG4gICAgICogQHN1bW1hcnkgVHJpZ2dlcmVkIHdoZW4gdGhlIG5vdGlmaWNhdGlvbiBpcyBoaWRkZW5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2lkXVxuICAgICAqL1xuICAgIEhJREVfTk9USUZJQ0FUSU9OOiAnaGlkZS1ub3RpZmljYXRpb24nLFxuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IGhpZGUtb3ZlcmxheVxuICAgICAqIEBtZW1iZXJvZiBQU1ZcbiAgICAgKiBAc3VtbWFyeSBUcmlnZ2VyZWQgd2hlbiB0aGUgb3ZlcmxheSBpcyBoaWRkZW5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2lkXVxuICAgICAqL1xuICAgIEhJREVfT1ZFUkxBWTogJ2hpZGUtb3ZlcmxheScsXG5cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgaGlkZS10b29sdGlwXG4gICAgICogQG1lbWJlcm9mIFBTVlxuICAgICAqIEBzdW1tYXJ5IFRyaWdnZXJlZCB3aGVuIHRoZSB0b29sdGlwIGlzIGhpZGRlblxuICAgICAqIEBwYXJhbSB7Kn0gRGF0YSBhc3NvY2lhdGVkIHRvIHRoaXMgdG9vbHRpcFxuICAgICAqL1xuICAgIEhJREVfVE9PTFRJUDogJ2hpZGUtdG9vbHRpcCcsXG5cbiAgICAvKipcbiAgICAgKiBAZXZlbnQga2V5LXByZXNzXG4gICAgICogQG1lbWJlcm9mIFBTVlxuICAgICAqIEBzdW1tYXJ5IFRyaWdnZXJlZCB3aGVuIGEga2V5IGlzIHByZXNzZWQsIGNhbiBiZSBjYW5jZWxsZWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICovXG4gICAgS0VZX1BSRVNTOiAna2V5LXByZXNzJyxcblxuICAgIC8qKlxuICAgICAqIEBldmVudCBsb2FkLXByb2dyZXNzXG4gICAgICogQG1lbWJlcm9mIFBTVlxuICAgICAqIEBzdW1tYXJ5IFRyaWdnZXJlZCB3aGVuIHRoZSBsb2FkZXIgdmFsdWUgY2hhbmdlc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBmcm9tIDAgdG8gMTAwXG4gICAgICovXG4gICAgTE9BRF9QUk9HUkVTUzogJ2xvYWQtcHJvZ3Jlc3MnLFxuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG9wZW4tcGFuZWxcbiAgICAgKiBAbWVtYmVyb2YgUFNWXG4gICAgICogQHN1bW1hcnkgVHJpZ2dlcmVkIHdoZW4gdGhlIHBhbmVsIGlzIG9wZW5lZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbaWRdXG4gICAgICovXG4gICAgT1BFTl9QQU5FTDogJ29wZW4tcGFuZWwnLFxuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IHBhbm9yYW1hLWxvYWRlZFxuICAgICAqIEBtZW1iZXJvZiBQU1ZcbiAgICAgKiBAc3VtbWFyeSBUcmlnZ2VyZWQgd2hlbiBhIHBhbm9yYW1hIGltYWdlIGhhcyBiZWVuIGxvYWRlZFxuICAgICAqIEBwYXJhbSB7UFNWLlRleHR1cmVEYXRhfSB0ZXh0dXJlRGF0YVxuICAgICAqL1xuICAgIFBBTk9SQU1BX0xPQURFRDogJ3Bhbm9yYW1hLWxvYWRlZCcsXG5cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgcG9zaXRpb24tdXBkYXRlZFxuICAgICAqIEBtZW1iZXJvZiBQU1ZcbiAgICAgKiBAc3VtbWFyeSBUcmlnZ2VyZWQgd2hlbiB0aGUgdmlldyBsb25naXR1ZGUgYW5kL29yIGxhdGl0dWRlIGNoYW5nZXNcbiAgICAgKiBAcGFyYW0ge1BTVi5Qb3NpdGlvbn0gcG9zaXRpb25cbiAgICAgKi9cbiAgICBQT1NJVElPTl9VUERBVEVEOiAncG9zaXRpb24tdXBkYXRlZCcsXG5cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgcmVhZHlcbiAgICAgKiBAbWVtYmVyb2YgUFNWXG4gICAgICogQHN1bW1hcnkgVHJpZ2dlcmVkIHdoZW4gdGhlIHBhbm9yYW1hIGltYWdlIGhhcyBiZWVuIGxvYWRlZCBhbmQgdGhlIHZpZXdlciBpcyByZWFkeSB0byBwZXJmb3JtIHRoZSBmaXJzdCByZW5kZXJcbiAgICAgKi9cbiAgICBSRUFEWTogJ3JlYWR5JyxcblxuICAgIC8qKlxuICAgICAqIEBldmVudCByZW5kZXJcbiAgICAgKiBAbWVtYmVyb2YgUFNWXG4gICAgICogQHN1bW1hcnkgVHJpZ2dlcmVkIG9uIGVhY2ggdmlld2VyIHJlbmRlciwgKip0aGlzIGV2ZW50IGlzIHRyaWdnZXJlZCB2ZXJ5IG9mdGVuKipcbiAgICAgKi9cbiAgICBSRU5ERVI6ICdyZW5kZXInLFxuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IHNob3ctbm90aWZpY2F0aW9uXG4gICAgICogQG1lbWJlcm9mIFBTVlxuICAgICAqIEBzdW1tYXJ5IFRyaWdnZXJlZCB3aGVuIHRoZSBub3RpZmljYXRpb24gaXMgc2hvd25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2lkXVxuICAgICAqL1xuICAgIFNIT1dfTk9USUZJQ0FUSU9OOiAnc2hvdy1ub3RpZmljYXRpb24nLFxuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IHNob3ctb3ZlcmxheVxuICAgICAqIEBtZW1iZXJvZiBQU1ZcbiAgICAgKiBAc3VtbWFyeSBUcmlnZ2VyZWQgd2hlbiB0aGUgb3ZlcmxheSBpcyBzaG93blxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbaWRdXG4gICAgICovXG4gICAgU0hPV19PVkVSTEFZOiAnc2hvdy1vdmVybGF5JyxcblxuICAgIC8qKlxuICAgICAqIEBldmVudCBzaG93LXRvb2x0aXBcbiAgICAgKiBAbWVtYmVyb2YgUFNWXG4gICAgICogQHN1bW1hcnkgVHJpZ2dlcmVkIHdoZW4gdGhlIHRvb2x0aXAgaXMgc2hvd25cbiAgICAgKiBAcGFyYW0geyp9IERhdGEgYXNzb2NpYXRlZCB0byB0aGlzIHRvb2x0aXBcbiAgICAgKiBAcGFyYW0ge1BTVi5jb21wb25lbnRzLlRvb2x0aXB9IEluc3RhbmNlIG9mIHRoZSB0b29sdGlwXG4gICAgICovXG4gICAgU0hPV19UT09MVElQOiAnc2hvdy10b29sdGlwJyxcblxuICAgIC8qKlxuICAgICAqIEBldmVudCBzaXplLXVwZGF0ZWRcbiAgICAgKiBAbWVtYmVyb2YgUFNWXG4gICAgICogQHN1bW1hcnkgVHJpZ2dlcmVkIHdoZW4gdGhlIHZpZXdlciBzaXplIGNoYW5nZXNcbiAgICAgKiBAcGFyYW0ge1BTVi5TaXplfSBzaXplXG4gICAgICovXG4gICAgU0laRV9VUERBVEVEOiAnc2l6ZS11cGRhdGVkJyxcblxuICAgIC8qKlxuICAgICAqIEBldmVudCBzdG9wLWFsbFxuICAgICAqIEBtZW1iZXJvZiBQU1ZcbiAgICAgKiBAc3VtbWFyeSBUcmlnZ2VyZWQgd2hlbiBhbGwgY3VycmVudCBhbmltYXRpb25zIGFyZSBzdG9wcGVkXG4gICAgICovXG4gICAgU1RPUF9BTEw6ICdzdG9wLWFsbCcsXG5cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgem9vbS11cGRhdGVkXG4gICAgICogQG1lbWJlcm9mIFBTVlxuICAgICAqIEBzdW1tYXJ5IFRyaWdnZXJlZCB3aGVuIHRoZSB6b29tIGxldmVsIGNoYW5nZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gem9vbUxldmVsXG4gICAgICovXG4gICAgWk9PTV9VUERBVEVEOiAnem9vbS11cGRhdGVkJ1xuICB9O1xuICAvKipcbiAgICogQHN1bW1hcnkgQXZhaWxhYmxlIGNoYW5nZSBldmVudHMgbmFtZXNcbiAgICogQG1lbWJlck9mIFBTVi5jb25zdGFudHNcbiAgICogQGVudW0ge3N0cmluZ31cbiAgICogQGNvbnN0YW50XG4gICAqL1xuXG4gIHZhciBDSEFOR0VfRVZFTlRTID0ge1xuICAgIC8qKlxuICAgICAqIEBldmVudCBnZXQtYW5pbWF0ZS1wb3NpdGlvblxuICAgICAqIEBtZW1iZXJvZiBQU1ZcbiAgICAgKiBAcGFyYW0ge1Bvc2l0aW9ufSBwb3NpdGlvblxuICAgICAqIEByZXR1cm5zIHtQb3NpdGlvbn1cbiAgICAgKiBAc3VtbWFyeSBDYWxsZWQgdG8gYWx0ZXIgdGhlIHRhcmdldCBwb3NpdGlvbiBvZiBhbiBhbmltYXRpb25cbiAgICAgKi9cbiAgICBHRVRfQU5JTUFURV9QT1NJVElPTjogJ2dldC1hbmltYXRlLXBvc2l0aW9uJyxcblxuICAgIC8qKlxuICAgICAqIEBldmVudCBnZXQtcm90YXRlLXBvc2l0aW9uXG4gICAgICogQG1lbWJlcm9mIFBTVlxuICAgICAqIEBwYXJhbSB7UG9zaXRpb259IHBvc2l0aW9uXG4gICAgICogQHJldHVybnMge1Bvc2l0aW9ufVxuICAgICAqIEBzdW1tYXJ5IENhbGxlZCB0byBhbHRlciB0aGUgdGFyZ2V0IHBvc2l0aW9uIG9mIGEgcm90YXRpb25cbiAgICAgKi9cbiAgICBHRVRfUk9UQVRFX1BPU0lUSU9OOiAnZ2V0LXJvdGF0ZS1wb3NpdGlvbidcbiAgfTtcbiAgLyoqXG4gICAqIEBzdW1tYXJ5IFNwZWNpYWwgZXZlbnRzIGVtaXR0ZWQgdG8gbGlzdGVuZXIgdXNpbmcge0BsaW5rIFZpZXdlciNvYnNlcnZlT2JqZWN0c31cbiAgICogQG1lbWJlck9mIFBTVi5jb25zdGFudHNcbiAgICogQGNvbnN0YW50XG4gICAqIEBwYWNrYWdlXG4gICAqL1xuXG4gIHZhciBPQkpFQ1RfRVZFTlRTID0ge1xuICAgIEVOVEVSX09CSkVDVDogJ2VudGVyLW9iamVjdCcsXG4gICAgSE9WRVJfT0JKRUNUOiAnaG92ZXItb2JqZWN0JyxcbiAgICBMRUFWRV9PQkpFQ1Q6ICdsZWF2ZS1vYmplY3QnXG4gIH07XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBJbnRlcm5hbCBpZGVudGlmaWVycyBmb3IgdmFyaW91cyBzdHVmZlxuICAgKiBAbWVtYmVyT2YgUFNWLmNvbnN0YW50c1xuICAgKiBAZW51bSB7c3RyaW5nfVxuICAgKiBAY29uc3RhbnRcbiAgICovXG5cbiAgdmFyIElEUyA9IHtcbiAgICBNRU5VOiAnbWVudScsXG4gICAgVFdPX0ZJTkdFUlM6ICd0d29GaW5nZXJzJyxcbiAgICBDVFJMX1pPT006ICdjdHJsWm9vbScsXG4gICAgRVJST1I6ICdlcnJvcicsXG4gICAgREVTQ1JJUFRJT046ICdkZXNjcmlwdGlvbidcbiAgfTtcbiAgLyogZXNsaW50LWRpc2FibGUgKi9cbiAgLy8gQGZvcm1hdHRlcjpvZmZcblxuICAvKipcbiAgICogQHN1bW1hcnkgQ29sbGVjdGlvbiBvZiBlYXNpbmcgZnVuY3Rpb25zXG4gICAqIEBtZW1iZXJPZiBQU1YuY29uc3RhbnRzXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2ZyZWRlcmlja2svNjE2NTc2OH1cbiAgICogQHR5cGUge09iamVjdDxzdHJpbmcsIEZ1bmN0aW9uPn1cbiAgICogQGNvbnN0YW50XG4gICAqL1xuXG4gIHZhciBFQVNJTkdTID0ge1xuICAgIGxpbmVhcjogZnVuY3Rpb24gbGluZWFyKHQpIHtcbiAgICAgIHJldHVybiB0O1xuICAgIH0sXG4gICAgaW5RdWFkOiBmdW5jdGlvbiBpblF1YWQodCkge1xuICAgICAgcmV0dXJuIHQgKiB0O1xuICAgIH0sXG4gICAgb3V0UXVhZDogZnVuY3Rpb24gb3V0UXVhZCh0KSB7XG4gICAgICByZXR1cm4gdCAqICgyIC0gdCk7XG4gICAgfSxcbiAgICBpbk91dFF1YWQ6IGZ1bmN0aW9uIGluT3V0UXVhZCh0KSB7XG4gICAgICByZXR1cm4gdCA8IC41ID8gMiAqIHQgKiB0IDogLTEgKyAoNCAtIDIgKiB0KSAqIHQ7XG4gICAgfSxcbiAgICBpbkN1YmljOiBmdW5jdGlvbiBpbkN1YmljKHQpIHtcbiAgICAgIHJldHVybiB0ICogdCAqIHQ7XG4gICAgfSxcbiAgICBvdXRDdWJpYzogZnVuY3Rpb24gb3V0Q3ViaWModCkge1xuICAgICAgcmV0dXJuIC0tdCAqIHQgKiB0ICsgMTtcbiAgICB9LFxuICAgIGluT3V0Q3ViaWM6IGZ1bmN0aW9uIGluT3V0Q3ViaWModCkge1xuICAgICAgcmV0dXJuIHQgPCAuNSA/IDQgKiB0ICogdCAqIHQgOiAodCAtIDEpICogKDIgKiB0IC0gMikgKiAoMiAqIHQgLSAyKSArIDE7XG4gICAgfSxcbiAgICBpblF1YXJ0OiBmdW5jdGlvbiBpblF1YXJ0KHQpIHtcbiAgICAgIHJldHVybiB0ICogdCAqIHQgKiB0O1xuICAgIH0sXG4gICAgb3V0UXVhcnQ6IGZ1bmN0aW9uIG91dFF1YXJ0KHQpIHtcbiAgICAgIHJldHVybiAxIC0gLS10ICogdCAqIHQgKiB0O1xuICAgIH0sXG4gICAgaW5PdXRRdWFydDogZnVuY3Rpb24gaW5PdXRRdWFydCh0KSB7XG4gICAgICByZXR1cm4gdCA8IC41ID8gOCAqIHQgKiB0ICogdCAqIHQgOiAxIC0gOCAqIC0tdCAqIHQgKiB0ICogdDtcbiAgICB9LFxuICAgIGluUXVpbnQ6IGZ1bmN0aW9uIGluUXVpbnQodCkge1xuICAgICAgcmV0dXJuIHQgKiB0ICogdCAqIHQgKiB0O1xuICAgIH0sXG4gICAgb3V0UXVpbnQ6IGZ1bmN0aW9uIG91dFF1aW50KHQpIHtcbiAgICAgIHJldHVybiAxICsgLS10ICogdCAqIHQgKiB0ICogdDtcbiAgICB9LFxuICAgIGluT3V0UXVpbnQ6IGZ1bmN0aW9uIGluT3V0UXVpbnQodCkge1xuICAgICAgcmV0dXJuIHQgPCAuNSA/IDE2ICogdCAqIHQgKiB0ICogdCAqIHQgOiAxICsgMTYgKiAtLXQgKiB0ICogdCAqIHQgKiB0O1xuICAgIH0sXG4gICAgaW5TaW5lOiBmdW5jdGlvbiBpblNpbmUodCkge1xuICAgICAgcmV0dXJuIDEgLSBNYXRoLmNvcyh0ICogKE1hdGguUEkgLyAyKSk7XG4gICAgfSxcbiAgICBvdXRTaW5lOiBmdW5jdGlvbiBvdXRTaW5lKHQpIHtcbiAgICAgIHJldHVybiBNYXRoLnNpbih0ICogKE1hdGguUEkgLyAyKSk7XG4gICAgfSxcbiAgICBpbk91dFNpbmU6IGZ1bmN0aW9uIGluT3V0U2luZSh0KSB7XG4gICAgICByZXR1cm4gLjUgLSAuNSAqIE1hdGguY29zKE1hdGguUEkgKiB0KTtcbiAgICB9LFxuICAgIGluRXhwbzogZnVuY3Rpb24gaW5FeHBvKHQpIHtcbiAgICAgIHJldHVybiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpO1xuICAgIH0sXG4gICAgb3V0RXhwbzogZnVuY3Rpb24gb3V0RXhwbyh0KSB7XG4gICAgICByZXR1cm4gMSAtIE1hdGgucG93KDIsIC0xMCAqIHQpO1xuICAgIH0sXG4gICAgaW5PdXRFeHBvOiBmdW5jdGlvbiBpbk91dEV4cG8odCkge1xuICAgICAgcmV0dXJuICh0ID0gdCAqIDIgLSAxKSA8IDAgPyAuNSAqIE1hdGgucG93KDIsIDEwICogdCkgOiAxIC0gLjUgKiBNYXRoLnBvdygyLCAtMTAgKiB0KTtcbiAgICB9LFxuICAgIGluQ2lyYzogZnVuY3Rpb24gaW5DaXJjKHQpIHtcbiAgICAgIHJldHVybiAxIC0gTWF0aC5zcXJ0KDEgLSB0ICogdCk7XG4gICAgfSxcbiAgICBvdXRDaXJjOiBmdW5jdGlvbiBvdXRDaXJjKHQpIHtcbiAgICAgIHJldHVybiBNYXRoLnNxcnQoMSAtICh0IC0gMSkgKiAodCAtIDEpKTtcbiAgICB9LFxuICAgIGluT3V0Q2lyYzogZnVuY3Rpb24gaW5PdXRDaXJjKHQpIHtcbiAgICAgIHJldHVybiAodCAqPSAyKSA8IDEgPyAuNSAtIC41ICogTWF0aC5zcXJ0KDEgLSB0ICogdCkgOiAuNSArIC41ICogTWF0aC5zcXJ0KDEgLSAodCAtPSAyKSAqIHQpO1xuICAgIH1cbiAgfTsgLy8gQGZvcm1hdHRlcjpvblxuXG4gIC8qIGVzbGludC1lbmFibGUgKi9cblxuICAvKipcbiAgICogQHN1bW1hcnkgU3Vic2V0IG9mIGtleSBjb2Rlc1xuICAgKiBAbWVtYmVyT2YgUFNWLmNvbnN0YW50c1xuICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgc3RyaW5nPn1cbiAgICogQGNvbnN0YW50XG4gICAqL1xuXG4gIHZhciBLRVlfQ09ERVMgPSB7XG4gICAgRW50ZXI6ICdFbnRlcicsXG4gICAgQ29udHJvbDogJ0NvbnRyb2wnLFxuICAgIEVzY2FwZTogJ0VzY2FwZScsXG4gICAgU3BhY2U6ICcgJyxcbiAgICBQYWdlVXA6ICdQYWdlVXAnLFxuICAgIFBhZ2VEb3duOiAnUGFnZURvd24nLFxuICAgIEFycm93TGVmdDogJ0Fycm93TGVmdCcsXG4gICAgQXJyb3dVcDogJ0Fycm93VXAnLFxuICAgIEFycm93UmlnaHQ6ICdBcnJvd1JpZ2h0JyxcbiAgICBBcnJvd0Rvd246ICdBcnJvd0Rvd24nLFxuICAgIERlbGV0ZTogJ0RlbGV0ZScsXG4gICAgUGx1czogJysnLFxuICAgIE1pbnVzOiAnLSdcbiAgfTtcblxuICB2YXIgY29uc3RhbnRzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBERUZBVUxUX1RSQU5TSVRJT046IERFRkFVTFRfVFJBTlNJVElPTixcbiAgICBNT1ZFX1RIUkVTSE9MRDogTU9WRV9USFJFU0hPTEQsXG4gICAgREJMQ0xJQ0tfREVMQVk6IERCTENMSUNLX0RFTEFZLFxuICAgIExPTkdUT1VDSF9ERUxBWTogTE9OR1RPVUNIX0RFTEFZLFxuICAgIFRXT0ZJTkdFUlNPVkVSTEFZX0RFTEFZOiBUV09GSU5HRVJTT1ZFUkxBWV9ERUxBWSxcbiAgICBDVFJMWk9PTV9USU1FT1VUOiBDVFJMWk9PTV9USU1FT1VULFxuICAgIElORVJUSUFfV0lORE9XOiBJTkVSVElBX1dJTkRPVyxcbiAgICBTUEhFUkVfUkFESVVTOiBTUEhFUkVfUkFESVVTLFxuICAgIFZJRVdFUl9EQVRBOiBWSUVXRVJfREFUQSxcbiAgICBNRVNIX1VTRVJfREFUQTogTUVTSF9VU0VSX0RBVEEsXG4gICAgQUNUSU9OUzogQUNUSU9OUyxcbiAgICBFVkVOVFM6IEVWRU5UUyxcbiAgICBDSEFOR0VfRVZFTlRTOiBDSEFOR0VfRVZFTlRTLFxuICAgIE9CSkVDVF9FVkVOVFM6IE9CSkVDVF9FVkVOVFMsXG4gICAgSURTOiBJRFMsXG4gICAgRUFTSU5HUzogRUFTSU5HUyxcbiAgICBLRVlfQ09ERVM6IEtFWV9DT0RFU1xuICB9KTtcblxuICB2YXIgTE9DQUxTVE9SQUdFX1RPVUNIX1NVUFBPUlQgPSBWSUVXRVJfREFUQSArIFwiX3RvdWNoU3VwcG9ydFwiO1xuICAvKipcbiAgICogQHN1bW1hcnkgR2VuZXJhbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgc3lzdGVtXG4gICAqIEBjb25zdGFudFxuICAgKiBAbWVtYmVyT2YgUFNWXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbG9hZGVkIC0gSW5kaWNhdGVzIGlmIHRoZSBzeXN0ZW0gZGF0YSBoYXMgYmVlbiBsb2FkZWRcbiAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gbG9hZCAtIExvYWRzIHRoZSBzeXN0ZW0gaWYgbm90IGFscmVhZHkgbG9hZGVkXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwaXhlbFJhdGlvXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNXZWJHTFN1cHBvcnRlZFxuICAgKiBAcHJvcGVydHkge251bWJlcn0gbWF4Q2FudmFzV2lkdGhcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IG1vdXNlV2hlZWxFdmVudFxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gZnVsbHNjcmVlbkV2ZW50XG4gICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGdldE1heENhbnZhc1dpZHRoIC0gUmV0dXJucyB0aGUgbWF4IHdpZHRoIG9mIGEgY2FudmFzIGFsbG93ZWQgYnkgdGhlIGJyb3dzZXJcbiAgICogQHByb3BlcnR5IHt7aW5pdGlhbDogYm9vbGVhbiwgcHJvbWlzZTogUHJvbWlzZTxib29sZWFuPn19IGlzVG91Y2hFbmFibGVkXG4gICAqL1xuXG4gIHZhciBTWVNURU0gPSB7XG4gICAgbG9hZGVkOiBmYWxzZSxcbiAgICBwaXhlbFJhdGlvOiAxLFxuICAgIGlzV2ViR0xTdXBwb3J0ZWQ6IGZhbHNlLFxuICAgIGlzVG91Y2hFbmFibGVkOiBudWxsLFxuICAgIG1heFRleHR1cmVXaWR0aDogMCxcbiAgICBtb3VzZVdoZWVsRXZlbnQ6IG51bGwsXG4gICAgZnVsbHNjcmVlbkV2ZW50OiBudWxsXG4gIH07XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBMb2FkcyB0aGUgc3lzdGVtIGlmIG5vdCBhbHJlYWR5IGxvYWRlZFxuICAgKi9cblxuICBTWVNURU0ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIVNZU1RFTS5sb2FkZWQpIHtcbiAgICAgIHZhciBjdHggPSBnZXRXZWJHTEN0eCgpO1xuICAgICAgU1lTVEVNLmxvYWRlZCA9IHRydWU7XG4gICAgICBTWVNURU0ucGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgICBTWVNURU0uaXNXZWJHTFN1cHBvcnRlZCA9IGN0eCAhPSBudWxsO1xuICAgICAgU1lTVEVNLmlzVG91Y2hFbmFibGVkID0gaXNUb3VjaEVuYWJsZWQoKTtcbiAgICAgIFNZU1RFTS5tYXhUZXh0dXJlV2lkdGggPSBnZXRNYXhUZXh0dXJlV2lkdGgoY3R4KTtcbiAgICAgIFNZU1RFTS5tb3VzZVdoZWVsRXZlbnQgPSBnZXRNb3VzZVdoZWVsRXZlbnQoKTtcbiAgICAgIFNZU1RFTS5mdWxsc2NyZWVuRXZlbnQgPSBnZXRGdWxsc2NyZWVuRXZlbnQoKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIG1heENhbnZhc1dpZHRoID0gbnVsbDtcblxuICBTWVNURU0uZ2V0TWF4Q2FudmFzV2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKG1heENhbnZhc1dpZHRoID09PSBudWxsKSB7XG4gICAgICBtYXhDYW52YXNXaWR0aCA9IGdldE1heENhbnZhc1dpZHRoKFNZU1RFTS5tYXhUZXh0dXJlV2lkdGgpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXhDYW52YXNXaWR0aDtcbiAgfTtcbiAgLyoqXG4gICAqIEBzdW1tYXJ5IFRyaWVzIHRvIHJldHVybiBhIGNhbnZhcyB3ZWJnbCBjb250ZXh0XG4gICAqIEByZXR1cm5zIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0V2ViR0xDdHgoKSB7XG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIHZhciBuYW1lcyA9IFsnd2ViZ2wnLCAnZXhwZXJpbWVudGFsLXdlYmdsJywgJ21vei13ZWJnbCcsICd3ZWJraXQtM2QnXTtcbiAgICB2YXIgY29udGV4dCA9IG51bGw7XG5cbiAgICBpZiAoIWNhbnZhcy5nZXRDb250ZXh0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAobmFtZXMuc29tZShmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KG5hbWUpO1xuICAgICAgICByZXR1cm4gY29udGV4dCAhPT0gbnVsbDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pKSB7XG4gICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBEZXRlY3RzIGlmIHRoZSB1c2VyIGlzIHVzaW5nIGEgdG91Y2ggc2NyZWVuXG4gICAqIEByZXR1cm5zIHt7aW5pdGlhbDogYm9vbGVhbiwgcHJvbWlzZTogUHJvbWlzZTxib29sZWFuPn19XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaXNUb3VjaEVuYWJsZWQoKSB7XG4gICAgdmFyIGluaXRpYWwgPSAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgfHwgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMDtcblxuICAgIGlmIChMT0NBTFNUT1JBR0VfVE9VQ0hfU1VQUE9SVCBpbiBsb2NhbFN0b3JhZ2UpIHtcbiAgICAgIGluaXRpYWwgPSBsb2NhbFN0b3JhZ2VbTE9DQUxTVE9SQUdFX1RPVUNIX1NVUFBPUlRdID09PSAndHJ1ZSc7XG4gICAgfVxuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgdmFyIGNsZWFyO1xuXG4gICAgICB2YXIgbGlzdGVuZXJNb3VzZSA9IGZ1bmN0aW9uIGxpc3RlbmVyTW91c2UoKSB7XG4gICAgICAgIGNsZWFyKCk7XG4gICAgICAgIGxvY2FsU3RvcmFnZVtMT0NBTFNUT1JBR0VfVE9VQ0hfU1VQUE9SVF0gPSBmYWxzZTtcbiAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgbGlzdGVuZXJUb3VjaCA9IGZ1bmN0aW9uIGxpc3RlbmVyVG91Y2goKSB7XG4gICAgICAgIGNsZWFyKCk7XG4gICAgICAgIGxvY2FsU3RvcmFnZVtMT0NBTFNUT1JBR0VfVE9VQ0hfU1VQUE9SVF0gPSB0cnVlO1xuICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgfTtcblxuICAgICAgdmFyIGxpc3RlbmVyVGltZW91dCA9IGZ1bmN0aW9uIGxpc3RlbmVyVGltZW91dCgpIHtcbiAgICAgICAgY2xlYXIoKTtcbiAgICAgICAgbG9jYWxTdG9yYWdlW0xPQ0FMU1RPUkFHRV9UT1VDSF9TVVBQT1JUXSA9IGluaXRpYWw7XG4gICAgICAgIHJlc29sdmUoaW5pdGlhbCk7XG4gICAgICB9O1xuXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbGlzdGVuZXJNb3VzZSwgZmFsc2UpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBsaXN0ZW5lclRvdWNoLCBmYWxzZSk7XG4gICAgICB2YXIgbGlzdGVuZXJUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGxpc3RlbmVyVGltZW91dCwgMTAwMDApO1xuXG4gICAgICBjbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbGlzdGVuZXJNb3VzZSk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgbGlzdGVuZXJUb3VjaCk7XG4gICAgICAgIGNsZWFyVGltZW91dChsaXN0ZW5lclRpbWVvdXRJZCk7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBpbml0aWFsOiBpbml0aWFsLFxuICAgICAgcHJvbWlzZTogcHJvbWlzZVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IEdldHMgbWF4IHRleHR1cmUgd2lkdGggaW4gV2ViR0wgY29udGV4dFxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldE1heFRleHR1cmVXaWR0aChjdHgpIHtcbiAgICBpZiAoY3R4ICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY3R4LmdldFBhcmFtZXRlcihjdHguTUFYX1RFWFRVUkVfU0laRSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQHN1bW1hcnkgR2V0cyBtYXggY2FudmFzIHdpZHRoIHN1cHBvcnRlZCBieSB0aGUgYnJvd3Nlci5cbiAgICogV2Ugb25seSB0ZXN0IHBvd2VycyBvZiAyIGFuZCBoZWlnaHQgPSB3aWR0aCAvIDIgYmVjYXVzZSB0aGF0J3Mgd2hhdCB3ZSBuZWVkIHRvIGdlbmVyYXRlIFdlYkdMIHRleHR1cmVzXG4gICAqIEBwYXJhbSBtYXhXaWR0aFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0TWF4Q2FudmFzV2lkdGgobWF4V2lkdGgpIHtcbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGNhbnZhcy53aWR0aCA9IG1heFdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBtYXhXaWR0aCAvIDI7XG5cbiAgICB3aGlsZSAoY2FudmFzLndpZHRoID4gMTAyNCkge1xuICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgMSwgMSk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpLmRhdGFbMF0gPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbnZhcy53aWR0aDtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkgey8vIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGNhbnZhcy53aWR0aCAvPSAyO1xuICAgICAgY2FudmFzLmhlaWdodCAvPSAyO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBQU1ZFcnJvcignVW5hYmxlIHRvIGRldGVjdCBzeXN0ZW0gY2FwYWJpbGl0aWVzJyk7XG4gIH1cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IEdldHMgdGhlIGV2ZW50IG5hbWUgZm9yIG1vdXNlIHdoZWVsXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0TW91c2VXaGVlbEV2ZW50KCkge1xuICAgIGlmICgnb253aGVlbCcgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpIHtcbiAgICAgIC8vIE1vZGVybiBicm93c2VycyBzdXBwb3J0IFwid2hlZWxcIlxuICAgICAgcmV0dXJuICd3aGVlbCc7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudC5vbm1vdXNld2hlZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gV2Via2l0IGFuZCBJRSBzdXBwb3J0IGF0IGxlYXN0IFwibW91c2V3aGVlbFwiXG4gICAgICByZXR1cm4gJ21vdXNld2hlZWwnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBsZXQncyBhc3N1bWUgdGhhdCByZW1haW5pbmcgYnJvd3NlcnMgYXJlIG9sZGVyIEZpcmVmb3hcbiAgICAgIHJldHVybiAnRE9NTW91c2VTY3JvbGwnO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQHN1bW1hcnkgTWFwIGJldHdlZW4gZnVsbHNjZWVuIG1ldGhvZCBhbmQgZnVsbHNjcmVlbiBldmVudCBuYW1lXG4gICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICB2YXIgRlVMTFNDUkVFTl9FVlRfTUFQID0ge1xuICAgIGV4aXRGdWxsc2NyZWVuOiAnZnVsbHNjcmVlbmNoYW5nZScsXG4gICAgd2Via2l0RXhpdEZ1bGxzY3JlZW46ICd3ZWJraXRmdWxsc2NyZWVuY2hhbmdlJyxcbiAgICBtb3pDYW5jZWxGdWxsU2NyZWVuOiAnbW96ZnVsbHNjcmVlbmNoYW5nZScsXG4gICAgbXNFeGl0RnVsbHNjcmVlbjogJ01TRnVsbHNjcmVlbkNoYW5nZSdcbiAgfTtcbiAgLyoqXG4gICAqIEBzdW1tYXJ5ICBHZXRzIHRoZSBldmVudCBuYW1lIGZvciBmdWxsc2NyZWVuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGdldEZ1bGxzY3JlZW5FdmVudCgpIHtcbiAgICB2YXIgdmFsaWRFeGl0cyA9IE9iamVjdC5rZXlzKEZVTExTQ1JFRU5fRVZUX01BUCkuZmlsdGVyKGZ1bmN0aW9uIChleGl0KSB7XG4gICAgICByZXR1cm4gZXhpdCBpbiBkb2N1bWVudDtcbiAgICB9KTtcblxuICAgIGlmICh2YWxpZEV4aXRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIEZVTExTQ1JFRU5fRVZUX01BUFt2YWxpZEV4aXRzWzBdXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IFRvZ2dsZXMgYSBDU1MgY2xhc3NcbiAgICogQG1lbWJlck9mIFBTVi51dGlsc1xuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fFNWR0VsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthY3RpdmVdIC0gZm9yY2VkIHN0YXRlXG4gICAqL1xuICBmdW5jdGlvbiB0b2dnbGVDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUsIGFjdGl2ZSkge1xuICAgIGlmIChhY3RpdmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKGNsYXNzTmFtZSk7XG4gICAgfSBlbHNlIGlmIChhY3RpdmUpIHtcbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICAgIH0gZWxzZSBpZiAoIWFjdGl2ZSkge1xuICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBBZGRzIG9uZSBvciBzZXZlcmFsIENTUyBjbGFzc2VzIHRvIGFuIGVsZW1lbnRcbiAgICogQG1lbWJlck9mIFBTVi51dGlsc1xuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG5cbiAgZnVuY3Rpb24gYWRkQ2xhc3NlcyhlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgICB2YXIgX2VsZW1lbnQkY2xhc3NMaXN0O1xuXG4gICAgKF9lbGVtZW50JGNsYXNzTGlzdCA9IGVsZW1lbnQuY2xhc3NMaXN0KS5hZGQuYXBwbHkoX2VsZW1lbnQkY2xhc3NMaXN0LCBjbGFzc05hbWUuc3BsaXQoJyAnKSk7XG4gIH1cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IFJlbW92ZXMgb25lIG9yIHNldmVyYWwgQ1NTIGNsYXNzZXMgdG8gYW4gZWxlbWVudFxuICAgKiBAbWVtYmVyT2YgUFNWLnV0aWxzXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cblxuICBmdW5jdGlvbiByZW1vdmVDbGFzc2VzKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICAgIHZhciBfZWxlbWVudCRjbGFzc0xpc3QyO1xuXG4gICAgKF9lbGVtZW50JGNsYXNzTGlzdDIgPSBlbGVtZW50LmNsYXNzTGlzdCkucmVtb3ZlLmFwcGx5KF9lbGVtZW50JGNsYXNzTGlzdDIsIGNsYXNzTmFtZS5zcGxpdCgnICcpKTtcbiAgfVxuICAvKipcbiAgICogQHN1bW1hcnkgU2VhcmNoZXMgaWYgYW4gZWxlbWVudCBoYXMgYSBwYXJ0aWN1bGFyIHBhcmVudCBhdCBhbnkgbGV2ZWwgaW5jbHVkaW5nIGl0c2VsZlxuICAgKiBAbWVtYmVyT2YgUFNWLnV0aWxzXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG5cbiAgZnVuY3Rpb24gaGFzUGFyZW50KGVsLCBwYXJlbnQpIHtcbiAgICB2YXIgdGVzdCA9IGVsO1xuXG4gICAgZG8ge1xuICAgICAgaWYgKHRlc3QgPT09IHBhcmVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdGVzdCA9IHRlc3QucGFyZW50Tm9kZTtcbiAgICB9IHdoaWxlICh0ZXN0KTtcblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogQHN1bW1hcnkgR2V0cyB0aGUgY2xvc2VzdCBwYXJlbnQgKGNhbiBieSBpdHNlbGYpXG4gICAqIEBtZW1iZXJPZiBQU1YudXRpbHNcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxTVkdFbGVtZW50fSBlbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgKi9cblxuICBmdW5jdGlvbiBnZXRDbG9zZXN0KGVsLCBzZWxlY3Rvcikge1xuICAgIC8vIFdoZW4gZWwgaXMgZG9jdW1lbnQgb3Igd2luZG93LCB0aGUgbWF0Y2hlcyBkb2VzIG5vdCBleGlzdFxuICAgIGlmICghKGVsICE9IG51bGwgJiYgZWwubWF0Y2hlcykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciB0ZXN0ID0gZWw7XG5cbiAgICBkbyB7XG4gICAgICBpZiAodGVzdC5tYXRjaGVzKHNlbGVjdG9yKSkge1xuICAgICAgICByZXR1cm4gdGVzdDtcbiAgICAgIH1cblxuICAgICAgdGVzdCA9IHRlc3QgaW5zdGFuY2VvZiBTVkdFbGVtZW50ID8gdGVzdC5wYXJlbnROb2RlIDogdGVzdC5wYXJlbnRFbGVtZW50O1xuICAgIH0gd2hpbGUgKHRlc3QpO1xuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IEdldHMgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgaW4gdGhlIHZpZXdlciB3aXRob3V0IHJlZmxvd1xuICAgKiBAZGVzY3JpcHRpb24gV2lsbCBnaXZlcyB0aGUgc2FtZSByZXN1bHQgYXMgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgYXMgc29vbiBhcyB0aGVyZSBhcmUgbm8gQ1NTIHRyYW5zZm9ybXNcbiAgICogQG1lbWJlck9mIFBTVi51dGlsc1xuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFxuICAgKiBAcmV0dXJuIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGdldFBvc2l0aW9uKGVsKSB7XG4gICAgdmFyIGxlZnQgPSAwO1xuICAgIHZhciB0b3AgPSAwO1xuICAgIHZhciB0ZXN0ID0gZWw7XG5cbiAgICB3aGlsZSAodGVzdCkge1xuICAgICAgbGVmdCArPSB0ZXN0Lm9mZnNldExlZnQgLSB0ZXN0LnNjcm9sbExlZnQgKyB0ZXN0LmNsaWVudExlZnQ7XG4gICAgICB0b3AgKz0gdGVzdC5vZmZzZXRUb3AgLSB0ZXN0LnNjcm9sbFRvcCArIHRlc3QuY2xpZW50VG9wO1xuICAgICAgdGVzdCA9IHRlc3Qub2Zmc2V0UGFyZW50O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgdG9wOiB0b3BcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBEZXRlY3RzIGlmIGZ1bGxzY3JlZW4gaXMgZW5hYmxlZFxuICAgKiBAbWVtYmVyT2YgUFNWLnV0aWxzXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsdFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG5cbiAgZnVuY3Rpb24gaXNGdWxsc2NyZWVuRW5hYmxlZChlbHQpIHtcbiAgICByZXR1cm4gKGRvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50IHx8IGRvY3VtZW50LndlYmtpdEZ1bGxzY3JlZW5FbGVtZW50KSA9PT0gZWx0O1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBFbnRlcnMgZnVsbHNjcmVlbiBtb2RlXG4gICAqIEBtZW1iZXJPZiBQU1YudXRpbHNcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWx0XG4gICAqL1xuXG4gIGZ1bmN0aW9uIHJlcXVlc3RGdWxsc2NyZWVuKGVsdCkge1xuICAgIChlbHQucmVxdWVzdEZ1bGxzY3JlZW4gfHwgZWx0LndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuKS5jYWxsKGVsdCk7XG4gIH1cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IEV4aXRzIGZ1bGxzY3JlZW4gbW9kZVxuICAgKiBAbWVtYmVyT2YgUFNWLnV0aWxzXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGV4aXRGdWxsc2NyZWVuKCkge1xuICAgIChkb2N1bWVudC5leGl0RnVsbHNjcmVlbiB8fCBkb2N1bWVudC53ZWJraXRFeGl0RnVsbHNjcmVlbikuY2FsbChkb2N1bWVudCk7XG4gIH1cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IEdldHMgYW4gZWxlbWVudCBzdHlsZVxuICAgKiBAbWVtYmVyT2YgUFNWLnV0aWxzXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcFxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG5cbiAgZnVuY3Rpb24gZ2V0U3R5bGUoZWx0LCBwcm9wKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsdCwgbnVsbClbcHJvcF07XG4gIH1cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IE5vcm1hbGl6ZSBtb3VzZXdoZWVsIHZhbHVlcyBhY2Nyb3NzIGJyb3dzZXJzXG4gICAqIEBtZW1iZXJPZiBQU1YudXRpbHNcbiAgICogQGRlc2NyaXB0aW9uIEZyb20gRmFjZWJvb2sncyBGaXhlZCBEYXRhIFRhYmxlXG4gICAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2thcmNoaXZlL2ZpeGVkLWRhdGEtdGFibGUvYmxvYi9tYXN0ZXIvc3JjL3ZlbmRvcl91cHN0cmVhbS9kb20vbm9ybWFsaXplV2hlZWwuanN9XG4gICAqIEBjb3B5cmlnaHQgRmFjZWJvb2tcbiAgICogQHBhcmFtIHtXaGVlbEV2ZW50fSBldmVudFxuICAgKiBAcmV0dXJucyB7e3NwaW5YOiBudW1iZXIsIHNwaW5ZOiBudW1iZXIsIHBpeGVsWDogbnVtYmVyLCBwaXhlbFk6IG51bWJlcn19XG4gICAqL1xuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVdoZWVsKGV2ZW50KSB7XG4gICAgdmFyIFBJWEVMX1NURVAgPSAxMDtcbiAgICB2YXIgTElORV9IRUlHSFQgPSA0MDtcbiAgICB2YXIgUEFHRV9IRUlHSFQgPSA4MDA7XG4gICAgdmFyIHNwaW5YID0gMDtcbiAgICB2YXIgc3BpblkgPSAwO1xuICAgIHZhciBwaXhlbFggPSAwO1xuICAgIHZhciBwaXhlbFkgPSAwOyAvLyBMZWdhY3lcblxuICAgIGlmICgnZGV0YWlsJyBpbiBldmVudCkge1xuICAgICAgc3BpblkgPSBldmVudC5kZXRhaWw7XG4gICAgfVxuXG4gICAgaWYgKCd3aGVlbERlbHRhJyBpbiBldmVudCkge1xuICAgICAgc3BpblkgPSAtZXZlbnQud2hlZWxEZWx0YSAvIDEyMDtcbiAgICB9XG5cbiAgICBpZiAoJ3doZWVsRGVsdGFZJyBpbiBldmVudCkge1xuICAgICAgc3BpblkgPSAtZXZlbnQud2hlZWxEZWx0YVkgLyAxMjA7XG4gICAgfVxuXG4gICAgaWYgKCd3aGVlbERlbHRhWCcgaW4gZXZlbnQpIHtcbiAgICAgIHNwaW5YID0gLWV2ZW50LndoZWVsRGVsdGFYIC8gMTIwO1xuICAgIH0gLy8gc2lkZSBzY3JvbGxpbmcgb24gRkYgd2l0aCBET01Nb3VzZVNjcm9sbFxuXG5cbiAgICBpZiAoJ2F4aXMnIGluIGV2ZW50ICYmIGV2ZW50LmF4aXMgPT09IGV2ZW50LkhPUklaT05UQUxfQVhJUykge1xuICAgICAgc3BpblggPSBzcGluWTtcbiAgICAgIHNwaW5ZID0gMDtcbiAgICB9XG5cbiAgICBwaXhlbFggPSBzcGluWCAqIFBJWEVMX1NURVA7XG4gICAgcGl4ZWxZID0gc3BpblkgKiBQSVhFTF9TVEVQO1xuXG4gICAgaWYgKCdkZWx0YVknIGluIGV2ZW50KSB7XG4gICAgICBwaXhlbFkgPSBldmVudC5kZWx0YVk7XG4gICAgfVxuXG4gICAgaWYgKCdkZWx0YVgnIGluIGV2ZW50KSB7XG4gICAgICBwaXhlbFggPSBldmVudC5kZWx0YVg7XG4gICAgfVxuXG4gICAgaWYgKChwaXhlbFggfHwgcGl4ZWxZKSAmJiBldmVudC5kZWx0YU1vZGUpIHtcbiAgICAgIC8vIGRlbHRhIGluIExJTkUgdW5pdHNcbiAgICAgIGlmIChldmVudC5kZWx0YU1vZGUgPT09IDEpIHtcbiAgICAgICAgcGl4ZWxYICo9IExJTkVfSEVJR0hUO1xuICAgICAgICBwaXhlbFkgKj0gTElORV9IRUlHSFQ7XG4gICAgICB9IC8vIGRlbHRhIGluIFBBR0UgdW5pdHNcbiAgICAgIGVsc2Uge1xuICAgICAgICBwaXhlbFggKj0gUEFHRV9IRUlHSFQ7XG4gICAgICAgIHBpeGVsWSAqPSBQQUdFX0hFSUdIVDtcbiAgICAgIH1cbiAgICB9IC8vIEZhbGwtYmFjayBpZiBzcGluIGNhbm5vdCBiZSBkZXRlcm1pbmVkXG5cblxuICAgIGlmIChwaXhlbFggJiYgIXNwaW5YKSB7XG4gICAgICBzcGluWCA9IHBpeGVsWCA8IDEgPyAtMSA6IDE7XG4gICAgfVxuXG4gICAgaWYgKHBpeGVsWSAmJiAhc3BpblkpIHtcbiAgICAgIHNwaW5ZID0gcGl4ZWxZIDwgMSA/IC0xIDogMTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3Bpblg6IHNwaW5YLFxuICAgICAgc3Bpblk6IHNwaW5ZLFxuICAgICAgcGl4ZWxYOiBwaXhlbFgsXG4gICAgICBwaXhlbFk6IHBpeGVsWVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIFRIUkVFLk1hdGhVdGlscy5jbGFtcFxuICAgKi9cblxuICBmdW5jdGlvbiBib3VuZCh4LCBtaW4sIG1heCkge1xuICAgIHJldHVybiB0aHJlZS5NYXRoVXRpbHMuY2xhbXAoeCwgbWluLCBtYXgpO1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBFbnN1cmUgYSB2YWx1ZSBpcyB3aXRoaW4gMCBhbmQgYG1heGBcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cblxuICBmdW5jdGlvbiBsb29wKHZhbHVlLCBtYXgpIHtcbiAgICB2YXIgcmVzdWx0ID0gdmFsdWUgJSBtYXg7XG5cbiAgICBpZiAocmVzdWx0IDwgMCkge1xuICAgICAgcmVzdWx0ICs9IG1heDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgVEhSRUUuTWF0aFV0aWxzLmlzUG93ZXJPZlR3b1xuICAgKi9cblxuICBmdW5jdGlvbiBpc1Bvd2VyT2ZUd28oeCkge1xuICAgIHJldHVybiB0aHJlZS5NYXRoVXRpbHMuaXNQb3dlck9mVHdvKHgpO1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBDb21wdXRlcyB0aGUgc3VtIG9mIGFuIGFycmF5XG4gICAqIEBtZW1iZXJPZiBQU1YudXRpbHNcbiAgICogQHBhcmFtIHtudW1iZXJbXX0gYXJyYXlcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG5cbiAgZnVuY3Rpb24gc3VtKGFycmF5KSB7XG4gICAgcmV0dXJuIGFycmF5LnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEgKyBiO1xuICAgIH0sIDApO1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBDb21wdXRlcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzXG4gICAqIEBtZW1iZXJPZiBQU1YudXRpbHNcbiAgICogQHBhcmFtIHtQU1YuUG9pbnR9IHAxXG4gICAqIEBwYXJhbSB7UFNWLlBvaW50fSBwMlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cblxuICBmdW5jdGlvbiBkaXN0YW5jZShwMSwgcDIpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHAxLnggLSBwMi54LCAyKSArIE1hdGgucG93KHAxLnkgLSBwMi55LCAyKSk7XG4gIH1cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IENvbXB1dGUgdGhlIHNob3J0ZXN0IG9mZnNldCBiZXR3ZWVuIHR3byBsb25naXR1ZGVzXG4gICAqIEBtZW1iZXJPZiBQU1YudXRpbHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21cbiAgICogQHBhcmFtIHtudW1iZXJ9IHRvXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGdldFNob3J0ZXN0QXJjKGZyb20sIHRvKSB7XG4gICAgdmFyIHRDYW5kaWRhdGVzID0gWzAsIC8vIGRpcmVjdFxuICAgIE1hdGguUEkgKiAyLCAvLyBjbG9jay13aXNlIGNyb3NzIHplcm9cbiAgICAtTWF0aC5QSSAqIDIgLy8gY291bnRlci1jbG9jay13aXNlIGNyb3NzIHplcm9cbiAgICBdO1xuICAgIHJldHVybiB0Q2FuZGlkYXRlcy5yZWR1Y2UoZnVuY3Rpb24gKHZhbHVlLCBjYW5kaWRhdGUpIHtcbiAgICAgIHZhciBuZXdDYW5kaWRhdGUgPSB0byAtIGZyb20gKyBjYW5kaWRhdGU7XG4gICAgICByZXR1cm4gTWF0aC5hYnMobmV3Q2FuZGlkYXRlKSA8IE1hdGguYWJzKHZhbHVlKSA/IG5ld0NhbmRpZGF0ZSA6IHZhbHVlO1xuICAgIH0sIEluZmluaXR5KTtcbiAgfVxuICAvKipcbiAgICogQHN1bW1hcnkgQ29tcHV0ZXMgdGhlIGFuZ2xlIGJldHdlZW4gdGhlIGN1cnJlbnQgcG9zaXRpb24gYW5kIGEgdGFyZ2V0IHBvc2l0aW9uXG4gICAqIEBtZW1iZXJPZiBQU1YudXRpbHNcbiAgICogQHBhcmFtIHtQU1YuUG9zaXRpb259IHBvc2l0aW9uMVxuICAgKiBAcGFyYW0ge1BTVi5Qb3NpdGlvbn0gcG9zaXRpb24yXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGdldEFuZ2xlKHBvc2l0aW9uMSwgcG9zaXRpb24yKSB7XG4gICAgcmV0dXJuIE1hdGguYWNvcyhNYXRoLmNvcyhwb3NpdGlvbjEubGF0aXR1ZGUpICogTWF0aC5jb3MocG9zaXRpb24yLmxhdGl0dWRlKSAqIE1hdGguY29zKHBvc2l0aW9uMS5sb25naXR1ZGUgLSBwb3NpdGlvbjIubG9uZ2l0dWRlKSArIE1hdGguc2luKHBvc2l0aW9uMS5sYXRpdHVkZSkgKiBNYXRoLnNpbihwb3NpdGlvbjIubGF0aXR1ZGUpKTtcbiAgfVxuICAvKipcbiAgICogQHN1bW1hcnkgUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzIG9uIGEgc3BoZXJlIG9mIHJhZGl1cyBvbmVcbiAgICoge0BsaW5rIGh0dHA6Ly93d3cubW92YWJsZS10eXBlLmNvLnVrL3NjcmlwdHMvbGF0bG9uZy5odG1sfVxuICAgKiBAbWVtYmVyT2YgUFNWLnV0aWxzXG4gICAqIEBwYXJhbSB7bnVtYmVyW119IHAxXG4gICAqIEBwYXJhbSB7bnVtYmVyW119IHAyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGdyZWF0QXJjRGlzdGFuY2UocDEsIHAyKSB7XG4gICAgdmFyIM67MSA9IHAxWzBdLFxuICAgICAgICDPhjEgPSBwMVsxXTtcbiAgICB2YXIgzrsyID0gcDJbMF0sXG4gICAgICAgIM+GMiA9IHAyWzFdO1xuICAgIHZhciB4ID0gKM67MiAtIM67MSkgKiBNYXRoLmNvcygoz4YxICsgz4YyKSAvIDIpO1xuICAgIHZhciB5ID0gz4YyIC0gz4YxO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG4gIH1cblxuICAvKipcbiAgICogQHN1bW1hcnkgVHJhbnNmb3JtcyBhIHN0cmluZyB0byBkYXNoLWNhc2Uge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9zaGFoYXRhL2Rhc2hlcml6ZX1cbiAgICogQG1lbWJlck9mIFBTVi51dGlsc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBmdW5jdGlvbiBkYXNoZXJpemUoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bQS1aXSg/Oig/PVteQS1aXSl8W0EtWl0qKD89W0EtWl1bXkEtWl18JCkpL2csIGZ1bmN0aW9uIChzLCBpKSB7XG4gICAgICByZXR1cm4gKGkgPiAwID8gJy0nIDogJycpICsgcy50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBvbmx5IGJlIHRyaWdnZXJlZCBhdCBtb3N0IG9uY2UgZHVyaW5nIGEgZ2l2ZW4gd2luZG93IG9mIHRpbWUuXG4gICAqIEBtZW1iZXJPZiBQU1YudXRpbHNcbiAgICogQGNvcHlyaWdodCB1bmRlcnNjb3JlLmpzIC0gbW9kaWZpZWQgYnkgQ2zDqW1lbnQgUHLDqXZvc3Qge0BsaW5rIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI3MDc4NDAxfVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0XG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAgICovXG5cbiAgZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlICovXG4gICAgdmFyIHNlbGYsIGFyZ3MsIHJlc3VsdDtcbiAgICB2YXIgdGltZW91dDtcbiAgICB2YXIgcHJldmlvdXMgPSAwO1xuXG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24gbGF0ZXIoKSB7XG4gICAgICBwcmV2aW91cyA9IERhdGUubm93KCk7XG4gICAgICB0aW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShzZWxmLCBhcmdzKTtcblxuICAgICAgaWYgKCF0aW1lb3V0KSB7XG4gICAgICAgIHNlbGYgPSBhcmdzID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuXG4gICAgICBpZiAoIXByZXZpb3VzKSB7XG4gICAgICAgIHByZXZpb3VzID0gbm93O1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgICBzZWxmID0gdGhpcztcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG5cbiAgICAgIGlmIChyZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiB3YWl0KSB7XG4gICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgIHRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShzZWxmLCBhcmdzKTtcblxuICAgICAgICBpZiAoIXRpbWVvdXQpIHtcbiAgICAgICAgICBzZWxmID0gYXJncyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQpIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlICovXG4gIH1cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IFRlc3QgaWYgYW4gb2JqZWN0IGlzIGEgcGxhaW4gb2JqZWN0XG4gICAqIEBtZW1iZXJPZiBQU1YudXRpbHNcbiAgICogQGRlc2NyaXB0aW9uIFRlc3QgaWYgYW4gb2JqZWN0IGlzIGEgcGxhaW4gb2JqZWN0LCBpLmUuIGlzIGNvbnN0cnVjdGVkXG4gICAqIGJ5IHRoZSBidWlsdC1pbiBPYmplY3QgY29uc3RydWN0b3IgYW5kIGluaGVyaXRzIGRpcmVjdGx5IGZyb20gT2JqZWN0LnByb3RvdHlwZVxuICAgKiBvciBudWxsLiBTb21lIGJ1aWx0LWluIG9iamVjdHMgcGFzcyB0aGUgdGVzdCwgZS5nLiBNYXRoIHdoaWNoIGlzIGEgcGxhaW4gb2JqZWN0XG4gICAqIGFuZCBzb21lIGhvc3Qgb3IgZXhvdGljIG9iamVjdHMgbWF5IHBhc3MgYWxzby5cbiAgICoge0BsaW5rIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzU4NzgxMDEvMTIwNzY3MH1cbiAgICogQHBhcmFtIHsqfSBvYmpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG4gICAgLy8gQmFzaWMgY2hlY2sgZm9yIFR5cGUgb2JqZWN0IHRoYXQncyBub3QgbnVsbFxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGwpIHtcbiAgICAgIC8vIElmIE9iamVjdC5nZXRQcm90b3R5cGVPZiBzdXBwb3J0ZWQsIHVzZSBpdFxuICAgICAgaWYgKHR5cGVvZiBPYmplY3QuZ2V0UHJvdG90eXBlT2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XG4gICAgICAgIHJldHVybiBwcm90byA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fCBwcm90byA9PT0gbnVsbDtcbiAgICAgIH0gLy8gT3RoZXJ3aXNlLCB1c2UgaW50ZXJuYWwgY2xhc3NcbiAgICAgIC8vIFRoaXMgc2hvdWxkIGJlIHJlbGlhYmxlIGFzIGlmIGdldFByb3RvdHlwZU9mIG5vdCBzdXBwb3J0ZWQsIGlzIHByZS1FUzVcblxuXG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xuICAgIH0gLy8gTm90IGFuIG9iamVjdFxuXG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IE1lcmdlcyB0aGUgZW51bWVyYWJsZSBhdHRyaWJ1dGVzIG9mIHR3byBvYmplY3RzXG4gICAqIEBtZW1iZXJPZiBQU1YudXRpbHNcbiAgICogQGRlc2NyaXB0aW9uIFJlcGxhY2VzIGFycmF5cyBhbmQgYWx0ZXJzIHRoZSB0YXJnZXQgb2JqZWN0LlxuICAgKiBAY29weXJpZ2h0IE5pY2hvbGFzIEZpc2hlciA8bmZpc2hlcjExMEBnbWFpbC5jb20+XG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICogQHBhcmFtIHtPYmplY3R9IHNyY1xuICAgKiBAcmV0dXJucyB7T2JqZWN0fSB0YXJnZXRcbiAgICovXG5cbiAgZnVuY3Rpb24gZGVlcG1lcmdlKHRhcmdldCwgc3JjKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgKi9cbiAgICB2YXIgZmlyc3QgPSBzcmM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlKHRhcmdldCwgc3JjKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShzcmMpKSB7XG4gICAgICAgIGlmICghdGFyZ2V0IHx8ICFBcnJheS5pc0FycmF5KHRhcmdldCkpIHtcbiAgICAgICAgICB0YXJnZXQgPSBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXQubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHNyYy5mb3JFYWNoKGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgdGFyZ2V0W2ldID0gbWVyZ2UobnVsbCwgZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3JjID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoIXRhcmdldCB8fCBBcnJheS5pc0FycmF5KHRhcmdldCkpIHtcbiAgICAgICAgICB0YXJnZXQgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5rZXlzKHNyYykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBzcmNba2V5XSAhPT0gJ29iamVjdCcgfHwgIXNyY1trZXldIHx8ICFpc1BsYWluT2JqZWN0KHNyY1trZXldKSkge1xuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzcmNba2V5XTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNyY1trZXldICE9IGZpcnN0KSB7XG4gICAgICAgICAgICBpZiAoIXRhcmdldFtrZXldKSB7XG4gICAgICAgICAgICAgIHRhcmdldFtrZXldID0gbWVyZ2UobnVsbCwgc3JjW2tleV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWVyZ2UodGFyZ2V0W2tleV0sIHNyY1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0ID0gc3JjO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0odGFyZ2V0LCBzcmMpO1xuICAgIC8qIGVzbGludC1lbmFibGUgKi9cbiAgfVxuICAvKipcbiAgICogQHN1bW1hcnkgRGVlcGx5IGNsb25lcyBhbiBvYmplY3RcbiAgICogQG1lbWJlck9mIFBTVi51dGlsc1xuICAgKiBAcGFyYW0ge09iamVjdH0gc3JjXG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNsb25lKHNyYykge1xuICAgIHJldHVybiBkZWVwbWVyZ2UobnVsbCwgc3JjKTtcbiAgfVxuICAvKipcbiAgICogQHN1bW1lcnkgVGVzdCBvZiBhbiBvYmplY3QgaXMgZW1wdHlcbiAgICogQG1lbWJlck9mIFBTVi51dGlsc1xuICAgKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cblxuICBmdW5jdGlvbiBpc0VtcHR5KG9iaikge1xuICAgIHJldHVybiAhb2JqIHx8IE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSAwICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBMb29wcyBvdmVyIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBhbiBvYmplY3RcbiAgICogQG1lbWJlck9mIFBTVi51dGlsc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGVhY2gob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIE9iamVjdC5rZXlzKG9iamVjdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBjYWxsYmFjayhvYmplY3Rba2V5XSwga2V5KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQHN1bW1hcnkgUmV0dXJucyBpZiBhIHZhbHUgaXMgbnVsbCBvciB1bmRlZmluZWRcbiAgICogQG1lbWJlck9mIFBTVi51dGlsc1xuICAgKiBAcGFyYW0geyp9IHZhbFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cblxuICBmdW5jdGlvbiBpc05pbCh2YWwpIHtcbiAgICByZXR1cm4gdmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkO1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBSZXR1cm5zIHRoZSBmaXJzdCBub24gbnVsbCBub24gdW5kZWZpbmVkIHBhcmFtZXRlclxuICAgKiBAbWVtYmVyT2YgUFNWLnV0aWxzXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVzXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGZpcnN0Tm9uTnVsbCgpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgdmFsdWVzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgdmFsdWVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGZvciAodmFyIF9pID0gMCwgX3ZhbHVlcyA9IHZhbHVlczsgX2kgPCBfdmFsdWVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIHZhbCA9IF92YWx1ZXNbX2ldO1xuXG4gICAgICBpZiAoIWlzTmlsKHZhbCkpIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBSZXR1cm5zIGRlZXAgZXF1YWxpdHkgYmV0d2VlbiBvYmplY3RzXG4gICAqIHtAbGluayBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9lZ2FyZG5lci9lZmQzNGYyNzBjYzMzZGI2N2MwMjQ2ZTgzNzY4OWNiOX1cbiAgICogQHBhcmFtIG9iajFcbiAgICogQHBhcmFtIG9iajJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgZnVuY3Rpb24gZGVlcEVxdWFsKG9iajEsIG9iajIpIHtcbiAgICBpZiAob2JqMSA9PT0gb2JqMikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdChvYmoxKSAmJiBpc09iamVjdChvYmoyKSkge1xuICAgICAgaWYgKE9iamVjdC5rZXlzKG9iajEpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMob2JqMikubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2kyID0gMCwgX09iamVjdCRrZXlzID0gT2JqZWN0LmtleXMob2JqMSk7IF9pMiA8IF9PYmplY3Qka2V5cy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgIHZhciBwcm9wID0gX09iamVjdCRrZXlzW19pMl07XG5cbiAgICAgICAgaWYgKCFkZWVwRXF1YWwob2JqMVtwcm9wXSwgb2JqMltwcm9wXSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHN1bW1hcnkgUmV0dXJucyB0aGUgcGx1Z2luIGNvbnN0cnVjdG9yIGZyb20gdGhlIGltcG9ydGVkIG9iamVjdFxuICAgKiBGb3IgcmV0cm9jb21wYXRpYmlsaXR5IHdpdGggcHJldmlvdXMgZGVmYXVsdCBleHBvcnRzXG4gICAqIEBtZW1iZXJPZiBQU1YudXRpbHNcbiAgICogQHBhY2thZ2VcbiAgICovXG5cbiAgZnVuY3Rpb24gcGx1Z2luSW50ZXJvcChwbHVnaW4sIHRhcmdldCkge1xuICAgIGlmIChwbHVnaW4pIHtcbiAgICAgIGZvciAodmFyIF9pID0gMCwgX2FyciA9IFtbJ18nLCBwbHVnaW5dXS5jb25jYXQoT2JqZWN0LmVudHJpZXMocGx1Z2luKSk7IF9pIDwgX2Fyci5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIF9hcnIkX2kgPSBfYXJyW19pXSxcbiAgICAgICAgICAgIHAgPSBfYXJyJF9pWzFdO1xuXG4gICAgICAgIGlmIChwLnByb3RvdHlwZSBpbnN0YW5jZW9mIHRhcmdldCkge1xuICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IEJ1aWxkcyBhbiBFcnJvciB3aXRoIG5hbWUgJ0Fib3J0RXJyb3InXG4gICAqIEBtZW1iZXJPZiBQU1YudXRpbHNcbiAgICogQHJldHVybiB7RXJyb3J9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGdldEFib3J0RXJyb3IoKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdMb2FkaW5nIHdhcyBhYm9ydGVkLicpO1xuICAgIGVycm9yLm5hbWUgPSAnQWJvcnRFcnJvcic7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBUZXN0cyBpZiBhbiBFcnJvciBoYXMgbmFtZSAnQWJvcnRFcnJvcidcbiAgICogQG1lbWJlck9mIFBTVi51dGlsc1xuICAgKiBAcGFyYW0ge0Vycm9yfSBlcnJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG5cbiAgZnVuY3Rpb24gaXNBYm9ydEVycm9yKGVycikge1xuICAgIHJldHVybiAoZXJyID09IG51bGwgPyB2b2lkIDAgOiBlcnIubmFtZSkgPT09ICdBYm9ydEVycm9yJztcbiAgfVxuICAvKipcbiAgICogQHN1bW1hcnkgRGlzcGxheXMgYSB3YXJuaW5nIGluIHRoZSBjb25zb2xlXG4gICAqIEBtZW1iZXJPZiBQU1YudXRpbHNcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAgICovXG5cbiAgZnVuY3Rpb24gbG9nV2FybihtZXNzYWdlKSB7XG4gICAgY29uc29sZS53YXJuKFwiUGhvdG9TcGhlcmVWaWV3ZXI6IFwiICsgbWVzc2FnZSk7XG4gIH1cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IENoZWNrcyBpZiBhbiBvYmplY3QgaXMgYSB7UFNWLkV4dGVuZGVkUG9zaXRpb259LCBpZSBoYXMgeC95IG9yIGxvbmdpdHVkZS9sYXRpdHVkZVxuICAgKiBAbWVtYmVyT2YgUFNWLnV0aWxzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3RcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGlzRXh0ZW5kZWRQb3NpdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gW1sneCcsICd5J10sIFsnbG9uZ2l0dWRlJywgJ2xhdGl0dWRlJ11dLnNvbWUoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBrZXkxID0gX3JlZlswXSxcbiAgICAgICAgICBrZXkyID0gX3JlZlsxXTtcbiAgICAgIHJldHVybiBvYmplY3Rba2V5MV0gIT09IHVuZGVmaW5lZCAmJiBvYmplY3Rba2V5Ml0gIT09IHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQHN1bW1hcnkgUmV0dXJucyB0aGUgdmFsdWUgb2YgYSBnaXZlbiBhdHRyaWJ1dGUgaW4gdGhlIHBhbm9yYW1hIG1ldGFkYXRhXG4gICAqIEBtZW1iZXJPZiBQU1YudXRpbHNcbiAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFcbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJcbiAgICogQHJldHVybnMgKG51bWJlcilcbiAgICovXG5cbiAgZnVuY3Rpb24gZ2V0WE1QVmFsdWUoZGF0YSwgYXR0cikge1xuICAgIC8vIFhNUCBkYXRhIGFyZSBzdG9yZWQgaW4gY2hpbGRyZW5cbiAgICB2YXIgcmVzdWx0ID0gZGF0YS5tYXRjaCgnPEdQYW5vOicgKyBhdHRyICsgJz4oLiopPC9HUGFubzonICsgYXR0ciArICc+Jyk7XG5cbiAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICB2YXIgdmFsID0gcGFyc2VJbnQocmVzdWx0WzFdLCAxMCk7XG4gICAgICByZXR1cm4gaXNOYU4odmFsKSA/IG51bGwgOiB2YWw7XG4gICAgfSAvLyBYTVAgZGF0YSBhcmUgc3RvcmVkIGluIGF0dHJpYnV0ZXNcblxuXG4gICAgcmVzdWx0ID0gZGF0YS5tYXRjaCgnR1Bhbm86JyArIGF0dHIgKyAnPVwiKC4qPylcIicpO1xuXG4gICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgdmFyIF92YWwgPSBwYXJzZUludChyZXN1bHRbMV0sIDEwKTtcblxuICAgICAgcmV0dXJuIGlzTmFOKF92YWwpID8gbnVsbCA6IF92YWw7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIEByZWFkb25seVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7e3RvcDogc3RyaW5nLCBsZWZ0OiBzdHJpbmcsIGJvdHRvbTogc3RyaW5nLCBjZW50ZXI6IHN0cmluZywgcmlnaHQ6IHN0cmluZ319XG4gICAqL1xuXG4gIHZhciBDU1NfUE9TSVRJT05TID0ge1xuICAgIHRvcDogJzAlJyxcbiAgICBib3R0b206ICcxMDAlJyxcbiAgICBsZWZ0OiAnMCUnLFxuICAgIHJpZ2h0OiAnMTAwJScsXG4gICAgY2VudGVyOiAnNTAlJ1xuICB9O1xuICAvKipcbiAgICogQHN1bW1hcnkgVHJhbnNsYXRlIENTUyB2YWx1ZXMgbGlrZSBcInRvcCBjZW50ZXJcIiBvciBcIjEwJSA1MCVcIiBhcyB0b3AgYW5kIGxlZnQgcG9zaXRpb25zXG4gICAqIEBtZW1iZXJPZiBQU1YudXRpbHNcbiAgICogQGRlc2NyaXB0aW9uIFRoZSBpbXBsZW1lbnRhdGlvbiBpcyBhcyBjbG9zZSBhcyBwb3NzaWJsZSB0byB0aGUgXCJiYWNrZ3JvdW5kLXBvc2l0aW9uXCIgc3BlY2lmaWNhdGlvblxuICAgKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2JhY2tncm91bmQtcG9zaXRpb259XG4gICAqIEBwYXJhbSB7c3RyaW5nfFBTVi5Qb2ludH0gdmFsdWVcbiAgICogQHJldHVybnMge1BTVi5Qb2ludH1cbiAgICovXG5cbiAgZnVuY3Rpb24gcGFyc2VQb3NpdGlvbih2YWx1ZSkge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IDAuNSxcbiAgICAgICAgeTogMC41XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIHRva2VucyA9IHZhbHVlLnRvTG9jYWxlTG93ZXJDYXNlKCkuc3BsaXQoJyAnKS5zbGljZSgwLCAyKTtcblxuICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAoQ1NTX1BPU0lUSU9OU1t0b2tlbnNbMF1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdG9rZW5zID0gW3Rva2Vuc1swXSwgJ2NlbnRlciddO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9rZW5zID0gW3Rva2Vuc1swXSwgdG9rZW5zWzBdXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgeEZpcnN0ID0gdG9rZW5zWzFdICE9PSAnbGVmdCcgJiYgdG9rZW5zWzFdICE9PSAncmlnaHQnICYmIHRva2Vuc1swXSAhPT0gJ3RvcCcgJiYgdG9rZW5zWzBdICE9PSAnYm90dG9tJztcbiAgICB0b2tlbnMgPSB0b2tlbnMubWFwKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgcmV0dXJuIENTU19QT1NJVElPTlNbdG9rZW5dIHx8IHRva2VuO1xuICAgIH0pO1xuXG4gICAgaWYgKCF4Rmlyc3QpIHtcbiAgICAgIHRva2Vucy5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgdmFyIHBhcnNlZCA9IHRva2Vucy5qb2luKCcgJykubWF0Y2goL14oWzAtOS5dKyklIChbMC05Ll0rKSUkLyk7XG5cbiAgICBpZiAocGFyc2VkKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBwYXJzZUZsb2F0KHBhcnNlZFsxXSkgLyAxMDAsXG4gICAgICAgIHk6IHBhcnNlRmxvYXQocGFyc2VkWzJdKSAvIDEwMFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogMC41LFxuICAgICAgICB5OiAwLjVcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdmFyIFhfVkFMVUVTID0gWydsZWZ0JywgJ2NlbnRlcicsICdyaWdodCddO1xuICAvKipcbiAgICogQHJlYWRvbmx5XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHZhciBZX1ZBTFVFUyA9IFsndG9wJywgJ2NlbnRlcicsICdib3R0b20nXTtcbiAgLyoqXG4gICAqIEByZWFkb25seVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB2YXIgUE9TX1ZBTFVFUyA9IFtdLmNvbmNhdChYX1ZBTFVFUywgWV9WQUxVRVMpO1xuICAvKipcbiAgICogQHJlYWRvbmx5XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHZhciBDRU5URVIgPSAnY2VudGVyJztcbiAgLyoqXG4gICAqIEBzdW1tYXJ5IFBhcnNlIGEgQ1NTLWxpa2UgcG9zaXRpb24gaW50byBhbiBhcnJheSBvZiBwb3NpdGlvbiBrZXl3b3JkcyBhbW9uZyB0b3AsIGJvdHRvbSwgbGVmdCwgcmlnaHQgYW5kIGNlbnRlclxuICAgKiBAbWVtYmVyT2YgUFNWLnV0aWxzXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgc3RyaW5nW119IHZhbHVlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hbGxvd0NlbnRlcj10cnVlXSBhbGxvdyBcImNlbnRlciBjZW50ZXJcIlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNzc09yZGVyPXRydWVdIGZvcmNlIENTUyBvcmRlciAoeSBheGlzIHRoZW4geCBheGlzKVxuICAgKiBAcmV0dXJuIHtzdHJpbmdbXX1cbiAgICovXG5cbiAgZnVuY3Rpb24gY2xlYW5Qb3NpdGlvbih2YWx1ZSwgX3RlbXApIHtcbiAgICB2YXIgX3JlZjIgPSBfdGVtcCA9PT0gdm9pZCAwID8ge1xuICAgICAgYWxsb3dDZW50ZXI6IHRydWUsXG4gICAgICBjc3NPcmRlcjogdHJ1ZVxuICAgIH0gOiBfdGVtcCxcbiAgICAgICAgYWxsb3dDZW50ZXIgPSBfcmVmMi5hbGxvd0NlbnRlcixcbiAgICAgICAgY3NzT3JkZXIgPSBfcmVmMi5jc3NPcmRlcjtcblxuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnNwbGl0KCcgJyk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKHZhbHVlWzBdID09PSBDRU5URVIpIHtcbiAgICAgICAgdmFsdWUgPSBbQ0VOVEVSLCBDRU5URVJdO1xuICAgICAgfSBlbHNlIGlmIChYX1ZBTFVFUy5pbmRleE9mKHZhbHVlWzBdKSAhPT0gLTEpIHtcbiAgICAgICAgdmFsdWUgPSBbQ0VOVEVSLCB2YWx1ZVswXV07XG4gICAgICB9IGVsc2UgaWYgKFlfVkFMVUVTLmluZGV4T2YodmFsdWVbMF0pICE9PSAtMSkge1xuICAgICAgICB2YWx1ZSA9IFt2YWx1ZVswXSwgQ0VOVEVSXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodmFsdWUubGVuZ3RoICE9PSAyIHx8IFBPU19WQUxVRVMuaW5kZXhPZih2YWx1ZVswXSkgPT09IC0xIHx8IFBPU19WQUxVRVMuaW5kZXhPZih2YWx1ZVsxXSkgPT09IC0xKSB7XG4gICAgICBsb2dXYXJuKFwiVW5wYXJzYWJsZSBwb3NpdGlvbiBcIiArIHZhbHVlKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICghYWxsb3dDZW50ZXIgJiYgdmFsdWVbMF0gPT09IENFTlRFUiAmJiB2YWx1ZVsxXSA9PT0gQ0VOVEVSKSB7XG4gICAgICBsb2dXYXJuKFwiSW52YWxpZCBwb3NpdGlvbiBjZW50ZXIgY2VudGVyXCIpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGNzc09yZGVyICYmICFwb3NpdGlvbklzT3JkZXJlZCh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gW3ZhbHVlWzFdLCB2YWx1ZVswXV07XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlWzFdID09PSBDRU5URVIgJiYgWF9WQUxVRVMuaW5kZXhPZih2YWx1ZVswXSkgIT09IC0xKSB7XG4gICAgICB2YWx1ZSA9IFtDRU5URVIsIHZhbHVlWzBdXTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWVbMF0gPT09IENFTlRFUiAmJiBZX1ZBTFVFUy5pbmRleE9mKHZhbHVlWzFdKSAhPT0gLTEpIHtcbiAgICAgIHZhbHVlID0gW3ZhbHVlWzFdLCBDRU5URVJdO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogQHN1bW1hcnkgQ2hlY2tzIGlmIGFuIGFycmF5IG9mIHR3byBwb3NpdGlvbnMgaXMgb3JkZXJlZCAoeSBheGlzIHRoZW4geCBheGlzKVxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cblxuICBmdW5jdGlvbiBwb3NpdGlvbklzT3JkZXJlZCh2YWx1ZSkge1xuICAgIHJldHVybiBZX1ZBTFVFUy5pbmRleE9mKHZhbHVlWzBdKSAhPT0gLTEgJiYgWF9WQUxVRVMuaW5kZXhPZih2YWx1ZVsxXSkgIT09IC0xO1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBQYXJzZXMgYW4gc3BlZWRcbiAgICogQG1lbWJlck9mIFBTVi51dGlsc1xuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHNwZWVkIC0gVGhlIHNwZWVkLCBpbiByYWRpYW5zL2RlZ3JlZXMvcmV2b2x1dGlvbnMgcGVyIHNlY29uZC9taW51dGVcbiAgICogQHJldHVybnMge251bWJlcn0gcmFkaWFucyBwZXIgc2Vjb25kXG4gICAqIEB0aHJvd3Mge1BTVi5QU1ZFcnJvcn0gd2hlbiB0aGUgc3BlZWQgY2Fubm90IGJlIHBhcnNlZFxuICAgKi9cblxuICBmdW5jdGlvbiBwYXJzZVNwZWVkKHNwZWVkKSB7XG4gICAgdmFyIHBhcnNlZDtcblxuICAgIGlmICh0eXBlb2Ygc3BlZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgc3BlZWRTdHIgPSBzcGVlZC50b1N0cmluZygpLnRyaW0oKTsgLy8gU3BlZWQgZXh0cmFjdGlvblxuXG4gICAgICB2YXIgc3BlZWRWYWx1ZSA9IHBhcnNlRmxvYXQoc3BlZWRTdHIucmVwbGFjZSgvXigtP1swLTldKyg/OlxcLlswLTldKik/KS4qJC8sICckMScpKTtcbiAgICAgIHZhciBzcGVlZFVuaXQgPSBzcGVlZFN0ci5yZXBsYWNlKC9eLT9bMC05XSsoPzpcXC5bMC05XSopPyguKikkLywgJyQxJykudHJpbSgpOyAvLyBcInBlciBtaW51dGVcIiAtPiBcInBlciBzZWNvbmRcIlxuXG4gICAgICBpZiAoc3BlZWRVbml0Lm1hdGNoKC8ocG18cGVyIG1pbnV0ZSkkLykpIHtcbiAgICAgICAgc3BlZWRWYWx1ZSAvPSA2MDtcbiAgICAgIH0gLy8gV2hpY2ggdW5pdD9cblxuXG4gICAgICBzd2l0Y2ggKHNwZWVkVW5pdCkge1xuICAgICAgICAvLyBEZWdyZWVzIHBlciBtaW51dGUgLyBzZWNvbmRcbiAgICAgICAgY2FzZSAnZHBtJzpcbiAgICAgICAgY2FzZSAnZGVncmVlcyBwZXIgbWludXRlJzpcbiAgICAgICAgY2FzZSAnZHBzJzpcbiAgICAgICAgY2FzZSAnZGVncmVlcyBwZXIgc2Vjb25kJzpcbiAgICAgICAgICBwYXJzZWQgPSB0aHJlZS5NYXRoVXRpbHMuZGVnVG9SYWQoc3BlZWRWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFJhZGlhbnMgcGVyIG1pbnV0ZSAvIHNlY29uZFxuXG4gICAgICAgIGNhc2UgJ3JkcG0nOlxuICAgICAgICBjYXNlICdyYWRpYW5zIHBlciBtaW51dGUnOlxuICAgICAgICBjYXNlICdyZHBzJzpcbiAgICAgICAgY2FzZSAncmFkaWFucyBwZXIgc2Vjb25kJzpcbiAgICAgICAgICBwYXJzZWQgPSBzcGVlZFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBSZXZvbHV0aW9ucyBwZXIgbWludXRlIC8gc2Vjb25kXG5cbiAgICAgICAgY2FzZSAncnBtJzpcbiAgICAgICAgY2FzZSAncmV2b2x1dGlvbnMgcGVyIG1pbnV0ZSc6XG4gICAgICAgIGNhc2UgJ3Jwcyc6XG4gICAgICAgIGNhc2UgJ3Jldm9sdXRpb25zIHBlciBzZWNvbmQnOlxuICAgICAgICAgIHBhcnNlZCA9IHNwZWVkVmFsdWUgKiBNYXRoLlBJICogMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gVW5rbm93biB1bml0XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgUFNWRXJyb3IoJ1Vua25vd24gc3BlZWQgdW5pdCBcIicgKyBzcGVlZFVuaXQgKyAnXCInKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGFyc2VkID0gc3BlZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICAvKipcbiAgICogQHN1bW1hcnkgUGFyc2VzIGFuIGFuZ2xlIHZhbHVlIGluIHJhZGlhbnMgb3IgZGVncmVlcyBhbmQgcmV0dXJucyBhIG5vcm1hbGl6ZWQgdmFsdWUgaW4gcmFkaWFuc1xuICAgKiBAbWVtYmVyT2YgUFNWLnV0aWxzXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gYW5nbGUgLSBlZzogMy4xNCwgMy4xNHJhZCwgMTgwZGVnXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3plcm9DZW50ZXI9ZmFsc2VdIC0gbm9ybWFsaXplIGJldHdlZW4gLVBpIC0gUGkgaW5zdGVhZCBvZiAwIC0gMipQaVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtoYWxmQ2lyY2xlPXplcm9DZW50ZXJdIC0gbm9ybWFsaXplIGJldHdlZW4gLVBpLzIgLSBQaS8yIGluc3RlYWQgb2YgLVBpIC0gUGlcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICogQHRocm93cyB7UFNWLlBTVkVycm9yfSB3aGVuIHRoZSBhbmdsZSBjYW5ub3QgYmUgcGFyc2VkXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHBhcnNlQW5nbGUoYW5nbGUsIHplcm9DZW50ZXIsIGhhbGZDaXJjbGUpIHtcbiAgICBpZiAoemVyb0NlbnRlciA9PT0gdm9pZCAwKSB7XG4gICAgICB6ZXJvQ2VudGVyID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGhhbGZDaXJjbGUgPT09IHZvaWQgMCkge1xuICAgICAgaGFsZkNpcmNsZSA9IHplcm9DZW50ZXI7XG4gICAgfVxuXG4gICAgdmFyIHBhcnNlZDtcblxuICAgIGlmICh0eXBlb2YgYW5nbGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBhbmdsZS50b0xvd2VyQ2FzZSgpLnRyaW0oKS5tYXRjaCgvXigtP1swLTldKyg/OlxcLlswLTldKik/KSguKikkLyk7XG5cbiAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBTVkVycm9yKCdVbmtub3duIGFuZ2xlIFwiJyArIGFuZ2xlICsgJ1wiJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZSA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICAgICAgdmFyIHVuaXQgPSBtYXRjaFsyXTtcblxuICAgICAgaWYgKHVuaXQpIHtcbiAgICAgICAgc3dpdGNoICh1bml0KSB7XG4gICAgICAgICAgY2FzZSAnZGVnJzpcbiAgICAgICAgICBjYXNlICdkZWdzJzpcbiAgICAgICAgICAgIHBhcnNlZCA9IHRocmVlLk1hdGhVdGlscy5kZWdUb1JhZCh2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3JhZCc6XG4gICAgICAgICAgY2FzZSAncmFkcyc6XG4gICAgICAgICAgICBwYXJzZWQgPSB2YWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBQU1ZFcnJvcignVW5rbm93biBhbmdsZSB1bml0IFwiJyArIHVuaXQgKyAnXCInKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYW5nbGUgPT09ICdudW1iZXInICYmICFpc05hTihhbmdsZSkpIHtcbiAgICAgIHBhcnNlZCA9IGFuZ2xlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgUFNWRXJyb3IoJ1Vua25vd24gYW5nbGUgXCInICsgYW5nbGUgKyAnXCInKTtcbiAgICB9XG5cbiAgICBwYXJzZWQgPSBsb29wKHplcm9DZW50ZXIgPyBwYXJzZWQgKyBNYXRoLlBJIDogcGFyc2VkLCBNYXRoLlBJICogMik7XG4gICAgcmV0dXJuIHplcm9DZW50ZXIgPyB0aHJlZS5NYXRoVXRpbHMuY2xhbXAocGFyc2VkIC0gTWF0aC5QSSwgLU1hdGguUEkgLyAoaGFsZkNpcmNsZSA/IDIgOiAxKSwgTWF0aC5QSSAvIChoYWxmQ2lyY2xlID8gMiA6IDEpKSA6IHBhcnNlZDtcbiAgfVxuICAvKipcbiAgICogQHN1bW1hcnkgQ3JlYXRlcyBhIFRIUkVFIHRleHR1cmUgZnJvbSBhbiBpbWFnZVxuICAgKiBAbWVtYmVyT2YgUFNWLnV0aWxzXG4gICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudCB8IEhUTUxDYW52YXNFbGVtZW50fSBpbWdcbiAgICogQHJldHVybiB7ZXh0ZXJuYWw6VEhSRUUuVGV4dHVyZX1cbiAgICovXG5cbiAgZnVuY3Rpb24gY3JlYXRlVGV4dHVyZShpbWcpIHtcbiAgICB2YXIgdGV4dHVyZSA9IG5ldyB0aHJlZS5UZXh0dXJlKGltZyk7XG4gICAgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgdGV4dHVyZS5taW5GaWx0ZXIgPSB0aHJlZS5MaW5lYXJGaWx0ZXI7XG4gICAgdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcbiAgICByZXR1cm4gdGV4dHVyZTtcbiAgfVxuICB2YXIgcXVhdGVybmlvbiA9IG5ldyB0aHJlZS5RdWF0ZXJuaW9uKCk7XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBBcHBsaWVzIHRoZSBpbnZlcnNlIG9mIEV1bGVyIGFuZ2xlcyB0byBhIHZlY3RvclxuICAgKiBAbWVtYmVyT2YgUFNWLnV0aWxzXG4gICAqIEBwYXJhbSB7ZXh0ZXJuYWw6VEhSRUUuVmVjdG9yM30gdmVjdG9yXG4gICAqIEBwYXJhbSB7ZXh0ZXJuYWw6VEhSRUUuRXVsZXJ9IGV1bGVyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFwcGx5RXVsZXJJbnZlcnNlKHZlY3RvciwgZXVsZXIpIHtcbiAgICBxdWF0ZXJuaW9uLnNldEZyb21FdWxlcihldWxlcikuaW52ZXJ0KCk7XG4gICAgdmVjdG9yLmFwcGx5UXVhdGVybmlvbihxdWF0ZXJuaW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAY2FsbGJhY2sgT25UaWNrXG4gICAqIEBzdW1tYXJ5IEZ1bmN0aW9uIGNhbGxlZCBmb3IgZWFjaCBhbmltYXRpb24gZnJhbWUgd2l0aCBjb21wdXRlZCBwcm9wZXJ0aWVzXG4gICAqIEBtZW1iZXJPZiBQU1YudXRpbHMuQW5pbWF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIG51bWJlcj59IHByb3BlcnRpZXMgLSBjdXJyZW50IHZhbHVlc1xuICAgKiBAcGFyYW0ge2Zsb2F0fSBwcm9ncmVzcyAtIDAgdG8gMVxuICAgKi9cblxuICAvKipcbiAgICogQHN1bW1hcnkgSW50ZXJwb2xhdGlvbiBoZWxwZXIgZm9yIGFuaW1hdGlvbnNcbiAgICogQG1lbWJlck9mIFBTVi51dGlsc1xuICAgKiBAZGVzY3JpcHRpb25cbiAgICogSW1wbGVtZW50cyB0aGUgUHJvbWlzZSBBUEkgd2l0aCBhbiBhZGRpdGlvbmFsIFwiY2FuY2VsXCIgbWV0aG9kLlxuICAgKiBUaGUgcHJvbWlzZSBpcyByZXNvbHZlZCB3aXRoIGB0cnVlYCB3aGVuIHRoZSBhbmltYXRpb24gaXMgY29tcGxldGVkIGFuZCBgZmFsc2VgIGlmIHRoZSBhbmltYXRpb24gaXMgY2FuY2VsbGVkLlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBhbmltID0gbmV3IEFuaW1hdGlvbih7XG4gICAqICAgICBwcm9wZXJ0aWVzOiB7XG4gICAqICAgICAgICAgd2lkdGg6IHtzdGFydDogMTAwLCBlbmQ6IDIwMH1cbiAgICogICAgIH0sXG4gICAqICAgICBkdXJhdGlvbjogNTAwMCxcbiAgICogICAgIG9uVGljazogKHByb3BlcnRpZXMpID0+IGVsZW1lbnQuc3R5bGUud2lkdGggPSBgJHtwcm9wZXJ0aWVzLndpZHRofXB4YDtcbiAgICogfSk7XG4gICAqXG4gICAqIGFuaW0udGhlbigoY29tcGxldGVkKSA9PiAuLi4pO1xuICAgKlxuICAgKiBhbmltLmNhbmNlbCgpXG4gICAqL1xuXG4gIHZhciBBbmltYXRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgT2JqZWN0Pn0gb3B0aW9ucy5wcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMucHJvcGVydGllc1tdLnN0YXJ0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMucHJvcGVydGllc1tdLmVuZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmR1cmF0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmRlbGF5PTBdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmVhc2luZz0nbGluZWFyJ11cbiAgICAgKiBAcGFyYW0ge1BTVi51dGlscy5BbmltYXRpb24uT25UaWNrfSBvcHRpb25zLm9uVGljayAtIGNhbGxlZCBvbiBlYWNoIGZyYW1lXG4gICAgICovXG4gICAgZnVuY3Rpb24gQW5pbWF0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuX19jYWxsYmFja3MgPSBbXTtcblxuICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLmVhc2luZyB8fCB0eXBlb2Ygb3B0aW9ucy5lYXNpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgb3B0aW9ucy5lYXNpbmcgPSBFQVNJTkdTW29wdGlvbnMuZWFzaW5nIHx8ICdsaW5lYXInXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX19zdGFydCA9IG51bGw7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZGVsYXkpIHtcbiAgICAgICAgICB0aGlzLl9fZGVsYXlUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fX2RlbGF5VGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICBfdGhpcy5fX2FuaW1hdGlvbkZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX19ydW4odCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCBvcHRpb25zLmRlbGF5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9fYW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX19ydW4odCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX19yZXNvbHZlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IE1haW4gbG9vcCBmb3IgdGhlIGFuaW1hdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lc3RhbXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICB2YXIgX3Byb3RvID0gQW5pbWF0aW9uLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5fX3J1biA9IGZ1bmN0aW9uIF9fcnVuKHRpbWVzdGFtcCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLl9fY2FuY2VsbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gZmlyc3QgaXRlcmF0aW9uXG5cblxuICAgICAgaWYgKHRoaXMuX19zdGFydCA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9fc3RhcnQgPSB0aW1lc3RhbXA7XG4gICAgICB9IC8vIGNvbXB1dGUgcHJvZ3Jlc3NcblxuXG4gICAgICB2YXIgcHJvZ3Jlc3MgPSAodGltZXN0YW1wIC0gdGhpcy5fX3N0YXJ0KSAvIHRoaXMub3B0aW9ucy5kdXJhdGlvbjtcbiAgICAgIHZhciBjdXJyZW50ID0ge307XG5cbiAgICAgIGlmIChwcm9ncmVzcyA8IDEuMCkge1xuICAgICAgICAvLyBpbnRlcnBvbGF0ZSBwcm9wZXJ0aWVzXG4gICAgICAgIGVhY2godGhpcy5vcHRpb25zLnByb3BlcnRpZXMsIGZ1bmN0aW9uIChwcm9wLCBuYW1lKSB7XG4gICAgICAgICAgaWYgKHByb3ApIHtcbiAgICAgICAgICAgIGN1cnJlbnRbbmFtZV0gPSBwcm9wLnN0YXJ0ICsgKHByb3AuZW5kIC0gcHJvcC5zdGFydCkgKiBfdGhpczIub3B0aW9ucy5lYXNpbmcocHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vblRpY2soY3VycmVudCwgcHJvZ3Jlc3MpO1xuICAgICAgICB0aGlzLl9fYW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5fX3J1bih0KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjYWxsIG9uVGljayBvbmUgbGFzdCB0aW1lIHdpdGggZmluYWwgdmFsdWVzXG4gICAgICAgIGVhY2godGhpcy5vcHRpb25zLnByb3BlcnRpZXMsIGZ1bmN0aW9uIChwcm9wLCBuYW1lKSB7XG4gICAgICAgICAgaWYgKHByb3ApIHtcbiAgICAgICAgICAgIGN1cnJlbnRbbmFtZV0gPSBwcm9wLmVuZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9wdGlvbnMub25UaWNrKGN1cnJlbnQsIDEuMCk7XG4gICAgICAgIHRoaXMuX19hbmltYXRpb25GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMi5fX3Jlc29sdmVkID0gdHJ1ZTtcblxuICAgICAgICAgIF90aGlzMi5fX3Jlc29sdmUodHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5fX3Jlc29sdmUgPSBmdW5jdGlvbiBfX3Jlc29sdmUodmFsdWUpIHtcbiAgICAgIHRoaXMuX19jYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgcmV0dXJuIGNiKHZhbHVlKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9fY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFByb21pc2UgY2hhaW5pbmdcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25GdWxmaWxsZWRdIC0gQ2FsbGVkIHdoZW4gdGhlIGFuaW1hdGlvbiBpcyBjb21wbGV0ZSAodHJ1ZSkgb3IgY2FuY2VsbGVkIChmYWxzZSlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8udGhlbiA9IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5fX3Jlc29sdmVkIHx8IHRoaXMuX19jYW5jZWxsZWQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9fcmVzb2x2ZWQpLnRoZW4ob25GdWxmaWxsZWQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgX3RoaXMzLl9fY2FsbGJhY2tzLnB1c2gocmVzb2x2ZSk7XG4gICAgICB9KS50aGVuKG9uRnVsZmlsbGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgQ2FuY2VscyB0aGUgYW5pbWF0aW9uXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLmNhbmNlbCA9IGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgIGlmICghdGhpcy5fX2NhbmNlbGxlZCAmJiAhdGhpcy5fX3Jlc29sdmVkKSB7XG4gICAgICAgIHRoaXMuX19jYW5jZWxsZWQgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuX19yZXNvbHZlKGZhbHNlKTtcblxuICAgICAgICBpZiAodGhpcy5fX2RlbGF5VGltZW91dCkge1xuICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5fX2RlbGF5VGltZW91dCk7XG4gICAgICAgICAgdGhpcy5fX2RlbGF5VGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fX2FuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX19hbmltYXRpb25GcmFtZSk7XG4gICAgICAgICAgdGhpcy5fX2FuaW1hdGlvbkZyYW1lID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gQW5pbWF0aW9uO1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IFJlcHJlc2VudHMgYSB2YXJpYWJsZSB0aGF0IGNhbiBkeW5hbWljYWxseSBjaGFuZ2Ugd2l0aCB0aW1lICh1c2luZyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUpXG4gICAqIEBtZW1iZXJPZiBQU1YudXRpbHNcbiAgICovXG5cbiAgdmFyIER5bmFtaWMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlZmF1bHRWYWx1ZV0gRGVmYXVsdCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbWluXSBNaW5pbXVtIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFttYXhdIE1heGltdW0gcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtsb29wVmFsdWVdIExvb3AgdmFsdWUgYmV0d2VlbiBtaW4gYW5kIG1heFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIER5bmFtaWMoZm4sIGRlZmF1bHRWYWx1ZSwgbWluLCBtYXgsIGxvb3BWYWx1ZSkge1xuICAgICAgaWYgKGRlZmF1bHRWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChtaW4gPT09IHZvaWQgMCkge1xuICAgICAgICBtaW4gPSAtSW5maW5pdHk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXggPT09IHZvaWQgMCkge1xuICAgICAgICBtYXggPSBJbmZpbml0eTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxvb3BWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGxvb3BWYWx1ZSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAqL1xuICAgICAgdGhpcy5mbiA9IGZuO1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgICB0aGlzLm1vZGUgPSBEeW5hbWljLlNUT1A7XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICAgIHRoaXMuc3BlZWQgPSAwO1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgICB0aGlzLnNwZWVkTXVsdCA9IDE7XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICAgIHRoaXMuY3VycmVudFNwZWVkID0gMDtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgICAgdGhpcy50YXJnZXQgPSAwO1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgKi9cblxuICAgICAgdGhpcy5jdXJyZW50ID0gZGVmYXVsdFZhbHVlO1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgICAgdGhpcy5tYXggPSBtYXg7XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgICB0aGlzLmxvb3BWYWx1ZSA9IGxvb3BWYWx1ZTtcblxuICAgICAgaWYgKGxvb3BWYWx1ZSAmJiBtaW4gIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFBTVkVycm9yKCdpbnZhbGlkIGNvbmZpZycpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5mbikge1xuICAgICAgICB0aGlzLmZuKGRlZmF1bHRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgYmFzZSBzcGVlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzcGVlZFxuICAgICAqL1xuXG5cbiAgICB2YXIgX3Byb3RvID0gRHluYW1pYy5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uc2V0U3BlZWQgPSBmdW5jdGlvbiBzZXRTcGVlZChzcGVlZCkge1xuICAgICAgdGhpcy5zcGVlZCA9IHNwZWVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHRoZSB0YXJnZXQgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NwZWVkTXVsdD0xXVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5nb3RvID0gZnVuY3Rpb24gZ290byhwb3NpdGlvbiwgc3BlZWRNdWx0KSB7XG4gICAgICBpZiAoc3BlZWRNdWx0ID09PSB2b2lkIDApIHtcbiAgICAgICAgc3BlZWRNdWx0ID0gMTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5tb2RlID0gRHluYW1pYy5QT1NJVElPTjtcbiAgICAgIHRoaXMudGFyZ2V0ID0gdGhpcy5sb29wVmFsdWUgPyBsb29wKHBvc2l0aW9uLCB0aGlzLm1heCkgOiB0aHJlZS5NYXRoVXRpbHMuY2xhbXAocG9zaXRpb24sIHRoaXMubWluLCB0aGlzLm1heCk7XG4gICAgICB0aGlzLnNwZWVkTXVsdCA9IHNwZWVkTXVsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5jcmVhc2UvZGVjcmVhc2UgdGhlIHRhcmdldCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzcGVlZE11bHQ9MV1cbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uc3RlcCA9IGZ1bmN0aW9uIHN0ZXAoX3N0ZXAsIHNwZWVkTXVsdCkge1xuICAgICAgaWYgKHNwZWVkTXVsdCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHNwZWVkTXVsdCA9IDE7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm1vZGUgIT09IER5bmFtaWMuUE9TSVRJT04pIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZ290byh0aGlzLnRhcmdldCArIF9zdGVwLCBzcGVlZE11bHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgaW5maW5pdGUgbW92ZW1lbnRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbnZlcnQ9ZmFsc2VdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzcGVlZE11bHQ9MV1cbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8ucm9sbCA9IGZ1bmN0aW9uIHJvbGwoaW52ZXJ0LCBzcGVlZE11bHQpIHtcbiAgICAgIGlmIChpbnZlcnQgPT09IHZvaWQgMCkge1xuICAgICAgICBpbnZlcnQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNwZWVkTXVsdCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHNwZWVkTXVsdCA9IDE7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubW9kZSA9IER5bmFtaWMuSU5GSU5JVEU7XG4gICAgICB0aGlzLnRhcmdldCA9IGludmVydCA/IC1JbmZpbml0eSA6IEluZmluaXR5O1xuICAgICAgdGhpcy5zcGVlZE11bHQgPSBzcGVlZE11bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3BzIG1vdmVtZW50XG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLnN0b3AgPSBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgdGhpcy5tb2RlID0gRHluYW1pYy5TVE9QO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHRoZSBjdXJyZW50IHBvc2l0aW9uIGFuZCBpbW1lZGlhdGVseSBzdG9wcyBtb3ZlbWVudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5zZXRWYWx1ZSA9IGZ1bmN0aW9uIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgICB0aGlzLnRhcmdldCA9IHRoaXMubG9vcFZhbHVlID8gbG9vcCh2YWx1ZSwgdGhpcy5tYXgpIDogdGhyZWUuTWF0aFV0aWxzLmNsYW1wKHZhbHVlLCB0aGlzLm1pbiwgdGhpcy5tYXgpO1xuICAgICAgdGhpcy5tb2RlID0gRHluYW1pYy5TVE9QO1xuXG4gICAgICBpZiAodGhpcy50YXJnZXQgIT09IHRoaXMuY3VycmVudCkge1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLnRhcmdldDtcblxuICAgICAgICBpZiAodGhpcy5mbikge1xuICAgICAgICAgIHRoaXMuZm4odGhpcy5jdXJyZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYWNrYWdlXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShlbGFwc2VkKSB7XG4gICAgICAvLyBpbiBwb3NpdGlvbiBtb2RlIHN3aXRjaCB0byBzdG9wIG1vZGUgd2hlbiBpbiB0aGUgZGVjY2VsZXJhdGlvbiB3aW5kb3dcbiAgICAgIGlmICh0aGlzLm1vZGUgPT09IER5bmFtaWMuUE9TSVRJT04pIHtcbiAgICAgICAgLy8gaW4gbG9vcCBtb2RlLCBhbHRlciBcImN1cnJlbnRcIiB0byBhdm9pZCBjcm9zc2luZyB0aGUgb3JpZ2luXG4gICAgICAgIGlmICh0aGlzLmxvb3BWYWx1ZSAmJiBNYXRoLmFicyh0aGlzLnRhcmdldCAtIHRoaXMuY3VycmVudCkgPiB0aGlzLm1heCAvIDIpIHtcbiAgICAgICAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLmN1cnJlbnQgPCB0aGlzLnRhcmdldCA/IHRoaXMuY3VycmVudCArIHRoaXMubWF4IDogdGhpcy5jdXJyZW50IC0gdGhpcy5tYXg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZHN0U3RvcCA9IHRoaXMuY3VycmVudFNwZWVkICogdGhpcy5jdXJyZW50U3BlZWQgLyAodGhpcy5zcGVlZCAqIHRoaXMuc3BlZWRNdWx0ICogNCk7XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMudGFyZ2V0IC0gdGhpcy5jdXJyZW50KSA8PSBkc3RTdG9wKSB7XG4gICAgICAgICAgdGhpcy5tb2RlID0gRHluYW1pYy5TVE9QO1xuICAgICAgICB9XG4gICAgICB9IC8vIGNvbXB1dGUgc3BlZWRcblxuXG4gICAgICB2YXIgdGFyZ2V0U3BlZWQgPSB0aGlzLm1vZGUgPT09IER5bmFtaWMuU1RPUCA/IDAgOiB0aGlzLnNwZWVkICogdGhpcy5zcGVlZE11bHQ7XG5cbiAgICAgIGlmICh0aGlzLnRhcmdldCA8IHRoaXMuY3VycmVudCkge1xuICAgICAgICB0YXJnZXRTcGVlZCA9IC10YXJnZXRTcGVlZDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY3VycmVudFNwZWVkIDwgdGFyZ2V0U3BlZWQpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50U3BlZWQgPSBNYXRoLm1pbih0YXJnZXRTcGVlZCwgdGhpcy5jdXJyZW50U3BlZWQgKyBlbGFwc2VkIC8gMTAwMCAqIHRoaXMuc3BlZWQgKiB0aGlzLnNwZWVkTXVsdCAqIDIpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRTcGVlZCA+IHRhcmdldFNwZWVkKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFNwZWVkID0gTWF0aC5tYXgodGFyZ2V0U3BlZWQsIHRoaXMuY3VycmVudFNwZWVkIC0gZWxhcHNlZCAvIDEwMDAgKiB0aGlzLnNwZWVkICogdGhpcy5zcGVlZE11bHQgKiAyKTtcbiAgICAgIH0gLy8gY29tcHV0ZSBuZXcgcG9zaXRpb25cblxuXG4gICAgICB2YXIgbmV4dCA9IG51bGw7XG5cbiAgICAgIGlmICh0aGlzLmN1cnJlbnQgPiB0aGlzLnRhcmdldCAmJiB0aGlzLmN1cnJlbnRTcGVlZCkge1xuICAgICAgICBuZXh0ID0gTWF0aC5tYXgodGhpcy50YXJnZXQsIHRoaXMuY3VycmVudCArIHRoaXMuY3VycmVudFNwZWVkICogZWxhcHNlZCAvIDEwMDApO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnQgPCB0aGlzLnRhcmdldCAmJiB0aGlzLmN1cnJlbnRTcGVlZCkge1xuICAgICAgICBuZXh0ID0gTWF0aC5taW4odGhpcy50YXJnZXQsIHRoaXMuY3VycmVudCArIHRoaXMuY3VycmVudFNwZWVkICogZWxhcHNlZCAvIDEwMDApO1xuICAgICAgfSAvLyBhcHBseSB2YWx1ZVxuXG5cbiAgICAgIGlmIChuZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIG5leHQgPSB0aGlzLmxvb3BWYWx1ZSA/IGxvb3AobmV4dCwgdGhpcy5tYXgpIDogdGhyZWUuTWF0aFV0aWxzLmNsYW1wKG5leHQsIHRoaXMubWluLCB0aGlzLm1heCk7XG5cbiAgICAgICAgaWYgKG5leHQgIT09IHRoaXMuY3VycmVudCkge1xuICAgICAgICAgIHRoaXMuY3VycmVudCA9IG5leHQ7XG5cbiAgICAgICAgICBpZiAodGhpcy5mbikge1xuICAgICAgICAgICAgdGhpcy5mbih0aGlzLmN1cnJlbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIER5bmFtaWM7XG4gIH0oKTtcbiAgRHluYW1pYy5TVE9QID0gMDtcbiAgRHluYW1pYy5JTkZJTklURSA9IDE7XG4gIER5bmFtaWMuUE9TSVRJT04gPSAyO1xuXG4gIC8qKlxuICAgKiBAc3VtbWFyeSBXcmFwcGVyIGZvciBtdWx0aXBsZSB7QGxpbmsgUFNWLnV0aWxzLkR5bmFtaWN9IGV2b2x2aW5nIHRvZ2V0aGVyXG4gICAqIEBtZW1iZXJPZiBQU1YudXRpbHNcbiAgICovXG5cbiAgdmFyIE11bHRpRHluYW1pYyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBQU1YudXRpbHMuRHluYW1pYz59IGR5bmFtaWNzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXSBDYWxsYmFjayBmdW5jdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE11bHRpRHluYW1pYyhkeW5hbWljcywgZm4pIHtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqIEByZWFkb25seVxuICAgICAgICovXG4gICAgICB0aGlzLmZuID0gZm47XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBQU1YudXRpbHMuRHluYW1pYz59XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgKi9cblxuICAgICAgdGhpcy5keW5hbWljcyA9IGR5bmFtaWNzO1xuXG4gICAgICBpZiAodGhpcy5mbikge1xuICAgICAgICB0aGlzLmZuKHRoaXMuY3VycmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgYmFzZSBzcGVlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzcGVlZFxuICAgICAqL1xuXG5cbiAgICB2YXIgX3Byb3RvID0gTXVsdGlEeW5hbWljLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5zZXRTcGVlZCA9IGZ1bmN0aW9uIHNldFNwZWVkKHNwZWVkKSB7XG4gICAgICBlYWNoKHRoaXMuZHluYW1pY3MsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIGQuc2V0U3BlZWQoc3BlZWQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmluZXMgdGhlIHRhcmdldCBwb3NpdGlvbnNcbiAgICAgKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIG51bWJlcj59IHBvc2l0aW9uc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3BlZWRNdWx0PTFdXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLmdvdG8gPSBmdW5jdGlvbiBnb3RvKHBvc2l0aW9ucywgc3BlZWRNdWx0KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAoc3BlZWRNdWx0ID09PSB2b2lkIDApIHtcbiAgICAgICAgc3BlZWRNdWx0ID0gMTtcbiAgICAgIH1cblxuICAgICAgZWFjaChwb3NpdGlvbnMsIGZ1bmN0aW9uIChwb3NpdGlvbiwgbmFtZSkge1xuICAgICAgICBfdGhpcy5keW5hbWljc1tuYW1lXS5nb3RvKHBvc2l0aW9uLCBzcGVlZE11bHQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluY3JlYXNlL2RlY3JlYXNlIHRoZSB0YXJnZXQgcG9zaXRpb25zXG4gICAgICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBudW1iZXI+fSBzdGVwc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3BlZWRNdWx0PTFdXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLnN0ZXAgPSBmdW5jdGlvbiBzdGVwKHN0ZXBzLCBzcGVlZE11bHQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBpZiAoc3BlZWRNdWx0ID09PSB2b2lkIDApIHtcbiAgICAgICAgc3BlZWRNdWx0ID0gMTtcbiAgICAgIH1cblxuICAgICAgZWFjaChzdGVwcywgZnVuY3Rpb24gKHN0ZXAsIG5hbWUpIHtcbiAgICAgICAgX3RoaXMyLmR5bmFtaWNzW25hbWVdLnN0ZXAoc3RlcCwgc3BlZWRNdWx0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgaW5maW5pdGUgbW92ZW1lbnRzXG4gICAgICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBib29sZWFuPn0gcm9sbHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NwZWVkTXVsdD0xXVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5yb2xsID0gZnVuY3Rpb24gcm9sbChyb2xscywgc3BlZWRNdWx0KSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgaWYgKHNwZWVkTXVsdCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHNwZWVkTXVsdCA9IDE7XG4gICAgICB9XG5cbiAgICAgIGVhY2gocm9sbHMsIGZ1bmN0aW9uIChyb2xsLCBuYW1lKSB7XG4gICAgICAgIF90aGlzMy5keW5hbWljc1tuYW1lXS5yb2xsKHJvbGwsIHNwZWVkTXVsdCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcHMgbW92ZW1lbnRzXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLnN0b3AgPSBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgZWFjaCh0aGlzLmR5bmFtaWNzLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZC5zdG9wKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB0aGUgY3VycmVudCBwb3NpdGlvbnMgYW5kIGltbWVkaWF0ZWx5IHN0b3BzIG1vdmVtZW50c1xuICAgICAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgbnVtYmVyPn0gdmFsdWVzXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLnNldFZhbHVlID0gZnVuY3Rpb24gc2V0VmFsdWUodmFsdWVzKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdmFyIGhhc1VwZGF0ZXMgPSBmYWxzZTtcbiAgICAgIGVhY2godmFsdWVzLCBmdW5jdGlvbiAodmFsdWUsIG5hbWUpIHtcbiAgICAgICAgaGFzVXBkYXRlcyB8PSBfdGhpczQuZHluYW1pY3NbbmFtZV0uc2V0VmFsdWUodmFsdWUpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChoYXNVcGRhdGVzICYmIHRoaXMuZm4pIHtcbiAgICAgICAgdGhpcy5mbih0aGlzLmN1cnJlbnQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFzVXBkYXRlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhY2thZ2VcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8udXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGVsYXBzZWQpIHtcbiAgICAgIHZhciBoYXNVcGRhdGVzID0gZmFsc2U7XG4gICAgICBlYWNoKHRoaXMuZHluYW1pY3MsIGZ1bmN0aW9uIChkeW5hbWljKSB7XG4gICAgICAgIGhhc1VwZGF0ZXMgfD0gZHluYW1pYy51cGRhdGUoZWxhcHNlZCk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGhhc1VwZGF0ZXMgJiYgdGhpcy5mbikge1xuICAgICAgICB0aGlzLmZuKHRoaXMuY3VycmVudCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNVcGRhdGVzO1xuICAgIH07XG5cbiAgICBfY3JlYXRlQ2xhc3MoTXVsdGlEeW5hbWljLCBbe1xuICAgICAga2V5OiBcImN1cnJlbnRcIixcbiAgICAgIGdldDpcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsIG51bWJlcj59XG4gICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgdmFsdWVzID0ge307XG4gICAgICAgIGVhY2godGhpcy5keW5hbWljcywgZnVuY3Rpb24gKGR5bmFtaWMsIG5hbWUpIHtcbiAgICAgICAgICB2YWx1ZXNbbmFtZV0gPSBkeW5hbWljLmN1cnJlbnQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBNdWx0aUR5bmFtaWM7XG4gIH0oKTtcblxuICAvKipcbiAgICogQHN1bW1hcnkgSGVscGVyIHRvIG1ha2Ugc2xpZGVycyBlbGVtZW50c1xuICAgKiBAbWVtYmVyT2YgUFNWLnV0aWxzXG4gICAqL1xuXG4gIHZhciBTbGlkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FdmVudEVtaXR0ZXIpIHtcbiAgICBfaW5oZXJpdHNMb29zZShTbGlkZXIsIF9FdmVudEVtaXR0ZXIpO1xuXG4gICAgZnVuY3Rpb24gU2xpZGVyKF9yZWYpIHtcbiAgICAgIHZhciBfdGhpcztcblxuICAgICAgdmFyIHBzdiA9IF9yZWYucHN2LFxuICAgICAgICAgIGNvbnRhaW5lciA9IF9yZWYuY29udGFpbmVyLFxuICAgICAgICAgIGRpcmVjdGlvbiA9IF9yZWYuZGlyZWN0aW9uLFxuICAgICAgICAgIG9uVXBkYXRlID0gX3JlZi5vblVwZGF0ZTtcbiAgICAgIF90aGlzID0gX0V2ZW50RW1pdHRlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAvKipcbiAgICAgICAqIEBzdW1tYXJ5IFJlZmVyZW5jZSB0byBtYWluIGNvbnRyb2xsZXJcbiAgICAgICAqIEB0eXBlIHtQU1YuVmlld2VyfVxuICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgKi9cblxuICAgICAgX3RoaXMucHN2ID0gcHN2O1xuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtIVE1MRWxlbWVudH1cbiAgICAgICAqIEByZWFkb25seVxuICAgICAgICovXG5cbiAgICAgIF90aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgIC8qKlxuICAgICAgICogQHN1bW1hcnkgSW50ZXJuYWwgcHJvcGVydGllc1xuICAgICAgICogQG1lbWJlciB7T2JqZWN0fVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICogQHByb3BlcnR5IHtib29sZWFufSBtb3VzZWRvd25cbiAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtZWRpYU1pbldpZHRoXG4gICAgICAgKi9cblxuICAgICAgX3RoaXMucHJvcCA9IHtcbiAgICAgICAgb25VcGRhdGU6IG9uVXBkYXRlLFxuICAgICAgICBkaXJlY3Rpb246IGRpcmVjdGlvbixcbiAgICAgICAgbW91c2Vkb3duOiBmYWxzZSxcbiAgICAgICAgbW91c2VvdmVyOiBmYWxzZVxuICAgICAgfTtcblxuICAgICAgX3RoaXMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgICBfdGhpcy5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgICBfdGhpcy5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgICAgX3RoaXMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICAgIF90aGlzLmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgICBfdGhpcy5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIHRydWUpO1xuXG4gICAgICBfdGhpcy5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIHRydWUpO1xuXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuXG5cbiAgICB2YXIgX3Byb3RvID0gU2xpZGVyLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcyk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgSGFuZGxlcyBldmVudHNcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiBoYW5kbGVFdmVudChlKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICAgICAgc3dpdGNoIChlLnR5cGUpIHtcbiAgICAgICAgLy8gQGZvcm1hdHRlcjpvZmZcbiAgICAgICAgY2FzZSAnY2xpY2snOlxuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICAgICAgICB0aGlzLl9fb25Nb3VzZURvd24oZSk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdtb3VzZWVudGVyJzpcbiAgICAgICAgICB0aGlzLl9fb25Nb3VzZUVudGVyKGUpO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbW91c2VsZWF2ZSc6XG4gICAgICAgICAgdGhpcy5fX29uTW91c2VMZWF2ZShlKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3RvdWNoc3RhcnQnOlxuICAgICAgICAgIHRoaXMuX19vblRvdWNoU3RhcnQoZSk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdtb3VzZW1vdmUnOlxuICAgICAgICAgIHRoaXMuX19vbk1vdXNlTW92ZShlKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3RvdWNobW92ZSc6XG4gICAgICAgICAgdGhpcy5fX29uVG91Y2hNb3ZlKGUpO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbW91c2V1cCc6XG4gICAgICAgICAgdGhpcy5fX29uTW91c2VVcChlKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3RvdWNoZW5kJzpcbiAgICAgICAgICB0aGlzLl9fb25Ub3VjaEVuZChlKTtcblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBAZm9ybWF0dGVyOm9uXG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlICovXG5cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uX19vbk1vdXNlRG93biA9IGZ1bmN0aW9uIF9fb25Nb3VzZURvd24oZXZ0KSB7XG4gICAgICB0aGlzLnByb3AubW91c2Vkb3duID0gdHJ1ZTtcblxuICAgICAgdGhpcy5fX3VwZGF0ZShldnQsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5fX29uTW91c2VFbnRlciA9IGZ1bmN0aW9uIF9fb25Nb3VzZUVudGVyKGV2dCkge1xuICAgICAgdGhpcy5wcm9wLm1vdXNlb3ZlciA9IHRydWU7XG5cbiAgICAgIHRoaXMuX191cGRhdGUoZXZ0LCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uX19vblRvdWNoU3RhcnQgPSBmdW5jdGlvbiBfX29uVG91Y2hTdGFydChldnQpIHtcbiAgICAgIHRoaXMucHJvcC5tb3VzZW92ZXIgPSB0cnVlO1xuICAgICAgdGhpcy5wcm9wLm1vdXNlZG93biA9IHRydWU7XG5cbiAgICAgIHRoaXMuX191cGRhdGUoZXZ0LmNoYW5nZWRUb3VjaGVzWzBdLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uX19vbk1vdXNlTW92ZSA9IGZ1bmN0aW9uIF9fb25Nb3VzZU1vdmUoZXZ0KSB7XG4gICAgICBpZiAodGhpcy5wcm9wLm1vdXNlZG93biB8fCB0aGlzLnByb3AubW91c2VvdmVyKSB7XG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICB0aGlzLl9fdXBkYXRlKGV2dCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLl9fb25Ub3VjaE1vdmUgPSBmdW5jdGlvbiBfX29uVG91Y2hNb3ZlKGV2dCkge1xuICAgICAgaWYgKHRoaXMucHJvcC5tb3VzZWRvd24gfHwgdGhpcy5wcm9wLm1vdXNlb3Zlcikge1xuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgdGhpcy5fX3VwZGF0ZShldnQuY2hhbmdlZFRvdWNoZXNbMF0sIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5fX29uTW91c2VVcCA9IGZ1bmN0aW9uIF9fb25Nb3VzZVVwKGV2dCkge1xuICAgICAgaWYgKHRoaXMucHJvcC5tb3VzZWRvd24pIHtcbiAgICAgICAgdGhpcy5wcm9wLm1vdXNlZG93biA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX191cGRhdGUoZXZ0LCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLl9fb25Nb3VzZUxlYXZlID0gZnVuY3Rpb24gX19vbk1vdXNlTGVhdmUoZXZ0KSB7XG4gICAgICBpZiAodGhpcy5wcm9wLm1vdXNlb3Zlcikge1xuICAgICAgICB0aGlzLnByb3AubW91c2VvdmVyID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fX3VwZGF0ZShldnQsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5fX29uVG91Y2hFbmQgPSBmdW5jdGlvbiBfX29uVG91Y2hFbmQoZXZ0KSB7XG4gICAgICBpZiAodGhpcy5wcm9wLm1vdXNlZG93bikge1xuICAgICAgICB0aGlzLnByb3AubW91c2VvdmVyID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHJvcC5tb3VzZWRvd24gPSBmYWxzZTtcblxuICAgICAgICB0aGlzLl9fdXBkYXRlKGV2dC5jaGFuZ2VkVG91Y2hlc1swXSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5fX3VwZGF0ZSA9IGZ1bmN0aW9uIF9fdXBkYXRlKGV2dCwgbW92aW5nKSB7XG4gICAgICB2YXIgYm91bmRpbmdDbGllbnRSZWN0ID0gdGhpcy5jb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgY3Vyc29yID0gZXZ0W3RoaXMudmVydGljYWwgPyAnY2xpZW50WScgOiAnY2xpZW50WCddO1xuICAgICAgdmFyIHBvcyA9IGJvdW5kaW5nQ2xpZW50UmVjdFt0aGlzLnZlcnRpY2FsID8gJ2JvdHRvbScgOiAnbGVmdCddO1xuICAgICAgdmFyIHNpemUgPSBib3VuZGluZ0NsaWVudFJlY3RbdGhpcy52ZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJ107XG4gICAgICB2YXIgdmFsID0gTWF0aC5hYnMoKHBvcyAtIGN1cnNvcikgLyBzaXplKTtcbiAgICAgIHRoaXMucHJvcC5vblVwZGF0ZSh7XG4gICAgICAgIHZhbHVlOiB2YWwsXG4gICAgICAgIGNsaWNrOiAhbW92aW5nLFxuICAgICAgICBtb3VzZWRvd246IHRoaXMucHJvcC5tb3VzZWRvd24sXG4gICAgICAgIG1vdXNlb3ZlcjogdGhpcy5wcm9wLm1vdXNlb3ZlcixcbiAgICAgICAgY3Vyc29yOiBldnRcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfY3JlYXRlQ2xhc3MoU2xpZGVyLCBbe1xuICAgICAga2V5OiBcInZlcnRpY2FsXCIsXG4gICAgICBnZXQ6XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcC5kaXJlY3Rpb24gPT09IFNsaWRlci5WRVJUSUNBTDtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gU2xpZGVyO1xuICB9KHVldmVudC5FdmVudEVtaXR0ZXIpO1xuICBTbGlkZXIuVkVSVElDQUwgPSAxO1xuICBTbGlkZXIuSE9SSVpPTlRBTCA9IDI7XG5cbiAgLyoqXG4gICAqIEBuYW1lc3BhY2UgUFNWLnV0aWxzXG4gICAqL1xuXG4gIHZhciBpbmRleCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgdG9nZ2xlQ2xhc3M6IHRvZ2dsZUNsYXNzLFxuICAgIGFkZENsYXNzZXM6IGFkZENsYXNzZXMsXG4gICAgcmVtb3ZlQ2xhc3NlczogcmVtb3ZlQ2xhc3NlcyxcbiAgICBoYXNQYXJlbnQ6IGhhc1BhcmVudCxcbiAgICBnZXRDbG9zZXN0OiBnZXRDbG9zZXN0LFxuICAgIGdldFBvc2l0aW9uOiBnZXRQb3NpdGlvbixcbiAgICBpc0Z1bGxzY3JlZW5FbmFibGVkOiBpc0Z1bGxzY3JlZW5FbmFibGVkLFxuICAgIHJlcXVlc3RGdWxsc2NyZWVuOiByZXF1ZXN0RnVsbHNjcmVlbixcbiAgICBleGl0RnVsbHNjcmVlbjogZXhpdEZ1bGxzY3JlZW4sXG4gICAgZ2V0U3R5bGU6IGdldFN0eWxlLFxuICAgIG5vcm1hbGl6ZVdoZWVsOiBub3JtYWxpemVXaGVlbCxcbiAgICBib3VuZDogYm91bmQsXG4gICAgbG9vcDogbG9vcCxcbiAgICBpc1Bvd2VyT2ZUd286IGlzUG93ZXJPZlR3byxcbiAgICBzdW06IHN1bSxcbiAgICBkaXN0YW5jZTogZGlzdGFuY2UsXG4gICAgZ2V0U2hvcnRlc3RBcmM6IGdldFNob3J0ZXN0QXJjLFxuICAgIGdldEFuZ2xlOiBnZXRBbmdsZSxcbiAgICBncmVhdEFyY0Rpc3RhbmNlOiBncmVhdEFyY0Rpc3RhbmNlLFxuICAgIGRhc2hlcml6ZTogZGFzaGVyaXplLFxuICAgIHRocm90dGxlOiB0aHJvdHRsZSxcbiAgICBpc1BsYWluT2JqZWN0OiBpc1BsYWluT2JqZWN0LFxuICAgIGRlZXBtZXJnZTogZGVlcG1lcmdlLFxuICAgIGNsb25lOiBjbG9uZSxcbiAgICBpc0VtcHR5OiBpc0VtcHR5LFxuICAgIGVhY2g6IGVhY2gsXG4gICAgaXNOaWw6IGlzTmlsLFxuICAgIGZpcnN0Tm9uTnVsbDogZmlyc3ROb25OdWxsLFxuICAgIGRlZXBFcXVhbDogZGVlcEVxdWFsLFxuICAgIHBsdWdpbkludGVyb3A6IHBsdWdpbkludGVyb3AsXG4gICAgZ2V0QWJvcnRFcnJvcjogZ2V0QWJvcnRFcnJvcixcbiAgICBpc0Fib3J0RXJyb3I6IGlzQWJvcnRFcnJvcixcbiAgICBsb2dXYXJuOiBsb2dXYXJuLFxuICAgIGlzRXh0ZW5kZWRQb3NpdGlvbjogaXNFeHRlbmRlZFBvc2l0aW9uLFxuICAgIGdldFhNUFZhbHVlOiBnZXRYTVBWYWx1ZSxcbiAgICBwYXJzZVBvc2l0aW9uOiBwYXJzZVBvc2l0aW9uLFxuICAgIGNsZWFuUG9zaXRpb246IGNsZWFuUG9zaXRpb24sXG4gICAgcG9zaXRpb25Jc09yZGVyZWQ6IHBvc2l0aW9uSXNPcmRlcmVkLFxuICAgIHBhcnNlU3BlZWQ6IHBhcnNlU3BlZWQsXG4gICAgcGFyc2VBbmdsZTogcGFyc2VBbmdsZSxcbiAgICBjcmVhdGVUZXh0dXJlOiBjcmVhdGVUZXh0dXJlLFxuICAgIGFwcGx5RXVsZXJJbnZlcnNlOiBhcHBseUV1bGVySW52ZXJzZSxcbiAgICBBbmltYXRpb246IEFuaW1hdGlvbixcbiAgICBEeW5hbWljOiBEeW5hbWljLFxuICAgIE11bHRpRHluYW1pYzogTXVsdGlEeW5hbWljLFxuICAgIFNsaWRlcjogU2xpZGVyXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQU1YuYWRhcHRlcnMuRXF1aXJlY3Rhbmd1bGFyQWRhcHRlci5PcHRpb25zXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmVzb2x1dGlvbj02NF0gLSBudW1iZXIgb2YgZmFjZXMgb2YgdGhlIHNwaGVyZSBnZW9tZXRyeSwgaGlnaGVyIHZhbHVlcyBtYXkgZGVjcmVhc2UgcGVyZm9ybWFuY2VzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAc3VtbWFyeSBBZGFwdGVyIGZvciBlcXVpcmVjdGFuZ3VsYXIgcGFub3JhbWFzXG4gICAqIEBtZW1iZXJvZiBQU1YuYWRhcHRlcnNcbiAgICogQGV4dGVuZHMgUFNWLmFkYXB0ZXJzLkFic3RyYWN0QWRhcHRlclxuICAgKi9cblxuICB2YXIgRXF1aXJlY3Rhbmd1bGFyQWRhcHRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Fic3RyYWN0QWRhcHRlcikge1xuICAgIF9pbmhlcml0c0xvb3NlKEVxdWlyZWN0YW5ndWxhckFkYXB0ZXIsIF9BYnN0cmFjdEFkYXB0ZXIpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQU1YuVmlld2VyfSBwc3ZcbiAgICAgKiBAcGFyYW0ge1BTVi5hZGFwdGVycy5FcXVpcmVjdGFuZ3VsYXJBZGFwdGVyLk9wdGlvbnN9IG9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFcXVpcmVjdGFuZ3VsYXJBZGFwdGVyKHBzdiwgb3B0aW9ucykge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBfdGhpcyA9IF9BYnN0cmFjdEFkYXB0ZXIuY2FsbCh0aGlzLCBwc3YpIHx8IHRoaXM7XG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge1BTVi5hZGFwdGVycy5FcXVpcmVjdGFuZ3VsYXJBZGFwdGVyLk9wdGlvbnN9XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICAgIF90aGlzLmNvbmZpZyA9IF9leHRlbmRzKHtcbiAgICAgICAgcmVzb2x1dGlvbjogNjRcbiAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICBpZiAoIXRocmVlLk1hdGhVdGlscy5pc1Bvd2VyT2ZUd28oX3RoaXMuY29uZmlnLnJlc29sdXRpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBQU1ZFcnJvcignRXF1aXJlY3Rhbmd1bGFyQWRhcHRlciByZXNvbHV0aW9uIG11c3QgYmUgcG93ZXIgb2YgdHdvJyk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLlNQSEVSRV9TRUdNRU5UUyA9IF90aGlzLmNvbmZpZy5yZXNvbHV0aW9uO1xuICAgICAgX3RoaXMuU1BIRVJFX0hPUklaT05UQUxfU0VHTUVOVFMgPSBfdGhpcy5TUEhFUkVfU0VHTUVOVFMgLyAyO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cblxuXG4gICAgdmFyIF9wcm90byA9IEVxdWlyZWN0YW5ndWxhckFkYXB0ZXIucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLnN1cHBvcnRzVHJhbnNpdGlvbiA9IGZ1bmN0aW9uIHN1cHBvcnRzVHJhbnNpdGlvbigpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uc3VwcG9ydHNQcmVsb2FkID0gZnVuY3Rpb24gc3VwcG9ydHNQcmVsb2FkKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYW5vcmFtYVxuICAgICAqIEBwYXJhbSB7UFNWLlBhbm9EYXRhIHwgUFNWLlBhbm9EYXRhUHJvdmlkZXJ9IFtuZXdQYW5vRGF0YV1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VYbXBQYW5vRGF0YV1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZS48UFNWLlRleHR1cmVEYXRhPn1cbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8ubG9hZFRleHR1cmUgPSBmdW5jdGlvbiBsb2FkVGV4dHVyZShwYW5vcmFtYSwgbmV3UGFub0RhdGEsIHVzZVhtcFBhbm9EYXRhKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKHVzZVhtcFBhbm9EYXRhID09PSB2b2lkIDApIHtcbiAgICAgICAgdXNlWG1wUGFub0RhdGEgPSB0aGlzLnBzdi5jb25maWcudXNlWG1wRGF0YTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBwYW5vcmFtYSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFub3JhbWEpIHx8IHR5cGVvZiBwYW5vcmFtYSA9PT0gJ29iamVjdCcgJiYgISFwYW5vcmFtYS5sZWZ0KSB7XG4gICAgICAgICAgbG9nV2FybignQ3ViZW1hcCBzdXBwb3J0IG5vdyByZXF1aXJlcyBhbiBhZGRpdGlvbmFsIGFkYXB0ZXIsIHNlZSBodHRwczovL3Bob3RvLXNwaGVyZS12aWV3ZXIuanMub3JnL2d1aWRlL2FkYXB0ZXJzJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFBTVkVycm9yKCdJbnZhbGlkIHBhbm9yYW1hIHVybCwgYXJlIHlvdSB1c2luZyB0aGUgcmlnaHQgYWRhcHRlcj8nKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAodXNlWG1wUGFub0RhdGEgPyB0aGlzLl9fbG9hZFhNUChwYW5vcmFtYSwgZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi5wc3YubG9hZGVyLnNldFByb2dyZXNzKHApO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAoeG1wUGFub0RhdGEpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi5wc3YudGV4dHVyZUxvYWRlci5sb2FkSW1hZ2UocGFub3JhbWEpLnRoZW4oZnVuY3Rpb24gKGltZykge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbWc6IGltZyxcbiAgICAgICAgICAgIHhtcFBhbm9EYXRhOiB4bXBQYW5vRGF0YVxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgfSkgOiB0aGlzLnBzdi50ZXh0dXJlTG9hZGVyLmxvYWRJbWFnZShwYW5vcmFtYSwgZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi5wc3YubG9hZGVyLnNldFByb2dyZXNzKHApO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAoaW1nKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaW1nOiBpbWcsXG4gICAgICAgICAgeG1wUGFub0RhdGE6IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH0pKS50aGVuKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciBfbmV3UGFub0RhdGEsIF9uZXdQYW5vRGF0YTIsIF9uZXdQYW5vRGF0YTMsIF9uZXdQYW5vRGF0YTQsIF9uZXdQYW5vRGF0YTUsIF9uZXdQYW5vRGF0YTYsIF9uZXdQYW5vRGF0YTcsIF9uZXdQYW5vRGF0YTgsIF9uZXdQYW5vRGF0YTk7XG5cbiAgICAgICAgdmFyIGltZyA9IF9yZWYuaW1nLFxuICAgICAgICAgICAgeG1wUGFub0RhdGEgPSBfcmVmLnhtcFBhbm9EYXRhO1xuXG4gICAgICAgIGlmICh0eXBlb2YgbmV3UGFub0RhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBuZXdQYW5vRGF0YSA9IG5ld1Bhbm9EYXRhKGltZyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFub0RhdGEgPSB7XG4gICAgICAgICAgZnVsbFdpZHRoOiBmaXJzdE5vbk51bGwoKF9uZXdQYW5vRGF0YSA9IG5ld1Bhbm9EYXRhKSA9PSBudWxsID8gdm9pZCAwIDogX25ld1Bhbm9EYXRhLmZ1bGxXaWR0aCwgeG1wUGFub0RhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IHhtcFBhbm9EYXRhLmZ1bGxXaWR0aCwgaW1nLndpZHRoKSxcbiAgICAgICAgICBmdWxsSGVpZ2h0OiBmaXJzdE5vbk51bGwoKF9uZXdQYW5vRGF0YTIgPSBuZXdQYW5vRGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9uZXdQYW5vRGF0YTIuZnVsbEhlaWdodCwgeG1wUGFub0RhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IHhtcFBhbm9EYXRhLmZ1bGxIZWlnaHQsIGltZy5oZWlnaHQpLFxuICAgICAgICAgIGNyb3BwZWRXaWR0aDogZmlyc3ROb25OdWxsKChfbmV3UGFub0RhdGEzID0gbmV3UGFub0RhdGEpID09IG51bGwgPyB2b2lkIDAgOiBfbmV3UGFub0RhdGEzLmNyb3BwZWRXaWR0aCwgeG1wUGFub0RhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IHhtcFBhbm9EYXRhLmNyb3BwZWRXaWR0aCwgaW1nLndpZHRoKSxcbiAgICAgICAgICBjcm9wcGVkSGVpZ2h0OiBmaXJzdE5vbk51bGwoKF9uZXdQYW5vRGF0YTQgPSBuZXdQYW5vRGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9uZXdQYW5vRGF0YTQuY3JvcHBlZEhlaWdodCwgeG1wUGFub0RhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IHhtcFBhbm9EYXRhLmNyb3BwZWRIZWlnaHQsIGltZy5oZWlnaHQpLFxuICAgICAgICAgIGNyb3BwZWRYOiBmaXJzdE5vbk51bGwoKF9uZXdQYW5vRGF0YTUgPSBuZXdQYW5vRGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9uZXdQYW5vRGF0YTUuY3JvcHBlZFgsIHhtcFBhbm9EYXRhID09IG51bGwgPyB2b2lkIDAgOiB4bXBQYW5vRGF0YS5jcm9wcGVkWCwgMCksXG4gICAgICAgICAgY3JvcHBlZFk6IGZpcnN0Tm9uTnVsbCgoX25ld1Bhbm9EYXRhNiA9IG5ld1Bhbm9EYXRhKSA9PSBudWxsID8gdm9pZCAwIDogX25ld1Bhbm9EYXRhNi5jcm9wcGVkWSwgeG1wUGFub0RhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IHhtcFBhbm9EYXRhLmNyb3BwZWRZLCAwKSxcbiAgICAgICAgICBwb3NlSGVhZGluZzogZmlyc3ROb25OdWxsKChfbmV3UGFub0RhdGE3ID0gbmV3UGFub0RhdGEpID09IG51bGwgPyB2b2lkIDAgOiBfbmV3UGFub0RhdGE3LnBvc2VIZWFkaW5nLCB4bXBQYW5vRGF0YSA9PSBudWxsID8gdm9pZCAwIDogeG1wUGFub0RhdGEucG9zZUhlYWRpbmcsIDApLFxuICAgICAgICAgIHBvc2VQaXRjaDogZmlyc3ROb25OdWxsKChfbmV3UGFub0RhdGE4ID0gbmV3UGFub0RhdGEpID09IG51bGwgPyB2b2lkIDAgOiBfbmV3UGFub0RhdGE4LnBvc2VQaXRjaCwgeG1wUGFub0RhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IHhtcFBhbm9EYXRhLnBvc2VQaXRjaCwgMCksXG4gICAgICAgICAgcG9zZVJvbGw6IGZpcnN0Tm9uTnVsbCgoX25ld1Bhbm9EYXRhOSA9IG5ld1Bhbm9EYXRhKSA9PSBudWxsID8gdm9pZCAwIDogX25ld1Bhbm9EYXRhOS5wb3NlUm9sbCwgeG1wUGFub0RhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IHhtcFBhbm9EYXRhLnBvc2VSb2xsLCAwKVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChwYW5vRGF0YS5jcm9wcGVkV2lkdGggIT09IGltZy53aWR0aCB8fCBwYW5vRGF0YS5jcm9wcGVkSGVpZ2h0ICE9PSBpbWcuaGVpZ2h0KSB7XG4gICAgICAgICAgbG9nV2FybihcIkludmFsaWQgcGFub0RhdGEsIGNyb3BwZWRXaWR0aCBhbmQvb3IgY3JvcHBlZEhlaWdodCBpcyBub3QgY29oZXJlbnQgd2l0aCBsb2FkZWQgaW1hZ2UuXFxuICAgIHBhbm9EYXRhOiBcIiArIHBhbm9EYXRhLmNyb3BwZWRXaWR0aCArIFwieFwiICsgcGFub0RhdGEuY3JvcHBlZEhlaWdodCArIFwiLCBpbWFnZTogXCIgKyBpbWcud2lkdGggKyBcInhcIiArIGltZy5oZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChuZXdQYW5vRGF0YSB8fCB4bXBQYW5vRGF0YSkgJiYgcGFub0RhdGEuZnVsbFdpZHRoICE9PSBwYW5vRGF0YS5mdWxsSGVpZ2h0ICogMikge1xuICAgICAgICAgIGxvZ1dhcm4oJ0ludmFsaWQgcGFub0RhdGEsIGZ1bGxXaWR0aCBzaG91bGQgYmUgdHdpY2UgZnVsbEhlaWdodCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRleHR1cmUgPSBfdGhpczIuX19jcmVhdGVFcXVpcmVjdGFuZ3VsYXJUZXh0dXJlKGltZywgcGFub0RhdGEpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGFub3JhbWE6IHBhbm9yYW1hLFxuICAgICAgICAgIHRleHR1cmU6IHRleHR1cmUsXG4gICAgICAgICAgcGFub0RhdGE6IHBhbm9EYXRhXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgTG9hZHMgdGhlIFhNUCBkYXRhIG9mIGFuIGltYWdlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhbm9yYW1hXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihudW1iZXIpfSBbb25Qcm9ncmVzc11cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxQU1YuUGFub0RhdGE+fVxuICAgICAqIEB0aHJvd3Mge1BTVi5QU1ZFcnJvcn0gd2hlbiB0aGUgaW1hZ2UgY2Fubm90IGJlIGxvYWRlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLl9fbG9hZFhNUCA9IGZ1bmN0aW9uIF9fbG9hZFhNUChwYW5vcmFtYSwgb25Qcm9ncmVzcykge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHJldHVybiB0aGlzLnBzdi50ZXh0dXJlTG9hZGVyLmxvYWRGaWxlKHBhbm9yYW1hLCBvblByb2dyZXNzKS50aGVuKGZ1bmN0aW9uIChibG9iKSB7XG4gICAgICAgIHJldHVybiBfdGhpczMuX19sb2FkQmxvYkFzU3RyaW5nKGJsb2IpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAoYmluYXJ5KSB7XG4gICAgICAgIHZhciBhID0gYmluYXJ5LmluZGV4T2YoJzx4OnhtcG1ldGEnKTtcbiAgICAgICAgdmFyIGIgPSBiaW5hcnkuaW5kZXhPZignPC94OnhtcG1ldGE+Jyk7XG4gICAgICAgIHZhciBkYXRhID0gYmluYXJ5LnN1YnN0cmluZyhhLCBiKTtcblxuICAgICAgICBpZiAoYSAhPT0gLTEgJiYgYiAhPT0gLTEgJiYgZGF0YS5pbmNsdWRlcygnR1Bhbm86JykpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZnVsbFdpZHRoOiBnZXRYTVBWYWx1ZShkYXRhLCAnRnVsbFBhbm9XaWR0aFBpeGVscycpLFxuICAgICAgICAgICAgZnVsbEhlaWdodDogZ2V0WE1QVmFsdWUoZGF0YSwgJ0Z1bGxQYW5vSGVpZ2h0UGl4ZWxzJyksXG4gICAgICAgICAgICBjcm9wcGVkV2lkdGg6IGdldFhNUFZhbHVlKGRhdGEsICdDcm9wcGVkQXJlYUltYWdlV2lkdGhQaXhlbHMnKSxcbiAgICAgICAgICAgIGNyb3BwZWRIZWlnaHQ6IGdldFhNUFZhbHVlKGRhdGEsICdDcm9wcGVkQXJlYUltYWdlSGVpZ2h0UGl4ZWxzJyksXG4gICAgICAgICAgICBjcm9wcGVkWDogZ2V0WE1QVmFsdWUoZGF0YSwgJ0Nyb3BwZWRBcmVhTGVmdFBpeGVscycpLFxuICAgICAgICAgICAgY3JvcHBlZFk6IGdldFhNUFZhbHVlKGRhdGEsICdDcm9wcGVkQXJlYVRvcFBpeGVscycpLFxuICAgICAgICAgICAgcG9zZUhlYWRpbmc6IGdldFhNUFZhbHVlKGRhdGEsICdQb3NlSGVhZGluZ0RlZ3JlZXMnKSxcbiAgICAgICAgICAgIHBvc2VQaXRjaDogZ2V0WE1QVmFsdWUoZGF0YSwgJ1Bvc2VQaXRjaERlZ3JlZXMnKSxcbiAgICAgICAgICAgIHBvc2VSb2xsOiBnZXRYTVBWYWx1ZShkYXRhLCAnUG9zZVJvbGxEZWdyZWVzJylcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1tYXJ5IHJlYWQgYSBCbG9iIGFzIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7QmxvYn0gYmxvYlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uX19sb2FkQmxvYkFzU3RyaW5nID0gZnVuY3Rpb24gX19sb2FkQmxvYkFzU3RyaW5nKGJsb2IpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXG4gICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUocmVhZGVyLnJlc3VsdCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGJsb2IpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IENyZWF0ZXMgdGhlIGZpbmFsIHRleHR1cmUgZnJvbSBpbWFnZSBhbmQgcGFub3JhbWEgZGF0YVxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IGltZ1xuICAgICAqIEBwYXJhbSB7UFNWLlBhbm9EYXRhfSBwYW5vRGF0YVxuICAgICAqIEByZXR1cm5zIHtleHRlcm5hbDpUSFJFRS5UZXh0dXJlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLl9fY3JlYXRlRXF1aXJlY3Rhbmd1bGFyVGV4dHVyZSA9IGZ1bmN0aW9uIF9fY3JlYXRlRXF1aXJlY3Rhbmd1bGFyVGV4dHVyZShpbWcsIHBhbm9EYXRhKSB7XG4gICAgICAvLyByZXNpemUgaW1hZ2UgLyBmaWxsIGNyb3BwZWQgcGFydHMgd2l0aCBibGFja1xuICAgICAgaWYgKHBhbm9EYXRhLmZ1bGxXaWR0aCA+IFNZU1RFTS5tYXhUZXh0dXJlV2lkdGggfHwgcGFub0RhdGEuY3JvcHBlZFdpZHRoICE9PSBwYW5vRGF0YS5mdWxsV2lkdGggfHwgcGFub0RhdGEuY3JvcHBlZEhlaWdodCAhPT0gcGFub0RhdGEuZnVsbEhlaWdodCkge1xuICAgICAgICB2YXIgcmF0aW8gPSBTWVNURU0uZ2V0TWF4Q2FudmFzV2lkdGgoKSAvIHBhbm9EYXRhLmZ1bGxXaWR0aDtcblxuICAgICAgICB2YXIgcmVzaXplZFBhbm9EYXRhID0gX2V4dGVuZHMoe30sIHBhbm9EYXRhKTtcblxuICAgICAgICBpZiAocmF0aW8gPCAxKSB7XG4gICAgICAgICAgcmVzaXplZFBhbm9EYXRhLmZ1bGxXaWR0aCAqPSByYXRpbztcbiAgICAgICAgICByZXNpemVkUGFub0RhdGEuZnVsbEhlaWdodCAqPSByYXRpbztcbiAgICAgICAgICByZXNpemVkUGFub0RhdGEuY3JvcHBlZFdpZHRoICo9IHJhdGlvO1xuICAgICAgICAgIHJlc2l6ZWRQYW5vRGF0YS5jcm9wcGVkSGVpZ2h0ICo9IHJhdGlvO1xuICAgICAgICAgIHJlc2l6ZWRQYW5vRGF0YS5jcm9wcGVkWCAqPSByYXRpbztcbiAgICAgICAgICByZXNpemVkUGFub0RhdGEuY3JvcHBlZFkgKj0gcmF0aW87XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIGJ1ZmZlci53aWR0aCA9IHJlc2l6ZWRQYW5vRGF0YS5mdWxsV2lkdGg7XG4gICAgICAgIGJ1ZmZlci5oZWlnaHQgPSByZXNpemVkUGFub0RhdGEuZnVsbEhlaWdodDtcbiAgICAgICAgdmFyIGN0eCA9IGJ1ZmZlci5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgcmVzaXplZFBhbm9EYXRhLmNyb3BwZWRYLCByZXNpemVkUGFub0RhdGEuY3JvcHBlZFksIHJlc2l6ZWRQYW5vRGF0YS5jcm9wcGVkV2lkdGgsIHJlc2l6ZWRQYW5vRGF0YS5jcm9wcGVkSGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRleHR1cmUoYnVmZmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNyZWF0ZVRleHR1cmUoaW1nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLmNyZWF0ZU1lc2ggPSBmdW5jdGlvbiBjcmVhdGVNZXNoKHNjYWxlKSB7XG4gICAgICBpZiAoc2NhbGUgPT09IHZvaWQgMCkge1xuICAgICAgICBzY2FsZSA9IDE7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBtaWRkbGUgb2YgdGhlIHBhbm9yYW1hIGlzIHBsYWNlZCBhdCBsb25naXR1ZGU9MFxuICAgICAgdmFyIGdlb21ldHJ5ID0gbmV3IHRocmVlLlNwaGVyZUdlb21ldHJ5KFNQSEVSRV9SQURJVVMgKiBzY2FsZSwgdGhpcy5TUEhFUkVfU0VHTUVOVFMsIHRoaXMuU1BIRVJFX0hPUklaT05UQUxfU0VHTUVOVFMsIC1NYXRoLlBJIC8gMikuc2NhbGUoLTEsIDEsIDEpO1xuICAgICAgdmFyIG1hdGVyaWFsID0gQWJzdHJhY3RBZGFwdGVyLmNyZWF0ZU92ZXJsYXlNYXRlcmlhbCgpO1xuICAgICAgcmV0dXJuIG5ldyB0aHJlZS5NZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5zZXRUZXh0dXJlID0gZnVuY3Rpb24gc2V0VGV4dHVyZShtZXNoLCB0ZXh0dXJlRGF0YSkge1xuICAgICAgdGhpcy5fX3NldFVuaWZvcm0obWVzaCwgQWJzdHJhY3RBZGFwdGVyLk9WRVJMQVlfVU5JRk9STVMucGFub3JhbWEsIHRleHR1cmVEYXRhLnRleHR1cmUpO1xuXG4gICAgICB0aGlzLnNldE92ZXJsYXkobWVzaCwgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5zZXRPdmVybGF5ID0gZnVuY3Rpb24gc2V0T3ZlcmxheShtZXNoLCB0ZXh0dXJlRGF0YSwgb3BhY2l0eSkge1xuICAgICAgdGhpcy5fX3NldFVuaWZvcm0obWVzaCwgQWJzdHJhY3RBZGFwdGVyLk9WRVJMQVlfVU5JRk9STVMub3ZlcmxheU9wYWNpdHksIG9wYWNpdHkpO1xuXG4gICAgICBpZiAoIXRleHR1cmVEYXRhKSB7XG4gICAgICAgIHRoaXMuX19zZXRVbmlmb3JtKG1lc2gsIEFic3RyYWN0QWRhcHRlci5PVkVSTEFZX1VOSUZPUk1TLm92ZXJsYXksIG5ldyB0aHJlZS5UZXh0dXJlKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fX3NldFVuaWZvcm0obWVzaCwgQWJzdHJhY3RBZGFwdGVyLk9WRVJMQVlfVU5JRk9STVMub3ZlcmxheSwgdGV4dHVyZURhdGEudGV4dHVyZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5zZXRUZXh0dXJlT3BhY2l0eSA9IGZ1bmN0aW9uIHNldFRleHR1cmVPcGFjaXR5KG1lc2gsIG9wYWNpdHkpIHtcbiAgICAgIHRoaXMuX19zZXRVbmlmb3JtKG1lc2gsIEFic3RyYWN0QWRhcHRlci5PVkVSTEFZX1VOSUZPUk1TLmdsb2JhbE9wYWNpdHksIG9wYWNpdHkpO1xuXG4gICAgICBtZXNoLm1hdGVyaWFsLnRyYW5zcGFyZW50ID0gb3BhY2l0eSA8IDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5kaXNwb3NlVGV4dHVyZSA9IGZ1bmN0aW9uIGRpc3Bvc2VUZXh0dXJlKHRleHR1cmVEYXRhKSB7XG4gICAgICB2YXIgX3RleHR1cmVEYXRhJHRleHR1cmU7XG5cbiAgICAgIChfdGV4dHVyZURhdGEkdGV4dHVyZSA9IHRleHR1cmVEYXRhLnRleHR1cmUpID09IG51bGwgPyB2b2lkIDAgOiBfdGV4dHVyZURhdGEkdGV4dHVyZS5kaXNwb3NlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7ZXh0ZXJuYWw6VEhSRUUuTWVzaH0gbWVzaFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1bmlmb3JtXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLl9fc2V0VW5pZm9ybSA9IGZ1bmN0aW9uIF9fc2V0VW5pZm9ybShtZXNoLCB1bmlmb3JtLCB2YWx1ZSkge1xuICAgICAgaWYgKG1lc2gubWF0ZXJpYWwudW5pZm9ybXNbdW5pZm9ybV0udmFsdWUgaW5zdGFuY2VvZiB0aHJlZS5UZXh0dXJlKSB7XG4gICAgICAgIG1lc2gubWF0ZXJpYWwudW5pZm9ybXNbdW5pZm9ybV0udmFsdWUuZGlzcG9zZSgpO1xuICAgICAgfVxuXG4gICAgICBtZXNoLm1hdGVyaWFsLnVuaWZvcm1zW3VuaWZvcm1dLnZhbHVlID0gdmFsdWU7XG4gICAgfTtcblxuICAgIHJldHVybiBFcXVpcmVjdGFuZ3VsYXJBZGFwdGVyO1xuICB9KEFic3RyYWN0QWRhcHRlcik7XG4gIEVxdWlyZWN0YW5ndWxhckFkYXB0ZXIuaWQgPSAnZXF1aXJlY3Rhbmd1bGFyJztcbiAgRXF1aXJlY3Rhbmd1bGFyQWRhcHRlci5zdXBwb3J0c0Rvd25sb2FkID0gdHJ1ZTtcbiAgRXF1aXJlY3Rhbmd1bGFyQWRhcHRlci5zdXBwb3J0c092ZXJsYXkgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBAbmFtZXNwYWNlIFBTVi5jb21wb25lbnRzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAc3VtbWFyeSBCYXNlIGNvbXBvbmVudCBjbGFzc1xuICAgKiBAbWVtYmVyb2YgUFNWLmNvbXBvbmVudHNcbiAgICogQGFic3RyYWN0XG4gICAqL1xuICB2YXIgQWJzdHJhY3RDb21wb25lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UFNWLlZpZXdlciB8IFBTVi5jb21wb25lbnRzLkFic3RyYWN0Q29tcG9uZW50fSBwYXJlbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIC0gQ1NTIGNsYXNzIGFkZGVkIHRvIHRoZSBjb21wb25lbnQncyBjb250YWluZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBYnN0cmFjdENvbXBvbmVudChwYXJlbnQsIGNsYXNzTmFtZSkge1xuICAgICAgLyoqXG4gICAgICAgKiBAc3VtbWFyeSBSZWZlcmVuY2UgdG8gbWFpbiBjb250cm9sbGVyXG4gICAgICAgKiBAdHlwZSB7UFNWLlZpZXdlcn1cbiAgICAgICAqIEByZWFkb25seVxuICAgICAgICovXG4gICAgICB0aGlzLnBzdiA9IHBhcmVudC5wc3YgfHwgcGFyZW50O1xuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtQU1YuVmlld2VyfFBTVi5jb21wb25lbnRzLkFic3RyYWN0Q29tcG9uZW50fVxuICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgKi9cblxuICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICB0aGlzLnBhcmVudC5jaGlsZHJlbi5wdXNoKHRoaXMpO1xuICAgICAgLyoqXG4gICAgICAgKiBAc3VtbWFyeSBBbGwgY2hpbGQgY29tcG9uZW50c1xuICAgICAgICogQHR5cGUge1BTVi5jb21wb25lbnRzLkFic3RyYWN0Q29tcG9uZW50W119XG4gICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAqIEBwYWNrYWdlXG4gICAgICAgKi9cblxuICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgLyoqXG4gICAgICAgKiBAc3VtbWFyeSBJbnRlcm5hbCBwcm9wZXJ0aWVzXG4gICAgICAgKiBAbWVtYmVyIHtPYmplY3R9XG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHZpc2libGUgLSBWaXNpYmlsaXR5IG9mIHRoZSBjb21wb25lbnRcbiAgICAgICAqL1xuXG4gICAgICB0aGlzLnByb3AgPSB7XG4gICAgICAgIHZpc2libGU6IHRydWVcbiAgICAgIH07XG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge0hUTUxFbGVtZW50fVxuICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgKi9cblxuICAgICAgdGhpcy5jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgIHRoaXMucGFyZW50LmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmNvbnRhaW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IERlc3Ryb3lzIHRoZSBjb21wb25lbnRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG5cblxuICAgIHZhciBfcHJvdG8gPSBBYnN0cmFjdENvbXBvbmVudC5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLnBhcmVudC5jb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5jb250YWluZXIpO1xuICAgICAgdmFyIGNoaWxkSWR4ID0gdGhpcy5wYXJlbnQuY2hpbGRyZW4uaW5kZXhPZih0aGlzKTtcblxuICAgICAgaWYgKGNoaWxkSWR4ICE9PSAtMSkge1xuICAgICAgICB0aGlzLnBhcmVudC5jaGlsZHJlbi5zcGxpY2UoY2hpbGRJZHgsIDEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNoaWxkcmVuLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkLmRlc3Ryb3koKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jaGlsZHJlbi5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuY29udGFpbmVyO1xuICAgICAgZGVsZXRlIHRoaXMucGFyZW50O1xuICAgICAgZGVsZXRlIHRoaXMucHN2O1xuICAgICAgZGVsZXRlIHRoaXMucHJvcDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgUmVmcmVzaCBVSVxuICAgICAqIEBkZXNjcmlwdGlvbiBNdXN0IGJlIGJlIGEgdmVyeSBsaWdodHdlaWdodCBvcGVyYXRpb25cbiAgICAgKiBAcGFja2FnZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5yZWZyZXNoVWkgPSBmdW5jdGlvbiByZWZyZXNoVWkoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB0aGlzLmNoaWxkcmVuLmV2ZXJ5KGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBjaGlsZC5yZWZyZXNoVWkoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzLnBzdi5wcm9wLnVpUmVmcmVzaCA9PT0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBEaXNwbGF5cyBvciBoaWRlcyB0aGUgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtib29sZWFufSBbdmlzaWJsZV0gLSBmb3JjZWQgc3RhdGVcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8udG9nZ2xlID0gZnVuY3Rpb24gdG9nZ2xlKHZpc2libGUpIHtcbiAgICAgIGlmICh2aXNpYmxlID09PSBmYWxzZSB8fCB2aXNpYmxlID09PSB1bmRlZmluZWQgJiYgdGhpcy5pc1Zpc2libGUoKSkge1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgIH0gZWxzZSBpZiAodmlzaWJsZSA9PT0gdHJ1ZSB8fCB2aXNpYmxlID09PSB1bmRlZmluZWQgJiYgIXRoaXMuaXNWaXNpYmxlKCkpIHtcbiAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEhpZGVzIHRoZSBjb21wb25lbnRcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uaGlkZSA9IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgdGhpcy5wcm9wLnZpc2libGUgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgRGlzcGxheXMgdGhlIGNvbXBvbmVudFxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5zaG93ID0gZnVuY3Rpb24gc2hvdygpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICAgIHRoaXMucHJvcC52aXNpYmxlID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgQ2hlY2tzIGlmIHRoZSBjb21wb25lbnQgaXMgdmlzaWJsZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5pc1Zpc2libGUgPSBmdW5jdGlvbiBpc1Zpc2libGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wLnZpc2libGU7XG4gICAgfTtcblxuICAgIHJldHVybiBBYnN0cmFjdENvbXBvbmVudDtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBAbmFtZXNwYWNlIFBTVi5idXR0b25zXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAc3VtbWFyeSBCYXNlIG5hdmJhciBidXR0b24gY2xhc3NcbiAgICogQGV4dGVuZHMgUFNWLmNvbXBvbmVudHMuQWJzdHJhY3RDb21wb25lbnRcbiAgICogQG1lbWJlcm9mIFBTVi5idXR0b25zXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cblxuICB2YXIgQWJzdHJhY3RCdXR0b24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9BYnN0cmFjdENvbXBvbmVudCkge1xuICAgIF9pbmhlcml0c0xvb3NlKEFic3RyYWN0QnV0dG9uLCBfQWJzdHJhY3RDb21wb25lbnQpO1xuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgVW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGJ1dHRvblxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBJZGVudGlmaWVyIHRvIGRlY2xhcmUgYSBncm91cCBvZiBidXR0b25zXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFNWRyBpY29uIG5hbWUgaW5qZWN0ZWQgaW4gdGhlIGJ1dHRvblxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBTVkcgaWNvbiBuYW1lIGluamVjdGVkIGluIHRoZSBidXR0b24gd2hlbiBpdCBpcyBhY3RpdmVcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQU1YuY29tcG9uZW50cy5OYXZiYXJ9IG5hdmJhclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2xhc3NOYW1lXSAtIEFkZGl0aW9uYWwgQ1NTIGNsYXNzZXNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjb2xsYXBzYWJsZT1mYWxzZV0gLSBgdHJ1ZWAgaWYgdGhlIGJ1dHRvbiBjYW4gYmUgbW92ZWQgdG8gbWVudSB3aGVuIHRoZSBuYXZiYXIgaXMgdG9vIHNtYWxsXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbdGFiYmFibGU9dHJ1ZV0gLSBgdHJ1ZWAgaWYgdGhlIGJ1dHRvbiBpcyBhY2Nlc3NpYmxlIHdpdGggdGhlIGtleWJvYXJkXG4gICAgICovXG4gICAgZnVuY3Rpb24gQWJzdHJhY3RCdXR0b24obmF2YmFyLCBjbGFzc05hbWUsIGNvbGxhcHNhYmxlLCB0YWJiYWJsZSkge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBpZiAoY2xhc3NOYW1lID09PSB2b2lkIDApIHtcbiAgICAgICAgY2xhc3NOYW1lID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb2xsYXBzYWJsZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbGxhcHNhYmxlID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICh0YWJiYWJsZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRhYmJhYmxlID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMgPSBfQWJzdHJhY3RDb21wb25lbnQuY2FsbCh0aGlzLCBuYXZiYXIsICdwc3YtYnV0dG9uICcgKyBjbGFzc05hbWUpIHx8IHRoaXM7XG4gICAgICAvKipcbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGlkIC0gVW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGJ1dHRvblxuICAgICAgICogQHByb3BlcnR5IHtib29sZWFufSBlbmFibGVkXG4gICAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHN1cHBvcnRlZFxuICAgICAgICogQHByb3BlcnR5IHtib29sZWFufSBjb2xsYXBzZWRcbiAgICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYWN0aXZlXG4gICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGhcbiAgICAgICAqL1xuXG4gICAgICBfdGhpcy5wcm9wID0gX2V4dGVuZHMoe30sIF90aGlzLnByb3AsIHtcbiAgICAgICAgaWQ6IF90aGlzLmNvbnN0cnVjdG9yLmlkLFxuICAgICAgICBjb2xsYXBzYWJsZTogY29sbGFwc2FibGUsXG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIHN1cHBvcnRlZDogdHJ1ZSxcbiAgICAgICAgY29sbGFwc2VkOiBmYWxzZSxcbiAgICAgICAgYWN0aXZlOiBmYWxzZSxcbiAgICAgICAgd2lkdGg6IF90aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChfdGhpcy5jb25zdHJ1Y3Rvci5pY29uKSB7XG4gICAgICAgIF90aGlzLl9fc2V0SWNvbihfdGhpcy5jb25zdHJ1Y3Rvci5pY29uKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF90aGlzLnByb3AuaWQgJiYgX3RoaXMucHN2LmNvbmZpZy5sYW5nW190aGlzLnByb3AuaWRdKSB7XG4gICAgICAgIF90aGlzLmNvbnRhaW5lci50aXRsZSA9IF90aGlzLnBzdi5jb25maWcubGFuZ1tfdGhpcy5wcm9wLmlkXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRhYmJhYmxlKSB7XG4gICAgICAgIF90aGlzLmNvbnRhaW5lci50YWJJbmRleCA9IDA7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChfdGhpcy5wcm9wLmVuYWJsZWQpIHtcbiAgICAgICAgICBfdGhpcy5vbkNsaWNrKCk7XG4gICAgICAgIH1cblxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfSk7XG5cbiAgICAgIF90aGlzLmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUua2V5ID09PSBLRVlfQ09ERVMuRW50ZXIgJiYgX3RoaXMucHJvcC5lbmFibGVkKSB7XG4gICAgICAgICAgX3RoaXMub25DbGljaygpO1xuXG4gICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhY2thZ2VcbiAgICAgKi9cblxuXG4gICAgdmFyIF9wcm90byA9IEFic3RyYWN0QnV0dG9uLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5jaGVja1N1cHBvcnRlZCA9IGZ1bmN0aW9uIGNoZWNrU3VwcG9ydGVkKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBzdXBwb3J0ZWRPck9iamVjdCA9IHRoaXMuaXNTdXBwb3J0ZWQoKTtcblxuICAgICAgaWYgKGlzUGxhaW5PYmplY3Qoc3VwcG9ydGVkT3JPYmplY3QpKSB7XG4gICAgICAgIGlmIChzdXBwb3J0ZWRPck9iamVjdC5pbml0aWFsID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgIHRoaXMucHJvcC5zdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN1cHBvcnRlZE9yT2JqZWN0LnByb21pc2UudGhlbihmdW5jdGlvbiAoc3VwcG9ydGVkKSB7XG4gICAgICAgICAgaWYgKCFfdGhpczIucHJvcCkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyB0aGUgY29tcG9uZW50IGhhcyBiZWVuIGRlc3Ryb3llZFxuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzMi5wcm9wLnN1cHBvcnRlZCA9IHN1cHBvcnRlZDtcblxuICAgICAgICAgIF90aGlzMi50b2dnbGUoc3VwcG9ydGVkKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByb3Auc3VwcG9ydGVkID0gc3VwcG9ydGVkT3JPYmplY3Q7XG5cbiAgICAgICAgaWYgKCFzdXBwb3J0ZWRPck9iamVjdCkge1xuICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IENoZWNrcyBpZiB0aGUgYnV0dG9uIGNhbiBiZSBkaXNwbGF5ZWRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbnx7aW5pdGlhbDogYm9vbGVhbiwgcHJvbWlzZTogUHJvbWlzZTxib29sZWFuPn19XG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWQoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgQ2hhbmdlcyB0aGUgYWN0aXZlIHN0YXRlIG9mIHRoZSBidXR0b25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthY3RpdmVdIC0gZm9yY2VkIHN0YXRlXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLnRvZ2dsZUFjdGl2ZSA9IGZ1bmN0aW9uIHRvZ2dsZUFjdGl2ZShhY3RpdmUpIHtcbiAgICAgIHRoaXMucHJvcC5hY3RpdmUgPSBhY3RpdmUgIT09IHVuZGVmaW5lZCA/IGFjdGl2ZSA6ICF0aGlzLnByb3AuYWN0aXZlO1xuICAgICAgdG9nZ2xlQ2xhc3ModGhpcy5jb250YWluZXIsICdwc3YtYnV0dG9uLS1hY3RpdmUnLCB0aGlzLnByb3AuYWN0aXZlKTtcblxuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IuaWNvbkFjdGl2ZSkge1xuICAgICAgICB0aGlzLl9fc2V0SWNvbih0aGlzLnByb3AuYWN0aXZlID8gdGhpcy5jb25zdHJ1Y3Rvci5pY29uQWN0aXZlIDogdGhpcy5jb25zdHJ1Y3Rvci5pY29uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLnNob3cgPSBmdW5jdGlvbiBzaG93KHJlZnJlc2gpIHtcbiAgICAgIGlmIChyZWZyZXNoID09PSB2b2lkIDApIHtcbiAgICAgICAgcmVmcmVzaCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5pc1Zpc2libGUoKSkge1xuICAgICAgICB0aGlzLnByb3AudmlzaWJsZSA9IHRydWU7XG5cbiAgICAgICAgaWYgKCF0aGlzLnByb3AuY29sbGFwc2VkKSB7XG4gICAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlZnJlc2gpIHtcbiAgICAgICAgICB0aGlzLnBzdi5yZWZyZXNoVWkoXCJzaG93IGJ1dHRvbiBcIiArIHRoaXMucHJvcC5pZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLmhpZGUgPSBmdW5jdGlvbiBoaWRlKHJlZnJlc2gpIHtcbiAgICAgIGlmIChyZWZyZXNoID09PSB2b2lkIDApIHtcbiAgICAgICAgcmVmcmVzaCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlzVmlzaWJsZSgpKSB7XG4gICAgICAgIHRoaXMucHJvcC52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAgICAgaWYgKHJlZnJlc2gpIHtcbiAgICAgICAgICB0aGlzLnBzdi5yZWZyZXNoVWkoXCJoaWRlIGJ1dHRvbiBcIiArIHRoaXMucHJvcC5pZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgRGlzYWJsZXMgdGhlIGJ1dHRvblxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5kaXNhYmxlID0gZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3Bzdi1idXR0b24tLWRpc2FibGVkJyk7XG4gICAgICB0aGlzLnByb3AuZW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBFbmFibGVzIHRoZSBidXR0b25cbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uZW5hYmxlID0gZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSgncHN2LWJ1dHRvbi0tZGlzYWJsZWQnKTtcbiAgICAgIHRoaXMucHJvcC5lbmFibGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgQ29sbGFwc2VzIHRoZSBidXR0b24gaW4gdGhlIG5hdmJhciBtZW51XG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLmNvbGxhcHNlID0gZnVuY3Rpb24gY29sbGFwc2UoKSB7XG4gICAgICB0aGlzLnByb3AuY29sbGFwc2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFVuY29sbGFwc2VzIHRoZSBidXR0b24gZnJvbSB0aGUgbmF2YmFyIG1lbnVcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8udW5jb2xsYXBzZSA9IGZ1bmN0aW9uIHVuY29sbGFwc2UoKSB7XG4gICAgICB0aGlzLnByb3AuY29sbGFwc2VkID0gZmFsc2U7XG5cbiAgICAgIGlmICh0aGlzLnByb3AudmlzaWJsZSkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFNldCB0aGUgYnV0dG9uIGljb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWNvbiBTVkdcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBbY29udGFpbmVyXSAtIGRlZmF1bHQgaXMgdGhlIG1haW4gYnV0dG9uIGNvbnRhaW5lclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLl9fc2V0SWNvbiA9IGZ1bmN0aW9uIF9fc2V0SWNvbihpY29uLCBjb250YWluZXIpIHtcbiAgICAgIGlmIChjb250YWluZXIgPT09IHZvaWQgMCkge1xuICAgICAgICBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgIH1cblxuICAgICAgaWYgKGljb24pIHtcbiAgICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9IGljb247IC8vIGNsYXNzTmFtZSBpcyByZWFkLW9ubHkgb24gU1ZHRWxlbWVudFxuXG4gICAgICAgIGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCdzdmcnKS5jbGFzc0xpc3QuYWRkKCdwc3YtYnV0dG9uLXN2ZycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBBY3Rpb24gd2hlbiB0aGUgYnV0dG9uIGlzIGNsaWNrZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5vbkNsaWNrID0gZnVuY3Rpb24gb25DbGljaygpIHtcbiAgICAgIHRocm93IG5ldyBQU1ZFcnJvcihcIm9uQ2xpY2sgbm90IGltcGxlbWVudGVkIGZvciBidXR0b24gXFxcIlwiICsgdGhpcy5wcm9wLmlkICsgXCJcXFwiLlwiKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEFic3RyYWN0QnV0dG9uO1xuICB9KEFic3RyYWN0Q29tcG9uZW50KTtcbiAgQWJzdHJhY3RCdXR0b24uaWQgPSBudWxsO1xuICBBYnN0cmFjdEJ1dHRvbi5ncm91cElkID0gbnVsbDtcbiAgQWJzdHJhY3RCdXR0b24uaWNvbiA9IG51bGw7XG4gIEFic3RyYWN0QnV0dG9uLmljb25BY3RpdmUgPSBudWxsO1xuXG4gIHZhciBwbGF5QWN0aXZlID0gXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgdmlld0JveD1cXFwiMCAwIDQxIDQxXFxcIj48cGF0aCBmaWxsPVxcXCJjdXJyZW50Q29sb3JcXFwiIGQ9XFxcIk00MC41IDE0LjFjLS4xLS4xLTEuMi0uNS0yLjg5OC0xLS4xMDIgMC0uMjAyLS4xLS4yMDItLjJDMzQuNSA2LjUgMjggMiAyMC41IDJTNi42IDYuNSAzLjcgMTIuOWMwIC4xLS4xLjEtLjIuMi0xLjcuNi0yLjggMS0yLjkgMWwtLjYuM3YxMi4xbC42LjJjLjEgMCAxLjEuMzk5IDIuNy44OTkuMSAwIC4yLjEwMS4yLjE5OUM2LjMgMzQuNCAxMi45IDM5IDIwLjUgMzljNy42MDIgMCAxNC4xMDItNC42IDE2LjktMTEuMSAwLS4xMDIuMS0uMTAyLjE5OS0uMiAxLjY5OS0uNjAxIDIuNjk5LTEgMi44MDEtMWwuNi0uM1YxNC4zbC0uNS0uMnpNNi43MDEgMTEuNUM5LjcgNyAxNC44IDQgMjAuNSA0YzUuOCAwIDEwLjkgMyAxMy44IDcuNS4yLjMtLjEuNi0uMzk5LjUtMy43OTktMS04Ljc5OS0yLTEzLjYtMi00LjcgMC05LjUgMS0xMy4yIDItLjMuMS0uNS0uMi0uNC0uNXpNMjUuMSAyMC4zTDE4LjcgMjRjLS4zLjItLjcgMC0uNy0uNXYtNy40YzAtLjQuNC0uNi43LS40bDYuMzk5IDMuOGMuMzAxLjEuMzAxLjYuMDAxLjh6bTkuNCA4LjkwMUExNi40MjEgMTYuNDIxIDAgMCAxIDIwLjUgMzdjLTUuOSAwLTExLjEtMy4xLTE0LTcuODk4LS4yLS4zMDIuMS0uNjAyLjQtLjUgMy45IDEgOC45IDIuMSAxMy42IDIuMSA1IDAgOS45LTEgMTMuNjAyLTIgLjI5OC0uMS41LjE5OC4zOTguNDk5elxcXCIvPjwhLS1DcmVhdGVkIGJ5IE5pY2sgQmx1dGggZnJvbSB0aGUgTm91biBQcm9qZWN0LS0+PC9zdmc+XFxuXCI7XG5cbiAgdmFyIHBsYXkgPSBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB2aWV3Qm94PVxcXCIwIDAgNDEgNDFcXFwiPjxwYXRoIGZpbGw9XFxcImN1cnJlbnRDb2xvclxcXCIgZD1cXFwiTTQwLjUgMTQuMWMtLjEtLjEtMS4yLS41LTIuODk5LTEtLjEwMSAwLS4yLS4xLS4yLS4yQzM0LjUgNi41IDI4IDIgMjAuNSAyUzYuNiA2LjUgMy43IDEyLjljMCAuMS0uMS4xLS4yLjItMS43LjYtMi44IDEtMi45IDFsLS42LjN2MTIuMWwuNi4yYy4xIDAgMS4xLjQgMi43LjkuMSAwIC4yLjEuMi4xOTlDNi4zIDM0LjQgMTIuOSAzOSAyMC41IDM5YzcuNjAxIDAgMTQuMTAxLTQuNiAxNi45LTExLjEgMC0uMTAxLjEtLjEwMS4yLS4yIDEuNjk5LS42IDIuNjk5LTEgMi44LTFsLjYtLjNWMTQuM2wtLjUtLjJ6TTIwLjUgNGM1LjggMCAxMC45IDMgMTMuOCA3LjUuMi4zLS4xLjYtLjM5OS41LTMuOC0xLTguOC0yLTEzLjYtMi00LjcgMC05LjUgMS0xMy4yIDItLjMuMS0uNS0uMi0uNC0uNUM5LjcgNyAxNC44IDQgMjAuNSA0em0wIDMzYy01LjkgMC0xMS4xLTMuMS0xNC03Ljg5OS0uMi0uMzAxLjEtLjYwMS40LS41IDMuOSAxIDguOSAyLjEgMTMuNiAyLjEgNSAwIDkuOS0xIDEzLjYwMS0yIC4zLS4xLjUuMi4zOTkuNUExNi40MjIgMTYuNDIyIDAgMCAxIDIwLjUgMzd6bTE4LjYwMS0xMi4xYzAgLjEtLjEwMS4zLS4yLjMtMi41LjktMTAuNCAzLjYtMTguNCAzLjYtNy4xIDAtMTUuNi0yLjY5OS0xOC4zLTMuNkMyLjEgMjUuMiAyIDI1IDIgMjQuOVYxNmMwLS4xLjEtLjMuMi0uMyAyLjYtLjkgMTAuNi0zLjYgMTguMi0zLjYgNy41IDAgMTUuODk5IDIuNyAxOC41IDMuNi4xIDAgLjIuMi4yLjN2OC45elxcXCIvPjxwYXRoIGZpbGw9XFxcImN1cnJlbnRDb2xvclxcXCIgZD1cXFwiTTE4LjcgMjRsNi40LTMuN2MuMy0uMi4zLS43IDAtLjhsLTYuNC0zLjhjLS4zLS4yLS43IDAtLjcuNHY3LjRjMCAuNS40LjcuNy41elxcXCIvPjwhLS1DcmVhdGVkIGJ5IE5pY2sgQmx1dGggZnJvbSB0aGUgTm91biBQcm9qZWN0LS0+PC9zdmc+XFxuXCI7XG5cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IE5hdmlnYXRpb24gYmFyIGF1dG9yb3RhdGUgYnV0dG9uIGNsYXNzXG4gICAqIEBleHRlbmRzIFBTVi5idXR0b25zLkFic3RyYWN0QnV0dG9uXG4gICAqIEBtZW1iZXJvZiBQU1YuYnV0dG9uc1xuICAgKi9cblxuICB2YXIgQXV0b3JvdGF0ZUJ1dHRvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Fic3RyYWN0QnV0dG9uKSB7XG4gICAgX2luaGVyaXRzTG9vc2UoQXV0b3JvdGF0ZUJ1dHRvbiwgX0Fic3RyYWN0QnV0dG9uKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UFNWLmNvbXBvbmVudHMuTmF2YmFyfSBuYXZiYXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBdXRvcm90YXRlQnV0dG9uKG5hdmJhcikge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBfdGhpcyA9IF9BYnN0cmFjdEJ1dHRvbi5jYWxsKHRoaXMsIG5hdmJhciwgJ3Bzdi1idXR0b24tLWhvdmVyLXNjYWxlIHBzdi1hdXRvcm90YXRlLWJ1dHRvbicsIHRydWUpIHx8IHRoaXM7XG5cbiAgICAgIF90aGlzLnBzdi5vbihFVkVOVFMuQVVUT1JPVEFURSwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuXG5cbiAgICB2YXIgX3Byb3RvID0gQXV0b3JvdGF0ZUJ1dHRvbi5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLnBzdi5vZmYoRVZFTlRTLkFVVE9ST1RBVEUsIHRoaXMpO1xuXG4gICAgICBfQWJzdHJhY3RCdXR0b24ucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgSGFuZGxlcyBldmVudHNcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiBoYW5kbGVFdmVudChlKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICAgICAgc3dpdGNoIChlLnR5cGUpIHtcbiAgICAgICAgLy8gQGZvcm1hdHRlcjpvZmZcbiAgICAgICAgY2FzZSBFVkVOVFMuQVVUT1JPVEFURTpcbiAgICAgICAgICB0aGlzLnRvZ2dsZUFjdGl2ZShlLmFyZ3NbMF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBAZm9ybWF0dGVyOm9uXG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlICovXG5cbiAgICB9XG4gICAgLyoqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQGRlc2NyaXB0aW9uIFRvZ2dsZXMgYXV0b3JvdGF0ZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5vbkNsaWNrID0gZnVuY3Rpb24gb25DbGljaygpIHtcbiAgICAgIGlmICh0aGlzLnBzdi5pc0F1dG9yb3RhdGVFbmFibGVkKCkpIHtcbiAgICAgICAgdGhpcy5wc3YuY29uZmlnLmF1dG9yb3RhdGVJZGxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHN2LnJlc2V0SWRsZVRpbWVyKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHN2LnRvZ2dsZUF1dG9yb3RhdGUoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEF1dG9yb3RhdGVCdXR0b247XG4gIH0oQWJzdHJhY3RCdXR0b24pO1xuICBBdXRvcm90YXRlQnV0dG9uLmlkID0gJ2F1dG9yb3RhdGUnO1xuICBBdXRvcm90YXRlQnV0dG9uLmljb24gPSBwbGF5O1xuICBBdXRvcm90YXRlQnV0dG9uLmljb25BY3RpdmUgPSBwbGF5QWN0aXZlO1xuXG4gIC8qKlxuICAgKiBAc3VtbWFyeSBOYXZpZ2F0aW9uIGJhciBjdXN0b20gYnV0dG9uIGNsYXNzXG4gICAqIEBleHRlbmRzIFBTVi5idXR0b25zLkFic3RyYWN0QnV0dG9uXG4gICAqIEBtZW1iZXJvZiBQU1YuYnV0dG9uc1xuICAgKi9cblxuICB2YXIgQ3VzdG9tQnV0dG9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQWJzdHJhY3RCdXR0b24pIHtcbiAgICBfaW5oZXJpdHNMb29zZShDdXN0b21CdXR0b24sIF9BYnN0cmFjdEJ1dHRvbik7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1BTVi5jb21wb25lbnRzLk5hdmJhcn0gbmF2YmFyXG4gICAgICogQHBhcmFtIHtQU1YuTmF2YmFyQ3VzdG9tQnV0dG9ufSBjb25maWdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDdXN0b21CdXR0b24obmF2YmFyLCBjb25maWcpIHtcbiAgICAgIHZhciBfdGhpcztcblxuICAgICAgX3RoaXMgPSBfQWJzdHJhY3RCdXR0b24uY2FsbCh0aGlzLCBuYXZiYXIsICdwc3YtY3VzdG9tLWJ1dHRvbicsIGNvbmZpZy5jb2xsYXBzYWJsZSAhPT0gZmFsc2UsIGNvbmZpZy50YWJiYWJsZSAhPT0gZmFsc2UpIHx8IHRoaXM7XG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge09iamVjdH1cbiAgICAgICAqIEByZWFkb25seVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgICBfdGhpcy5jb25maWcgPSBjb25maWc7XG5cbiAgICAgIGlmIChfdGhpcy5jb25maWcuaWQpIHtcbiAgICAgICAgX3RoaXMucHJvcC5pZCA9IF90aGlzLmNvbmZpZy5pZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLnByb3AuaWQgPSAncHN2QnV0dG9uLScgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfdGhpcy5jb25maWcuY2xhc3NOYW1lKSB7XG4gICAgICAgIGFkZENsYXNzZXMoX3RoaXMuY29udGFpbmVyLCBfdGhpcy5jb25maWcuY2xhc3NOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF90aGlzLmNvbmZpZy50aXRsZSkge1xuICAgICAgICBfdGhpcy5jb250YWluZXIudGl0bGUgPSBfdGhpcy5jb25maWcudGl0bGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChfdGhpcy5jb25maWcuY29udGVudCkge1xuICAgICAgICBfdGhpcy5jb250YWluZXIuaW5uZXJIVE1MID0gX3RoaXMuY29uZmlnLmNvbnRlbnQ7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnByb3Aud2lkdGggPSBfdGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGg7XG5cbiAgICAgIGlmIChfdGhpcy5jb25maWcuZW5hYmxlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgX3RoaXMuZGlzYWJsZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoX3RoaXMuY29uZmlnLnZpc2libGUgPT09IGZhbHNlKSB7XG4gICAgICAgIF90aGlzLmhpZGUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cblxuXG4gICAgdmFyIF9wcm90byA9IEN1c3RvbUJ1dHRvbi5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICBkZWxldGUgdGhpcy5jb25maWc7XG5cbiAgICAgIF9BYnN0cmFjdEJ1dHRvbi5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAZGVzY3JpcHRpb24gQ2FsbHMgdXNlciBtZXRob2RcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8ub25DbGljayA9IGZ1bmN0aW9uIG9uQ2xpY2soKSB7XG4gICAgICBpZiAodGhpcy5jb25maWcub25DbGljaykge1xuICAgICAgICB0aGlzLmNvbmZpZy5vbkNsaWNrLmNhbGwodGhpcy5wc3YsIHRoaXMucHN2KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIEN1c3RvbUJ1dHRvbjtcbiAgfShBYnN0cmFjdEJ1dHRvbik7XG5cbiAgdmFyIGluZm8gPSBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB2aWV3Qm94PVxcXCIwIDAgNjQgNjRcXFwiPjxwYXRoIGZpbGw9XFxcImN1cnJlbnRDb2xvclxcXCIgZD1cXFwiTTI4LjMgMjYuMWMtMSAyLjYtMS45IDQuOC0yLjYgNy0yLjUgNy40LTUgMTQuNy03LjIgMjItMS4zIDQuNC41IDcuMiA0LjMgNy44IDEuMy4yIDIuOC4yIDQuMi0uMSA4LjItMiAxMS45LTguNiAxNS43LTE1LjJsLTIuMiAyYTE4LjggMTguOCAwIDAgMS03LjQgNS4yIDIgMiAwIDAgMS0xLjYtLjJjLS4yLS4xIDAtMSAwLTEuNGwuOC0xLjhMNDEuOSAyOGMuNS0xLjQuOS0zIC43LTQuNC0uMi0yLjYtMy00LjQtNi4zLTQuNC04LjguMi0xNSA0LjUtMTkuNSAxMS44LS4yLjMtLjIuNi0uMyAxLjMgMy43LTIuOCA2LjgtNi4xIDExLjgtNi4yelxcXCIvPjxjaXJjbGUgZmlsbD1cXFwiY3VycmVudENvbG9yXFxcIiBjeD1cXFwiMzkuM1xcXCIgY3k9XFxcIjkuMlxcXCIgcj1cXFwiOC4yXFxcIi8+PCEtLUNyZWF0ZWQgYnkgQXJhZmF0IFVkZGluIGZyb20gdGhlIE5vdW4gUHJvamVjdC0tPjwvc3ZnPlxcblwiO1xuXG4gIHZhciBNT0RFX05PVElGID0gMTtcbiAgdmFyIE1PREVfUEFORUwgPSAyO1xuICAvKipcbiAgICogQHN1bW1hcnkgTmF2aWdhdGlvbiBiYXIgZGVzY3JpcHRpb24gYnV0dG9uIGNsYXNzXG4gICAqIEBleHRlbmRzIFBTVi5idXR0b25zLkFic3RyYWN0QnV0dG9uXG4gICAqIEBtZW1iZXJvZiBQU1YuYnV0dG9uc1xuICAgKi9cblxuICB2YXIgRGVzY3JpcHRpb25CdXR0b24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9BYnN0cmFjdEJ1dHRvbikge1xuICAgIF9pbmhlcml0c0xvb3NlKERlc2NyaXB0aW9uQnV0dG9uLCBfQWJzdHJhY3RCdXR0b24pO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQU1YuY29tcG9uZW50cy5OYXZiYXJ9IG5hdmJhclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERlc2NyaXB0aW9uQnV0dG9uKG5hdmJhcikge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBfdGhpcyA9IF9BYnN0cmFjdEJ1dHRvbi5jYWxsKHRoaXMsIG5hdmJhciwgJ3Bzdi1idXR0b24tLWhvdmVyLXNjYWxlIHBzdi1kZXNjcmlwdGlvbi1idXR0b24nKSB8fCB0aGlzO1xuICAgICAgLyoqXG4gICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtb2RlIC0gbm90aWZpY2F0aW9uIG9yIHBhbmVsXG4gICAgICAgKi9cblxuICAgICAgX3RoaXMucHJvcCA9IF9leHRlbmRzKHt9LCBfdGhpcy5wcm9wLCB7XG4gICAgICAgIG1vZGU6IG51bGxcbiAgICAgIH0pO1xuXG4gICAgICBfdGhpcy5wc3Yub24oRVZFTlRTLkhJREVfTk9USUZJQ0FUSU9OLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICAgIF90aGlzLnBzdi5vbihFVkVOVFMuU0hPV19OT1RJRklDQVRJT04sIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgICAgX3RoaXMucHN2Lm9uKEVWRU5UUy5DTE9TRV9QQU5FTCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgICBfdGhpcy5wc3Yub24oRVZFTlRTLk9QRU5fUEFORUwsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cblxuXG4gICAgdmFyIF9wcm90byA9IERlc2NyaXB0aW9uQnV0dG9uLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMucHN2Lm9mZihFVkVOVFMuSElERV9OT1RJRklDQVRJT04sIHRoaXMpO1xuICAgICAgdGhpcy5wc3Yub2ZmKEVWRU5UUy5TSE9XX05PVElGSUNBVElPTiwgdGhpcyk7XG4gICAgICB0aGlzLnBzdi5vZmYoRVZFTlRTLkNMT1NFX1BBTkVMLCB0aGlzKTtcbiAgICAgIHRoaXMucHN2Lm9mZihFVkVOVFMuT1BFTl9QQU5FTCwgdGhpcyk7XG5cbiAgICAgIF9BYnN0cmFjdEJ1dHRvbi5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBIYW5kbGVzIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uIGhhbmRsZUV2ZW50KGUpIHtcbiAgICAgIGlmICghdGhpcy5wcm9wLm1vZGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2xvc2VkID0gZmFsc2U7XG5cbiAgICAgIHN3aXRjaCAoZS50eXBlKSB7XG4gICAgICAgIGNhc2UgRVZFTlRTLkhJREVfTk9USUZJQ0FUSU9OOlxuICAgICAgICAgIGNsb3NlZCA9IHRoaXMucHJvcC5tb2RlID09PSBNT0RFX05PVElGO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgRVZFTlRTLlNIT1dfTk9USUZJQ0FUSU9OOlxuICAgICAgICAgIGNsb3NlZCA9IHRoaXMucHJvcC5tb2RlID09PSBNT0RFX05PVElGICYmIGUuYXJnc1swXSAhPT0gSURTLkRFU0NSSVBUSU9OO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgRVZFTlRTLkNMT1NFX1BBTkVMOlxuICAgICAgICAgIGNsb3NlZCA9IHRoaXMucHJvcC5tb2RlID09PSBNT0RFX1BBTkVMO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgRVZFTlRTLk9QRU5fUEFORUw6XG4gICAgICAgICAgY2xvc2VkID0gdGhpcy5wcm9wLm1vZGUgPT09IE1PREVfUEFORUwgJiYgZS5hcmdzWzBdICE9PSBJRFMuREVTQ1JJUFRJT047XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChjbG9zZWQpIHtcbiAgICAgICAgdGhpcy50b2dnbGVBY3RpdmUoZmFsc2UpO1xuICAgICAgICB0aGlzLnByb3AubW9kZSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5oaWRlID0gZnVuY3Rpb24gaGlkZShyZWZyZXNoKSB7XG4gICAgICBfQWJzdHJhY3RCdXR0b24ucHJvdG90eXBlLmhpZGUuY2FsbCh0aGlzLCByZWZyZXNoKTtcblxuICAgICAgaWYgKHRoaXMucHJvcC5tb2RlKSB7XG4gICAgICAgIHRoaXMuX19jbG9zZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGJ1dHRvbiBjYW4gb25seSBiZSByZWZyZXNoIGZyb20gTmF2YmFyQ2FwdGlvblxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5yZWZyZXNoVWkgPSBmdW5jdGlvbiByZWZyZXNoVWkocmVmcmVzaCkge1xuICAgICAgaWYgKHJlZnJlc2ggPT09IHZvaWQgMCkge1xuICAgICAgICByZWZyZXNoID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWZyZXNoKSB7XG4gICAgICAgIHZhciBjYXB0aW9uID0gdGhpcy5wc3YubmF2YmFyLmdldEJ1dHRvbignY2FwdGlvbicsIGZhbHNlKTtcbiAgICAgICAgdmFyIGNhcHRpb25IaWRkZW4gPSBjYXB0aW9uICYmICFjYXB0aW9uLmlzVmlzaWJsZSgpO1xuICAgICAgICB2YXIgaGFzRGVzY3JpcHRpb24gPSAhIXRoaXMucHN2LmNvbmZpZy5kZXNjcmlwdGlvbjtcblxuICAgICAgICBpZiAoY2FwdGlvbkhpZGRlbiB8fCBoYXNEZXNjcmlwdGlvbikge1xuICAgICAgICAgIHRoaXMuc2hvdyhmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5oaWRlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAZGVzY3JpcHRpb24gVG9nZ2xlcyBjYXB0aW9uXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLm9uQ2xpY2sgPSBmdW5jdGlvbiBvbkNsaWNrKCkge1xuICAgICAgaWYgKHRoaXMucHJvcC5tb2RlKSB7XG4gICAgICAgIHRoaXMuX19jbG9zZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fX29wZW4oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uX19jbG9zZSA9IGZ1bmN0aW9uIF9fY2xvc2UoKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMucHJvcC5tb2RlKSB7XG4gICAgICAgIGNhc2UgTU9ERV9OT1RJRjpcbiAgICAgICAgICB0aGlzLnBzdi5ub3RpZmljYXRpb24uaGlkZShJRFMuREVTQ1JJUFRJT04pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgTU9ERV9QQU5FTDpcbiAgICAgICAgICB0aGlzLnBzdi5wYW5lbC5oaWRlKElEUy5ERVNDUklQVElPTik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLl9fb3BlbiA9IGZ1bmN0aW9uIF9fb3BlbigpIHtcbiAgICAgIHRoaXMudG9nZ2xlQWN0aXZlKHRydWUpO1xuXG4gICAgICBpZiAodGhpcy5wc3YuY29uZmlnLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgIHRoaXMucHJvcC5tb2RlID0gTU9ERV9QQU5FTDtcbiAgICAgICAgdGhpcy5wc3YucGFuZWwuc2hvdyh7XG4gICAgICAgICAgaWQ6IElEUy5ERVNDUklQVElPTixcbiAgICAgICAgICBjb250ZW50OiBcIlwiICsgKHRoaXMucHN2LmNvbmZpZy5jYXB0aW9uID8gXCI8cD5cIiArIHRoaXMucHN2LmNvbmZpZy5jYXB0aW9uICsgXCI8L3A+XCIgOiAnJykgKyB0aGlzLnBzdi5jb25maWcuZGVzY3JpcHRpb25cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByb3AubW9kZSA9IE1PREVfTk9USUY7XG4gICAgICAgIHRoaXMucHN2Lm5vdGlmaWNhdGlvbi5zaG93KHtcbiAgICAgICAgICBpZDogSURTLkRFU0NSSVBUSU9OLFxuICAgICAgICAgIGNvbnRlbnQ6IHRoaXMucHN2LmNvbmZpZy5jYXB0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gRGVzY3JpcHRpb25CdXR0b247XG4gIH0oQWJzdHJhY3RCdXR0b24pO1xuICBEZXNjcmlwdGlvbkJ1dHRvbi5pZCA9ICdkZXNjcmlwdGlvbic7XG4gIERlc2NyaXB0aW9uQnV0dG9uLmljb24gPSBpbmZvO1xuXG4gIHZhciBkb3dubG9hZCA9IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHZpZXdCb3g9XFxcIjAgMCAxMDAgMTAwXFxcIj48cGF0aCBmaWxsPVxcXCJjdXJyZW50Q29sb3JcXFwiIGQ9XFxcIk04My4zIDM1LjZoLTE3VjNIMzIuMnYzMi42SDE2LjZsMzMuNiAzMi43IDMzLTMyLjd6XFxcIi8+PHBhdGggZmlsbD1cXFwiY3VycmVudENvbG9yXFxcIiBkPVxcXCJNODMuMyA2NC4ydjE2LjNIMTYuNlY2NC4ySC0uMXYzMi42SDEwMFY2NC4ySDgzLjN6XFxcIi8+PCEtLUNyZWF0ZWQgYnkgTWljaGFlbCBaZW5hdHkgZnJvbSB0aGUgTm91biBQcm9qZWN0LS0+PC9zdmc+XFxuXCI7XG5cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IE5hdmlnYXRpb24gYmFyIGRvd25sb2FkIGJ1dHRvbiBjbGFzc1xuICAgKiBAZXh0ZW5kcyBQU1YuYnV0dG9ucy5BYnN0cmFjdEJ1dHRvblxuICAgKiBAbWVtYmVyb2YgUFNWLmJ1dHRvbnNcbiAgICovXG5cbiAgdmFyIERvd25sb2FkQnV0dG9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQWJzdHJhY3RCdXR0b24pIHtcbiAgICBfaW5oZXJpdHNMb29zZShEb3dubG9hZEJ1dHRvbiwgX0Fic3RyYWN0QnV0dG9uKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UFNWLmNvbXBvbmVudHMuTmF2YmFyfSBuYXZiYXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEb3dubG9hZEJ1dHRvbihuYXZiYXIpIHtcbiAgICAgIHJldHVybiBfQWJzdHJhY3RCdXR0b24uY2FsbCh0aGlzLCBuYXZiYXIsICdwc3YtYnV0dG9uLS1ob3Zlci1zY2FsZSBwc3YtZG93bmxvYWQtYnV0dG9uJywgdHJ1ZSkgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQGRlc2NyaXB0aW9uIEFza3MgdGhlIGJyb3dzZXIgdG8gZG93bmxvYWQgdGhlIHBhbm9yYW1hIHNvdXJjZSBmaWxlXG4gICAgICovXG5cblxuICAgIHZhciBfcHJvdG8gPSBEb3dubG9hZEJ1dHRvbi5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8ub25DbGljayA9IGZ1bmN0aW9uIG9uQ2xpY2soKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgIGxpbmsuaHJlZiA9IHRoaXMucHN2LmNvbmZpZy5kb3dubG9hZFVybCB8fCB0aGlzLnBzdi5jb25maWcucGFub3JhbWE7XG4gICAgICBsaW5rLmRvd25sb2FkID0gbGluay5ocmVmLnNwbGl0KCcvJykucG9wKCk7XG4gICAgICB0aGlzLnBzdi5jb250YWluZXIuYXBwZW5kQ2hpbGQobGluayk7XG4gICAgICBsaW5rLmNsaWNrKCk7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMucHN2LmNvbnRhaW5lci5yZW1vdmVDaGlsZChsaW5rKTtcbiAgICAgIH0sIDEwMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5yZWZyZXNoVWkgPSBmdW5jdGlvbiByZWZyZXNoVWkoKSB7XG4gICAgICB2YXIgc3VwcG9ydGVkID0gdGhpcy5wc3YuYWRhcHRlci5jb25zdHJ1Y3Rvci5zdXBwb3J0c0Rvd25sb2FkIHx8IHRoaXMucHN2LmNvbmZpZy5kb3dubG9hZFVybDtcblxuICAgICAgaWYgKHN1cHBvcnRlZCAmJiAhdGhpcy5wcm9wLnZpc2libGUpIHtcbiAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICB9IGVsc2UgaWYgKCFzdXBwb3J0ZWQgJiYgdGhpcy5wcm9wLnZpc2libGUpIHtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBEb3dubG9hZEJ1dHRvbjtcbiAgfShBYnN0cmFjdEJ1dHRvbik7XG4gIERvd25sb2FkQnV0dG9uLmlkID0gJ2Rvd25sb2FkJztcbiAgRG93bmxvYWRCdXR0b24uaWNvbiA9IGRvd25sb2FkO1xuXG4gIHZhciBmdWxsc2NyZWVuSW4gPSBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB2aWV3Qm94PVxcXCIwIDAgMTAwIDEwMFxcXCI+PHBhdGggZmlsbD1cXFwiY3VycmVudENvbG9yXFxcIiBkPVxcXCJNMTAwIDQwSDg3LjFWMTguOGgtMjFWNkgxMDB6TTEwMCA5My4ySDY2VjgwLjNoMjEuMXYtMjFIMTAwek0zNCA5My4ySDB2LTM0aDEyLjl2MjEuMWgyMXpNMTIuOSA0MEgwVjZoMzR2MTIuOUgxMi44elxcXCIvPjwhLS1DcmVhdGVkIGJ5IEdhcnJldHQgS25vbGwgZnJvbSB0aGUgTm91biBQcm9qZWN0LS0+PC9zdmc+XFxuXCI7XG5cbiAgdmFyIGZ1bGxzY3JlZW5PdXQgPSBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB2aWV3Qm94PVxcXCIwIDAgMTAwIDEwMFxcXCI+PHBhdGggZmlsbD1cXFwiY3VycmVudENvbG9yXFxcIiBkPVxcXCJNNjYgN2gxM3YyMWgyMXYxM0g2NnpNNjYgNjAuM2gzNHYxMi45SDc5djIxSDY2ek0wIDYwLjNoMzR2MzRIMjFWNzMuMUgwek0yMSA3aDEzdjM0SDBWMjhoMjF6XFxcIi8+PCEtLUNyZWF0ZWQgYnkgR2FycmV0dCBLbm9sbCBmcm9tIHRoZSBOb3VuIFByb2plY3QtLT48L3N2Zz5cXG5cIjtcblxuICAvKipcbiAgICogQHN1bW1hcnkgTmF2aWdhdGlvbiBiYXIgZnVsbHNjcmVlbiBidXR0b24gY2xhc3NcbiAgICogQGV4dGVuZHMgUFNWLmJ1dHRvbnMuQWJzdHJhY3RCdXR0b25cbiAgICogQG1lbWJlcm9mIFBTVi5idXR0b25zXG4gICAqL1xuXG4gIHZhciBGdWxsc2NyZWVuQnV0dG9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQWJzdHJhY3RCdXR0b24pIHtcbiAgICBfaW5oZXJpdHNMb29zZShGdWxsc2NyZWVuQnV0dG9uLCBfQWJzdHJhY3RCdXR0b24pO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQU1YuY29tcG9uZW50cy5OYXZiYXJ9IG5hdmJhclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEZ1bGxzY3JlZW5CdXR0b24obmF2YmFyKSB7XG4gICAgICB2YXIgX3RoaXM7XG5cbiAgICAgIF90aGlzID0gX0Fic3RyYWN0QnV0dG9uLmNhbGwodGhpcywgbmF2YmFyLCAncHN2LWJ1dHRvbi0taG92ZXItc2NhbGUgcHN2LWZ1bGxzY3JlZW4tYnV0dG9uJykgfHwgdGhpcztcblxuICAgICAgX3RoaXMucHN2Lm9uKEVWRU5UUy5GVUxMU0NSRUVOX1VQREFURUQsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cblxuXG4gICAgdmFyIF9wcm90byA9IEZ1bGxzY3JlZW5CdXR0b24ucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy5wc3Yub2ZmKEVWRU5UUy5GVUxMU0NSRUVOX1VQREFURUQsIHRoaXMpO1xuXG4gICAgICBfQWJzdHJhY3RCdXR0b24ucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uIGhhbmRsZUV2ZW50KGUpIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlICovXG4gICAgICBzd2l0Y2ggKGUudHlwZSkge1xuICAgICAgICAvLyBAZm9ybWF0dGVyOm9mZlxuICAgICAgICBjYXNlIEVWRU5UUy5GVUxMU0NSRUVOX1VQREFURUQ6XG4gICAgICAgICAgdGhpcy50b2dnbGVBY3RpdmUoZS5hcmdzWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gQGZvcm1hdHRlcjpvblxuICAgICAgfVxuICAgICAgLyogZXNsaW50LWVuYWJsZSAqL1xuXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBkZXNjcmlwdGlvbiBUb2dnbGVzIGZ1bGxzY3JlZW5cbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8ub25DbGljayA9IGZ1bmN0aW9uIG9uQ2xpY2soKSB7XG4gICAgICB0aGlzLnBzdi50b2dnbGVGdWxsc2NyZWVuKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBGdWxsc2NyZWVuQnV0dG9uO1xuICB9KEFic3RyYWN0QnV0dG9uKTtcbiAgRnVsbHNjcmVlbkJ1dHRvbi5pZCA9ICdmdWxsc2NyZWVuJztcbiAgRnVsbHNjcmVlbkJ1dHRvbi5pY29uID0gZnVsbHNjcmVlbkluO1xuICBGdWxsc2NyZWVuQnV0dG9uLmljb25BY3RpdmUgPSBmdWxsc2NyZWVuT3V0O1xuXG4gIHZhciBtZW51SWNvbiA9IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHZpZXdCb3g9XFxcIjEwIDEwIDgwIDgwXFxcIj48ZyBmaWxsPVxcXCJjdXJyZW50Q29sb3JcXFwiPjxjaXJjbGUgcj1cXFwiMTBcXFwiIGN4PVxcXCIyMFxcXCIgY3k9XFxcIjIwXFxcIi8+PGNpcmNsZSByPVxcXCIxMFxcXCIgY3g9XFxcIjUwXFxcIiBjeT1cXFwiMjBcXFwiLz48Y2lyY2xlIHI9XFxcIjEwXFxcIiBjeD1cXFwiODBcXFwiIGN5PVxcXCIyMFxcXCIvPjxjaXJjbGUgcj1cXFwiMTBcXFwiIGN4PVxcXCIyMFxcXCIgY3k9XFxcIjUwXFxcIi8+PGNpcmNsZSByPVxcXCIxMFxcXCIgY3g9XFxcIjUwXFxcIiBjeT1cXFwiNTBcXFwiLz48Y2lyY2xlIHI9XFxcIjEwXFxcIiBjeD1cXFwiODBcXFwiIGN5PVxcXCI1MFxcXCIvPjxjaXJjbGUgcj1cXFwiMTBcXFwiIGN4PVxcXCIyMFxcXCIgY3k9XFxcIjgwXFxcIi8+PGNpcmNsZSByPVxcXCIxMFxcXCIgY3g9XFxcIjUwXFxcIiBjeT1cXFwiODBcXFwiLz48Y2lyY2xlIHI9XFxcIjEwXFxcIiBjeD1cXFwiODBcXFwiIGN5PVxcXCI4MFxcXCIvPjwvZz48IS0tIENyZWF0ZWQgYnkgUmljaGFyZCBLdW7DoWsgZnJvbSB0aGUgTm91biBQcm9qZWN0LS0+PC9zdmc+XFxuXCI7XG5cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IE5hdmlnYXRpb24gYmFyIG1lbnUgYnV0dG9uIGNsYXNzXG4gICAqIEBleHRlbmRzIFBTVi5idXR0b25zLkFic3RyYWN0QnV0dG9uXG4gICAqIEBtZW1iZXJvZiBQU1YuYnV0dG9uc1xuICAgKi9cblxuICB2YXIgTWVudUJ1dHRvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Fic3RyYWN0QnV0dG9uKSB7XG4gICAgX2luaGVyaXRzTG9vc2UoTWVudUJ1dHRvbiwgX0Fic3RyYWN0QnV0dG9uKTtcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFByb3BlcnR5IG5hbWUgYWRkZWQgdG8gYnV0dG9ucyBsaXN0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IE1lbnUgdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0ge0Fic3RyYWN0QnV0dG9uW119IGJ1dHRvbnNcbiAgICAgKiBAcGFyYW0ge1BTVi5WaWV3ZXJ9IHBzdlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhS2V5XG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UFNWLmNvbXBvbmVudHMuTmF2YmFyfSBuYXZiYXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZW51QnV0dG9uKG5hdmJhcikge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBfdGhpcyA9IF9BYnN0cmFjdEJ1dHRvbi5jYWxsKHRoaXMsIG5hdmJhciwgJ3Bzdi1idXR0b24tLWhvdmVyLXNjYWxlIHBzdi1tZW51LWJ1dHRvbicpIHx8IHRoaXM7XG5cbiAgICAgIF90aGlzLnBzdi5vbihFVkVOVFMuT1BFTl9QQU5FTCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgICBfdGhpcy5wc3Yub24oRVZFTlRTLkNMT1NFX1BBTkVMLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICAgIF9BYnN0cmFjdEJ1dHRvbi5wcm90b3R5cGUuaGlkZS5jYWxsKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cblxuXG4gICAgdmFyIF9wcm90byA9IE1lbnVCdXR0b24ucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy5wc3Yub2ZmKEVWRU5UUy5PUEVOX1BBTkVMLCB0aGlzKTtcbiAgICAgIHRoaXMucHN2Lm9mZihFVkVOVFMuQ0xPU0VfUEFORUwsIHRoaXMpO1xuXG4gICAgICBfQWJzdHJhY3RCdXR0b24ucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgSGFuZGxlcyBldmVudHNcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiBoYW5kbGVFdmVudChlKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICAgICAgc3dpdGNoIChlLnR5cGUpIHtcbiAgICAgICAgLy8gQGZvcm1hdHRlcjpvZmZcbiAgICAgICAgY2FzZSBFVkVOVFMuT1BFTl9QQU5FTDpcbiAgICAgICAgICB0aGlzLnRvZ2dsZUFjdGl2ZShlLmFyZ3NbMF0gPT09IElEUy5NRU5VKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEVWRU5UUy5DTE9TRV9QQU5FTDpcbiAgICAgICAgICB0aGlzLnRvZ2dsZUFjdGl2ZShmYWxzZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIEBmb3JtYXR0ZXI6b25cbiAgICAgIH1cbiAgICAgIC8qIGVzbGludC1lbmFibGUgKi9cblxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uaGlkZSA9IGZ1bmN0aW9uIGhpZGUocmVmcmVzaCkge1xuICAgICAgX0Fic3RyYWN0QnV0dG9uLnByb3RvdHlwZS5oaWRlLmNhbGwodGhpcywgcmVmcmVzaCk7XG5cbiAgICAgIHRoaXMuX19oaWRlTWVudSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uc2hvdyA9IGZ1bmN0aW9uIHNob3cocmVmcmVzaCkge1xuICAgICAgX0Fic3RyYWN0QnV0dG9uLnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgcmVmcmVzaCk7XG5cbiAgICAgIGlmICh0aGlzLnByb3AuYWN0aXZlKSB7XG4gICAgICAgIHRoaXMuX19zaG93TWVudSgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAZGVzY3JpcHRpb24gVG9nZ2xlcyBtZW51XG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLm9uQ2xpY2sgPSBmdW5jdGlvbiBvbkNsaWNrKCkge1xuICAgICAgaWYgKHRoaXMucHJvcC5hY3RpdmUpIHtcbiAgICAgICAgdGhpcy5fX2hpZGVNZW51KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9fc2hvd01lbnUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLl9fc2hvd01lbnUgPSBmdW5jdGlvbiBfX3Nob3dNZW51KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMucHN2LnBhbmVsLnNob3coe1xuICAgICAgICBpZDogSURTLk1FTlUsXG4gICAgICAgIGNvbnRlbnQ6IE1lbnVCdXR0b24uTUVOVV9URU1QTEFURSh0aGlzLnBhcmVudC5jb2xsYXBzZWQsIHRoaXMucHN2LCBkYXNoZXJpemUoTWVudUJ1dHRvbi5CVVRUT05fREFUQSkpLFxuICAgICAgICBub01hcmdpbjogdHJ1ZSxcbiAgICAgICAgY2xpY2tIYW5kbGVyOiBmdW5jdGlvbiBjbGlja0hhbmRsZXIoZSkge1xuICAgICAgICAgIHZhciBsaSA9IGUudGFyZ2V0ID8gZ2V0Q2xvc2VzdChlLnRhcmdldCwgJ2xpJykgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgdmFyIGJ1dHRvbklkID0gbGkgPyBsaS5kYXRhc2V0W01lbnVCdXR0b24uQlVUVE9OX0RBVEFdIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgaWYgKGJ1dHRvbklkKSB7XG4gICAgICAgICAgICBfdGhpczIucGFyZW50LmdldEJ1dHRvbihidXR0b25JZCkub25DbGljaygpO1xuXG4gICAgICAgICAgICBfdGhpczIuX19oaWRlTWVudSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF9wcm90by5fX2hpZGVNZW51ID0gZnVuY3Rpb24gX19oaWRlTWVudSgpIHtcbiAgICAgIHRoaXMucHN2LnBhbmVsLmhpZGUoSURTLk1FTlUpO1xuICAgIH07XG5cbiAgICByZXR1cm4gTWVudUJ1dHRvbjtcbiAgfShBYnN0cmFjdEJ1dHRvbik7XG4gIE1lbnVCdXR0b24uaWQgPSAnbWVudSc7XG4gIE1lbnVCdXR0b24uaWNvbiA9IG1lbnVJY29uO1xuICBNZW51QnV0dG9uLkJVVFRPTl9EQVRBID0gJ3BzdkJ1dHRvbic7XG5cbiAgTWVudUJ1dHRvbi5NRU5VX1RFTVBMQVRFID0gZnVuY3Rpb24gKGJ1dHRvbnMsIHBzdiwgZGF0YUtleSkge1xuICAgIHJldHVybiBcIlxcbjxkaXYgY2xhc3M9XFxcInBzdi1wYW5lbC1tZW51IHBzdi1wYW5lbC1tZW51LS1zdHJpcHBlZFxcXCI+XFxuICA8aDEgY2xhc3M9XFxcInBzdi1wYW5lbC1tZW51LXRpdGxlXFxcIj5cIiArIG1lbnVJY29uICsgXCIgXCIgKyBwc3YuY29uZmlnLmxhbmcubWVudSArIFwiPC9oMT5cXG4gIDx1bCBjbGFzcz1cXFwicHN2LXBhbmVsLW1lbnUtbGlzdFxcXCI+XFxuICAgIFwiICsgYnV0dG9ucy5tYXAoZnVuY3Rpb24gKGJ1dHRvbikge1xuICAgICAgcmV0dXJuIFwiXFxuICAgIDxsaSBkYXRhLVwiICsgZGF0YUtleSArIFwiPVxcXCJcIiArIGJ1dHRvbi5wcm9wLmlkICsgXCJcXFwiIGNsYXNzPVxcXCJwc3YtcGFuZWwtbWVudS1pdGVtXFxcIiB0YWJpbmRleD1cXFwiMFxcXCI+XFxuICAgICAgPHNwYW4gY2xhc3M9XFxcInBzdi1wYW5lbC1tZW51LWl0ZW0taWNvblxcXCI+XCIgKyBidXR0b24uY29udGFpbmVyLmlubmVySFRNTCArIFwiPC9zcGFuPlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJwc3YtcGFuZWwtbWVudS1pdGVtLWxhYmVsXFxcIj5cIiArIGJ1dHRvbi5jb250YWluZXIudGl0bGUgKyBcIjwvc3Bhbj5cXG4gICAgPC9saT5cXG4gICAgXCI7XG4gICAgfSkuam9pbignJykgKyBcIlxcbiAgPC91bD5cXG48L2Rpdj5cXG5cIjtcbiAgfTtcblxuICB2YXIgYXJyb3cgPSBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB2aWV3Qm94PVxcXCI0MCA0MCA0MzIgNDMyXFxcIj48ZyB0cmFuc2Zvcm09XFxcInJvdGF0ZSgwLCAyNTYsIDI1NilcXFwiPjxwYXRoIGZpbGw9XFxcImN1cnJlbnRDb2xvclxcXCIgZD1cXFwiTTQyNS4yMyAyMTAuNTVIMjI3LjM5YTUgNSAwIDAxLTMuNTMtOC41M2w1Ni41Ni01Ni41N2E0NS41IDQ1LjUgMCAwMDAtNjQuMjggNDUuMTUgNDUuMTUgMCAwMC0zMi4xMy0xMy4zIDQ1LjE1IDQ1LjE1IDAgMDAtMzIuMTQgMTMuM0w0MS4zMiAyNTZsMTc0LjgzIDE3NC44M2E0NS4xNSA0NS4xNSAwIDAwMzIuMTQgMTMuMyA0NS4xNSA0NS4xNSAwIDAwMzIuMTMtMTMuMyA0NS41IDQ1LjUgMCAwMDAtNjQuMjhsLTU2LjU3LTU2LjU3YTUgNSAwIDAxMy41NC04LjUzaDE5Ny44NGMyNS4wNiAwIDQ1LjQ1LTIwLjM5IDQ1LjQ1LTQ1LjQ1cy0yMC40LTQ1LjQ1LTQ1LjQ1LTQ1LjQ1elxcXCIvPjwvZz48IS0tIENyZWF0ZWQgYnkgRmxhdGFydCBmcm9tIHRoZSBOb3VuIFByb2plY3QgLS0+PC9zdmc+XFxuXCI7XG5cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IEhlbHBlciBmb3IgcHJlc3NhYmxlIHRoaW5ncyAoYnV0dG9ucywga2V5Ym9hcmQpXG4gICAqIEBkZXNjcmlwdGlvbiBXaGVuIHRoZSBwcmVzc2VkIHRoaW5nIGdvZXMgdXAgYW5kIHdhcyBub3QgcHJlc3NlZCBsb25nIGVub3VnaCwgd2FpdCBhIGJpdCBtb3JlIGJlZm9yZSBleGVjdXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHZhciBQcmVzc0hhbmRsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFByZXNzSGFuZGxlcihkZWxheSkge1xuICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHtcbiAgICAgICAgZGVsYXkgPSAyMDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGVsYXkgPSBkZWxheTtcbiAgICAgIHRoaXMudGltZSA9IDA7XG4gICAgICB0aGlzLnRpbWVvdXQgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBfcHJvdG8gPSBQcmVzc0hhbmRsZXIucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLmRvd24gPSBmdW5jdGlvbiBkb3duKCkge1xuICAgICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdGhpcy50aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgfTtcblxuICAgIF9wcm90by51cCA9IGZ1bmN0aW9uIHVwKGNiKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAoIXRoaXMudGltZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBlbGFwc2VkID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLnRpbWU7XG5cbiAgICAgIGlmIChlbGFwc2VkIDwgdGhpcy5kZWxheSkge1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjYigpO1xuICAgICAgICAgIF90aGlzLnRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgIF90aGlzLnRpbWUgPSAwO1xuICAgICAgICB9LCB0aGlzLmRlbGF5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNiKCk7XG4gICAgICAgIHRoaXMudGltZSA9IDA7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBQcmVzc0hhbmRsZXI7XG4gIH0oKTtcblxuICBmdW5jdGlvbiBnZXRPcmllbnRlZEFycm93KGRpcmVjdGlvbikge1xuICAgIHZhciBhbmdsZSA9IDA7XG5cbiAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgLy8gQGZvcm1hdHRlcjpvZmZcbiAgICAgIGNhc2UgJ3VwJzpcbiAgICAgICAgYW5nbGUgPSA5MDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgYW5nbGUgPSAxODA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdkb3duJzpcbiAgICAgICAgYW5nbGUgPSAtOTA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhbmdsZSA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gQGZvcm1hdHRlcjpvblxuICAgIH1cblxuICAgIHJldHVybiBhcnJvdy5yZXBsYWNlKCdyb3RhdGUoMCcsIFwicm90YXRlKFwiICsgYW5nbGUpO1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBOYXZpZ2F0aW9uIGJhciBtb3ZlIGJ1dHRvbiBjbGFzc1xuICAgKiBAZXh0ZW5kcyBQU1YuYnV0dG9ucy5BYnN0cmFjdEJ1dHRvblxuICAgKiBAbWVtYmVyb2YgUFNWLmJ1dHRvbnNcbiAgICovXG5cbiAgdmFyIEFic3RyYWN0TW92ZUJ1dHRvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Fic3RyYWN0QnV0dG9uKSB7XG4gICAgX2luaGVyaXRzTG9vc2UoQWJzdHJhY3RNb3ZlQnV0dG9uLCBfQWJzdHJhY3RCdXR0b24pO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQU1YuY29tcG9uZW50cy5OYXZiYXJ9IG5hdmJhclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFic3RyYWN0TW92ZUJ1dHRvbihuYXZiYXIsIHZhbHVlKSB7XG4gICAgICB2YXIgX3RoaXM7XG5cbiAgICAgIF90aGlzID0gX0Fic3RyYWN0QnV0dG9uLmNhbGwodGhpcywgbmF2YmFyLCAncHN2LWJ1dHRvbi0taG92ZXItc2NhbGUgcHN2LW1vdmUtYnV0dG9uJykgfHwgdGhpcztcbiAgICAgIF90aGlzLmNvbnRhaW5lci50aXRsZSA9IF90aGlzLnBzdi5jb25maWcubGFuZy5tb3ZlO1xuICAgICAgLyoqXG4gICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAqIEBwcm9wZXJ0eSB7e2xvbmdpdHVkZTogYm9vbGVhbiwgbGF0aXR1ZGU6IGJvb2xlYW59fSB2YWx1ZVxuICAgICAgICogQHByb3BlcnR5IHtQcmVzc0hhbmRsZXJ9IGhhbmRsZXJcbiAgICAgICAqL1xuXG4gICAgICBfdGhpcy5wcm9wID0gX2V4dGVuZHMoe30sIF90aGlzLnByb3AsIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBoYW5kbGVyOiBuZXcgUHJlc3NIYW5kbGVyKClcbiAgICAgIH0pO1xuXG4gICAgICBfdGhpcy5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgICBfdGhpcy5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgICAgX3RoaXMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgICBfdGhpcy5wc3YuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICAgIF90aGlzLnBzdi5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG5cblxuICAgIHZhciBfcHJvdG8gPSBBYnN0cmFjdE1vdmVCdXR0b24ucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy5fX29uTW91c2VVcCgpO1xuXG4gICAgICB0aGlzLnBzdi5jb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMpO1xuICAgICAgdGhpcy5wc3YuY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcyk7XG5cbiAgICAgIF9BYnN0cmFjdEJ1dHRvbi5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBIYW5kbGVzIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uIGhhbmRsZUV2ZW50KGUpIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlICovXG4gICAgICBzd2l0Y2ggKGUudHlwZSkge1xuICAgICAgICAvLyBAZm9ybWF0dGVyOm9mZlxuICAgICAgICBjYXNlICdtb3VzZWRvd24nOlxuICAgICAgICAgIHRoaXMuX19vbk1vdXNlRG93bigpO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbW91c2V1cCc6XG4gICAgICAgICAgdGhpcy5fX29uTW91c2VVcCgpO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndG91Y2hlbmQnOlxuICAgICAgICAgIHRoaXMuX19vbk1vdXNlVXAoKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2tleWRvd24nOlxuICAgICAgICAgIGUua2V5ID09PSBLRVlfQ09ERVMuRW50ZXIgJiYgdGhpcy5fX29uTW91c2VEb3duKCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAna2V5dXAnOlxuICAgICAgICAgIGUua2V5ID09PSBLRVlfQ09ERVMuRW50ZXIgJiYgdGhpcy5fX29uTW91c2VVcCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBAZm9ybWF0dGVyOm9uXG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlICovXG5cbiAgICB9XG4gICAgLyoqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWQoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbml0aWFsOiAhU1lTVEVNLmlzVG91Y2hFbmFibGVkLmluaXRpYWwsXG4gICAgICAgIHByb21pc2U6IFNZU1RFTS5pc1RvdWNoRW5hYmxlZC5wcm9taXNlLnRoZW4oZnVuY3Rpb24gKGVuYWJsZWQpIHtcbiAgICAgICAgICByZXR1cm4gIWVuYWJsZWQ7XG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8ub25DbGljayA9IGZ1bmN0aW9uIG9uQ2xpY2soKSB7Ly8gbm90aGluZ1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5fX29uTW91c2VEb3duID0gZnVuY3Rpb24gX19vbk1vdXNlRG93bigpIHtcbiAgICAgIGlmICghdGhpcy5wcm9wLmVuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBzdi5fX3N0b3BBbGwoKTtcblxuICAgICAgdGhpcy5wc3YuZHluYW1pY3MucG9zaXRpb24ucm9sbCh0aGlzLnByb3AudmFsdWUpO1xuICAgICAgdGhpcy5wcm9wLmhhbmRsZXIuZG93bigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5fX29uTW91c2VVcCA9IGZ1bmN0aW9uIF9fb25Nb3VzZVVwKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy5wcm9wLmVuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnByb3AuaGFuZGxlci51cChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5wc3YuZHluYW1pY3MucG9zaXRpb24uc3RvcCgpO1xuXG4gICAgICAgIF90aGlzMi5wc3YucmVzZXRJZGxlVGltZXIoKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gQWJzdHJhY3RNb3ZlQnV0dG9uO1xuICB9KEFic3RyYWN0QnV0dG9uKTtcbiAgQWJzdHJhY3RNb3ZlQnV0dG9uLmdyb3VwSWQgPSAnbW92ZSc7XG5cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IE5hdmlnYXRpb24gYmFyIG1vdmUgZG93biBidXR0b24gY2xhc3NcbiAgICogQGV4dGVuZHMgUFNWLmJ1dHRvbnMuQWJzdHJhY3RNb3ZlQnV0dG9uXG4gICAqIEBtZW1iZXJvZiBQU1YuYnV0dG9uc1xuICAgKi9cblxuICB2YXIgTW92ZURvd25CdXR0b24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9BYnN0cmFjdE1vdmVCdXR0b24pIHtcbiAgICBfaW5oZXJpdHNMb29zZShNb3ZlRG93bkJ1dHRvbiwgX0Fic3RyYWN0TW92ZUJ1dHRvbik7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1BTVi5jb21wb25lbnRzLk5hdmJhcn0gbmF2YmFyXG4gICAgICovXG4gICAgZnVuY3Rpb24gTW92ZURvd25CdXR0b24obmF2YmFyKSB7XG4gICAgICByZXR1cm4gX0Fic3RyYWN0TW92ZUJ1dHRvbi5jYWxsKHRoaXMsIG5hdmJhciwge1xuICAgICAgICBsYXRpdHVkZTogdHJ1ZVxuICAgICAgfSkgfHwgdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gTW92ZURvd25CdXR0b247XG4gIH0oQWJzdHJhY3RNb3ZlQnV0dG9uKTtcbiAgTW92ZURvd25CdXR0b24uaWQgPSAnbW92ZURvd24nO1xuICBNb3ZlRG93bkJ1dHRvbi5pY29uID0gZ2V0T3JpZW50ZWRBcnJvdygnZG93bicpO1xuXG4gIC8qKlxuICAgKiBAc3VtbWFyeSBOYXZpZ2F0aW9uIGJhciBtb3ZlIGxlZnQgYnV0dG9uIGNsYXNzXG4gICAqIEBleHRlbmRzIFBTVi5idXR0b25zLkFic3RyYWN0TW92ZUJ1dHRvblxuICAgKiBAbWVtYmVyb2YgUFNWLmJ1dHRvbnNcbiAgICovXG5cbiAgdmFyIE1vdmVMZWZ0QnV0dG9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQWJzdHJhY3RNb3ZlQnV0dG9uKSB7XG4gICAgX2luaGVyaXRzTG9vc2UoTW92ZUxlZnRCdXR0b24sIF9BYnN0cmFjdE1vdmVCdXR0b24pO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQU1YuY29tcG9uZW50cy5OYXZiYXJ9IG5hdmJhclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1vdmVMZWZ0QnV0dG9uKG5hdmJhcikge1xuICAgICAgcmV0dXJuIF9BYnN0cmFjdE1vdmVCdXR0b24uY2FsbCh0aGlzLCBuYXZiYXIsIHtcbiAgICAgICAgbG9uZ2l0dWRlOiB0cnVlXG4gICAgICB9KSB8fCB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBNb3ZlTGVmdEJ1dHRvbjtcbiAgfShBYnN0cmFjdE1vdmVCdXR0b24pO1xuICBNb3ZlTGVmdEJ1dHRvbi5pZCA9ICdtb3ZlTGVmdCc7XG4gIE1vdmVMZWZ0QnV0dG9uLmljb24gPSBnZXRPcmllbnRlZEFycm93KCdsZWZ0Jyk7XG5cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IE5hdmlnYXRpb24gYmFyIG1vdmUgcmlnaHQgYnV0dG9uIGNsYXNzXG4gICAqIEBleHRlbmRzIFBTVi5idXR0b25zLkFic3RyYWN0TW92ZUJ1dHRvblxuICAgKiBAbWVtYmVyb2YgUFNWLmJ1dHRvbnNcbiAgICovXG5cbiAgdmFyIE1vdmVSaWdodEJ1dHRvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Fic3RyYWN0TW92ZUJ1dHRvbikge1xuICAgIF9pbmhlcml0c0xvb3NlKE1vdmVSaWdodEJ1dHRvbiwgX0Fic3RyYWN0TW92ZUJ1dHRvbik7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1BTVi5jb21wb25lbnRzLk5hdmJhcn0gbmF2YmFyXG4gICAgICovXG4gICAgZnVuY3Rpb24gTW92ZVJpZ2h0QnV0dG9uKG5hdmJhcikge1xuICAgICAgcmV0dXJuIF9BYnN0cmFjdE1vdmVCdXR0b24uY2FsbCh0aGlzLCBuYXZiYXIsIHtcbiAgICAgICAgbG9uZ2l0dWRlOiBmYWxzZVxuICAgICAgfSkgfHwgdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gTW92ZVJpZ2h0QnV0dG9uO1xuICB9KEFic3RyYWN0TW92ZUJ1dHRvbik7XG4gIE1vdmVSaWdodEJ1dHRvbi5pZCA9ICdtb3ZlUmlnaHQnO1xuICBNb3ZlUmlnaHRCdXR0b24uaWNvbiA9IGdldE9yaWVudGVkQXJyb3coJ3JpZ2h0Jyk7XG5cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IE5hdmlnYXRpb24gYmFyIG1vdmUgdXAgYnV0dG9uIGNsYXNzXG4gICAqIEBleHRlbmRzIFBTVi5idXR0b25zLkFic3RyYWN0TW92ZUJ1dHRvblxuICAgKiBAbWVtYmVyb2YgUFNWLmJ1dHRvbnNcbiAgICovXG5cbiAgdmFyIE1vdmVVcEJ1dHRvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Fic3RyYWN0TW92ZUJ1dHRvbikge1xuICAgIF9pbmhlcml0c0xvb3NlKE1vdmVVcEJ1dHRvbiwgX0Fic3RyYWN0TW92ZUJ1dHRvbik7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1BTVi5jb21wb25lbnRzLk5hdmJhcn0gbmF2YmFyXG4gICAgICovXG4gICAgZnVuY3Rpb24gTW92ZVVwQnV0dG9uKG5hdmJhcikge1xuICAgICAgcmV0dXJuIF9BYnN0cmFjdE1vdmVCdXR0b24uY2FsbCh0aGlzLCBuYXZiYXIsIHtcbiAgICAgICAgbGF0aXR1ZGU6IGZhbHNlXG4gICAgICB9KSB8fCB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBNb3ZlVXBCdXR0b247XG4gIH0oQWJzdHJhY3RNb3ZlQnV0dG9uKTtcbiAgTW92ZVVwQnV0dG9uLmlkID0gJ21vdmVVcCc7XG4gIE1vdmVVcEJ1dHRvbi5pY29uID0gZ2V0T3JpZW50ZWRBcnJvdygndXAnKTtcblxuICAvKipcbiAgICogQHN1bW1hcnkgTmF2aWdhdGlvbiBiYXIgem9vbSBidXR0b24gY2xhc3NcbiAgICogQGV4dGVuZHMgUFNWLmJ1dHRvbnMuQWJzdHJhY3RCdXR0b25cbiAgICogQG1lbWJlcm9mIFBTVi5idXR0b25zXG4gICAqL1xuXG4gIHZhciBBYnN0cmFjdFpvb21CdXR0b24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9BYnN0cmFjdEJ1dHRvbikge1xuICAgIF9pbmhlcml0c0xvb3NlKEFic3RyYWN0Wm9vbUJ1dHRvbiwgX0Fic3RyYWN0QnV0dG9uKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UFNWLmNvbXBvbmVudHMuTmF2YmFyfSBuYXZiYXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBYnN0cmFjdFpvb21CdXR0b24obmF2YmFyLCB2YWx1ZSkge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBfdGhpcyA9IF9BYnN0cmFjdEJ1dHRvbi5jYWxsKHRoaXMsIG5hdmJhciwgJ3Bzdi1idXR0b24tLWhvdmVyLXNjYWxlIHBzdi16b29tLWJ1dHRvbicpIHx8IHRoaXM7XG4gICAgICAvKipcbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICogQHByb3BlcnR5IHtib29sZWFufSB2YWx1ZVxuICAgICAgICogQHByb3BlcnR5IHtQcmVzc0hhbmRsZXJ9IGhhbmRsZXJcbiAgICAgICAqL1xuXG4gICAgICBfdGhpcy5wcm9wID0gX2V4dGVuZHMoe30sIF90aGlzLnByb3AsIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBoYW5kbGVyOiBuZXcgUHJlc3NIYW5kbGVyKClcbiAgICAgIH0pO1xuXG4gICAgICBfdGhpcy5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgICBfdGhpcy5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgICAgX3RoaXMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgICBfdGhpcy5wc3YuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICAgIF90aGlzLnBzdi5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG5cblxuICAgIHZhciBfcHJvdG8gPSBBYnN0cmFjdFpvb21CdXR0b24ucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy5fX29uTW91c2VVcCgpO1xuXG4gICAgICB0aGlzLnBzdi5jb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMpO1xuICAgICAgdGhpcy5wc3YuY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcyk7XG5cbiAgICAgIF9BYnN0cmFjdEJ1dHRvbi5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBIYW5kbGVzIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uIGhhbmRsZUV2ZW50KGUpIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlICovXG4gICAgICBzd2l0Y2ggKGUudHlwZSkge1xuICAgICAgICAvLyBAZm9ybWF0dGVyOm9mZlxuICAgICAgICBjYXNlICdtb3VzZWRvd24nOlxuICAgICAgICAgIHRoaXMuX19vbk1vdXNlRG93bigpO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbW91c2V1cCc6XG4gICAgICAgICAgdGhpcy5fX29uTW91c2VVcCgpO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndG91Y2hlbmQnOlxuICAgICAgICAgIHRoaXMuX19vbk1vdXNlVXAoKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2tleWRvd24nOlxuICAgICAgICAgIGUua2V5ID09PSBLRVlfQ09ERVMuRW50ZXIgJiYgdGhpcy5fX29uTW91c2VEb3duKCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAna2V5dXAnOlxuICAgICAgICAgIGUua2V5ID09PSBLRVlfQ09ERVMuRW50ZXIgJiYgdGhpcy5fX29uTW91c2VVcCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBAZm9ybWF0dGVyOm9uXG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlICovXG5cbiAgICB9XG4gICAgLyoqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWQoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbml0aWFsOiAhU1lTVEVNLmlzVG91Y2hFbmFibGVkLmluaXRpYWwsXG4gICAgICAgIHByb21pc2U6IFNZU1RFTS5pc1RvdWNoRW5hYmxlZC5wcm9taXNlLnRoZW4oZnVuY3Rpb24gKGVuYWJsZWQpIHtcbiAgICAgICAgICByZXR1cm4gIWVuYWJsZWQ7XG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8ub25DbGljayA9IGZ1bmN0aW9uIG9uQ2xpY2soKSB7Ly8gbm90aGluZ1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5fX29uTW91c2VEb3duID0gZnVuY3Rpb24gX19vbk1vdXNlRG93bigpIHtcbiAgICAgIGlmICghdGhpcy5wcm9wLmVuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBzdi5keW5hbWljcy56b29tLnJvbGwodGhpcy5wcm9wLnZhbHVlKTtcbiAgICAgIHRoaXMucHJvcC5oYW5kbGVyLmRvd24oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uX19vbk1vdXNlVXAgPSBmdW5jdGlvbiBfX29uTW91c2VVcCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBpZiAoIXRoaXMucHJvcC5lbmFibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcm9wLmhhbmRsZXIudXAoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLnBzdi5keW5hbWljcy56b29tLnN0b3AoKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gQWJzdHJhY3Rab29tQnV0dG9uO1xuICB9KEFic3RyYWN0QnV0dG9uKTtcbiAgQWJzdHJhY3Rab29tQnV0dG9uLmdyb3VwSWQgPSAnem9vbSc7XG5cbiAgdmFyIHpvb21JbiA9IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCI+PHBhdGggZmlsbD1cXFwiY3VycmVudENvbG9yXFxcIiBkPVxcXCJNMTQuMDQzIDEyLjIyYTcuNzM4IDcuNzM4IDAgMSAwLTEuODIzIDEuODIybDQuOTg1IDQuOTg1Yy41MDMuNTA0IDEuMzIuNTA0IDEuODIyIDBhMS4yODUgMS4yODUgMCAwIDAgMC0xLjgyMmwtNC45ODQtNC45ODV6bS02LjMwNSAxLjA0M2E1LjUyNyA1LjUyNyAwIDEgMSAwLTExLjA1MyA1LjUyNyA1LjUyNyAwIDAgMSAwIDExLjA1M3pcXFwiLz48cGF0aCBmaWxsPVxcXCJjdXJyZW50Q29sb3JcXFwiIGQ9XFxcIk04LjcyOCA0LjAwOUg2Ljc0NHYyLjczN0g0LjAwNlY4LjczaDIuNzM4djIuNzM2aDEuOTg0VjguNzNoMi43MzdWNi43NDZIOC43Mjh6XFxcIi8+PCEtLUNyZWF0ZWQgYnkgUnlhbiBDYW5uaW5nIGZyb20gdGhlIE5vdW4gUHJvamVjdC0tPjwvc3ZnPlxcblwiO1xuXG4gIC8qKlxuICAgKiBAc3VtbWFyeSBOYXZpZ2F0aW9uIGJhciB6b29tLWluIGJ1dHRvbiBjbGFzc1xuICAgKiBAZXh0ZW5kcyBQU1YuYnV0dG9ucy5BYnN0cmFjdFpvb21CdXR0b25cbiAgICogQG1lbWJlcm9mIFBTVi5idXR0b25zXG4gICAqL1xuXG4gIHZhciBab29tSW5CdXR0b24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9BYnN0cmFjdFpvb21CdXR0b24pIHtcbiAgICBfaW5oZXJpdHNMb29zZShab29tSW5CdXR0b24sIF9BYnN0cmFjdFpvb21CdXR0b24pO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQU1YuY29tcG9uZW50cy5OYXZiYXJ9IG5hdmJhclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFpvb21JbkJ1dHRvbihuYXZiYXIpIHtcbiAgICAgIHJldHVybiBfQWJzdHJhY3Rab29tQnV0dG9uLmNhbGwodGhpcywgbmF2YmFyLCBmYWxzZSkgfHwgdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gWm9vbUluQnV0dG9uO1xuICB9KEFic3RyYWN0Wm9vbUJ1dHRvbik7XG4gIFpvb21JbkJ1dHRvbi5pZCA9ICd6b29tSW4nO1xuICBab29tSW5CdXR0b24uaWNvbiA9IHpvb21JbjtcblxuICB2YXIgem9vbU91dCA9IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCI+PHBhdGggZmlsbD1cXFwiY3VycmVudENvbG9yXFxcIiBkPVxcXCJNMTQuMDQzIDEyLjIyYTcuNzM4IDcuNzM4IDAgMSAwLTEuODIzIDEuODIybDQuOTg1IDQuOTg1Yy41MDMuNTA0IDEuMzIuNTA0IDEuODIyIDBhMS4yODUgMS4yODUgMCAwIDAgMC0xLjgyMmwtNC45ODQtNC45ODV6bS02LjMwNSAxLjA0M2E1LjUyNyA1LjUyNyAwIDEgMSAwLTExLjA1MyA1LjUyNyA1LjUyNyAwIDAgMSAwIDExLjA1M3pcXFwiLz48cGF0aCBmaWxsPVxcXCJjdXJyZW50Q29sb3JcXFwiIGQ9XFxcIk00LjAwNiA2Ljc0Nmg3LjQ1OVY4LjczSDQuMDA2elxcXCIvPjwhLS1DcmVhdGVkIGJ5IFJ5YW4gQ2FubmluZyBmcm9tIHRoZSBOb3VuIFByb2plY3QtLT48L3N2Zz5cXG5cIjtcblxuICAvKipcbiAgICogQHN1bW1hcnkgTmF2aWdhdGlvbiBiYXIgem9vbS1vdXQgYnV0dG9uIGNsYXNzXG4gICAqIEBleHRlbmRzIFBTVi5idXR0b25zLkFic3RyYWN0Wm9vbUJ1dHRvblxuICAgKiBAbWVtYmVyb2YgUFNWLmJ1dHRvbnNcbiAgICovXG5cbiAgdmFyIFpvb21PdXRCdXR0b24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9BYnN0cmFjdFpvb21CdXR0b24pIHtcbiAgICBfaW5oZXJpdHNMb29zZShab29tT3V0QnV0dG9uLCBfQWJzdHJhY3Rab29tQnV0dG9uKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UFNWLmNvbXBvbmVudHMuTmF2YmFyfSBuYXZiYXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBab29tT3V0QnV0dG9uKG5hdmJhcikge1xuICAgICAgcmV0dXJuIF9BYnN0cmFjdFpvb21CdXR0b24uY2FsbCh0aGlzLCBuYXZiYXIsIHRydWUpIHx8IHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIFpvb21PdXRCdXR0b247XG4gIH0oQWJzdHJhY3Rab29tQnV0dG9uKTtcbiAgWm9vbU91dEJ1dHRvbi5pZCA9ICd6b29tT3V0JztcbiAgWm9vbU91dEJ1dHRvbi5pY29uID0gem9vbU91dDtcblxuICAvKipcbiAgICogQHN1bW1hcnkgTmF2aWdhdGlvbiBiYXIgem9vbSBidXR0b24gY2xhc3NcbiAgICogQGV4dGVuZHMgUFNWLmJ1dHRvbnMuQWJzdHJhY3RCdXR0b25cbiAgICogQG1lbWJlcm9mIFBTVi5idXR0b25zXG4gICAqL1xuXG4gIHZhciBab29tUmFuZ2VCdXR0b24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9BYnN0cmFjdEJ1dHRvbikge1xuICAgIF9pbmhlcml0c0xvb3NlKFpvb21SYW5nZUJ1dHRvbiwgX0Fic3RyYWN0QnV0dG9uKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UFNWLmNvbXBvbmVudHMuTmF2YmFyfSBuYXZiYXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBab29tUmFuZ2VCdXR0b24obmF2YmFyKSB7XG4gICAgICB2YXIgX3RoaXM7XG5cbiAgICAgIF90aGlzID0gX0Fic3RyYWN0QnV0dG9uLmNhbGwodGhpcywgbmF2YmFyLCAncHN2LXpvb20tcmFuZ2UnLCBmYWxzZSwgZmFsc2UpIHx8IHRoaXM7XG4gICAgICAvKipcbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1lZGlhTWluV2lkdGhcbiAgICAgICAqL1xuXG4gICAgICBfdGhpcy5wcm9wID0gX2V4dGVuZHMoe30sIF90aGlzLnByb3AsIHtcbiAgICAgICAgbWVkaWFNaW5XaWR0aDogMFxuICAgICAgfSk7XG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge0hUTUxFbGVtZW50fVxuICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICAgIF90aGlzLnpvb21SYW5nZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgX3RoaXMuem9vbVJhbmdlLmNsYXNzTmFtZSA9ICdwc3Ytem9vbS1yYW5nZS1saW5lJztcblxuICAgICAgX3RoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKF90aGlzLnpvb21SYW5nZSk7XG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge0hUTUxFbGVtZW50fVxuICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cblxuICAgICAgX3RoaXMuem9vbVZhbHVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBfdGhpcy56b29tVmFsdWUuY2xhc3NOYW1lID0gJ3Bzdi16b29tLXJhbmdlLWhhbmRsZSc7XG5cbiAgICAgIF90aGlzLnpvb21SYW5nZS5hcHBlbmRDaGlsZChfdGhpcy56b29tVmFsdWUpO1xuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtQU1YuU2xpZGVyfVxuICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cblxuICAgICAgX3RoaXMuc2xpZGVyID0gbmV3IFNsaWRlcih7XG4gICAgICAgIGNvbnRhaW5lcjogX3RoaXMuY29udGFpbmVyLFxuICAgICAgICBkaXJlY3Rpb246IFNsaWRlci5IT1JJWk9OVEFMLFxuICAgICAgICBvblVwZGF0ZTogZnVuY3Rpb24gb25VcGRhdGUoZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5fX29uU2xpZGVyVXBkYXRlKGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIF90aGlzLnByb3AubWVkaWFNaW5XaWR0aCA9IHBhcnNlSW50KGdldFN0eWxlKF90aGlzLmNvbnRhaW5lciwgJ21heFdpZHRoJyksIDEwKTtcblxuICAgICAgX3RoaXMucHN2Lm9uKEVWRU5UUy5aT09NX1VQREFURUQsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgICAgaWYgKF90aGlzLnBzdi5wcm9wLnJlYWR5KSB7XG4gICAgICAgIF90aGlzLl9fbW92ZVpvb21WYWx1ZShfdGhpcy5wc3YuZ2V0Wm9vbUxldmVsKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMucHN2Lm9uY2UoRVZFTlRTLlJFQURZLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnJlZnJlc2hVaSgpO1xuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuXG5cbiAgICB2YXIgX3Byb3RvID0gWm9vbVJhbmdlQnV0dG9uLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuc2xpZGVyLmRlc3Ryb3koKTtcbiAgICAgIGRlbGV0ZSB0aGlzLnpvb21SYW5nZTtcbiAgICAgIGRlbGV0ZSB0aGlzLnpvb21WYWx1ZTtcbiAgICAgIHRoaXMucHN2Lm9mZihFVkVOVFMuWk9PTV9VUERBVEVELCB0aGlzKTtcbiAgICAgIHRoaXMucHN2Lm9mZihFVkVOVFMuUkVBRFksIHRoaXMpO1xuXG4gICAgICBfQWJzdHJhY3RCdXR0b24ucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgSGFuZGxlcyBldmVudHNcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiBoYW5kbGVFdmVudChlKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICAgICAgc3dpdGNoIChlLnR5cGUpIHtcbiAgICAgICAgLy8gQGZvcm1hdHRlcjpvZmZcbiAgICAgICAgY2FzZSBFVkVOVFMuWk9PTV9VUERBVEVEOlxuICAgICAgICAgIHRoaXMuX19tb3ZlWm9vbVZhbHVlKGUuYXJnc1swXSk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEVWRU5UUy5SRUFEWTpcbiAgICAgICAgICB0aGlzLl9fbW92ZVpvb21WYWx1ZSh0aGlzLnBzdi5nZXRab29tTGV2ZWwoKSk7XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gQGZvcm1hdHRlcjpvblxuICAgICAgfVxuICAgICAgLyogZXNsaW50LWVuYWJsZSAqL1xuXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uIGlzU3VwcG9ydGVkKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5pdGlhbDogIVNZU1RFTS5pc1RvdWNoRW5hYmxlZC5pbml0aWFsLFxuICAgICAgICBwcm9taXNlOiBTWVNURU0uaXNUb3VjaEVuYWJsZWQucHJvbWlzZS50aGVuKGZ1bmN0aW9uIChlbmFibGVkKSB7XG4gICAgICAgICAgcmV0dXJuICFlbmFibGVkO1xuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLnJlZnJlc2hVaSA9IGZ1bmN0aW9uIHJlZnJlc2hVaSgpIHtcbiAgICAgIGlmICh0aGlzLnByb3Auc3VwcG9ydGVkKSB7XG4gICAgICAgIGlmICh0aGlzLnBzdi5wcm9wLnNpemUud2lkdGggPD0gdGhpcy5wcm9wLm1lZGlhTWluV2lkdGggJiYgdGhpcy5wcm9wLnZpc2libGUpIHtcbiAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnBzdi5wcm9wLnNpemUud2lkdGggPiB0aGlzLnByb3AubWVkaWFNaW5XaWR0aCAmJiAhdGhpcy5wcm9wLnZpc2libGUpIHtcbiAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8ub25DbGljayA9IGZ1bmN0aW9uIG9uQ2xpY2soKSB7Ly8gbm90aGluZ1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBNb3ZlcyB0aGUgem9vbSBjdXJzb3JcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGV2ZWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5fX21vdmVab29tVmFsdWUgPSBmdW5jdGlvbiBfX21vdmVab29tVmFsdWUobGV2ZWwpIHtcbiAgICAgIHRoaXMuem9vbVZhbHVlLnN0eWxlLmxlZnQgPSBsZXZlbCAvIDEwMCAqIHRoaXMuem9vbVJhbmdlLm9mZnNldFdpZHRoIC0gdGhpcy56b29tVmFsdWUub2Zmc2V0V2lkdGggLyAyICsgJ3B4JztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgWm9vbSBjaGFuZ2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5fX29uU2xpZGVyVXBkYXRlID0gZnVuY3Rpb24gX19vblNsaWRlclVwZGF0ZShlKSB7XG4gICAgICBpZiAoZS5tb3VzZWRvd24pIHtcbiAgICAgICAgdGhpcy5wc3Yuem9vbShlLnZhbHVlICogMTAwKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIFpvb21SYW5nZUJ1dHRvbjtcbiAgfShBYnN0cmFjdEJ1dHRvbik7XG4gIFpvb21SYW5nZUJ1dHRvbi5pZCA9ICd6b29tUmFuZ2UnO1xuICBab29tUmFuZ2VCdXR0b24uZ3JvdXBJZCA9ICd6b29tJztcblxuICAvKipcbiAgICogQG5hbWVzcGFjZSBQU1YucGx1Z2luc1xuICAgKi9cblxuICAvKipcbiAgICogQHN1bW1hcnkgQmFzZSBwbHVnaW5zIGNsYXNzXG4gICAqIEBtZW1iZXJvZiBQU1YucGx1Z2luc1xuICAgKiBAYWJzdHJhY3RcbiAgICovXG5cbiAgdmFyIEFic3RyYWN0UGx1Z2luID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXZlbnRFbWl0dGVyKSB7XG4gICAgX2luaGVyaXRzTG9vc2UoQWJzdHJhY3RQbHVnaW4sIF9FdmVudEVtaXR0ZXIpO1xuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgVW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHBsdWdpblxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1BTVi5WaWV3ZXJ9IHBzdlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFic3RyYWN0UGx1Z2luKHBzdikge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBfdGhpcyA9IF9FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgLyoqXG4gICAgICAgKiBAc3VtbWFyeSBSZWZlcmVuY2UgdG8gbWFpbiBjb250cm9sbGVyXG4gICAgICAgKiBAdHlwZSB7UFNWLlZpZXdlcn1cbiAgICAgICAqIEByZWFkb25seVxuICAgICAgICovXG5cbiAgICAgIF90aGlzLnBzdiA9IHBzdjtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgSW5pdGlhbGl6ZXMgdGhlIHBsdWdpblxuICAgICAqIEBwYWNrYWdlXG4gICAgICovXG5cblxuICAgIHZhciBfcHJvdG8gPSBBYnN0cmFjdFBsdWdpbi5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uaW5pdCA9IGZ1bmN0aW9uIGluaXQoKSB7fVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IERlc3Ryb3lzIHRoZSBwbHVnaW5cbiAgICAgKiBAcGFja2FnZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnBzdjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEFic3RyYWN0UGx1Z2luO1xuICB9KHVldmVudC5FdmVudEVtaXR0ZXIpO1xuICBBYnN0cmFjdFBsdWdpbi5pZCA9IG51bGw7XG5cbiAgdmFyIF9rZXlib2FyZDtcbiAgLyoqXG4gICAqIEBzdW1tYXJ5IERlZmF1bHQgb3B0aW9uc1xuICAgKiBAdHlwZSB7UFNWLk9wdGlvbnN9XG4gICAqIEBtZW1iZXJPZiBQU1ZcbiAgICogQGNvbnN0YW50XG4gICAqL1xuXG4gIHZhciBERUZBVUxUUyA9IHtcbiAgICBwYW5vcmFtYTogbnVsbCxcbiAgICBvdmVybGF5OiBudWxsLFxuICAgIG92ZXJsYXlPcGFjaXR5OiAxLFxuICAgIGNvbnRhaW5lcjogbnVsbCxcbiAgICBhZGFwdGVyOiBudWxsLFxuICAgIHBsdWdpbnM6IFtdLFxuICAgIGNhcHRpb246IG51bGwsXG4gICAgZGVzY3JpcHRpb246IG51bGwsXG4gICAgZG93bmxvYWRVcmw6IG51bGwsXG4gICAgbG9hZGluZ0ltZzogbnVsbCxcbiAgICBsb2FkaW5nVHh0OiAnTG9hZGluZy4uLicsXG4gICAgc2l6ZTogbnVsbCxcbiAgICBmaXNoZXllOiBmYWxzZSxcbiAgICBtaW5Gb3Y6IDMwLFxuICAgIG1heEZvdjogOTAsXG4gICAgZGVmYXVsdFpvb21Mdmw6IDUwLFxuICAgIGRlZmF1bHRMb25nOiAwLFxuICAgIGRlZmF1bHRMYXQ6IDAsXG4gICAgc3BoZXJlQ29ycmVjdGlvbjogbnVsbCxcbiAgICBtb3ZlU3BlZWQ6IDEsXG4gICAgem9vbVNwZWVkOiAxLFxuICAgIGF1dG9yb3RhdGVEZWxheTogbnVsbCxcbiAgICBhdXRvcm90YXRlSWRsZTogZmFsc2UsXG4gICAgYXV0b3JvdGF0ZVNwZWVkOiAnMnJwbScsXG4gICAgYXV0b3JvdGF0ZUxhdDogbnVsbCxcbiAgICBhdXRvcm90YXRlWm9vbUx2bDogbnVsbCxcbiAgICBtb3ZlSW5lcnRpYTogdHJ1ZSxcbiAgICBtb3VzZXdoZWVsOiB0cnVlLFxuICAgIG1vdXNlbW92ZTogdHJ1ZSxcbiAgICBtb3VzZXdoZWVsQ3RybEtleTogZmFsc2UsXG4gICAgdG91Y2htb3ZlVHdvRmluZ2VyczogZmFsc2UsXG4gICAgdXNlWG1wRGF0YTogdHJ1ZSxcbiAgICBwYW5vRGF0YTogbnVsbCxcbiAgICByZXF1ZXN0SGVhZGVyczogbnVsbCxcbiAgICBjYW52YXNCYWNrZ3JvdW5kOiAnIzAwMCcsXG4gICAgd2l0aENyZWRlbnRpYWxzOiBmYWxzZSxcbiAgICBuYXZiYXI6IFsnYXV0b3JvdGF0ZScsICd6b29tJywgJ21vdmUnLCAnZG93bmxvYWQnLCAnZGVzY3JpcHRpb24nLCAnY2FwdGlvbicsICdmdWxsc2NyZWVuJ10sXG4gICAgbGFuZzoge1xuICAgICAgYXV0b3JvdGF0ZTogJ0F1dG9tYXRpYyByb3RhdGlvbicsXG4gICAgICB6b29tOiAnWm9vbScsXG4gICAgICB6b29tT3V0OiAnWm9vbSBvdXQnLFxuICAgICAgem9vbUluOiAnWm9vbSBpbicsXG4gICAgICBtb3ZlOiAnTW92ZScsXG4gICAgICBkb3dubG9hZDogJ0Rvd25sb2FkJyxcbiAgICAgIGZ1bGxzY3JlZW46ICdGdWxsc2NyZWVuJyxcbiAgICAgIG1lbnU6ICdNZW51JyxcbiAgICAgIHR3b0ZpbmdlcnM6ICdVc2UgdHdvIGZpbmdlcnMgdG8gbmF2aWdhdGUnLFxuICAgICAgY3RybFpvb206ICdVc2UgY3RybCArIHNjcm9sbCB0byB6b29tIHRoZSBpbWFnZScsXG4gICAgICBsb2FkRXJyb3I6ICdUaGUgcGFub3JhbWEgY2FuXFwndCBiZSBsb2FkZWQnXG4gICAgfSxcbiAgICBrZXlib2FyZDogKF9rZXlib2FyZCA9IHt9LCBfa2V5Ym9hcmRbS0VZX0NPREVTLkFycm93VXBdID0gQUNUSU9OUy5ST1RBVEVfTEFUX1VQLCBfa2V5Ym9hcmRbS0VZX0NPREVTLkFycm93RG93bl0gPSBBQ1RJT05TLlJPVEFURV9MQVRfRE9XTiwgX2tleWJvYXJkW0tFWV9DT0RFUy5BcnJvd1JpZ2h0XSA9IEFDVElPTlMuUk9UQVRFX0xPTkdfUklHSFQsIF9rZXlib2FyZFtLRVlfQ09ERVMuQXJyb3dMZWZ0XSA9IEFDVElPTlMuUk9UQVRFX0xPTkdfTEVGVCwgX2tleWJvYXJkW0tFWV9DT0RFUy5QYWdlVXBdID0gQUNUSU9OUy5aT09NX0lOLCBfa2V5Ym9hcmRbS0VZX0NPREVTLlBhZ2VEb3duXSA9IEFDVElPTlMuWk9PTV9PVVQsIF9rZXlib2FyZFtLRVlfQ09ERVMuUGx1c10gPSBBQ1RJT05TLlpPT01fSU4sIF9rZXlib2FyZFtLRVlfQ09ERVMuTWludXNdID0gQUNUSU9OUy5aT09NX09VVCwgX2tleWJvYXJkW0tFWV9DT0RFUy5TcGFjZV0gPSBBQ1RJT05TLlRPR0dMRV9BVVRPUk9UQVRFLCBfa2V5Ym9hcmQpXG4gIH07XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBMaXN0IG9mIHVubW9kaWZpYWJsZSBvcHRpb25zIGFuZCB0aGVpciBlcnJvciBtZXNzYWdlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB2YXIgUkVBRE9OTFlfT1BUSU9OUyA9IHtcbiAgICBwYW5vcmFtYTogJ1VzZSBzZXRQYW5vcmFtYSBtZXRob2QgdG8gY2hhbmdlIHRoZSBwYW5vcmFtYScsXG4gICAgcGFub0RhdGE6ICdVc2Ugc2V0UGFub3JhbWEgbWV0aG9kIHRvIGNoYW5nZSB0aGUgcGFub3JhbWEnLFxuICAgIGNvbnRhaW5lcjogJ0Nhbm5vdCBjaGFuZ2Ugdmlld2VyIGNvbnRhaW5lcicsXG4gICAgYWRhcHRlcjogJ0Nhbm5vdCBjaGFuZ2UgYWRhcHRlcicsXG4gICAgcGx1Z2luczogJ0Nhbm5vdCBjaGFuZ2UgcGx1Z2lucydcbiAgfTtcbiAgLyoqXG4gICAqIEBzdW1tYXJ5IExpc3Qgb2YgZGVwcmVjYXRlZCBvcHRpb25zIGFuZCB0aGVpciB3YXJuaW5nIG1lc3NhZ2VzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHZhciBERVBSRUNBVEVEX09QVElPTlMgPSB7XG4gICAgY2FwdHVyZUN1cnNvcjogJ2NhcHR1cmVDdXJzb3IgaXMgZGVwcmVjYXRlZCdcbiAgfTtcbiAgLyoqXG4gICAqIEBzdW1tYXJ5IFBhcnNlcnMvdmFsaWRhdG9ycyBmb3IgZWFjaCBvcHRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdmFyIENPTkZJR19QQVJTRVJTID0ge1xuICAgIGNvbnRhaW5lcjogZnVuY3Rpb24gY29udGFpbmVyKF9jb250YWluZXIpIHtcbiAgICAgIGlmICghX2NvbnRhaW5lcikge1xuICAgICAgICB0aHJvdyBuZXcgUFNWRXJyb3IoJ05vIHZhbHVlIGdpdmVuIGZvciBjb250YWluZXIuJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfY29udGFpbmVyO1xuICAgIH0sXG4gICAgYWRhcHRlcjogZnVuY3Rpb24gYWRhcHRlcihfYWRhcHRlcikge1xuICAgICAgaWYgKCFfYWRhcHRlcikge1xuICAgICAgICBfYWRhcHRlciA9IFtFcXVpcmVjdGFuZ3VsYXJBZGFwdGVyXTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShfYWRhcHRlcikpIHtcbiAgICAgICAgX2FkYXB0ZXIgPSBbcGx1Z2luSW50ZXJvcChfYWRhcHRlclswXSwgQWJzdHJhY3RBZGFwdGVyKSwgX2FkYXB0ZXJbMV1dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkYXB0ZXIgPSBbcGx1Z2luSW50ZXJvcChfYWRhcHRlciwgQWJzdHJhY3RBZGFwdGVyKV07XG4gICAgICB9XG5cbiAgICAgIGlmICghX2FkYXB0ZXJbMF0pIHtcbiAgICAgICAgdGhyb3cgbmV3IFBTVkVycm9yKCdVbiB1bmRlZmluZWQgdmFsdWUgd2l0aCBnaXZlbiBmb3IgYWRhcHRlci4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9hZGFwdGVyO1xuICAgIH0sXG4gICAgb3ZlcmxheU9wYWNpdHk6IGZ1bmN0aW9uIG92ZXJsYXlPcGFjaXR5KF9vdmVybGF5T3BhY2l0eSkge1xuICAgICAgcmV0dXJuIHRocmVlLk1hdGhVdGlscy5jbGFtcChfb3ZlcmxheU9wYWNpdHksIDAsIDEpO1xuICAgIH0sXG4gICAgZGVmYXVsdExvbmc6IGZ1bmN0aW9uIGRlZmF1bHRMb25nKF9kZWZhdWx0TG9uZykge1xuICAgICAgLy8gZGVmYXVsdExhdCBpcyBiZXR3ZWVuIDAgYW5kIFBJXG4gICAgICByZXR1cm4gcGFyc2VBbmdsZShfZGVmYXVsdExvbmcpO1xuICAgIH0sXG4gICAgZGVmYXVsdExhdDogZnVuY3Rpb24gZGVmYXVsdExhdChfZGVmYXVsdExhdCkge1xuICAgICAgLy8gZGVmYXVsdExhdCBpcyBiZXR3ZWVuIC1QSS8yIGFuZCBQSS8yXG4gICAgICByZXR1cm4gcGFyc2VBbmdsZShfZGVmYXVsdExhdCwgdHJ1ZSk7XG4gICAgfSxcbiAgICBkZWZhdWx0Wm9vbUx2bDogZnVuY3Rpb24gZGVmYXVsdFpvb21MdmwoX2RlZmF1bHRab29tTHZsKSB7XG4gICAgICByZXR1cm4gdGhyZWUuTWF0aFV0aWxzLmNsYW1wKF9kZWZhdWx0Wm9vbUx2bCwgMCwgMTAwKTtcbiAgICB9LFxuICAgIG1pbkZvdjogZnVuY3Rpb24gbWluRm92KF9taW5Gb3YsIGNvbmZpZykge1xuICAgICAgLy8gbWluRm92IGFuZCBtYXhGb3YgbXVzdCBiZSBvcmRlcmVkXG4gICAgICBpZiAoY29uZmlnLm1heEZvdiA8IF9taW5Gb3YpIHtcbiAgICAgICAgbG9nV2FybignbWF4Rm92IGNhbm5vdCBiZSBsb3dlciB0aGFuIG1pbkZvdicpO1xuICAgICAgICBfbWluRm92ID0gY29uZmlnLm1heEZvdjtcbiAgICAgIH0gLy8gbWluRm92IGJldHdlZW4gMSBhbmQgMTc5XG5cblxuICAgICAgcmV0dXJuIHRocmVlLk1hdGhVdGlscy5jbGFtcChfbWluRm92LCAxLCAxNzkpO1xuICAgIH0sXG4gICAgbWF4Rm92OiBmdW5jdGlvbiBtYXhGb3YoX21heEZvdiwgY29uZmlnKSB7XG4gICAgICAvLyBtaW5Gb3YgYW5kIG1heEZvdiBtdXN0IGJlIG9yZGVyZWRcbiAgICAgIGlmIChfbWF4Rm92IDwgY29uZmlnLm1pbkZvdikge1xuICAgICAgICBfbWF4Rm92ID0gY29uZmlnLm1pbkZvdjtcbiAgICAgIH0gLy8gbWF4Rm92IGJldHdlZW4gMSBhbmQgMTc5XG5cblxuICAgICAgcmV0dXJuIHRocmVlLk1hdGhVdGlscy5jbGFtcChfbWF4Rm92LCAxLCAxNzkpO1xuICAgIH0sXG4gICAgbGFuZzogZnVuY3Rpb24gbGFuZyhfbGFuZykge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoX2xhbmcudHdvRmluZ2VycykpIHtcbiAgICAgICAgbG9nV2FybignbGFuZy50d29GaW5nZXJzIG11c3Qgbm90IGJlIGFuIGFycmF5Jyk7XG4gICAgICAgIF9sYW5nLnR3b0ZpbmdlcnMgPSBfbGFuZy50d29GaW5nZXJzWzBdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIERFRkFVTFRTLmxhbmcsIF9sYW5nKTtcbiAgICB9LFxuICAgIGtleWJvYXJkOiBmdW5jdGlvbiBrZXlib2FyZChfa2V5Ym9hcmQyKSB7XG4gICAgICAvLyBrZXlib2FyZD10cnVlIGJlY29tZXMgdGhlIGRlZmF1bHQgbWFwXG4gICAgICBpZiAoX2tleWJvYXJkMiA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gY2xvbmUoREVGQVVMVFMua2V5Ym9hcmQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2tleWJvYXJkMjtcbiAgICB9LFxuICAgIGF1dG9yb3RhdGVMYXQ6IGZ1bmN0aW9uIGF1dG9yb3RhdGVMYXQoX2F1dG9yb3RhdGVMYXQsIGNvbmZpZykge1xuICAgICAgLy8gZGVmYXVsdCBhdXRvcm90YXRlTGF0IGlzIGRlZmF1bHRMYXRcbiAgICAgIGlmIChfYXV0b3JvdGF0ZUxhdCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcGFyc2VBbmdsZShjb25maWcuZGVmYXVsdExhdCwgdHJ1ZSk7XG4gICAgICB9IC8vIGF1dG9yb3RhdGVMYXQgaXMgYmV0d2VlbiAtUEkvMiBhbmQgUEkvMlxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBwYXJzZUFuZ2xlKF9hdXRvcm90YXRlTGF0LCB0cnVlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGF1dG9yb3RhdGVab29tTHZsOiBmdW5jdGlvbiBhdXRvcm90YXRlWm9vbUx2bChfYXV0b3JvdGF0ZVpvb21MdmwpIHtcbiAgICAgIGlmIChpc05pbChfYXV0b3JvdGF0ZVpvb21MdmwpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRocmVlLk1hdGhVdGlscy5jbGFtcChfYXV0b3JvdGF0ZVpvb21MdmwsIDAsIDEwMCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBhdXRvcm90YXRlU3BlZWQ6IGZ1bmN0aW9uIGF1dG9yb3RhdGVTcGVlZChfYXV0b3JvdGF0ZVNwZWVkKSB7XG4gICAgICByZXR1cm4gcGFyc2VTcGVlZChfYXV0b3JvdGF0ZVNwZWVkKTtcbiAgICB9LFxuICAgIGF1dG9yb3RhdGVJZGxlOiBmdW5jdGlvbiBhdXRvcm90YXRlSWRsZShfYXV0b3JvdGF0ZUlkbGUsIGNvbmZpZykge1xuICAgICAgaWYgKF9hdXRvcm90YXRlSWRsZSAmJiBpc05pbChjb25maWcuYXV0b3JvdGF0ZURlbGF5KSkge1xuICAgICAgICBsb2dXYXJuKCdhdXRvcm90YXRlSWRsZSByZXF1aXJlcyBhIG5vbiBudWxsIGF1dG9yb3RhdGVEZWxheScpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfYXV0b3JvdGF0ZUlkbGU7XG4gICAgfSxcbiAgICBmaXNoZXllOiBmdW5jdGlvbiBmaXNoZXllKF9maXNoZXllKSB7XG4gICAgICAvLyB0cmFuc2xhdGUgYm9vbGVhbiBmaXNoZXllIHRvIGFtb3VudFxuICAgICAgaWYgKF9maXNoZXllID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSBlbHNlIGlmIChfZmlzaGV5ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZmlzaGV5ZTtcbiAgICB9LFxuICAgIHBsdWdpbnM6IGZ1bmN0aW9uIHBsdWdpbnMoX3BsdWdpbnMpIHtcbiAgICAgIHJldHVybiBfcGx1Z2lucy5tYXAoZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwbHVnaW4pKSB7XG4gICAgICAgICAgcGx1Z2luID0gW3BsdWdpbkludGVyb3AocGx1Z2luWzBdLCBBYnN0cmFjdFBsdWdpbiksIHBsdWdpblsxXV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGx1Z2luID0gW3BsdWdpbkludGVyb3AocGx1Z2luLCBBYnN0cmFjdFBsdWdpbildO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwbHVnaW5bMF0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUFNWRXJyb3IoJ1VuIHVuZGVmaW5lZCB2YWx1ZSB3YXMgZ2l2ZW4gZm9yIHBsdWdpbnMuJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGx1Z2luO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQHN1bW1hcnkgTWVyZ2UgdXNlciBjb25maWcgd2l0aCBkZWZhdWx0IGNvbmZpZyBhbmQgcGVyZm9ybXMgdmFsaWRhdGlvblxuICAgKiBAcGFyYW0ge1BTVi5PcHRpb25zfSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtQU1YuT3B0aW9uc31cbiAgICogQG1lbWJlck9mIFBTVlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICBmdW5jdGlvbiBnZXRDb25maWcob3B0aW9ucykge1xuICAgIHZhciB0ZW1wQ29uZmlnID0gY2xvbmUoREVGQVVMVFMpO1xuICAgIGRlZXBtZXJnZSh0ZW1wQ29uZmlnLCBvcHRpb25zKTtcbiAgICB2YXIgY29uZmlnID0ge307XG4gICAgZWFjaCh0ZW1wQ29uZmlnLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgaWYgKERFUFJFQ0FURURfT1BUSU9OU1trZXldKSB7XG4gICAgICAgIGxvZ1dhcm4oREVQUkVDQVRFRF9PUFRJT05TW2tleV0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKERFRkFVTFRTLCBrZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBQU1ZFcnJvcihcIlVua25vd24gb3B0aW9uIFwiICsga2V5KTtcbiAgICAgIH1cblxuICAgICAgaWYgKENPTkZJR19QQVJTRVJTW2tleV0pIHtcbiAgICAgICAgY29uZmlnW2tleV0gPSBDT05GSUdfUEFSU0VSU1trZXldKHZhbHVlLCB0ZW1wQ29uZmlnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbmZpZ1trZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxuXG4gIC8qKlxuICAgKiBAc3VtbWFyeSBOYXZiYXIgY2FwdGlvbiBjbGFzc1xuICAgKiBAZXh0ZW5kcyBQU1YuY29tcG9uZW50cy5BYnN0cmFjdENvbXBvbmVudFxuICAgKiBAbWVtYmVyb2YgUFNWLmNvbXBvbmVudHNcbiAgICovXG5cbiAgdmFyIE5hdmJhckNhcHRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9BYnN0cmFjdENvbXBvbmVudCkge1xuICAgIF9pbmhlcml0c0xvb3NlKE5hdmJhckNhcHRpb24sIF9BYnN0cmFjdENvbXBvbmVudCk7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1BTVi5jb21wb25lbnRzLk5hdmJhcn0gbmF2YmFyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNhcHRpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBOYXZiYXJDYXB0aW9uKG5hdmJhciwgY2FwdGlvbikge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBfdGhpcyA9IF9BYnN0cmFjdENvbXBvbmVudC5jYWxsKHRoaXMsIG5hdmJhciwgJ3Bzdi1jYXB0aW9uJykgfHwgdGhpcztcbiAgICAgIC8qKlxuICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gaWRcbiAgICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY29sbGFwc2FibGVcbiAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB3aWR0aFxuICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGNvbnRlbnRXaWR0aCAtIHdpZHRoIG9mIHRoZSBjYXB0aW9uIGNvbnRlbnRcbiAgICAgICAqL1xuXG4gICAgICBfdGhpcy5wcm9wID0gX2V4dGVuZHMoe30sIF90aGlzLnByb3AsIHtcbiAgICAgICAgaWQ6IF90aGlzLmNvbnN0cnVjdG9yLmlkLFxuICAgICAgICBjb2xsYXBzYWJsZTogZmFsc2UsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBjb250ZW50V2lkdGg6IDBcbiAgICAgIH0pO1xuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtIVE1MRWxlbWVudH1cbiAgICAgICAqIEByZWFkb25seVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgICBfdGhpcy5jb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBfdGhpcy5jb250ZW50LmNsYXNzTmFtZSA9ICdwc3YtY2FwdGlvbi1jb250ZW50JztcblxuICAgICAgX3RoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKF90aGlzLmNvbnRlbnQpO1xuXG4gICAgICBfdGhpcy5zZXRDYXB0aW9uKGNhcHRpb24pO1xuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuXG5cbiAgICB2YXIgX3Byb3RvID0gTmF2YmFyQ2FwdGlvbi5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICBkZWxldGUgdGhpcy5jb250ZW50O1xuXG4gICAgICBfQWJzdHJhY3RDb21wb25lbnQucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgU2V0cyB0aGUgYmFyIGNhcHRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5zZXRDYXB0aW9uID0gZnVuY3Rpb24gc2V0Q2FwdGlvbihodG1sKSB7XG4gICAgICB0aGlzLnNob3coKTtcbiAgICAgIHRoaXMuY29udGVudC5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgdGhpcy5wcm9wLmNvbnRlbnRXaWR0aCA9IGh0bWwgPyB0aGlzLmNvbnRlbnQub2Zmc2V0V2lkdGggOiAwO1xuICAgICAgdGhpcy5yZWZyZXNoVWkoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgVG9nZ2xlcyBjb250ZW50IGFuZCBpY29uIGRlcGVuZGluZyBvbiBhdmFpbGFibGUgc3BhY2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5yZWZyZXNoVWkgPSBmdW5jdGlvbiByZWZyZXNoVWkoKSB7XG4gICAgICB0aGlzLnRvZ2dsZSh0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aCA+PSB0aGlzLnByb3AuY29udGVudFdpZHRoKTtcblxuICAgICAgdGhpcy5fX3JlZnJlc2hCdXR0b24oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLmhpZGUgPSBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgdGhpcy5jb250ZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB0aGlzLnByb3AudmlzaWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uc2hvdyA9IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgICB0aGlzLmNvbnRlbnQuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgICAgdGhpcy5wcm9wLnZpc2libGUgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5fX3JlZnJlc2hCdXR0b24gPSBmdW5jdGlvbiBfX3JlZnJlc2hCdXR0b24oKSB7XG4gICAgICB2YXIgX3RoaXMkcHN2JG5hdmJhciRnZXRCO1xuXG4gICAgICAoX3RoaXMkcHN2JG5hdmJhciRnZXRCID0gdGhpcy5wc3YubmF2YmFyLmdldEJ1dHRvbihEZXNjcmlwdGlvbkJ1dHRvbi5pZCwgZmFsc2UpKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkcHN2JG5hdmJhciRnZXRCLnJlZnJlc2hVaSh0cnVlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIE5hdmJhckNhcHRpb247XG4gIH0oQWJzdHJhY3RDb21wb25lbnQpO1xuICBOYXZiYXJDYXB0aW9uLmlkID0gJ2NhcHRpb24nO1xuXG4gIC8qKlxuICAgKiBAc3VtbWFyeSBMaXN0IG9mIGF2YWlsYWJsZSBidXR0b25zXG4gICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBDbGFzczxQU1YuYnV0dG9ucy5BYnN0cmFjdEJ1dHRvbj4+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB2YXIgQVZBSUxBQkxFX0JVVFRPTlMgPSB7fTtcbiAgLyoqXG4gICAqIEBzdW1tYXJ5IExpc3Qgb2YgYXZhaWxhYmxlIGJ1dHRvbnNcbiAgICogQHR5cGUge09iamVjdDxzdHJpbmcsIEFycmF5PENsYXNzPFBTVi5idXR0b25zLkFic3RyYWN0QnV0dG9uPj4+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB2YXIgQVZBSUxBQkxFX0dST1VQUyA9IHt9O1xuICAvKipcbiAgICogQHN1bW1hcnkgUmVnaXN0ZXIgYSBuZXcgYnV0dG9uIGF2YWlsYWJsZSBmb3IgYWxsIHZpZXdlcnNcbiAgICogQHBhcmFtIHtDbGFzczxQU1YuYnV0dG9ucy5BYnN0cmFjdEJ1dHRvbj59IGJ1dHRvblxuICAgKiBAcGFyYW0geydzdGFydCcgfCAnZW5kJyB8ICdbaWRdOmxlZnQnIHwgJ1tpZF06cmlnaHQnfSBbZGVmYXVsdFBvc2l0aW9uXVxuICAgKiAgICBJZiBwcm92aWRlZCB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIG9mIHRoZSBuYXZiYXIgd2lsbCBiZSBtb2RpZmllZC5cbiAgICogQG1lbWJlck9mIFBTVlxuICAgKi9cblxuICBmdW5jdGlvbiByZWdpc3RlckJ1dHRvbihidXR0b24sIGRlZmF1bHRQb3NpdGlvbikge1xuICAgIGlmICghYnV0dG9uLmlkKSB7XG4gICAgICB0aHJvdyBuZXcgUFNWRXJyb3IoJ0J1dHRvbiBJRCBpcyByZXF1aXJlZCcpO1xuICAgIH1cblxuICAgIEFWQUlMQUJMRV9CVVRUT05TW2J1dHRvbi5pZF0gPSBidXR0b247XG5cbiAgICBpZiAoYnV0dG9uLmdyb3VwSWQpIHtcbiAgICAgIEFWQUlMQUJMRV9HUk9VUFNbYnV0dG9uLmdyb3VwSWRdID0gQVZBSUxBQkxFX0dST1VQU1tidXR0b24uZ3JvdXBJZF0gfHwgW107XG4gICAgICBBVkFJTEFCTEVfR1JPVVBTW2J1dHRvbi5ncm91cElkXS5wdXNoKGJ1dHRvbik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkZWZhdWx0UG9zaXRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICBzd2l0Y2ggKGRlZmF1bHRQb3NpdGlvbikge1xuICAgICAgICBjYXNlICdzdGFydCc6XG4gICAgICAgICAgREVGQVVMVFMubmF2YmFyLnVuc2hpZnQoYnV0dG9uLmlkKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgIERFRkFVTFRTLm5hdmJhci5wdXNoKGJ1dHRvbi5pZCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB2YXIgX2RlZmF1bHRQb3NpdGlvbiRzcGxpID0gZGVmYXVsdFBvc2l0aW9uLnNwbGl0KCc6JyksXG4gICAgICAgICAgICAgIGlkID0gX2RlZmF1bHRQb3NpdGlvbiRzcGxpWzBdLFxuICAgICAgICAgICAgICBwb3MgPSBfZGVmYXVsdFBvc2l0aW9uJHNwbGlbMV07XG5cbiAgICAgICAgICBERUZBVUxUUy5uYXZiYXIuc3BsaWNlKERFRkFVTFRTLm5hdmJhci5pbmRleE9mKGlkKSArIChwb3MgPT09ICdyaWdodCcgPyAxIDogMCksIDAsIGJ1dHRvbi5pZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFtBdXRvcm90YXRlQnV0dG9uLCBab29tT3V0QnV0dG9uLCBab29tUmFuZ2VCdXR0b24sIFpvb21JbkJ1dHRvbiwgRGVzY3JpcHRpb25CdXR0b24sIERvd25sb2FkQnV0dG9uLCBGdWxsc2NyZWVuQnV0dG9uLCBNb3ZlTGVmdEJ1dHRvbiwgTW92ZVJpZ2h0QnV0dG9uLCBNb3ZlVXBCdXR0b24sIE1vdmVEb3duQnV0dG9uXS5mb3JFYWNoKHJlZ2lzdGVyQnV0dG9uKTtcbiAgLyoqXG4gICAqIEBzdW1tYXJ5IE5hdmlnYXRpb24gYmFyIGNvbXBvbmVudFxuICAgKiBAZXh0ZW5kcyBQU1YuY29tcG9uZW50cy5BYnN0cmFjdENvbXBvbmVudFxuICAgKiBAbWVtYmVyb2YgUFNWLmNvbXBvbmVudHNcbiAgICovXG5cbiAgdmFyIE5hdmJhciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Fic3RyYWN0Q29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzTG9vc2UoTmF2YmFyLCBfQWJzdHJhY3RDb21wb25lbnQpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQU1YuVmlld2VyfSBwc3ZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBOYXZiYXIocHN2KSB7XG4gICAgICB2YXIgX3RoaXM7XG5cbiAgICAgIF90aGlzID0gX0Fic3RyYWN0Q29tcG9uZW50LmNhbGwodGhpcywgcHN2LCAncHN2LW5hdmJhciBwc3YtLWNhcHR1cmUtZXZlbnQnKSB8fCB0aGlzO1xuICAgICAgLyoqXG4gICAgICAgKiBAc3VtbWFyeSBMaXN0IG9mIGJ1dHRvbnMgb2YgdGhlIG5hdmJhclxuICAgICAgICogQG1lbWJlciB7UFNWLmJ1dHRvbnMuQWJzdHJhY3RCdXR0b25bXX1cbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICovXG5cbiAgICAgIF90aGlzLmNoaWxkcmVuID0gW107XG4gICAgICAvKipcbiAgICAgICAqIEBzdW1tYXJ5IExpc3Qgb2YgY29sbGFwc2VkIGJ1dHRvbnNcbiAgICAgICAqIEBtZW1iZXIge1BTVi5idXR0b25zLkFic3RyYWN0QnV0dG9uW119XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICAgIF90aGlzLmNvbGxhcHNlZCA9IFtdO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBDaGFuZ2UgdGhlIGJ1dHRvbnMgdmlzaWJsZSBvbiB0aGUgbmF2YmFyXG4gICAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXk8c3RyaW5nfFBTVi5OYXZiYXJDdXN0b21CdXR0b24+fSBidXR0b25zXG4gICAgICogQHRocm93cyB7UFNWLlBTVkVycm9yfSB3aGVuIGEgYnV0dG9uIGlzIHVua25vd25cbiAgICAgKi9cblxuXG4gICAgdmFyIF9wcm90byA9IE5hdmJhci5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uc2V0QnV0dG9ucyA9IGZ1bmN0aW9uIHNldEJ1dHRvbnMoYnV0dG9ucykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMuY2hpbGRyZW4uc2xpY2UoKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLmRlc3Ryb3koKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jaGlsZHJlbi5sZW5ndGggPSAwO1xuXG4gICAgICB2YXIgY2xlYW5lZEJ1dHRvbnMgPSB0aGlzLl9fY2xlYW5CdXR0b25zKGJ1dHRvbnMpOyAvLyBmb3JjZSBkZXNjcmlwdGlvbiBidXR0b24gaWYgY2FwdGlvbiBpcyBwcmVzZW50ICh1c2VkIG9uIG5hcnJvdyBzY3JlZW5zKVxuXG5cbiAgICAgIGlmIChjbGVhbmVkQnV0dG9ucy5pbmRleE9mKE5hdmJhckNhcHRpb24uaWQpICE9PSAtMSAmJiBjbGVhbmVkQnV0dG9ucy5pbmRleE9mKERlc2NyaXB0aW9uQnV0dG9uLmlkKSA9PT0gLTEpIHtcbiAgICAgICAgY2xlYW5lZEJ1dHRvbnMuc3BsaWNlKGNsZWFuZWRCdXR0b25zLmluZGV4T2YoTmF2YmFyQ2FwdGlvbi5pZCksIDAsIERlc2NyaXB0aW9uQnV0dG9uLmlkKTtcbiAgICAgIH1cbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLW5ldyAqL1xuXG5cbiAgICAgIGNsZWFuZWRCdXR0b25zLmZvckVhY2goZnVuY3Rpb24gKGJ1dHRvbikge1xuICAgICAgICBpZiAodHlwZW9mIGJ1dHRvbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBuZXcgQ3VzdG9tQnV0dG9uKF90aGlzMiwgYnV0dG9uKTtcbiAgICAgICAgfSBlbHNlIGlmIChBVkFJTEFCTEVfQlVUVE9OU1tidXR0b25dKSB7XG4gICAgICAgICAgbmV3IEFWQUlMQUJMRV9CVVRUT05TW2J1dHRvbl0oX3RoaXMyKTtcbiAgICAgICAgfSBlbHNlIGlmIChBVkFJTEFCTEVfR1JPVVBTW2J1dHRvbl0pIHtcbiAgICAgICAgICBBVkFJTEFCTEVfR1JPVVBTW2J1dHRvbl0uZm9yRWFjaChmdW5jdGlvbiAoYnV0dG9uQ3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBidXR0b25DdG9yKF90aGlzMik7XG4gICAgICAgICAgfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxuICAgICAgICB9IGVsc2UgaWYgKGJ1dHRvbiA9PT0gTmF2YmFyQ2FwdGlvbi5pZCkge1xuICAgICAgICAgIG5ldyBOYXZiYXJDYXB0aW9uKF90aGlzMiwgX3RoaXMyLnBzdi5jb25maWcuY2FwdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBTVkVycm9yKCdVbmtub3duIGJ1dHRvbiAnICsgYnV0dG9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBuZXcgTWVudUJ1dHRvbih0aGlzKTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tbmV3ICovXG5cbiAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAodHlwZW9mIGl0ZW0uY2hlY2tTdXBwb3J0ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBpdGVtLmNoZWNrU3VwcG9ydGVkKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBTZXRzIHRoZSBiYXIgY2FwdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLnNldENhcHRpb24gPSBmdW5jdGlvbiBzZXRDYXB0aW9uKGh0bWwpIHtcbiAgICAgIHZhciBjYXB0aW9uID0gdGhpcy5nZXRCdXR0b24oTmF2YmFyQ2FwdGlvbi5pZCwgZmFsc2UpO1xuICAgICAgY2FwdGlvbiA9PSBudWxsID8gdm9pZCAwIDogY2FwdGlvbi5zZXRDYXB0aW9uKGh0bWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBSZXR1cm5zIGEgYnV0dG9uIGJ5IGl0cyBpZGVudGlmaWVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbd2Fybk5vdEZvdW5kPXRydWVdXG4gICAgICogQHJldHVybnMge1BTVi5idXR0b25zLkFic3RyYWN0QnV0dG9ufVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5nZXRCdXR0b24gPSBmdW5jdGlvbiBnZXRCdXR0b24oaWQsIHdhcm5Ob3RGb3VuZCkge1xuICAgICAgaWYgKHdhcm5Ob3RGb3VuZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHdhcm5Ob3RGb3VuZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBidXR0b24gPSBudWxsO1xuICAgICAgdGhpcy5jaGlsZHJlbi5zb21lKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtLnByb3AuaWQgPT09IGlkKSB7XG4gICAgICAgICAgYnV0dG9uID0gaXRlbTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWJ1dHRvbiAmJiB3YXJuTm90Rm91bmQpIHtcbiAgICAgICAgbG9nV2FybihcImJ1dHRvbiBcXFwiXCIgKyBpZCArIFwiXFxcIiBub3QgZm91bmQgaW4gdGhlIG5hdmJhclwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJ1dHRvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgU2hvd3MgdGhlIG5hdmJhclxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5zaG93ID0gZnVuY3Rpb24gc2hvdygpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3Bzdi1uYXZiYXItLW9wZW4nKTtcbiAgICAgIHRoaXMucHJvcC52aXNpYmxlID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgSGlkZXMgdGhlIG5hdmJhclxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5oaWRlID0gZnVuY3Rpb24gaGlkZSgpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoJ3Bzdi1uYXZiYXItLW9wZW4nKTtcbiAgICAgIHRoaXMucHJvcC52aXNpYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5yZWZyZXNoVWkgPSBmdW5jdGlvbiByZWZyZXNoVWkoKSB7XG4gICAgICBfQWJzdHJhY3RDb21wb25lbnQucHJvdG90eXBlLnJlZnJlc2hVaS5jYWxsKHRoaXMpO1xuXG4gICAgICBpZiAodGhpcy5wc3YucHJvcC51aVJlZnJlc2ggPT09IHRydWUpIHtcbiAgICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0gdGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGg7XG4gICAgICAgIHZhciB0b3RhbFdpZHRoID0gMDtcbiAgICAgICAgdmFyIHZpc2libGVCdXR0b25zID0gW107XG4gICAgICAgIHZhciBjb2xsYXBzYWJsZUJ1dHRvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgaWYgKGl0ZW0ucHJvcC52aXNpYmxlKSB7XG4gICAgICAgICAgICB0b3RhbFdpZHRoICs9IGl0ZW0ucHJvcC53aWR0aDtcbiAgICAgICAgICAgIHZpc2libGVCdXR0b25zLnB1c2goaXRlbSk7XG5cbiAgICAgICAgICAgIGlmIChpdGVtLnByb3AuY29sbGFwc2FibGUpIHtcbiAgICAgICAgICAgICAgY29sbGFwc2FibGVCdXR0b25zLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXZpc2libGVCdXR0b25zLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhdmFpbGFibGVXaWR0aCA8IHRvdGFsV2lkdGggJiYgY29sbGFwc2FibGVCdXR0b25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb2xsYXBzYWJsZUJ1dHRvbnMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uY29sbGFwc2UoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmNvbGxhcHNlZCA9IGNvbGxhcHNhYmxlQnV0dG9ucztcbiAgICAgICAgICB0aGlzLmdldEJ1dHRvbihNZW51QnV0dG9uLmlkKS5zaG93KGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChhdmFpbGFibGVXaWR0aCA+PSB0b3RhbFdpZHRoICYmIHRoaXMuY29sbGFwc2VkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aGlzLmNvbGxhcHNlZC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS51bmNvbGxhcHNlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5jb2xsYXBzZWQgPSBbXTtcbiAgICAgICAgICB0aGlzLmdldEJ1dHRvbihNZW51QnV0dG9uLmlkKS5oaWRlKGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjYXB0aW9uID0gdGhpcy5nZXRCdXR0b24oTmF2YmFyQ2FwdGlvbi5pZCwgZmFsc2UpO1xuXG4gICAgICAgIGlmIChjYXB0aW9uKSB7XG4gICAgICAgICAgY2FwdGlvbi5yZWZyZXNoVWkoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBFbnN1cmUgdGhlIGJ1dHRvbnMgY29uZmlndXJhdGlvbiBpcyBjb3JyZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uX19jbGVhbkJ1dHRvbnMgPSBmdW5jdGlvbiBfX2NsZWFuQnV0dG9ucyhidXR0b25zKSB7XG4gICAgICAvLyB0cnVlIGJlY29tZXMgdGhlIGRlZmF1bHQgYXJyYXlcbiAgICAgIGlmIChidXR0b25zID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBjbG9uZShERUZBVUxUUy5uYXZiYXIpO1xuICAgICAgfSAvLyBjYW4gYmUgYSBzcGFjZSBvciBjb21hIHNlcGFyYXRlZCBsaXN0XG4gICAgICBlbHNlIGlmICh0eXBlb2YgYnV0dG9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGJ1dHRvbnMuc3BsaXQoL1sgLF0vKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBidXR0b25zIHx8IFtdO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gTmF2YmFyO1xuICB9KEFic3RyYWN0Q29tcG9uZW50KTtcblxuICAvKipcbiAgICogQHN1bW1hcnkgTG9hZGVyIGNvbXBvbmVudFxuICAgKiBAZXh0ZW5kcyBQU1YuY29tcG9uZW50cy5BYnN0cmFjdENvbXBvbmVudFxuICAgKiBAbWVtYmVyb2YgUFNWLmNvbXBvbmVudHNcbiAgICovXG5cbiAgdmFyIExvYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Fic3RyYWN0Q29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzTG9vc2UoTG9hZGVyLCBfQWJzdHJhY3RDb21wb25lbnQpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQU1YuVmlld2VyfSBwc3ZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMb2FkZXIocHN2KSB7XG4gICAgICB2YXIgX3RoaXM7XG5cbiAgICAgIF90aGlzID0gX0Fic3RyYWN0Q29tcG9uZW50LmNhbGwodGhpcywgcHN2LCAncHN2LWxvYWRlci1jb250YWluZXInKSB8fCB0aGlzO1xuICAgICAgLyoqXG4gICAgICAgKiBAc3VtbWFyeSBJbm5lciBjb250YWluZXIgZm9yIHZlcnRpY2FsIGNlbnRlclxuICAgICAgICogQG1lbWJlciB7SFRNTEVsZW1lbnR9XG4gICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgICAgX3RoaXMubG9hZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBfdGhpcy5sb2FkZXIuY2xhc3NOYW1lID0gJ3Bzdi1sb2FkZXInO1xuXG4gICAgICBfdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoX3RoaXMubG9hZGVyKTtcbiAgICAgIC8qKlxuICAgICAgICogQHN1bW1hcnkgQW5pbWF0aW9uIGNhbnZhc1xuICAgICAgICogQG1lbWJlciB7SFRNTENhbnZhc0VsZW1lbnR9XG4gICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuXG4gICAgICBfdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgIF90aGlzLmNhbnZhcy5jbGFzc05hbWUgPSAncHN2LWxvYWRlci1jYW52YXMnO1xuICAgICAgX3RoaXMuY2FudmFzLndpZHRoID0gX3RoaXMubG9hZGVyLmNsaWVudFdpZHRoICogU1lTVEVNLnBpeGVsUmF0aW87XG4gICAgICBfdGhpcy5jYW52YXMuaGVpZ2h0ID0gX3RoaXMubG9hZGVyLmNsaWVudFdpZHRoICogU1lTVEVNLnBpeGVsUmF0aW87XG5cbiAgICAgIF90aGlzLmxvYWRlci5hcHBlbmRDaGlsZChfdGhpcy5jYW52YXMpO1xuICAgICAgLyoqXG4gICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aGlja25lc3NcbiAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjdXJyZW50XG4gICAgICAgKi9cblxuXG4gICAgICBfdGhpcy5wcm9wID0gX2V4dGVuZHMoe30sIF90aGlzLnByb3AsIHtcbiAgICAgICAgdGlja25lc3M6IChfdGhpcy5sb2FkZXIub2Zmc2V0V2lkdGggLSBfdGhpcy5sb2FkZXIuY2xpZW50V2lkdGgpIC8gMiAqIFNZU1RFTS5waXhlbFJhdGlvLFxuICAgICAgICBjdXJyZW50OiBudWxsXG4gICAgICB9KTtcblxuICAgICAgX3RoaXMucmVmcmVzaFVpKCk7XG5cbiAgICAgIF90aGlzLmhpZGUoKTtcblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cblxuXG4gICAgdmFyIF9wcm90byA9IExvYWRlci5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICBkZWxldGUgdGhpcy5sb2FkZXI7XG4gICAgICBkZWxldGUgdGhpcy5jYW52YXM7XG5cbiAgICAgIF9BYnN0cmFjdENvbXBvbmVudC5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8ucmVmcmVzaFVpID0gZnVuY3Rpb24gcmVmcmVzaFVpKCkge1xuICAgICAgaWYgKHRoaXMucHJvcC5jdXJyZW50ICE9PSAodGhpcy5wc3YuY29uZmlnLmxvYWRpbmdJbWcgfHwgdGhpcy5wc3YuY29uZmlnLmxvYWRpbmdUeHQpKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3AuY3VycmVudCkge1xuICAgICAgICAgIHRoaXMubG9hZGVyLnJlbW92ZUNoaWxkKHRoaXMubG9hZGVyLmxhc3RDaGlsZCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5uZXI7XG5cbiAgICAgICAgaWYgKHRoaXMucHN2LmNvbmZpZy5sb2FkaW5nSW1nKSB7XG4gICAgICAgICAgaW5uZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgICBpbm5lci5jbGFzc05hbWUgPSAncHN2LWxvYWRlci1pbWFnZSc7XG4gICAgICAgICAgaW5uZXIuc3JjID0gdGhpcy5wc3YuY29uZmlnLmxvYWRpbmdJbWc7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5wc3YuY29uZmlnLmxvYWRpbmdUeHQpIHtcbiAgICAgICAgICBpbm5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgIGlubmVyLmNsYXNzTmFtZSA9ICdwc3YtbG9hZGVyLXRleHQnO1xuICAgICAgICAgIGlubmVyLmlubmVySFRNTCA9IHRoaXMucHN2LmNvbmZpZy5sb2FkaW5nVHh0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlubmVyKSB7XG4gICAgICAgICAgdmFyIHNpemUgPSBNYXRoLnJvdW5kKE1hdGguc3FydCgyICogTWF0aC5wb3coKHRoaXMuY2FudmFzLndpZHRoIC8gMiAtIHRoaXMucHJvcC50aWNrbmVzcyAvIDIpIC8gU1lTVEVNLnBpeGVsUmF0aW8sIDIpKSk7XG4gICAgICAgICAgaW5uZXIuc3R5bGUubWF4V2lkdGggPSBzaXplICsgJ3B4JztcbiAgICAgICAgICBpbm5lci5zdHlsZS5tYXhIZWlnaHQgPSBzaXplICsgJ3B4JztcbiAgICAgICAgICB0aGlzLmxvYWRlci5hcHBlbmRDaGlsZChpbm5lcik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByb3AuY3VycmVudCA9IHRoaXMucHN2LmNvbmZpZy5sb2FkaW5nSW1nIHx8IHRoaXMucHN2LmNvbmZpZy5sb2FkaW5nVHh0O1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBTZXRzIHRoZSBsb2FkZXIgcHJvZ3Jlc3Npb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBmcm9tIDAgdG8gMTAwXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLnNldFByb2dyZXNzID0gZnVuY3Rpb24gc2V0UHJvZ3Jlc3ModmFsdWUpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpO1xuICAgICAgY29udGV4dC5saW5lV2lkdGggPSB0aGlzLnByb3AudGlja25lc3M7XG4gICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gZ2V0U3R5bGUodGhpcy5sb2FkZXIsICdjb2xvcicpO1xuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGNvbnRleHQuYXJjKHRoaXMuY2FudmFzLndpZHRoIC8gMiwgdGhpcy5jYW52YXMuaGVpZ2h0IC8gMiwgdGhpcy5jYW52YXMud2lkdGggLyAyIC0gdGhpcy5wcm9wLnRpY2tuZXNzIC8gMiwgLU1hdGguUEkgLyAyLCB0aHJlZS5NYXRoVXRpbHMuY2xhbXAodmFsdWUsIDAsIDEwMCkgLyAxMDAgKiAyICogTWF0aC5QSSAtIE1hdGguUEkgLyAyKTtcbiAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICB0aGlzLnBzdi50cmlnZ2VyKEVWRU5UUy5MT0FEX1BST0dSRVNTLCBNYXRoLnJvdW5kKHZhbHVlKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBMb2FkZXI7XG4gIH0oQWJzdHJhY3RDb21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBAc3VtbWFyeSBOb3RpZmljYXRpb24gY29tcG9uZW50XG4gICAqIEBleHRlbmRzIFBTVi5jb21wb25lbnRzLkFic3RyYWN0Q29tcG9uZW50XG4gICAqIEBtZW1iZXJvZiBQU1YuY29tcG9uZW50c1xuICAgKi9cblxuICB2YXIgTm90aWZpY2F0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQWJzdHJhY3RDb21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHNMb29zZShOb3RpZmljYXRpb24sIF9BYnN0cmFjdENvbXBvbmVudCk7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1BTVi5WaWV3ZXJ9IHBzdlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE5vdGlmaWNhdGlvbihwc3YpIHtcbiAgICAgIHZhciBfdGhpcztcblxuICAgICAgX3RoaXMgPSBfQWJzdHJhY3RDb21wb25lbnQuY2FsbCh0aGlzLCBwc3YsICdwc3Ytbm90aWZpY2F0aW9uJykgfHwgdGhpcztcbiAgICAgIC8qKlxuICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgKiBAcHJvcGVydHkgeyp9IHRpbWVvdXRcbiAgICAgICAqL1xuXG4gICAgICBfdGhpcy5wcm9wID0gX2V4dGVuZHMoe30sIF90aGlzLnByb3AsIHtcbiAgICAgICAgdmlzaWJsZTogZmFsc2UsXG4gICAgICAgIGNvbnRlbnRJZDogdW5kZWZpbmVkLFxuICAgICAgICB0aW1lb3V0OiBudWxsXG4gICAgICB9KTtcbiAgICAgIC8qKlxuICAgICAgICogTm90aWZpY2F0aW9uIGNvbnRlbnRcbiAgICAgICAqIEBtZW1iZXIge0hUTUxFbGVtZW50fVxuICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICAgIF90aGlzLmNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIF90aGlzLmNvbnRlbnQuY2xhc3NOYW1lID0gJ3Bzdi1ub3RpZmljYXRpb24tY29udGVudCc7XG5cbiAgICAgIF90aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChfdGhpcy5jb250ZW50KTtcblxuICAgICAgX3RoaXMuY29udGVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmhpZGUoKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuXG5cbiAgICB2YXIgX3Byb3RvID0gTm90aWZpY2F0aW9uLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmNvbnRlbnQ7XG5cbiAgICAgIF9BYnN0cmFjdENvbXBvbmVudC5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2lkXVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5pc1Zpc2libGUgPSBmdW5jdGlvbiBpc1Zpc2libGUoaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3AudmlzaWJsZSAmJiAoIWlkIHx8ICF0aGlzLnByb3AuY29udGVudElkIHx8IHRoaXMucHJvcC5jb250ZW50SWQgPT09IGlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHN1bW1hcnkgVGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZFxuICAgICAqIEB0aHJvd3Mge1BTVi5QU1ZFcnJvcn0gYWx3YXlzXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLnRvZ2dsZSA9IGZ1bmN0aW9uIHRvZ2dsZSgpIHtcbiAgICAgIHRocm93IG5ldyBQU1ZFcnJvcignTm90aWZpY2F0aW9uIGNhbm5vdCBiZSB0b2dnbGVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IERpc3BsYXlzIGEgbm90aWZpY2F0aW9uIG9uIHRoZSB2aWV3ZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLmlkXSAtIHVuaXF1ZSBpZGVudGlmaWVyIHRvIHVzZSB3aXRoIFwiaGlkZVwiXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbmZpZy5jb250ZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtjb25maWcudGltZW91dF1cbiAgICAgKiBAZmlyZXMgUFNWLnNob3ctbm90aWZpY2F0aW9uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZpZXdlci5zaG93Tm90aWZpY2F0aW9uKHsgY29udGVudDogJ0hlbGxvIHdvcmxkJywgdGltZW91dDogNTAwMCB9KVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmlld2VyLnNob3dOb3RpZmljYXRpb24oJ0hlbGxvIHdvcmxkJylcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uc2hvdyA9IGZ1bmN0aW9uIHNob3coY29uZmlnKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMucHJvcC50aW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnByb3AudGltZW91dCk7XG4gICAgICAgIHRoaXMucHJvcC50aW1lb3V0ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbmZpZyA9IHtcbiAgICAgICAgICBjb250ZW50OiBjb25maWdcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcm9wLmNvbnRlbnRJZCA9IGNvbmZpZy5pZDtcbiAgICAgIHRoaXMuY29udGVudC5pbm5lckhUTUwgPSBjb25maWcuY29udGVudDtcbiAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3Bzdi1ub3RpZmljYXRpb24tLXZpc2libGUnKTtcbiAgICAgIHRoaXMucHJvcC52aXNpYmxlID0gdHJ1ZTtcbiAgICAgIHRoaXMucHN2LnRyaWdnZXIoRVZFTlRTLlNIT1dfTk9USUZJQ0FUSU9OLCBjb25maWcuaWQpO1xuXG4gICAgICBpZiAoY29uZmlnLnRpbWVvdXQpIHtcbiAgICAgICAgdGhpcy5wcm9wLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLmhpZGUoY29uZmlnLmlkKTtcbiAgICAgICAgfSwgY29uZmlnLnRpbWVvdXQpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBIaWRlcyB0aGUgbm90aWZpY2F0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtpZF1cbiAgICAgKiBAZmlyZXMgUFNWLmhpZGUtbm90aWZpY2F0aW9uXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLmhpZGUgPSBmdW5jdGlvbiBoaWRlKGlkKSB7XG4gICAgICBpZiAodGhpcy5pc1Zpc2libGUoaWQpKSB7XG4gICAgICAgIHZhciBjb250ZW50SWQgPSB0aGlzLnByb3AuY29udGVudElkO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKCdwc3Ytbm90aWZpY2F0aW9uLS12aXNpYmxlJyk7XG4gICAgICAgIHRoaXMucHJvcC52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHJvcC5jb250ZW50SWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucHN2LnRyaWdnZXIoRVZFTlRTLkhJREVfTk9USUZJQ0FUSU9OLCBjb250ZW50SWQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gTm90aWZpY2F0aW9uO1xuICB9KEFic3RyYWN0Q29tcG9uZW50KTtcblxuICAvKipcbiAgICogQHN1bW1hcnkgT3ZlcmxheSBjb21wb25lbnRcbiAgICogQGV4dGVuZHMgUFNWLmNvbXBvbmVudHMuQWJzdHJhY3RDb21wb25lbnRcbiAgICogQG1lbWJlcm9mIFBTVi5jb21wb25lbnRzXG4gICAqL1xuXG4gIHZhciBPdmVybGF5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQWJzdHJhY3RDb21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHNMb29zZShPdmVybGF5LCBfQWJzdHJhY3RDb21wb25lbnQpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQU1YuVmlld2VyfSBwc3ZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBPdmVybGF5KHBzdikge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBfdGhpcyA9IF9BYnN0cmFjdENvbXBvbmVudC5jYWxsKHRoaXMsIHBzdiwgJ3Bzdi1vdmVybGF5JykgfHwgdGhpcztcbiAgICAgIC8qKlxuICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gY29udGVudElkXG4gICAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGRpc3NtaXNhYmxlXG4gICAgICAgKi9cblxuICAgICAgX3RoaXMucHJvcCA9IF9leHRlbmRzKHt9LCBfdGhpcy5wcm9wLCB7XG4gICAgICAgIGNvbnRlbnRJZDogdW5kZWZpbmVkLFxuICAgICAgICBkaXNzbWlzYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICAvKipcbiAgICAgICAqIEltYWdlIGNvbnRhaW5lclxuICAgICAgICogQG1lbWJlciB7SFRNTEVsZW1lbnR9XG4gICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgICAgX3RoaXMuaW1hZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIF90aGlzLmltYWdlLmNsYXNzTmFtZSA9ICdwc3Ytb3ZlcmxheS1pbWFnZSc7XG5cbiAgICAgIF90aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChfdGhpcy5pbWFnZSk7XG4gICAgICAvKipcbiAgICAgICAqIFRleHQgY29udGFpbmVyXG4gICAgICAgKiBAbWVtYmVyIHtIVE1MRWxlbWVudH1cbiAgICAgICAqIEByZWFkb25seVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG5cbiAgICAgIF90aGlzLnRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIF90aGlzLnRleHQuY2xhc3NOYW1lID0gJ3Bzdi1vdmVybGF5LXRleHQnO1xuXG4gICAgICBfdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoX3RoaXMudGV4dCk7XG4gICAgICAvKipcbiAgICAgICAqIFN1YnRleHQgY29udGFpbmVyXG4gICAgICAgKiBAbWVtYmVyIHtIVE1MRWxlbWVudH1cbiAgICAgICAqIEByZWFkb25seVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG5cbiAgICAgIF90aGlzLnN1YnRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIF90aGlzLnN1YnRleHQuY2xhc3NOYW1lID0gJ3Bzdi1vdmVybGF5LXN1YnRleHQnO1xuXG4gICAgICBfdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoX3RoaXMuc3VidGV4dCk7XG5cbiAgICAgIF90aGlzLnBzdi5vbihFVkVOVFMuQ0xJQ0ssIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgICAgX3RoaXMucHN2Lm9uKEVWRU5UUy5LRVlfUFJFU1MsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgICAgX0Fic3RyYWN0Q29tcG9uZW50LnByb3RvdHlwZS5oaWRlLmNhbGwoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuXG5cbiAgICB2YXIgX3Byb3RvID0gT3ZlcmxheS5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLnBzdi5vZmYoRVZFTlRTLkNMSUNLLCB0aGlzKTtcbiAgICAgIHRoaXMucHN2Lm9mZihFVkVOVFMuS0VZX1BSRVNTLCB0aGlzKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmltYWdlO1xuICAgICAgZGVsZXRlIHRoaXMudGV4dDtcbiAgICAgIGRlbGV0ZSB0aGlzLnN1YnRleHQ7XG5cbiAgICAgIF9BYnN0cmFjdENvbXBvbmVudC5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBIYW5kbGVzIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uIGhhbmRsZUV2ZW50KGUpIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlICovXG4gICAgICBzd2l0Y2ggKGUudHlwZSkge1xuICAgICAgICBjYXNlIEVWRU5UUy5DTElDSzpcbiAgICAgICAgICBpZiAodGhpcy5pc1Zpc2libGUoKSAmJiB0aGlzLnByb3AuZGlzc21pc2FibGUpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEVWRU5UUy5LRVlfUFJFU1M6XG4gICAgICAgICAgaWYgKHRoaXMuaXNWaXNpYmxlKCkgJiYgdGhpcy5wcm9wLmRpc3NtaXNhYmxlICYmIGUuYXJnc1swXSA9PT0gS0VZX0NPREVTLkVzY2FwZSkge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlICovXG5cbiAgICB9XG4gICAgLyoqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtpZF1cbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uaXNWaXNpYmxlID0gZnVuY3Rpb24gaXNWaXNpYmxlKGlkKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wLnZpc2libGUgJiYgKCFpZCB8fCAhdGhpcy5wcm9wLmNvbnRlbnRJZCB8fCB0aGlzLnByb3AuY29udGVudElkID09PSBpZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBzdW1tYXJ5IFRoaXMgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWRcbiAgICAgKiBAdGhyb3dzIHtQU1YuUFNWRXJyb3J9IGFsd2F5c1xuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by50b2dnbGUgPSBmdW5jdGlvbiB0b2dnbGUoKSB7XG4gICAgICB0aHJvdyBuZXcgUFNWRXJyb3IoJ092ZXJsYXkgY2Fubm90IGJlIHRvZ2dsZWQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgRGlzcGxheXMgYW4gb3ZlcmxheSBvbiB0aGUgdmlld2VyXG4gICAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBjb25maWdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmZpZy5pZF0gLSB1bmlxdWUgaWRlbnRpZmllciB0byB1c2Ugd2l0aCBcImhpZGVcIlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb25maWcuaW1hZ2UgLSBTVkcgaW1hZ2UvaWNvbiBkaXNwbGF5ZWQgYWJvdmUgdGhlIHRleHRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29uZmlnLnRleHQgLSBtYWluIG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmZpZy5zdWJ0ZXh0XSAtIHNlY29uZGFyeSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbY29uZmlnLmRpc3NtaXNhYmxlPXRydWVdIC0gaWYgdGhlIHVzZXIgY2FuIGhpZGUgdGhlIG92ZXJsYXkgYnkgY2xpY2tpbmdcbiAgICAgKiBAZmlyZXMgUFNWLnNob3ctb3ZlcmxheVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5zaG93ID0gZnVuY3Rpb24gc2hvdyhjb25maWcpIHtcbiAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25maWcgPSB7XG4gICAgICAgICAgdGV4dDogY29uZmlnXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHJvcC5jb250ZW50SWQgPSBjb25maWcuaWQ7XG4gICAgICB0aGlzLnByb3AuZGlzc21pc2FibGUgPSBjb25maWcuZGlzc21pc2FibGUgIT09IGZhbHNlO1xuICAgICAgdGhpcy5pbWFnZS5pbm5lckhUTUwgPSBjb25maWcuaW1hZ2UgfHwgJyc7XG4gICAgICB0aGlzLnRleHQuaW5uZXJIVE1MID0gY29uZmlnLnRleHQgfHwgJyc7XG4gICAgICB0aGlzLnN1YnRleHQuaW5uZXJIVE1MID0gY29uZmlnLnN1YnRleHQgfHwgJyc7XG5cbiAgICAgIF9BYnN0cmFjdENvbXBvbmVudC5wcm90b3R5cGUuc2hvdy5jYWxsKHRoaXMpO1xuXG4gICAgICB0aGlzLnBzdi50cmlnZ2VyKEVWRU5UUy5TSE9XX09WRVJMQVksIGNvbmZpZy5pZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEhpZGVzIHRoZSBvdmVybGF5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtpZF1cbiAgICAgKiBAZmlyZXMgUFNWLmhpZGUtb3ZlcmxheVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5oaWRlID0gZnVuY3Rpb24gaGlkZShpZCkge1xuICAgICAgaWYgKHRoaXMuaXNWaXNpYmxlKGlkKSkge1xuICAgICAgICB2YXIgY29udGVudElkID0gdGhpcy5wcm9wLmNvbnRlbnRJZDtcblxuICAgICAgICBfQWJzdHJhY3RDb21wb25lbnQucHJvdG90eXBlLmhpZGUuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLnByb3AuY29udGVudElkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnBzdi50cmlnZ2VyKEVWRU5UUy5ISURFX09WRVJMQVksIGNvbnRlbnRJZCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBPdmVybGF5O1xuICB9KEFic3RyYWN0Q29tcG9uZW50KTtcblxuICAvKipcbiAgICogQHN1bW1hcnkgTWluaW11bSB3aWR0aCBvZiB0aGUgcGFuZWxcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGNvbnN0YW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHZhciBQQU5FTF9NSU5fV0lEVEggPSAyMDA7XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBQYW5lbCBjb21wb25lbnRcbiAgICogQGV4dGVuZHMgUFNWLmNvbXBvbmVudHMuQWJzdHJhY3RDb21wb25lbnRcbiAgICogQG1lbWJlcm9mIFBTVi5jb21wb25lbnRzXG4gICAqL1xuXG4gIHZhciBQYW5lbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Fic3RyYWN0Q29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzTG9vc2UoUGFuZWwsIF9BYnN0cmFjdENvbXBvbmVudCk7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1BTVi5WaWV3ZXJ9IHBzdlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFBhbmVsKHBzdikge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBfdGhpcyA9IF9BYnN0cmFjdENvbXBvbmVudC5jYWxsKHRoaXMsIHBzdiwgJ3Bzdi1wYW5lbCBwc3YtLWNhcHR1cmUtZXZlbnQnKSB8fCB0aGlzO1xuICAgICAgLyoqXG4gICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb250ZW50SWRcbiAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtb3VzZVhcbiAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtb3VzZVlcbiAgICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbW91c2Vkb3duXG4gICAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBjbGlja0hhbmRsZXJcbiAgICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IGtleUhhbmRsZXJcbiAgICAgICAqL1xuXG4gICAgICBfdGhpcy5wcm9wID0gX2V4dGVuZHMoe30sIF90aGlzLnByb3AsIHtcbiAgICAgICAgdmlzaWJsZTogZmFsc2UsXG4gICAgICAgIGNvbnRlbnRJZDogdW5kZWZpbmVkLFxuICAgICAgICBtb3VzZVg6IDAsXG4gICAgICAgIG1vdXNlWTogMCxcbiAgICAgICAgbW91c2Vkb3duOiBmYWxzZSxcbiAgICAgICAgY2xpY2tIYW5kbGVyOiBudWxsLFxuICAgICAgICBrZXlIYW5kbGVyOiBudWxsLFxuICAgICAgICB3aWR0aDoge31cbiAgICAgIH0pO1xuICAgICAgdmFyIHJlc2l6ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHJlc2l6ZXIuY2xhc3NOYW1lID0gJ3Bzdi1wYW5lbC1yZXNpemVyJztcblxuICAgICAgX3RoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHJlc2l6ZXIpO1xuXG4gICAgICB2YXIgY2xvc2VCdG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGNsb3NlQnRuLmNsYXNzTmFtZSA9ICdwc3YtcGFuZWwtY2xvc2UtYnV0dG9uJztcblxuICAgICAgX3RoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGNsb3NlQnRuKTtcbiAgICAgIC8qKlxuICAgICAgICogQHN1bW1hcnkgQ29udGVudCBjb250YWluZXJcbiAgICAgICAqIEBtZW1iZXIge0hUTUxFbGVtZW50fVxuICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cblxuICAgICAgX3RoaXMuY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgX3RoaXMuY29udGVudC5jbGFzc05hbWUgPSAncHN2LXBhbmVsLWNvbnRlbnQnO1xuXG4gICAgICBfdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoX3RoaXMuY29udGVudCk7IC8vIFN0b3Agd2hlZWwgZXZlbnQgYnViYmxpbmcgZnJvbSBwYW5lbFxuXG5cbiAgICAgIF90aGlzLmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFNZU1RFTS5tb3VzZVdoZWVsRXZlbnQsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfSk7XG5cbiAgICAgIGNsb3NlQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuaGlkZSgpO1xuICAgICAgfSk7IC8vIEV2ZW50IGZvciBwYW5lbCByZXNpemluZyArIHN0b3AgYnVibGluZ1xuXG4gICAgICByZXNpemVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICAgIHJlc2l6ZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgICAgX3RoaXMucHN2LmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgICBfdGhpcy5wc3YuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgICBfdGhpcy5wc3YuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgICAgX3RoaXMucHN2LmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICAgIF90aGlzLnBzdi5vbihFVkVOVFMuS0VZX1BSRVNTLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG5cblxuICAgIHZhciBfcHJvdG8gPSBQYW5lbC5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLnBzdi5vZmYoRVZFTlRTLktFWV9QUkVTUywgdGhpcyk7XG4gICAgICB0aGlzLnBzdi5jb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcyk7XG4gICAgICB0aGlzLnBzdi5jb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcyk7XG4gICAgICB0aGlzLnBzdi5jb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMpO1xuICAgICAgdGhpcy5wc3YuY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcyk7XG4gICAgICBkZWxldGUgdGhpcy5wcm9wO1xuICAgICAgZGVsZXRlIHRoaXMuY29udGVudDtcblxuICAgICAgX0Fic3RyYWN0Q29tcG9uZW50LnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEhhbmRsZXMgZXZlbnRzXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24gaGFuZGxlRXZlbnQoZSkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgKi9cbiAgICAgIHN3aXRjaCAoZS50eXBlKSB7XG4gICAgICAgIC8vIEBmb3JtYXR0ZXI6b2ZmXG4gICAgICAgIGNhc2UgJ21vdXNlZG93bic6XG4gICAgICAgICAgdGhpcy5fX29uTW91c2VEb3duKGUpO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndG91Y2hzdGFydCc6XG4gICAgICAgICAgdGhpcy5fX29uVG91Y2hTdGFydChlKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ21vdXNlbW92ZSc6XG4gICAgICAgICAgdGhpcy5fX29uTW91c2VNb3ZlKGUpO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndG91Y2htb3ZlJzpcbiAgICAgICAgICB0aGlzLl9fb25Ub3VjaE1vdmUoZSk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdtb3VzZXVwJzpcbiAgICAgICAgICB0aGlzLl9fb25Nb3VzZVVwKGUpO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndG91Y2hlbmQnOlxuICAgICAgICAgIHRoaXMuX19vbk1vdXNlVXAoZSk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEVWRU5UUy5LRVlfUFJFU1M6XG4gICAgICAgICAgaWYgKHRoaXMuaXNWaXNpYmxlKCkgJiYgZS5hcmdzWzBdID09PSBLRVlfQ09ERVMuRXNjYXBlKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gQGZvcm1hdHRlcjpvblxuICAgICAgfVxuICAgICAgLyogZXNsaW50LWVuYWJsZSAqL1xuXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbaWRdXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLmlzVmlzaWJsZSA9IGZ1bmN0aW9uIGlzVmlzaWJsZShpZCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvcC52aXNpYmxlICYmICghaWQgfHwgIXRoaXMucHJvcC5jb250ZW50SWQgfHwgdGhpcy5wcm9wLmNvbnRlbnRJZCA9PT0gaWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAc3VtbWFyeSBUaGlzIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkXG4gICAgICogQHRocm93cyB7UFNWLlBTVkVycm9yfSBhbHdheXNcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8udG9nZ2xlID0gZnVuY3Rpb24gdG9nZ2xlKCkge1xuICAgICAgdGhyb3cgbmV3IFBTVkVycm9yKCdQYW5lbCBjYW5ub3QgYmUgdG9nZ2xlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBTaG93cyB0aGUgcGFuZWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLmlkXSAtIHVuaXF1ZSBpZGVudGlmaWVyIHRvIHVzZSB3aXRoIFwiaGlkZVwiIGFuZCB0byBzdG9yZSB0aGUgdXNlciBkZXNpcmVkIHdpZHRoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbmZpZy5jb250ZW50IC0gSFRNTCBjb250ZW50IG9mIHRoZSBwYW5lbFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NvbmZpZy5ub01hcmdpbj1mYWxzZV0gLSByZW1vdmUgdGhlIGRlZmF1bHQgbWFyZ2luc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLndpZHRoXSAtIGluaXRpYWwgd2lkdGhcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmNsaWNrSGFuZGxlcl0gLSBjYWxsZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgaW5zaWRlIHRoZSBwYW5lbCBvciBwcmVzc2VzIHRoZSBFbnRlciBrZXkgd2hpbGUgYW4gZWxlbWVudCBmb2N1c2VkXG4gICAgICogQGZpcmVzIFBTVi5vcGVuLXBhbmVsXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLnNob3cgPSBmdW5jdGlvbiBzaG93KGNvbmZpZykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciB3YXNWaXNpYmxlID0gdGhpcy5pc1Zpc2libGUoY29uZmlnLmlkKTtcblxuICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbmZpZyA9IHtcbiAgICAgICAgICBjb250ZW50OiBjb25maWdcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcm9wLmNvbnRlbnRJZCA9IGNvbmZpZy5pZDtcbiAgICAgIHRoaXMucHJvcC52aXNpYmxlID0gdHJ1ZTtcblxuICAgICAgaWYgKHRoaXMucHJvcC5jbGlja0hhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5jb250ZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5wcm9wLmNsaWNrSGFuZGxlcik7XG4gICAgICAgIHRoaXMuY29udGVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5wcm9wLmtleUhhbmRsZXIpO1xuICAgICAgICB0aGlzLnByb3AuY2xpY2tIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcm9wLmtleUhhbmRsZXIgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29uZmlnLmlkICYmIHRoaXMucHJvcC53aWR0aFtjb25maWcuaWRdKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLndpZHRoID0gdGhpcy5wcm9wLndpZHRoW2NvbmZpZy5pZF07XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZy53aWR0aCkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS53aWR0aCA9IGNvbmZpZy53aWR0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLndpZHRoID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb250ZW50LmlubmVySFRNTCA9IGNvbmZpZy5jb250ZW50O1xuICAgICAgdGhpcy5jb250ZW50LnNjcm9sbFRvcCA9IDA7XG4gICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdwc3YtcGFuZWwtLW9wZW4nKTtcbiAgICAgIHRvZ2dsZUNsYXNzKHRoaXMuY29udGVudCwgJ3Bzdi1wYW5lbC1jb250ZW50LS1uby1tYXJnaW4nLCBjb25maWcubm9NYXJnaW4gPT09IHRydWUpO1xuXG4gICAgICBpZiAoY29uZmlnLmNsaWNrSGFuZGxlcikge1xuICAgICAgICB0aGlzLnByb3AuY2xpY2tIYW5kbGVyID0gY29uZmlnLmNsaWNrSGFuZGxlcjtcblxuICAgICAgICB0aGlzLnByb3Aua2V5SGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgaWYgKGUua2V5ID09PSBLRVlfQ09ERVMuRW50ZXIpIHtcbiAgICAgICAgICAgIGNvbmZpZy5jbGlja0hhbmRsZXIoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuY29udGVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMucHJvcC5jbGlja0hhbmRsZXIpO1xuICAgICAgICB0aGlzLmNvbnRlbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMucHJvcC5rZXlIYW5kbGVyKTsgLy8gZm9jdXMgdGhlIGZpcnN0IGVsZW1lbnQgaWYgcG9zc2libGUsIGFmdGVyIGFuaW1hdGlvbiBlbmRzXG5cbiAgICAgICAgaWYgKCF3YXNWaXNpYmxlKSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMyJGNvbnRlbnQkcXVlcnlTO1xuXG4gICAgICAgICAgICAoX3RoaXMyJGNvbnRlbnQkcXVlcnlTID0gX3RoaXMyLmNvbnRlbnQucXVlcnlTZWxlY3RvcignYSxidXR0b24sW3RhYmluZGV4XScpKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMyJGNvbnRlbnQkcXVlcnlTLmZvY3VzKCk7XG4gICAgICAgICAgfSwgMzAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnBzdi50cmlnZ2VyKEVWRU5UUy5PUEVOX1BBTkVMLCBjb25maWcuaWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBIaWRlcyB0aGUgcGFuZWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2lkXVxuICAgICAqIEBmaXJlcyBQU1YuY2xvc2UtcGFuZWxcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uaGlkZSA9IGZ1bmN0aW9uIGhpZGUoaWQpIHtcbiAgICAgIGlmICh0aGlzLmlzVmlzaWJsZShpZCkpIHtcbiAgICAgICAgdmFyIGNvbnRlbnRJZCA9IHRoaXMucHJvcC5jb250ZW50SWQ7XG4gICAgICAgIHRoaXMucHJvcC52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHJvcC5jb250ZW50SWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY29udGVudC5pbm5lckhUTUwgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKCdwc3YtcGFuZWwtLW9wZW4nKTtcblxuICAgICAgICBpZiAodGhpcy5wcm9wLmNsaWNrSGFuZGxlcikge1xuICAgICAgICAgIHRoaXMuY29udGVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMucHJvcC5jbGlja0hhbmRsZXIpO1xuICAgICAgICAgIHRoaXMucHJvcC5jbGlja0hhbmRsZXIgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wc3YudHJpZ2dlcihFVkVOVFMuQ0xPU0VfUEFORUwsIGNvbnRlbnRJZCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEhhbmRsZXMgbW91c2UgZG93biBldmVudHNcbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2dFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLl9fb25Nb3VzZURvd24gPSBmdW5jdGlvbiBfX29uTW91c2VEb3duKGV2dCkge1xuICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICB0aGlzLl9fc3RhcnRSZXNpemUoZXZ0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgSGFuZGxlcyB0b3VjaCBldmVudHNcbiAgICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGV2dFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLl9fb25Ub3VjaFN0YXJ0ID0gZnVuY3Rpb24gX19vblRvdWNoU3RhcnQoZXZ0KSB7XG4gICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgIHRoaXMuX19zdGFydFJlc2l6ZShldnQuY2hhbmdlZFRvdWNoZXNbMF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBIYW5kbGVzIG1vdXNlIHVwIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZ0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uX19vbk1vdXNlVXAgPSBmdW5jdGlvbiBfX29uTW91c2VVcChldnQpIHtcbiAgICAgIGlmICh0aGlzLnByb3AubW91c2Vkb3duKSB7XG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgdGhpcy5wcm9wLm1vdXNlZG93biA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbnRlbnQuY2xhc3NMaXN0LnJlbW92ZSgncHN2LXBhbmVsLWNvbnRlbnQtLW5vLWludGVyYWN0aW9uJyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEhhbmRsZXMgbW91c2UgbW92ZSBldmVudHNcbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2dFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLl9fb25Nb3VzZU1vdmUgPSBmdW5jdGlvbiBfX29uTW91c2VNb3ZlKGV2dCkge1xuICAgICAgaWYgKHRoaXMucHJvcC5tb3VzZWRvd24pIHtcbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgIHRoaXMuX19yZXNpemUoZXZ0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgSGFuZGxlcyB0b3VjaCBtb3ZlIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZXZ0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uX19vblRvdWNoTW92ZSA9IGZ1bmN0aW9uIF9fb25Ub3VjaE1vdmUoZXZ0KSB7XG4gICAgICBpZiAodGhpcy5wcm9wLm1vdXNlZG93bikge1xuICAgICAgICB0aGlzLl9fcmVzaXplKGV2dC50b3VjaGVzWzBdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgSW5pdGlhbGl6ZXMgdGhlIHBhbmVsIHJlc2l6ZVxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudHxUb3VjaH0gZXZ0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uX19zdGFydFJlc2l6ZSA9IGZ1bmN0aW9uIF9fc3RhcnRSZXNpemUoZXZ0KSB7XG4gICAgICB0aGlzLnByb3AubW91c2VYID0gZXZ0LmNsaWVudFg7XG4gICAgICB0aGlzLnByb3AubW91c2VZID0gZXZ0LmNsaWVudFk7XG4gICAgICB0aGlzLnByb3AubW91c2Vkb3duID0gdHJ1ZTtcbiAgICAgIHRoaXMuY29udGVudC5jbGFzc0xpc3QuYWRkKCdwc3YtcGFuZWwtY29udGVudC0tbm8taW50ZXJhY3Rpb24nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgUmVzaXplcyB0aGUgcGFuZWxcbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR8VG91Y2h9IGV2dFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLl9fcmVzaXplID0gZnVuY3Rpb24gX19yZXNpemUoZXZ0KSB7XG4gICAgICB2YXIgeCA9IGV2dC5jbGllbnRYO1xuICAgICAgdmFyIHkgPSBldnQuY2xpZW50WTtcbiAgICAgIHZhciB3aWR0aCA9IE1hdGgubWF4KFBBTkVMX01JTl9XSURUSCwgdGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGggLSAoeCAtIHRoaXMucHJvcC5tb3VzZVgpKSArICdweCc7XG5cbiAgICAgIGlmICh0aGlzLnByb3AuY29udGVudElkKSB7XG4gICAgICAgIHRoaXMucHJvcC53aWR0aFt0aGlzLnByb3AuY29udGVudElkXSA9IHdpZHRoO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgICAgdGhpcy5wcm9wLm1vdXNlWCA9IHg7XG4gICAgICB0aGlzLnByb3AubW91c2VZID0geTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFBhbmVsO1xuICB9KEFic3RyYWN0Q29tcG9uZW50KTtcblxuICB2YXIgZXJyb3JJY29uID0gXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgdmlld0JveD1cXFwiMTUgMTUgNzAgNzBcXFwiPjxwYXRoIGZpbGw9XFxcImN1cnJlbnRDb2xvclxcXCIgZD1cXFwiTTUwLDE2LjJjLTE4LjYsMC0zMy44LDE1LjEtMzMuOCwzMy44UzMxLjQsODMuNyw1MCw4My43UzgzLjgsNjguNiw4My44LDUwUzY4LjYsMTYuMiw1MCwxNi4yeiBNNTAsODAuMmMtMTYuNywwLTMwLjItMTMuNi0zMC4yLTMwLjJTMzMuMywxOS43LDUwLDE5LjdTODAuMywzMy4zLDgwLjMsNTBTNjYuNyw4MC4yLDUwLDgwLjJ6XFxcIi8+PHJlY3QgZmlsbD1cXFwiY3VycmVudENvbG9yXFxcIiB4PVxcXCI0OFxcXCIgeT1cXFwiMzEuN1xcXCIgd2lkdGg9XFxcIjRcXFwiIGhlaWdodD1cXFwiMjhcXFwiLz48cmVjdCBmaWxsPVxcXCJjdXJyZW50Q29sb3JcXFwiIHg9XFxcIjQ4XFxcIiB5PVxcXCI2My4yXFxcIiB3aWR0aD1cXFwiNFxcXCIgaGVpZ2h0PVxcXCI1XFxcIi8+PCEtLUNyZWF0ZWQgYnkgU2hhc3RyeSBmcm9tIHRoZSBOb3VuIFByb2plY3QtLT48L3N2Zz5cXG5cIjtcblxuICAvKipcbiAgICogQG5hbWVzcGFjZSBQU1Yuc2VydmljZXNcbiAgICovXG5cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IEJhc2Ugc2VydmljZXMgY2xhc3NcbiAgICogQG1lbWJlcm9mIFBTVi5zZXJ2aWNlc1xuICAgKiBAYWJzdHJhY3RcbiAgICovXG4gIHZhciBBYnN0cmFjdFNlcnZpY2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UFNWLlZpZXdlcn0gcHN2XG4gICAgICovXG4gICAgZnVuY3Rpb24gQWJzdHJhY3RTZXJ2aWNlKHBzdikge1xuICAgICAgLyoqXG4gICAgICAgKiBAc3VtbWFyeSBSZWZlcmVuY2UgdG8gbWFpbiBjb250cm9sbGVyXG4gICAgICAgKiBAdHlwZSB7UFNWLlZpZXdlcn1cbiAgICAgICAqIEByZWFkb25seVxuICAgICAgICovXG4gICAgICB0aGlzLnBzdiA9IHBzdjtcbiAgICAgIC8qKlxuICAgICAgICogQHN1bW1hcnkgQ29uZmlndXJhdGlvbiBob2xkZXJcbiAgICAgICAqIEB0eXBlIHtQU1YuT3B0aW9uc31cbiAgICAgICAqIEByZWFkb25seVxuICAgICAgICovXG5cbiAgICAgIHRoaXMuY29uZmlnID0gcHN2LmNvbmZpZztcbiAgICAgIC8qKlxuICAgICAgICogQHN1bW1hcnkgUHJvcGVydGllcyBob2xkZXJcbiAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAqL1xuXG4gICAgICB0aGlzLnByb3AgPSBwc3YucHJvcDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgRGVzdHJveXMgdGhlIHNlcnZpY2VcbiAgICAgKi9cblxuXG4gICAgdmFyIF9wcm90byA9IEFic3RyYWN0U2VydmljZS5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICBkZWxldGUgdGhpcy5wc3Y7XG4gICAgICBkZWxldGUgdGhpcy5jb25maWc7XG4gICAgICBkZWxldGUgdGhpcy5wcm9wO1xuICAgIH07XG5cbiAgICByZXR1cm4gQWJzdHJhY3RTZXJ2aWNlO1xuICB9KCk7XG5cbiAgdmFyIHZlY3RvcjIgPSBuZXcgdGhyZWUuVmVjdG9yMigpO1xuICB2YXIgdmVjdG9yMyA9IG5ldyB0aHJlZS5WZWN0b3IzKCk7XG4gIHZhciBldWxlclplcm8gPSBuZXcgdGhyZWUuRXVsZXIoMCwgMCwgMCwgJ1pYWScpO1xuICAvKipcbiAgICogQHN1bW1hcnkgQ29sbGVjdGlvbnMgb2YgZGF0YSBjb252ZXJ0ZXJzIGZvciB0aGUgY3VycmVudCB2aWV3ZXJcbiAgICogQGV4dGVuZHMgUFNWLnNlcnZpY2VzLkFic3RyYWN0U2VydmljZVxuICAgKiBAbWVtYmVyb2YgUFNWLnNlcnZpY2VzXG4gICAqL1xuXG4gIHZhciBEYXRhSGVscGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQWJzdHJhY3RTZXJ2aWNlKSB7XG4gICAgX2luaGVyaXRzTG9vc2UoRGF0YUhlbHBlciwgX0Fic3RyYWN0U2VydmljZSk7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1BTVi5WaWV3ZXJ9IHBzdlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERhdGFIZWxwZXIocHN2KSB7XG4gICAgICByZXR1cm4gX0Fic3RyYWN0U2VydmljZS5jYWxsKHRoaXMsIHBzdikgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgQ29udmVydHMgdmVydGljYWwgRk9WIHRvIHpvb20gbGV2ZWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZm92XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cblxuXG4gICAgdmFyIF9wcm90byA9IERhdGFIZWxwZXIucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLmZvdlRvWm9vbUxldmVsID0gZnVuY3Rpb24gZm92VG9ab29tTGV2ZWwoZm92KSB7XG4gICAgICB2YXIgdGVtcCA9IE1hdGgucm91bmQoKGZvdiAtIHRoaXMuY29uZmlnLm1pbkZvdikgLyAodGhpcy5jb25maWcubWF4Rm92IC0gdGhpcy5jb25maWcubWluRm92KSAqIDEwMCk7XG4gICAgICByZXR1cm4gdGVtcCAtIDIgKiAodGVtcCAtIDUwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgQ29udmVydHMgem9vbSBsZXZlbCB0byB2ZXJ0aWNhbCBGT1ZcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGV2ZWxcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by56b29tTGV2ZWxUb0ZvdiA9IGZ1bmN0aW9uIHpvb21MZXZlbFRvRm92KGxldmVsKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25maWcubWF4Rm92ICsgbGV2ZWwgLyAxMDAgKiAodGhpcy5jb25maWcubWluRm92IC0gdGhpcy5jb25maWcubWF4Rm92KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgQ29udmVydCB2ZXJ0aWNhbCBGT1YgdG8gaG9yaXpvbnRhbCBGT1ZcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdkZvdlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLnZGb3ZUb0hGb3YgPSBmdW5jdGlvbiB2Rm92VG9IRm92KHZGb3YpIHtcbiAgICAgIHJldHVybiB0aHJlZS5NYXRoVXRpbHMucmFkVG9EZWcoMiAqIE1hdGguYXRhbihNYXRoLnRhbih0aHJlZS5NYXRoVXRpbHMuZGVnVG9SYWQodkZvdikgLyAyKSAqIHRoaXMucHJvcC5hc3BlY3QpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgQ29udmVydHMgYSBzcGVlZCBpbnRvIGEgZHVyYXRpb24gZnJvbSBjdXJyZW50IHBvc2l0aW9uIHRvIGEgbmV3IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLnNwZWVkVG9EdXJhdGlvbiA9IGZ1bmN0aW9uIHNwZWVkVG9EdXJhdGlvbih2YWx1ZSwgYW5nbGUpIHtcbiAgICAgIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAvLyBkZXNpcmVkIHJhZGlhbCBzcGVlZFxuICAgICAgICB2YXIgc3BlZWQgPSB2YWx1ZSA/IHBhcnNlU3BlZWQodmFsdWUpIDogdGhpcy5jb25maWcuYXV0b3JvdGF0ZVNwZWVkOyAvLyBjb21wdXRlIGR1cmF0aW9uXG5cbiAgICAgICAgcmV0dXJuIGFuZ2xlIC8gTWF0aC5hYnMoc3BlZWQpICogMTAwMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IENvbnZlcnRzIHBpeGVsIHRleHR1cmUgY29vcmRpbmF0ZXMgdG8gc3BoZXJpY2FsIHJhZGlhbnMgY29vcmRpbmF0ZXNcbiAgICAgKiBAcGFyYW0ge1BTVi5Qb2ludH0gcG9pbnRcbiAgICAgKiBAcmV0dXJucyB7UFNWLlBvc2l0aW9ufVxuICAgICAqIEB0aHJvd3Mge1BTVi5QU1ZFcnJvcn0gd2hlbiB0aGUgY3VycmVudCBhZGFwdGVyIGRvZXMgbm90IHN1cHBvcnQgdGV4dHVyZSBjb29yZGluYXRlc1xuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by50ZXh0dXJlQ29vcmRzVG9TcGhlcmljYWxDb29yZHMgPSBmdW5jdGlvbiB0ZXh0dXJlQ29vcmRzVG9TcGhlcmljYWxDb29yZHMocG9pbnQpIHtcbiAgICAgIHZhciBwYW5vRGF0YSA9IHRoaXMucHJvcC5wYW5vRGF0YTtcblxuICAgICAgaWYgKCFwYW5vRGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgUFNWRXJyb3IoJ0N1cnJlbnQgYWRhcHRlciBkb2VzIG5vdCBzdXBwb3J0IHRleHR1cmUgY29vcmRpbmF0ZXMuJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWxhdGl2ZVggPSAocG9pbnQueCArIHBhbm9EYXRhLmNyb3BwZWRYKSAvIHBhbm9EYXRhLmZ1bGxXaWR0aCAqIE1hdGguUEkgKiAyO1xuICAgICAgdmFyIHJlbGF0aXZlWSA9IChwb2ludC55ICsgcGFub0RhdGEuY3JvcHBlZFkpIC8gcGFub0RhdGEuZnVsbEhlaWdodCAqIE1hdGguUEk7XG4gICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICBsb25naXR1ZGU6IHJlbGF0aXZlWCA+PSBNYXRoLlBJID8gcmVsYXRpdmVYIC0gTWF0aC5QSSA6IHJlbGF0aXZlWCArIE1hdGguUEksXG4gICAgICAgIGxhdGl0dWRlOiBNYXRoLlBJIC8gMiAtIHJlbGF0aXZlWVxuICAgICAgfTsgLy8gQXBwbHkgcGFub0RhdGEgcG9zZSBhbmQgc3BoZXJlQ29ycmVjdGlvblxuXG4gICAgICBpZiAoIWV1bGVyWmVyby5lcXVhbHModGhpcy5wc3YucmVuZGVyZXIubWVzaC5yb3RhdGlvbikgfHwgIWV1bGVyWmVyby5lcXVhbHModGhpcy5wc3YucmVuZGVyZXIubWVzaENvbnRhaW5lci5yb3RhdGlvbikpIHtcbiAgICAgICAgdGhpcy5zcGhlcmljYWxDb29yZHNUb1ZlY3RvcjMocmVzdWx0LCB2ZWN0b3IzKTtcbiAgICAgICAgdmVjdG9yMy5hcHBseUV1bGVyKHRoaXMucHN2LnJlbmRlcmVyLm1lc2gucm90YXRpb24pO1xuICAgICAgICB2ZWN0b3IzLmFwcGx5RXVsZXIodGhpcy5wc3YucmVuZGVyZXIubWVzaENvbnRhaW5lci5yb3RhdGlvbik7XG4gICAgICAgIHJldHVybiB0aGlzLnZlY3RvcjNUb1NwaGVyaWNhbENvb3Jkcyh2ZWN0b3IzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IENvbnZlcnRzIHNwaGVyaWNhbCByYWRpYW5zIGNvb3JkaW5hdGVzIHRvIHBpeGVsIHRleHR1cmUgY29vcmRpbmF0ZXNcbiAgICAgKiBAcGFyYW0ge1BTVi5Qb3NpdGlvbn0gcG9zaXRpb25cbiAgICAgKiBAcmV0dXJucyB7UFNWLlBvaW50fVxuICAgICAqIEB0aHJvd3Mge1BTVi5QU1ZFcnJvcn0gd2hlbiB0aGUgY3VycmVudCBhZGFwdGVyIGRvZXMgbm90IHN1cHBvcnQgdGV4dHVyZSBjb29yZGluYXRlc1xuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5zcGhlcmljYWxDb29yZHNUb1RleHR1cmVDb29yZHMgPSBmdW5jdGlvbiBzcGhlcmljYWxDb29yZHNUb1RleHR1cmVDb29yZHMocG9zaXRpb24pIHtcbiAgICAgIHZhciBwYW5vRGF0YSA9IHRoaXMucHJvcC5wYW5vRGF0YTtcblxuICAgICAgaWYgKCFwYW5vRGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgUFNWRXJyb3IoJ0N1cnJlbnQgYWRhcHRlciBkb2VzIG5vdCBzdXBwb3J0IHRleHR1cmUgY29vcmRpbmF0ZXMuJyk7XG4gICAgICB9IC8vIEFwcGx5IHBhbm9EYXRhIHBvc2UgYW5kIHNwaGVyZUNvcnJlY3Rpb25cblxuXG4gICAgICBpZiAoIWV1bGVyWmVyby5lcXVhbHModGhpcy5wc3YucmVuZGVyZXIubWVzaC5yb3RhdGlvbikgfHwgIWV1bGVyWmVyby5lcXVhbHModGhpcy5wc3YucmVuZGVyZXIubWVzaENvbnRhaW5lci5yb3RhdGlvbikpIHtcbiAgICAgICAgdGhpcy5zcGhlcmljYWxDb29yZHNUb1ZlY3RvcjMocG9zaXRpb24sIHZlY3RvcjMpO1xuICAgICAgICBhcHBseUV1bGVySW52ZXJzZSh2ZWN0b3IzLCB0aGlzLnBzdi5yZW5kZXJlci5tZXNoQ29udGFpbmVyLnJvdGF0aW9uKTtcbiAgICAgICAgYXBwbHlFdWxlckludmVyc2UodmVjdG9yMywgdGhpcy5wc3YucmVuZGVyZXIubWVzaC5yb3RhdGlvbik7XG4gICAgICAgIHBvc2l0aW9uID0gdGhpcy52ZWN0b3IzVG9TcGhlcmljYWxDb29yZHModmVjdG9yMyk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWxhdGl2ZUxvbmcgPSBwb3NpdGlvbi5sb25naXR1ZGUgLyBNYXRoLlBJIC8gMiAqIHBhbm9EYXRhLmZ1bGxXaWR0aDtcbiAgICAgIHZhciByZWxhdGl2ZUxhdCA9IHBvc2l0aW9uLmxhdGl0dWRlIC8gTWF0aC5QSSAqIHBhbm9EYXRhLmZ1bGxIZWlnaHQ7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBNYXRoLnJvdW5kKHBvc2l0aW9uLmxvbmdpdHVkZSA8IE1hdGguUEkgPyByZWxhdGl2ZUxvbmcgKyBwYW5vRGF0YS5mdWxsV2lkdGggLyAyIDogcmVsYXRpdmVMb25nIC0gcGFub0RhdGEuZnVsbFdpZHRoIC8gMikgLSBwYW5vRGF0YS5jcm9wcGVkWCxcbiAgICAgICAgeTogTWF0aC5yb3VuZChwYW5vRGF0YS5mdWxsSGVpZ2h0IC8gMiAtIHJlbGF0aXZlTGF0KSAtIHBhbm9EYXRhLmNyb3BwZWRZXG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBDb252ZXJ0cyBzcGhlcmljYWwgcmFkaWFucyBjb29yZGluYXRlcyB0byBhIFRIUkVFLlZlY3RvcjNcbiAgICAgKiBAcGFyYW0ge1BTVi5Qb3NpdGlvbn0gcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge2V4dGVybmFsOlRIUkVFLlZlY3RvcjN9IFt2ZWN0b3JdXG4gICAgICogQHJldHVybnMge2V4dGVybmFsOlRIUkVFLlZlY3RvcjN9XG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLnNwaGVyaWNhbENvb3Jkc1RvVmVjdG9yMyA9IGZ1bmN0aW9uIHNwaGVyaWNhbENvb3Jkc1RvVmVjdG9yMyhwb3NpdGlvbiwgdmVjdG9yKSB7XG4gICAgICBpZiAoIXZlY3Rvcikge1xuICAgICAgICB2ZWN0b3IgPSBuZXcgdGhyZWUuVmVjdG9yMygpO1xuICAgICAgfVxuXG4gICAgICB2ZWN0b3IueCA9IFNQSEVSRV9SQURJVVMgKiAtTWF0aC5jb3MocG9zaXRpb24ubGF0aXR1ZGUpICogTWF0aC5zaW4ocG9zaXRpb24ubG9uZ2l0dWRlKTtcbiAgICAgIHZlY3Rvci55ID0gU1BIRVJFX1JBRElVUyAqIE1hdGguc2luKHBvc2l0aW9uLmxhdGl0dWRlKTtcbiAgICAgIHZlY3Rvci56ID0gU1BIRVJFX1JBRElVUyAqIE1hdGguY29zKHBvc2l0aW9uLmxhdGl0dWRlKSAqIE1hdGguY29zKHBvc2l0aW9uLmxvbmdpdHVkZSk7XG4gICAgICByZXR1cm4gdmVjdG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBDb252ZXJ0cyBhIFRIUkVFLlZlY3RvcjMgdG8gc3BoZXJpY2FsIHJhZGlhbnMgY29vcmRpbmF0ZXNcbiAgICAgKiBAcGFyYW0ge2V4dGVybmFsOlRIUkVFLlZlY3RvcjN9IHZlY3RvclxuICAgICAqIEByZXR1cm5zIHtQU1YuUG9zaXRpb259XG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLnZlY3RvcjNUb1NwaGVyaWNhbENvb3JkcyA9IGZ1bmN0aW9uIHZlY3RvcjNUb1NwaGVyaWNhbENvb3Jkcyh2ZWN0b3IpIHtcbiAgICAgIHZhciBwaGkgPSBNYXRoLmFjb3ModmVjdG9yLnkgLyBNYXRoLnNxcnQodmVjdG9yLnggKiB2ZWN0b3IueCArIHZlY3Rvci55ICogdmVjdG9yLnkgKyB2ZWN0b3IueiAqIHZlY3Rvci56KSk7XG4gICAgICB2YXIgdGhldGEgPSBNYXRoLmF0YW4yKHZlY3Rvci54LCB2ZWN0b3Iueik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsb25naXR1ZGU6IHRoZXRhIDwgMCA/IC10aGV0YSA6IE1hdGguUEkgKiAyIC0gdGhldGEsXG4gICAgICAgIGxhdGl0dWRlOiBNYXRoLlBJIC8gMiAtIHBoaVxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgQ29udmVydHMgcG9zaXRpb24gb24gdGhlIHZpZXdlciB0byBhIFRIUkVFLlZlY3RvcjNcbiAgICAgKiBAcGFyYW0ge1BTVi5Qb2ludH0gdmlld2VyUG9pbnRcbiAgICAgKiBAcmV0dXJucyB7ZXh0ZXJuYWw6VEhSRUUuVmVjdG9yM31cbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8udmlld2VyQ29vcmRzVG9WZWN0b3IzID0gZnVuY3Rpb24gdmlld2VyQ29vcmRzVG9WZWN0b3IzKHZpZXdlclBvaW50KSB7XG4gICAgICB2YXIgc3BoZXJlSW50ZXJzZWN0ID0gdGhpcy5nZXRJbnRlcnNlY3Rpb25zKHZpZXdlclBvaW50KS5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIGkub2JqZWN0LnVzZXJEYXRhW01FU0hfVVNFUl9EQVRBXTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoc3BoZXJlSW50ZXJzZWN0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc3BoZXJlSW50ZXJzZWN0WzBdLnBvaW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IENvbnZlcnRzIGEgVEhSRUUuVmVjdG9yMyB0byBwb3NpdGlvbiBvbiB0aGUgdmlld2VyXG4gICAgICogQHBhcmFtIHtleHRlcm5hbDpUSFJFRS5WZWN0b3IzfSB2ZWN0b3JcbiAgICAgKiBAcmV0dXJucyB7UFNWLlBvaW50fVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by52ZWN0b3IzVG9WaWV3ZXJDb29yZHMgPSBmdW5jdGlvbiB2ZWN0b3IzVG9WaWV3ZXJDb29yZHModmVjdG9yKSB7XG4gICAgICB2YXIgdmVjdG9yQ2xvbmUgPSB2ZWN0b3IuY2xvbmUoKTtcbiAgICAgIHZlY3RvckNsb25lLnByb2plY3QodGhpcy5wc3YucmVuZGVyZXIuY2FtZXJhKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IE1hdGgucm91bmQoKHZlY3RvckNsb25lLnggKyAxKSAvIDIgKiB0aGlzLnByb3Auc2l6ZS53aWR0aCksXG4gICAgICAgIHk6IE1hdGgucm91bmQoKDEgLSB2ZWN0b3JDbG9uZS55KSAvIDIgKiB0aGlzLnByb3Auc2l6ZS5oZWlnaHQpXG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBDb252ZXJ0cyBzcGhlcmljYWwgcmFkaWFucyBjb29yZGluYXRlcyB0byBwb3NpdGlvbiBvbiB0aGUgdmlld2VyXG4gICAgICogQHBhcmFtIHtQU1YuUG9zaXRpb259IHBvc2l0aW9uXG4gICAgICogQHJldHVybnMge1BTVi5Qb2ludH1cbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uc3BoZXJpY2FsQ29vcmRzVG9WaWV3ZXJDb29yZHMgPSBmdW5jdGlvbiBzcGhlcmljYWxDb29yZHNUb1ZpZXdlckNvb3Jkcyhwb3NpdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMudmVjdG9yM1RvVmlld2VyQ29vcmRzKHRoaXMuc3BoZXJpY2FsQ29vcmRzVG9WZWN0b3IzKHBvc2l0aW9uLCB2ZWN0b3IzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFJldHVybnMgaW50ZXJzZWN0aW9ucyB3aXRoIG9iamVjdHMgaW4gdGhlIHNjZW5lXG4gICAgICogQHBhcmFtIHtQU1YuUG9pbnR9IHZpZXdlclBvaW50XG4gICAgICogQHJldHVybiB7ZXh0ZXJuYWw6VEhSRUUuSW50ZXJzZWN0aW9uW119XG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLmdldEludGVyc2VjdGlvbnMgPSBmdW5jdGlvbiBnZXRJbnRlcnNlY3Rpb25zKHZpZXdlclBvaW50KSB7XG4gICAgICB2ZWN0b3IyLnggPSAyICogdmlld2VyUG9pbnQueCAvIHRoaXMucHJvcC5zaXplLndpZHRoIC0gMTtcbiAgICAgIHZlY3RvcjIueSA9IC0yICogdmlld2VyUG9pbnQueSAvIHRoaXMucHJvcC5zaXplLmhlaWdodCArIDE7XG4gICAgICB0aGlzLnBzdi5yZW5kZXJlci5yYXljYXN0ZXIuc2V0RnJvbUNhbWVyYSh2ZWN0b3IyLCB0aGlzLnBzdi5yZW5kZXJlci5jYW1lcmEpO1xuICAgICAgcmV0dXJuIHRoaXMucHN2LnJlbmRlcmVyLnJheWNhc3Rlci5pbnRlcnNlY3RPYmplY3RzKHRoaXMucHN2LnJlbmRlcmVyLnNjZW5lLmNoaWxkcmVuLCB0cnVlKS5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuICEhaS5vYmplY3QudXNlckRhdGE7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgQ29udmVydHMgeC95IHRvIGxhdGl0dWRlL2xvbmdpdHVkZSBpZiBwcmVzZW50IGFuZCBlbnN1cmUgYm91bmRhcmllc1xuICAgICAqIEBwYXJhbSB7UFNWLkV4dGVuZGVkUG9zaXRpb259IHBvc2l0aW9uXG4gICAgICogQHJldHVybnMge1BTVi5Qb3NpdGlvbn1cbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uY2xlYW5Qb3NpdGlvbiA9IGZ1bmN0aW9uIGNsZWFuUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICAgIGlmIChwb3NpdGlvbi54ICE9PSB1bmRlZmluZWQgJiYgcG9zaXRpb24ueSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHR1cmVDb29yZHNUb1NwaGVyaWNhbENvb3Jkcyhwb3NpdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxvbmdpdHVkZTogcGFyc2VBbmdsZShwb3NpdGlvbi5sb25naXR1ZGUpLFxuICAgICAgICAgIGxhdGl0dWRlOiBwYXJzZUFuZ2xlKHBvc2l0aW9uLmxhdGl0dWRlLCAhdGhpcy5wcm9wLmxpdHRsZVBsYW5ldClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgRW5zdXJlIGEgU3BoZXJlQ29ycmVjdGlvbiBvYmplY3QgaXMgdmFsaWRcbiAgICAgKiBAcGFyYW0ge1BTVi5TcGhlcmVDb3JyZWN0aW9ufSBzcGhlcmVDb3JyZWN0aW9uXG4gICAgICogQHJldHVybnMge1BTVi5TcGhlcmVDb3JyZWN0aW9ufVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5jbGVhblNwaGVyZUNvcnJlY3Rpb24gPSBmdW5jdGlvbiBjbGVhblNwaGVyZUNvcnJlY3Rpb24oc3BoZXJlQ29ycmVjdGlvbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGFuOiBwYXJzZUFuZ2xlKChzcGhlcmVDb3JyZWN0aW9uID09IG51bGwgPyB2b2lkIDAgOiBzcGhlcmVDb3JyZWN0aW9uLnBhbikgfHwgMCksXG4gICAgICAgIHRpbHQ6IHBhcnNlQW5nbGUoKHNwaGVyZUNvcnJlY3Rpb24gPT0gbnVsbCA/IHZvaWQgMCA6IHNwaGVyZUNvcnJlY3Rpb24udGlsdCkgfHwgMCwgdHJ1ZSksXG4gICAgICAgIHJvbGw6IHBhcnNlQW5nbGUoKHNwaGVyZUNvcnJlY3Rpb24gPT0gbnVsbCA/IHZvaWQgMCA6IHNwaGVyZUNvcnJlY3Rpb24ucm9sbCkgfHwgMCwgdHJ1ZSwgZmFsc2UpXG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBQYXJzZSB0aGUgcG9zZSBhbmdsZXMgb2YgdGhlIHBhbm8gZGF0YVxuICAgICAqIEBwYXJhbSB7UFNWLlBhbm9EYXRhfSBwYW5vRGF0YVxuICAgICAqIEByZXR1cm5zIHtQU1YuU3BoZXJlQ29ycmVjdGlvbn1cbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uY2xlYW5QYW5vcmFtYVBvc2UgPSBmdW5jdGlvbiBjbGVhblBhbm9yYW1hUG9zZShwYW5vRGF0YSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGFuOiB0aHJlZS5NYXRoVXRpbHMuZGVnVG9SYWQoKHBhbm9EYXRhID09IG51bGwgPyB2b2lkIDAgOiBwYW5vRGF0YS5wb3NlSGVhZGluZykgfHwgMCksXG4gICAgICAgIHRpbHQ6IHRocmVlLk1hdGhVdGlscy5kZWdUb1JhZCgocGFub0RhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IHBhbm9EYXRhLnBvc2VQaXRjaCkgfHwgMCksXG4gICAgICAgIHJvbGw6IHRocmVlLk1hdGhVdGlscy5kZWdUb1JhZCgocGFub0RhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IHBhbm9EYXRhLnBvc2VSb2xsKSB8fCAwKVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIERhdGFIZWxwZXI7XG4gIH0oQWJzdHJhY3RTZXJ2aWNlKTtcblxuICB2YXIgZ2VzdHVyZUljb24gPSBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB2aWV3Qm94PVxcXCIwIDAgMTAwIDEwMFxcXCI+PHBhdGggZmlsbD1cXFwiY3VycmVudENvbG9yXFxcIiBkPVxcXCJNMzMuMzggMzMuMmExLjk2IDEuOTYgMCAwIDAgMS41LTMuMjMgMTAuNjEgMTAuNjEgMCAwIDEgNy4xOC0xNy41MWMuNy0uMDYgMS4zMS0uNDkgMS42MS0xLjEyYTEzLjAyIDEzLjAyIDAgMCAxIDExLjc0LTcuNDNjNy4xNCAwIDEyLjk2IDUuOCAxMi45NiAxMi45IDAgMy4wNy0xLjEgNi4wNS0zLjEgOC4zOC0uNy44Mi0uNjEgMi4wNS4yMSAyLjc2LjgzLjcgMi4wNy42IDIuNzgtLjIyYTE2Ljc3IDE2Ljc3IDAgMCAwIDQuMDQtMTAuOTFDNzIuMyA3LjU0IDY0LjcyIDAgNTUuNCAwYTE2Ljk4IDE2Ljk4IDAgMCAwLTE0Ljc5IDguNyAxNC42IDE0LjYgMCAwIDAtMTIuMjMgMTQuMzZjMCAzLjQ2IDEuMjUgNi44MiAzLjUgOS40NS40LjQ1Ljk0LjY5IDEuNS42OW00NS43NCA0My41NWEyMi4xMyAyMi4xMyAwIDAgMS01LjIzIDEyLjRjLTQgNC41NS05LjUzIDYuODYtMTYuNDIgNi44Ni0xMi42IDAtMjAuMS0xMC44LTIwLjE3LTEwLjkxYTEuODIgMS44MiAwIDAgMC0uMDgtLjFjLTUuMy02LjgzLTE0LjU1LTIzLjgyLTE3LjI3LTI4Ljg3LS4wNS0uMSAwLS4yMS4wMi0uMjNhNi4zIDYuMyAwIDAgMSA4LjI0IDEuODVsOS4zOCAxMi41OWExLjk3IDEuOTcgMCAwIDAgMy41NC0xLjE3VjI1LjM0YTQgNCAwIDAgMSAxLjE5LTIuODcgMy4zMiAzLjMyIDAgMCAxIDIuNC0uOTVjMS44OC4wNSAzLjQgMS44MiAzLjQgMy45NHYyNC4zMmExLjk2IDEuOTYgMCAwIDAgMy45MyAwdi0zMy4xYTMuNSAzLjUgMCAwIDEgNyAwdjM1LjM5YTEuOTYgMS45NiAwIDAgMCAzLjkzIDB2LS40NGMuMDUtMi4wNSAxLjYtMy43IDMuNDktMy43IDEuOTMgMCAzLjUgMS43IDMuNSAzLjgydjUuNjNjMCAuMjQuMDQuNDguMTMuNzFsLjEuMjZhMS45NyAxLjk3IDAgMCAwIDMuNzYtLjM3Yy4zMy0xLjc4IDEuNzctMy4wNyAzLjQzLTMuMDcgMS45IDAgMy40NSAxLjY3IDMuNSAzLjc0bC0xLjc3IDE4LjF6TTc3LjM5IDUxYy0xLjI1IDAtMi40NS4zMi0zLjUuOXYtLjE1YzAtNC4yNy0zLjMzLTcuNzQtNy40Mi03Ljc0LTEuMjYgMC0yLjQ1LjMzLTMuNS45VjE2LjY5YTcuNDIgNy40MiAwIDAgMC0xNC44NSAwdjEuODZhNyA3IDAgMCAwLTMuMjgtLjk0IDcuMjEgNy4yMSAwIDAgMC01LjI2IDIuMDcgNy45MiA3LjkyIDAgMCAwLTIuMzggNS42N3YzNy45bC01LjgzLTcuODJhMTAuMiAxMC4yIDAgMCAwLTEzLjM1LTIuOTIgNC4xIDQuMSAwIDAgMC0xLjUzIDUuNDhDMjAgNjQuNTIgMjguNzQgODAuNDUgMzQuMDcgODcuMzRjLjcyIDEuMDQgOS4wMiAxMi41OSAyMy40IDEyLjU5IDcuOTYgMCAxNC42Ni0yLjg0IDE5LjM4LTguMmEyNi4wNiAyNi4wNiAwIDAgMCA2LjE4LTE0LjZsMS43OC0xOC4ydi0uMmMwLTQuMjYtMy4zMi03LjczLTcuNDItNy43M3pcXFwiLz48IS0tQ3JlYXRlZCBieSBBb21BbSBmcm9tIHRoZSBOb3VuIFByb2plY3QtLT48L3N2Zz5cXG5cIjtcblxuICB2YXIgbW91c2V3aGVlbEljb24gPSBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB2aWV3Qm94PVxcXCIxMCAxNyA3OSA3OVxcXCI+PHBhdGggZmlsbD1cXFwiY3VycmVudENvbG9yXFxcIiBkPVxcXCJNMzguMSAyOS4yN2MtLjI0IDAtLjQ0LjItLjQ0LjQ1djEwLjdhLjQ1LjQ1IDAgMDAuOSAwdi0xMC43YzAtLjI1LS4yLS40NS0uNDUtLjQ1em0xMC4yIDI2LjY2YTExLjU0IDExLjU0IDAgMDEtOC40OC02LjE0LjQ1LjQ1IDAgMTAtLjguNDEgMTIuNDUgMTIuNDUgMCAwMDkuMjIgNi42Mi40NS40NSAwIDAwLjA3LS45em0yNC41NS0xMy4wOGEyMy4wNCAyMy4wNCAwIDAwLTIyLjU2LTIzdjcuMDdsLS4wMS4wNWEyLjgzIDIuODMgMCAwMTIuMzkgMi43OHYxNC4wM2wuMDktLjAyaDguODR2LTkuMjJhLjQ1LjQ1IDAgMTEuOSAwdjkuMjJoMTAuMzV2LS45em0wIDI3LjMzVjQ0LjY2SDYyLjVjLS4wMiAyLjAxLS41MiA0LTEuNDcgNS43NmEuNDUuNDUgMCAwMS0uNjEuMTguNDUuNDUgMCAwMS0uMTktLjYxIDExLjU0IDExLjU0IDAgMDAxLjM2LTUuMzNoLTguODNsLS4xLS4wMWEyLjgzIDIuODMgMCAwMS0yLjgzIDIuODRoLS4wNC0uMDRhMi44MyAyLjgzIDAgMDEtMi44My0yLjgzdi0xNC45YTIuODIgMi44MiAwIDAxMi40Ny0yLjh2LTcuMTFhMjMuMDQgMjMuMDQgMCAwMC0yMi41NyAyM3YuOTFoMTQuNzJWMjkuODhhOC4yIDguMiAwIDAxNS4wMi03LjU3Yy4yMi0uMS41LjAxLjU5LjI0LjEuMjMtLjAxLjUtLjI0LjZhNy4zIDcuMyAwIDAwLTQuNDcgNi43M3YxMy44OGgzLjlhLjQ1LjQ1IDAgMTEwIC45aC0zLjl2LjE1YTcuMzIgNy4zMiAwIDAwMTEuMjMgNi4xNy40NS40NSAwIDAxLjQ5Ljc2IDguMjIgOC4yMiAwIDAxLTEyLjYyLTYuOTN2LS4xNUgyNi44MnYyNS41MmEyMy4wNCAyMy4wNCAwIDAwMjMuMDEgMjMuMDEgMjMuMDQgMjMuMDQgMCAwMDIzLjAyLTIzLjAxem0xLjgtMjcuMzN2MjcuMzNBMjQuODUgMjQuODUgMCAwMTQ5Ljg0IDk1YTI0Ljg1IDI0Ljg1IDAgMDEtMjQuODItMjQuODJWNDIuODVhMjQuODUgMjQuODUgMCAwMTI0LjgyLTI0LjgyIDI0Ljg1IDI0Ljg1IDAgMDEyNC44MyAyNC44MnpNNTcuOTggMjkuODh2OS4zNmEuNDUuNDUgMCAxMS0uOSAwdi05LjM2YTcuMjggNy4yOCAwIDAwLTMuNC02LjE3LjQ1LjQ1IDAgMDEuNDktLjc2IDguMTggOC4xOCAwIDAxMy44IDYuOTN6XFxcIi8+PCEtLSBDcmVhdGVkIGJ5IEljb24gSXNsYW5kIGZyb20gdGhlIE5vdW4gUHJvamVjdCAtLT48L3N2Zz5cXG5cIjtcblxuICB2YXIgSURMRSA9IDA7XG4gIHZhciBNT1ZJTkcgPSAxO1xuICB2YXIgSU5FUlRJQSA9IDI7XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBFdmVudHMgaGFuZGxlclxuICAgKiBAZXh0ZW5kcyBQU1Yuc2VydmljZXMuQWJzdHJhY3RTZXJ2aWNlXG4gICAqIEBtZW1iZXJvZiBQU1Yuc2VydmljZXNcbiAgICovXG5cbiAgdmFyIEV2ZW50c0hhbmRsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9BYnN0cmFjdFNlcnZpY2UpIHtcbiAgICBfaW5oZXJpdHNMb29zZShFdmVudHNIYW5kbGVyLCBfQWJzdHJhY3RTZXJ2aWNlKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UFNWLlZpZXdlcn0gcHN2XG4gICAgICovXG4gICAgZnVuY3Rpb24gRXZlbnRzSGFuZGxlcihwc3YpIHtcbiAgICAgIHZhciBfdGhpcztcblxuICAgICAgX3RoaXMgPSBfQWJzdHJhY3RTZXJ2aWNlLmNhbGwodGhpcywgcHN2KSB8fCB0aGlzO1xuICAgICAgLyoqXG4gICAgICAgKiBAc3VtbWFyeSBJbnRlcm5hbCBwcm9wZXJ0aWVzXG4gICAgICAgKiBAbWVtYmVyIHtPYmplY3R9XG4gICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbW92ZVRocmVzaG9sZCAtIGNvbXB1dGVkIHRocmVzaG9sZCBiYXNlZCBvbiBkZXZpY2UgcGl4ZWwgcmF0aW9cbiAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdGVwXG4gICAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IG1vdXNlZG93biAtIGJlZm9yZSBtb3ZpbmcgcGFzdCB0aGUgdGhyZXNob2xkXG4gICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc3RhcnRNb3VzZVggLSBzdGFydCB4IHBvc2l0aW9uIG9mIHRoZSBjbGljay90b3VjaFxuICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHN0YXJ0TW91c2VZIC0gc3RhcnQgeSBwb3NpdGlvbiBvZiB0aGUgY2xpY2svdG91Y2hcbiAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtb3VzZVggLSBjdXJyZW50IHggcG9zaXRpb24gb2YgdGhlIGN1cnNvclxuICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1vdXNlWSAtIGN1cnJlbnQgeSBwb3NpdGlvbiBvZiB0aGUgY3Vyc29yXG4gICAgICAgKiBAcHJvcGVydHkge251bWJlcltdW119IG1vdXNlSGlzdG9yeSAtIGxpc3Qgb2YgbGF0ZXN0IHBvc2l0aW9ucyBvZiB0aGUgY3Vyc29yLCBbdGltZSwgeCwgeV1cbiAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwaW5jaERpc3QgLSBkaXN0YW5jZSBiZXR3ZWVuIGZpbmdlcnMgd2hlbiB6b29taW5nXG4gICAgICAgKiBAcHJvcGVydHkge1ByZXNzSGFuZGxlcn0ga2V5SGFuZGxlclxuICAgICAgICogQHByb3BlcnR5IHtib29sZWFufSBjdHJsS2V5RG93biAtIHdoZW4gdGhlIEN0cmwga2V5IGlzIHByZXNzZWRcbiAgICAgICAqIEBwcm9wZXJ0eSB7UFNWLkNsaWNrRGF0YX0gZGJsY2xpY2tEYXRhIC0gdGVtcG9yYXJ5IHN0b3JhZ2Ugb2YgY2xpY2sgZGF0YSBiZXR3ZWVuIHR3byBjbGlja3NcbiAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYmxjbGlja1RpbWVvdXQgLSB0aW1lb3V0IGlkIGZvciBkb3VibGUgY2xpY2tcbiAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0d29maW5nZXJzVGltZW91dCAtIHRpbWVvdXQgaWQgZm9yIFwidHdvIGZpbmdlcnNcIiBvdmVybGF5XG4gICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gY3RybFpvb21UaW1lb3V0IC0gdGltZW91dCBpZCBmb3IgXCJjdHJvbCB6b29tXCIgb3ZlcmxheVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG5cbiAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICBtb3ZlVGhyZXNob2xkOiBNT1ZFX1RIUkVTSE9MRCAqIFNZU1RFTS5waXhlbFJhdGlvLFxuICAgICAgICBrZXlib2FyZEVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBzdGVwOiBJRExFLFxuICAgICAgICBtb3VzZWRvd246IGZhbHNlLFxuICAgICAgICBzdGFydE1vdXNlWDogMCxcbiAgICAgICAgc3RhcnRNb3VzZVk6IDAsXG4gICAgICAgIG1vdXNlWDogMCxcbiAgICAgICAgbW91c2VZOiAwLFxuICAgICAgICBtb3VzZUhpc3Rvcnk6IFtdLFxuICAgICAgICBwaW5jaERpc3Q6IDAsXG4gICAgICAgIGtleUhhbmRsZXI6IG5ldyBQcmVzc0hhbmRsZXIoKSxcbiAgICAgICAgY3RybEtleURvd246IGZhbHNlLFxuICAgICAgICBkYmxjbGlja0RhdGE6IG51bGwsXG4gICAgICAgIGRibGNsaWNrVGltZW91dDogbnVsbCxcbiAgICAgICAgbG9uZ3RvdWNoVGltZW91dDogbnVsbCxcbiAgICAgICAgdHdvZmluZ2Vyc1RpbWVvdXQ6IG51bGwsXG4gICAgICAgIGN0cmxab29tVGltZW91dDogbnVsbFxuICAgICAgfTtcbiAgICAgIC8qKlxuICAgICAgICogQHN1bW1hcnkgVGhyb3R0bGVkIHdyYXBwZXIgb2Yge0BsaW5rIFBTVi5WaWV3ZXIjYXV0b1NpemV9XG4gICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICAgIF90aGlzLl9fb25SZXNpemUgPSB0aHJvdHRsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5wc3YuYXV0b1NpemUoKTtcbiAgICAgIH0sIDUwKTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgSW5pdGlhbGl6ZXMgZXZlbnQgaGFuZGxlcnNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG5cblxuICAgIHZhciBfcHJvdG8gPSBFdmVudHNIYW5kbGVyLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5pbml0ID0gZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcywge1xuICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzKTtcbiAgICAgIHRoaXMucHN2LmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLCB7XG4gICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcyk7XG4gICAgICB0aGlzLnBzdi5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMsIHtcbiAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMsIHtcbiAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcywge1xuICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICB0aGlzLnBzdi5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihTWVNURU0ubW91c2VXaGVlbEV2ZW50LCB0aGlzLCB7XG4gICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICB9KTtcblxuICAgICAgaWYgKFNZU1RFTS5mdWxsc2NyZWVuRXZlbnQpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihTWVNURU0uZnVsbHNjcmVlbkV2ZW50LCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMpO1xuICAgICAgdGhpcy5wc3YuY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzKTtcbiAgICAgIHRoaXMucHN2LmNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcyk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcyk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzKTtcbiAgICAgIHRoaXMucHN2LmNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFNZU1RFTS5tb3VzZVdoZWVsRXZlbnQsIHRoaXMpO1xuXG4gICAgICBpZiAoU1lTVEVNLmZ1bGxzY3JlZW5FdmVudCkge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFNZU1RFTS5mdWxsc2NyZWVuRXZlbnQsIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5zdGF0ZS5kYmxjbGlja1RpbWVvdXQpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuc3RhdGUubG9uZ3RvdWNoVGltZW91dCk7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5zdGF0ZS50d29maW5nZXJzVGltZW91dCk7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5zdGF0ZS5jdHJsWm9vbVRpbWVvdXQpO1xuICAgICAgZGVsZXRlIHRoaXMuc3RhdGU7XG5cbiAgICAgIF9BYnN0cmFjdFNlcnZpY2UucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgSGFuZGxlcyBldmVudHNcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uIGhhbmRsZUV2ZW50KGV2dCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgKi9cbiAgICAgIHN3aXRjaCAoZXZ0LnR5cGUpIHtcbiAgICAgICAgLy8gQGZvcm1hdHRlcjpvZmZcbiAgICAgICAgY2FzZSAncmVzaXplJzpcbiAgICAgICAgICB0aGlzLl9fb25SZXNpemUoKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2tleWRvd24nOlxuICAgICAgICAgIHRoaXMuX19vbktleURvd24oZXZ0KTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2tleXVwJzpcbiAgICAgICAgICB0aGlzLl9fb25LZXlVcCgpO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbW91c2Vtb3ZlJzpcbiAgICAgICAgICB0aGlzLl9fb25Nb3VzZU1vdmUoZXZ0KTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ21vdXNldXAnOlxuICAgICAgICAgIHRoaXMuX19vbk1vdXNlVXAoZXZ0KTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3RvdWNobW92ZSc6XG4gICAgICAgICAgdGhpcy5fX29uVG91Y2hNb3ZlKGV2dCk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd0b3VjaGVuZCc6XG4gICAgICAgICAgdGhpcy5fX29uVG91Y2hFbmQoZXZ0KTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU1lTVEVNLmZ1bGxzY3JlZW5FdmVudDpcbiAgICAgICAgICB0aGlzLl9fZnVsbHNjcmVlblRvZ2dsZWQoKTtcblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBAZm9ybWF0dGVyOm9uXG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlICovXG5cblxuICAgICAgaWYgKCFnZXRDbG9zZXN0KGV2dC50YXJnZXQsICcucHN2LS1jYXB0dXJlLWV2ZW50JykpIHtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgKi9cbiAgICAgICAgc3dpdGNoIChldnQudHlwZSkge1xuICAgICAgICAgIC8vIEBmb3JtYXR0ZXI6b2ZmXG4gICAgICAgICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICAgICAgICAgIHRoaXMuX19vbk1vdXNlRG93bihldnQpO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3RvdWNoc3RhcnQnOlxuICAgICAgICAgICAgdGhpcy5fX29uVG91Y2hTdGFydChldnQpO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgU1lTVEVNLm1vdXNlV2hlZWxFdmVudDpcbiAgICAgICAgICAgIHRoaXMuX19vbk1vdXNlV2hlZWwoZXZ0KTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgLy8gQGZvcm1hdHRlcjpvblxuICAgICAgICB9XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgKi9cblxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBFbmFibGVzIHRoZSBrZXlib2FyZCBjb250cm9sc1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uZW5hYmxlS2V5Ym9hcmQgPSBmdW5jdGlvbiBlbmFibGVLZXlib2FyZCgpIHtcbiAgICAgIHRoaXMuc3RhdGUua2V5Ym9hcmRFbmFibGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgRGlzYWJsZXMgdGhlIGtleWJvYXJkIGNvbnRyb2xzXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5kaXNhYmxlS2V5Ym9hcmQgPSBmdW5jdGlvbiBkaXNhYmxlS2V5Ym9hcmQoKSB7XG4gICAgICB0aGlzLnN0YXRlLmtleWJvYXJkRW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBIYW5kbGVzIGtleWJvYXJkIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLl9fb25LZXlEb3duID0gZnVuY3Rpb24gX19vbktleURvd24oZSkge1xuICAgICAgaWYgKHRoaXMuY29uZmlnLm1vdXNld2hlZWxDdHJsS2V5KSB7XG4gICAgICAgIHRoaXMuc3RhdGUuY3RybEtleURvd24gPSBlLmtleSA9PT0gS0VZX0NPREVTLkNvbnRyb2w7XG5cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuY3RybEtleURvd24pIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5zdGF0ZS5jdHJsWm9vbVRpbWVvdXQpO1xuICAgICAgICAgIHRoaXMucHN2Lm92ZXJsYXkuaGlkZShJRFMuQ1RSTF9aT09NKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZTIgPSB0aGlzLnBzdi50cmlnZ2VyKEVWRU5UUy5LRVlfUFJFU1MsIGUua2V5KTtcblxuICAgICAgaWYgKGUyLmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLnN0YXRlLmtleWJvYXJkRW5hYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBhY3Rpb24gPSB0aGlzLmNvbmZpZy5rZXlib2FyZFtlLmtleV07XG5cbiAgICAgIGlmIChhY3Rpb24gPT09IEFDVElPTlMuVE9HR0xFX0FVVE9ST1RBVEUpIHtcbiAgICAgICAgdGhpcy5wc3YudG9nZ2xlQXV0b3JvdGF0ZSgpO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9IGVsc2UgaWYgKGFjdGlvbiAmJiAhdGhpcy5zdGF0ZS5rZXlIYW5kbGVyLnRpbWUpIHtcbiAgICAgICAgaWYgKGFjdGlvbiAhPT0gQUNUSU9OUy5aT09NX0lOICYmIGFjdGlvbiAhPT0gQUNUSU9OUy5aT09NX09VVCkge1xuICAgICAgICAgIHRoaXMucHN2Ll9fc3RvcEFsbCgpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlICovXG5cblxuICAgICAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgICAgIC8vIEBmb3JtYXR0ZXI6b2ZmXG4gICAgICAgICAgY2FzZSBBQ1RJT05TLlJPVEFURV9MQVRfVVA6XG4gICAgICAgICAgICB0aGlzLnBzdi5keW5hbWljcy5wb3NpdGlvbi5yb2xsKHtcbiAgICAgICAgICAgICAgbGF0aXR1ZGU6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBBQ1RJT05TLlJPVEFURV9MQVRfRE9XTjpcbiAgICAgICAgICAgIHRoaXMucHN2LmR5bmFtaWNzLnBvc2l0aW9uLnJvbGwoe1xuICAgICAgICAgICAgICBsYXRpdHVkZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgQUNUSU9OUy5ST1RBVEVfTE9OR19SSUdIVDpcbiAgICAgICAgICAgIHRoaXMucHN2LmR5bmFtaWNzLnBvc2l0aW9uLnJvbGwoe1xuICAgICAgICAgICAgICBsb25naXR1ZGU6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBBQ1RJT05TLlJPVEFURV9MT05HX0xFRlQ6XG4gICAgICAgICAgICB0aGlzLnBzdi5keW5hbWljcy5wb3NpdGlvbi5yb2xsKHtcbiAgICAgICAgICAgICAgbG9uZ2l0dWRlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBBQ1RJT05TLlpPT01fSU46XG4gICAgICAgICAgICB0aGlzLnBzdi5keW5hbWljcy56b29tLnJvbGwoZmFsc2UpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIEFDVElPTlMuWk9PTV9PVVQ6XG4gICAgICAgICAgICB0aGlzLnBzdi5keW5hbWljcy56b29tLnJvbGwodHJ1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAvLyBAZm9ybWF0dGVyOm9uXG4gICAgICAgIH1cbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSAqL1xuXG5cbiAgICAgICAgdGhpcy5zdGF0ZS5rZXlIYW5kbGVyLmRvd24oKTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBIYW5kbGVzIGtleWJvYXJkIGV2ZW50c1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLl9fb25LZXlVcCA9IGZ1bmN0aW9uIF9fb25LZXlVcCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLnN0YXRlLmN0cmxLZXlEb3duID0gZmFsc2U7XG5cbiAgICAgIGlmICghdGhpcy5zdGF0ZS5rZXlib2FyZEVuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YXRlLmtleUhhbmRsZXIudXAoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIucHN2LmR5bmFtaWNzLnBvc2l0aW9uLnN0b3AoKTtcblxuICAgICAgICBfdGhpczIucHN2LmR5bmFtaWNzLnpvb20uc3RvcCgpO1xuXG4gICAgICAgIF90aGlzMi5wc3YucmVzZXRJZGxlVGltZXIoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBIYW5kbGVzIG1vdXNlIGRvd24gZXZlbnRzXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5fX29uTW91c2VEb3duID0gZnVuY3Rpb24gX19vbk1vdXNlRG93bihldnQpIHtcbiAgICAgIHRoaXMuc3RhdGUubW91c2Vkb3duID0gdHJ1ZTtcbiAgICAgIHRoaXMuc3RhdGUuc3RhcnRNb3VzZVggPSBldnQuY2xpZW50WDtcbiAgICAgIHRoaXMuc3RhdGUuc3RhcnRNb3VzZVkgPSBldnQuY2xpZW50WTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgSGFuZGxlcyBtb3VzZSB1cCBldmVudHNcbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2dFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLl9fb25Nb3VzZVVwID0gZnVuY3Rpb24gX19vbk1vdXNlVXAoZXZ0KSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5tb3VzZWRvd24gfHwgdGhpcy5zdGF0ZS5zdGVwID09PSBNT1ZJTkcpIHtcbiAgICAgICAgdGhpcy5fX3N0b3BNb3ZlKGV2dC5jbGllbnRYLCBldnQuY2xpZW50WSwgZXZ0LnRhcmdldCwgZXZ0LmJ1dHRvbiA9PT0gMik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEhhbmRsZXMgbW91c2UgbW92ZSBldmVudHNcbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2dFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLl9fb25Nb3VzZU1vdmUgPSBmdW5jdGlvbiBfX29uTW91c2VNb3ZlKGV2dCkge1xuICAgICAgaWYgKHRoaXMuY29uZmlnLm1vdXNlbW92ZSAmJiAodGhpcy5zdGF0ZS5tb3VzZWRvd24gfHwgdGhpcy5zdGF0ZS5zdGVwID09PSBNT1ZJTkcpKSB7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIHRoaXMuX19tb3ZlKGV2dC5jbGllbnRYLCBldnQuY2xpZW50WSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNFbXB0eSh0aGlzLnByb3Aub2JqZWN0c09ic2VydmVycykgJiYgaGFzUGFyZW50KGV2dC50YXJnZXQsIHRoaXMucHN2LmNvbnRhaW5lcikpIHtcbiAgICAgICAgdmFyIHZpZXdlclBvcyA9IGdldFBvc2l0aW9uKHRoaXMucHN2LmNvbnRhaW5lcik7XG4gICAgICAgIHZhciB2aWV3ZXJQb2ludCA9IHtcbiAgICAgICAgICB4OiBldnQuY2xpZW50WCAtIHZpZXdlclBvcy5sZWZ0LFxuICAgICAgICAgIHk6IGV2dC5jbGllbnRZIC0gdmlld2VyUG9zLnRvcFxuICAgICAgICB9O1xuICAgICAgICB2YXIgaW50ZXJzZWN0aW9ucyA9IHRoaXMucHN2LmRhdGFIZWxwZXIuZ2V0SW50ZXJzZWN0aW9ucyh2aWV3ZXJQb2ludCk7XG5cbiAgICAgICAgdmFyIGVtaXQgPSBmdW5jdGlvbiBlbWl0KG9ic2VydmVyLCBrZXksIHR5cGUpIHtcbiAgICAgICAgICBvYnNlcnZlci5saXN0ZW5lci5oYW5kbGVFdmVudChuZXcgQ3VzdG9tRXZlbnQodHlwZSwge1xuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dCxcbiAgICAgICAgICAgICAgb2JqZWN0OiBvYnNlcnZlci5vYmplY3QsXG4gICAgICAgICAgICAgIGRhdGE6IG9ic2VydmVyLm9iamVjdC51c2VyRGF0YVtrZXldLFxuICAgICAgICAgICAgICB2aWV3ZXJQb2ludDogdmlld2VyUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZWFjaCh0aGlzLnByb3Aub2JqZWN0c09ic2VydmVycywgZnVuY3Rpb24gKG9ic2VydmVyLCBrZXkpIHtcbiAgICAgICAgICB2YXIgaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9ucy5maW5kKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICByZXR1cm4gaS5vYmplY3QudXNlckRhdGFba2V5XTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChpbnRlcnNlY3Rpb24pIHtcbiAgICAgICAgICAgIGlmIChvYnNlcnZlci5vYmplY3QgJiYgaW50ZXJzZWN0aW9uLm9iamVjdCAhPT0gb2JzZXJ2ZXIub2JqZWN0KSB7XG4gICAgICAgICAgICAgIGVtaXQob2JzZXJ2ZXIsIGtleSwgT0JKRUNUX0VWRU5UUy5MRUFWRV9PQkpFQ1QpO1xuICAgICAgICAgICAgICBkZWxldGUgb2JzZXJ2ZXIub2JqZWN0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW9ic2VydmVyLm9iamVjdCkge1xuICAgICAgICAgICAgICBvYnNlcnZlci5vYmplY3QgPSBpbnRlcnNlY3Rpb24ub2JqZWN0O1xuICAgICAgICAgICAgICBlbWl0KG9ic2VydmVyLCBrZXksIE9CSkVDVF9FVkVOVFMuRU5URVJfT0JKRUNUKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVtaXQob2JzZXJ2ZXIsIGtleSwgT0JKRUNUX0VWRU5UUy5IT1ZFUl9PQkpFQ1QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAob2JzZXJ2ZXIub2JqZWN0KSB7XG4gICAgICAgICAgICBlbWl0KG9ic2VydmVyLCBrZXksIE9CSkVDVF9FVkVOVFMuTEVBVkVfT0JKRUNUKTtcbiAgICAgICAgICAgIGRlbGV0ZSBvYnNlcnZlci5vYmplY3Q7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgSGFuZGxlcyB0b3VjaCBldmVudHNcbiAgICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGV2dFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLl9fb25Ub3VjaFN0YXJ0ID0gZnVuY3Rpb24gX19vblRvdWNoU3RhcnQoZXZ0KSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgaWYgKGV2dC50b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB0aGlzLnN0YXRlLm1vdXNlZG93biA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhdGUuc3RhcnRNb3VzZVggPSBldnQudG91Y2hlc1swXS5jbGllbnRYO1xuICAgICAgICB0aGlzLnN0YXRlLnN0YXJ0TW91c2VZID0gZXZ0LnRvdWNoZXNbMF0uY2xpZW50WTtcblxuICAgICAgICBpZiAoIXRoaXMucHJvcC5sb25ndG91Y2hUaW1lb3V0KSB7XG4gICAgICAgICAgdGhpcy5wcm9wLmxvbmd0b3VjaFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0b3VjaCA9IGV2dC50b3VjaGVzWzBdO1xuXG4gICAgICAgICAgICBfdGhpczMuX19zdG9wTW92ZSh0b3VjaC5jbGllbnRYLCB0b3VjaC5jbGllbnRZLCB0b3VjaC50YXJnZXQsIHRydWUpO1xuXG4gICAgICAgICAgICBfdGhpczMucHJvcC5sb25ndG91Y2hUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICB9LCBMT05HVE9VQ0hfREVMQVkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGV2dC50b3VjaGVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICB0aGlzLnN0YXRlLm1vdXNlZG93biA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX19jYW5jZWxMb25nVG91Y2goKTtcblxuICAgICAgICBpZiAodGhpcy5jb25maWcubW91c2Vtb3ZlKSB7XG4gICAgICAgICAgdGhpcy5fX2NhbmNlbFR3b0ZpbmdlcnNPdmVybGF5KCk7XG5cbiAgICAgICAgICB0aGlzLl9fc3RhcnRNb3ZlWm9vbShldnQpO1xuXG4gICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgSGFuZGxlcyB0b3VjaCBldmVudHNcbiAgICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGV2dFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLl9fb25Ub3VjaEVuZCA9IGZ1bmN0aW9uIF9fb25Ub3VjaEVuZChldnQpIHtcbiAgICAgIHRoaXMuX19jYW5jZWxMb25nVG91Y2goKTtcblxuICAgICAgaWYgKHRoaXMuc3RhdGUubW91c2Vkb3duIHx8IHRoaXMuc3RhdGUuc3RlcCA9PT0gTU9WSU5HKSB7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIHRoaXMuX19jYW5jZWxUd29GaW5nZXJzT3ZlcmxheSgpO1xuXG4gICAgICAgIGlmIChldnQudG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICB0aGlzLl9fc3RvcE1vdmUodGhpcy5zdGF0ZS5tb3VzZVgsIHRoaXMuc3RhdGUubW91c2VZKTtcbiAgICAgICAgfSBlbHNlIGlmIChldnQudG91Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB2YXIgdG91Y2ggPSBldnQuY2hhbmdlZFRvdWNoZXNbMF07XG5cbiAgICAgICAgICB0aGlzLl9fc3RvcE1vdmUodG91Y2guY2xpZW50WCwgdG91Y2guY2xpZW50WSwgdG91Y2gudGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBIYW5kbGVzIHRvdWNoIG1vdmUgZXZlbnRzXG4gICAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBldnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5fX29uVG91Y2hNb3ZlID0gZnVuY3Rpb24gX19vblRvdWNoTW92ZShldnQpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB0aGlzLl9fY2FuY2VsTG9uZ1RvdWNoKCk7XG5cbiAgICAgIGlmICghdGhpcy5jb25maWcubW91c2Vtb3ZlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2dC50b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAodGhpcy5jb25maWcudG91Y2htb3ZlVHdvRmluZ2Vycykge1xuICAgICAgICAgIGlmICh0aGlzLnN0YXRlLm1vdXNlZG93biAmJiAhdGhpcy5wcm9wLnR3b2ZpbmdlcnNUaW1lb3V0KSB7XG4gICAgICAgICAgICB0aGlzLnByb3AudHdvZmluZ2Vyc1RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3RoaXM0LnBzdi5vdmVybGF5LnNob3coe1xuICAgICAgICAgICAgICAgIGlkOiBJRFMuVFdPX0ZJTkdFUlMsXG4gICAgICAgICAgICAgICAgaW1hZ2U6IGdlc3R1cmVJY29uLFxuICAgICAgICAgICAgICAgIHRleHQ6IF90aGlzNC5jb25maWcubGFuZy50d29GaW5nZXJzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgVFdPRklOR0VSU09WRVJMQVlfREVMQVkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLm1vdXNlZG93biB8fCB0aGlzLnN0YXRlLnN0ZXAgPT09IE1PVklORykge1xuICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHZhciB0b3VjaCA9IGV2dC50b3VjaGVzWzBdO1xuXG4gICAgICAgICAgdGhpcy5fX21vdmUodG91Y2guY2xpZW50WCwgdG91Y2guY2xpZW50WSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX19tb3ZlWm9vbShldnQpO1xuXG4gICAgICAgIHRoaXMuX19jYW5jZWxUd29GaW5nZXJzT3ZlcmxheSgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBDYW5jZWwgdGhlIGxvbmcgdG91Y2ggdGltZXIgaWYgYW55XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uX19jYW5jZWxMb25nVG91Y2ggPSBmdW5jdGlvbiBfX2NhbmNlbExvbmdUb3VjaCgpIHtcbiAgICAgIGlmICh0aGlzLnByb3AubG9uZ3RvdWNoVGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5wcm9wLmxvbmd0b3VjaFRpbWVvdXQpO1xuICAgICAgICB0aGlzLnByb3AubG9uZ3RvdWNoVGltZW91dCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IENhbmNlbCB0aGUgdHdvIGZpbmdlcnMgb3ZlcmxheSB0aW1lciBpZiBhbnlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5fX2NhbmNlbFR3b0ZpbmdlcnNPdmVybGF5ID0gZnVuY3Rpb24gX19jYW5jZWxUd29GaW5nZXJzT3ZlcmxheSgpIHtcbiAgICAgIGlmICh0aGlzLmNvbmZpZy50b3VjaG1vdmVUd29GaW5nZXJzKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3AudHdvZmluZ2Vyc1RpbWVvdXQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5wcm9wLnR3b2ZpbmdlcnNUaW1lb3V0KTtcbiAgICAgICAgICB0aGlzLnByb3AudHdvZmluZ2Vyc1RpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wc3Yub3ZlcmxheS5oaWRlKElEUy5UV09fRklOR0VSUyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEhhbmRsZXMgbW91c2Ugd2hlZWwgZXZlbnRzXG4gICAgICogQHBhcmFtIHtXaGVlbEV2ZW50fSBldnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5fX29uTW91c2VXaGVlbCA9IGZ1bmN0aW9uIF9fb25Nb3VzZVdoZWVsKGV2dCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy5jb25maWcubW91c2V3aGVlbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNvbmZpZy5tb3VzZXdoZWVsQ3RybEtleSAmJiAhdGhpcy5zdGF0ZS5jdHJsS2V5RG93bikge1xuICAgICAgICB0aGlzLnBzdi5vdmVybGF5LnNob3coe1xuICAgICAgICAgIGlkOiBJRFMuQ1RSTF9aT09NLFxuICAgICAgICAgIGltYWdlOiBtb3VzZXdoZWVsSWNvbixcbiAgICAgICAgICB0ZXh0OiB0aGlzLmNvbmZpZy5sYW5nLmN0cmxab29tXG4gICAgICAgIH0pO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5zdGF0ZS5jdHJsWm9vbVRpbWVvdXQpO1xuICAgICAgICB0aGlzLnN0YXRlLmN0cmxab29tVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczUucHN2Lm92ZXJsYXkuaGlkZShJRFMuQ1RSTF9aT09NKTtcbiAgICAgICAgfSwgQ1RSTFpPT01fVElNRU9VVCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB2YXIgZGVsdGEgPSBub3JtYWxpemVXaGVlbChldnQpLnNwaW5ZICogNSAqIHRoaXMuY29uZmlnLnpvb21TcGVlZDtcblxuICAgICAgaWYgKGRlbHRhICE9PSAwKSB7XG4gICAgICAgIHRoaXMucHN2LmR5bmFtaWNzLnpvb20uc3RlcCgtZGVsdGEsIDUpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBIYW5kbGVzIGZ1bGxzY3JlZW4gZXZlbnRzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZm9yY2VdIGZvcmNlIHN0YXRlXG4gICAgICogQGZpcmVzIFBTVi5mdWxsc2NyZWVuLXVwZGF0ZWRcbiAgICAgKiBAcGFja2FnZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5fX2Z1bGxzY3JlZW5Ub2dnbGVkID0gZnVuY3Rpb24gX19mdWxsc2NyZWVuVG9nZ2xlZChmb3JjZSkge1xuICAgICAgdGhpcy5wcm9wLmZ1bGxzY3JlZW4gPSBmb3JjZSAhPT0gdW5kZWZpbmVkID8gZm9yY2UgOiBpc0Z1bGxzY3JlZW5FbmFibGVkKHRoaXMucHN2LmNvbnRhaW5lcik7XG5cbiAgICAgIGlmICh0aGlzLmNvbmZpZy5rZXlib2FyZCkge1xuICAgICAgICBpZiAodGhpcy5wcm9wLmZ1bGxzY3JlZW4pIHtcbiAgICAgICAgICB0aGlzLnBzdi5zdGFydEtleWJvYXJkQ29udHJvbCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucHN2LnN0b3BLZXlib2FyZENvbnRyb2woKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnBzdi50cmlnZ2VyKEVWRU5UUy5GVUxMU0NSRUVOX1VQREFURUQsIHRoaXMucHJvcC5mdWxsc2NyZWVuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgUmVzZXRzIGFsbCBzdGF0ZSB2YXJpYWJsZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5fX3Jlc2V0TW92ZSA9IGZ1bmN0aW9uIF9fcmVzZXRNb3ZlKCkge1xuICAgICAgdGhpcy5zdGF0ZS5zdGVwID0gSURMRTtcbiAgICAgIHRoaXMuc3RhdGUubW91c2Vkb3duID0gZmFsc2U7XG4gICAgICB0aGlzLnN0YXRlLm1vdXNlWCA9IDA7XG4gICAgICB0aGlzLnN0YXRlLm1vdXNlWSA9IDA7XG4gICAgICB0aGlzLnN0YXRlLnN0YXJ0TW91c2VYID0gMDtcbiAgICAgIHRoaXMuc3RhdGUuc3RhcnRNb3VzZVkgPSAwO1xuICAgICAgdGhpcy5zdGF0ZS5tb3VzZUhpc3RvcnkubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgSW5pdGlhbGl6ZXMgdGhlIGNvbWJpbmVzIG1vdmUgYW5kIHpvb21cbiAgICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGV2dFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLl9fc3RhcnRNb3ZlWm9vbSA9IGZ1bmN0aW9uIF9fc3RhcnRNb3ZlWm9vbShldnQpIHtcbiAgICAgIHRoaXMucHN2Ll9fc3RvcEFsbCgpO1xuXG4gICAgICB0aGlzLl9fcmVzZXRNb3ZlKCk7XG5cbiAgICAgIHZhciBwMSA9IHtcbiAgICAgICAgeDogZXZ0LnRvdWNoZXNbMF0uY2xpZW50WCxcbiAgICAgICAgeTogZXZ0LnRvdWNoZXNbMF0uY2xpZW50WVxuICAgICAgfTtcbiAgICAgIHZhciBwMiA9IHtcbiAgICAgICAgeDogZXZ0LnRvdWNoZXNbMV0uY2xpZW50WCxcbiAgICAgICAgeTogZXZ0LnRvdWNoZXNbMV0uY2xpZW50WVxuICAgICAgfTtcbiAgICAgIHRoaXMuc3RhdGUuc3RlcCA9IE1PVklORztcbiAgICAgIHRoaXMuc3RhdGUucGluY2hEaXN0ID0gZGlzdGFuY2UocDEsIHAyKTtcbiAgICAgIHRoaXMuc3RhdGUubW91c2VYID0gKHAxLnggKyBwMi54KSAvIDI7XG4gICAgICB0aGlzLnN0YXRlLm1vdXNlWSA9IChwMS55ICsgcDIueSkgLyAyO1xuXG4gICAgICB0aGlzLl9fbG9nTW91c2VNb3ZlKHRoaXMuc3RhdGUubW91c2VYLCB0aGlzLnN0YXRlLm1vdXNlWSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFN0b3BzIHRoZSBtb3ZlbWVudFxuICAgICAqIEBkZXNjcmlwdGlvbiBJZiB0aGUgbW92ZSB0aHJlc2hvbGQgd2FzIG5vdCByZWFjaGVkIGEgY2xpY2sgZXZlbnQgaXMgdHJpZ2dlcmVkLCBvdGhlcndpc2UgYW4gYW5pbWF0aW9uIGlzIGxhdW5jaGVkIHRvIHNpbXVsYXRlIGluZXJ0aWFcbiAgICAgKiBAcGFyYW0ge2ludH0gY2xpZW50WFxuICAgICAqIEBwYXJhbSB7aW50fSBjbGllbnRZXG4gICAgICogQHBhcmFtIHtFdmVudFRhcmdldH0gW3RhcmdldF1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyaWdodGNsaWNrPWZhbHNlXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLl9fc3RvcE1vdmUgPSBmdW5jdGlvbiBfX3N0b3BNb3ZlKGNsaWVudFgsIGNsaWVudFksIHRhcmdldCwgcmlnaHRjbGljaykge1xuICAgICAgaWYgKHRhcmdldCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRhcmdldCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmIChyaWdodGNsaWNrID09PSB2b2lkIDApIHtcbiAgICAgICAgcmlnaHRjbGljayA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zdGF0ZS5zdGVwID09PSBNT1ZJTkcpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLm1vdmVJbmVydGlhKSB7XG4gICAgICAgICAgdGhpcy5fX2xvZ01vdXNlTW92ZShjbGllbnRYLCBjbGllbnRZKTtcblxuICAgICAgICAgIHRoaXMuX19zdG9wTW92ZUluZXJ0aWEoY2xpZW50WCwgY2xpZW50WSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fX3Jlc2V0TW92ZSgpO1xuXG4gICAgICAgICAgdGhpcy5wc3YucmVzZXRJZGxlVGltZXIoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLm1vdXNlZG93bikge1xuICAgICAgICB0aGlzLnBzdi5zdG9wQW5pbWF0aW9uKCk7XG5cbiAgICAgICAgdGhpcy5fX2NsaWNrKGNsaWVudFgsIGNsaWVudFksIHRhcmdldCwgcmlnaHRjbGljayk7XG5cbiAgICAgICAgdGhpcy5fX3Jlc2V0TW92ZSgpO1xuXG4gICAgICAgIHRoaXMucHN2LnJlc2V0SWRsZVRpbWVyKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFBlcmZvcm1zIGFuIGFuaW1hdGlvbiB0byBzaW11bGF0ZSBpbmVydGlhIHdoZW4gdGhlIG1vdmVtZW50IHN0b3BzXG4gICAgICogQHBhcmFtIHtpbnR9IGNsaWVudFhcbiAgICAgKiBAcGFyYW0ge2ludH0gY2xpZW50WVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLl9fc3RvcE1vdmVJbmVydGlhID0gZnVuY3Rpb24gX19zdG9wTW92ZUluZXJ0aWEoY2xpZW50WCwgY2xpZW50WSkge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgIC8vIGdldCBkaXJlY3Rpb24gYXQgZW5kIG9mIG1vdmVtZW50XG4gICAgICB2YXIgY3VydmUgPSBuZXcgdGhyZWUuU3BsaW5lQ3VydmUodGhpcy5zdGF0ZS5tb3VzZUhpc3RvcnkubWFwKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciB4ID0gX3JlZlsxXSxcbiAgICAgICAgICAgIHkgPSBfcmVmWzJdO1xuICAgICAgICByZXR1cm4gbmV3IHRocmVlLlZlY3RvcjIoeCwgeSk7XG4gICAgICB9KSk7XG4gICAgICB2YXIgZGlyZWN0aW9uID0gY3VydmUuZ2V0VGFuZ2VudCgxKTsgLy8gYXZlcmFnZSBzcGVlZFxuXG4gICAgICB2YXIgc3BlZWQgPSB0aGlzLnN0YXRlLm1vdXNlSGlzdG9yeS5zbGljZSgxKS5yZWR1Y2UoZnVuY3Rpb24gKF9yZWYyLCBjdXJyKSB7XG4gICAgICAgIHZhciB0b3RhbCA9IF9yZWYyLnRvdGFsLFxuICAgICAgICAgICAgcHJldiA9IF9yZWYyLnByZXY7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdG90YWw6IHRvdGFsICsgZGlzdGFuY2Uoe1xuICAgICAgICAgICAgeDogcHJldlsxXSxcbiAgICAgICAgICAgIHk6IHByZXZbMl1cbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICB4OiBjdXJyWzFdLFxuICAgICAgICAgICAgeTogY3VyclsyXVxuICAgICAgICAgIH0pIC8gKGN1cnJbMF0gLSBwcmV2WzBdKSxcbiAgICAgICAgICBwcmV2OiBjdXJyXG4gICAgICAgIH07XG4gICAgICB9LCB7XG4gICAgICAgIHRvdGFsOiAwLFxuICAgICAgICBwcmV2OiB0aGlzLnN0YXRlLm1vdXNlSGlzdG9yeVswXVxuICAgICAgfSkudG90YWwgLyB0aGlzLnN0YXRlLm1vdXNlSGlzdG9yeS5sZW5ndGg7XG5cbiAgICAgIGlmICghc3BlZWQpIHtcbiAgICAgICAgdGhpcy5fX3Jlc2V0TW92ZSgpO1xuXG4gICAgICAgIHRoaXMucHN2LnJlc2V0SWRsZVRpbWVyKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGF0ZS5zdGVwID0gSU5FUlRJQTtcbiAgICAgIHZhciBjdXJyZW50Q2xpZW50WCA9IGNsaWVudFg7XG4gICAgICB2YXIgY3VycmVudENsaWVudFkgPSBjbGllbnRZO1xuICAgICAgdGhpcy5wcm9wLmFuaW1hdGlvblByb21pc2UgPSBuZXcgQW5pbWF0aW9uKHtcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIHNwZWVkOiB7XG4gICAgICAgICAgICBzdGFydDogc3BlZWQsXG4gICAgICAgICAgICBlbmQ6IDBcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGR1cmF0aW9uOiAxMDAwLFxuICAgICAgICBlYXNpbmc6ICdvdXRRdWFkJyxcbiAgICAgICAgb25UaWNrOiBmdW5jdGlvbiBvblRpY2socHJvcGVydGllcykge1xuICAgICAgICAgIC8vIDMgaXMgYSBtYWdpYyBudW1iZXJcbiAgICAgICAgICBjdXJyZW50Q2xpZW50WCArPSBwcm9wZXJ0aWVzLnNwZWVkICogZGlyZWN0aW9uLnggKiAzICogU1lTVEVNLnBpeGVsUmF0aW87XG4gICAgICAgICAgY3VycmVudENsaWVudFkgKz0gcHJvcGVydGllcy5zcGVlZCAqIGRpcmVjdGlvbi55ICogMyAqIFNZU1RFTS5waXhlbFJhdGlvO1xuXG4gICAgICAgICAgX3RoaXM2Ll9fYXBwbHlNb3ZlKGN1cnJlbnRDbGllbnRYLCBjdXJyZW50Q2xpZW50WSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5wcm9wLmFuaW1hdGlvblByb21pc2UudGhlbihmdW5jdGlvbiAoZG9uZSkge1xuICAgICAgICBfdGhpczYucHJvcC5hbmltYXRpb25Qcm9taXNlID0gbnVsbDtcblxuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIF90aGlzNi5fX3Jlc2V0TW92ZSgpO1xuXG4gICAgICAgICAgX3RoaXM2LnBzdi5yZXNldElkbGVUaW1lcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgVHJpZ2dlcnMgYW4gZXZlbnQgd2l0aCBhbGwgY29vcmRpbmF0ZXMgd2hlbiBhIHNpbXBsZSBjbGljayBpcyBwZXJmb3JtZWRcbiAgICAgKiBAcGFyYW0ge2ludH0gY2xpZW50WFxuICAgICAqIEBwYXJhbSB7aW50fSBjbGllbnRZXG4gICAgICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmlnaHRjbGljaz1mYWxzZV1cbiAgICAgKiBAZmlyZXMgUFNWLmNsaWNrXG4gICAgICogQGZpcmVzIFBTVi5kYmxjbGlja1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLl9fY2xpY2sgPSBmdW5jdGlvbiBfX2NsaWNrKGNsaWVudFgsIGNsaWVudFksIHRhcmdldCwgcmlnaHRjbGljaykge1xuICAgICAgdmFyIF90aGlzNyA9IHRoaXM7XG5cbiAgICAgIGlmIChyaWdodGNsaWNrID09PSB2b2lkIDApIHtcbiAgICAgICAgcmlnaHRjbGljayA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgYm91bmRpbmdSZWN0ID0gdGhpcy5wc3YuY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7UFNWLkNsaWNrRGF0YX1cbiAgICAgICAqL1xuXG4gICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgcmlnaHRjbGljazogcmlnaHRjbGljayxcbiAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgIGNsaWVudFg6IGNsaWVudFgsXG4gICAgICAgIGNsaWVudFk6IGNsaWVudFksXG4gICAgICAgIHZpZXdlclg6IGNsaWVudFggLSBib3VuZGluZ1JlY3QubGVmdCxcbiAgICAgICAgdmlld2VyWTogY2xpZW50WSAtIGJvdW5kaW5nUmVjdC50b3BcbiAgICAgIH07XG4gICAgICB2YXIgaW50ZXJzZWN0aW9ucyA9IHRoaXMucHN2LmRhdGFIZWxwZXIuZ2V0SW50ZXJzZWN0aW9ucyh7XG4gICAgICAgIHg6IGRhdGEudmlld2VyWCxcbiAgICAgICAgeTogZGF0YS52aWV3ZXJZXG4gICAgICB9KTtcbiAgICAgIHZhciBzcGhlcmVJbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb25zLmZpbmQoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIGkub2JqZWN0LnVzZXJEYXRhW01FU0hfVVNFUl9EQVRBXTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoc3BoZXJlSW50ZXJzZWN0aW9uKSB7XG4gICAgICAgIHZhciBzcGhlcmljYWxDb29yZHMgPSB0aGlzLnBzdi5kYXRhSGVscGVyLnZlY3RvcjNUb1NwaGVyaWNhbENvb3JkcyhzcGhlcmVJbnRlcnNlY3Rpb24ucG9pbnQpO1xuICAgICAgICBkYXRhLmxvbmdpdHVkZSA9IHNwaGVyaWNhbENvb3Jkcy5sb25naXR1ZGU7XG4gICAgICAgIGRhdGEubGF0aXR1ZGUgPSBzcGhlcmljYWxDb29yZHMubGF0aXR1ZGU7XG4gICAgICAgIGRhdGEub2JqZWN0cyA9IGludGVyc2VjdGlvbnMubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgcmV0dXJuIGkub2JqZWN0O1xuICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICByZXR1cm4gIW8udXNlckRhdGFbTUVTSF9VU0VSX0RBVEFdO1xuICAgICAgICB9KTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciB0ZXh0dXJlQ29vcmRzID0gdGhpcy5wc3YuZGF0YUhlbHBlci5zcGhlcmljYWxDb29yZHNUb1RleHR1cmVDb29yZHMoZGF0YSk7XG4gICAgICAgICAgZGF0YS50ZXh0dXJlWCA9IHRleHR1cmVDb29yZHMueDtcbiAgICAgICAgICBkYXRhLnRleHR1cmVZID0gdGV4dHVyZUNvb3Jkcy55O1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZGF0YS50ZXh0dXJlWCA9IE5hTjtcbiAgICAgICAgICBkYXRhLnRleHR1cmVZID0gTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmRibGNsaWNrVGltZW91dCkge1xuICAgICAgICAgIHRoaXMucHN2LnRyaWdnZXIoRVZFTlRTLkNMSUNLLCBkYXRhKTtcbiAgICAgICAgICB0aGlzLnN0YXRlLmRibGNsaWNrRGF0YSA9IGNsb25lKGRhdGEpO1xuICAgICAgICAgIHRoaXMuc3RhdGUuZGJsY2xpY2tUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczcuc3RhdGUuZGJsY2xpY2tUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgIF90aGlzNy5zdGF0ZS5kYmxjbGlja0RhdGEgPSBudWxsO1xuICAgICAgICAgIH0sIERCTENMSUNLX0RFTEFZKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5zdGF0ZS5kYmxjbGlja0RhdGEuY2xpZW50WCAtIGRhdGEuY2xpZW50WCkgPCB0aGlzLnN0YXRlLm1vdmVUaHJlc2hvbGQgJiYgTWF0aC5hYnModGhpcy5zdGF0ZS5kYmxjbGlja0RhdGEuY2xpZW50WSAtIGRhdGEuY2xpZW50WSkgPCB0aGlzLnN0YXRlLm1vdmVUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgIHRoaXMucHN2LnRyaWdnZXIoRVZFTlRTLkRPVUJMRV9DTElDSywgdGhpcy5zdGF0ZS5kYmxjbGlja0RhdGEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnN0YXRlLmRibGNsaWNrVGltZW91dCk7XG4gICAgICAgICAgdGhpcy5zdGF0ZS5kYmxjbGlja1RpbWVvdXQgPSBudWxsO1xuICAgICAgICAgIHRoaXMuc3RhdGUuZGJsY2xpY2tEYXRhID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBTdGFydHMgbW92aW5nIHdoZW4gY3Jvc3NpbmcgbW92ZVRocmVzaG9sZCBhbmQgcGVyZm9ybXMgbW92ZW1lbnRcbiAgICAgKiBAcGFyYW0ge2ludH0gY2xpZW50WFxuICAgICAqIEBwYXJhbSB7aW50fSBjbGllbnRZXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uX19tb3ZlID0gZnVuY3Rpb24gX19tb3ZlKGNsaWVudFgsIGNsaWVudFkpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlLm1vdXNlZG93biAmJiAoTWF0aC5hYnMoY2xpZW50WCAtIHRoaXMuc3RhdGUuc3RhcnRNb3VzZVgpID49IHRoaXMuc3RhdGUubW92ZVRocmVzaG9sZCB8fCBNYXRoLmFicyhjbGllbnRZIC0gdGhpcy5zdGF0ZS5zdGFydE1vdXNlWSkgPj0gdGhpcy5zdGF0ZS5tb3ZlVGhyZXNob2xkKSkge1xuICAgICAgICB0aGlzLnBzdi5fX3N0b3BBbGwoKTtcblxuICAgICAgICB0aGlzLl9fcmVzZXRNb3ZlKCk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZS5zdGVwID0gTU9WSU5HO1xuICAgICAgICB0aGlzLnN0YXRlLm1vdXNlWCA9IGNsaWVudFg7XG4gICAgICAgIHRoaXMuc3RhdGUubW91c2VZID0gY2xpZW50WTtcblxuICAgICAgICB0aGlzLl9fbG9nTW91c2VNb3ZlKGNsaWVudFgsIGNsaWVudFkpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLnN0ZXAgPT09IE1PVklORykge1xuICAgICAgICB0aGlzLl9fYXBwbHlNb3ZlKGNsaWVudFgsIGNsaWVudFkpO1xuXG4gICAgICAgIHRoaXMuX19sb2dNb3VzZU1vdmUoY2xpZW50WCwgY2xpZW50WSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFJhdyBtZXRob2QgZm9yIG1vdmVtZW50LCBjYWxsZWQgZnJvbSBtb3VzZSBldmVudCBhbmQgbW92ZSBpbmVydGlhXG4gICAgICogQHBhcmFtIHtpbnR9IGNsaWVudFhcbiAgICAgKiBAcGFyYW0ge2ludH0gY2xpZW50WVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLl9fYXBwbHlNb3ZlID0gZnVuY3Rpb24gX19hcHBseU1vdmUoY2xpZW50WCwgY2xpZW50WSkge1xuICAgICAgdmFyIHJvdGF0aW9uID0ge1xuICAgICAgICBsb25naXR1ZGU6IChjbGllbnRYIC0gdGhpcy5zdGF0ZS5tb3VzZVgpIC8gdGhpcy5wcm9wLnNpemUud2lkdGggKiB0aGlzLmNvbmZpZy5tb3ZlU3BlZWQgKiB0aHJlZS5NYXRoVXRpbHMuZGVnVG9SYWQodGhpcy5wcm9wLmxpdHRsZVBsYW5ldCA/IDkwIDogdGhpcy5wcm9wLmhGb3YpLFxuICAgICAgICBsYXRpdHVkZTogKGNsaWVudFkgLSB0aGlzLnN0YXRlLm1vdXNlWSkgLyB0aGlzLnByb3Auc2l6ZS5oZWlnaHQgKiB0aGlzLmNvbmZpZy5tb3ZlU3BlZWQgKiB0aHJlZS5NYXRoVXRpbHMuZGVnVG9SYWQodGhpcy5wcm9wLmxpdHRsZVBsYW5ldCA/IDkwIDogdGhpcy5wcm9wLnZGb3YpXG4gICAgICB9O1xuICAgICAgdmFyIGN1cnJlbnRQb3NpdGlvbiA9IHRoaXMucHN2LmdldFBvc2l0aW9uKCk7XG4gICAgICB0aGlzLnBzdi5yb3RhdGUoe1xuICAgICAgICBsb25naXR1ZGU6IGN1cnJlbnRQb3NpdGlvbi5sb25naXR1ZGUgLSByb3RhdGlvbi5sb25naXR1ZGUsXG4gICAgICAgIGxhdGl0dWRlOiBjdXJyZW50UG9zaXRpb24ubGF0aXR1ZGUgKyByb3RhdGlvbi5sYXRpdHVkZVxuICAgICAgfSk7XG4gICAgICB0aGlzLnN0YXRlLm1vdXNlWCA9IGNsaWVudFg7XG4gICAgICB0aGlzLnN0YXRlLm1vdXNlWSA9IGNsaWVudFk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFBlcmZvbXMgY29tYmluZWQgbW92ZSBhbmQgem9vbVxuICAgICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZXZ0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uX19tb3ZlWm9vbSA9IGZ1bmN0aW9uIF9fbW92ZVpvb20oZXZ0KSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5zdGVwID09PSBNT1ZJTkcpIHtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHZhciBwMSA9IHtcbiAgICAgICAgICB4OiBldnQudG91Y2hlc1swXS5jbGllbnRYLFxuICAgICAgICAgIHk6IGV2dC50b3VjaGVzWzBdLmNsaWVudFlcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHAyID0ge1xuICAgICAgICAgIHg6IGV2dC50b3VjaGVzWzFdLmNsaWVudFgsXG4gICAgICAgICAgeTogZXZ0LnRvdWNoZXNbMV0uY2xpZW50WVxuICAgICAgICB9O1xuICAgICAgICB2YXIgcCA9IGRpc3RhbmNlKHAxLCBwMik7XG4gICAgICAgIHZhciBkZWx0YSA9IChwIC0gdGhpcy5zdGF0ZS5waW5jaERpc3QpIC8gU1lTVEVNLnBpeGVsUmF0aW8gKiB0aGlzLmNvbmZpZy56b29tU3BlZWQ7XG4gICAgICAgIHRoaXMucHN2Lnpvb20odGhpcy5wc3YuZ2V0Wm9vbUxldmVsKCkgKyBkZWx0YSk7XG5cbiAgICAgICAgdGhpcy5fX21vdmUoKHAxLnggKyBwMi54KSAvIDIsIChwMS55ICsgcDIueSkgLyAyKTtcblxuICAgICAgICB0aGlzLnN0YXRlLnBpbmNoRGlzdCA9IHA7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFN0b3JlcyBlYWNoIG1vdXNlIHBvc2l0aW9uIGR1cmluZyBhIG1vdXNlIG1vdmVcbiAgICAgKiBAZGVzY3JpcHRpb24gUG9zaXRpb25zIG9sZGVyIHRoYW4gXCJJTkVSVElBX1dJTkRPV1wiIGFyZSByZW1vdmVkPGJyPlxuICAgICAqICAgICBQb3NpdGlvbnMgYmVmb3JlIGEgcGF1c2Ugb2YgXCJJTkVSVElBX1dJTkRPV1wiIC8gMTAgYXJlIHJlbW92ZWRcbiAgICAgKiBAcGFyYW0ge2ludH0gY2xpZW50WFxuICAgICAqIEBwYXJhbSB7aW50fSBjbGllbnRZXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uX19sb2dNb3VzZU1vdmUgPSBmdW5jdGlvbiBfX2xvZ01vdXNlTW92ZShjbGllbnRYLCBjbGllbnRZKSB7XG4gICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgIHZhciBsYXN0ID0gdGhpcy5zdGF0ZS5tb3VzZUhpc3RvcnkubGVuZ3RoID8gdGhpcy5zdGF0ZS5tb3VzZUhpc3RvcnlbdGhpcy5zdGF0ZS5tb3VzZUhpc3RvcnkubGVuZ3RoIC0gMV0gOiBbMCwgLTEsIC0xXTsgLy8gYXZvaWQgZHVwbGljYXRlc1xuXG4gICAgICBpZiAobGFzdFsxXSA9PT0gY2xpZW50WCAmJiBsYXN0WzJdID09PSBjbGllbnRZKSB7XG4gICAgICAgIGxhc3RbMF0gPSBub3c7XG4gICAgICB9IGVsc2UgaWYgKG5vdyA9PT0gbGFzdFswXSkge1xuICAgICAgICBsYXN0WzFdID0gY2xpZW50WDtcbiAgICAgICAgbGFzdFsyXSA9IGNsaWVudFk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXRlLm1vdXNlSGlzdG9yeS5wdXNoKFtub3csIGNsaWVudFgsIGNsaWVudFldKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByZXZpb3VzID0gbnVsbDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN0YXRlLm1vdXNlSGlzdG9yeS5sZW5ndGg7KSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLm1vdXNlSGlzdG9yeVtpXVswXSA8IG5vdyAtIElORVJUSUFfV0lORE9XKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZS5tb3VzZUhpc3Rvcnkuc3BsaWNlKGksIDEpO1xuICAgICAgICB9IGVsc2UgaWYgKHByZXZpb3VzICYmIHRoaXMuc3RhdGUubW91c2VIaXN0b3J5W2ldWzBdIC0gcHJldmlvdXMgPiBJTkVSVElBX1dJTkRPVyAvIDEwKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZS5tb3VzZUhpc3Rvcnkuc3BsaWNlKDAsIGkpO1xuICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgIHByZXZpb3VzID0gdGhpcy5zdGF0ZS5tb3VzZUhpc3RvcnlbaV1bMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXMgPSB0aGlzLnN0YXRlLm1vdXNlSGlzdG9yeVtpXVswXTtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIEV2ZW50c0hhbmRsZXI7XG4gIH0oQWJzdHJhY3RTZXJ2aWNlKTtcblxuICAvKipcbiAgICogQHN1bW1hcnkgVmlld2VyIGFuZCByZW5kZXJlclxuICAgKiBAZXh0ZW5kcyBQU1Yuc2VydmljZXMuQWJzdHJhY3RTZXJ2aWNlXG4gICAqIEBtZW1iZXJvZiBQU1Yuc2VydmljZXNcbiAgICovXG5cbiAgdmFyIFJlbmRlcmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQWJzdHJhY3RTZXJ2aWNlKSB7XG4gICAgX2luaGVyaXRzTG9vc2UoUmVuZGVyZXIsIF9BYnN0cmFjdFNlcnZpY2UpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQU1YuVmlld2VyfSBwc3ZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSZW5kZXJlcihwc3YpIHtcbiAgICAgIHZhciBfdGhpcyRtZXNoJHVzZXJEYXRhO1xuXG4gICAgICB2YXIgX3RoaXM7XG5cbiAgICAgIF90aGlzID0gX0Fic3RyYWN0U2VydmljZS5jYWxsKHRoaXMsIHBzdikgfHwgdGhpcztcbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7ZXh0ZXJuYWw6VEhSRUUuV2ViR0xSZW5kZXJlcn1cbiAgICAgICAqIEByZWFkb25seVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG5cbiAgICAgIF90aGlzLnJlbmRlcmVyID0gbmV3IHRocmVlLldlYkdMUmVuZGVyZXIoe1xuICAgICAgICBhbHBoYTogdHJ1ZSxcbiAgICAgICAgYW50aWFsaWFzOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgX3RoaXMucmVuZGVyZXIuc2V0UGl4ZWxSYXRpbyhTWVNURU0ucGl4ZWxSYXRpbyk7XG5cbiAgICAgIF90aGlzLnJlbmRlcmVyLmRvbUVsZW1lbnQuY2xhc3NOYW1lID0gJ3Bzdi1jYW52YXMnO1xuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtleHRlcm5hbDpUSFJFRS5TY2VuZX1cbiAgICAgICAqIEByZWFkb25seVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG5cbiAgICAgIF90aGlzLnNjZW5lID0gbmV3IHRocmVlLlNjZW5lKCk7XG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge2V4dGVybmFsOlRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhfVxuICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cblxuICAgICAgX3RoaXMuY2FtZXJhID0gbmV3IHRocmVlLlBlcnNwZWN0aXZlQ2FtZXJhKDUwLCAxNiAvIDksIDAuMSwgMiAqIFNQSEVSRV9SQURJVVMpO1xuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtleHRlcm5hbDpUSFJFRS5NZXNofVxuICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cblxuICAgICAgX3RoaXMubWVzaCA9IF90aGlzLnBzdi5hZGFwdGVyLmNyZWF0ZU1lc2goKTtcbiAgICAgIF90aGlzLm1lc2gudXNlckRhdGEgPSAoX3RoaXMkbWVzaCR1c2VyRGF0YSA9IHt9LCBfdGhpcyRtZXNoJHVzZXJEYXRhW01FU0hfVVNFUl9EQVRBXSA9IHRydWUsIF90aGlzJG1lc2gkdXNlckRhdGEpO1xuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtleHRlcm5hbDpUSFJFRS5Hcm91cH1cbiAgICAgICAqIEByZWFkb25seVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgICBfdGhpcy5tZXNoQ29udGFpbmVyID0gbmV3IHRocmVlLkdyb3VwKCk7XG5cbiAgICAgIF90aGlzLm1lc2hDb250YWluZXIuYWRkKF90aGlzLm1lc2gpO1xuXG4gICAgICBfdGhpcy5zY2VuZS5hZGQoX3RoaXMubWVzaENvbnRhaW5lcik7XG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge2V4dGVybmFsOlRIUkVFLlJheWNhc3Rlcn1cbiAgICAgICAqIEByZWFkb25seVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG5cblxuICAgICAgX3RoaXMucmF5Y2FzdGVyID0gbmV3IHRocmVlLlJheWNhc3RlcigpO1xuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICAgIF90aGlzLnRpbWVzdGFtcCA9IG51bGw7XG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICAgIF90aGlzLnJlYWR5ID0gZmFsc2U7XG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge0hUTUxFbGVtZW50fVxuICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgKiBAcGFja2FnZVxuICAgICAgICovXG5cbiAgICAgIF90aGlzLmNhbnZhc0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgX3RoaXMuY2FudmFzQ29udGFpbmVyLmNsYXNzTmFtZSA9ICdwc3YtY2FudmFzLWNvbnRhaW5lcic7XG4gICAgICBfdGhpcy5jYW52YXNDb250YWluZXIuc3R5bGUuYmFja2dyb3VuZCA9IF90aGlzLnBzdi5jb25maWcuY2FudmFzQmFja2dyb3VuZDtcbiAgICAgIF90aGlzLmNhbnZhc0NvbnRhaW5lci5zdHlsZS5jdXJzb3IgPSBfdGhpcy5wc3YuY29uZmlnLm1vdXNlbW92ZSA/ICdtb3ZlJyA6ICdkZWZhdWx0JztcblxuICAgICAgX3RoaXMuY2FudmFzQ29udGFpbmVyLmFwcGVuZENoaWxkKF90aGlzLnJlbmRlcmVyLmRvbUVsZW1lbnQpO1xuXG4gICAgICBfdGhpcy5wc3YuY29udGFpbmVyLmFwcGVuZENoaWxkKF90aGlzLmNhbnZhc0NvbnRhaW5lcik7XG5cbiAgICAgIHBzdi5vbihFVkVOVFMuU0laRV9VUERBVEVELCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgICBwc3Yub24oRVZFTlRTLlpPT01fVVBEQVRFRCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgICAgcHN2Lm9uKEVWRU5UUy5QT1NJVElPTl9VUERBVEVELCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgICBwc3Yub24oRVZFTlRTLkNPTkZJR19DSEFOR0VELCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICAgIF90aGlzLmhpZGUoKTtcblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cblxuXG4gICAgdmFyIF9wcm90byA9IFJlbmRlcmVyLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIC8vIGNhbmNlbCByZW5kZXIgbG9vcFxuICAgICAgdGhpcy5yZW5kZXJlci5zZXRBbmltYXRpb25Mb29wKG51bGwpOyAvLyBkZXN0cm95IFRocmVlSlMgdmlld1xuXG4gICAgICB0aGlzLl9fY2xlYW5USFJFRVNjZW5lKHRoaXMuc2NlbmUpOyAvLyByZW1vdmUgY29udGFpbmVyXG5cblxuICAgICAgdGhpcy5wc3YuY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuY2FudmFzQ29udGFpbmVyKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmNhbnZhc0NvbnRhaW5lcjtcbiAgICAgIGRlbGV0ZSB0aGlzLnJlbmRlcmVyO1xuICAgICAgZGVsZXRlIHRoaXMuc2NlbmU7XG4gICAgICBkZWxldGUgdGhpcy5jYW1lcmE7XG4gICAgICBkZWxldGUgdGhpcy5tZXNoO1xuICAgICAgZGVsZXRlIHRoaXMubWVzaENvbnRhaW5lcjtcbiAgICAgIGRlbGV0ZSB0aGlzLnJheWNhc3RlcjtcblxuICAgICAgX0Fic3RyYWN0U2VydmljZS5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBIYW5kbGVzIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2dFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24gaGFuZGxlRXZlbnQoZXZ0KSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICAgICAgc3dpdGNoIChldnQudHlwZSkge1xuICAgICAgICAvLyBAZm9ybWF0dGVyOm9mZlxuICAgICAgICBjYXNlIEVWRU5UUy5TSVpFX1VQREFURUQ6XG4gICAgICAgICAgdGhpcy5fX29uU2l6ZVVwZGF0ZWQoKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgRVZFTlRTLlpPT01fVVBEQVRFRDpcbiAgICAgICAgICB0aGlzLl9fb25ab29tVXBkYXRlZCgpO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBFVkVOVFMuUE9TSVRJT05fVVBEQVRFRDpcbiAgICAgICAgICB0aGlzLl9fb25Qb3NpdGlvblVwZGF0ZWQoKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgRVZFTlRTLkNPTkZJR19DSEFOR0VEOlxuICAgICAgICAgIGlmIChldnQuYXJnc1swXS5pbmNsdWRlcygnZmlzaGV5ZScpKSB7XG4gICAgICAgICAgICB0aGlzLl9fb25Qb3NpdGlvblVwZGF0ZWQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZXZ0LmFyZ3NbMF0uaW5jbHVkZXMoJ21vdXNlbW92ZScpKSB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhc0NvbnRhaW5lci5zdHlsZS5jdXJzb3IgPSB0aGlzLnBzdi5jb25maWcubW91c2Vtb3ZlID8gJ21vdmUnIDogJ2RlZmF1bHQnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBAZm9ybWF0dGVyOm9uXG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlICovXG5cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgSGlkZXMgdGhlIHZpZXdlclxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5oaWRlID0gZnVuY3Rpb24gaGlkZSgpIHtcbiAgICAgIHRoaXMuY2FudmFzQ29udGFpbmVyLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBTaG93cyB0aGUgdmlld2VyXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLnNob3cgPSBmdW5jdGlvbiBzaG93KCkge1xuICAgICAgdGhpcy5jYW52YXNDb250YWluZXIuc3R5bGUub3BhY2l0eSA9IDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFVwZGF0ZXMgdGhlIHNpemUgb2YgdGhlIHJlbmRlcmVyIGFuZCB0aGUgYXNwZWN0IG9mIHRoZSBjYW1lcmFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5fX29uU2l6ZVVwZGF0ZWQgPSBmdW5jdGlvbiBfX29uU2l6ZVVwZGF0ZWQoKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLnNldFNpemUodGhpcy5wcm9wLnNpemUud2lkdGgsIHRoaXMucHJvcC5zaXplLmhlaWdodCk7XG4gICAgICB0aGlzLmNhbWVyYS5hc3BlY3QgPSB0aGlzLnByb3AuYXNwZWN0O1xuICAgICAgdGhpcy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgICAgdGhpcy5wcm9wLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgVXBkYXRlcyB0aGUgZm92IG9mIHRoZSBjYW1lcmFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5fX29uWm9vbVVwZGF0ZWQgPSBmdW5jdGlvbiBfX29uWm9vbVVwZGF0ZWQoKSB7XG4gICAgICB0aGlzLmNhbWVyYS5mb3YgPSB0aGlzLnByb3AudkZvdjtcbiAgICAgIHRoaXMuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAgIHRoaXMucHJvcC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFVwZGF0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBjYW1lcmFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5fX29uUG9zaXRpb25VcGRhdGVkID0gZnVuY3Rpb24gX19vblBvc2l0aW9uVXBkYXRlZCgpIHtcbiAgICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLnNldCgwLCAwLCAwKTtcbiAgICAgIHRoaXMuY2FtZXJhLmxvb2tBdCh0aGlzLnByb3AuZGlyZWN0aW9uKTtcblxuICAgICAgaWYgKHRoaXMuY29uZmlnLmZpc2hleWUpIHtcbiAgICAgICAgdGhpcy5jYW1lcmEucG9zaXRpb24uY29weSh0aGlzLnByb3AuZGlyZWN0aW9uKS5tdWx0aXBseVNjYWxhcih0aGlzLmNvbmZpZy5maXNoZXllIC8gMikubmVnYXRlKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHJvcC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IE1haW4gZXZlbnQgbG9vcCwgY2FsbHMge0BsaW5rIHJlbmRlcn0gaWYgYHByb3AubmVlZHNVcGRhdGVgIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZXN0YW1wXG4gICAgICogQGZpcmVzIFBTVi5iZWZvcmUtcmVuZGVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uX19yZW5kZXJMb29wID0gZnVuY3Rpb24gX19yZW5kZXJMb29wKHRpbWVzdGFtcCkge1xuICAgICAgdmFyIGVsYXBzZWQgPSB0aGlzLnRpbWVzdGFtcCAhPT0gbnVsbCA/IHRpbWVzdGFtcCAtIHRoaXMudGltZXN0YW1wIDogMDtcbiAgICAgIHRoaXMudGltZXN0YW1wID0gdGltZXN0YW1wO1xuICAgICAgdGhpcy5wc3YudHJpZ2dlcihFVkVOVFMuQkVGT1JFX1JFTkRFUiwgdGltZXN0YW1wLCBlbGFwc2VkKTtcbiAgICAgIGVhY2godGhpcy5wc3YuZHluYW1pY3MsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLnVwZGF0ZShlbGFwc2VkKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5wcm9wLmlkbGVUaW1lID4gMCAmJiB0aW1lc3RhbXAgLSB0aGlzLnByb3AuaWRsZVRpbWUgPiB0aGlzLmNvbmZpZy5hdXRvcm90YXRlRGVsYXkpIHtcbiAgICAgICAgdGhpcy5wc3Yuc3RhcnRBdXRvcm90YXRlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnByb3AubmVlZHNVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgdGhpcy5wcm9wLm5lZWRzVXBkYXRlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFBlcmZvcm1zIGEgcmVuZGVyXG4gICAgICogQGRlc2NyaXB0aW9uIERvIG5vdCBjYWxsIHRoaXMgbWV0aG9kIGRpcmVjdGx5LCBpbnN0ZWFkIGNhbGxcbiAgICAgKiB7QGxpbmsgUFNWLlZpZXdlciNuZWVkc1VwZGF0ZX0gb24ge0BsaW5rIFBTVi5ldmVudDpiZWZvcmUtcmVuZGVyfS5cbiAgICAgKiBAZmlyZXMgUFNWLnJlbmRlclxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSk7XG4gICAgICB0aGlzLnBzdi50cmlnZ2VyKEVWRU5UUy5SRU5ERVIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBBcHBsaWVzIHRoZSB0ZXh0dXJlIHRvIHRoZSBzY2VuZSwgY3JlYXRlcyB0aGUgc2NlbmUgaWYgbmVlZGVkXG4gICAgICogQHBhcmFtIHtQU1YuVGV4dHVyZURhdGF9IHRleHR1cmVEYXRhXG4gICAgICogQGZpcmVzIFBTVi5wYW5vcmFtYS1sb2FkZWRcbiAgICAgKiBAcGFja2FnZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5zZXRUZXh0dXJlID0gZnVuY3Rpb24gc2V0VGV4dHVyZSh0ZXh0dXJlRGF0YSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMucHJvcC5wYW5vRGF0YSA9IHRleHR1cmVEYXRhLnBhbm9EYXRhO1xuICAgICAgdGhpcy5wc3YuYWRhcHRlci5zZXRUZXh0dXJlKHRoaXMubWVzaCwgdGV4dHVyZURhdGEpO1xuXG4gICAgICBpZiAoIXRoaXMucmVhZHkpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRBbmltYXRpb25Mb29wKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5fX3JlbmRlckxvb3AodCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wc3YubmVlZHNVcGRhdGUoKTtcbiAgICAgIHRoaXMucHN2LnRyaWdnZXIoRVZFTlRTLlBBTk9SQU1BX0xPQURFRCwgdGV4dHVyZURhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBBcHBsaWVzIHRoZSBvdmVybGF5IHRvIHRoZSBtZXNoXG4gICAgICogQHBhcmFtIHtQU1YuVGV4dHVyZURhdGF9IHRleHR1cmVEYXRhXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wYWNpdHlcbiAgICAgKiBAcGFja2FnZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5zZXRPdmVybGF5ID0gZnVuY3Rpb24gc2V0T3ZlcmxheSh0ZXh0dXJlRGF0YSwgb3BhY2l0eSkge1xuICAgICAgdGhpcy5wc3YuYWRhcHRlci5zZXRPdmVybGF5KHRoaXMubWVzaCwgdGV4dHVyZURhdGEsIG9wYWNpdHkpO1xuICAgICAgdGhpcy5wc3YubmVlZHNVcGRhdGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgQXBwbHkgYSBwYW5vcmFtYSBkYXRhIHBvc2UgdG8gYSBNZXNoXG4gICAgICogQHBhcmFtIHtQU1YuUGFub0RhdGF9IFtwYW5vRGF0YV1cbiAgICAgKiBAcGFyYW0ge2V4dGVybmFsOlRIUkVFLk1lc2h9IFttZXNoPXRoaXMubWVzaF1cbiAgICAgKiBAcGFja2FnZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5zZXRQYW5vcmFtYVBvc2UgPSBmdW5jdGlvbiBzZXRQYW5vcmFtYVBvc2UocGFub0RhdGEsIG1lc2gpIHtcbiAgICAgIGlmIChtZXNoID09PSB2b2lkIDApIHtcbiAgICAgICAgbWVzaCA9IHRoaXMubWVzaDtcbiAgICAgIH1cblxuICAgICAgLy8gQnkgR29vZ2xlIGRvY3VtZW50YXRpb24gdGhlIGFuZ2xlcyBhcmUgYXBwbGllZCBvbiB0aGUgY2FtZXJhIGluIG9yZGVyIDogaGVhZGluZywgcGl0Y2gsIHJvbGxcbiAgICAgIC8vIGhlcmUgd2UgYXBwbHkgdGhlIHJldmVyc2UgdHJhbnNmb3JtYXRpb24gb24gdGhlIHNwaGVyZVxuICAgICAgdmFyIGNsZWFuQ29ycmVjdGlvbiA9IHRoaXMucHN2LmRhdGFIZWxwZXIuY2xlYW5QYW5vcmFtYVBvc2UocGFub0RhdGEpO1xuICAgICAgbWVzaC5yb3RhdGlvbi5zZXQoLWNsZWFuQ29ycmVjdGlvbi50aWx0LCAtY2xlYW5Db3JyZWN0aW9uLnBhbiwgLWNsZWFuQ29ycmVjdGlvbi5yb2xsLCAnWlhZJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEFwcGx5IGEgU3BoZXJlQ29ycmVjdGlvbiB0byBhIE1lc2hcbiAgICAgKiBAcGFyYW0ge1BTVi5TcGhlcmVDb3JyZWN0aW9ufSBbc3BoZXJlQ29ycmVjdGlvbl1cbiAgICAgKiBAcGFyYW0ge2V4dGVybmFsOlRIUkVFLk1lc2h9IFttZXNoPXRoaXMubWVzaENvbnRhaW5lcl1cbiAgICAgKiBAcGFja2FnZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5zZXRTcGhlcmVDb3JyZWN0aW9uID0gZnVuY3Rpb24gc2V0U3BoZXJlQ29ycmVjdGlvbihzcGhlcmVDb3JyZWN0aW9uLCBtZXNoKSB7XG4gICAgICBpZiAobWVzaCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIG1lc2ggPSB0aGlzLm1lc2hDb250YWluZXI7XG4gICAgICB9XG5cbiAgICAgIHZhciBjbGVhbkNvcnJlY3Rpb24gPSB0aGlzLnBzdi5kYXRhSGVscGVyLmNsZWFuU3BoZXJlQ29ycmVjdGlvbihzcGhlcmVDb3JyZWN0aW9uKTtcbiAgICAgIG1lc2gucm90YXRpb24uc2V0KGNsZWFuQ29ycmVjdGlvbi50aWx0LCBjbGVhbkNvcnJlY3Rpb24ucGFuLCBjbGVhbkNvcnJlY3Rpb24ucm9sbCwgJ1pYWScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBQZXJmb3JtcyB0cmFuc2l0aW9uIGJldHdlZW4gdGhlIGN1cnJlbnQgYW5kIGEgbmV3IHRleHR1cmVcbiAgICAgKiBAcGFyYW0ge1BTVi5UZXh0dXJlRGF0YX0gdGV4dHVyZURhdGFcbiAgICAgKiBAcGFyYW0ge1BTVi5QYW5vcmFtYU9wdGlvbnN9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7UFNWLnV0aWxzLkFuaW1hdGlvbn1cbiAgICAgKiBAcGFja2FnZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by50cmFuc2l0aW9uID0gZnVuY3Rpb24gdHJhbnNpdGlvbih0ZXh0dXJlRGF0YSwgb3B0aW9ucykge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBwb3NpdGlvblByb3ZpZGVkID0gaXNFeHRlbmRlZFBvc2l0aW9uKG9wdGlvbnMpO1xuICAgICAgdmFyIHpvb21Qcm92aWRlZCA9ICgnem9vbScgaW4gb3B0aW9ucyk7IC8vIGNyZWF0ZSB0ZW1wIGdyb3VwIGFuZCBuZXcgbWVzaCwgaGFsZiBzaXplIHRvIGJlIGluIFwiZnJvbnRcIiBvZiB0aGUgZmlyc3Qgb25lXG5cbiAgICAgIHZhciBncm91cCA9IG5ldyB0aHJlZS5Hcm91cCgpO1xuICAgICAgdmFyIG1lc2ggPSB0aGlzLnBzdi5hZGFwdGVyLmNyZWF0ZU1lc2goMC41KTtcbiAgICAgIHRoaXMucHN2LmFkYXB0ZXIuc2V0VGV4dHVyZShtZXNoLCB0ZXh0dXJlRGF0YSwgdHJ1ZSk7XG4gICAgICB0aGlzLnBzdi5hZGFwdGVyLnNldFRleHR1cmVPcGFjaXR5KG1lc2gsIDApO1xuICAgICAgdGhpcy5zZXRQYW5vcmFtYVBvc2UodGV4dHVyZURhdGEucGFub0RhdGEsIG1lc2gpO1xuICAgICAgdGhpcy5zZXRTcGhlcmVDb3JyZWN0aW9uKG9wdGlvbnMuc3BoZXJlQ29ycmVjdGlvbiwgZ3JvdXApOyAvLyByb3RhdGUgdGhlIG5ldyBzcGhlcmUgdG8gbWFrZSB0aGUgdGFyZ2V0IHBvc2l0aW9uIGZhY2UgdGhlIGNhbWVyYVxuXG4gICAgICBpZiAocG9zaXRpb25Qcm92aWRlZCkge1xuICAgICAgICB2YXIgY2xlYW5Qb3NpdGlvbiA9IHRoaXMucHN2LmRhdGFIZWxwZXIuY2xlYW5Qb3NpdGlvbihvcHRpb25zKTtcbiAgICAgICAgdmFyIGN1cnJlbnRQb3NpdGlvbiA9IHRoaXMucHN2LmdldFBvc2l0aW9uKCk7IC8vIExvbmdpdHVkZSByb3RhdGlvbiBhbG9uZyB0aGUgdmVydGljYWwgYXhpc1xuXG4gICAgICAgIHZhciB2ZXJ0aWNhbEF4aXMgPSBuZXcgdGhyZWUuVmVjdG9yMygwLCAxLCAwKTtcbiAgICAgICAgZ3JvdXAucm90YXRlT25Xb3JsZEF4aXModmVydGljYWxBeGlzLCBjbGVhblBvc2l0aW9uLmxvbmdpdHVkZSAtIGN1cnJlbnRQb3NpdGlvbi5sb25naXR1ZGUpOyAvLyBMYXRpdHVkZSByb3RhdGlvbiBhbG9uZyB0aGUgY2FtZXJhIGhvcml6b250YWwgYXhpc1xuXG4gICAgICAgIHZhciBob3Jpem9udGFsQXhpcyA9IG5ldyB0aHJlZS5WZWN0b3IzKDAsIDEsIDApLmNyb3NzKHRoaXMuY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKG5ldyB0aHJlZS5WZWN0b3IzKCkpKS5ub3JtYWxpemUoKTtcbiAgICAgICAgZ3JvdXAucm90YXRlT25Xb3JsZEF4aXMoaG9yaXpvbnRhbEF4aXMsIGNsZWFuUG9zaXRpb24ubGF0aXR1ZGUgLSBjdXJyZW50UG9zaXRpb24ubGF0aXR1ZGUpO1xuICAgICAgfVxuXG4gICAgICBncm91cC5hZGQobWVzaCk7XG4gICAgICB0aGlzLnNjZW5lLmFkZChncm91cCk7XG4gICAgICB2YXIgYW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbih7XG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICBvcGFjaXR5OiB7XG4gICAgICAgICAgICBzdGFydDogMC4wLFxuICAgICAgICAgICAgZW5kOiAxLjBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHpvb206IHpvb21Qcm92aWRlZCA/IHtcbiAgICAgICAgICAgIHN0YXJ0OiB0aGlzLnBzdi5nZXRab29tTGV2ZWwoKSxcbiAgICAgICAgICAgIGVuZDogb3B0aW9ucy56b29tXG4gICAgICAgICAgfSA6IHVuZGVmaW5lZFxuICAgICAgICB9LFxuICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy50cmFuc2l0aW9uLFxuICAgICAgICBlYXNpbmc6ICdvdXRDdWJpYycsXG4gICAgICAgIG9uVGljazogZnVuY3Rpb24gb25UaWNrKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICBfdGhpczMucHN2LmFkYXB0ZXIuc2V0VGV4dHVyZU9wYWNpdHkobWVzaCwgcHJvcGVydGllcy5vcGFjaXR5KTtcblxuICAgICAgICAgIF90aGlzMy5wc3YuYWRhcHRlci5zZXRUZXh0dXJlT3BhY2l0eShfdGhpczMubWVzaCwgMSAtIHByb3BlcnRpZXMub3BhY2l0eSk7XG5cbiAgICAgICAgICBpZiAoem9vbVByb3ZpZGVkKSB7XG4gICAgICAgICAgICBfdGhpczMucHN2Lnpvb20ocHJvcGVydGllcy56b29tKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfdGhpczMucHN2Lm5lZWRzVXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgYW5pbWF0aW9uLnRoZW4oZnVuY3Rpb24gKGNvbXBsZXRlZCkge1xuICAgICAgICBpZiAoY29tcGxldGVkKSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIHRlbXAgc3BoZXJlIGFuZCB0cmFuc2ZlciB0aGUgdGV4dHVyZSB0byB0aGUgbWFpbiBtZXNoXG4gICAgICAgICAgX3RoaXMzLnNldFRleHR1cmUodGV4dHVyZURhdGEpO1xuXG4gICAgICAgICAgX3RoaXMzLnBzdi5hZGFwdGVyLnNldFRleHR1cmVPcGFjaXR5KF90aGlzMy5tZXNoLCAxKTtcblxuICAgICAgICAgIF90aGlzMy5zZXRQYW5vcmFtYVBvc2UodGV4dHVyZURhdGEucGFub0RhdGEpO1xuXG4gICAgICAgICAgX3RoaXMzLnNldFNwaGVyZUNvcnJlY3Rpb24ob3B0aW9ucy5zcGhlcmVDb3JyZWN0aW9uKTsgLy8gYWN0dWFsbHkgcm90YXRlIHRoZSBjYW1lcmFcblxuXG4gICAgICAgICAgaWYgKHBvc2l0aW9uUHJvdmlkZWQpIHtcbiAgICAgICAgICAgIF90aGlzMy5wc3Yucm90YXRlKG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpczMucHN2LmFkYXB0ZXIuZGlzcG9zZVRleHR1cmUodGV4dHVyZURhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMzLnNjZW5lLnJlbW92ZShncm91cCk7XG5cbiAgICAgICAgbWVzaC5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgICAgIG1lc2guZ2VvbWV0cnkgPSBudWxsO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYW5pbWF0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBDYWxscyBgZGlzcG9zZWAgb24gYWxsIG9iamVjdHMgYW5kIHRleHR1cmVzXG4gICAgICogQHBhcmFtIHtleHRlcm5hbDpUSFJFRS5PYmplY3QzRH0gb2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uX19jbGVhblRIUkVFU2NlbmUgPSBmdW5jdGlvbiBfX2NsZWFuVEhSRUVTY2VuZShvYmplY3QpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICBvYmplY3QudHJhdmVyc2UoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0uZ2VvbWV0cnkpIHtcbiAgICAgICAgICBpdGVtLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpdGVtLm1hdGVyaWFsKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbS5tYXRlcmlhbCkpIHtcbiAgICAgICAgICAgIGl0ZW0ubWF0ZXJpYWwuZm9yRWFjaChmdW5jdGlvbiAobWF0ZXJpYWwpIHtcbiAgICAgICAgICAgICAgaWYgKG1hdGVyaWFsLm1hcCkge1xuICAgICAgICAgICAgICAgIG1hdGVyaWFsLm1hcC5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBtYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGl0ZW0ubWF0ZXJpYWwubWFwKSB7XG4gICAgICAgICAgICAgIGl0ZW0ubWF0ZXJpYWwubWFwLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaXRlbS5tYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGl0ZW0uZGlzcG9zZSAmJiAhKGl0ZW0gaW5zdGFuY2VvZiB0aHJlZS5TY2VuZSkpIHtcbiAgICAgICAgICBpdGVtLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpdGVtICE9PSBvYmplY3QpIHtcbiAgICAgICAgICBfdGhpczQuX19jbGVhblRIUkVFU2NlbmUoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gUmVuZGVyZXI7XG4gIH0oQWJzdHJhY3RTZXJ2aWNlKTtcblxuICAvKipcbiAgICogQHN1bW1hcnkgVGV4dHVyZSBsb2FkZXJcbiAgICogQGV4dGVuZHMgUFNWLnNlcnZpY2VzLkFic3RyYWN0U2VydmljZVxuICAgKiBAbWVtYmVyb2YgUFNWLnNlcnZpY2VzXG4gICAqL1xuXG4gIHZhciBUZXh0dXJlTG9hZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQWJzdHJhY3RTZXJ2aWNlKSB7XG4gICAgX2luaGVyaXRzTG9vc2UoVGV4dHVyZUxvYWRlciwgX0Fic3RyYWN0U2VydmljZSk7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1BTVi5WaWV3ZXJ9IHBzdlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRleHR1cmVMb2FkZXIocHN2KSB7XG4gICAgICB2YXIgX3RoaXM7XG5cbiAgICAgIF90aGlzID0gX0Fic3RyYWN0U2VydmljZS5jYWxsKHRoaXMsIHBzdikgfHwgdGhpcztcbiAgICAgIC8qKlxuICAgICAgICogQHN1bW1hcnkgVEhSRUUgZmlsZSBsb2FkZXJcbiAgICAgICAqIEB0eXBlIHtleHRlcm5hbDpUSFJFRTpGaWxlTG9hZGVyfVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgICBfdGhpcy5sb2FkZXIgPSBuZXcgdGhyZWUuRmlsZUxvYWRlcigpO1xuXG4gICAgICBfdGhpcy5sb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCdibG9iJyk7XG5cbiAgICAgIGlmIChfdGhpcy5jb25maWcud2l0aENyZWRlbnRpYWxzKSB7XG4gICAgICAgIF90aGlzLmxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHModHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfdGhpcy5jb25maWcucmVxdWVzdEhlYWRlcnMgJiYgdHlwZW9mIF90aGlzLmNvbmZpZy5yZXF1ZXN0SGVhZGVycyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgX3RoaXMubG9hZGVyLnNldFJlcXVlc3RIZWFkZXIoX3RoaXMuY29uZmlnLnJlcXVlc3RIZWFkZXJzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cblxuXG4gICAgdmFyIF9wcm90byA9IFRleHR1cmVMb2FkZXIucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy5hYm9ydExvYWRpbmcoKTtcblxuICAgICAgX0Fic3RyYWN0U2VydmljZS5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBDYW5jZWxzIGN1cnJlbnQgSFRUUCByZXF1ZXN0c1xuICAgICAqIEBwYWNrYWdlXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLmFib3J0TG9hZGluZyA9IGZ1bmN0aW9uIGFib3J0TG9hZGluZygpIHsvLyBub29wIGltcGxlbWVudGF0aW9uIHdhaXRpbmcgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvcHVsbC8yMzA3MFxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBMb2FkcyBhIEJsb2Igd2l0aCBGaWxlTG9hZGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24obnVtYmVyKX0gW29uUHJvZ3Jlc3NdXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QmxvYj59XG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLmxvYWRGaWxlID0gZnVuY3Rpb24gbG9hZEZpbGUodXJsLCBvblByb2dyZXNzKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuY29uZmlnLnJlcXVlc3RIZWFkZXJzICYmIHR5cGVvZiB0aGlzLmNvbmZpZy5yZXF1ZXN0SGVhZGVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLmxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKHRoaXMuY29uZmlnLnJlcXVlc3RIZWFkZXJzKHVybCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgcHJvZ3Jlc3MgPSAwO1xuICAgICAgICBvblByb2dyZXNzID09IG51bGwgPyB2b2lkIDAgOiBvblByb2dyZXNzKHByb2dyZXNzKTtcblxuICAgICAgICBfdGhpczIubG9hZGVyLmxvYWQodXJsLCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgcHJvZ3Jlc3MgPSAxMDA7XG4gICAgICAgICAgb25Qcm9ncmVzcyA9PSBudWxsID8gdm9pZCAwIDogb25Qcm9ncmVzcyhwcm9ncmVzcyk7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGlmIChlLmxlbmd0aENvbXB1dGFibGUpIHtcbiAgICAgICAgICAgIHZhciBuZXdQcm9ncmVzcyA9IGUubG9hZGVkIC8gZS50b3RhbCAqIDEwMDtcblxuICAgICAgICAgICAgaWYgKG5ld1Byb2dyZXNzID4gcHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgcHJvZ3Jlc3MgPSBuZXdQcm9ncmVzcztcbiAgICAgICAgICAgICAgb25Qcm9ncmVzcyA9PSBudWxsID8gdm9pZCAwIDogb25Qcm9ncmVzcyhwcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IExvYWRzIGFuIEltYWdlIHVzaW5nIEZpbGVMb2FkZXIgdG8gaGF2ZSBwcm9ncmVzcyBldmVudHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihudW1iZXIpfSBbb25Qcm9ncmVzc11cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxIVE1MSW1hZ2VFbGVtZW50Pn1cbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8ubG9hZEltYWdlID0gZnVuY3Rpb24gbG9hZEltYWdlKHVybCwgb25Qcm9ncmVzcykge1xuICAgICAgcmV0dXJuIHRoaXMubG9hZEZpbGUodXJsLCBvblByb2dyZXNzKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICB2YXIgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJywgJ2ltZycpO1xuXG4gICAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoaW1nLnNyYyk7XG4gICAgICAgICAgICByZXNvbHZlKGltZyk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGltZy5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICAgIGltZy5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFByZWxvYWQgYSBwYW5vcmFtYSBmaWxlIHdpdGhvdXQgZGlzcGxheWluZyBpdFxuICAgICAqIEBwYXJhbSB7Kn0gcGFub3JhbWFcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8ucHJlbG9hZFBhbm9yYW1hID0gZnVuY3Rpb24gcHJlbG9hZFBhbm9yYW1hKHBhbm9yYW1hKSB7XG4gICAgICBpZiAodGhpcy5wc3YuYWRhcHRlci5zdXBwb3J0c1ByZWxvYWQocGFub3JhbWEpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBzdi5hZGFwdGVyLmxvYWRUZXh0dXJlKHBhbm9yYW1hKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIFRleHR1cmVMb2FkZXI7XG4gIH0oQWJzdHJhY3RTZXJ2aWNlKTtcblxuICB2YXIgU1RBVEUgPSB7XG4gICAgTk9ORTogMCxcbiAgICBTSE9XSU5HOiAxLFxuICAgIEhJRElORzogMixcbiAgICBSRUFEWTogM1xuICB9O1xuICAvKipcbiAgICogQHR5cGVkZWYge09iamVjdH0gUFNWLmNvbXBvbmVudHMuVG9vbHRpcC5Qb3NpdGlvblxuICAgKiBAc3VtbWFyeSBPYmplY3QgZGVmaW5pbmcgdGhlIHRvb2x0aXAgcG9zaXRpb25cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHRvcCAtIFBvc2l0aW9uIG9mIHRoZSB0aXAgb2YgdGhlIGFycm93IG9mIHRoZSB0b29sdGlwLCBpbiBwaXhlbHNcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IGxlZnQgLSBQb3NpdGlvbiBvZiB0aGUgdGlwIG9mIHRoZSBhcnJvdyBvZiB0aGUgdG9vbHRpcCwgaW4gcGl4ZWxzXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfHN0cmluZ1tdfSBbcG9zaXRpb249J3RvcCBjZW50ZXInXSAtIFRvb2x0aXAgcG9zaXRpb24gdG93YXJkIGl0J3MgYXJyb3cgdGlwLlxuICAgKiAgICAgICAgICAgQWNjZXB0ZWQgdmFsdWVzIGFyZSBjb21iaW5hdGlvbnMgb2YgYHRvcGAsIGBjZW50ZXJgLCBgYm90dG9tYCBhbmQgYGxlZnRgLCBgY2VudGVyYCwgYHJpZ2h0YFxuICAgKiBAcHJvcGVydHkge09iamVjdH0gW2JveF0gLSBVc2VkIHdoZW4gZGlzcGxheWluZyBhIHRvb2x0aXAgb24gYSBtYXJrZXJcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IFtib3gud2lkdGg9MF1cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IFtib3guaGVpZ2h0PTBdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7UFNWLmNvbXBvbmVudHMuVG9vbHRpcC5Qb3NpdGlvbn0gUFNWLmNvbXBvbmVudHMuVG9vbHRpcC5Db25maWdcbiAgICogQHN1bW1hcnkgT2JqZWN0IGRlZmluaW5nIHRoZSB0b29sdGlwIGNvbmZpZ3VyYXRpb25cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IGNvbnRlbnQgLSBIVE1MIGNvbnRlbnQgb2YgdGhlIHRvb2x0aXBcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzc05hbWVdIC0gQWRkaXRpb25hbCBDU1MgY2xhc3MgYWRkZWQgdG8gdGhlIHRvb2x0aXBcbiAgICogQHByb3BlcnR5IHsqfSBbZGF0YV0gLSBVc2VyZGF0YSBhc3NvY2lhdGVkIHRvIHRoZSB0b29sdGlwXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAc3VtbWFyeSBUb29sdGlwIGNvbXBvbmVudFxuICAgKiBAZGVzY3JpcHRpb24gTmV2ZXIgaW5zdGFuY2lhdGUgdG9vbHRpcHMgZGlyZWN0bHkgdXNlIHtAbGluayBQU1Yuc2VydmljZXMuVG9vbHRpcFJlbmRlcmVyfSBpbnN0ZWFkXG4gICAqIEBleHRlbmRzIFBTVi5jb21wb25lbnRzLkFic3RyYWN0Q29tcG9uZW50XG4gICAqIEBtZW1iZXJvZiBQU1YuY29tcG9uZW50c1xuICAgKi9cblxuICB2YXIgVG9vbHRpcCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Fic3RyYWN0Q29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzTG9vc2UoVG9vbHRpcCwgX0Fic3RyYWN0Q29tcG9uZW50KTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UFNWLlZpZXdlcn0gcHN2XG4gICAgICogQHBhcmFtIHt7YXJyb3c6IG51bWJlciwgYm9yZGVyOiBudW1iZXJ9fSBzaXplXG4gICAgICovXG4gICAgZnVuY3Rpb24gVG9vbHRpcChwc3YsIHNpemUpIHtcbiAgICAgIHZhciBfdGhpcztcblxuICAgICAgX3RoaXMgPSBfQWJzdHJhY3RDb21wb25lbnQuY2FsbCh0aGlzLCBwc3YsICdwc3YtdG9vbHRpcCcpIHx8IHRoaXM7XG4gICAgICAvKipcbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGFycm93XG4gICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYm9yZGVyXG4gICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGhcbiAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoZWlnaHRcbiAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwb3NcbiAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdGF0ZVxuICAgICAgICogQHByb3BlcnR5IHsqfSBkYXRhXG4gICAgICAgKi9cblxuICAgICAgX3RoaXMucHJvcCA9IF9leHRlbmRzKHt9LCBfdGhpcy5wcm9wLCBzaXplLCB7XG4gICAgICAgIHN0YXRlOiBTVEFURS5OT05FLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICBwb3M6ICcnLFxuICAgICAgICBjb25maWc6IG51bGwsXG4gICAgICAgIGRhdGE6IG51bGxcbiAgICAgIH0pO1xuICAgICAgLyoqXG4gICAgICAgKiBUb29sdGlwIGNvbnRlbnRcbiAgICAgICAqIEBtZW1iZXIge0hUTUxFbGVtZW50fVxuICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICAgIF90aGlzLmNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIF90aGlzLmNvbnRlbnQuY2xhc3NOYW1lID0gJ3Bzdi10b29sdGlwLWNvbnRlbnQnO1xuXG4gICAgICBfdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoX3RoaXMuY29udGVudCk7XG4gICAgICAvKipcbiAgICAgICAqIFRvb2x0aXAgYXJyb3dcbiAgICAgICAqIEBtZW1iZXIge0hUTUxFbGVtZW50fVxuICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgKiBAcGFja2FnZVxuICAgICAgICovXG5cblxuICAgICAgX3RoaXMuYXJyb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIF90aGlzLmFycm93LmNsYXNzTmFtZSA9ICdwc3YtdG9vbHRpcC1hcnJvdyc7XG5cbiAgICAgIF90aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChfdGhpcy5hcnJvdyk7XG5cbiAgICAgIF90aGlzLmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgICBfdGhpcy5jb250YWluZXIuc3R5bGUudG9wID0gJy0xMDAwcHgnO1xuICAgICAgX3RoaXMuY29udGFpbmVyLnN0eWxlLmxlZnQgPSAnLTEwMDBweCc7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuXG5cbiAgICB2YXIgX3Byb3RvID0gVG9vbHRpcC5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICBkZWxldGUgdGhpcy5hcnJvdztcbiAgICAgIGRlbGV0ZSB0aGlzLmNvbnRlbnQ7XG5cbiAgICAgIF9BYnN0cmFjdENvbXBvbmVudC5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBIYW5kbGVzIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uIGhhbmRsZUV2ZW50KGUpIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlICovXG4gICAgICBzd2l0Y2ggKGUudHlwZSkge1xuICAgICAgICAvLyBAZm9ybWF0dGVyOm9mZlxuICAgICAgICBjYXNlICd0cmFuc2l0aW9uZW5kJzpcbiAgICAgICAgICB0aGlzLl9fb25UcmFuc2l0aW9uRW5kKGUpO1xuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIEBmb3JtYXR0ZXI6b25cbiAgICAgIH1cbiAgICAgIC8qIGVzbGludC1lbmFibGUgKi9cblxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAc3VtbWFyeSBUaGlzIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkXG4gICAgICogQHRocm93cyB7UFNWLlBTVkVycm9yfSBhbHdheXNcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8udG9nZ2xlID0gZnVuY3Rpb24gdG9nZ2xlKCkge1xuICAgICAgdGhyb3cgbmV3IFBTVkVycm9yKCdUb29sdGlwIGNhbm5vdCBiZSB0b2dnbGVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IERpc3BsYXlzIHRoZSB0b29sdGlwIG9uIHRoZSB2aWV3ZXJcbiAgICAgKiBEbyBub3QgY2FsbCB0aGlzIG1ldGhvZCBkaXJlY3RseSwgdXNlIHtAbGluayBQU1Yuc2VydmljZXMuVG9vbHRpcFJlbmRlcmVyfSBpbnN0ZWFkLlxuICAgICAqIEBwYXJhbSB7UFNWLmNvbXBvbmVudHMuVG9vbHRpcC5Db25maWd9IGNvbmZpZ1xuICAgICAqXG4gICAgICogQGZpcmVzIFBTVi5zaG93LXRvb2x0aXBcbiAgICAgKiBAdGhyb3dzIHtQU1YuUFNWRXJyb3J9IHdoZW4gdGhlIGNvbmZpZ3VyYXRpb24gaXMgaW5jb3JyZWN0XG4gICAgICpcbiAgICAgKiBAcGFja2FnZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5zaG93ID0gZnVuY3Rpb24gc2hvdyhjb25maWcpIHtcbiAgICAgIGlmICh0aGlzLnByb3Auc3RhdGUgIT09IFNUQVRFLk5PTkUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBTVkVycm9yKCdJbml0aWFsaXplZCB0b29sdGlwIGNhbm5vdCBiZSByZS1pbml0aWFsaXplZCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29uZmlnLmNsYXNzTmFtZSkge1xuICAgICAgICBhZGRDbGFzc2VzKHRoaXMuY29udGFpbmVyLCBjb25maWcuY2xhc3NOYW1lKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb250ZW50LmlubmVySFRNTCA9IGNvbmZpZy5jb250ZW50O1xuICAgICAgdmFyIHJlY3QgPSB0aGlzLmNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHRoaXMucHJvcC53aWR0aCA9IHJlY3QucmlnaHQgLSByZWN0LmxlZnQ7XG4gICAgICB0aGlzLnByb3AuaGVpZ2h0ID0gcmVjdC5ib3R0b20gLSByZWN0LnRvcDtcbiAgICAgIHRoaXMucHJvcC5zdGF0ZSA9IFNUQVRFLlJFQURZO1xuICAgICAgdGhpcy5tb3ZlKGNvbmZpZyk7XG4gICAgICB0aGlzLnByb3AuZGF0YSA9IGNvbmZpZy5kYXRhO1xuICAgICAgdGhpcy5wcm9wLnN0YXRlID0gU1RBVEUuU0hPV0lORztcbiAgICAgIHRoaXMucHN2LnRyaWdnZXIoRVZFTlRTLlNIT1dfVE9PTFRJUCwgdGhpcy5wcm9wLmRhdGEsIHRoaXMpO1xuXG4gICAgICB0aGlzLl9fd2FpdEltYWdlcygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBNb3ZlcyB0aGUgdG9vbHRpcCB0byBhIG5ldyBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7UFNWLmNvbXBvbmVudHMuVG9vbHRpcC5Qb3NpdGlvbn0gY29uZmlnXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtQU1YuUFNWRXJyb3J9IHdoZW4gdGhlIGNvbmZpZ3VyYXRpb24gaXMgaW5jb3JyZWN0XG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLm1vdmUgPSBmdW5jdGlvbiBtb3ZlKGNvbmZpZykge1xuICAgICAgaWYgKHRoaXMucHJvcC5zdGF0ZSAhPT0gU1RBVEUuU0hPV0lORyAmJiB0aGlzLnByb3Auc3RhdGUgIT09IFNUQVRFLlJFQURZKSB7XG4gICAgICAgIHRocm93IG5ldyBQU1ZFcnJvcignVW5pbml0aWFsaXplZCB0b29sdGlwIGNhbm5vdCBiZSBtb3ZlZCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWNvbmZpZy5ib3gpIHtcbiAgICAgICAgY29uZmlnLmJveCA9IHtcbiAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICB2YXIgdCA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgdmFyIGEgPSB0aGlzLmFycm93OyAvLyBjb21wdXRlIHNpemVcblxuICAgICAgdmFyIHN0eWxlID0ge1xuICAgICAgICBwb3NDbGFzczogY2xlYW5Qb3NpdGlvbihjb25maWcucG9zaXRpb24sIHtcbiAgICAgICAgICBhbGxvd0NlbnRlcjogZmFsc2UsXG4gICAgICAgICAgY3NzT3JkZXI6IGZhbHNlXG4gICAgICAgIH0pIHx8IFsndG9wJywgJ2NlbnRlciddLFxuICAgICAgICB3aWR0aDogdGhpcy5wcm9wLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRoaXMucHJvcC5oZWlnaHQsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgYXJyb3dUb3A6IDAsXG4gICAgICAgIGFycm93TGVmdDogMFxuICAgICAgfTsgLy8gc2V0IGluaXRpYWwgcG9zaXRpb25cblxuICAgICAgdGhpcy5fX2NvbXB1dGVUb29sdGlwUG9zaXRpb24oc3R5bGUsIGNvbmZpZyk7IC8vIGNvcnJlY3QgcG9zaXRpb24gaWYgb3ZlcmZsb3dcblxuXG4gICAgICB2YXIgc3dhcFkgPSBudWxsO1xuICAgICAgdmFyIHN3YXBYID0gbnVsbDtcblxuICAgICAgaWYgKHN0eWxlLnRvcCA8IDApIHtcbiAgICAgICAgc3dhcFkgPSAnYm90dG9tJztcbiAgICAgIH0gZWxzZSBpZiAoc3R5bGUudG9wICsgc3R5bGUuaGVpZ2h0ID4gdGhpcy5wc3YucHJvcC5zaXplLmhlaWdodCkge1xuICAgICAgICBzd2FwWSA9ICd0b3AnO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3R5bGUubGVmdCA8IDApIHtcbiAgICAgICAgc3dhcFggPSAncmlnaHQnO1xuICAgICAgfSBlbHNlIGlmIChzdHlsZS5sZWZ0ICsgc3R5bGUud2lkdGggPiB0aGlzLnBzdi5wcm9wLnNpemUud2lkdGgpIHtcbiAgICAgICAgc3dhcFggPSAnbGVmdCc7XG4gICAgICB9XG5cbiAgICAgIGlmIChzd2FwWCB8fCBzd2FwWSkge1xuICAgICAgICB2YXIgb3JkZXJlZCA9IHBvc2l0aW9uSXNPcmRlcmVkKHN0eWxlLnBvc0NsYXNzKTtcblxuICAgICAgICBpZiAoc3dhcFkpIHtcbiAgICAgICAgICBzdHlsZS5wb3NDbGFzc1tvcmRlcmVkID8gMCA6IDFdID0gc3dhcFk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3dhcFgpIHtcbiAgICAgICAgICBzdHlsZS5wb3NDbGFzc1tvcmRlcmVkID8gMSA6IDBdID0gc3dhcFg7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9fY29tcHV0ZVRvb2x0aXBQb3NpdGlvbihzdHlsZSwgY29uZmlnKTtcbiAgICAgIH0gLy8gYXBwbHkgcG9zaXRpb25cblxuXG4gICAgICB0LnN0eWxlLnRvcCA9IHN0eWxlLnRvcCArICdweCc7XG4gICAgICB0LnN0eWxlLmxlZnQgPSBzdHlsZS5sZWZ0ICsgJ3B4JztcbiAgICAgIGEuc3R5bGUudG9wID0gc3R5bGUuYXJyb3dUb3AgKyAncHgnO1xuICAgICAgYS5zdHlsZS5sZWZ0ID0gc3R5bGUuYXJyb3dMZWZ0ICsgJ3B4JztcbiAgICAgIHZhciBuZXdQb3MgPSBzdHlsZS5wb3NDbGFzcy5qb2luKCctJyk7XG5cbiAgICAgIGlmIChuZXdQb3MgIT09IHRoaXMucHJvcC5wb3MpIHtcbiAgICAgICAgdC5jbGFzc0xpc3QucmVtb3ZlKFwicHN2LXRvb2x0aXAtLVwiICsgdGhpcy5wcm9wLnBvcyk7XG4gICAgICAgIHRoaXMucHJvcC5wb3MgPSBuZXdQb3M7XG4gICAgICAgIHQuY2xhc3NMaXN0LmFkZChcInBzdi10b29sdGlwLS1cIiArIHRoaXMucHJvcC5wb3MpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBIaWRlcyB0aGUgdG9vbHRpcFxuICAgICAqIEBmaXJlcyBQU1YuaGlkZS10b29sdGlwXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLmhpZGUgPSBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSgncHN2LXRvb2x0aXAtLXZpc2libGUnKTtcbiAgICAgIHRoaXMucHJvcC5zdGF0ZSA9IFNUQVRFLkhJRElORztcbiAgICAgIHRoaXMucHN2LnRyaWdnZXIoRVZFTlRTLkhJREVfVE9PTFRJUCwgdGhpcy5wcm9wLmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBGaW5hbGl6ZSB0cmFuc2l0aW9uXG4gICAgICogQHBhcmFtIHtUcmFuc2l0aW9uRXZlbnR9IGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5fX29uVHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uIF9fb25UcmFuc2l0aW9uRW5kKGUpIHtcbiAgICAgIGlmIChlLnByb3BlcnR5TmFtZSA9PT0gJ3RyYW5zZm9ybScpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnByb3Auc3RhdGUpIHtcbiAgICAgICAgICBjYXNlIFNUQVRFLlNIT1dJTkc6XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdwc3YtdG9vbHRpcC0tdmlzaWJsZScpO1xuICAgICAgICAgICAgdGhpcy5wcm9wLnN0YXRlID0gU1RBVEUuUkVBRFk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgU1RBVEUuSElESU5HOlxuICAgICAgICAgICAgdGhpcy5wcm9wLnN0YXRlID0gU1RBVEUuTk9ORTtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBDb21wdXRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIHRvb2x0aXAgYW5kIGl0cyBhcnJvd1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5fX2NvbXB1dGVUb29sdGlwUG9zaXRpb24gPSBmdW5jdGlvbiBfX2NvbXB1dGVUb29sdGlwUG9zaXRpb24oc3R5bGUsIGNvbmZpZykge1xuICAgICAgdmFyIGFycm93ID0gdGhpcy5wcm9wLmFycm93O1xuICAgICAgdmFyIHRvcCA9IGNvbmZpZy50b3A7XG4gICAgICB2YXIgaGVpZ2h0ID0gc3R5bGUuaGVpZ2h0O1xuICAgICAgdmFyIGxlZnQgPSBjb25maWcubGVmdDtcbiAgICAgIHZhciB3aWR0aCA9IHN0eWxlLndpZHRoO1xuICAgICAgdmFyIG9mZnNldFNpZGUgPSBhcnJvdyArIHRoaXMucHJvcC5ib3JkZXI7XG4gICAgICB2YXIgb2Zmc2V0WCA9IGNvbmZpZy5ib3gud2lkdGggLyAyICsgYXJyb3cgKiAyO1xuICAgICAgdmFyIG9mZnNldFkgPSBjb25maWcuYm94LmhlaWdodCAvIDIgKyBhcnJvdyAqIDI7XG5cbiAgICAgIHN3aXRjaCAoc3R5bGUucG9zQ2xhc3Muam9pbignLScpKSB7XG4gICAgICAgIGNhc2UgJ3RvcC1sZWZ0JzpcbiAgICAgICAgICBzdHlsZS50b3AgPSB0b3AgLSBvZmZzZXRZIC0gaGVpZ2h0O1xuICAgICAgICAgIHN0eWxlLmxlZnQgPSBsZWZ0ICsgb2Zmc2V0U2lkZSAtIHdpZHRoO1xuICAgICAgICAgIHN0eWxlLmFycm93VG9wID0gaGVpZ2h0O1xuICAgICAgICAgIHN0eWxlLmFycm93TGVmdCA9IHdpZHRoIC0gb2Zmc2V0U2lkZSAtIGFycm93O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3RvcC1jZW50ZXInOlxuICAgICAgICAgIHN0eWxlLnRvcCA9IHRvcCAtIG9mZnNldFkgLSBoZWlnaHQ7XG4gICAgICAgICAgc3R5bGUubGVmdCA9IGxlZnQgLSB3aWR0aCAvIDI7XG4gICAgICAgICAgc3R5bGUuYXJyb3dUb3AgPSBoZWlnaHQ7XG4gICAgICAgICAgc3R5bGUuYXJyb3dMZWZ0ID0gd2lkdGggLyAyIC0gYXJyb3c7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndG9wLXJpZ2h0JzpcbiAgICAgICAgICBzdHlsZS50b3AgPSB0b3AgLSBvZmZzZXRZIC0gaGVpZ2h0O1xuICAgICAgICAgIHN0eWxlLmxlZnQgPSBsZWZ0IC0gb2Zmc2V0U2lkZTtcbiAgICAgICAgICBzdHlsZS5hcnJvd1RvcCA9IGhlaWdodDtcbiAgICAgICAgICBzdHlsZS5hcnJvd0xlZnQgPSBhcnJvdztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdib3R0b20tbGVmdCc6XG4gICAgICAgICAgc3R5bGUudG9wID0gdG9wICsgb2Zmc2V0WTtcbiAgICAgICAgICBzdHlsZS5sZWZ0ID0gbGVmdCArIG9mZnNldFNpZGUgLSB3aWR0aDtcbiAgICAgICAgICBzdHlsZS5hcnJvd1RvcCA9IC1hcnJvdyAqIDI7XG4gICAgICAgICAgc3R5bGUuYXJyb3dMZWZ0ID0gd2lkdGggLSBvZmZzZXRTaWRlIC0gYXJyb3c7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnYm90dG9tLWNlbnRlcic6XG4gICAgICAgICAgc3R5bGUudG9wID0gdG9wICsgb2Zmc2V0WTtcbiAgICAgICAgICBzdHlsZS5sZWZ0ID0gbGVmdCAtIHdpZHRoIC8gMjtcbiAgICAgICAgICBzdHlsZS5hcnJvd1RvcCA9IC1hcnJvdyAqIDI7XG4gICAgICAgICAgc3R5bGUuYXJyb3dMZWZ0ID0gd2lkdGggLyAyIC0gYXJyb3c7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnYm90dG9tLXJpZ2h0JzpcbiAgICAgICAgICBzdHlsZS50b3AgPSB0b3AgKyBvZmZzZXRZO1xuICAgICAgICAgIHN0eWxlLmxlZnQgPSBsZWZ0IC0gb2Zmc2V0U2lkZTtcbiAgICAgICAgICBzdHlsZS5hcnJvd1RvcCA9IC1hcnJvdyAqIDI7XG4gICAgICAgICAgc3R5bGUuYXJyb3dMZWZ0ID0gYXJyb3c7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbGVmdC10b3AnOlxuICAgICAgICAgIHN0eWxlLnRvcCA9IHRvcCArIG9mZnNldFNpZGUgLSBoZWlnaHQ7XG4gICAgICAgICAgc3R5bGUubGVmdCA9IGxlZnQgLSBvZmZzZXRYIC0gd2lkdGg7XG4gICAgICAgICAgc3R5bGUuYXJyb3dUb3AgPSBoZWlnaHQgLSBvZmZzZXRTaWRlIC0gYXJyb3c7XG4gICAgICAgICAgc3R5bGUuYXJyb3dMZWZ0ID0gd2lkdGg7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnY2VudGVyLWxlZnQnOlxuICAgICAgICAgIHN0eWxlLnRvcCA9IHRvcCAtIGhlaWdodCAvIDI7XG4gICAgICAgICAgc3R5bGUubGVmdCA9IGxlZnQgLSBvZmZzZXRYIC0gd2lkdGg7XG4gICAgICAgICAgc3R5bGUuYXJyb3dUb3AgPSBoZWlnaHQgLyAyIC0gYXJyb3c7XG4gICAgICAgICAgc3R5bGUuYXJyb3dMZWZ0ID0gd2lkdGg7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbGVmdC1ib3R0b20nOlxuICAgICAgICAgIHN0eWxlLnRvcCA9IHRvcCAtIG9mZnNldFNpZGU7XG4gICAgICAgICAgc3R5bGUubGVmdCA9IGxlZnQgLSBvZmZzZXRYIC0gd2lkdGg7XG4gICAgICAgICAgc3R5bGUuYXJyb3dUb3AgPSBhcnJvdztcbiAgICAgICAgICBzdHlsZS5hcnJvd0xlZnQgPSB3aWR0aDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdyaWdodC10b3AnOlxuICAgICAgICAgIHN0eWxlLnRvcCA9IHRvcCArIG9mZnNldFNpZGUgLSBoZWlnaHQ7XG4gICAgICAgICAgc3R5bGUubGVmdCA9IGxlZnQgKyBvZmZzZXRYO1xuICAgICAgICAgIHN0eWxlLmFycm93VG9wID0gaGVpZ2h0IC0gb2Zmc2V0U2lkZSAtIGFycm93O1xuICAgICAgICAgIHN0eWxlLmFycm93TGVmdCA9IC1hcnJvdyAqIDI7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnY2VudGVyLXJpZ2h0JzpcbiAgICAgICAgICBzdHlsZS50b3AgPSB0b3AgLSBoZWlnaHQgLyAyO1xuICAgICAgICAgIHN0eWxlLmxlZnQgPSBsZWZ0ICsgb2Zmc2V0WDtcbiAgICAgICAgICBzdHlsZS5hcnJvd1RvcCA9IGhlaWdodCAvIDIgLSBhcnJvdztcbiAgICAgICAgICBzdHlsZS5hcnJvd0xlZnQgPSAtYXJyb3cgKiAyO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3JpZ2h0LWJvdHRvbSc6XG4gICAgICAgICAgc3R5bGUudG9wID0gdG9wIC0gb2Zmc2V0U2lkZTtcbiAgICAgICAgICBzdHlsZS5sZWZ0ID0gbGVmdCArIG9mZnNldFg7XG4gICAgICAgICAgc3R5bGUuYXJyb3dUb3AgPSBhcnJvdztcbiAgICAgICAgICBzdHlsZS5hcnJvd0xlZnQgPSAtYXJyb3cgKiAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBubyBkZWZhdWx0XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IElmIHRoZSB0b29sdGlwIGNvbnRhaW5zIGltYWdlcywgcmVjb21wdXRlIGl0cyBzaXplIG9uY2UgdGhleSBhcmUgbG9hZGVkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uX193YWl0SW1hZ2VzID0gZnVuY3Rpb24gX193YWl0SW1hZ2VzKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBpbWFnZXMgPSB0aGlzLmNvbnRlbnQucXVlcnlTZWxlY3RvckFsbCgnaW1nJyk7XG5cbiAgICAgIGlmIChpbWFnZXMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgaW1hZ2VzLmZvckVhY2goZnVuY3Rpb24gKGltYWdlKSB7XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgaW1hZ2Uub25sb2FkID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIGltYWdlLm9uZXJyb3IgPSByZXNvbHZlO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoX3RoaXMyLnByb3Auc3RhdGUgPT09IFNUQVRFLlNIT1dJTkcgfHwgX3RoaXMyLnByb3Auc3RhdGUgPT09IFNUQVRFLlJFQURZKSB7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IF90aGlzMi5jb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgICAgIF90aGlzMi5wcm9wLndpZHRoID0gcmVjdC5yaWdodCAtIHJlY3QubGVmdDtcbiAgICAgICAgICAgIF90aGlzMi5wcm9wLmhlaWdodCA9IHJlY3QuYm90dG9tIC0gcmVjdC50b3A7XG5cbiAgICAgICAgICAgIF90aGlzMi5tb3ZlKF90aGlzMi5jb25maWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBUb29sdGlwO1xuICB9KEFic3RyYWN0Q29tcG9uZW50KTtcblxuICAvKipcbiAgICogQHN1bW1hcnkgVG9vbHRpcCByZW5kZXJlclxuICAgKiBAZXh0ZW5kcyBQU1Yuc2VydmljZXMuQWJzdHJhY3RTZXJ2aWNlXG4gICAqIEBtZW1iZXJvZiBQU1Yuc2VydmljZXNcbiAgICovXG5cbiAgdmFyIFRvb2x0aXBSZW5kZXJlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Fic3RyYWN0U2VydmljZSkge1xuICAgIF9pbmhlcml0c0xvb3NlKFRvb2x0aXBSZW5kZXJlciwgX0Fic3RyYWN0U2VydmljZSk7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1BTVi5WaWV3ZXJ9IHBzdlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRvb2x0aXBSZW5kZXJlcihwc3YpIHtcbiAgICAgIHZhciBfdGhpcztcblxuICAgICAgX3RoaXMgPSBfQWJzdHJhY3RTZXJ2aWNlLmNhbGwodGhpcywgcHN2KSB8fCB0aGlzO1xuICAgICAgdmFyIHRlc3RUb29sdGlwID0gbmV3IFRvb2x0aXAoX3RoaXMucHN2LCB7XG4gICAgICAgIGFycm93OiAwLFxuICAgICAgICBib3JkZXI6IDBcbiAgICAgIH0pO1xuICAgICAgLyoqXG4gICAgICAgKiBAc3VtbWFyeSBDb21wdXRlZCBzdGF0aWMgc2l6ZXNcbiAgICAgICAqIEBtZW1iZXIge09iamVjdH1cbiAgICAgICAqIEBwYWNrYWdlXG4gICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYXJyb3dcbiAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBib3JkZXJcbiAgICAgICAqL1xuXG4gICAgICBfdGhpcy5zaXplID0ge1xuICAgICAgICBhcnJvdzogcGFyc2VJbnQoZ2V0U3R5bGUodGVzdFRvb2x0aXAuYXJyb3csICdib3JkZXJUb3BXaWR0aCcpLCAxMCksXG4gICAgICAgIGJvcmRlcjogcGFyc2VJbnQoZ2V0U3R5bGUodGVzdFRvb2x0aXAuY29udGFpbmVyLCAnYm9yZGVyVG9wTGVmdFJhZGl1cycpLCAxMClcbiAgICAgIH07XG4gICAgICB0ZXN0VG9vbHRpcC5kZXN0cm95KCk7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuXG5cbiAgICB2YXIgX3Byb3RvID0gVG9vbHRpcFJlbmRlcmVyLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnNpemU7XG5cbiAgICAgIF9BYnN0cmFjdFNlcnZpY2UucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgRGlzcGxheXMgYSB0b29sdGlwIG9uIHRoZSB2aWV3ZXJcbiAgICAgKiBAcGFyYW0ge1BTVi5jb21wb25lbnRzLlRvb2x0aXAuQ29uZmlnfSBjb25maWdcbiAgICAgKiBAcmV0dXJucyB7UFNWLmNvbXBvbmVudHMuVG9vbHRpcH1cbiAgICAgKlxuICAgICAqIEBmaXJlcyBQU1Yuc2hvdy10b29sdGlwXG4gICAgICogQHRocm93cyB7UFNWLlBTVkVycm9yfSB3aGVuIHRoZSBjb25maWd1cmF0aW9uIGlzIGluY29ycmVjdFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2aWV3ZXIudG9vbHRpcC5jcmVhdGUoeyBjb250ZW50OiAnSGVsbG8gd29ybGQnLCB0b3A6IDIwMCwgbGVmdDogNDUwLCBwb3NpdGlvbjogJ2NlbnRlciBib3R0b20nfSlcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGNvbmZpZykge1xuICAgICAgdmFyIHRvb2x0aXAgPSBuZXcgVG9vbHRpcCh0aGlzLnBzdiwgdGhpcy5zaXplKTtcbiAgICAgIHRvb2x0aXAuc2hvdyhjb25maWcpO1xuICAgICAgcmV0dXJuIHRvb2x0aXA7XG4gICAgfTtcblxuICAgIHJldHVybiBUb29sdGlwUmVuZGVyZXI7XG4gIH0oQWJzdHJhY3RTZXJ2aWNlKTtcblxuICB0aHJlZS5DYWNoZS5lbmFibGVkID0gdHJ1ZTtcbiAgLyoqXG4gICAqIEBzdW1tYXJ5IE1haW4gY2xhc3NcbiAgICogQG1lbWJlck9mIFBTVlxuICAgKiBAZXh0ZW5kcyB7ZXh0ZXJuYWw6dUV2ZW50LkV2ZW50RW1pdHRlcn1cbiAgICovXG5cbiAgdmFyIFZpZXdlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0V2ZW50RW1pdHRlcikge1xuICAgIF9pbmhlcml0c0xvb3NlKFZpZXdlciwgX0V2ZW50RW1pdHRlcik7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1BTVi5PcHRpb25zfSBvcHRpb25zXG4gICAgICogQGZpcmVzIFBTVi5yZWFkeVxuICAgICAqIEB0aHJvd3Mge1BTVi5QU1ZFcnJvcn0gd2hlbiB0aGUgY29uZmlndXJhdGlvbiBpcyBpbmNvcnJlY3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBWaWV3ZXIob3B0aW9ucykge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBfdGhpcyA9IF9FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgU1lTVEVNLmxvYWQoKTsgLy8gbXVzdCBzdXBwb3J0IFdlYkdMXG5cbiAgICAgIGlmICghU1lTVEVNLmlzV2ViR0xTdXBwb3J0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBTVkVycm9yKCdXZWJHTCBpcyBub3Qgc3VwcG9ydGVkLicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoU1lTVEVNLm1heFRleHR1cmVXaWR0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgUFNWRXJyb3IoJ1VuYWJsZSB0byBkZXRlY3Qgc3lzdGVtIGNhcGFiaWxpdGllcycpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBAc3VtbWFyeSBJbnRlcm5hbCBwcm9wZXJ0aWVzXG4gICAgICAgKiBAbWVtYmVyIHtPYmplY3R9XG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHJlYWR5IC0gd2hlbiBhbGwgY29tcG9uZW50cyBhcmUgbG9hZGVkXG4gICAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHVpUmVmcmVzaCAtIGlmIHRoZSBVSSBuZWVkcyB0byBiZSByZW5kZXJlclxuICAgICAgICogQHByb3BlcnR5IHtib29sZWFufSBuZWVkc1VwZGF0ZSAtIGlmIHRoZSB2aWV3IG5lZWRzIHRvIGJlIHJlbmRlcmVyXG4gICAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGZ1bGxzY3JlZW4gLSBpZiB0aGUgdmlld2VyIGlzIGN1cnJlbnRseSBmdWxsc2NyZWVuXG4gICAgICAgKiBAcHJvcGVydHkge2V4dGVybmFsOlRIUkVFLlZlY3RvcjN9IGRpcmVjdGlvbiAtIGRpcmVjdGlvbiBvZiB0aGUgY2FtZXJhXG4gICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gdkZvdiAtIHZlcnRpY2FsIEZPVlxuICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGhGb3YgLSBob3Jpem9udGFsIEZPVlxuICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGFzcGVjdCAtIHZpZXdlciBhc3BlY3QgcmF0aW9cbiAgICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYXV0b3JvdGF0ZUVuYWJsZWQgLSBhdXRvbWF0aWMgcm90YXRpb24gaXMgZW5hYmxlZFxuICAgICAgICogQHByb3BlcnR5IHtQU1YudXRpbHMuQW5pbWF0aW9ufSBhbmltYXRpb25Qcm9taXNlIC0gcHJvbWlzZSBvZiB0aGUgY3VycmVudCBhbmltYXRpb25cbiAgICAgICAqIEBwcm9wZXJ0eSB7UHJvbWlzZX0gbG9hZGluZ1Byb21pc2UgLSBwcm9taXNlIG9mIHRoZSBzZXRQYW5vcmFtYSBtZXRob2RcbiAgICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbGl0dGxlUGxhbmV0IC0gc3BlY2lhbCB0d2Vha3MgZm9yIExpdHRsZVBsYW5ldEFkYXB0ZXJcbiAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpZGxlVGltZSAtIHRpbWUgb2YgdGhlIGxhc3QgdXNlciBhY3Rpb25cbiAgICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBvYmplY3RzT2JzZXJ2ZXJzXG4gICAgICAgKiBAcHJvcGVydHkge1BTVi5TaXplfSBzaXplIC0gc2l6ZSBvZiB0aGUgY29udGFpbmVyXG4gICAgICAgKiBAcHJvcGVydHkge1BTVi5QYW5vRGF0YX0gcGFub0RhdGEgLSBwYW5vcmFtYSBtZXRhZGF0YSwgaWYgc3VwcG9ydGVkXG4gICAgICAgKi9cblxuXG4gICAgICBfdGhpcy5wcm9wID0ge1xuICAgICAgICByZWFkeTogZmFsc2UsXG4gICAgICAgIHVpUmVmcmVzaDogZmFsc2UsXG4gICAgICAgIG5lZWRzVXBkYXRlOiBmYWxzZSxcbiAgICAgICAgZnVsbHNjcmVlbjogZmFsc2UsXG4gICAgICAgIGRpcmVjdGlvbjogbmV3IHRocmVlLlZlY3RvcjMoMCwgMCwgU1BIRVJFX1JBRElVUyksXG4gICAgICAgIHZGb3Y6IG51bGwsXG4gICAgICAgIGhGb3Y6IG51bGwsXG4gICAgICAgIGFzcGVjdDogbnVsbCxcbiAgICAgICAgYXV0b3JvdGF0ZUVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBhbmltYXRpb25Qcm9taXNlOiBudWxsLFxuICAgICAgICBsb2FkaW5nUHJvbWlzZTogbnVsbCxcbiAgICAgICAgbGl0dGxlUGxhbmV0OiBmYWxzZSxcbiAgICAgICAgaWRsZVRpbWU6IC0xLFxuICAgICAgICBvYmplY3RzT2JzZXJ2ZXJzOiB7fSxcbiAgICAgICAgc2l6ZToge1xuICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9LFxuICAgICAgICBwYW5vRGF0YToge1xuICAgICAgICAgIGZ1bGxXaWR0aDogMCxcbiAgICAgICAgICBmdWxsSGVpZ2h0OiAwLFxuICAgICAgICAgIGNyb3BwZWRXaWR0aDogMCxcbiAgICAgICAgICBjcm9wcGVkSGVpZ2h0OiAwLFxuICAgICAgICAgIGNyb3BwZWRYOiAwLFxuICAgICAgICAgIGNyb3BwZWRZOiAwLFxuICAgICAgICAgIHBvc2VIZWFkaW5nOiAwLFxuICAgICAgICAgIHBvc2VQaXRjaDogMCxcbiAgICAgICAgICBwb3NlUm9sbDogMFxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiBAc3VtbWFyeSBDb25maWd1cmF0aW9uIGhvbGRlclxuICAgICAgICogQHR5cGUge1BTVi5PcHRpb25zfVxuICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgKi9cblxuICAgICAgX3RoaXMuY29uZmlnID0gZ2V0Q29uZmlnKG9wdGlvbnMpO1xuICAgICAgLyoqXG4gICAgICAgKiBAc3VtbWFyeSBUb3AgbW9zdCBwYXJlbnRcbiAgICAgICAqIEBtZW1iZXIge0hUTUxFbGVtZW50fVxuICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgKi9cblxuICAgICAgX3RoaXMucGFyZW50ID0gdHlwZW9mIG9wdGlvbnMuY29udGFpbmVyID09PSAnc3RyaW5nJyA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG9wdGlvbnMuY29udGFpbmVyKSA6IG9wdGlvbnMuY29udGFpbmVyO1xuICAgICAgX3RoaXMucGFyZW50W1ZJRVdFUl9EQVRBXSA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpO1xuICAgICAgLyoqXG4gICAgICAgKiBAc3VtbWFyeSBNYWluIGNvbnRhaW5lclxuICAgICAgICogQG1lbWJlciB7SFRNTEVsZW1lbnR9XG4gICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAqL1xuXG4gICAgICBfdGhpcy5jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgX3RoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3Bzdi1jb250YWluZXInKTtcblxuICAgICAgX3RoaXMucGFyZW50LmFwcGVuZENoaWxkKF90aGlzLmNvbnRhaW5lcik7XG4gICAgICAvKipcbiAgICAgICAqIEBzdW1tYXJ5IFJlbmRlciBhZGFwdGVyXG4gICAgICAgKiBAdHlwZSB7UFNWLmFkYXB0ZXJzLkFic3RyYWN0QWRhcHRlcn1cbiAgICAgICAqIEByZWFkb25seVxuICAgICAgICogQHBhY2thZ2VcbiAgICAgICAqL1xuXG5cbiAgICAgIF90aGlzLmFkYXB0ZXIgPSBuZXcgX3RoaXMuY29uZmlnLmFkYXB0ZXJbMF0oX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIF90aGlzLmNvbmZpZy5hZGFwdGVyWzFdKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXG5cbiAgICAgIC8qKlxuICAgICAgICogQHN1bW1hcnkgQWxsIGNoaWxkIGNvbXBvbmVudHNcbiAgICAgICAqIEB0eXBlIHtQU1YuY29tcG9uZW50cy5BYnN0cmFjdENvbXBvbmVudFtdfVxuICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgKiBAcGFja2FnZVxuICAgICAgICovXG5cbiAgICAgIF90aGlzLmNoaWxkcmVuID0gW107XG4gICAgICAvKipcbiAgICAgICAqIEBzdW1tYXJ5IEFsbCBwbHVnaW5zXG4gICAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgUFNWLnBsdWdpbnMuQWJzdHJhY3RQbHVnaW4+fVxuICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgKiBAcGFja2FnZVxuICAgICAgICovXG5cbiAgICAgIF90aGlzLnBsdWdpbnMgPSB7fTtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge1BTVi5zZXJ2aWNlcy5SZW5kZXJlcn1cbiAgICAgICAqIEByZWFkb25seVxuICAgICAgICovXG5cbiAgICAgIF90aGlzLnJlbmRlcmVyID0gbmV3IFJlbmRlcmVyKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge1BTVi5zZXJ2aWNlcy5UZXh0dXJlTG9hZGVyfVxuICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgKi9cblxuICAgICAgX3RoaXMudGV4dHVyZUxvYWRlciA9IG5ldyBUZXh0dXJlTG9hZGVyKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge1BTVi5zZXJ2aWNlcy5FdmVudHNIYW5kbGVyfVxuICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgKi9cblxuICAgICAgX3RoaXMuZXZlbnRzSGFuZGxlciA9IG5ldyBFdmVudHNIYW5kbGVyKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge1BTVi5zZXJ2aWNlcy5EYXRhSGVscGVyfVxuICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgKi9cblxuICAgICAgX3RoaXMuZGF0YUhlbHBlciA9IG5ldyBEYXRhSGVscGVyKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7UFNWLmNvbXBvbmVudHMuTG9hZGVyfVxuICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgKi9cblxuICAgICAgX3RoaXMubG9hZGVyID0gbmV3IExvYWRlcihfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge1BTVi5jb21wb25lbnRzLk5hdmJhcn1cbiAgICAgICAqIEByZWFkb25seVxuICAgICAgICovXG5cbiAgICAgIF90aGlzLm5hdmJhciA9IG5ldyBOYXZiYXIoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtQU1YuY29tcG9uZW50cy5QYW5lbH1cbiAgICAgICAqIEByZWFkb25seVxuICAgICAgICovXG5cbiAgICAgIF90aGlzLnBhbmVsID0gbmV3IFBhbmVsKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7UFNWLnNlcnZpY2VzLlRvb2x0aXBSZW5kZXJlcn1cbiAgICAgICAqIEByZWFkb25seVxuICAgICAgICovXG5cbiAgICAgIF90aGlzLnRvb2x0aXAgPSBuZXcgVG9vbHRpcFJlbmRlcmVyKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7UFNWLmNvbXBvbmVudHMuTm90aWZpY2F0aW9ufVxuICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgKi9cblxuICAgICAgX3RoaXMubm90aWZpY2F0aW9uID0gbmV3IE5vdGlmaWNhdGlvbihfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge1BTVi5jb21wb25lbnRzLk92ZXJsYXl9XG4gICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAqL1xuXG4gICAgICBfdGhpcy5vdmVybGF5ID0gbmV3IE92ZXJsYXkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtSZWNvcmQ8c3RyaW5nLCBQU1YudXRpbHMuRHluYW1pYz59XG4gICAgICAgKiBAcGFja2FnZVxuICAgICAgICovXG5cbiAgICAgIF90aGlzLmR5bmFtaWNzID0ge1xuICAgICAgICB6b29tOiBuZXcgRHluYW1pYyhmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBfdGhpcy5wcm9wLnZGb3YgPSBfdGhpcy5kYXRhSGVscGVyLnpvb21MZXZlbFRvRm92KHZhbHVlKTtcbiAgICAgICAgICBfdGhpcy5wcm9wLmhGb3YgPSBfdGhpcy5kYXRhSGVscGVyLnZGb3ZUb0hGb3YoX3RoaXMucHJvcC52Rm92KTtcblxuICAgICAgICAgIF90aGlzLnRyaWdnZXIoRVZFTlRTLlpPT01fVVBEQVRFRCwgdmFsdWUpO1xuICAgICAgICB9LCBfdGhpcy5jb25maWcuZGVmYXVsdFpvb21MdmwsIDAsIDEwMCksXG4gICAgICAgIHBvc2l0aW9uOiBuZXcgTXVsdGlEeW5hbWljKHtcbiAgICAgICAgICBsb25naXR1ZGU6IG5ldyBEeW5hbWljKG51bGwsIF90aGlzLmNvbmZpZy5kZWZhdWx0TG9uZywgMCwgMiAqIE1hdGguUEksIHRydWUpLFxuICAgICAgICAgIGxhdGl0dWRlOiBfdGhpcy5wcm9wLmxpdHRsZVBsYW5ldCA/IG5ldyBEeW5hbWljKG51bGwsIF90aGlzLmNvbmZpZy5kZWZhdWx0TGF0LCAwLCBNYXRoLlBJICogMiwgdHJ1ZSkgOiBuZXcgRHluYW1pYyhudWxsLCBfdGhpcy5jb25maWcuZGVmYXVsdExhdCwgLU1hdGguUEkgLyAyLCBNYXRoLlBJIC8gMilcbiAgICAgICAgfSwgZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICAgICAgX3RoaXMuZGF0YUhlbHBlci5zcGhlcmljYWxDb29yZHNUb1ZlY3RvcjMocG9zaXRpb24sIF90aGlzLnByb3AuZGlyZWN0aW9uKTtcblxuICAgICAgICAgIF90aGlzLnRyaWdnZXIoRVZFTlRTLlBPU0lUSU9OX1VQREFURUQsIHBvc2l0aW9uKTtcbiAgICAgICAgfSlcbiAgICAgIH07XG5cbiAgICAgIF90aGlzLl9fdXBkYXRlU3BlZWRzKCk7XG5cbiAgICAgIF90aGlzLmV2ZW50c0hhbmRsZXIuaW5pdCgpO1xuXG4gICAgICBfdGhpcy5fX3Jlc2l6ZVJlZnJlc2ggPSB0aHJvdHRsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5yZWZyZXNoVWkoJ3Jlc2l6ZScpO1xuICAgICAgfSwgNTAwKTsgLy8gYXBwbHkgY29udGFpbmVyIHNpemVcblxuICAgICAgX3RoaXMucmVzaXplKF90aGlzLmNvbmZpZy5zaXplKTsgLy8gaW5pdCBwbHVnaW5zXG5cblxuICAgICAgX3RoaXMuY29uZmlnLnBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgcGx1Z2luID0gX3JlZlswXSxcbiAgICAgICAgICAgIG9wdHMgPSBfcmVmWzFdO1xuICAgICAgICBfdGhpcy5wbHVnaW5zW3BsdWdpbi5pZF0gPSBuZXcgcGx1Z2luKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBvcHRzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXG4gICAgICB9KTtcblxuICAgICAgZWFjaChfdGhpcy5wbHVnaW5zLCBmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICAgIHJldHVybiBwbHVnaW4uaW5pdCA9PSBudWxsID8gdm9pZCAwIDogcGx1Z2luLmluaXQoKTtcbiAgICAgIH0pOyAvLyBpbml0IGJ1dHRvbnNcblxuICAgICAgX3RoaXMubmF2YmFyLnNldEJ1dHRvbnMoX3RoaXMuY29uZmlnLm5hdmJhcik7IC8vIGxvYWQgcGFub3JhbWFcblxuXG4gICAgICBpZiAoX3RoaXMuY29uZmlnLnBhbm9yYW1hKSB7XG4gICAgICAgIF90aGlzLnNldFBhbm9yYW1hKF90aGlzLmNvbmZpZy5wYW5vcmFtYSk7XG4gICAgICB9XG5cbiAgICAgIHRvZ2dsZUNsYXNzKF90aGlzLmNvbnRhaW5lciwgJ3Bzdi0taXMtdG91Y2gnLCBTWVNURU0uaXNUb3VjaEVuYWJsZWQuaW5pdGlhbCk7XG4gICAgICBTWVNURU0uaXNUb3VjaEVuYWJsZWQucHJvbWlzZS50aGVuKGZ1bmN0aW9uIChlbmFibGVkKSB7XG4gICAgICAgIHJldHVybiB0b2dnbGVDbGFzcyhfdGhpcy5jb250YWluZXIsICdwc3YtLWlzLXRvdWNoJywgZW5hYmxlZCk7XG4gICAgICB9KTsgLy8gZW5hYmxlIEdVSSBhZnRlciBmaXJzdCByZW5kZXJcblxuICAgICAgX3RoaXMub25jZShFVkVOVFMuUkVOREVSLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpcy5jb25maWcubmF2YmFyKSB7XG4gICAgICAgICAgX3RoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3Bzdi0taGFzLW5hdmJhcicpO1xuXG4gICAgICAgICAgX3RoaXMubmF2YmFyLnNob3coKTtcbiAgICAgICAgfSAvLyBRdWV1ZSBhdXRvcm90YXRlXG5cblxuICAgICAgICBpZiAoIWlzTmlsKF90aGlzLmNvbmZpZy5hdXRvcm90YXRlRGVsYXkpKSB7XG4gICAgICAgICAgX3RoaXMucHJvcC5pZGxlVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMucHJvcC5yZWFkeSA9IHRydWU7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLnJlZnJlc2hVaSgnaW5pdCcpO1xuXG4gICAgICAgICAgX3RoaXMudHJpZ2dlcihFVkVOVFMuUkVBRFkpO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IERlc3Ryb3lzIHRoZSB2aWV3ZXJcbiAgICAgKiBAZGVzY3JpcHRpb24gVGhlIG1lbW9yeSB1c2VkIGJ5IHRoZSBUaHJlZUpTIGNvbnRleHQgaXMgbm90IHRvdGFsbHkgY2xlYXJlZC4gVGhpcyB3aWxsIGJlIGZpeGVkIGFzIHNvb24gYXMgcG9zc2libGUuXG4gICAgICovXG5cblxuICAgIHZhciBfcHJvdG8gPSBWaWV3ZXIucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy5fX3N0b3BBbGwoKTtcblxuICAgICAgdGhpcy5zdG9wS2V5Ym9hcmRDb250cm9sKCk7XG4gICAgICB0aGlzLmV4aXRGdWxsc2NyZWVuKCk7XG4gICAgICBlYWNoKHRoaXMucGx1Z2lucywgZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgICByZXR1cm4gcGx1Z2luLmRlc3Ryb3koKTtcbiAgICAgIH0pO1xuICAgICAgZGVsZXRlIHRoaXMucGx1Z2lucztcbiAgICAgIHRoaXMuY2hpbGRyZW4uc2xpY2UoKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gY2hpbGQuZGVzdHJveSgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLmV2ZW50c0hhbmRsZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5yZW5kZXJlci5kZXN0cm95KCk7XG4gICAgICB0aGlzLnRleHR1cmVMb2FkZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5kYXRhSGVscGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuYWRhcHRlci5kZXN0cm95KCk7XG4gICAgICB0aGlzLnBhcmVudC5yZW1vdmVDaGlsZCh0aGlzLmNvbnRhaW5lcik7XG4gICAgICBkZWxldGUgdGhpcy5wYXJlbnRbVklFV0VSX0RBVEFdO1xuICAgICAgZGVsZXRlIHRoaXMucGFyZW50O1xuICAgICAgZGVsZXRlIHRoaXMuY29udGFpbmVyO1xuICAgICAgZGVsZXRlIHRoaXMubG9hZGVyO1xuICAgICAgZGVsZXRlIHRoaXMubmF2YmFyO1xuICAgICAgZGVsZXRlIHRoaXMucGFuZWw7XG4gICAgICBkZWxldGUgdGhpcy50b29sdGlwO1xuICAgICAgZGVsZXRlIHRoaXMubm90aWZpY2F0aW9uO1xuICAgICAgZGVsZXRlIHRoaXMub3ZlcmxheTtcbiAgICAgIGRlbGV0ZSB0aGlzLmR5bmFtaWNzO1xuICAgICAgZGVsZXRlIHRoaXMuY29uZmlnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBSZWZyZXNoIFVJXG4gICAgICogQHBhY2thZ2VcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8ucmVmcmVzaFVpID0gZnVuY3Rpb24gcmVmcmVzaFVpKHJlYXNvbikge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy5wcm9wLnJlYWR5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLnByb3AudWlSZWZyZXNoKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGBQaG90b1NwaGVyZVZpZXdlcjogVUkgUmVmcmVzaCwgJHtyZWFzb259YCk7XG4gICAgICAgIHRoaXMucHJvcC51aVJlZnJlc2ggPSB0cnVlO1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmV2ZXJ5KGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgIGNoaWxkLnJlZnJlc2hVaSgpO1xuICAgICAgICAgIHJldHVybiBfdGhpczIucHJvcC51aVJlZnJlc2ggPT09IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnByb3AudWlSZWZyZXNoID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucHJvcC51aVJlZnJlc2ggIT09ICduZXcnKSB7XG4gICAgICAgIHRoaXMucHJvcC51aVJlZnJlc2ggPSAnbmV3JzsgLy8gd2FpdCBmb3IgY3VycmVudCByZWZyZXNoIHRvIGNhbmNlbFxuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMi5wcm9wLnVpUmVmcmVzaCA9IGZhbHNlO1xuXG4gICAgICAgICAgX3RoaXMyLnJlZnJlc2hVaShyZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgYSBwbHVnaW4gaWYgaXQgZXhpc3RzXG4gICAgICogQHBhcmFtIHtDbGFzczxQU1YucGx1Z2lucy5BYnN0cmFjdFBsdWdpbj58c3RyaW5nfSBwbHVnaW5JZFxuICAgICAqIEByZXR1cm5zIHtQU1YucGx1Z2lucy5BYnN0cmFjdFBsdWdpbn1cbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uZ2V0UGx1Z2luID0gZnVuY3Rpb24gZ2V0UGx1Z2luKHBsdWdpbklkKSB7XG4gICAgICBpZiAodHlwZW9mIHBsdWdpbklkID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdGhpcy5wbHVnaW5zW3BsdWdpbklkXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwbHVnaW5DdG9yID0gcGx1Z2luSW50ZXJvcChwbHVnaW5JZCwgQWJzdHJhY3RQbHVnaW4pO1xuICAgICAgICByZXR1cm4gcGx1Z2luQ3RvciA/IHRoaXMucGx1Z2luc1twbHVnaW5DdG9yLmlkXSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgUmV0dXJucyB0aGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgY2FtZXJhXG4gICAgICogQHJldHVybnMge1BTVi5Qb3NpdGlvbn1cbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiBnZXRQb3NpdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmRhdGFIZWxwZXIuY2xlYW5Qb3NpdGlvbih0aGlzLmR5bmFtaWNzLnBvc2l0aW9uLmN1cnJlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBSZXR1cm5zIHRoZSBjdXJyZW50IHpvb20gbGV2ZWxcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5nZXRab29tTGV2ZWwgPSBmdW5jdGlvbiBnZXRab29tTGV2ZWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5keW5hbWljcy56b29tLmN1cnJlbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFJldHVybnMgdGhlIGN1cnJlbnQgdmlld2VyIHNpemVcbiAgICAgKiBAcmV0dXJucyB7UFNWLlNpemV9XG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLmdldFNpemUgPSBmdW5jdGlvbiBnZXRTaXplKCkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCB0aGlzLnByb3Auc2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IENoZWNrcyBpZiB0aGUgYXV0b21hdGljIHJvdGF0aW9uIGlzIGVuYWJsZWRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uaXNBdXRvcm90YXRlRW5hYmxlZCA9IGZ1bmN0aW9uIGlzQXV0b3JvdGF0ZUVuYWJsZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wLmF1dG9yb3RhdGVFbmFibGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBDaGVja3MgaWYgdGhlIHZpZXdlciBpcyBpbiBmdWxsc2NyZWVuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLmlzRnVsbHNjcmVlbkVuYWJsZWQgPSBmdW5jdGlvbiBpc0Z1bGxzY3JlZW5FbmFibGVkJDEoKSB7XG4gICAgICBpZiAoU1lTVEVNLmZ1bGxzY3JlZW5FdmVudCkge1xuICAgICAgICByZXR1cm4gaXNGdWxsc2NyZWVuRW5hYmxlZCh0aGlzLmNvbnRhaW5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wLmZ1bGxzY3JlZW47XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEZsYWdzIHRoZSB2aWV3IGhhcyBjaGFuZ2VkIGZvciB0aGUgbmV4dCByZW5kZXJcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8ubmVlZHNVcGRhdGUgPSBmdW5jdGlvbiBuZWVkc1VwZGF0ZSgpIHtcbiAgICAgIHRoaXMucHJvcC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFJlc2l6ZXMgdGhlIGNhbnZhcyB3aGVuIHRoZSB3aW5kb3cgaXMgcmVzaXplZFxuICAgICAqIEBmaXJlcyBQU1Yuc2l6ZS11cGRhdGVkXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLmF1dG9TaXplID0gZnVuY3Rpb24gYXV0b1NpemUoKSB7XG4gICAgICBpZiAodGhpcy5jb250YWluZXIuY2xpZW50V2lkdGggIT09IHRoaXMucHJvcC5zaXplLndpZHRoIHx8IHRoaXMuY29udGFpbmVyLmNsaWVudEhlaWdodCAhPT0gdGhpcy5wcm9wLnNpemUuaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMucHJvcC5zaXplLndpZHRoID0gTWF0aC5yb3VuZCh0aGlzLmNvbnRhaW5lci5jbGllbnRXaWR0aCk7XG4gICAgICAgIHRoaXMucHJvcC5zaXplLmhlaWdodCA9IE1hdGgucm91bmQodGhpcy5jb250YWluZXIuY2xpZW50SGVpZ2h0KTtcbiAgICAgICAgdGhpcy5wcm9wLmFzcGVjdCA9IHRoaXMucHJvcC5zaXplLndpZHRoIC8gdGhpcy5wcm9wLnNpemUuaGVpZ2h0O1xuICAgICAgICB0aGlzLnByb3AuaEZvdiA9IHRoaXMuZGF0YUhlbHBlci52Rm92VG9IRm92KHRoaXMucHJvcC52Rm92KTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKEVWRU5UUy5TSVpFX1VQREFURUQsIHRoaXMuZ2V0U2l6ZSgpKTtcblxuICAgICAgICB0aGlzLl9fcmVzaXplUmVmcmVzaCgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBMb2FkcyBhIG5ldyBwYW5vcmFtYSBmaWxlXG4gICAgICogQGRlc2NyaXB0aW9uIExvYWRzIGEgbmV3IHBhbm9yYW1hIGZpbGUsIG9wdGlvbmFsbHkgY2hhbmdpbmcgdGhlIGNhbWVyYSBwb3NpdGlvbi96b29tIGFuZCBhY3RpdmF0aW5nIHRoZSB0cmFuc2l0aW9uIGFuaW1hdGlvbi48YnI+XG4gICAgICogSWYgdGhlIFwib3B0aW9uc1wiIHBhcmFtZXRlciBpcyBub3QgZGVmaW5lZCwgdGhlIGNhbWVyYSB3aWxsIG5vdCBtb3ZlIGFuZCB0aGUgb25nb2luZyBhbmltYXRpb24gd2lsbCBjb250aW51ZS48YnI+XG4gICAgICogSWYgYW5vdGhlciBsb2FkaW5nIGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3MgaXQgd2lsbCBiZSBhYm9ydGVkLlxuICAgICAqIEBwYXJhbSB7Kn0gcGF0aCAtIFVSTCBvZiB0aGUgbmV3IHBhbm9yYW1hIGZpbGVcbiAgICAgKiBAcGFyYW0ge1BTVi5QYW5vcmFtYU9wdGlvbnN9IFtvcHRpb25zXVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSByZXNvbHZlcyBmYWxzZSBpZiB0aGUgbG9hZGluZyB3YXMgYWJvcnRlZCBieSBhbm90aGVyIGNhbGxcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uc2V0UGFub3JhbWEgPSBmdW5jdGlvbiBzZXRQYW5vcmFtYShwYXRoLCBvcHRpb25zKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcCR0cmFuc2l0aW9uLFxuICAgICAgICAgIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRleHR1cmVMb2FkZXIuYWJvcnRMb2FkaW5nKCk7XG4gICAgICAoX3RoaXMkcHJvcCR0cmFuc2l0aW9uID0gdGhpcy5wcm9wLnRyYW5zaXRpb25BbmltYXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRwcm9wJHRyYW5zaXRpb24uY2FuY2VsKCk7IC8vIGFwcGx5IGRlZmF1bHQgcGFyYW1ldGVycyBvbiBmaXJzdCBsb2FkXG5cbiAgICAgIGlmICghdGhpcy5wcm9wLnJlYWR5KSB7XG4gICAgICAgIFsnc3BoZXJlQ29ycmVjdGlvbicsICdwYW5vRGF0YScsICdvdmVybGF5JywgJ292ZXJsYXlPcGFjaXR5J10uZm9yRWFjaChmdW5jdGlvbiAob3B0KSB7XG4gICAgICAgICAgaWYgKCEob3B0IGluIG9wdGlvbnMpKSB7XG4gICAgICAgICAgICBvcHRpb25zW29wdF0gPSBfdGhpczMuY29uZmlnW29wdF07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMudHJhbnNpdGlvbiA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMudHJhbnNpdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICBvcHRpb25zLnRyYW5zaXRpb24gPSBERUZBVUxUX1RSQU5TSVRJT047XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnNob3dMb2FkZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLnNob3dMb2FkZXIgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5jYXB0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5jYXB0aW9uID0gdGhpcy5jb25maWcuY2FwdGlvbjtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuZGVzY3JpcHRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLmRlc2NyaXB0aW9uID0gdGhpcy5jb25maWcuZGVzY3JpcHRpb247XG4gICAgICB9XG5cbiAgICAgIGlmICghb3B0aW9ucy5wYW5vRGF0YSAmJiB0eXBlb2YgdGhpcy5jb25maWcucGFub0RhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb3B0aW9ucy5wYW5vRGF0YSA9IHRoaXMuY29uZmlnLnBhbm9EYXRhO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9zaXRpb25Qcm92aWRlZCA9IGlzRXh0ZW5kZWRQb3NpdGlvbihvcHRpb25zKTtcbiAgICAgIHZhciB6b29tUHJvdmlkZWQgPSAoJ3pvb20nIGluIG9wdGlvbnMpO1xuXG4gICAgICBpZiAocG9zaXRpb25Qcm92aWRlZCB8fCB6b29tUHJvdmlkZWQpIHtcbiAgICAgICAgdGhpcy5fX3N0b3BBbGwoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5oaWRlRXJyb3IoKTtcbiAgICAgIHRoaXMuY29uZmlnLnBhbm9yYW1hID0gcGF0aDtcbiAgICAgIHRoaXMuY29uZmlnLmNhcHRpb24gPSBvcHRpb25zLmNhcHRpb247XG4gICAgICB0aGlzLmNvbmZpZy5kZXNjcmlwdGlvbiA9IG9wdGlvbnMuZGVzY3JpcHRpb247XG5cbiAgICAgIHZhciBkb25lID0gZnVuY3Rpb24gZG9uZShlcnIpIHtcbiAgICAgICAgX3RoaXMzLmxvYWRlci5oaWRlKCk7XG5cbiAgICAgICAgX3RoaXMzLnByb3AubG9hZGluZ1Byb21pc2UgPSBudWxsO1xuXG4gICAgICAgIGlmIChpc0Fib3J0RXJyb3IoZXJyKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChlcnIpIHtcbiAgICAgICAgICBfdGhpczMubmF2YmFyLnNldENhcHRpb24oJycpO1xuXG4gICAgICAgICAgX3RoaXMzLnNob3dFcnJvcihfdGhpczMuY29uZmlnLmxhbmcubG9hZEVycm9yKTtcblxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMzLnJlc2V0SWRsZVRpbWVyKCk7XG5cbiAgICAgICAgICBfdGhpczMuc2V0T3ZlcmxheShvcHRpb25zLm92ZXJsYXksIG9wdGlvbnMub3ZlcmxheU9wYWNpdHkpO1xuXG4gICAgICAgICAgX3RoaXMzLm5hdmJhci5zZXRDYXB0aW9uKF90aGlzMy5jb25maWcuY2FwdGlvbik7XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5uYXZiYXIuc2V0Q2FwdGlvbihcIjxlbT5cIiArICh0aGlzLmNvbmZpZy5sb2FkaW5nVHh0IHx8ICcnKSArIFwiPC9lbT5cIik7XG5cbiAgICAgIGlmIChvcHRpb25zLnNob3dMb2FkZXIgfHwgIXRoaXMucHJvcC5yZWFkeSkge1xuICAgICAgICB0aGlzLmxvYWRlci5zaG93KCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBsb2FkaW5nUHJvbWlzZSA9IHRoaXMuYWRhcHRlci5sb2FkVGV4dHVyZSh0aGlzLmNvbmZpZy5wYW5vcmFtYSwgb3B0aW9ucy5wYW5vRGF0YSkudGhlbihmdW5jdGlvbiAodGV4dHVyZURhdGEpIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgYW5vdGhlciBwYW5vcmFtYSB3YXMgcmVxdWVzdGVkXG4gICAgICAgIGlmICh0ZXh0dXJlRGF0YS5wYW5vcmFtYSAhPT0gX3RoaXMzLmNvbmZpZy5wYW5vcmFtYSkge1xuICAgICAgICAgIF90aGlzMy5hZGFwdGVyLmRpc3Bvc2VUZXh0dXJlKHRleHR1cmVEYXRhKTtcblxuICAgICAgICAgIHRocm93IGdldEFib3J0RXJyb3IoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZXh0dXJlRGF0YTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIW9wdGlvbnMudHJhbnNpdGlvbiB8fCAhdGhpcy5wcm9wLnJlYWR5IHx8ICF0aGlzLmFkYXB0ZXIuc3VwcG9ydHNUcmFuc2l0aW9uKHRoaXMuY29uZmlnLnBhbm9yYW1hKSkge1xuICAgICAgICB0aGlzLnByb3AubG9hZGluZ1Byb21pc2UgPSBsb2FkaW5nUHJvbWlzZS50aGVuKGZ1bmN0aW9uICh0ZXh0dXJlRGF0YSkge1xuICAgICAgICAgIF90aGlzMy5yZW5kZXJlci5zaG93KCk7XG5cbiAgICAgICAgICBfdGhpczMucmVuZGVyZXIuc2V0VGV4dHVyZSh0ZXh0dXJlRGF0YSk7XG5cbiAgICAgICAgICBfdGhpczMucmVuZGVyZXIuc2V0UGFub3JhbWFQb3NlKHRleHR1cmVEYXRhLnBhbm9EYXRhKTtcblxuICAgICAgICAgIF90aGlzMy5yZW5kZXJlci5zZXRTcGhlcmVDb3JyZWN0aW9uKG9wdGlvbnMuc3BoZXJlQ29ycmVjdGlvbik7XG5cbiAgICAgICAgICBpZiAoem9vbVByb3ZpZGVkKSB7XG4gICAgICAgICAgICBfdGhpczMuem9vbShvcHRpb25zLnpvb20pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwb3NpdGlvblByb3ZpZGVkKSB7XG4gICAgICAgICAgICBfdGhpczMucm90YXRlKG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkudGhlbihkb25lLCBkb25lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJvcC5sb2FkaW5nUHJvbWlzZSA9IGxvYWRpbmdQcm9taXNlLnRoZW4oZnVuY3Rpb24gKHRleHR1cmVEYXRhKSB7XG4gICAgICAgICAgX3RoaXMzLmxvYWRlci5oaWRlKCk7XG5cbiAgICAgICAgICBfdGhpczMucHJvcC50cmFuc2l0aW9uQW5pbWF0aW9uID0gX3RoaXMzLnJlbmRlcmVyLnRyYW5zaXRpb24odGV4dHVyZURhdGEsIG9wdGlvbnMpO1xuICAgICAgICAgIHJldHVybiBfdGhpczMucHJvcC50cmFuc2l0aW9uQW5pbWF0aW9uO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChjb21wbGV0ZWQpIHtcbiAgICAgICAgICBfdGhpczMucHJvcC50cmFuc2l0aW9uQW5pbWF0aW9uID0gbnVsbDtcblxuICAgICAgICAgIGlmICghY29tcGxldGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBnZXRBYm9ydEVycm9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KS50aGVuKGRvbmUsIGRvbmUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5wcm9wLmxvYWRpbmdQcm9taXNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBMb2FkcyBhIG5ldyBvdmVybGF5XG4gICAgICogQHBhcmFtIHsqfSBwYXRoIC0gVVJMIG9mIHRoZSBuZXcgb3ZlcmxheSBmaWxlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcGFjaXR5PTFdXG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLnNldE92ZXJsYXkgPSBmdW5jdGlvbiBzZXRPdmVybGF5KHBhdGgsIG9wYWNpdHkpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICBpZiAob3BhY2l0eSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIG9wYWNpdHkgPSAxO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgaWYgKHRoaXMuYWRhcHRlci5jb25zdHJ1Y3Rvci5zdXBwb3J0c092ZXJsYXkpIHtcbiAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldE92ZXJsYXkobnVsbCwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXRoaXMuYWRhcHRlci5jb25zdHJ1Y3Rvci5zdXBwb3J0c092ZXJsYXkpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFBTVkVycm9yKHRoaXMuYWRhcHRlci5jb25zdHJ1Y3Rvci5pZCArIFwiIGFkYXB0ZXIgZG9lcyBub3Qgc3VwcG9ydHMgb3ZlcmxheVwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5hZGFwdGVyLmxvYWRUZXh0dXJlKHBhdGgsIGZ1bmN0aW9uIChpbWFnZSkge1xuICAgICAgICAgIHZhciBwID0gX3RoaXM0LnByb3AucGFub0RhdGE7XG4gICAgICAgICAgdmFyIHIgPSBpbWFnZS53aWR0aCAvIHAuY3JvcHBlZFdpZHRoO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmdWxsV2lkdGg6IHIgKiBwLmZ1bGxXaWR0aCxcbiAgICAgICAgICAgIGZ1bGxIZWlnaHQ6IHIgKiBwLmZ1bGxIZWlnaHQsXG4gICAgICAgICAgICBjcm9wcGVkV2lkdGg6IHIgKiBwLmNyb3BwZWRXaWR0aCxcbiAgICAgICAgICAgIGNyb3BwZWRIZWlnaHQ6IHIgKiBwLmNyb3BwZWRIZWlnaHQsXG4gICAgICAgICAgICBjcm9wcGVkWDogciAqIHAuY3JvcHBlZFgsXG4gICAgICAgICAgICBjcm9wcGVkWTogciAqIHAuY3JvcHBlZFlcbiAgICAgICAgICB9O1xuICAgICAgICB9LCBmYWxzZSkudGhlbihmdW5jdGlvbiAodGV4dHVyZURhdGEpIHtcbiAgICAgICAgICBfdGhpczQucmVuZGVyZXIuc2V0T3ZlcmxheSh0ZXh0dXJlRGF0YSwgb3BhY2l0eSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBVcGRhdGUgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7UFNWLk9wdGlvbnN9IG9wdGlvbnNcbiAgICAgKiBAZmlyZXMgUFNWLmNvbmZpZy1jaGFuZ2VkXG4gICAgICogQHRocm93cyB7UFNWLlBTVkVycm9yfSB3aGVuIHRoZSBjb25maWd1cmF0aW9uIGlzIGluY29ycmVjdFxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5zZXRPcHRpb25zID0gZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgdmFyIHJhd0NvbmZpZyA9IF9leHRlbmRzKHt9LCB0aGlzLmNvbmZpZywgb3B0aW9ucyk7XG5cbiAgICAgIGVhY2gob3B0aW9ucywgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgaWYgKERFUFJFQ0FURURfT1BUSU9OU1trZXldKSB7XG4gICAgICAgICAgbG9nV2FybihERVBSRUNBVEVEX09QVElPTlNba2V5XSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoREVGQVVMVFMsIGtleSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUFNWRXJyb3IoXCJVbmtub3duIG9wdGlvbiBcIiArIGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoUkVBRE9OTFlfT1BUSU9OU1trZXldKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBTVkVycm9yKFJFQURPTkxZX09QVElPTlNba2V5XSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQ09ORklHX1BBUlNFUlNba2V5XSkge1xuICAgICAgICAgIF90aGlzNS5jb25maWdba2V5XSA9IENPTkZJR19QQVJTRVJTW2tleV0odmFsdWUsIHJhd0NvbmZpZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXM1LmNvbmZpZ1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgIGNhc2UgJ292ZXJsYXknOlxuICAgICAgICAgIGNhc2UgJ292ZXJsYXlPcGFjaXR5JzpcbiAgICAgICAgICAgIF90aGlzNS5zZXRPdmVybGF5KF90aGlzNS5jb25maWcub3ZlcmxheSwgX3RoaXM1LmNvbmZpZy5vdmVybGF5T3BhY2l0eSk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnY2FwdGlvbic6XG4gICAgICAgICAgY2FzZSAnZGVzY3JpcHRpb24nOlxuICAgICAgICAgICAgX3RoaXM1Lm5hdmJhci5zZXRDYXB0aW9uKF90aGlzNS5jb25maWcuY2FwdGlvbik7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnc2l6ZSc6XG4gICAgICAgICAgICBfdGhpczUucmVzaXplKHZhbHVlKTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdzcGhlcmVDb3JyZWN0aW9uJzpcbiAgICAgICAgICAgIF90aGlzNS5yZW5kZXJlci5zZXRTcGhlcmVDb3JyZWN0aW9uKHZhbHVlKTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICduYXZiYXInOlxuICAgICAgICAgIGNhc2UgJ2xhbmcnOlxuICAgICAgICAgICAgX3RoaXM1Lm5hdmJhci5zZXRCdXR0b25zKF90aGlzNS5jb25maWcubmF2YmFyKTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdtb3ZlU3BlZWQnOlxuICAgICAgICAgIGNhc2UgJ3pvb21TcGVlZCc6XG4gICAgICAgICAgICBfdGhpczUuX191cGRhdGVTcGVlZHMoKTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdtaW5Gb3YnOlxuICAgICAgICAgIGNhc2UgJ21heEZvdic6XG4gICAgICAgICAgICBfdGhpczUuZHluYW1pY3Muem9vbS5zZXRWYWx1ZShfdGhpczUuZGF0YUhlbHBlci5mb3ZUb1pvb21MZXZlbChfdGhpczUucHJvcC52Rm92KSk7XG5cbiAgICAgICAgICAgIF90aGlzNS50cmlnZ2VyKEVWRU5UUy5aT09NX1VQREFURUQsIF90aGlzNS5nZXRab29tTGV2ZWwoKSk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnY2FudmFzQmFja2dyb3VuZCc6XG4gICAgICAgICAgICBfdGhpczUucmVuZGVyZXIuY2FudmFzQ29udGFpbmVyLnN0eWxlLmJhY2tncm91bmQgPSBfdGhpczUuY29uZmlnLmNhbnZhc0JhY2tncm91bmQ7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2F1dG9yb3RhdGVJZGxlJzpcbiAgICAgICAgICAgIF90aGlzNS5yZXNldElkbGVUaW1lcigpO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLm5lZWRzVXBkYXRlKCk7XG4gICAgICB0aGlzLnJlZnJlc2hVaSgnc2V0IG9wdGlvbnMnKTtcbiAgICAgIHRoaXMudHJpZ2dlcihFVkVOVFMuQ09ORklHX0NIQU5HRUQsIE9iamVjdC5rZXlzKG9wdGlvbnMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgVXBkYXRlIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9uXG4gICAgICogQHBhcmFtIHthbnl9IHZhbHVlXG4gICAgICogQGZpcmVzIFBTVi5jb25maWctY2hhbmdlZFxuICAgICAqIEB0aHJvd3Mge1BTVi5QU1ZFcnJvcn0gd2hlbiB0aGUgY29uZmlndXJhdGlvbiBpcyBpbmNvcnJlY3RcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uc2V0T3B0aW9uID0gZnVuY3Rpb24gc2V0T3B0aW9uKG9wdGlvbiwgdmFsdWUpIHtcbiAgICAgIHZhciBfdGhpcyRzZXRPcHRpb25zO1xuXG4gICAgICB0aGlzLnNldE9wdGlvbnMoKF90aGlzJHNldE9wdGlvbnMgPSB7fSwgX3RoaXMkc2V0T3B0aW9uc1tvcHRpb25dID0gdmFsdWUsIF90aGlzJHNldE9wdGlvbnMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgUmVzdGFydHMgdGhlIGlkbGUgdGltZXIgKGlmIGBhdXRvcm90YXRlSWRsZT10cnVlYClcbiAgICAgKiBAcGFja2FnZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5yZXNldElkbGVUaW1lciA9IGZ1bmN0aW9uIHJlc2V0SWRsZVRpbWVyKCkge1xuICAgICAgdGhpcy5wcm9wLmlkbGVUaW1lID0gdGhpcy5jb25maWcuYXV0b3JvdGF0ZUlkbGUgPyBwZXJmb3JtYW5jZS5ub3coKSA6IC0xO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBTdG9wcyB0aGUgaWRsZSB0aW1lclxuICAgICAqIEBwYWNrYWdlXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLmRpc2FibGVJZGxlVGltZXIgPSBmdW5jdGlvbiBkaXNhYmxlSWRsZVRpbWVyKCkge1xuICAgICAgdGhpcy5wcm9wLmlkbGVUaW1lID0gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFN0YXJ0cyB0aGUgYXV0b21hdGljIHJvdGF0aW9uXG4gICAgICogQGZpcmVzIFBTVi5hdXRvcm90YXRlXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLnN0YXJ0QXV0b3JvdGF0ZSA9IGZ1bmN0aW9uIHN0YXJ0QXV0b3JvdGF0ZShyZWZyZXNoKSB7XG4gICAgICBpZiAocmVmcmVzaCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJlZnJlc2ggPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZnJlc2ggJiYgIXRoaXMuaXNBdXRvcm90YXRlRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFyZWZyZXNoICYmIHRoaXMuaXNBdXRvcm90YXRlRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFyZWZyZXNoKSB7XG4gICAgICAgIHRoaXMuX19zdG9wQWxsKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZHluYW1pY3MucG9zaXRpb24ucm9sbCh7XG4gICAgICAgIGxvbmdpdHVkZTogdGhpcy5jb25maWcuYXV0b3JvdGF0ZVNwZWVkIDwgMFxuICAgICAgfSwgTWF0aC5hYnModGhpcy5jb25maWcuYXV0b3JvdGF0ZVNwZWVkIC8gdGhpcy5jb25maWcubW92ZVNwZWVkKSk7XG4gICAgICB0aGlzLmR5bmFtaWNzLnBvc2l0aW9uLmdvdG8oe1xuICAgICAgICBsYXRpdHVkZTogdGhpcy5jb25maWcuYXV0b3JvdGF0ZUxhdFxuICAgICAgfSwgTWF0aC5hYnModGhpcy5jb25maWcuYXV0b3JvdGF0ZVNwZWVkIC8gdGhpcy5jb25maWcubW92ZVNwZWVkKSk7XG5cbiAgICAgIGlmICh0aGlzLmNvbmZpZy5hdXRvcm90YXRlWm9vbUx2bCAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmR5bmFtaWNzLnpvb20uZ290byh0aGlzLmNvbmZpZy5hdXRvcm90YXRlWm9vbUx2bCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHJvcC5hdXRvcm90YXRlRW5hYmxlZCA9IHRydWU7XG5cbiAgICAgIGlmICghcmVmcmVzaCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoRVZFTlRTLkFVVE9ST1RBVEUsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBTdG9wcyB0aGUgYXV0b21hdGljIHJvdGF0aW9uXG4gICAgICogQGZpcmVzIFBTVi5hdXRvcm90YXRlXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLnN0b3BBdXRvcm90YXRlID0gZnVuY3Rpb24gc3RvcEF1dG9yb3RhdGUoKSB7XG4gICAgICBpZiAodGhpcy5pc0F1dG9yb3RhdGVFbmFibGVkKCkpIHtcbiAgICAgICAgdGhpcy5keW5hbWljcy5wb3NpdGlvbi5zdG9wKCk7XG4gICAgICAgIHRoaXMuZHluYW1pY3Muem9vbS5zdG9wKCk7XG4gICAgICAgIHRoaXMucHJvcC5hdXRvcm90YXRlRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRyaWdnZXIoRVZFTlRTLkFVVE9ST1RBVEUsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgU3RhcnRzIG9yIHN0b3BzIHRoZSBhdXRvbWF0aWMgcm90YXRpb25cbiAgICAgKiBAZmlyZXMgUFNWLmF1dG9yb3RhdGVcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8udG9nZ2xlQXV0b3JvdGF0ZSA9IGZ1bmN0aW9uIHRvZ2dsZUF1dG9yb3RhdGUoKSB7XG4gICAgICBpZiAodGhpcy5pc0F1dG9yb3RhdGVFbmFibGVkKCkpIHtcbiAgICAgICAgdGhpcy5zdG9wQXV0b3JvdGF0ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGFydEF1dG9yb3RhdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgRGlzcGxheXMgYW4gZXJyb3IgbWVzc2FnZSBvdmVyIHRoZSB2aWV3ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5zaG93RXJyb3IgPSBmdW5jdGlvbiBzaG93RXJyb3IobWVzc2FnZSkge1xuICAgICAgdGhpcy5vdmVybGF5LnNob3coe1xuICAgICAgICBpZDogSURTLkVSUk9SLFxuICAgICAgICBpbWFnZTogZXJyb3JJY29uLFxuICAgICAgICB0ZXh0OiBtZXNzYWdlLFxuICAgICAgICBkaXNzbWlzYWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBIaWRlcyB0aGUgZXJyb3IgbWVzc2FnZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5oaWRlRXJyb3IgPSBmdW5jdGlvbiBoaWRlRXJyb3IoKSB7XG4gICAgICB0aGlzLm92ZXJsYXkuaGlkZShJRFMuRVJST1IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBSb3RhdGVzIHRoZSB2aWV3IHRvIHNwZWNpZmljIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGVcbiAgICAgKiBAcGFyYW0ge1BTVi5FeHRlbmRlZFBvc2l0aW9ufSBwb3NpdGlvblxuICAgICAqIEBmaXJlcyBQU1YuYmVmb3JlLXJvdGF0ZVxuICAgICAqIEBmaXJlcyBQU1YucG9zaXRpb24tdXBkYXRlZFxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5yb3RhdGUgPSBmdW5jdGlvbiByb3RhdGUocG9zaXRpb24pIHtcbiAgICAgIHZhciBlID0gdGhpcy50cmlnZ2VyKEVWRU5UUy5CRUZPUkVfUk9UQVRFLCBwb3NpdGlvbik7XG5cbiAgICAgIGlmIChlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNsZWFuUG9zaXRpb24gPSB0aGlzLmNoYW5nZShDSEFOR0VfRVZFTlRTLkdFVF9ST1RBVEVfUE9TSVRJT04sIHRoaXMuZGF0YUhlbHBlci5jbGVhblBvc2l0aW9uKHBvc2l0aW9uKSk7XG4gICAgICB0aGlzLmR5bmFtaWNzLnBvc2l0aW9uLnNldFZhbHVlKGNsZWFuUG9zaXRpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBSb3RhdGVzIGFuZCB6b29tcyB0aGUgdmlldyB3aXRoIGEgc21vb3RoIGFuaW1hdGlvblxuICAgICAqIEBwYXJhbSB7UFNWLkFuaW1hdGVPcHRpb25zfSBvcHRpb25zIC0gcG9zaXRpb24gYW5kL29yIHpvb20gbGV2ZWxcbiAgICAgKiBAcmV0dXJucyB7UFNWLnV0aWxzLkFuaW1hdGlvbn1cbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uYW5pbWF0ZSA9IGZ1bmN0aW9uIGFuaW1hdGUob3B0aW9ucykge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgIHRoaXMuX19zdG9wQWxsKCk7XG5cbiAgICAgIHZhciBwb3NpdGlvblByb3ZpZGVkID0gaXNFeHRlbmRlZFBvc2l0aW9uKG9wdGlvbnMpO1xuICAgICAgdmFyIHpvb21Qcm92aWRlZCA9IG9wdGlvbnMuem9vbSAhPT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGFuaW1Qcm9wZXJ0aWVzID0ge307XG4gICAgICB2YXIgZHVyYXRpb247IC8vIGNsZWFuL2ZpbHRlciBwb3NpdGlvbiBhbmQgY29tcHV0ZSBkdXJhdGlvblxuXG4gICAgICBpZiAocG9zaXRpb25Qcm92aWRlZCkge1xuICAgICAgICB2YXIgY2xlYW5Qb3NpdGlvbiA9IHRoaXMuY2hhbmdlKENIQU5HRV9FVkVOVFMuR0VUX0FOSU1BVEVfUE9TSVRJT04sIHRoaXMuZGF0YUhlbHBlci5jbGVhblBvc2l0aW9uKG9wdGlvbnMpKTtcbiAgICAgICAgdmFyIGN1cnJlbnRQb3NpdGlvbiA9IHRoaXMuZ2V0UG9zaXRpb24oKTsgLy8gbG9uZ2l0dWRlIG9mZnNldCBmb3Igc2hvcnRlc3QgYXJjXG5cbiAgICAgICAgdmFyIHRPZmZzZXQgPSBnZXRTaG9ydGVzdEFyYyhjdXJyZW50UG9zaXRpb24ubG9uZ2l0dWRlLCBjbGVhblBvc2l0aW9uLmxvbmdpdHVkZSk7XG4gICAgICAgIGFuaW1Qcm9wZXJ0aWVzLmxvbmdpdHVkZSA9IHtcbiAgICAgICAgICBzdGFydDogY3VycmVudFBvc2l0aW9uLmxvbmdpdHVkZSxcbiAgICAgICAgICBlbmQ6IGN1cnJlbnRQb3NpdGlvbi5sb25naXR1ZGUgKyB0T2Zmc2V0XG4gICAgICAgIH07XG4gICAgICAgIGFuaW1Qcm9wZXJ0aWVzLmxhdGl0dWRlID0ge1xuICAgICAgICAgIHN0YXJ0OiBjdXJyZW50UG9zaXRpb24ubGF0aXR1ZGUsXG4gICAgICAgICAgZW5kOiBjbGVhblBvc2l0aW9uLmxhdGl0dWRlXG4gICAgICAgIH07XG4gICAgICAgIGR1cmF0aW9uID0gdGhpcy5kYXRhSGVscGVyLnNwZWVkVG9EdXJhdGlvbihvcHRpb25zLnNwZWVkLCBnZXRBbmdsZShjdXJyZW50UG9zaXRpb24sIGNsZWFuUG9zaXRpb24pKTtcbiAgICAgIH0gLy8gY2xlYW4vZmlsdGVyIHpvb20gYW5kIGNvbXB1dGUgZHVyYXRpb25cblxuXG4gICAgICBpZiAoem9vbVByb3ZpZGVkKSB7XG4gICAgICAgIHZhciBkWm9vbSA9IE1hdGguYWJzKG9wdGlvbnMuem9vbSAtIHRoaXMuZ2V0Wm9vbUxldmVsKCkpO1xuICAgICAgICBhbmltUHJvcGVydGllcy56b29tID0ge1xuICAgICAgICAgIHN0YXJ0OiB0aGlzLmdldFpvb21MZXZlbCgpLFxuICAgICAgICAgIGVuZDogb3B0aW9ucy56b29tXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCFkdXJhdGlvbikge1xuICAgICAgICAgIC8vIGlmIGFuaW1hdGluZyB6b29tIG9ubHkgYW5kIGEgc3BlZWQgaXMgZ2l2ZW4sIHVzZSBhbiBhcmJpdHJhcnkgUEkvNCB0byBjb21wdXRlIHRoZSBkdXJhdGlvblxuICAgICAgICAgIGR1cmF0aW9uID0gdGhpcy5kYXRhSGVscGVyLnNwZWVkVG9EdXJhdGlvbihvcHRpb25zLnNwZWVkLCBNYXRoLlBJIC8gNCAqIGRab29tIC8gMTAwKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBpZiBubyBhbmltYXRpb24gbmVlZGVkXG5cblxuICAgICAgaWYgKCFkdXJhdGlvbikge1xuICAgICAgICBpZiAocG9zaXRpb25Qcm92aWRlZCkge1xuICAgICAgICAgIHRoaXMucm90YXRlKG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHpvb21Qcm92aWRlZCkge1xuICAgICAgICAgIHRoaXMuem9vbShvcHRpb25zLnpvb20pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb24oKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcm9wLmFuaW1hdGlvblByb21pc2UgPSBuZXcgQW5pbWF0aW9uKHtcbiAgICAgICAgcHJvcGVydGllczogYW5pbVByb3BlcnRpZXMsXG4gICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgZWFzaW5nOiAnaW5PdXRTaW5lJyxcbiAgICAgICAgb25UaWNrOiBmdW5jdGlvbiBvblRpY2socHJvcGVydGllcykge1xuICAgICAgICAgIGlmIChwb3NpdGlvblByb3ZpZGVkKSB7XG4gICAgICAgICAgICBfdGhpczYucm90YXRlKHByb3BlcnRpZXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh6b29tUHJvdmlkZWQpIHtcbiAgICAgICAgICAgIF90aGlzNi56b29tKHByb3BlcnRpZXMuem9vbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMucHJvcC5hbmltYXRpb25Qcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczYucHJvcC5hbmltYXRpb25Qcm9taXNlID0gbnVsbDtcblxuICAgICAgICBfdGhpczYucmVzZXRJZGxlVGltZXIoKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMucHJvcC5hbmltYXRpb25Qcm9taXNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBTdG9wcyB0aGUgb25nb2luZyBhbmltYXRpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gVGhlIHJldHVybiB2YWx1ZSBpcyBhIFByb21pc2UgYmVjYXVzZSB0aGUgaXMgbm8gZ3VhcmFudHkgdGhlIGFuaW1hdGlvbiBjYW4gYmUgc3RvcHBlZCBzeW5jaHJvbm91c2x5LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBhbmltYXRpb24gaGFzIGJlbiBjYW5jZWxsZWRcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uc3RvcEFuaW1hdGlvbiA9IGZ1bmN0aW9uIHN0b3BBbmltYXRpb24oKSB7XG4gICAgICBpZiAodGhpcy5wcm9wLmFuaW1hdGlvblByb21pc2UpIHtcbiAgICAgICAgdGhpcy5wcm9wLmFuaW1hdGlvblByb21pc2UuY2FuY2VsKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3AuYW5pbWF0aW9uUHJvbWlzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgWm9vbXMgdG8gYSBzcGVjaWZpYyBsZXZlbCBiZXR3ZWVuIGBtYXhfZm92YCBhbmQgYG1pbl9mb3ZgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxldmVsIC0gbmV3IHpvb20gbGV2ZWwgZnJvbSAwIHRvIDEwMFxuICAgICAqIEBmaXJlcyBQU1Yuem9vbS11cGRhdGVkXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLnpvb20gPSBmdW5jdGlvbiB6b29tKGxldmVsKSB7XG4gICAgICB0aGlzLmR5bmFtaWNzLnpvb20uc2V0VmFsdWUobGV2ZWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBJbmNyZWFzZXMgdGhlIHpvb20gbGV2ZWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0ZXA9MV1cbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uem9vbUluID0gZnVuY3Rpb24gem9vbUluKHN0ZXApIHtcbiAgICAgIGlmIChzdGVwID09PSB2b2lkIDApIHtcbiAgICAgICAgc3RlcCA9IDE7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZHluYW1pY3Muem9vbS5zdGVwKHN0ZXApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBEZWNyZWFzZXMgdGhlIHpvb20gbGV2ZWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0ZXA9MV1cbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uem9vbU91dCA9IGZ1bmN0aW9uIHpvb21PdXQoc3RlcCkge1xuICAgICAgaWYgKHN0ZXAgPT09IHZvaWQgMCkge1xuICAgICAgICBzdGVwID0gMTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5keW5hbWljcy56b29tLnN0ZXAoLXN0ZXApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBSZXNpemVzIHRoZSB2aWV3ZXJcbiAgICAgKiBAcGFyYW0ge1BTVi5Dc3NTaXplfSBzaXplXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLnJlc2l6ZSA9IGZ1bmN0aW9uIHJlc2l6ZShzaXplKSB7XG4gICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgWyd3aWR0aCcsICdoZWlnaHQnXS5mb3JFYWNoKGZ1bmN0aW9uIChkaW0pIHtcbiAgICAgICAgaWYgKHNpemUgJiYgc2l6ZVtkaW1dKSB7XG4gICAgICAgICAgaWYgKC9eWzAtOS5dKyQvLnRlc3Qoc2l6ZVtkaW1dKSkge1xuICAgICAgICAgICAgc2l6ZVtkaW1dICs9ICdweCc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RoaXM3LnBhcmVudC5zdHlsZVtkaW1dID0gc2l6ZVtkaW1dO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYXV0b1NpemUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgRW50ZXJzIHRoZSBmdWxsc2NyZWVuIG1vZGVcbiAgICAgKiBAZmlyZXMgUFNWLmZ1bGxzY3JlZW4tdXBkYXRlZFxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5lbnRlckZ1bGxzY3JlZW4gPSBmdW5jdGlvbiBlbnRlckZ1bGxzY3JlZW4oKSB7XG4gICAgICBpZiAoU1lTVEVNLmZ1bGxzY3JlZW5FdmVudCkge1xuICAgICAgICByZXF1ZXN0RnVsbHNjcmVlbih0aGlzLmNvbnRhaW5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdwc3YtY29udGFpbmVyLS1mdWxsc2NyZWVuJyk7XG4gICAgICAgIHRoaXMuYXV0b1NpemUoKTtcblxuICAgICAgICB0aGlzLmV2ZW50c0hhbmRsZXIuX19mdWxsc2NyZWVuVG9nZ2xlZCh0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgRXhpdHMgdGhlIGZ1bGxzY3JlZW4gbW9kZVxuICAgICAqIEBmaXJlcyBQU1YuZnVsbHNjcmVlbi11cGRhdGVkXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLmV4aXRGdWxsc2NyZWVuID0gZnVuY3Rpb24gZXhpdEZ1bGxzY3JlZW4kMSgpIHtcbiAgICAgIGlmICh0aGlzLmlzRnVsbHNjcmVlbkVuYWJsZWQoKSkge1xuICAgICAgICBpZiAoU1lTVEVNLmZ1bGxzY3JlZW5FdmVudCkge1xuICAgICAgICAgIGV4aXRGdWxsc2NyZWVuKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSgncHN2LWNvbnRhaW5lci0tZnVsbHNjcmVlbicpO1xuICAgICAgICAgIHRoaXMuYXV0b1NpemUoKTtcblxuICAgICAgICAgIHRoaXMuZXZlbnRzSGFuZGxlci5fX2Z1bGxzY3JlZW5Ub2dnbGVkKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBFbnRlcnMgb3IgZXhpdHMgdGhlIGZ1bGxzY3JlZW4gbW9kZVxuICAgICAqIEBmaXJlcyBQU1YuZnVsbHNjcmVlbi11cGRhdGVkXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLnRvZ2dsZUZ1bGxzY3JlZW4gPSBmdW5jdGlvbiB0b2dnbGVGdWxsc2NyZWVuKCkge1xuICAgICAgaWYgKCF0aGlzLmlzRnVsbHNjcmVlbkVuYWJsZWQoKSkge1xuICAgICAgICB0aGlzLmVudGVyRnVsbHNjcmVlbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5leGl0RnVsbHNjcmVlbigpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBFbmFibGVzIHRoZSBrZXlib2FyZCBjb250cm9scyAoZG9uZSBhdXRvbWF0aWNhbGx5IHdoZW4gZW50ZXJpbmcgZnVsbHNjcmVlbilcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uc3RhcnRLZXlib2FyZENvbnRyb2wgPSBmdW5jdGlvbiBzdGFydEtleWJvYXJkQ29udHJvbCgpIHtcbiAgICAgIHRoaXMuZXZlbnRzSGFuZGxlci5lbmFibGVLZXlib2FyZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBEaXNhYmxlcyB0aGUga2V5Ym9hcmQgY29udHJvbHMgKGRvbmUgYXV0b21hdGljYWxseSB3aGVuIGV4aXRpbmcgZnVsbHNjcmVlbilcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uc3RvcEtleWJvYXJkQ29udHJvbCA9IGZ1bmN0aW9uIHN0b3BLZXlib2FyZENvbnRyb2woKSB7XG4gICAgICB0aGlzLmV2ZW50c0hhbmRsZXIuZGlzYWJsZUtleWJvYXJkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFN1YnNjcmliZXMgdG8gZXZlbnRzIG9uIG9iamVjdHMgaW4gdGhlIHNjZW5lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJEYXRhS2V5IC0gb25seSBvYmplY3RzIHdpdGggdGhlIGZvbGxvd2luZyBgdXNlckRhdGFgIHdpbGwgYmUgZW1pdHRlZFxuICAgICAqIEBwYXJhbSB7RXZlbnRMaXN0ZW5lcn0gbGlzdGVuZXIgLSBtdXN0IGltcGxlbWVudCBgaGFuZGxlRXZlbnRgXG4gICAgICogQHJldHVybiB7ZnVuY3Rpb259IGNhbGwgdG8gc3RvcCB0aGUgc3Vic2NyaXB0aW9uXG4gICAgICogQHBhY2thZ2VcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8ub2JzZXJ2ZU9iamVjdHMgPSBmdW5jdGlvbiBvYnNlcnZlT2JqZWN0cyh1c2VyRGF0YUtleSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBfdGhpczggPSB0aGlzO1xuXG4gICAgICB0aGlzLnByb3Aub2JqZWN0c09ic2VydmVyc1t1c2VyRGF0YUtleV0gPSB7XG4gICAgICAgIGxpc3RlbmVyOiBsaXN0ZW5lclxuICAgICAgfTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRlbGV0ZSBfdGhpczgucHJvcC5vYmplY3RzT2JzZXJ2ZXJzW3VzZXJEYXRhS2V5XTtcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFN0b3BzIGFsbCBjdXJyZW50IGFuaW1hdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKiBAcGFja2FnZVxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5fX3N0b3BBbGwgPSBmdW5jdGlvbiBfX3N0b3BBbGwoKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoRVZFTlRTLlNUT1BfQUxMKTtcbiAgICAgIHRoaXMuZGlzYWJsZUlkbGVUaW1lcigpO1xuICAgICAgdGhpcy5zdG9wQXV0b3JvdGF0ZSgpO1xuICAgICAgcmV0dXJuIHRoaXMuc3RvcEFuaW1hdGlvbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBSZWNvbXB1dGVzIGR5bmFtaWNzIHNwZWVkc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLl9fdXBkYXRlU3BlZWRzID0gZnVuY3Rpb24gX191cGRhdGVTcGVlZHMoKSB7XG4gICAgICB0aGlzLmR5bmFtaWNzLnpvb20uc2V0U3BlZWQodGhpcy5jb25maWcuem9vbVNwZWVkICogNTApO1xuICAgICAgdGhpcy5keW5hbWljcy5wb3NpdGlvbi5zZXRTcGVlZCh0aHJlZS5NYXRoVXRpbHMuZGVnVG9SYWQodGhpcy5jb25maWcubW92ZVNwZWVkICogNTApKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFZpZXdlcjtcbiAgfSh1ZXZlbnQuRXZlbnRFbWl0dGVyKTtcblxuICBleHBvcnRzLkFic3RyYWN0QWRhcHRlciA9IEFic3RyYWN0QWRhcHRlcjtcbiAgZXhwb3J0cy5BYnN0cmFjdEJ1dHRvbiA9IEFic3RyYWN0QnV0dG9uO1xuICBleHBvcnRzLkFic3RyYWN0Q29tcG9uZW50ID0gQWJzdHJhY3RDb21wb25lbnQ7XG4gIGV4cG9ydHMuQWJzdHJhY3RQbHVnaW4gPSBBYnN0cmFjdFBsdWdpbjtcbiAgZXhwb3J0cy5DT05TVEFOVFMgPSBjb25zdGFudHM7XG4gIGV4cG9ydHMuREVGQVVMVFMgPSBERUZBVUxUUztcbiAgZXhwb3J0cy5FcXVpcmVjdGFuZ3VsYXJBZGFwdGVyID0gRXF1aXJlY3Rhbmd1bGFyQWRhcHRlcjtcbiAgZXhwb3J0cy5QU1ZFcnJvciA9IFBTVkVycm9yO1xuICBleHBvcnRzLlNZU1RFTSA9IFNZU1RFTTtcbiAgZXhwb3J0cy5WaWV3ZXIgPSBWaWV3ZXI7XG4gIGV4cG9ydHMucmVnaXN0ZXJCdXR0b24gPSByZWdpc3RlckJ1dHRvbjtcbiAgZXhwb3J0cy51dGlscyA9IGluZGV4O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBob3RvLXNwaGVyZS12aWV3ZXIuanMubWFwXG4iLCIvKiFcbiAqIHVldmVudCAodjIuMi4wKVxuICogQGNvcHlyaWdodCAyMDE1LTIwMjIgRGFtaWVuIFwiTWlzdGljXCIgU29yZWwgPGNvbnRhY3RAZ2l0LnN0cmFuZ2VwbGFuZXQuZnI+XG4gKiBAbGljZW5jZSBNSVRcbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC51RXZlbnQgPSB7fSkpO1xufSkodGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciByZXR1cm5UcnVlID0gZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICB2YXIgcmV0dXJuRmFsc2UgPSBmdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgdmFyIEV2ZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHsqfSB0YXJnZXRcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIEV2ZW50KHRhcmdldCwgdHlwZSwgYXJncykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgJ3RhcmdldCc6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KCkge30sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICAndHlwZSc6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCgpIHt9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgJ2FyZ3MnOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoKSB7fSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVybkZhbHNlO1xuICAgICAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuRmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBfcHJvdG8gPSBFdmVudC5wcm90b3R5cGU7XG5cbiAgICAgIF9wcm90by5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG4gICAgICB9O1xuXG4gICAgICBfcHJvdG8uc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKCkge1xuICAgICAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBFdmVudDtcbiAgICB9KCk7XG5cbiAgICB2YXIgRXZlbnRfMSA9IEV2ZW50O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdC48U3RyaW5nLCBGdW5jdGlvbj59IENhbGxiYWNrc1xuICAgICAqL1xuXG4gICAgdmFyIEV2ZW50RW1pdHRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7fVxuXG4gICAgICB2YXIgX3Byb3RvID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZTtcblxuICAgICAgLyoqXG4gICAgICAgKiBBZGQgb25lIG9yIG1hbnkgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAqXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogIG9iai5vbignZXZlbnQnLCBjYWxsYmFjaylcbiAgICAgICAqICBvYmoub24oJ2V2ZW50JywgbGlzdGVuZXIpIC8vIGxpc3RlbmVyIGhhcyBhbiBgaGFuZGxlRXZlbnRgIG1ldGhvZFxuICAgICAgICogIG9iai5vbignZXZlbnQxIGV2ZW50MicsIGNhbGxiYWNrKVxuICAgICAgICogIG9iai5vbih7IGV2ZW50MTogY2FsbGJhY2sxLCBldmVudDI6IGNhbGxiYWNrMiB9KVxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfENhbGxiYWNrc30gZXZlbnRzXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdXG4gICAgICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgICAgICovXG4gICAgICBfcHJvdG8ub24gPSBmdW5jdGlvbiBvbihldmVudHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5fX2V2ZW50cyA9IHRoaXMuX19ldmVudHMgfHwge307XG5cbiAgICAgICAgaWYgKHR5cGVvZiBldmVudHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgZm9yICh2YXIgZXZlbnQgaW4gZXZlbnRzKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnRzLmhhc093blByb3BlcnR5KGV2ZW50KSkge1xuICAgICAgICAgICAgICB0aGlzLl9fZXZlbnRzW2V2ZW50XSA9IHRoaXMuX19ldmVudHNbZXZlbnRdIHx8IFtdO1xuXG4gICAgICAgICAgICAgIHRoaXMuX19ldmVudHNbZXZlbnRdLnB1c2goZXZlbnRzW2V2ZW50XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV2ZW50cy5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBfdGhpcy5fX2V2ZW50c1tldmVudF0gPSBfdGhpcy5fX2V2ZW50c1tldmVudF0gfHwgW107XG5cbiAgICAgICAgICAgIF90aGlzLl9fZXZlbnRzW2V2ZW50XS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmUgb25lIG9yIG1hbnkgb3IgYWxsIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgKlxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqICBvYmoub2ZmKCdldmVudCcpXG4gICAgICAgKiAgb2JqLm9mZignZXZlbnQnLCBjYWxsYmFjaylcbiAgICAgICAqICBvYmoub2ZmKCdldmVudDEgZXZlbnQyJylcbiAgICAgICAqICBvYmoub2ZmKHsgZXZlbnQxOiBjYWxsYmFjazEsIGV2ZW50MjogY2FsbGJhY2syIH0pXG4gICAgICAgKiAgb2JqLm9mZigpXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtTdHJpbmd8Q2FsbGJhY2tzfSBbZXZlbnRzXVxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXVxuICAgICAgICogQHJldHVybiB7dGhpc31cbiAgICAgICAqL1xuICAgICAgO1xuXG4gICAgICBfcHJvdG8ub2ZmID0gZnVuY3Rpb24gb2ZmKGV2ZW50cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBldmVudHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgZm9yICh2YXIgZXZlbnQgaW4gZXZlbnRzKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnRzLmhhc093blByb3BlcnR5KGV2ZW50KSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5fX2V2ZW50cyAmJiBldmVudCBpbiB0aGlzLl9fZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fX2V2ZW50c1tldmVudF0uaW5kZXhPZihldmVudHNbZXZlbnRdKTtcblxuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHRoaXMuX19ldmVudHNbZXZlbnRdLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAodGhpcy5fX29uY2UgJiYgZXZlbnQgaW4gdGhpcy5fX29uY2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2luZGV4ID0gdGhpcy5fX29uY2VbZXZlbnRdLmluZGV4T2YoZXZlbnRzW2V2ZW50XSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoX2luZGV4ICE9PSAtMSkgdGhpcy5fX29uY2VbZXZlbnRdLnNwbGljZShfaW5kZXgsIDEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEhZXZlbnRzKSB7XG4gICAgICAgICAgZXZlbnRzLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChfdGhpczIuX19ldmVudHMgJiYgZXZlbnQgaW4gX3RoaXMyLl9fZXZlbnRzKSB7XG4gICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHZhciBfaW5kZXgyID0gX3RoaXMyLl9fZXZlbnRzW2V2ZW50XS5pbmRleE9mKGNhbGxiYWNrKTtcblxuICAgICAgICAgICAgICAgIGlmIChfaW5kZXgyICE9PSAtMSkgX3RoaXMyLl9fZXZlbnRzW2V2ZW50XS5zcGxpY2UoX2luZGV4MiwgMSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMyLl9fZXZlbnRzW2V2ZW50XS5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChfdGhpczIuX19vbmNlICYmIGV2ZW50IGluIF90aGlzMi5fX29uY2UpIHtcbiAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9pbmRleDMgPSBfdGhpczIuX19vbmNlW2V2ZW50XS5pbmRleE9mKGNhbGxiYWNrKTtcblxuICAgICAgICAgICAgICAgIGlmIChfaW5kZXgzICE9PSAtMSkgX3RoaXMyLl9fb25jZVtldmVudF0uc3BsaWNlKF9pbmRleDMsIDEpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzMi5fX29uY2VbZXZlbnRdLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9fZXZlbnRzID0ge307XG4gICAgICAgICAgdGhpcy5fX29uY2UgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBBZGQgb25lIG9yIG1hbnkgZXZlbnQgaGFuZGxlcnMgdGhhdCB3aWxsIGJlIGNhbGxlZCBvbmx5IG9uY2VcbiAgICAgICAqIFRoaXMgaGFuZGxlcnMgYXJlIG9ubHkgYXBwbGljYWJsZSB0byBcInRyaWdnZXJcIiwgbm90IFwiY2hhbmdlXCJcbiAgICAgICAqXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogIG9iai5vbmNlKCdldmVudCcsIGNhbGxiYWNrKVxuICAgICAgICogIG9iai5vbmNlKCdldmVudDEgZXZlbnQyJywgY2FsbGJhY2spXG4gICAgICAgKiAgb2JqLm9uY2UoeyBldmVudDE6IGNhbGxiYWNrMSwgZXZlbnQyOiBjYWxsYmFjazIgfSlcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ3xDYWxsYmFja3N9IGV2ZW50c1xuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXVxuICAgICAgICogQHJldHVybiB7dGhpc31cbiAgICAgICAqL1xuICAgICAgO1xuXG4gICAgICBfcHJvdG8ub25jZSA9IGZ1bmN0aW9uIG9uY2UoZXZlbnRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICB0aGlzLl9fb25jZSA9IHRoaXMuX19vbmNlIHx8IHt9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGZvciAodmFyIGV2ZW50IGluIGV2ZW50cykge1xuICAgICAgICAgICAgaWYgKGV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5fX29uY2VbZXZlbnRdID0gdGhpcy5fX29uY2VbZXZlbnRdIHx8IFtdO1xuXG4gICAgICAgICAgICAgIHRoaXMuX19vbmNlW2V2ZW50XS5wdXNoKGV2ZW50c1tldmVudF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBldmVudHMuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgX3RoaXMzLl9fb25jZVtldmVudF0gPSBfdGhpczMuX19vbmNlW2V2ZW50XSB8fCBbXTtcblxuICAgICAgICAgICAgX3RoaXMzLl9fb25jZVtldmVudF0ucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogVHJpZ2dlciBhbGwgaGFuZGxlcnMgZm9yIGFuIGV2ZW50XG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAgICAgKiBAcGFyYW0geyouLi59IFthcmd1bWVudHNdXG4gICAgICAgKiBAcmV0dXJuIHtFdmVudH1cbiAgICAgICAqL1xuICAgICAgO1xuXG4gICAgICBfcHJvdG8udHJpZ2dlciA9IGZ1bmN0aW9uIHRyaWdnZXIoZXZlbnRcbiAgICAgIC8qICwgYXJncy4uLiAqL1xuICAgICAgKSB7XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgdmFyIGUgPSBuZXcgRXZlbnRfMSh0aGlzLCBldmVudCwgYXJncyk7XG5cbiAgICAgICAgaWYgKHRoaXMuX19ldmVudHMgJiYgZXZlbnQgaW4gdGhpcy5fX2V2ZW50cykge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fX2V2ZW50c1tldmVudF0ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZiA9IHRoaXMuX19ldmVudHNbZXZlbnRdW2ldO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGYgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgIGYuaGFuZGxlRXZlbnQoZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmLmNhbGwuYXBwbHkoZiwgW3RoaXMsIGVdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX19vbmNlICYmIGV2ZW50IGluIHRoaXMuX19vbmNlKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfbCA9IHRoaXMuX19vbmNlW2V2ZW50XS5sZW5ndGg7IF9pIDwgX2w7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBfZiA9IHRoaXMuX19vbmNlW2V2ZW50XVtfaV07XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgX2YgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgIF9mLmhhbmRsZUV2ZW50KGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX2YuY2FsbC5hcHBseShfZiwgW3RoaXMsIGVdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVsZXRlIHRoaXMuX19vbmNlW2V2ZW50XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBUcmlnZ2VyIGFsbCBtb2RpZmljYXRvcnMgZm9yIGFuIGV2ZW50LCBlYWNoIGhhbmRsZXIgbXVzdCByZXR1cm4gYSB2YWx1ZVxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAgICogQHBhcmFtIHsqLi4ufSBbYXJndW1lbnRzXVxuICAgICAgICogQHJldHVybiB7Kn0gbW9kaWZpZWQgdmFsdWVcbiAgICAgICAqL1xuICAgICAgO1xuXG4gICAgICBfcHJvdG8uY2hhbmdlID0gZnVuY3Rpb24gY2hhbmdlKGV2ZW50LCB2YWx1ZVxuICAgICAgLyogLCBhcmdzLi4uICovXG4gICAgICApIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgICAgICB2YXIgZSA9IG5ldyBFdmVudF8xKHRoaXMsIGV2ZW50LCBhcmdzKTtcbiAgICAgICAgZS52YWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgIGlmICh0aGlzLl9fZXZlbnRzICYmIGV2ZW50IGluIHRoaXMuX19ldmVudHMpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX19ldmVudHNbZXZlbnRdLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIGYgPSB0aGlzLl9fZXZlbnRzW2V2ZW50XVtpXTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBmID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICBlLnZhbHVlID0gZi5oYW5kbGVFdmVudChlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGUudmFsdWUgPSBmLmNhbGwuYXBwbHkoZiwgW3RoaXMsIGUsIGUudmFsdWVdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGUudmFsdWU7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gRXZlbnRFbWl0dGVyO1xuICAgIH0oKTtcblxuICAgIHZhciBFdmVudEVtaXR0ZXJfMSA9IEV2ZW50RW1pdHRlcjtcblxuICAgIGZ1bmN0aW9uIG1peGluKHRhcmdldCkge1xuICAgICAgdGFyZ2V0ID0gdHlwZW9mIHRhcmdldCA9PT0gJ2Z1bmN0aW9uJyA/IHRhcmdldC5wcm90b3R5cGUgOiB0YXJnZXQ7XG4gICAgICBbJ29uJywgJ29mZicsICdvbmNlJywgJ3RyaWdnZXInLCAnY2hhbmdlJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB0YXJnZXRbbmFtZV0gPSBFdmVudEVtaXR0ZXJfMS5wcm90b3R5cGVbbmFtZV07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgdmFyIHVFdmVudCA9IHtcbiAgICAgIEV2ZW50RW1pdHRlcjogRXZlbnRFbWl0dGVyXzEsXG4gICAgICBFdmVudDogRXZlbnRfMSxcbiAgICAgIG1peGluOiBtaXhpblxuICAgIH07XG4gICAgdmFyIHVFdmVudF8xID0gdUV2ZW50LkV2ZW50RW1pdHRlcjtcbiAgICB2YXIgdUV2ZW50XzIgPSB1RXZlbnQuRXZlbnQ7XG4gICAgdmFyIHVFdmVudF8zID0gdUV2ZW50Lm1peGluO1xuXG4gICAgZXhwb3J0cy5FdmVudCA9IHVFdmVudF8yO1xuICAgIGV4cG9ydHMuRXZlbnRFbWl0dGVyID0gdUV2ZW50XzE7XG4gICAgZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB1RXZlbnQ7XG4gICAgZXhwb3J0cy5taXhpbiA9IHVFdmVudF8zO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnJvd3Nlci5qcy5tYXBcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDEwLTIwMjIgVGhyZWUuanMgQXV0aG9yc1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVFxuICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmNvbnN0IFJFVklTSU9OID0gJzE0Nic7XG5jb25zdCBNT1VTRSA9IHtcblx0TEVGVDogMCxcblx0TUlERExFOiAxLFxuXHRSSUdIVDogMixcblx0Uk9UQVRFOiAwLFxuXHRET0xMWTogMSxcblx0UEFOOiAyXG59O1xuY29uc3QgVE9VQ0ggPSB7XG5cdFJPVEFURTogMCxcblx0UEFOOiAxLFxuXHRET0xMWV9QQU46IDIsXG5cdERPTExZX1JPVEFURTogM1xufTtcbmNvbnN0IEN1bGxGYWNlTm9uZSA9IDA7XG5jb25zdCBDdWxsRmFjZUJhY2sgPSAxO1xuY29uc3QgQ3VsbEZhY2VGcm9udCA9IDI7XG5jb25zdCBDdWxsRmFjZUZyb250QmFjayA9IDM7XG5jb25zdCBCYXNpY1NoYWRvd01hcCA9IDA7XG5jb25zdCBQQ0ZTaGFkb3dNYXAgPSAxO1xuY29uc3QgUENGU29mdFNoYWRvd01hcCA9IDI7XG5jb25zdCBWU01TaGFkb3dNYXAgPSAzO1xuY29uc3QgRnJvbnRTaWRlID0gMDtcbmNvbnN0IEJhY2tTaWRlID0gMTtcbmNvbnN0IERvdWJsZVNpZGUgPSAyO1xuY29uc3QgTm9CbGVuZGluZyA9IDA7XG5jb25zdCBOb3JtYWxCbGVuZGluZyA9IDE7XG5jb25zdCBBZGRpdGl2ZUJsZW5kaW5nID0gMjtcbmNvbnN0IFN1YnRyYWN0aXZlQmxlbmRpbmcgPSAzO1xuY29uc3QgTXVsdGlwbHlCbGVuZGluZyA9IDQ7XG5jb25zdCBDdXN0b21CbGVuZGluZyA9IDU7XG5jb25zdCBBZGRFcXVhdGlvbiA9IDEwMDtcbmNvbnN0IFN1YnRyYWN0RXF1YXRpb24gPSAxMDE7XG5jb25zdCBSZXZlcnNlU3VidHJhY3RFcXVhdGlvbiA9IDEwMjtcbmNvbnN0IE1pbkVxdWF0aW9uID0gMTAzO1xuY29uc3QgTWF4RXF1YXRpb24gPSAxMDQ7XG5jb25zdCBaZXJvRmFjdG9yID0gMjAwO1xuY29uc3QgT25lRmFjdG9yID0gMjAxO1xuY29uc3QgU3JjQ29sb3JGYWN0b3IgPSAyMDI7XG5jb25zdCBPbmVNaW51c1NyY0NvbG9yRmFjdG9yID0gMjAzO1xuY29uc3QgU3JjQWxwaGFGYWN0b3IgPSAyMDQ7XG5jb25zdCBPbmVNaW51c1NyY0FscGhhRmFjdG9yID0gMjA1O1xuY29uc3QgRHN0QWxwaGFGYWN0b3IgPSAyMDY7XG5jb25zdCBPbmVNaW51c0RzdEFscGhhRmFjdG9yID0gMjA3O1xuY29uc3QgRHN0Q29sb3JGYWN0b3IgPSAyMDg7XG5jb25zdCBPbmVNaW51c0RzdENvbG9yRmFjdG9yID0gMjA5O1xuY29uc3QgU3JjQWxwaGFTYXR1cmF0ZUZhY3RvciA9IDIxMDtcbmNvbnN0IE5ldmVyRGVwdGggPSAwO1xuY29uc3QgQWx3YXlzRGVwdGggPSAxO1xuY29uc3QgTGVzc0RlcHRoID0gMjtcbmNvbnN0IExlc3NFcXVhbERlcHRoID0gMztcbmNvbnN0IEVxdWFsRGVwdGggPSA0O1xuY29uc3QgR3JlYXRlckVxdWFsRGVwdGggPSA1O1xuY29uc3QgR3JlYXRlckRlcHRoID0gNjtcbmNvbnN0IE5vdEVxdWFsRGVwdGggPSA3O1xuY29uc3QgTXVsdGlwbHlPcGVyYXRpb24gPSAwO1xuY29uc3QgTWl4T3BlcmF0aW9uID0gMTtcbmNvbnN0IEFkZE9wZXJhdGlvbiA9IDI7XG5jb25zdCBOb1RvbmVNYXBwaW5nID0gMDtcbmNvbnN0IExpbmVhclRvbmVNYXBwaW5nID0gMTtcbmNvbnN0IFJlaW5oYXJkVG9uZU1hcHBpbmcgPSAyO1xuY29uc3QgQ2luZW9uVG9uZU1hcHBpbmcgPSAzO1xuY29uc3QgQUNFU0ZpbG1pY1RvbmVNYXBwaW5nID0gNDtcbmNvbnN0IEN1c3RvbVRvbmVNYXBwaW5nID0gNTtcbmNvbnN0IFVWTWFwcGluZyA9IDMwMDtcbmNvbnN0IEN1YmVSZWZsZWN0aW9uTWFwcGluZyA9IDMwMTtcbmNvbnN0IEN1YmVSZWZyYWN0aW9uTWFwcGluZyA9IDMwMjtcbmNvbnN0IEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nID0gMzAzO1xuY29uc3QgRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmcgPSAzMDQ7XG5jb25zdCBDdWJlVVZSZWZsZWN0aW9uTWFwcGluZyA9IDMwNjtcbmNvbnN0IFJlcGVhdFdyYXBwaW5nID0gMTAwMDtcbmNvbnN0IENsYW1wVG9FZGdlV3JhcHBpbmcgPSAxMDAxO1xuY29uc3QgTWlycm9yZWRSZXBlYXRXcmFwcGluZyA9IDEwMDI7XG5jb25zdCBOZWFyZXN0RmlsdGVyID0gMTAwMztcbmNvbnN0IE5lYXJlc3RNaXBtYXBOZWFyZXN0RmlsdGVyID0gMTAwNDtcbmNvbnN0IE5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyID0gMTAwNDtcbmNvbnN0IE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIgPSAxMDA1O1xuY29uc3QgTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlciA9IDEwMDU7XG5jb25zdCBMaW5lYXJGaWx0ZXIgPSAxMDA2O1xuY29uc3QgTGluZWFyTWlwbWFwTmVhcmVzdEZpbHRlciA9IDEwMDc7XG5jb25zdCBMaW5lYXJNaXBNYXBOZWFyZXN0RmlsdGVyID0gMTAwNztcbmNvbnN0IExpbmVhck1pcG1hcExpbmVhckZpbHRlciA9IDEwMDg7XG5jb25zdCBMaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXIgPSAxMDA4O1xuY29uc3QgVW5zaWduZWRCeXRlVHlwZSA9IDEwMDk7XG5jb25zdCBCeXRlVHlwZSA9IDEwMTA7XG5jb25zdCBTaG9ydFR5cGUgPSAxMDExO1xuY29uc3QgVW5zaWduZWRTaG9ydFR5cGUgPSAxMDEyO1xuY29uc3QgSW50VHlwZSA9IDEwMTM7XG5jb25zdCBVbnNpZ25lZEludFR5cGUgPSAxMDE0O1xuY29uc3QgRmxvYXRUeXBlID0gMTAxNTtcbmNvbnN0IEhhbGZGbG9hdFR5cGUgPSAxMDE2O1xuY29uc3QgVW5zaWduZWRTaG9ydDQ0NDRUeXBlID0gMTAxNztcbmNvbnN0IFVuc2lnbmVkU2hvcnQ1NTUxVHlwZSA9IDEwMTg7XG5jb25zdCBVbnNpZ25lZEludDI0OFR5cGUgPSAxMDIwO1xuY29uc3QgQWxwaGFGb3JtYXQgPSAxMDIxO1xuY29uc3QgUkdCRm9ybWF0ID0gMTAyMjsgLy8gQGRlcHJlY2F0ZWQgc2luY2UgcjEzN1xuY29uc3QgUkdCQUZvcm1hdCA9IDEwMjM7XG5jb25zdCBMdW1pbmFuY2VGb3JtYXQgPSAxMDI0O1xuY29uc3QgTHVtaW5hbmNlQWxwaGFGb3JtYXQgPSAxMDI1O1xuY29uc3QgRGVwdGhGb3JtYXQgPSAxMDI2O1xuY29uc3QgRGVwdGhTdGVuY2lsRm9ybWF0ID0gMTAyNztcbmNvbnN0IFJlZEZvcm1hdCA9IDEwMjg7XG5jb25zdCBSZWRJbnRlZ2VyRm9ybWF0ID0gMTAyOTtcbmNvbnN0IFJHRm9ybWF0ID0gMTAzMDtcbmNvbnN0IFJHSW50ZWdlckZvcm1hdCA9IDEwMzE7XG5jb25zdCBSR0JBSW50ZWdlckZvcm1hdCA9IDEwMzM7XG5jb25zdCBSR0JfUzNUQ19EWFQxX0Zvcm1hdCA9IDMzNzc2O1xuY29uc3QgUkdCQV9TM1RDX0RYVDFfRm9ybWF0ID0gMzM3Nzc7XG5jb25zdCBSR0JBX1MzVENfRFhUM19Gb3JtYXQgPSAzMzc3ODtcbmNvbnN0IFJHQkFfUzNUQ19EWFQ1X0Zvcm1hdCA9IDMzNzc5O1xuY29uc3QgUkdCX1BWUlRDXzRCUFBWMV9Gb3JtYXQgPSAzNTg0MDtcbmNvbnN0IFJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0ID0gMzU4NDE7XG5jb25zdCBSR0JBX1BWUlRDXzRCUFBWMV9Gb3JtYXQgPSAzNTg0MjtcbmNvbnN0IFJHQkFfUFZSVENfMkJQUFYxX0Zvcm1hdCA9IDM1ODQzO1xuY29uc3QgUkdCX0VUQzFfRm9ybWF0ID0gMzYxOTY7XG5jb25zdCBSR0JfRVRDMl9Gb3JtYXQgPSAzNzQ5MjtcbmNvbnN0IFJHQkFfRVRDMl9FQUNfRm9ybWF0ID0gMzc0OTY7XG5jb25zdCBSR0JBX0FTVENfNHg0X0Zvcm1hdCA9IDM3ODA4O1xuY29uc3QgUkdCQV9BU1RDXzV4NF9Gb3JtYXQgPSAzNzgwOTtcbmNvbnN0IFJHQkFfQVNUQ181eDVfRm9ybWF0ID0gMzc4MTA7XG5jb25zdCBSR0JBX0FTVENfNng1X0Zvcm1hdCA9IDM3ODExO1xuY29uc3QgUkdCQV9BU1RDXzZ4Nl9Gb3JtYXQgPSAzNzgxMjtcbmNvbnN0IFJHQkFfQVNUQ184eDVfRm9ybWF0ID0gMzc4MTM7XG5jb25zdCBSR0JBX0FTVENfOHg2X0Zvcm1hdCA9IDM3ODE0O1xuY29uc3QgUkdCQV9BU1RDXzh4OF9Gb3JtYXQgPSAzNzgxNTtcbmNvbnN0IFJHQkFfQVNUQ18xMHg1X0Zvcm1hdCA9IDM3ODE2O1xuY29uc3QgUkdCQV9BU1RDXzEweDZfRm9ybWF0ID0gMzc4MTc7XG5jb25zdCBSR0JBX0FTVENfMTB4OF9Gb3JtYXQgPSAzNzgxODtcbmNvbnN0IFJHQkFfQVNUQ18xMHgxMF9Gb3JtYXQgPSAzNzgxOTtcbmNvbnN0IFJHQkFfQVNUQ18xMngxMF9Gb3JtYXQgPSAzNzgyMDtcbmNvbnN0IFJHQkFfQVNUQ18xMngxMl9Gb3JtYXQgPSAzNzgyMTtcbmNvbnN0IFJHQkFfQlBUQ19Gb3JtYXQgPSAzNjQ5MjtcbmNvbnN0IExvb3BPbmNlID0gMjIwMDtcbmNvbnN0IExvb3BSZXBlYXQgPSAyMjAxO1xuY29uc3QgTG9vcFBpbmdQb25nID0gMjIwMjtcbmNvbnN0IEludGVycG9sYXRlRGlzY3JldGUgPSAyMzAwO1xuY29uc3QgSW50ZXJwb2xhdGVMaW5lYXIgPSAyMzAxO1xuY29uc3QgSW50ZXJwb2xhdGVTbW9vdGggPSAyMzAyO1xuY29uc3QgWmVyb0N1cnZhdHVyZUVuZGluZyA9IDI0MDA7XG5jb25zdCBaZXJvU2xvcGVFbmRpbmcgPSAyNDAxO1xuY29uc3QgV3JhcEFyb3VuZEVuZGluZyA9IDI0MDI7XG5jb25zdCBOb3JtYWxBbmltYXRpb25CbGVuZE1vZGUgPSAyNTAwO1xuY29uc3QgQWRkaXRpdmVBbmltYXRpb25CbGVuZE1vZGUgPSAyNTAxO1xuY29uc3QgVHJpYW5nbGVzRHJhd01vZGUgPSAwO1xuY29uc3QgVHJpYW5nbGVTdHJpcERyYXdNb2RlID0gMTtcbmNvbnN0IFRyaWFuZ2xlRmFuRHJhd01vZGUgPSAyO1xuY29uc3QgTGluZWFyRW5jb2RpbmcgPSAzMDAwO1xuY29uc3Qgc1JHQkVuY29kaW5nID0gMzAwMTtcbmNvbnN0IEJhc2ljRGVwdGhQYWNraW5nID0gMzIwMDtcbmNvbnN0IFJHQkFEZXB0aFBhY2tpbmcgPSAzMjAxO1xuY29uc3QgVGFuZ2VudFNwYWNlTm9ybWFsTWFwID0gMDtcbmNvbnN0IE9iamVjdFNwYWNlTm9ybWFsTWFwID0gMTtcblxuLy8gQ29sb3Igc3BhY2Ugc3RyaW5nIGlkZW50aWZpZXJzLCBtYXRjaGluZyBDU1MgQ29sb3IgTW9kdWxlIExldmVsIDQgYW5kIFdlYkdQVSBuYW1lcyB3aGVyZSBhdmFpbGFibGUuXG5jb25zdCBOb0NvbG9yU3BhY2UgPSAnJztcbmNvbnN0IFNSR0JDb2xvclNwYWNlID0gJ3NyZ2InO1xuY29uc3QgTGluZWFyU1JHQkNvbG9yU3BhY2UgPSAnc3JnYi1saW5lYXInO1xuY29uc3QgWmVyb1N0ZW5jaWxPcCA9IDA7XG5jb25zdCBLZWVwU3RlbmNpbE9wID0gNzY4MDtcbmNvbnN0IFJlcGxhY2VTdGVuY2lsT3AgPSA3NjgxO1xuY29uc3QgSW5jcmVtZW50U3RlbmNpbE9wID0gNzY4MjtcbmNvbnN0IERlY3JlbWVudFN0ZW5jaWxPcCA9IDc2ODM7XG5jb25zdCBJbmNyZW1lbnRXcmFwU3RlbmNpbE9wID0gMzQwNTU7XG5jb25zdCBEZWNyZW1lbnRXcmFwU3RlbmNpbE9wID0gMzQwNTY7XG5jb25zdCBJbnZlcnRTdGVuY2lsT3AgPSA1Mzg2O1xuY29uc3QgTmV2ZXJTdGVuY2lsRnVuYyA9IDUxMjtcbmNvbnN0IExlc3NTdGVuY2lsRnVuYyA9IDUxMztcbmNvbnN0IEVxdWFsU3RlbmNpbEZ1bmMgPSA1MTQ7XG5jb25zdCBMZXNzRXF1YWxTdGVuY2lsRnVuYyA9IDUxNTtcbmNvbnN0IEdyZWF0ZXJTdGVuY2lsRnVuYyA9IDUxNjtcbmNvbnN0IE5vdEVxdWFsU3RlbmNpbEZ1bmMgPSA1MTc7XG5jb25zdCBHcmVhdGVyRXF1YWxTdGVuY2lsRnVuYyA9IDUxODtcbmNvbnN0IEFsd2F5c1N0ZW5jaWxGdW5jID0gNTE5O1xuY29uc3QgU3RhdGljRHJhd1VzYWdlID0gMzUwNDQ7XG5jb25zdCBEeW5hbWljRHJhd1VzYWdlID0gMzUwNDg7XG5jb25zdCBTdHJlYW1EcmF3VXNhZ2UgPSAzNTA0MDtcbmNvbnN0IFN0YXRpY1JlYWRVc2FnZSA9IDM1MDQ1O1xuY29uc3QgRHluYW1pY1JlYWRVc2FnZSA9IDM1MDQ5O1xuY29uc3QgU3RyZWFtUmVhZFVzYWdlID0gMzUwNDE7XG5jb25zdCBTdGF0aWNDb3B5VXNhZ2UgPSAzNTA0NjtcbmNvbnN0IER5bmFtaWNDb3B5VXNhZ2UgPSAzNTA1MDtcbmNvbnN0IFN0cmVhbUNvcHlVc2FnZSA9IDM1MDQyO1xuY29uc3QgR0xTTDEgPSAnMTAwJztcbmNvbnN0IEdMU0wzID0gJzMwMCBlcyc7XG5jb25zdCBfU1JHQkFGb3JtYXQgPSAxMDM1OyAvLyBmYWxsYmFjayBmb3IgV2ViR0wgMVxuXG4vKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvZXZlbnRkaXNwYXRjaGVyLmpzL1xuICovXG5cbmNsYXNzIEV2ZW50RGlzcGF0Y2hlciB7XG5cdGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcblx0XHRpZiAodGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQpIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuXHRcdGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcblx0XHRpZiAobGlzdGVuZXJzW3R5cGVdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGxpc3RlbmVyc1t0eXBlXSA9IFtdO1xuXHRcdH1cblx0XHRpZiAobGlzdGVuZXJzW3R5cGVdLmluZGV4T2YobGlzdGVuZXIpID09PSAtMSkge1xuXHRcdFx0bGlzdGVuZXJzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuXHRcdH1cblx0fVxuXHRoYXNFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG5cdFx0aWYgKHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZmFsc2U7XG5cdFx0Y29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuXHRcdHJldHVybiBsaXN0ZW5lcnNbdHlwZV0gIT09IHVuZGVmaW5lZCAmJiBsaXN0ZW5lcnNbdHlwZV0uaW5kZXhPZihsaXN0ZW5lcikgIT09IC0xO1xuXHR9XG5cdHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcblx0XHRpZiAodGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQpIHJldHVybjtcblx0XHRjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG5cdFx0Y29uc3QgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1t0eXBlXTtcblx0XHRpZiAobGlzdGVuZXJBcnJheSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjb25zdCBpbmRleCA9IGxpc3RlbmVyQXJyYXkuaW5kZXhPZihsaXN0ZW5lcik7XG5cdFx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG5cdFx0XHRcdGxpc3RlbmVyQXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZGlzcGF0Y2hFdmVudChldmVudCkge1xuXHRcdGlmICh0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXHRcdGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcblx0XHRjb25zdCBsaXN0ZW5lckFycmF5ID0gbGlzdGVuZXJzW2V2ZW50LnR5cGVdO1xuXHRcdGlmIChsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IHRoaXM7XG5cblx0XHRcdC8vIE1ha2UgYSBjb3B5LCBpbiBjYXNlIGxpc3RlbmVycyBhcmUgcmVtb3ZlZCB3aGlsZSBpdGVyYXRpbmcuXG5cdFx0XHRjb25zdCBhcnJheSA9IGxpc3RlbmVyQXJyYXkuc2xpY2UoMCk7XG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRhcnJheVtpXS5jYWxsKHRoaXMsIGV2ZW50KTtcblx0XHRcdH1cblx0XHRcdGV2ZW50LnRhcmdldCA9IG51bGw7XG5cdFx0fVxuXHR9XG59XG5cbmNvbnN0IF9sdXQgPSBbJzAwJywgJzAxJywgJzAyJywgJzAzJywgJzA0JywgJzA1JywgJzA2JywgJzA3JywgJzA4JywgJzA5JywgJzBhJywgJzBiJywgJzBjJywgJzBkJywgJzBlJywgJzBmJywgJzEwJywgJzExJywgJzEyJywgJzEzJywgJzE0JywgJzE1JywgJzE2JywgJzE3JywgJzE4JywgJzE5JywgJzFhJywgJzFiJywgJzFjJywgJzFkJywgJzFlJywgJzFmJywgJzIwJywgJzIxJywgJzIyJywgJzIzJywgJzI0JywgJzI1JywgJzI2JywgJzI3JywgJzI4JywgJzI5JywgJzJhJywgJzJiJywgJzJjJywgJzJkJywgJzJlJywgJzJmJywgJzMwJywgJzMxJywgJzMyJywgJzMzJywgJzM0JywgJzM1JywgJzM2JywgJzM3JywgJzM4JywgJzM5JywgJzNhJywgJzNiJywgJzNjJywgJzNkJywgJzNlJywgJzNmJywgJzQwJywgJzQxJywgJzQyJywgJzQzJywgJzQ0JywgJzQ1JywgJzQ2JywgJzQ3JywgJzQ4JywgJzQ5JywgJzRhJywgJzRiJywgJzRjJywgJzRkJywgJzRlJywgJzRmJywgJzUwJywgJzUxJywgJzUyJywgJzUzJywgJzU0JywgJzU1JywgJzU2JywgJzU3JywgJzU4JywgJzU5JywgJzVhJywgJzViJywgJzVjJywgJzVkJywgJzVlJywgJzVmJywgJzYwJywgJzYxJywgJzYyJywgJzYzJywgJzY0JywgJzY1JywgJzY2JywgJzY3JywgJzY4JywgJzY5JywgJzZhJywgJzZiJywgJzZjJywgJzZkJywgJzZlJywgJzZmJywgJzcwJywgJzcxJywgJzcyJywgJzczJywgJzc0JywgJzc1JywgJzc2JywgJzc3JywgJzc4JywgJzc5JywgJzdhJywgJzdiJywgJzdjJywgJzdkJywgJzdlJywgJzdmJywgJzgwJywgJzgxJywgJzgyJywgJzgzJywgJzg0JywgJzg1JywgJzg2JywgJzg3JywgJzg4JywgJzg5JywgJzhhJywgJzhiJywgJzhjJywgJzhkJywgJzhlJywgJzhmJywgJzkwJywgJzkxJywgJzkyJywgJzkzJywgJzk0JywgJzk1JywgJzk2JywgJzk3JywgJzk4JywgJzk5JywgJzlhJywgJzliJywgJzljJywgJzlkJywgJzllJywgJzlmJywgJ2EwJywgJ2ExJywgJ2EyJywgJ2EzJywgJ2E0JywgJ2E1JywgJ2E2JywgJ2E3JywgJ2E4JywgJ2E5JywgJ2FhJywgJ2FiJywgJ2FjJywgJ2FkJywgJ2FlJywgJ2FmJywgJ2IwJywgJ2IxJywgJ2IyJywgJ2IzJywgJ2I0JywgJ2I1JywgJ2I2JywgJ2I3JywgJ2I4JywgJ2I5JywgJ2JhJywgJ2JiJywgJ2JjJywgJ2JkJywgJ2JlJywgJ2JmJywgJ2MwJywgJ2MxJywgJ2MyJywgJ2MzJywgJ2M0JywgJ2M1JywgJ2M2JywgJ2M3JywgJ2M4JywgJ2M5JywgJ2NhJywgJ2NiJywgJ2NjJywgJ2NkJywgJ2NlJywgJ2NmJywgJ2QwJywgJ2QxJywgJ2QyJywgJ2QzJywgJ2Q0JywgJ2Q1JywgJ2Q2JywgJ2Q3JywgJ2Q4JywgJ2Q5JywgJ2RhJywgJ2RiJywgJ2RjJywgJ2RkJywgJ2RlJywgJ2RmJywgJ2UwJywgJ2UxJywgJ2UyJywgJ2UzJywgJ2U0JywgJ2U1JywgJ2U2JywgJ2U3JywgJ2U4JywgJ2U5JywgJ2VhJywgJ2ViJywgJ2VjJywgJ2VkJywgJ2VlJywgJ2VmJywgJ2YwJywgJ2YxJywgJ2YyJywgJ2YzJywgJ2Y0JywgJ2Y1JywgJ2Y2JywgJ2Y3JywgJ2Y4JywgJ2Y5JywgJ2ZhJywgJ2ZiJywgJ2ZjJywgJ2ZkJywgJ2ZlJywgJ2ZmJ107XG5sZXQgX3NlZWQgPSAxMjM0NTY3O1xuY29uc3QgREVHMlJBRCA9IE1hdGguUEkgLyAxODA7XG5jb25zdCBSQUQyREVHID0gMTgwIC8gTWF0aC5QSTtcblxuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDUwMzQvaG93LXRvLWNyZWF0ZS1hLWd1aWQtdXVpZC1pbi1qYXZhc2NyaXB0LzIxOTYzMTM2IzIxOTYzMTM2XG5mdW5jdGlvbiBnZW5lcmF0ZVVVSUQoKSB7XG5cdGNvbnN0IGQwID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xuXHRjb25zdCBkMSA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcblx0Y29uc3QgZDIgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XG5cdGNvbnN0IGQzID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xuXHRjb25zdCB1dWlkID0gX2x1dFtkMCAmIDB4ZmZdICsgX2x1dFtkMCA+PiA4ICYgMHhmZl0gKyBfbHV0W2QwID4+IDE2ICYgMHhmZl0gKyBfbHV0W2QwID4+IDI0ICYgMHhmZl0gKyAnLScgKyBfbHV0W2QxICYgMHhmZl0gKyBfbHV0W2QxID4+IDggJiAweGZmXSArICctJyArIF9sdXRbZDEgPj4gMTYgJiAweDBmIHwgMHg0MF0gKyBfbHV0W2QxID4+IDI0ICYgMHhmZl0gKyAnLScgKyBfbHV0W2QyICYgMHgzZiB8IDB4ODBdICsgX2x1dFtkMiA+PiA4ICYgMHhmZl0gKyAnLScgKyBfbHV0W2QyID4+IDE2ICYgMHhmZl0gKyBfbHV0W2QyID4+IDI0ICYgMHhmZl0gKyBfbHV0W2QzICYgMHhmZl0gKyBfbHV0W2QzID4+IDggJiAweGZmXSArIF9sdXRbZDMgPj4gMTYgJiAweGZmXSArIF9sdXRbZDMgPj4gMjQgJiAweGZmXTtcblxuXHQvLyAudG9Mb3dlckNhc2UoKSBoZXJlIGZsYXR0ZW5zIGNvbmNhdGVuYXRlZCBzdHJpbmdzIHRvIHNhdmUgaGVhcCBtZW1vcnkgc3BhY2UuXG5cdHJldHVybiB1dWlkLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBjbGFtcCh2YWx1ZSwgbWluLCBtYXgpIHtcblx0cmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB2YWx1ZSkpO1xufVxuXG4vLyBjb21wdXRlIGV1Y2xpZGVhbiBtb2R1bG8gb2YgbSAlIG5cbi8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01vZHVsb19vcGVyYXRpb25cbmZ1bmN0aW9uIGV1Y2xpZGVhbk1vZHVsbyhuLCBtKSB7XG5cdHJldHVybiAobiAlIG0gKyBtKSAlIG07XG59XG5cbi8vIExpbmVhciBtYXBwaW5nIGZyb20gcmFuZ2UgPGExLCBhMj4gdG8gcmFuZ2UgPGIxLCBiMj5cbmZ1bmN0aW9uIG1hcExpbmVhcih4LCBhMSwgYTIsIGIxLCBiMikge1xuXHRyZXR1cm4gYjEgKyAoeCAtIGExKSAqIChiMiAtIGIxKSAvIChhMiAtIGExKTtcbn1cblxuLy8gaHR0cHM6Ly93d3cuZ2FtZWRldi5uZXQvdHV0b3JpYWxzL3Byb2dyYW1taW5nL2dlbmVyYWwtYW5kLWdhbWVwbGF5LXByb2dyYW1taW5nL2ludmVyc2UtbGVycC1hLXN1cGVyLXVzZWZ1bC15ZXQtb2Z0ZW4tb3Zlcmxvb2tlZC1mdW5jdGlvbi1yNTIzMC9cbmZ1bmN0aW9uIGludmVyc2VMZXJwKHgsIHksIHZhbHVlKSB7XG5cdGlmICh4ICE9PSB5KSB7XG5cdFx0cmV0dXJuICh2YWx1ZSAtIHgpIC8gKHkgLSB4KTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gMDtcblx0fVxufVxuXG4vLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaW5lYXJfaW50ZXJwb2xhdGlvblxuZnVuY3Rpb24gbGVycCh4LCB5LCB0KSB7XG5cdHJldHVybiAoMSAtIHQpICogeCArIHQgKiB5O1xufVxuXG4vLyBodHRwOi8vd3d3LnJvcnlkcmlzY29sbC5jb20vMjAxNi8wMy8wNy9mcmFtZS1yYXRlLWluZGVwZW5kZW50LWRhbXBpbmctdXNpbmctbGVycC9cbmZ1bmN0aW9uIGRhbXAoeCwgeSwgbGFtYmRhLCBkdCkge1xuXHRyZXR1cm4gbGVycCh4LCB5LCAxIC0gTWF0aC5leHAoLWxhbWJkYSAqIGR0KSk7XG59XG5cbi8vIGh0dHBzOi8vd3d3LmRlc21vcy5jb20vY2FsY3VsYXRvci92Y3Nqbnl6N3g0XG5mdW5jdGlvbiBwaW5ncG9uZyh4LCBsZW5ndGggPSAxKSB7XG5cdHJldHVybiBsZW5ndGggLSBNYXRoLmFicyhldWNsaWRlYW5Nb2R1bG8oeCwgbGVuZ3RoICogMikgLSBsZW5ndGgpO1xufVxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Ntb290aHN0ZXBcbmZ1bmN0aW9uIHNtb290aHN0ZXAoeCwgbWluLCBtYXgpIHtcblx0aWYgKHggPD0gbWluKSByZXR1cm4gMDtcblx0aWYgKHggPj0gbWF4KSByZXR1cm4gMTtcblx0eCA9ICh4IC0gbWluKSAvIChtYXggLSBtaW4pO1xuXHRyZXR1cm4geCAqIHggKiAoMyAtIDIgKiB4KTtcbn1cbmZ1bmN0aW9uIHNtb290aGVyc3RlcCh4LCBtaW4sIG1heCkge1xuXHRpZiAoeCA8PSBtaW4pIHJldHVybiAwO1xuXHRpZiAoeCA+PSBtYXgpIHJldHVybiAxO1xuXHR4ID0gKHggLSBtaW4pIC8gKG1heCAtIG1pbik7XG5cdHJldHVybiB4ICogeCAqIHggKiAoeCAqICh4ICogNiAtIDE1KSArIDEwKTtcbn1cblxuLy8gUmFuZG9tIGludGVnZXIgZnJvbSA8bG93LCBoaWdoPiBpbnRlcnZhbFxuZnVuY3Rpb24gcmFuZEludChsb3csIGhpZ2gpIHtcblx0cmV0dXJuIGxvdyArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChoaWdoIC0gbG93ICsgMSkpO1xufVxuXG4vLyBSYW5kb20gZmxvYXQgZnJvbSA8bG93LCBoaWdoPiBpbnRlcnZhbFxuZnVuY3Rpb24gcmFuZEZsb2F0KGxvdywgaGlnaCkge1xuXHRyZXR1cm4gbG93ICsgTWF0aC5yYW5kb20oKSAqIChoaWdoIC0gbG93KTtcbn1cblxuLy8gUmFuZG9tIGZsb2F0IGZyb20gPC1yYW5nZS8yLCByYW5nZS8yPiBpbnRlcnZhbFxuZnVuY3Rpb24gcmFuZEZsb2F0U3ByZWFkKHJhbmdlKSB7XG5cdHJldHVybiByYW5nZSAqICgwLjUgLSBNYXRoLnJhbmRvbSgpKTtcbn1cblxuLy8gRGV0ZXJtaW5pc3RpYyBwc2V1ZG8tcmFuZG9tIGZsb2F0IGluIHRoZSBpbnRlcnZhbCBbIDAsIDEgXVxuZnVuY3Rpb24gc2VlZGVkUmFuZG9tKHMpIHtcblx0aWYgKHMgIT09IHVuZGVmaW5lZCkgX3NlZWQgPSBzO1xuXG5cdC8vIE11bGJlcnJ5MzIgZ2VuZXJhdG9yXG5cblx0bGV0IHQgPSBfc2VlZCArPSAweDZEMkI3OUY1O1xuXHR0ID0gTWF0aC5pbXVsKHQgXiB0ID4+PiAxNSwgdCB8IDEpO1xuXHR0IF49IHQgKyBNYXRoLmltdWwodCBeIHQgPj4+IDcsIHQgfCA2MSk7XG5cdHJldHVybiAoKHQgXiB0ID4+PiAxNCkgPj4+IDApIC8gNDI5NDk2NzI5Njtcbn1cbmZ1bmN0aW9uIGRlZ1RvUmFkKGRlZ3JlZXMpIHtcblx0cmV0dXJuIGRlZ3JlZXMgKiBERUcyUkFEO1xufVxuZnVuY3Rpb24gcmFkVG9EZWcocmFkaWFucykge1xuXHRyZXR1cm4gcmFkaWFucyAqIFJBRDJERUc7XG59XG5mdW5jdGlvbiBpc1Bvd2VyT2ZUd28odmFsdWUpIHtcblx0cmV0dXJuICh2YWx1ZSAmIHZhbHVlIC0gMSkgPT09IDAgJiYgdmFsdWUgIT09IDA7XG59XG5mdW5jdGlvbiBjZWlsUG93ZXJPZlR3byh2YWx1ZSkge1xuXHRyZXR1cm4gTWF0aC5wb3coMiwgTWF0aC5jZWlsKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKSk7XG59XG5mdW5jdGlvbiBmbG9vclBvd2VyT2ZUd28odmFsdWUpIHtcblx0cmV0dXJuIE1hdGgucG93KDIsIE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpKTtcbn1cbmZ1bmN0aW9uIHNldFF1YXRlcm5pb25Gcm9tUHJvcGVyRXVsZXIocSwgYSwgYiwgYywgb3JkZXIpIHtcblx0Ly8gSW50cmluc2ljIFByb3BlciBFdWxlciBBbmdsZXMgLSBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXVsZXJfYW5nbGVzXG5cblx0Ly8gcm90YXRpb25zIGFyZSBhcHBsaWVkIHRvIHRoZSBheGVzIGluIHRoZSBvcmRlciBzcGVjaWZpZWQgYnkgJ29yZGVyJ1xuXHQvLyByb3RhdGlvbiBieSBhbmdsZSAnYScgaXMgYXBwbGllZCBmaXJzdCwgdGhlbiBieSBhbmdsZSAnYicsIHRoZW4gYnkgYW5nbGUgJ2MnXG5cdC8vIGFuZ2xlcyBhcmUgaW4gcmFkaWFuc1xuXG5cdGNvbnN0IGNvcyA9IE1hdGguY29zO1xuXHRjb25zdCBzaW4gPSBNYXRoLnNpbjtcblx0Y29uc3QgYzIgPSBjb3MoYiAvIDIpO1xuXHRjb25zdCBzMiA9IHNpbihiIC8gMik7XG5cdGNvbnN0IGMxMyA9IGNvcygoYSArIGMpIC8gMik7XG5cdGNvbnN0IHMxMyA9IHNpbigoYSArIGMpIC8gMik7XG5cdGNvbnN0IGMxXzMgPSBjb3MoKGEgLSBjKSAvIDIpO1xuXHRjb25zdCBzMV8zID0gc2luKChhIC0gYykgLyAyKTtcblx0Y29uc3QgYzNfMSA9IGNvcygoYyAtIGEpIC8gMik7XG5cdGNvbnN0IHMzXzEgPSBzaW4oKGMgLSBhKSAvIDIpO1xuXHRzd2l0Y2ggKG9yZGVyKSB7XG5cdFx0Y2FzZSAnWFlYJzpcblx0XHRcdHEuc2V0KGMyICogczEzLCBzMiAqIGMxXzMsIHMyICogczFfMywgYzIgKiBjMTMpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnWVpZJzpcblx0XHRcdHEuc2V0KHMyICogczFfMywgYzIgKiBzMTMsIHMyICogYzFfMywgYzIgKiBjMTMpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnWlhaJzpcblx0XHRcdHEuc2V0KHMyICogYzFfMywgczIgKiBzMV8zLCBjMiAqIHMxMywgYzIgKiBjMTMpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnWFpYJzpcblx0XHRcdHEuc2V0KGMyICogczEzLCBzMiAqIHMzXzEsIHMyICogYzNfMSwgYzIgKiBjMTMpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnWVhZJzpcblx0XHRcdHEuc2V0KHMyICogYzNfMSwgYzIgKiBzMTMsIHMyICogczNfMSwgYzIgKiBjMTMpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnWllaJzpcblx0XHRcdHEuc2V0KHMyICogczNfMSwgczIgKiBjM18xLCBjMiAqIHMxMywgYzIgKiBjMTMpO1xuXHRcdFx0YnJlYWs7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuTWF0aFV0aWxzOiAuc2V0UXVhdGVybmlvbkZyb21Qcm9wZXJFdWxlcigpIGVuY291bnRlcmVkIGFuIHVua25vd24gb3JkZXI6ICcgKyBvcmRlcik7XG5cdH1cbn1cbmZ1bmN0aW9uIGRlbm9ybWFsaXplKHZhbHVlLCBhcnJheSkge1xuXHRzd2l0Y2ggKGFycmF5LmNvbnN0cnVjdG9yKSB7XG5cdFx0Y2FzZSBGbG9hdDMyQXJyYXk6XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0Y2FzZSBVaW50MTZBcnJheTpcblx0XHRcdHJldHVybiB2YWx1ZSAvIDY1NTM1LjA7XG5cdFx0Y2FzZSBVaW50OEFycmF5OlxuXHRcdFx0cmV0dXJuIHZhbHVlIC8gMjU1LjA7XG5cdFx0Y2FzZSBJbnQxNkFycmF5OlxuXHRcdFx0cmV0dXJuIE1hdGgubWF4KHZhbHVlIC8gMzI3NjcuMCwgLTEuMCk7XG5cdFx0Y2FzZSBJbnQ4QXJyYXk6XG5cdFx0XHRyZXR1cm4gTWF0aC5tYXgodmFsdWUgLyAxMjcuMCwgLTEuMCk7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb21wb25lbnQgdHlwZS4nKTtcblx0fVxufVxuZnVuY3Rpb24gbm9ybWFsaXplKHZhbHVlLCBhcnJheSkge1xuXHRzd2l0Y2ggKGFycmF5LmNvbnN0cnVjdG9yKSB7XG5cdFx0Y2FzZSBGbG9hdDMyQXJyYXk6XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0Y2FzZSBVaW50MTZBcnJheTpcblx0XHRcdHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogNjU1MzUuMCk7XG5cdFx0Y2FzZSBVaW50OEFycmF5OlxuXHRcdFx0cmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiAyNTUuMCk7XG5cdFx0Y2FzZSBJbnQxNkFycmF5OlxuXHRcdFx0cmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiAzMjc2Ny4wKTtcblx0XHRjYXNlIEludDhBcnJheTpcblx0XHRcdHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogMTI3LjApO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29tcG9uZW50IHR5cGUuJyk7XG5cdH1cbn1cblxudmFyIE1hdGhVdGlscyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRERUcyUkFEOiBERUcyUkFELFxuXHRSQUQyREVHOiBSQUQyREVHLFxuXHRnZW5lcmF0ZVVVSUQ6IGdlbmVyYXRlVVVJRCxcblx0Y2xhbXA6IGNsYW1wLFxuXHRldWNsaWRlYW5Nb2R1bG86IGV1Y2xpZGVhbk1vZHVsbyxcblx0bWFwTGluZWFyOiBtYXBMaW5lYXIsXG5cdGludmVyc2VMZXJwOiBpbnZlcnNlTGVycCxcblx0bGVycDogbGVycCxcblx0ZGFtcDogZGFtcCxcblx0cGluZ3Bvbmc6IHBpbmdwb25nLFxuXHRzbW9vdGhzdGVwOiBzbW9vdGhzdGVwLFxuXHRzbW9vdGhlcnN0ZXA6IHNtb290aGVyc3RlcCxcblx0cmFuZEludDogcmFuZEludCxcblx0cmFuZEZsb2F0OiByYW5kRmxvYXQsXG5cdHJhbmRGbG9hdFNwcmVhZDogcmFuZEZsb2F0U3ByZWFkLFxuXHRzZWVkZWRSYW5kb206IHNlZWRlZFJhbmRvbSxcblx0ZGVnVG9SYWQ6IGRlZ1RvUmFkLFxuXHRyYWRUb0RlZzogcmFkVG9EZWcsXG5cdGlzUG93ZXJPZlR3bzogaXNQb3dlck9mVHdvLFxuXHRjZWlsUG93ZXJPZlR3bzogY2VpbFBvd2VyT2ZUd28sXG5cdGZsb29yUG93ZXJPZlR3bzogZmxvb3JQb3dlck9mVHdvLFxuXHRzZXRRdWF0ZXJuaW9uRnJvbVByb3BlckV1bGVyOiBzZXRRdWF0ZXJuaW9uRnJvbVByb3BlckV1bGVyLFxuXHRub3JtYWxpemU6IG5vcm1hbGl6ZSxcblx0ZGVub3JtYWxpemU6IGRlbm9ybWFsaXplXG59KTtcblxuY2xhc3MgVmVjdG9yMiB7XG5cdGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCkge1xuXHRcdFZlY3RvcjIucHJvdG90eXBlLmlzVmVjdG9yMiA9IHRydWU7XG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXHR9XG5cdGdldCB3aWR0aCgpIHtcblx0XHRyZXR1cm4gdGhpcy54O1xuXHR9XG5cdHNldCB3aWR0aCh2YWx1ZSkge1xuXHRcdHRoaXMueCA9IHZhbHVlO1xuXHR9XG5cdGdldCBoZWlnaHQoKSB7XG5cdFx0cmV0dXJuIHRoaXMueTtcblx0fVxuXHRzZXQgaGVpZ2h0KHZhbHVlKSB7XG5cdFx0dGhpcy55ID0gdmFsdWU7XG5cdH1cblx0c2V0KHgsIHkpIHtcblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0c2V0U2NhbGFyKHNjYWxhcikge1xuXHRcdHRoaXMueCA9IHNjYWxhcjtcblx0XHR0aGlzLnkgPSBzY2FsYXI7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0c2V0WCh4KSB7XG5cdFx0dGhpcy54ID0geDtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRzZXRZKHkpIHtcblx0XHR0aGlzLnkgPSB5O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHNldENvbXBvbmVudChpbmRleCwgdmFsdWUpIHtcblx0XHRzd2l0Y2ggKGluZGV4KSB7XG5cdFx0XHRjYXNlIDA6XG5cdFx0XHRcdHRoaXMueCA9IHZhbHVlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgMTpcblx0XHRcdFx0dGhpcy55ID0gdmFsdWU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGdldENvbXBvbmVudChpbmRleCkge1xuXHRcdHN3aXRjaCAoaW5kZXgpIHtcblx0XHRcdGNhc2UgMDpcblx0XHRcdFx0cmV0dXJuIHRoaXMueDtcblx0XHRcdGNhc2UgMTpcblx0XHRcdFx0cmV0dXJuIHRoaXMueTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXgpO1xuXHRcdH1cblx0fVxuXHRjbG9uZSgpIHtcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy54LCB0aGlzLnkpO1xuXHR9XG5cdGNvcHkodikge1xuXHRcdHRoaXMueCA9IHYueDtcblx0XHR0aGlzLnkgPSB2Lnk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0YWRkKHYpIHtcblx0XHR0aGlzLnggKz0gdi54O1xuXHRcdHRoaXMueSArPSB2Lnk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0YWRkU2NhbGFyKHMpIHtcblx0XHR0aGlzLnggKz0gcztcblx0XHR0aGlzLnkgKz0gcztcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRhZGRWZWN0b3JzKGEsIGIpIHtcblx0XHR0aGlzLnggPSBhLnggKyBiLng7XG5cdFx0dGhpcy55ID0gYS55ICsgYi55O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGFkZFNjYWxlZFZlY3Rvcih2LCBzKSB7XG5cdFx0dGhpcy54ICs9IHYueCAqIHM7XG5cdFx0dGhpcy55ICs9IHYueSAqIHM7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0c3ViKHYpIHtcblx0XHR0aGlzLnggLT0gdi54O1xuXHRcdHRoaXMueSAtPSB2Lnk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0c3ViU2NhbGFyKHMpIHtcblx0XHR0aGlzLnggLT0gcztcblx0XHR0aGlzLnkgLT0gcztcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRzdWJWZWN0b3JzKGEsIGIpIHtcblx0XHR0aGlzLnggPSBhLnggLSBiLng7XG5cdFx0dGhpcy55ID0gYS55IC0gYi55O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdG11bHRpcGx5KHYpIHtcblx0XHR0aGlzLnggKj0gdi54O1xuXHRcdHRoaXMueSAqPSB2Lnk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0bXVsdGlwbHlTY2FsYXIoc2NhbGFyKSB7XG5cdFx0dGhpcy54ICo9IHNjYWxhcjtcblx0XHR0aGlzLnkgKj0gc2NhbGFyO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGRpdmlkZSh2KSB7XG5cdFx0dGhpcy54IC89IHYueDtcblx0XHR0aGlzLnkgLz0gdi55O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGRpdmlkZVNjYWxhcihzY2FsYXIpIHtcblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhcigxIC8gc2NhbGFyKTtcblx0fVxuXHRhcHBseU1hdHJpeDMobSkge1xuXHRcdGNvbnN0IHggPSB0aGlzLngsXG5cdFx0XHR5ID0gdGhpcy55O1xuXHRcdGNvbnN0IGUgPSBtLmVsZW1lbnRzO1xuXHRcdHRoaXMueCA9IGVbMF0gKiB4ICsgZVszXSAqIHkgKyBlWzZdO1xuXHRcdHRoaXMueSA9IGVbMV0gKiB4ICsgZVs0XSAqIHkgKyBlWzddO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdG1pbih2KSB7XG5cdFx0dGhpcy54ID0gTWF0aC5taW4odGhpcy54LCB2LngpO1xuXHRcdHRoaXMueSA9IE1hdGgubWluKHRoaXMueSwgdi55KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRtYXgodikge1xuXHRcdHRoaXMueCA9IE1hdGgubWF4KHRoaXMueCwgdi54KTtcblx0XHR0aGlzLnkgPSBNYXRoLm1heCh0aGlzLnksIHYueSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0Y2xhbXAobWluLCBtYXgpIHtcblx0XHQvLyBhc3N1bWVzIG1pbiA8IG1heCwgY29tcG9uZW50d2lzZVxuXG5cdFx0dGhpcy54ID0gTWF0aC5tYXgobWluLngsIE1hdGgubWluKG1heC54LCB0aGlzLngpKTtcblx0XHR0aGlzLnkgPSBNYXRoLm1heChtaW4ueSwgTWF0aC5taW4obWF4LnksIHRoaXMueSkpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGNsYW1wU2NhbGFyKG1pblZhbCwgbWF4VmFsKSB7XG5cdFx0dGhpcy54ID0gTWF0aC5tYXgobWluVmFsLCBNYXRoLm1pbihtYXhWYWwsIHRoaXMueCkpO1xuXHRcdHRoaXMueSA9IE1hdGgubWF4KG1pblZhbCwgTWF0aC5taW4obWF4VmFsLCB0aGlzLnkpKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRjbGFtcExlbmd0aChtaW4sIG1heCkge1xuXHRcdGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG5cdFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKGxlbmd0aCB8fCAxKS5tdWx0aXBseVNjYWxhcihNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgbGVuZ3RoKSkpO1xuXHR9XG5cdGZsb29yKCkge1xuXHRcdHRoaXMueCA9IE1hdGguZmxvb3IodGhpcy54KTtcblx0XHR0aGlzLnkgPSBNYXRoLmZsb29yKHRoaXMueSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0Y2VpbCgpIHtcblx0XHR0aGlzLnggPSBNYXRoLmNlaWwodGhpcy54KTtcblx0XHR0aGlzLnkgPSBNYXRoLmNlaWwodGhpcy55KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRyb3VuZCgpIHtcblx0XHR0aGlzLnggPSBNYXRoLnJvdW5kKHRoaXMueCk7XG5cdFx0dGhpcy55ID0gTWF0aC5yb3VuZCh0aGlzLnkpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHJvdW5kVG9aZXJvKCkge1xuXHRcdHRoaXMueCA9IHRoaXMueCA8IDAgPyBNYXRoLmNlaWwodGhpcy54KSA6IE1hdGguZmxvb3IodGhpcy54KTtcblx0XHR0aGlzLnkgPSB0aGlzLnkgPCAwID8gTWF0aC5jZWlsKHRoaXMueSkgOiBNYXRoLmZsb29yKHRoaXMueSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0bmVnYXRlKCkge1xuXHRcdHRoaXMueCA9IC10aGlzLng7XG5cdFx0dGhpcy55ID0gLXRoaXMueTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRkb3Qodikge1xuXHRcdHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2Lnk7XG5cdH1cblx0Y3Jvc3Modikge1xuXHRcdHJldHVybiB0aGlzLnggKiB2LnkgLSB0aGlzLnkgKiB2Lng7XG5cdH1cblx0bGVuZ3RoU3EoKSB7XG5cdFx0cmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueTtcblx0fVxuXHRsZW5ndGgoKSB7XG5cdFx0cmV0dXJuIE1hdGguc3FydCh0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkpO1xuXHR9XG5cdG1hbmhhdHRhbkxlbmd0aCgpIHtcblx0XHRyZXR1cm4gTWF0aC5hYnModGhpcy54KSArIE1hdGguYWJzKHRoaXMueSk7XG5cdH1cblx0bm9ybWFsaXplKCkge1xuXHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhcih0aGlzLmxlbmd0aCgpIHx8IDEpO1xuXHR9XG5cdGFuZ2xlKCkge1xuXHRcdC8vIGNvbXB1dGVzIHRoZSBhbmdsZSBpbiByYWRpYW5zIHdpdGggcmVzcGVjdCB0byB0aGUgcG9zaXRpdmUgeC1heGlzXG5cblx0XHRjb25zdCBhbmdsZSA9IE1hdGguYXRhbjIoLXRoaXMueSwgLXRoaXMueCkgKyBNYXRoLlBJO1xuXHRcdHJldHVybiBhbmdsZTtcblx0fVxuXHRkaXN0YW5jZVRvKHYpIHtcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQodikpO1xuXHR9XG5cdGRpc3RhbmNlVG9TcXVhcmVkKHYpIHtcblx0XHRjb25zdCBkeCA9IHRoaXMueCAtIHYueCxcblx0XHRcdGR5ID0gdGhpcy55IC0gdi55O1xuXHRcdHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcblx0fVxuXHRtYW5oYXR0YW5EaXN0YW5jZVRvKHYpIHtcblx0XHRyZXR1cm4gTWF0aC5hYnModGhpcy54IC0gdi54KSArIE1hdGguYWJzKHRoaXMueSAtIHYueSk7XG5cdH1cblx0c2V0TGVuZ3RoKGxlbmd0aCkge1xuXHRcdHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKGxlbmd0aCk7XG5cdH1cblx0bGVycCh2LCBhbHBoYSkge1xuXHRcdHRoaXMueCArPSAodi54IC0gdGhpcy54KSAqIGFscGhhO1xuXHRcdHRoaXMueSArPSAodi55IC0gdGhpcy55KSAqIGFscGhhO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGxlcnBWZWN0b3JzKHYxLCB2MiwgYWxwaGEpIHtcblx0XHR0aGlzLnggPSB2MS54ICsgKHYyLnggLSB2MS54KSAqIGFscGhhO1xuXHRcdHRoaXMueSA9IHYxLnkgKyAodjIueSAtIHYxLnkpICogYWxwaGE7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0ZXF1YWxzKHYpIHtcblx0XHRyZXR1cm4gdi54ID09PSB0aGlzLnggJiYgdi55ID09PSB0aGlzLnk7XG5cdH1cblx0ZnJvbUFycmF5KGFycmF5LCBvZmZzZXQgPSAwKSB7XG5cdFx0dGhpcy54ID0gYXJyYXlbb2Zmc2V0XTtcblx0XHR0aGlzLnkgPSBhcnJheVtvZmZzZXQgKyAxXTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHR0b0FycmF5KGFycmF5ID0gW10sIG9mZnNldCA9IDApIHtcblx0XHRhcnJheVtvZmZzZXRdID0gdGhpcy54O1xuXHRcdGFycmF5W29mZnNldCArIDFdID0gdGhpcy55O1xuXHRcdHJldHVybiBhcnJheTtcblx0fVxuXHRmcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZSwgaW5kZXgpIHtcblx0XHR0aGlzLnggPSBhdHRyaWJ1dGUuZ2V0WChpbmRleCk7XG5cdFx0dGhpcy55ID0gYXR0cmlidXRlLmdldFkoaW5kZXgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHJvdGF0ZUFyb3VuZChjZW50ZXIsIGFuZ2xlKSB7XG5cdFx0Y29uc3QgYyA9IE1hdGguY29zKGFuZ2xlKSxcblx0XHRcdHMgPSBNYXRoLnNpbihhbmdsZSk7XG5cdFx0Y29uc3QgeCA9IHRoaXMueCAtIGNlbnRlci54O1xuXHRcdGNvbnN0IHkgPSB0aGlzLnkgLSBjZW50ZXIueTtcblx0XHR0aGlzLnggPSB4ICogYyAtIHkgKiBzICsgY2VudGVyLng7XG5cdFx0dGhpcy55ID0geCAqIHMgKyB5ICogYyArIGNlbnRlci55O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHJhbmRvbSgpIHtcblx0XHR0aGlzLnggPSBNYXRoLnJhbmRvbSgpO1xuXHRcdHRoaXMueSA9IE1hdGgucmFuZG9tKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0KltTeW1ib2wuaXRlcmF0b3JdKCkge1xuXHRcdHlpZWxkIHRoaXMueDtcblx0XHR5aWVsZCB0aGlzLnk7XG5cdH1cbn1cblxuY2xhc3MgTWF0cml4MyB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdE1hdHJpeDMucHJvdG90eXBlLmlzTWF0cml4MyA9IHRydWU7XG5cdFx0dGhpcy5lbGVtZW50cyA9IFsxLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAxXTtcblx0fVxuXHRzZXQobjExLCBuMTIsIG4xMywgbjIxLCBuMjIsIG4yMywgbjMxLCBuMzIsIG4zMykge1xuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHR0ZVswXSA9IG4xMTtcblx0XHR0ZVsxXSA9IG4yMTtcblx0XHR0ZVsyXSA9IG4zMTtcblx0XHR0ZVszXSA9IG4xMjtcblx0XHR0ZVs0XSA9IG4yMjtcblx0XHR0ZVs1XSA9IG4zMjtcblx0XHR0ZVs2XSA9IG4xMztcblx0XHR0ZVs3XSA9IG4yMztcblx0XHR0ZVs4XSA9IG4zMztcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRpZGVudGl0eSgpIHtcblx0XHR0aGlzLnNldCgxLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAxKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRjb3B5KG0pIHtcblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0Y29uc3QgbWUgPSBtLmVsZW1lbnRzO1xuXHRcdHRlWzBdID0gbWVbMF07XG5cdFx0dGVbMV0gPSBtZVsxXTtcblx0XHR0ZVsyXSA9IG1lWzJdO1xuXHRcdHRlWzNdID0gbWVbM107XG5cdFx0dGVbNF0gPSBtZVs0XTtcblx0XHR0ZVs1XSA9IG1lWzVdO1xuXHRcdHRlWzZdID0gbWVbNl07XG5cdFx0dGVbN10gPSBtZVs3XTtcblx0XHR0ZVs4XSA9IG1lWzhdO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGV4dHJhY3RCYXNpcyh4QXhpcywgeUF4aXMsIHpBeGlzKSB7XG5cdFx0eEF4aXMuc2V0RnJvbU1hdHJpeDNDb2x1bW4odGhpcywgMCk7XG5cdFx0eUF4aXMuc2V0RnJvbU1hdHJpeDNDb2x1bW4odGhpcywgMSk7XG5cdFx0ekF4aXMuc2V0RnJvbU1hdHJpeDNDb2x1bW4odGhpcywgMik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0c2V0RnJvbU1hdHJpeDQobSkge1xuXHRcdGNvbnN0IG1lID0gbS5lbGVtZW50cztcblx0XHR0aGlzLnNldChtZVswXSwgbWVbNF0sIG1lWzhdLCBtZVsxXSwgbWVbNV0sIG1lWzldLCBtZVsyXSwgbWVbNl0sIG1lWzEwXSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0bXVsdGlwbHkobSkge1xuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXModGhpcywgbSk7XG5cdH1cblx0cHJlbXVsdGlwbHkobSkge1xuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMobSwgdGhpcyk7XG5cdH1cblx0bXVsdGlwbHlNYXRyaWNlcyhhLCBiKSB7XG5cdFx0Y29uc3QgYWUgPSBhLmVsZW1lbnRzO1xuXHRcdGNvbnN0IGJlID0gYi5lbGVtZW50cztcblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0Y29uc3QgYTExID0gYWVbMF0sXG5cdFx0XHRhMTIgPSBhZVszXSxcblx0XHRcdGExMyA9IGFlWzZdO1xuXHRcdGNvbnN0IGEyMSA9IGFlWzFdLFxuXHRcdFx0YTIyID0gYWVbNF0sXG5cdFx0XHRhMjMgPSBhZVs3XTtcblx0XHRjb25zdCBhMzEgPSBhZVsyXSxcblx0XHRcdGEzMiA9IGFlWzVdLFxuXHRcdFx0YTMzID0gYWVbOF07XG5cdFx0Y29uc3QgYjExID0gYmVbMF0sXG5cdFx0XHRiMTIgPSBiZVszXSxcblx0XHRcdGIxMyA9IGJlWzZdO1xuXHRcdGNvbnN0IGIyMSA9IGJlWzFdLFxuXHRcdFx0YjIyID0gYmVbNF0sXG5cdFx0XHRiMjMgPSBiZVs3XTtcblx0XHRjb25zdCBiMzEgPSBiZVsyXSxcblx0XHRcdGIzMiA9IGJlWzVdLFxuXHRcdFx0YjMzID0gYmVbOF07XG5cdFx0dGVbMF0gPSBhMTEgKiBiMTEgKyBhMTIgKiBiMjEgKyBhMTMgKiBiMzE7XG5cdFx0dGVbM10gPSBhMTEgKiBiMTIgKyBhMTIgKiBiMjIgKyBhMTMgKiBiMzI7XG5cdFx0dGVbNl0gPSBhMTEgKiBiMTMgKyBhMTIgKiBiMjMgKyBhMTMgKiBiMzM7XG5cdFx0dGVbMV0gPSBhMjEgKiBiMTEgKyBhMjIgKiBiMjEgKyBhMjMgKiBiMzE7XG5cdFx0dGVbNF0gPSBhMjEgKiBiMTIgKyBhMjIgKiBiMjIgKyBhMjMgKiBiMzI7XG5cdFx0dGVbN10gPSBhMjEgKiBiMTMgKyBhMjIgKiBiMjMgKyBhMjMgKiBiMzM7XG5cdFx0dGVbMl0gPSBhMzEgKiBiMTEgKyBhMzIgKiBiMjEgKyBhMzMgKiBiMzE7XG5cdFx0dGVbNV0gPSBhMzEgKiBiMTIgKyBhMzIgKiBiMjIgKyBhMzMgKiBiMzI7XG5cdFx0dGVbOF0gPSBhMzEgKiBiMTMgKyBhMzIgKiBiMjMgKyBhMzMgKiBiMzM7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0bXVsdGlwbHlTY2FsYXIocykge1xuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHR0ZVswXSAqPSBzO1xuXHRcdHRlWzNdICo9IHM7XG5cdFx0dGVbNl0gKj0gcztcblx0XHR0ZVsxXSAqPSBzO1xuXHRcdHRlWzRdICo9IHM7XG5cdFx0dGVbN10gKj0gcztcblx0XHR0ZVsyXSAqPSBzO1xuXHRcdHRlWzVdICo9IHM7XG5cdFx0dGVbOF0gKj0gcztcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRkZXRlcm1pbmFudCgpIHtcblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0Y29uc3QgYSA9IHRlWzBdLFxuXHRcdFx0YiA9IHRlWzFdLFxuXHRcdFx0YyA9IHRlWzJdLFxuXHRcdFx0ZCA9IHRlWzNdLFxuXHRcdFx0ZSA9IHRlWzRdLFxuXHRcdFx0ZiA9IHRlWzVdLFxuXHRcdFx0ZyA9IHRlWzZdLFxuXHRcdFx0aCA9IHRlWzddLFxuXHRcdFx0aSA9IHRlWzhdO1xuXHRcdHJldHVybiBhICogZSAqIGkgLSBhICogZiAqIGggLSBiICogZCAqIGkgKyBiICogZiAqIGcgKyBjICogZCAqIGggLSBjICogZSAqIGc7XG5cdH1cblx0aW52ZXJ0KCkge1xuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cyxcblx0XHRcdG4xMSA9IHRlWzBdLFxuXHRcdFx0bjIxID0gdGVbMV0sXG5cdFx0XHRuMzEgPSB0ZVsyXSxcblx0XHRcdG4xMiA9IHRlWzNdLFxuXHRcdFx0bjIyID0gdGVbNF0sXG5cdFx0XHRuMzIgPSB0ZVs1XSxcblx0XHRcdG4xMyA9IHRlWzZdLFxuXHRcdFx0bjIzID0gdGVbN10sXG5cdFx0XHRuMzMgPSB0ZVs4XSxcblx0XHRcdHQxMSA9IG4zMyAqIG4yMiAtIG4zMiAqIG4yMyxcblx0XHRcdHQxMiA9IG4zMiAqIG4xMyAtIG4zMyAqIG4xMixcblx0XHRcdHQxMyA9IG4yMyAqIG4xMiAtIG4yMiAqIG4xMyxcblx0XHRcdGRldCA9IG4xMSAqIHQxMSArIG4yMSAqIHQxMiArIG4zMSAqIHQxMztcblx0XHRpZiAoZGV0ID09PSAwKSByZXR1cm4gdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG5cdFx0Y29uc3QgZGV0SW52ID0gMSAvIGRldDtcblx0XHR0ZVswXSA9IHQxMSAqIGRldEludjtcblx0XHR0ZVsxXSA9IChuMzEgKiBuMjMgLSBuMzMgKiBuMjEpICogZGV0SW52O1xuXHRcdHRlWzJdID0gKG4zMiAqIG4yMSAtIG4zMSAqIG4yMikgKiBkZXRJbnY7XG5cdFx0dGVbM10gPSB0MTIgKiBkZXRJbnY7XG5cdFx0dGVbNF0gPSAobjMzICogbjExIC0gbjMxICogbjEzKSAqIGRldEludjtcblx0XHR0ZVs1XSA9IChuMzEgKiBuMTIgLSBuMzIgKiBuMTEpICogZGV0SW52O1xuXHRcdHRlWzZdID0gdDEzICogZGV0SW52O1xuXHRcdHRlWzddID0gKG4yMSAqIG4xMyAtIG4yMyAqIG4xMSkgKiBkZXRJbnY7XG5cdFx0dGVbOF0gPSAobjIyICogbjExIC0gbjIxICogbjEyKSAqIGRldEludjtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHR0cmFuc3Bvc2UoKSB7XG5cdFx0bGV0IHRtcDtcblx0XHRjb25zdCBtID0gdGhpcy5lbGVtZW50cztcblx0XHR0bXAgPSBtWzFdO1xuXHRcdG1bMV0gPSBtWzNdO1xuXHRcdG1bM10gPSB0bXA7XG5cdFx0dG1wID0gbVsyXTtcblx0XHRtWzJdID0gbVs2XTtcblx0XHRtWzZdID0gdG1wO1xuXHRcdHRtcCA9IG1bNV07XG5cdFx0bVs1XSA9IG1bN107XG5cdFx0bVs3XSA9IHRtcDtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRnZXROb3JtYWxNYXRyaXgobWF0cml4NCkge1xuXHRcdHJldHVybiB0aGlzLnNldEZyb21NYXRyaXg0KG1hdHJpeDQpLmludmVydCgpLnRyYW5zcG9zZSgpO1xuXHR9XG5cdHRyYW5zcG9zZUludG9BcnJheShyKSB7XG5cdFx0Y29uc3QgbSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0clswXSA9IG1bMF07XG5cdFx0clsxXSA9IG1bM107XG5cdFx0clsyXSA9IG1bNl07XG5cdFx0clszXSA9IG1bMV07XG5cdFx0cls0XSA9IG1bNF07XG5cdFx0cls1XSA9IG1bN107XG5cdFx0cls2XSA9IG1bMl07XG5cdFx0cls3XSA9IG1bNV07XG5cdFx0cls4XSA9IG1bOF07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0c2V0VXZUcmFuc2Zvcm0odHgsIHR5LCBzeCwgc3ksIHJvdGF0aW9uLCBjeCwgY3kpIHtcblx0XHRjb25zdCBjID0gTWF0aC5jb3Mocm90YXRpb24pO1xuXHRcdGNvbnN0IHMgPSBNYXRoLnNpbihyb3RhdGlvbik7XG5cdFx0dGhpcy5zZXQoc3ggKiBjLCBzeCAqIHMsIC1zeCAqIChjICogY3ggKyBzICogY3kpICsgY3ggKyB0eCwgLXN5ICogcywgc3kgKiBjLCAtc3kgKiAoLXMgKiBjeCArIGMgKiBjeSkgKyBjeSArIHR5LCAwLCAwLCAxKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRzY2FsZShzeCwgc3kpIHtcblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0dGVbMF0gKj0gc3g7XG5cdFx0dGVbM10gKj0gc3g7XG5cdFx0dGVbNl0gKj0gc3g7XG5cdFx0dGVbMV0gKj0gc3k7XG5cdFx0dGVbNF0gKj0gc3k7XG5cdFx0dGVbN10gKj0gc3k7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0cm90YXRlKHRoZXRhKSB7XG5cdFx0Y29uc3QgYyA9IE1hdGguY29zKHRoZXRhKTtcblx0XHRjb25zdCBzID0gTWF0aC5zaW4odGhldGEpO1xuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRjb25zdCBhMTEgPSB0ZVswXSxcblx0XHRcdGExMiA9IHRlWzNdLFxuXHRcdFx0YTEzID0gdGVbNl07XG5cdFx0Y29uc3QgYTIxID0gdGVbMV0sXG5cdFx0XHRhMjIgPSB0ZVs0XSxcblx0XHRcdGEyMyA9IHRlWzddO1xuXHRcdHRlWzBdID0gYyAqIGExMSArIHMgKiBhMjE7XG5cdFx0dGVbM10gPSBjICogYTEyICsgcyAqIGEyMjtcblx0XHR0ZVs2XSA9IGMgKiBhMTMgKyBzICogYTIzO1xuXHRcdHRlWzFdID0gLXMgKiBhMTEgKyBjICogYTIxO1xuXHRcdHRlWzRdID0gLXMgKiBhMTIgKyBjICogYTIyO1xuXHRcdHRlWzddID0gLXMgKiBhMTMgKyBjICogYTIzO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHRyYW5zbGF0ZSh0eCwgdHkpIHtcblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0dGVbMF0gKz0gdHggKiB0ZVsyXTtcblx0XHR0ZVszXSArPSB0eCAqIHRlWzVdO1xuXHRcdHRlWzZdICs9IHR4ICogdGVbOF07XG5cdFx0dGVbMV0gKz0gdHkgKiB0ZVsyXTtcblx0XHR0ZVs0XSArPSB0eSAqIHRlWzVdO1xuXHRcdHRlWzddICs9IHR5ICogdGVbOF07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0ZXF1YWxzKG1hdHJpeCkge1xuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRjb25zdCBtZSA9IG1hdHJpeC5lbGVtZW50cztcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDk7IGkrKykge1xuXHRcdFx0aWYgKHRlW2ldICE9PSBtZVtpXSkgcmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRmcm9tQXJyYXkoYXJyYXksIG9mZnNldCA9IDApIHtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDk7IGkrKykge1xuXHRcdFx0dGhpcy5lbGVtZW50c1tpXSA9IGFycmF5W2kgKyBvZmZzZXRdO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHR0b0FycmF5KGFycmF5ID0gW10sIG9mZnNldCA9IDApIHtcblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0YXJyYXlbb2Zmc2V0XSA9IHRlWzBdO1xuXHRcdGFycmF5W29mZnNldCArIDFdID0gdGVbMV07XG5cdFx0YXJyYXlbb2Zmc2V0ICsgMl0gPSB0ZVsyXTtcblx0XHRhcnJheVtvZmZzZXQgKyAzXSA9IHRlWzNdO1xuXHRcdGFycmF5W29mZnNldCArIDRdID0gdGVbNF07XG5cdFx0YXJyYXlbb2Zmc2V0ICsgNV0gPSB0ZVs1XTtcblx0XHRhcnJheVtvZmZzZXQgKyA2XSA9IHRlWzZdO1xuXHRcdGFycmF5W29mZnNldCArIDddID0gdGVbN107XG5cdFx0YXJyYXlbb2Zmc2V0ICsgOF0gPSB0ZVs4XTtcblx0XHRyZXR1cm4gYXJyYXk7XG5cdH1cblx0Y2xvbmUoKSB7XG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuZnJvbUFycmF5KHRoaXMuZWxlbWVudHMpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGFycmF5TmVlZHNVaW50MzIoYXJyYXkpIHtcblx0Ly8gYXNzdW1lcyBsYXJnZXIgdmFsdWVzIHVzdWFsbHkgb24gbGFzdFxuXG5cdGZvciAobGV0IGkgPSBhcnJheS5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuXHRcdGlmIChhcnJheVtpXSA+PSA2NTUzNSkgcmV0dXJuIHRydWU7IC8vIGFjY291bnQgZm9yIFBSSU1JVElWRV9SRVNUQVJUX0ZJWEVEX0lOREVYLCAjMjQ1NjVcblx0fVxuXG5cdHJldHVybiBmYWxzZTtcbn1cbmNvbnN0IFRZUEVEX0FSUkFZUyA9IHtcblx0SW50OEFycmF5OiBJbnQ4QXJyYXksXG5cdFVpbnQ4QXJyYXk6IFVpbnQ4QXJyYXksXG5cdFVpbnQ4Q2xhbXBlZEFycmF5OiBVaW50OENsYW1wZWRBcnJheSxcblx0SW50MTZBcnJheTogSW50MTZBcnJheSxcblx0VWludDE2QXJyYXk6IFVpbnQxNkFycmF5LFxuXHRJbnQzMkFycmF5OiBJbnQzMkFycmF5LFxuXHRVaW50MzJBcnJheTogVWludDMyQXJyYXksXG5cdEZsb2F0MzJBcnJheTogRmxvYXQzMkFycmF5LFxuXHRGbG9hdDY0QXJyYXk6IEZsb2F0NjRBcnJheVxufTtcbmZ1bmN0aW9uIGdldFR5cGVkQXJyYXkodHlwZSwgYnVmZmVyKSB7XG5cdHJldHVybiBuZXcgVFlQRURfQVJSQVlTW3R5cGVdKGJ1ZmZlcik7XG59XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMobmFtZSkge1xuXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJywgbmFtZSk7XG59XG5cbmZ1bmN0aW9uIFNSR0JUb0xpbmVhcihjKSB7XG5cdHJldHVybiBjIDwgMC4wNDA0NSA/IGMgKiAwLjA3NzM5OTM4MDggOiBNYXRoLnBvdyhjICogMC45NDc4NjcyOTg2ICsgMC4wNTIxMzI3MDE0LCAyLjQpO1xufVxuZnVuY3Rpb24gTGluZWFyVG9TUkdCKGMpIHtcblx0cmV0dXJuIGMgPCAwLjAwMzEzMDggPyBjICogMTIuOTIgOiAxLjA1NSAqIE1hdGgucG93KGMsIDAuNDE2NjYpIC0gMC4wNTU7XG59XG5cbi8vIEphdmFTY3JpcHQgUkdCLXRvLVJHQiB0cmFuc2Zvcm1zLCBkZWZpbmVkIGFzXG4vLyBGTltJbnB1dENvbG9yU3BhY2VdW091dHB1dENvbG9yU3BhY2VdIGNhbGxiYWNrIGZ1bmN0aW9ucy5cbmNvbnN0IEZOID0ge1xuXHRbU1JHQkNvbG9yU3BhY2VdOiB7XG5cdFx0W0xpbmVhclNSR0JDb2xvclNwYWNlXTogU1JHQlRvTGluZWFyXG5cdH0sXG5cdFtMaW5lYXJTUkdCQ29sb3JTcGFjZV06IHtcblx0XHRbU1JHQkNvbG9yU3BhY2VdOiBMaW5lYXJUb1NSR0Jcblx0fVxufTtcbmNvbnN0IENvbG9yTWFuYWdlbWVudCA9IHtcblx0bGVnYWN5TW9kZTogdHJ1ZSxcblx0Z2V0IHdvcmtpbmdDb2xvclNwYWNlKCkge1xuXHRcdHJldHVybiBMaW5lYXJTUkdCQ29sb3JTcGFjZTtcblx0fSxcblx0c2V0IHdvcmtpbmdDb2xvclNwYWNlKGNvbG9yU3BhY2UpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkNvbG9yTWFuYWdlbWVudDogLndvcmtpbmdDb2xvclNwYWNlIGlzIHJlYWRvbmx5LicpO1xuXHR9LFxuXHRjb252ZXJ0OiBmdW5jdGlvbiAoY29sb3IsIHNvdXJjZUNvbG9yU3BhY2UsIHRhcmdldENvbG9yU3BhY2UpIHtcblx0XHRpZiAodGhpcy5sZWdhY3lNb2RlIHx8IHNvdXJjZUNvbG9yU3BhY2UgPT09IHRhcmdldENvbG9yU3BhY2UgfHwgIXNvdXJjZUNvbG9yU3BhY2UgfHwgIXRhcmdldENvbG9yU3BhY2UpIHtcblx0XHRcdHJldHVybiBjb2xvcjtcblx0XHR9XG5cdFx0aWYgKEZOW3NvdXJjZUNvbG9yU3BhY2VdICYmIEZOW3NvdXJjZUNvbG9yU3BhY2VdW3RhcmdldENvbG9yU3BhY2VdICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGNvbnN0IGZuID0gRk5bc291cmNlQ29sb3JTcGFjZV1bdGFyZ2V0Q29sb3JTcGFjZV07XG5cdFx0XHRjb2xvci5yID0gZm4oY29sb3Iucik7XG5cdFx0XHRjb2xvci5nID0gZm4oY29sb3IuZyk7XG5cdFx0XHRjb2xvci5iID0gZm4oY29sb3IuYik7XG5cdFx0XHRyZXR1cm4gY29sb3I7XG5cdFx0fVxuXHRcdHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgY29sb3Igc3BhY2UgY29udmVyc2lvbi4nKTtcblx0fSxcblx0ZnJvbVdvcmtpbmdDb2xvclNwYWNlOiBmdW5jdGlvbiAoY29sb3IsIHRhcmdldENvbG9yU3BhY2UpIHtcblx0XHRyZXR1cm4gdGhpcy5jb252ZXJ0KGNvbG9yLCB0aGlzLndvcmtpbmdDb2xvclNwYWNlLCB0YXJnZXRDb2xvclNwYWNlKTtcblx0fSxcblx0dG9Xb3JraW5nQ29sb3JTcGFjZTogZnVuY3Rpb24gKGNvbG9yLCBzb3VyY2VDb2xvclNwYWNlKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29udmVydChjb2xvciwgc291cmNlQ29sb3JTcGFjZSwgdGhpcy53b3JraW5nQ29sb3JTcGFjZSk7XG5cdH1cbn07XG5cbmNvbnN0IF9jb2xvcktleXdvcmRzID0ge1xuXHQnYWxpY2VibHVlJzogMHhGMEY4RkYsXG5cdCdhbnRpcXVld2hpdGUnOiAweEZBRUJENyxcblx0J2FxdWEnOiAweDAwRkZGRixcblx0J2FxdWFtYXJpbmUnOiAweDdGRkZENCxcblx0J2F6dXJlJzogMHhGMEZGRkYsXG5cdCdiZWlnZSc6IDB4RjVGNURDLFxuXHQnYmlzcXVlJzogMHhGRkU0QzQsXG5cdCdibGFjayc6IDB4MDAwMDAwLFxuXHQnYmxhbmNoZWRhbG1vbmQnOiAweEZGRUJDRCxcblx0J2JsdWUnOiAweDAwMDBGRixcblx0J2JsdWV2aW9sZXQnOiAweDhBMkJFMixcblx0J2Jyb3duJzogMHhBNTJBMkEsXG5cdCdidXJseXdvb2QnOiAweERFQjg4Nyxcblx0J2NhZGV0Ymx1ZSc6IDB4NUY5RUEwLFxuXHQnY2hhcnRyZXVzZSc6IDB4N0ZGRjAwLFxuXHQnY2hvY29sYXRlJzogMHhEMjY5MUUsXG5cdCdjb3JhbCc6IDB4RkY3RjUwLFxuXHQnY29ybmZsb3dlcmJsdWUnOiAweDY0OTVFRCxcblx0J2Nvcm5zaWxrJzogMHhGRkY4REMsXG5cdCdjcmltc29uJzogMHhEQzE0M0MsXG5cdCdjeWFuJzogMHgwMEZGRkYsXG5cdCdkYXJrYmx1ZSc6IDB4MDAwMDhCLFxuXHQnZGFya2N5YW4nOiAweDAwOEI4Qixcblx0J2Rhcmtnb2xkZW5yb2QnOiAweEI4ODYwQixcblx0J2RhcmtncmF5JzogMHhBOUE5QTksXG5cdCdkYXJrZ3JlZW4nOiAweDAwNjQwMCxcblx0J2RhcmtncmV5JzogMHhBOUE5QTksXG5cdCdkYXJra2hha2knOiAweEJEQjc2Qixcblx0J2RhcmttYWdlbnRhJzogMHg4QjAwOEIsXG5cdCdkYXJrb2xpdmVncmVlbic6IDB4NTU2QjJGLFxuXHQnZGFya29yYW5nZSc6IDB4RkY4QzAwLFxuXHQnZGFya29yY2hpZCc6IDB4OTkzMkNDLFxuXHQnZGFya3JlZCc6IDB4OEIwMDAwLFxuXHQnZGFya3NhbG1vbic6IDB4RTk5NjdBLFxuXHQnZGFya3NlYWdyZWVuJzogMHg4RkJDOEYsXG5cdCdkYXJrc2xhdGVibHVlJzogMHg0ODNEOEIsXG5cdCdkYXJrc2xhdGVncmF5JzogMHgyRjRGNEYsXG5cdCdkYXJrc2xhdGVncmV5JzogMHgyRjRGNEYsXG5cdCdkYXJrdHVycXVvaXNlJzogMHgwMENFRDEsXG5cdCdkYXJrdmlvbGV0JzogMHg5NDAwRDMsXG5cdCdkZWVwcGluayc6IDB4RkYxNDkzLFxuXHQnZGVlcHNreWJsdWUnOiAweDAwQkZGRixcblx0J2RpbWdyYXknOiAweDY5Njk2OSxcblx0J2RpbWdyZXknOiAweDY5Njk2OSxcblx0J2RvZGdlcmJsdWUnOiAweDFFOTBGRixcblx0J2ZpcmVicmljayc6IDB4QjIyMjIyLFxuXHQnZmxvcmFsd2hpdGUnOiAweEZGRkFGMCxcblx0J2ZvcmVzdGdyZWVuJzogMHgyMjhCMjIsXG5cdCdmdWNoc2lhJzogMHhGRjAwRkYsXG5cdCdnYWluc2Jvcm8nOiAweERDRENEQyxcblx0J2dob3N0d2hpdGUnOiAweEY4RjhGRixcblx0J2dvbGQnOiAweEZGRDcwMCxcblx0J2dvbGRlbnJvZCc6IDB4REFBNTIwLFxuXHQnZ3JheSc6IDB4ODA4MDgwLFxuXHQnZ3JlZW4nOiAweDAwODAwMCxcblx0J2dyZWVueWVsbG93JzogMHhBREZGMkYsXG5cdCdncmV5JzogMHg4MDgwODAsXG5cdCdob25leWRldyc6IDB4RjBGRkYwLFxuXHQnaG90cGluayc6IDB4RkY2OUI0LFxuXHQnaW5kaWFucmVkJzogMHhDRDVDNUMsXG5cdCdpbmRpZ28nOiAweDRCMDA4Mixcblx0J2l2b3J5JzogMHhGRkZGRjAsXG5cdCdraGFraSc6IDB4RjBFNjhDLFxuXHQnbGF2ZW5kZXInOiAweEU2RTZGQSxcblx0J2xhdmVuZGVyYmx1c2gnOiAweEZGRjBGNSxcblx0J2xhd25ncmVlbic6IDB4N0NGQzAwLFxuXHQnbGVtb25jaGlmZm9uJzogMHhGRkZBQ0QsXG5cdCdsaWdodGJsdWUnOiAweEFERDhFNixcblx0J2xpZ2h0Y29yYWwnOiAweEYwODA4MCxcblx0J2xpZ2h0Y3lhbic6IDB4RTBGRkZGLFxuXHQnbGlnaHRnb2xkZW5yb2R5ZWxsb3cnOiAweEZBRkFEMixcblx0J2xpZ2h0Z3JheSc6IDB4RDNEM0QzLFxuXHQnbGlnaHRncmVlbic6IDB4OTBFRTkwLFxuXHQnbGlnaHRncmV5JzogMHhEM0QzRDMsXG5cdCdsaWdodHBpbmsnOiAweEZGQjZDMSxcblx0J2xpZ2h0c2FsbW9uJzogMHhGRkEwN0EsXG5cdCdsaWdodHNlYWdyZWVuJzogMHgyMEIyQUEsXG5cdCdsaWdodHNreWJsdWUnOiAweDg3Q0VGQSxcblx0J2xpZ2h0c2xhdGVncmF5JzogMHg3Nzg4OTksXG5cdCdsaWdodHNsYXRlZ3JleSc6IDB4Nzc4ODk5LFxuXHQnbGlnaHRzdGVlbGJsdWUnOiAweEIwQzRERSxcblx0J2xpZ2h0eWVsbG93JzogMHhGRkZGRTAsXG5cdCdsaW1lJzogMHgwMEZGMDAsXG5cdCdsaW1lZ3JlZW4nOiAweDMyQ0QzMixcblx0J2xpbmVuJzogMHhGQUYwRTYsXG5cdCdtYWdlbnRhJzogMHhGRjAwRkYsXG5cdCdtYXJvb24nOiAweDgwMDAwMCxcblx0J21lZGl1bWFxdWFtYXJpbmUnOiAweDY2Q0RBQSxcblx0J21lZGl1bWJsdWUnOiAweDAwMDBDRCxcblx0J21lZGl1bW9yY2hpZCc6IDB4QkE1NUQzLFxuXHQnbWVkaXVtcHVycGxlJzogMHg5MzcwREIsXG5cdCdtZWRpdW1zZWFncmVlbic6IDB4M0NCMzcxLFxuXHQnbWVkaXVtc2xhdGVibHVlJzogMHg3QjY4RUUsXG5cdCdtZWRpdW1zcHJpbmdncmVlbic6IDB4MDBGQTlBLFxuXHQnbWVkaXVtdHVycXVvaXNlJzogMHg0OEQxQ0MsXG5cdCdtZWRpdW12aW9sZXRyZWQnOiAweEM3MTU4NSxcblx0J21pZG5pZ2h0Ymx1ZSc6IDB4MTkxOTcwLFxuXHQnbWludGNyZWFtJzogMHhGNUZGRkEsXG5cdCdtaXN0eXJvc2UnOiAweEZGRTRFMSxcblx0J21vY2Nhc2luJzogMHhGRkU0QjUsXG5cdCduYXZham93aGl0ZSc6IDB4RkZERUFELFxuXHQnbmF2eSc6IDB4MDAwMDgwLFxuXHQnb2xkbGFjZSc6IDB4RkRGNUU2LFxuXHQnb2xpdmUnOiAweDgwODAwMCxcblx0J29saXZlZHJhYic6IDB4NkI4RTIzLFxuXHQnb3JhbmdlJzogMHhGRkE1MDAsXG5cdCdvcmFuZ2VyZWQnOiAweEZGNDUwMCxcblx0J29yY2hpZCc6IDB4REE3MEQ2LFxuXHQncGFsZWdvbGRlbnJvZCc6IDB4RUVFOEFBLFxuXHQncGFsZWdyZWVuJzogMHg5OEZCOTgsXG5cdCdwYWxldHVycXVvaXNlJzogMHhBRkVFRUUsXG5cdCdwYWxldmlvbGV0cmVkJzogMHhEQjcwOTMsXG5cdCdwYXBheWF3aGlwJzogMHhGRkVGRDUsXG5cdCdwZWFjaHB1ZmYnOiAweEZGREFCOSxcblx0J3BlcnUnOiAweENEODUzRixcblx0J3BpbmsnOiAweEZGQzBDQixcblx0J3BsdW0nOiAweEREQTBERCxcblx0J3Bvd2RlcmJsdWUnOiAweEIwRTBFNixcblx0J3B1cnBsZSc6IDB4ODAwMDgwLFxuXHQncmViZWNjYXB1cnBsZSc6IDB4NjYzMzk5LFxuXHQncmVkJzogMHhGRjAwMDAsXG5cdCdyb3N5YnJvd24nOiAweEJDOEY4Rixcblx0J3JveWFsYmx1ZSc6IDB4NDE2OUUxLFxuXHQnc2FkZGxlYnJvd24nOiAweDhCNDUxMyxcblx0J3NhbG1vbic6IDB4RkE4MDcyLFxuXHQnc2FuZHlicm93bic6IDB4RjRBNDYwLFxuXHQnc2VhZ3JlZW4nOiAweDJFOEI1Nyxcblx0J3NlYXNoZWxsJzogMHhGRkY1RUUsXG5cdCdzaWVubmEnOiAweEEwNTIyRCxcblx0J3NpbHZlcic6IDB4QzBDMEMwLFxuXHQnc2t5Ymx1ZSc6IDB4ODdDRUVCLFxuXHQnc2xhdGVibHVlJzogMHg2QTVBQ0QsXG5cdCdzbGF0ZWdyYXknOiAweDcwODA5MCxcblx0J3NsYXRlZ3JleSc6IDB4NzA4MDkwLFxuXHQnc25vdyc6IDB4RkZGQUZBLFxuXHQnc3ByaW5nZ3JlZW4nOiAweDAwRkY3Rixcblx0J3N0ZWVsYmx1ZSc6IDB4NDY4MkI0LFxuXHQndGFuJzogMHhEMkI0OEMsXG5cdCd0ZWFsJzogMHgwMDgwODAsXG5cdCd0aGlzdGxlJzogMHhEOEJGRDgsXG5cdCd0b21hdG8nOiAweEZGNjM0Nyxcblx0J3R1cnF1b2lzZSc6IDB4NDBFMEQwLFxuXHQndmlvbGV0JzogMHhFRTgyRUUsXG5cdCd3aGVhdCc6IDB4RjVERUIzLFxuXHQnd2hpdGUnOiAweEZGRkZGRixcblx0J3doaXRlc21va2UnOiAweEY1RjVGNSxcblx0J3llbGxvdyc6IDB4RkZGRjAwLFxuXHQneWVsbG93Z3JlZW4nOiAweDlBQ0QzMlxufTtcbmNvbnN0IF9yZ2IgPSB7XG5cdHI6IDAsXG5cdGc6IDAsXG5cdGI6IDBcbn07XG5jb25zdCBfaHNsQSA9IHtcblx0aDogMCxcblx0czogMCxcblx0bDogMFxufTtcbmNvbnN0IF9oc2xCID0ge1xuXHRoOiAwLFxuXHRzOiAwLFxuXHRsOiAwXG59O1xuZnVuY3Rpb24gaHVlMnJnYihwLCBxLCB0KSB7XG5cdGlmICh0IDwgMCkgdCArPSAxO1xuXHRpZiAodCA+IDEpIHQgLT0gMTtcblx0aWYgKHQgPCAxIC8gNikgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XG5cdGlmICh0IDwgMSAvIDIpIHJldHVybiBxO1xuXHRpZiAodCA8IDIgLyAzKSByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogKDIgLyAzIC0gdCk7XG5cdHJldHVybiBwO1xufVxuZnVuY3Rpb24gdG9Db21wb25lbnRzKHNvdXJjZSwgdGFyZ2V0KSB7XG5cdHRhcmdldC5yID0gc291cmNlLnI7XG5cdHRhcmdldC5nID0gc291cmNlLmc7XG5cdHRhcmdldC5iID0gc291cmNlLmI7XG5cdHJldHVybiB0YXJnZXQ7XG59XG5jbGFzcyBDb2xvciB7XG5cdGNvbnN0cnVjdG9yKHIsIGcsIGIpIHtcblx0XHR0aGlzLmlzQ29sb3IgPSB0cnVlO1xuXHRcdHRoaXMuciA9IDE7XG5cdFx0dGhpcy5nID0gMTtcblx0XHR0aGlzLmIgPSAxO1xuXHRcdGlmIChnID09PSB1bmRlZmluZWQgJiYgYiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHQvLyByIGlzIFRIUkVFLkNvbG9yLCBoZXggb3Igc3RyaW5nXG5cdFx0XHRyZXR1cm4gdGhpcy5zZXQocik7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLnNldFJHQihyLCBnLCBiKTtcblx0fVxuXHRzZXQodmFsdWUpIHtcblx0XHRpZiAodmFsdWUgJiYgdmFsdWUuaXNDb2xvcikge1xuXHRcdFx0dGhpcy5jb3B5KHZhbHVlKTtcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdHRoaXMuc2V0SGV4KHZhbHVlKTtcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHRoaXMuc2V0U3R5bGUodmFsdWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRzZXRTY2FsYXIoc2NhbGFyKSB7XG5cdFx0dGhpcy5yID0gc2NhbGFyO1xuXHRcdHRoaXMuZyA9IHNjYWxhcjtcblx0XHR0aGlzLmIgPSBzY2FsYXI7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0c2V0SGV4KGhleCwgY29sb3JTcGFjZSA9IFNSR0JDb2xvclNwYWNlKSB7XG5cdFx0aGV4ID0gTWF0aC5mbG9vcihoZXgpO1xuXHRcdHRoaXMuciA9IChoZXggPj4gMTYgJiAyNTUpIC8gMjU1O1xuXHRcdHRoaXMuZyA9IChoZXggPj4gOCAmIDI1NSkgLyAyNTU7XG5cdFx0dGhpcy5iID0gKGhleCAmIDI1NSkgLyAyNTU7XG5cdFx0Q29sb3JNYW5hZ2VtZW50LnRvV29ya2luZ0NvbG9yU3BhY2UodGhpcywgY29sb3JTcGFjZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0c2V0UkdCKHIsIGcsIGIsIGNvbG9yU3BhY2UgPSBMaW5lYXJTUkdCQ29sb3JTcGFjZSkge1xuXHRcdHRoaXMuciA9IHI7XG5cdFx0dGhpcy5nID0gZztcblx0XHR0aGlzLmIgPSBiO1xuXHRcdENvbG9yTWFuYWdlbWVudC50b1dvcmtpbmdDb2xvclNwYWNlKHRoaXMsIGNvbG9yU3BhY2UpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHNldEhTTChoLCBzLCBsLCBjb2xvclNwYWNlID0gTGluZWFyU1JHQkNvbG9yU3BhY2UpIHtcblx0XHQvLyBoLHMsbCByYW5nZXMgYXJlIGluIDAuMCAtIDEuMFxuXHRcdGggPSBldWNsaWRlYW5Nb2R1bG8oaCwgMSk7XG5cdFx0cyA9IGNsYW1wKHMsIDAsIDEpO1xuXHRcdGwgPSBjbGFtcChsLCAwLCAxKTtcblx0XHRpZiAocyA9PT0gMCkge1xuXHRcdFx0dGhpcy5yID0gdGhpcy5nID0gdGhpcy5iID0gbDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3QgcCA9IGwgPD0gMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzO1xuXHRcdFx0Y29uc3QgcSA9IDIgKiBsIC0gcDtcblx0XHRcdHRoaXMuciA9IGh1ZTJyZ2IocSwgcCwgaCArIDEgLyAzKTtcblx0XHRcdHRoaXMuZyA9IGh1ZTJyZ2IocSwgcCwgaCk7XG5cdFx0XHR0aGlzLmIgPSBodWUycmdiKHEsIHAsIGggLSAxIC8gMyk7XG5cdFx0fVxuXHRcdENvbG9yTWFuYWdlbWVudC50b1dvcmtpbmdDb2xvclNwYWNlKHRoaXMsIGNvbG9yU3BhY2UpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHNldFN0eWxlKHN0eWxlLCBjb2xvclNwYWNlID0gU1JHQkNvbG9yU3BhY2UpIHtcblx0XHRmdW5jdGlvbiBoYW5kbGVBbHBoYShzdHJpbmcpIHtcblx0XHRcdGlmIChzdHJpbmcgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXHRcdFx0aWYgKHBhcnNlRmxvYXQoc3RyaW5nKSA8IDEpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5Db2xvcjogQWxwaGEgY29tcG9uZW50IG9mICcgKyBzdHlsZSArICcgd2lsbCBiZSBpZ25vcmVkLicpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRsZXQgbTtcblx0XHRpZiAobSA9IC9eKCg/OnJnYnxoc2wpYT8pXFwoKFteXFwpXSopXFwpLy5leGVjKHN0eWxlKSkge1xuXHRcdFx0Ly8gcmdiIC8gaHNsXG5cblx0XHRcdGxldCBjb2xvcjtcblx0XHRcdGNvbnN0IG5hbWUgPSBtWzFdO1xuXHRcdFx0Y29uc3QgY29tcG9uZW50cyA9IG1bMl07XG5cdFx0XHRzd2l0Y2ggKG5hbWUpIHtcblx0XHRcdFx0Y2FzZSAncmdiJzpcblx0XHRcdFx0Y2FzZSAncmdiYSc6XG5cdFx0XHRcdFx0aWYgKGNvbG9yID0gL15cXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKig/OixcXHMqKFxcZCpcXC4/XFxkKylcXHMqKT8kLy5leGVjKGNvbXBvbmVudHMpKSB7XG5cdFx0XHRcdFx0XHQvLyByZ2IoMjU1LDAsMCkgcmdiYSgyNTUsMCwwLDAuNSlcblx0XHRcdFx0XHRcdHRoaXMuciA9IE1hdGgubWluKDI1NSwgcGFyc2VJbnQoY29sb3JbMV0sIDEwKSkgLyAyNTU7XG5cdFx0XHRcdFx0XHR0aGlzLmcgPSBNYXRoLm1pbigyNTUsIHBhcnNlSW50KGNvbG9yWzJdLCAxMCkpIC8gMjU1O1xuXHRcdFx0XHRcdFx0dGhpcy5iID0gTWF0aC5taW4oMjU1LCBwYXJzZUludChjb2xvclszXSwgMTApKSAvIDI1NTtcblx0XHRcdFx0XHRcdENvbG9yTWFuYWdlbWVudC50b1dvcmtpbmdDb2xvclNwYWNlKHRoaXMsIGNvbG9yU3BhY2UpO1xuXHRcdFx0XHRcdFx0aGFuZGxlQWxwaGEoY29sb3JbNF0pO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChjb2xvciA9IC9eXFxzKihcXGQrKVxcJVxccyosXFxzKihcXGQrKVxcJVxccyosXFxzKihcXGQrKVxcJVxccyooPzosXFxzKihcXGQqXFwuP1xcZCspXFxzKik/JC8uZXhlYyhjb21wb25lbnRzKSkge1xuXHRcdFx0XHRcdFx0Ly8gcmdiKDEwMCUsMCUsMCUpIHJnYmEoMTAwJSwwJSwwJSwwLjUpXG5cdFx0XHRcdFx0XHR0aGlzLnIgPSBNYXRoLm1pbigxMDAsIHBhcnNlSW50KGNvbG9yWzFdLCAxMCkpIC8gMTAwO1xuXHRcdFx0XHRcdFx0dGhpcy5nID0gTWF0aC5taW4oMTAwLCBwYXJzZUludChjb2xvclsyXSwgMTApKSAvIDEwMDtcblx0XHRcdFx0XHRcdHRoaXMuYiA9IE1hdGgubWluKDEwMCwgcGFyc2VJbnQoY29sb3JbM10sIDEwKSkgLyAxMDA7XG5cdFx0XHRcdFx0XHRDb2xvck1hbmFnZW1lbnQudG9Xb3JraW5nQ29sb3JTcGFjZSh0aGlzLCBjb2xvclNwYWNlKTtcblx0XHRcdFx0XHRcdGhhbmRsZUFscGhhKGNvbG9yWzRdKTtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnaHNsJzpcblx0XHRcdFx0Y2FzZSAnaHNsYSc6XG5cdFx0XHRcdFx0aWYgKGNvbG9yID0gL15cXHMqKFxcZCpcXC4/XFxkKylcXHMqLFxccyooXFxkKlxcLj9cXGQrKVxcJVxccyosXFxzKihcXGQqXFwuP1xcZCspXFwlXFxzKig/OixcXHMqKFxcZCpcXC4/XFxkKylcXHMqKT8kLy5leGVjKGNvbXBvbmVudHMpKSB7XG5cdFx0XHRcdFx0XHQvLyBoc2woMTIwLDUwJSw1MCUpIGhzbGEoMTIwLDUwJSw1MCUsMC41KVxuXHRcdFx0XHRcdFx0Y29uc3QgaCA9IHBhcnNlRmxvYXQoY29sb3JbMV0pIC8gMzYwO1xuXHRcdFx0XHRcdFx0Y29uc3QgcyA9IHBhcnNlRmxvYXQoY29sb3JbMl0pIC8gMTAwO1xuXHRcdFx0XHRcdFx0Y29uc3QgbCA9IHBhcnNlRmxvYXQoY29sb3JbM10pIC8gMTAwO1xuXHRcdFx0XHRcdFx0aGFuZGxlQWxwaGEoY29sb3JbNF0pO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0SFNMKGgsIHMsIGwsIGNvbG9yU3BhY2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKG0gPSAvXlxcIyhbQS1GYS1mXFxkXSspJC8uZXhlYyhzdHlsZSkpIHtcblx0XHRcdC8vIGhleCBjb2xvclxuXG5cdFx0XHRjb25zdCBoZXggPSBtWzFdO1xuXHRcdFx0Y29uc3Qgc2l6ZSA9IGhleC5sZW5ndGg7XG5cdFx0XHRpZiAoc2l6ZSA9PT0gMykge1xuXHRcdFx0XHQvLyAjZmYwXG5cdFx0XHRcdHRoaXMuciA9IHBhcnNlSW50KGhleC5jaGFyQXQoMCkgKyBoZXguY2hhckF0KDApLCAxNikgLyAyNTU7XG5cdFx0XHRcdHRoaXMuZyA9IHBhcnNlSW50KGhleC5jaGFyQXQoMSkgKyBoZXguY2hhckF0KDEpLCAxNikgLyAyNTU7XG5cdFx0XHRcdHRoaXMuYiA9IHBhcnNlSW50KGhleC5jaGFyQXQoMikgKyBoZXguY2hhckF0KDIpLCAxNikgLyAyNTU7XG5cdFx0XHRcdENvbG9yTWFuYWdlbWVudC50b1dvcmtpbmdDb2xvclNwYWNlKHRoaXMsIGNvbG9yU3BhY2UpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0gZWxzZSBpZiAoc2l6ZSA9PT0gNikge1xuXHRcdFx0XHQvLyAjZmYwMDAwXG5cdFx0XHRcdHRoaXMuciA9IHBhcnNlSW50KGhleC5jaGFyQXQoMCkgKyBoZXguY2hhckF0KDEpLCAxNikgLyAyNTU7XG5cdFx0XHRcdHRoaXMuZyA9IHBhcnNlSW50KGhleC5jaGFyQXQoMikgKyBoZXguY2hhckF0KDMpLCAxNikgLyAyNTU7XG5cdFx0XHRcdHRoaXMuYiA9IHBhcnNlSW50KGhleC5jaGFyQXQoNCkgKyBoZXguY2hhckF0KDUpLCAxNikgLyAyNTU7XG5cdFx0XHRcdENvbG9yTWFuYWdlbWVudC50b1dvcmtpbmdDb2xvclNwYWNlKHRoaXMsIGNvbG9yU3BhY2UpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHN0eWxlICYmIHN0eWxlLmxlbmd0aCA+IDApIHtcblx0XHRcdHJldHVybiB0aGlzLnNldENvbG9yTmFtZShzdHlsZSwgY29sb3JTcGFjZSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHNldENvbG9yTmFtZShzdHlsZSwgY29sb3JTcGFjZSA9IFNSR0JDb2xvclNwYWNlKSB7XG5cdFx0Ly8gY29sb3Iga2V5d29yZHNcblx0XHRjb25zdCBoZXggPSBfY29sb3JLZXl3b3Jkc1tzdHlsZS50b0xvd2VyQ2FzZSgpXTtcblx0XHRpZiAoaGV4ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdC8vIHJlZFxuXHRcdFx0dGhpcy5zZXRIZXgoaGV4LCBjb2xvclNwYWNlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gdW5rbm93biBjb2xvclxuXHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5Db2xvcjogVW5rbm93biBjb2xvciAnICsgc3R5bGUpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRjbG9uZSgpIHtcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5yLCB0aGlzLmcsIHRoaXMuYik7XG5cdH1cblx0Y29weShjb2xvcikge1xuXHRcdHRoaXMuciA9IGNvbG9yLnI7XG5cdFx0dGhpcy5nID0gY29sb3IuZztcblx0XHR0aGlzLmIgPSBjb2xvci5iO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGNvcHlTUkdCVG9MaW5lYXIoY29sb3IpIHtcblx0XHR0aGlzLnIgPSBTUkdCVG9MaW5lYXIoY29sb3Iucik7XG5cdFx0dGhpcy5nID0gU1JHQlRvTGluZWFyKGNvbG9yLmcpO1xuXHRcdHRoaXMuYiA9IFNSR0JUb0xpbmVhcihjb2xvci5iKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRjb3B5TGluZWFyVG9TUkdCKGNvbG9yKSB7XG5cdFx0dGhpcy5yID0gTGluZWFyVG9TUkdCKGNvbG9yLnIpO1xuXHRcdHRoaXMuZyA9IExpbmVhclRvU1JHQihjb2xvci5nKTtcblx0XHR0aGlzLmIgPSBMaW5lYXJUb1NSR0IoY29sb3IuYik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0Y29udmVydFNSR0JUb0xpbmVhcigpIHtcblx0XHR0aGlzLmNvcHlTUkdCVG9MaW5lYXIodGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0Y29udmVydExpbmVhclRvU1JHQigpIHtcblx0XHR0aGlzLmNvcHlMaW5lYXJUb1NSR0IodGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0Z2V0SGV4KGNvbG9yU3BhY2UgPSBTUkdCQ29sb3JTcGFjZSkge1xuXHRcdENvbG9yTWFuYWdlbWVudC5mcm9tV29ya2luZ0NvbG9yU3BhY2UodG9Db21wb25lbnRzKHRoaXMsIF9yZ2IpLCBjb2xvclNwYWNlKTtcblx0XHRyZXR1cm4gY2xhbXAoX3JnYi5yICogMjU1LCAwLCAyNTUpIDw8IDE2IF4gY2xhbXAoX3JnYi5nICogMjU1LCAwLCAyNTUpIDw8IDggXiBjbGFtcChfcmdiLmIgKiAyNTUsIDAsIDI1NSkgPDwgMDtcblx0fVxuXHRnZXRIZXhTdHJpbmcoY29sb3JTcGFjZSA9IFNSR0JDb2xvclNwYWNlKSB7XG5cdFx0cmV0dXJuICgnMDAwMDAwJyArIHRoaXMuZ2V0SGV4KGNvbG9yU3BhY2UpLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTYpO1xuXHR9XG5cdGdldEhTTCh0YXJnZXQsIGNvbG9yU3BhY2UgPSBMaW5lYXJTUkdCQ29sb3JTcGFjZSkge1xuXHRcdC8vIGgscyxsIHJhbmdlcyBhcmUgaW4gMC4wIC0gMS4wXG5cblx0XHRDb2xvck1hbmFnZW1lbnQuZnJvbVdvcmtpbmdDb2xvclNwYWNlKHRvQ29tcG9uZW50cyh0aGlzLCBfcmdiKSwgY29sb3JTcGFjZSk7XG5cdFx0Y29uc3QgciA9IF9yZ2Iucixcblx0XHRcdGcgPSBfcmdiLmcsXG5cdFx0XHRiID0gX3JnYi5iO1xuXHRcdGNvbnN0IG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuXHRcdGNvbnN0IG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuXHRcdGxldCBodWUsIHNhdHVyYXRpb247XG5cdFx0Y29uc3QgbGlnaHRuZXNzID0gKG1pbiArIG1heCkgLyAyLjA7XG5cdFx0aWYgKG1pbiA9PT0gbWF4KSB7XG5cdFx0XHRodWUgPSAwO1xuXHRcdFx0c2F0dXJhdGlvbiA9IDA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnN0IGRlbHRhID0gbWF4IC0gbWluO1xuXHRcdFx0c2F0dXJhdGlvbiA9IGxpZ2h0bmVzcyA8PSAwLjUgPyBkZWx0YSAvIChtYXggKyBtaW4pIDogZGVsdGEgLyAoMiAtIG1heCAtIG1pbik7XG5cdFx0XHRzd2l0Y2ggKG1heCkge1xuXHRcdFx0XHRjYXNlIHI6XG5cdFx0XHRcdFx0aHVlID0gKGcgLSBiKSAvIGRlbHRhICsgKGcgPCBiID8gNiA6IDApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIGc6XG5cdFx0XHRcdFx0aHVlID0gKGIgLSByKSAvIGRlbHRhICsgMjtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBiOlxuXHRcdFx0XHRcdGh1ZSA9IChyIC0gZykgLyBkZWx0YSArIDQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRodWUgLz0gNjtcblx0XHR9XG5cdFx0dGFyZ2V0LmggPSBodWU7XG5cdFx0dGFyZ2V0LnMgPSBzYXR1cmF0aW9uO1xuXHRcdHRhcmdldC5sID0gbGlnaHRuZXNzO1xuXHRcdHJldHVybiB0YXJnZXQ7XG5cdH1cblx0Z2V0UkdCKHRhcmdldCwgY29sb3JTcGFjZSA9IExpbmVhclNSR0JDb2xvclNwYWNlKSB7XG5cdFx0Q29sb3JNYW5hZ2VtZW50LmZyb21Xb3JraW5nQ29sb3JTcGFjZSh0b0NvbXBvbmVudHModGhpcywgX3JnYiksIGNvbG9yU3BhY2UpO1xuXHRcdHRhcmdldC5yID0gX3JnYi5yO1xuXHRcdHRhcmdldC5nID0gX3JnYi5nO1xuXHRcdHRhcmdldC5iID0gX3JnYi5iO1xuXHRcdHJldHVybiB0YXJnZXQ7XG5cdH1cblx0Z2V0U3R5bGUoY29sb3JTcGFjZSA9IFNSR0JDb2xvclNwYWNlKSB7XG5cdFx0Q29sb3JNYW5hZ2VtZW50LmZyb21Xb3JraW5nQ29sb3JTcGFjZSh0b0NvbXBvbmVudHModGhpcywgX3JnYiksIGNvbG9yU3BhY2UpO1xuXHRcdGlmIChjb2xvclNwYWNlICE9PSBTUkdCQ29sb3JTcGFjZSkge1xuXHRcdFx0Ly8gUmVxdWlyZXMgQ1NTIENvbG9yIE1vZHVsZSBMZXZlbCA0IChodHRwczovL3d3dy53My5vcmcvVFIvY3NzLWNvbG9yLTQvKS5cblx0XHRcdHJldHVybiBgY29sb3IoJHtjb2xvclNwYWNlfSAke19yZ2Iucn0gJHtfcmdiLmd9ICR7X3JnYi5ifSlgO1xuXHRcdH1cblx0XHRyZXR1cm4gYHJnYigke19yZ2IuciAqIDI1NSB8IDB9LCR7X3JnYi5nICogMjU1IHwgMH0sJHtfcmdiLmIgKiAyNTUgfCAwfSlgO1xuXHR9XG5cdG9mZnNldEhTTChoLCBzLCBsKSB7XG5cdFx0dGhpcy5nZXRIU0woX2hzbEEpO1xuXHRcdF9oc2xBLmggKz0gaDtcblx0XHRfaHNsQS5zICs9IHM7XG5cdFx0X2hzbEEubCArPSBsO1xuXHRcdHRoaXMuc2V0SFNMKF9oc2xBLmgsIF9oc2xBLnMsIF9oc2xBLmwpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGFkZChjb2xvcikge1xuXHRcdHRoaXMuciArPSBjb2xvci5yO1xuXHRcdHRoaXMuZyArPSBjb2xvci5nO1xuXHRcdHRoaXMuYiArPSBjb2xvci5iO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGFkZENvbG9ycyhjb2xvcjEsIGNvbG9yMikge1xuXHRcdHRoaXMuciA9IGNvbG9yMS5yICsgY29sb3IyLnI7XG5cdFx0dGhpcy5nID0gY29sb3IxLmcgKyBjb2xvcjIuZztcblx0XHR0aGlzLmIgPSBjb2xvcjEuYiArIGNvbG9yMi5iO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGFkZFNjYWxhcihzKSB7XG5cdFx0dGhpcy5yICs9IHM7XG5cdFx0dGhpcy5nICs9IHM7XG5cdFx0dGhpcy5iICs9IHM7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0c3ViKGNvbG9yKSB7XG5cdFx0dGhpcy5yID0gTWF0aC5tYXgoMCwgdGhpcy5yIC0gY29sb3Iucik7XG5cdFx0dGhpcy5nID0gTWF0aC5tYXgoMCwgdGhpcy5nIC0gY29sb3IuZyk7XG5cdFx0dGhpcy5iID0gTWF0aC5tYXgoMCwgdGhpcy5iIC0gY29sb3IuYik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0bXVsdGlwbHkoY29sb3IpIHtcblx0XHR0aGlzLnIgKj0gY29sb3Iucjtcblx0XHR0aGlzLmcgKj0gY29sb3IuZztcblx0XHR0aGlzLmIgKj0gY29sb3IuYjtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRtdWx0aXBseVNjYWxhcihzKSB7XG5cdFx0dGhpcy5yICo9IHM7XG5cdFx0dGhpcy5nICo9IHM7XG5cdFx0dGhpcy5iICo9IHM7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0bGVycChjb2xvciwgYWxwaGEpIHtcblx0XHR0aGlzLnIgKz0gKGNvbG9yLnIgLSB0aGlzLnIpICogYWxwaGE7XG5cdFx0dGhpcy5nICs9IChjb2xvci5nIC0gdGhpcy5nKSAqIGFscGhhO1xuXHRcdHRoaXMuYiArPSAoY29sb3IuYiAtIHRoaXMuYikgKiBhbHBoYTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRsZXJwQ29sb3JzKGNvbG9yMSwgY29sb3IyLCBhbHBoYSkge1xuXHRcdHRoaXMuciA9IGNvbG9yMS5yICsgKGNvbG9yMi5yIC0gY29sb3IxLnIpICogYWxwaGE7XG5cdFx0dGhpcy5nID0gY29sb3IxLmcgKyAoY29sb3IyLmcgLSBjb2xvcjEuZykgKiBhbHBoYTtcblx0XHR0aGlzLmIgPSBjb2xvcjEuYiArIChjb2xvcjIuYiAtIGNvbG9yMS5iKSAqIGFscGhhO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGxlcnBIU0woY29sb3IsIGFscGhhKSB7XG5cdFx0dGhpcy5nZXRIU0woX2hzbEEpO1xuXHRcdGNvbG9yLmdldEhTTChfaHNsQik7XG5cdFx0Y29uc3QgaCA9IGxlcnAoX2hzbEEuaCwgX2hzbEIuaCwgYWxwaGEpO1xuXHRcdGNvbnN0IHMgPSBsZXJwKF9oc2xBLnMsIF9oc2xCLnMsIGFscGhhKTtcblx0XHRjb25zdCBsID0gbGVycChfaHNsQS5sLCBfaHNsQi5sLCBhbHBoYSk7XG5cdFx0dGhpcy5zZXRIU0woaCwgcywgbCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0ZXF1YWxzKGMpIHtcblx0XHRyZXR1cm4gYy5yID09PSB0aGlzLnIgJiYgYy5nID09PSB0aGlzLmcgJiYgYy5iID09PSB0aGlzLmI7XG5cdH1cblx0ZnJvbUFycmF5KGFycmF5LCBvZmZzZXQgPSAwKSB7XG5cdFx0dGhpcy5yID0gYXJyYXlbb2Zmc2V0XTtcblx0XHR0aGlzLmcgPSBhcnJheVtvZmZzZXQgKyAxXTtcblx0XHR0aGlzLmIgPSBhcnJheVtvZmZzZXQgKyAyXTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHR0b0FycmF5KGFycmF5ID0gW10sIG9mZnNldCA9IDApIHtcblx0XHRhcnJheVtvZmZzZXRdID0gdGhpcy5yO1xuXHRcdGFycmF5W29mZnNldCArIDFdID0gdGhpcy5nO1xuXHRcdGFycmF5W29mZnNldCArIDJdID0gdGhpcy5iO1xuXHRcdHJldHVybiBhcnJheTtcblx0fVxuXHRmcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZSwgaW5kZXgpIHtcblx0XHR0aGlzLnIgPSBhdHRyaWJ1dGUuZ2V0WChpbmRleCk7XG5cdFx0dGhpcy5nID0gYXR0cmlidXRlLmdldFkoaW5kZXgpO1xuXHRcdHRoaXMuYiA9IGF0dHJpYnV0ZS5nZXRaKGluZGV4KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHR0b0pTT04oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0SGV4KCk7XG5cdH1cblx0KltTeW1ib2wuaXRlcmF0b3JdKCkge1xuXHRcdHlpZWxkIHRoaXMucjtcblx0XHR5aWVsZCB0aGlzLmc7XG5cdFx0eWllbGQgdGhpcy5iO1xuXHR9XG59XG5Db2xvci5OQU1FUyA9IF9jb2xvcktleXdvcmRzO1xuXG5sZXQgX2NhbnZhcztcbmNsYXNzIEltYWdlVXRpbHMge1xuXHRzdGF0aWMgZ2V0RGF0YVVSTChpbWFnZSkge1xuXHRcdGlmICgvXmRhdGE6L2kudGVzdChpbWFnZS5zcmMpKSB7XG5cdFx0XHRyZXR1cm4gaW1hZ2Uuc3JjO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIEhUTUxDYW52YXNFbGVtZW50ID09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRyZXR1cm4gaW1hZ2Uuc3JjO1xuXHRcdH1cblx0XHRsZXQgY2FudmFzO1xuXHRcdGlmIChpbWFnZSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50KSB7XG5cdFx0XHRjYW52YXMgPSBpbWFnZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKF9jYW52YXMgPT09IHVuZGVmaW5lZCkgX2NhbnZhcyA9IGNyZWF0ZUVsZW1lbnROUygnY2FudmFzJyk7XG5cdFx0XHRfY2FudmFzLndpZHRoID0gaW1hZ2Uud2lkdGg7XG5cdFx0XHRfY2FudmFzLmhlaWdodCA9IGltYWdlLmhlaWdodDtcblx0XHRcdGNvbnN0IGNvbnRleHQgPSBfY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cdFx0XHRpZiAoaW1hZ2UgaW5zdGFuY2VvZiBJbWFnZURhdGEpIHtcblx0XHRcdFx0Y29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2UsIDAsIDApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpO1xuXHRcdFx0fVxuXHRcdFx0Y2FudmFzID0gX2NhbnZhcztcblx0XHR9XG5cdFx0aWYgKGNhbnZhcy53aWR0aCA+IDIwNDggfHwgY2FudmFzLmhlaWdodCA+IDIwNDgpIHtcblx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuSW1hZ2VVdGlscy5nZXREYXRhVVJMOiBJbWFnZSBjb252ZXJ0ZWQgdG8ganBnIGZvciBwZXJmb3JtYW5jZSByZWFzb25zJywgaW1hZ2UpO1xuXHRcdFx0cmV0dXJuIGNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL2pwZWcnLCAwLjYpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7XG5cdFx0fVxuXHR9XG5cdHN0YXRpYyBzUkdCVG9MaW5lYXIoaW1hZ2UpIHtcblx0XHRpZiAodHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGltYWdlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCB8fCB0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGltYWdlIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQgfHwgdHlwZW9mIEltYWdlQml0bWFwICE9PSAndW5kZWZpbmVkJyAmJiBpbWFnZSBpbnN0YW5jZW9mIEltYWdlQml0bWFwKSB7XG5cdFx0XHRjb25zdCBjYW52YXMgPSBjcmVhdGVFbGVtZW50TlMoJ2NhbnZhcycpO1xuXHRcdFx0Y2FudmFzLndpZHRoID0gaW1hZ2Uud2lkdGg7XG5cdFx0XHRjYW52YXMuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuXHRcdFx0Y29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXHRcdFx0Y29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpO1xuXHRcdFx0Y29uc3QgaW1hZ2VEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCk7XG5cdFx0XHRjb25zdCBkYXRhID0gaW1hZ2VEYXRhLmRhdGE7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0ZGF0YVtpXSA9IFNSR0JUb0xpbmVhcihkYXRhW2ldIC8gMjU1KSAqIDI1NTtcblx0XHRcdH1cblx0XHRcdGNvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG5cdFx0XHRyZXR1cm4gY2FudmFzO1xuXHRcdH0gZWxzZSBpZiAoaW1hZ2UuZGF0YSkge1xuXHRcdFx0Y29uc3QgZGF0YSA9IGltYWdlLmRhdGEuc2xpY2UoMCk7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IGRhdGEgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkge1xuXHRcdFx0XHRcdGRhdGFbaV0gPSBNYXRoLmZsb29yKFNSR0JUb0xpbmVhcihkYXRhW2ldIC8gMjU1KSAqIDI1NSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gYXNzdW1pbmcgZmxvYXRcblxuXHRcdFx0XHRcdGRhdGFbaV0gPSBTUkdCVG9MaW5lYXIoZGF0YVtpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdHdpZHRoOiBpbWFnZS53aWR0aCxcblx0XHRcdFx0aGVpZ2h0OiBpbWFnZS5oZWlnaHRcblx0XHRcdH07XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuSW1hZ2VVdGlscy5zUkdCVG9MaW5lYXIoKTogVW5zdXBwb3J0ZWQgaW1hZ2UgdHlwZS4gTm8gY29sb3Igc3BhY2UgY29udmVyc2lvbiBhcHBsaWVkLicpO1xuXHRcdFx0cmV0dXJuIGltYWdlO1xuXHRcdH1cblx0fVxufVxuXG5jbGFzcyBTb3VyY2Uge1xuXHRjb25zdHJ1Y3RvcihkYXRhID0gbnVsbCkge1xuXHRcdHRoaXMuaXNTb3VyY2UgPSB0cnVlO1xuXHRcdHRoaXMudXVpZCA9IGdlbmVyYXRlVVVJRCgpO1xuXHRcdHRoaXMuZGF0YSA9IGRhdGE7XG5cdFx0dGhpcy52ZXJzaW9uID0gMDtcblx0fVxuXHRzZXQgbmVlZHNVcGRhdGUodmFsdWUpIHtcblx0XHRpZiAodmFsdWUgPT09IHRydWUpIHRoaXMudmVyc2lvbisrO1xuXHR9XG5cdHRvSlNPTihtZXRhKSB7XG5cdFx0Y29uc3QgaXNSb290T2JqZWN0ID0gbWV0YSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBtZXRhID09PSAnc3RyaW5nJztcblx0XHRpZiAoIWlzUm9vdE9iamVjdCAmJiBtZXRhLmltYWdlc1t0aGlzLnV1aWRdICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiBtZXRhLmltYWdlc1t0aGlzLnV1aWRdO1xuXHRcdH1cblx0XHRjb25zdCBvdXRwdXQgPSB7XG5cdFx0XHR1dWlkOiB0aGlzLnV1aWQsXG5cdFx0XHR1cmw6ICcnXG5cdFx0fTtcblx0XHRjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xuXHRcdGlmIChkYXRhICE9PSBudWxsKSB7XG5cdFx0XHRsZXQgdXJsO1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcblx0XHRcdFx0Ly8gY3ViZSB0ZXh0dXJlXG5cblx0XHRcdFx0dXJsID0gW107XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoZGF0YVtpXS5pc0RhdGFUZXh0dXJlKSB7XG5cdFx0XHRcdFx0XHR1cmwucHVzaChzZXJpYWxpemVJbWFnZShkYXRhW2ldLmltYWdlKSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHVybC5wdXNoKHNlcmlhbGl6ZUltYWdlKGRhdGFbaV0pKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHRleHR1cmVcblxuXHRcdFx0XHR1cmwgPSBzZXJpYWxpemVJbWFnZShkYXRhKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC51cmwgPSB1cmw7XG5cdFx0fVxuXHRcdGlmICghaXNSb290T2JqZWN0KSB7XG5cdFx0XHRtZXRhLmltYWdlc1t0aGlzLnV1aWRdID0gb3V0cHV0O1xuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG59XG5mdW5jdGlvbiBzZXJpYWxpemVJbWFnZShpbWFnZSkge1xuXHRpZiAodHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGltYWdlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCB8fCB0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGltYWdlIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQgfHwgdHlwZW9mIEltYWdlQml0bWFwICE9PSAndW5kZWZpbmVkJyAmJiBpbWFnZSBpbnN0YW5jZW9mIEltYWdlQml0bWFwKSB7XG5cdFx0Ly8gZGVmYXVsdCBpbWFnZXNcblxuXHRcdHJldHVybiBJbWFnZVV0aWxzLmdldERhdGFVUkwoaW1hZ2UpO1xuXHR9IGVsc2Uge1xuXHRcdGlmIChpbWFnZS5kYXRhKSB7XG5cdFx0XHQvLyBpbWFnZXMgb2YgRGF0YVRleHR1cmVcblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogQXJyYXkuZnJvbShpbWFnZS5kYXRhKSxcblx0XHRcdFx0d2lkdGg6IGltYWdlLndpZHRoLFxuXHRcdFx0XHRoZWlnaHQ6IGltYWdlLmhlaWdodCxcblx0XHRcdFx0dHlwZTogaW1hZ2UuZGF0YS5jb25zdHJ1Y3Rvci5uYW1lXG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlRleHR1cmU6IFVuYWJsZSB0byBzZXJpYWxpemUgVGV4dHVyZS4nKTtcblx0XHRcdHJldHVybiB7fTtcblx0XHR9XG5cdH1cbn1cblxubGV0IHRleHR1cmVJZCA9IDA7XG5jbGFzcyBUZXh0dXJlIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyIHtcblx0Y29uc3RydWN0b3IoaW1hZ2UgPSBUZXh0dXJlLkRFRkFVTFRfSU1BR0UsIG1hcHBpbmcgPSBUZXh0dXJlLkRFRkFVTFRfTUFQUElORywgd3JhcFMgPSBDbGFtcFRvRWRnZVdyYXBwaW5nLCB3cmFwVCA9IENsYW1wVG9FZGdlV3JhcHBpbmcsIG1hZ0ZpbHRlciA9IExpbmVhckZpbHRlciwgbWluRmlsdGVyID0gTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyLCBmb3JtYXQgPSBSR0JBRm9ybWF0LCB0eXBlID0gVW5zaWduZWRCeXRlVHlwZSwgYW5pc290cm9weSA9IDEsIGVuY29kaW5nID0gTGluZWFyRW5jb2RpbmcpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuaXNUZXh0dXJlID0gdHJ1ZTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2lkJywge1xuXHRcdFx0dmFsdWU6IHRleHR1cmVJZCsrXG5cdFx0fSk7XG5cdFx0dGhpcy51dWlkID0gZ2VuZXJhdGVVVUlEKCk7XG5cdFx0dGhpcy5uYW1lID0gJyc7XG5cdFx0dGhpcy5zb3VyY2UgPSBuZXcgU291cmNlKGltYWdlKTtcblx0XHR0aGlzLm1pcG1hcHMgPSBbXTtcblx0XHR0aGlzLm1hcHBpbmcgPSBtYXBwaW5nO1xuXHRcdHRoaXMud3JhcFMgPSB3cmFwUztcblx0XHR0aGlzLndyYXBUID0gd3JhcFQ7XG5cdFx0dGhpcy5tYWdGaWx0ZXIgPSBtYWdGaWx0ZXI7XG5cdFx0dGhpcy5taW5GaWx0ZXIgPSBtaW5GaWx0ZXI7XG5cdFx0dGhpcy5hbmlzb3Ryb3B5ID0gYW5pc290cm9weTtcblx0XHR0aGlzLmZvcm1hdCA9IGZvcm1hdDtcblx0XHR0aGlzLmludGVybmFsRm9ybWF0ID0gbnVsbDtcblx0XHR0aGlzLnR5cGUgPSB0eXBlO1xuXHRcdHRoaXMub2Zmc2V0ID0gbmV3IFZlY3RvcjIoMCwgMCk7XG5cdFx0dGhpcy5yZXBlYXQgPSBuZXcgVmVjdG9yMigxLCAxKTtcblx0XHR0aGlzLmNlbnRlciA9IG5ldyBWZWN0b3IyKDAsIDApO1xuXHRcdHRoaXMucm90YXRpb24gPSAwO1xuXHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IHRydWU7XG5cdFx0dGhpcy5tYXRyaXggPSBuZXcgTWF0cml4MygpO1xuXHRcdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gdHJ1ZTtcblx0XHR0aGlzLnByZW11bHRpcGx5QWxwaGEgPSBmYWxzZTtcblx0XHR0aGlzLmZsaXBZID0gdHJ1ZTtcblx0XHR0aGlzLnVucGFja0FsaWdubWVudCA9IDQ7IC8vIHZhbGlkIHZhbHVlczogMSwgMiwgNCwgOCAoc2VlIGh0dHA6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsZXMvc2RrL2RvY3MvbWFuL3hodG1sL2dsUGl4ZWxTdG9yZWkueG1sKVxuXG5cdFx0Ly8gVmFsdWVzIG9mIGVuY29kaW5nICE9PSBUSFJFRS5MaW5lYXJFbmNvZGluZyBvbmx5IHN1cHBvcnRlZCBvbiBtYXAsIGVudk1hcCBhbmQgZW1pc3NpdmVNYXAuXG5cdFx0Ly9cblx0XHQvLyBBbHNvIGNoYW5naW5nIHRoZSBlbmNvZGluZyBhZnRlciBhbHJlYWR5IHVzZWQgYnkgYSBNYXRlcmlhbCB3aWxsIG5vdCBhdXRvbWF0aWNhbGx5IG1ha2UgdGhlIE1hdGVyaWFsXG5cdFx0Ly8gdXBkYXRlLiBZb3UgbmVlZCB0byBleHBsaWNpdGx5IGNhbGwgTWF0ZXJpYWwubmVlZHNVcGRhdGUgdG8gdHJpZ2dlciBpdCB0byByZWNvbXBpbGUuXG5cdFx0dGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuXHRcdHRoaXMudXNlckRhdGEgPSB7fTtcblx0XHR0aGlzLnZlcnNpb24gPSAwO1xuXHRcdHRoaXMub25VcGRhdGUgPSBudWxsO1xuXHRcdHRoaXMuaXNSZW5kZXJUYXJnZXRUZXh0dXJlID0gZmFsc2U7IC8vIGluZGljYXRlcyB3aGV0aGVyIGEgdGV4dHVyZSBiZWxvbmdzIHRvIGEgcmVuZGVyIHRhcmdldCBvciBub3Rcblx0XHR0aGlzLm5lZWRzUE1SRU1VcGRhdGUgPSBmYWxzZTsgLy8gaW5kaWNhdGVzIHdoZXRoZXIgdGhpcyB0ZXh0dXJlIHNob3VsZCBiZSBwcm9jZXNzZWQgYnkgUE1SRU1HZW5lcmF0b3Igb3Igbm90IChvbmx5IHJlbGV2YW50IGZvciByZW5kZXIgdGFyZ2V0IHRleHR1cmVzKVxuXHR9XG5cblx0Z2V0IGltYWdlKCkge1xuXHRcdHJldHVybiB0aGlzLnNvdXJjZS5kYXRhO1xuXHR9XG5cdHNldCBpbWFnZSh2YWx1ZSkge1xuXHRcdHRoaXMuc291cmNlLmRhdGEgPSB2YWx1ZTtcblx0fVxuXHR1cGRhdGVNYXRyaXgoKSB7XG5cdFx0dGhpcy5tYXRyaXguc2V0VXZUcmFuc2Zvcm0odGhpcy5vZmZzZXQueCwgdGhpcy5vZmZzZXQueSwgdGhpcy5yZXBlYXQueCwgdGhpcy5yZXBlYXQueSwgdGhpcy5yb3RhdGlvbiwgdGhpcy5jZW50ZXIueCwgdGhpcy5jZW50ZXIueSk7XG5cdH1cblx0Y2xvbmUoKSB7XG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKTtcblx0fVxuXHRjb3B5KHNvdXJjZSkge1xuXHRcdHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xuXHRcdHRoaXMuc291cmNlID0gc291cmNlLnNvdXJjZTtcblx0XHR0aGlzLm1pcG1hcHMgPSBzb3VyY2UubWlwbWFwcy5zbGljZSgwKTtcblx0XHR0aGlzLm1hcHBpbmcgPSBzb3VyY2UubWFwcGluZztcblx0XHR0aGlzLndyYXBTID0gc291cmNlLndyYXBTO1xuXHRcdHRoaXMud3JhcFQgPSBzb3VyY2Uud3JhcFQ7XG5cdFx0dGhpcy5tYWdGaWx0ZXIgPSBzb3VyY2UubWFnRmlsdGVyO1xuXHRcdHRoaXMubWluRmlsdGVyID0gc291cmNlLm1pbkZpbHRlcjtcblx0XHR0aGlzLmFuaXNvdHJvcHkgPSBzb3VyY2UuYW5pc290cm9weTtcblx0XHR0aGlzLmZvcm1hdCA9IHNvdXJjZS5mb3JtYXQ7XG5cdFx0dGhpcy5pbnRlcm5hbEZvcm1hdCA9IHNvdXJjZS5pbnRlcm5hbEZvcm1hdDtcblx0XHR0aGlzLnR5cGUgPSBzb3VyY2UudHlwZTtcblx0XHR0aGlzLm9mZnNldC5jb3B5KHNvdXJjZS5vZmZzZXQpO1xuXHRcdHRoaXMucmVwZWF0LmNvcHkoc291cmNlLnJlcGVhdCk7XG5cdFx0dGhpcy5jZW50ZXIuY29weShzb3VyY2UuY2VudGVyKTtcblx0XHR0aGlzLnJvdGF0aW9uID0gc291cmNlLnJvdGF0aW9uO1xuXHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IHNvdXJjZS5tYXRyaXhBdXRvVXBkYXRlO1xuXHRcdHRoaXMubWF0cml4LmNvcHkoc291cmNlLm1hdHJpeCk7XG5cdFx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBzb3VyY2UuZ2VuZXJhdGVNaXBtYXBzO1xuXHRcdHRoaXMucHJlbXVsdGlwbHlBbHBoYSA9IHNvdXJjZS5wcmVtdWx0aXBseUFscGhhO1xuXHRcdHRoaXMuZmxpcFkgPSBzb3VyY2UuZmxpcFk7XG5cdFx0dGhpcy51bnBhY2tBbGlnbm1lbnQgPSBzb3VyY2UudW5wYWNrQWxpZ25tZW50O1xuXHRcdHRoaXMuZW5jb2RpbmcgPSBzb3VyY2UuZW5jb2Rpbmc7XG5cdFx0dGhpcy51c2VyRGF0YSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc291cmNlLnVzZXJEYXRhKSk7XG5cdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0dG9KU09OKG1ldGEpIHtcblx0XHRjb25zdCBpc1Jvb3RPYmplY3QgPSBtZXRhID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG1ldGEgPT09ICdzdHJpbmcnO1xuXHRcdGlmICghaXNSb290T2JqZWN0ICYmIG1ldGEudGV4dHVyZXNbdGhpcy51dWlkXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gbWV0YS50ZXh0dXJlc1t0aGlzLnV1aWRdO1xuXHRcdH1cblx0XHRjb25zdCBvdXRwdXQgPSB7XG5cdFx0XHRtZXRhZGF0YToge1xuXHRcdFx0XHR2ZXJzaW9uOiA0LjUsXG5cdFx0XHRcdHR5cGU6ICdUZXh0dXJlJyxcblx0XHRcdFx0Z2VuZXJhdG9yOiAnVGV4dHVyZS50b0pTT04nXG5cdFx0XHR9LFxuXHRcdFx0dXVpZDogdGhpcy51dWlkLFxuXHRcdFx0bmFtZTogdGhpcy5uYW1lLFxuXHRcdFx0aW1hZ2U6IHRoaXMuc291cmNlLnRvSlNPTihtZXRhKS51dWlkLFxuXHRcdFx0bWFwcGluZzogdGhpcy5tYXBwaW5nLFxuXHRcdFx0cmVwZWF0OiBbdGhpcy5yZXBlYXQueCwgdGhpcy5yZXBlYXQueV0sXG5cdFx0XHRvZmZzZXQ6IFt0aGlzLm9mZnNldC54LCB0aGlzLm9mZnNldC55XSxcblx0XHRcdGNlbnRlcjogW3RoaXMuY2VudGVyLngsIHRoaXMuY2VudGVyLnldLFxuXHRcdFx0cm90YXRpb246IHRoaXMucm90YXRpb24sXG5cdFx0XHR3cmFwOiBbdGhpcy53cmFwUywgdGhpcy53cmFwVF0sXG5cdFx0XHRmb3JtYXQ6IHRoaXMuZm9ybWF0LFxuXHRcdFx0dHlwZTogdGhpcy50eXBlLFxuXHRcdFx0ZW5jb2Rpbmc6IHRoaXMuZW5jb2RpbmcsXG5cdFx0XHRtaW5GaWx0ZXI6IHRoaXMubWluRmlsdGVyLFxuXHRcdFx0bWFnRmlsdGVyOiB0aGlzLm1hZ0ZpbHRlcixcblx0XHRcdGFuaXNvdHJvcHk6IHRoaXMuYW5pc290cm9weSxcblx0XHRcdGZsaXBZOiB0aGlzLmZsaXBZLFxuXHRcdFx0cHJlbXVsdGlwbHlBbHBoYTogdGhpcy5wcmVtdWx0aXBseUFscGhhLFxuXHRcdFx0dW5wYWNrQWxpZ25tZW50OiB0aGlzLnVucGFja0FsaWdubWVudFxuXHRcdH07XG5cdFx0aWYgKEpTT04uc3RyaW5naWZ5KHRoaXMudXNlckRhdGEpICE9PSAne30nKSBvdXRwdXQudXNlckRhdGEgPSB0aGlzLnVzZXJEYXRhO1xuXHRcdGlmICghaXNSb290T2JqZWN0KSB7XG5cdFx0XHRtZXRhLnRleHR1cmVzW3RoaXMudXVpZF0gPSBvdXRwdXQ7XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblx0ZGlzcG9zZSgpIHtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoe1xuXHRcdFx0dHlwZTogJ2Rpc3Bvc2UnXG5cdFx0fSk7XG5cdH1cblx0dHJhbnNmb3JtVXYodXYpIHtcblx0XHRpZiAodGhpcy5tYXBwaW5nICE9PSBVVk1hcHBpbmcpIHJldHVybiB1djtcblx0XHR1di5hcHBseU1hdHJpeDModGhpcy5tYXRyaXgpO1xuXHRcdGlmICh1di54IDwgMCB8fCB1di54ID4gMSkge1xuXHRcdFx0c3dpdGNoICh0aGlzLndyYXBTKSB7XG5cdFx0XHRcdGNhc2UgUmVwZWF0V3JhcHBpbmc6XG5cdFx0XHRcdFx0dXYueCA9IHV2LnggLSBNYXRoLmZsb29yKHV2LngpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIENsYW1wVG9FZGdlV3JhcHBpbmc6XG5cdFx0XHRcdFx0dXYueCA9IHV2LnggPCAwID8gMCA6IDE7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgTWlycm9yZWRSZXBlYXRXcmFwcGluZzpcblx0XHRcdFx0XHRpZiAoTWF0aC5hYnMoTWF0aC5mbG9vcih1di54KSAlIDIpID09PSAxKSB7XG5cdFx0XHRcdFx0XHR1di54ID0gTWF0aC5jZWlsKHV2LngpIC0gdXYueDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dXYueCA9IHV2LnggLSBNYXRoLmZsb29yKHV2LngpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHV2LnkgPCAwIHx8IHV2LnkgPiAxKSB7XG5cdFx0XHRzd2l0Y2ggKHRoaXMud3JhcFQpIHtcblx0XHRcdFx0Y2FzZSBSZXBlYXRXcmFwcGluZzpcblx0XHRcdFx0XHR1di55ID0gdXYueSAtIE1hdGguZmxvb3IodXYueSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgQ2xhbXBUb0VkZ2VXcmFwcGluZzpcblx0XHRcdFx0XHR1di55ID0gdXYueSA8IDAgPyAwIDogMTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nOlxuXHRcdFx0XHRcdGlmIChNYXRoLmFicyhNYXRoLmZsb29yKHV2LnkpICUgMikgPT09IDEpIHtcblx0XHRcdFx0XHRcdHV2LnkgPSBNYXRoLmNlaWwodXYueSkgLSB1di55O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR1di55ID0gdXYueSAtIE1hdGguZmxvb3IodXYueSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAodGhpcy5mbGlwWSkge1xuXHRcdFx0dXYueSA9IDEgLSB1di55O1xuXHRcdH1cblx0XHRyZXR1cm4gdXY7XG5cdH1cblx0c2V0IG5lZWRzVXBkYXRlKHZhbHVlKSB7XG5cdFx0aWYgKHZhbHVlID09PSB0cnVlKSB7XG5cdFx0XHR0aGlzLnZlcnNpb24rKztcblx0XHRcdHRoaXMuc291cmNlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHR9XG5cdH1cbn1cblRleHR1cmUuREVGQVVMVF9JTUFHRSA9IG51bGw7XG5UZXh0dXJlLkRFRkFVTFRfTUFQUElORyA9IFVWTWFwcGluZztcblxuY2xhc3MgVmVjdG9yNCB7XG5cdGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgeiA9IDAsIHcgPSAxKSB7XG5cdFx0VmVjdG9yNC5wcm90b3R5cGUuaXNWZWN0b3I0ID0gdHJ1ZTtcblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7XG5cdFx0dGhpcy56ID0gejtcblx0XHR0aGlzLncgPSB3O1xuXHR9XG5cdGdldCB3aWR0aCgpIHtcblx0XHRyZXR1cm4gdGhpcy56O1xuXHR9XG5cdHNldCB3aWR0aCh2YWx1ZSkge1xuXHRcdHRoaXMueiA9IHZhbHVlO1xuXHR9XG5cdGdldCBoZWlnaHQoKSB7XG5cdFx0cmV0dXJuIHRoaXMudztcblx0fVxuXHRzZXQgaGVpZ2h0KHZhbHVlKSB7XG5cdFx0dGhpcy53ID0gdmFsdWU7XG5cdH1cblx0c2V0KHgsIHksIHosIHcpIHtcblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7XG5cdFx0dGhpcy56ID0gejtcblx0XHR0aGlzLncgPSB3O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHNldFNjYWxhcihzY2FsYXIpIHtcblx0XHR0aGlzLnggPSBzY2FsYXI7XG5cdFx0dGhpcy55ID0gc2NhbGFyO1xuXHRcdHRoaXMueiA9IHNjYWxhcjtcblx0XHR0aGlzLncgPSBzY2FsYXI7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0c2V0WCh4KSB7XG5cdFx0dGhpcy54ID0geDtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRzZXRZKHkpIHtcblx0XHR0aGlzLnkgPSB5O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHNldFooeikge1xuXHRcdHRoaXMueiA9IHo7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0c2V0Vyh3KSB7XG5cdFx0dGhpcy53ID0gdztcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRzZXRDb21wb25lbnQoaW5kZXgsIHZhbHVlKSB7XG5cdFx0c3dpdGNoIChpbmRleCkge1xuXHRcdFx0Y2FzZSAwOlxuXHRcdFx0XHR0aGlzLnggPSB2YWx1ZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIDE6XG5cdFx0XHRcdHRoaXMueSA9IHZhbHVlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgMjpcblx0XHRcdFx0dGhpcy56ID0gdmFsdWU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAzOlxuXHRcdFx0XHR0aGlzLncgPSB2YWx1ZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4KTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0Z2V0Q29tcG9uZW50KGluZGV4KSB7XG5cdFx0c3dpdGNoIChpbmRleCkge1xuXHRcdFx0Y2FzZSAwOlxuXHRcdFx0XHRyZXR1cm4gdGhpcy54O1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRyZXR1cm4gdGhpcy55O1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHRyZXR1cm4gdGhpcy56O1xuXHRcdFx0Y2FzZSAzOlxuXHRcdFx0XHRyZXR1cm4gdGhpcy53O1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCk7XG5cdFx0fVxuXHR9XG5cdGNsb25lKCkge1xuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLngsIHRoaXMueSwgdGhpcy56LCB0aGlzLncpO1xuXHR9XG5cdGNvcHkodikge1xuXHRcdHRoaXMueCA9IHYueDtcblx0XHR0aGlzLnkgPSB2Lnk7XG5cdFx0dGhpcy56ID0gdi56O1xuXHRcdHRoaXMudyA9IHYudyAhPT0gdW5kZWZpbmVkID8gdi53IDogMTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRhZGQodikge1xuXHRcdHRoaXMueCArPSB2Lng7XG5cdFx0dGhpcy55ICs9IHYueTtcblx0XHR0aGlzLnogKz0gdi56O1xuXHRcdHRoaXMudyArPSB2Lnc7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0YWRkU2NhbGFyKHMpIHtcblx0XHR0aGlzLnggKz0gcztcblx0XHR0aGlzLnkgKz0gcztcblx0XHR0aGlzLnogKz0gcztcblx0XHR0aGlzLncgKz0gcztcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRhZGRWZWN0b3JzKGEsIGIpIHtcblx0XHR0aGlzLnggPSBhLnggKyBiLng7XG5cdFx0dGhpcy55ID0gYS55ICsgYi55O1xuXHRcdHRoaXMueiA9IGEueiArIGIuejtcblx0XHR0aGlzLncgPSBhLncgKyBiLnc7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0YWRkU2NhbGVkVmVjdG9yKHYsIHMpIHtcblx0XHR0aGlzLnggKz0gdi54ICogcztcblx0XHR0aGlzLnkgKz0gdi55ICogcztcblx0XHR0aGlzLnogKz0gdi56ICogcztcblx0XHR0aGlzLncgKz0gdi53ICogcztcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRzdWIodikge1xuXHRcdHRoaXMueCAtPSB2Lng7XG5cdFx0dGhpcy55IC09IHYueTtcblx0XHR0aGlzLnogLT0gdi56O1xuXHRcdHRoaXMudyAtPSB2Lnc7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0c3ViU2NhbGFyKHMpIHtcblx0XHR0aGlzLnggLT0gcztcblx0XHR0aGlzLnkgLT0gcztcblx0XHR0aGlzLnogLT0gcztcblx0XHR0aGlzLncgLT0gcztcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRzdWJWZWN0b3JzKGEsIGIpIHtcblx0XHR0aGlzLnggPSBhLnggLSBiLng7XG5cdFx0dGhpcy55ID0gYS55IC0gYi55O1xuXHRcdHRoaXMueiA9IGEueiAtIGIuejtcblx0XHR0aGlzLncgPSBhLncgLSBiLnc7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0bXVsdGlwbHkodikge1xuXHRcdHRoaXMueCAqPSB2Lng7XG5cdFx0dGhpcy55ICo9IHYueTtcblx0XHR0aGlzLnogKj0gdi56O1xuXHRcdHRoaXMudyAqPSB2Lnc7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0bXVsdGlwbHlTY2FsYXIoc2NhbGFyKSB7XG5cdFx0dGhpcy54ICo9IHNjYWxhcjtcblx0XHR0aGlzLnkgKj0gc2NhbGFyO1xuXHRcdHRoaXMueiAqPSBzY2FsYXI7XG5cdFx0dGhpcy53ICo9IHNjYWxhcjtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRhcHBseU1hdHJpeDQobSkge1xuXHRcdGNvbnN0IHggPSB0aGlzLngsXG5cdFx0XHR5ID0gdGhpcy55LFxuXHRcdFx0eiA9IHRoaXMueixcblx0XHRcdHcgPSB0aGlzLnc7XG5cdFx0Y29uc3QgZSA9IG0uZWxlbWVudHM7XG5cdFx0dGhpcy54ID0gZVswXSAqIHggKyBlWzRdICogeSArIGVbOF0gKiB6ICsgZVsxMl0gKiB3O1xuXHRcdHRoaXMueSA9IGVbMV0gKiB4ICsgZVs1XSAqIHkgKyBlWzldICogeiArIGVbMTNdICogdztcblx0XHR0aGlzLnogPSBlWzJdICogeCArIGVbNl0gKiB5ICsgZVsxMF0gKiB6ICsgZVsxNF0gKiB3O1xuXHRcdHRoaXMudyA9IGVbM10gKiB4ICsgZVs3XSAqIHkgKyBlWzExXSAqIHogKyBlWzE1XSAqIHc7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0ZGl2aWRlU2NhbGFyKHNjYWxhcikge1xuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKDEgLyBzY2FsYXIpO1xuXHR9XG5cdHNldEF4aXNBbmdsZUZyb21RdWF0ZXJuaW9uKHEpIHtcblx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvcXVhdGVybmlvblRvQW5nbGUvaW5kZXguaHRtXG5cblx0XHQvLyBxIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXG5cdFx0dGhpcy53ID0gMiAqIE1hdGguYWNvcyhxLncpO1xuXHRcdGNvbnN0IHMgPSBNYXRoLnNxcnQoMSAtIHEudyAqIHEudyk7XG5cdFx0aWYgKHMgPCAwLjAwMDEpIHtcblx0XHRcdHRoaXMueCA9IDE7XG5cdFx0XHR0aGlzLnkgPSAwO1xuXHRcdFx0dGhpcy56ID0gMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy54ID0gcS54IC8gcztcblx0XHRcdHRoaXMueSA9IHEueSAvIHM7XG5cdFx0XHR0aGlzLnogPSBxLnogLyBzO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRzZXRBeGlzQW5nbGVGcm9tUm90YXRpb25NYXRyaXgobSkge1xuXHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9tYXRyaXhUb0FuZ2xlL2luZGV4Lmh0bVxuXG5cdFx0Ly8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcblxuXHRcdGxldCBhbmdsZSwgeCwgeSwgejsgLy8gdmFyaWFibGVzIGZvciByZXN1bHRcblx0XHRjb25zdCBlcHNpbG9uID0gMC4wMSxcblx0XHRcdC8vIG1hcmdpbiB0byBhbGxvdyBmb3Igcm91bmRpbmcgZXJyb3JzXG5cdFx0XHRlcHNpbG9uMiA9IDAuMSxcblx0XHRcdC8vIG1hcmdpbiB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIDAgYW5kIDE4MCBkZWdyZWVzXG5cblx0XHRcdHRlID0gbS5lbGVtZW50cyxcblx0XHRcdG0xMSA9IHRlWzBdLFxuXHRcdFx0bTEyID0gdGVbNF0sXG5cdFx0XHRtMTMgPSB0ZVs4XSxcblx0XHRcdG0yMSA9IHRlWzFdLFxuXHRcdFx0bTIyID0gdGVbNV0sXG5cdFx0XHRtMjMgPSB0ZVs5XSxcblx0XHRcdG0zMSA9IHRlWzJdLFxuXHRcdFx0bTMyID0gdGVbNl0sXG5cdFx0XHRtMzMgPSB0ZVsxMF07XG5cdFx0aWYgKE1hdGguYWJzKG0xMiAtIG0yMSkgPCBlcHNpbG9uICYmIE1hdGguYWJzKG0xMyAtIG0zMSkgPCBlcHNpbG9uICYmIE1hdGguYWJzKG0yMyAtIG0zMikgPCBlcHNpbG9uKSB7XG5cdFx0XHQvLyBzaW5ndWxhcml0eSBmb3VuZFxuXHRcdFx0Ly8gZmlyc3QgY2hlY2sgZm9yIGlkZW50aXR5IG1hdHJpeCB3aGljaCBtdXN0IGhhdmUgKzEgZm9yIGFsbCB0ZXJtc1xuXHRcdFx0Ly8gaW4gbGVhZGluZyBkaWFnb25hbCBhbmQgemVybyBpbiBvdGhlciB0ZXJtc1xuXG5cdFx0XHRpZiAoTWF0aC5hYnMobTEyICsgbTIxKSA8IGVwc2lsb24yICYmIE1hdGguYWJzKG0xMyArIG0zMSkgPCBlcHNpbG9uMiAmJiBNYXRoLmFicyhtMjMgKyBtMzIpIDwgZXBzaWxvbjIgJiYgTWF0aC5hYnMobTExICsgbTIyICsgbTMzIC0gMykgPCBlcHNpbG9uMikge1xuXHRcdFx0XHQvLyB0aGlzIHNpbmd1bGFyaXR5IGlzIGlkZW50aXR5IG1hdHJpeCBzbyBhbmdsZSA9IDBcblxuXHRcdFx0XHR0aGlzLnNldCgxLCAwLCAwLCAwKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7IC8vIHplcm8gYW5nbGUsIGFyYml0cmFyeSBheGlzXG5cdFx0XHR9XG5cblx0XHRcdC8vIG90aGVyd2lzZSB0aGlzIHNpbmd1bGFyaXR5IGlzIGFuZ2xlID0gMTgwXG5cblx0XHRcdGFuZ2xlID0gTWF0aC5QSTtcblx0XHRcdGNvbnN0IHh4ID0gKG0xMSArIDEpIC8gMjtcblx0XHRcdGNvbnN0IHl5ID0gKG0yMiArIDEpIC8gMjtcblx0XHRcdGNvbnN0IHp6ID0gKG0zMyArIDEpIC8gMjtcblx0XHRcdGNvbnN0IHh5ID0gKG0xMiArIG0yMSkgLyA0O1xuXHRcdFx0Y29uc3QgeHogPSAobTEzICsgbTMxKSAvIDQ7XG5cdFx0XHRjb25zdCB5eiA9IChtMjMgKyBtMzIpIC8gNDtcblx0XHRcdGlmICh4eCA+IHl5ICYmIHh4ID4genopIHtcblx0XHRcdFx0Ly8gbTExIGlzIHRoZSBsYXJnZXN0IGRpYWdvbmFsIHRlcm1cblxuXHRcdFx0XHRpZiAoeHggPCBlcHNpbG9uKSB7XG5cdFx0XHRcdFx0eCA9IDA7XG5cdFx0XHRcdFx0eSA9IDAuNzA3MTA2NzgxO1xuXHRcdFx0XHRcdHogPSAwLjcwNzEwNjc4MTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR4ID0gTWF0aC5zcXJ0KHh4KTtcblx0XHRcdFx0XHR5ID0geHkgLyB4O1xuXHRcdFx0XHRcdHogPSB4eiAvIHg7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoeXkgPiB6eikge1xuXHRcdFx0XHQvLyBtMjIgaXMgdGhlIGxhcmdlc3QgZGlhZ29uYWwgdGVybVxuXG5cdFx0XHRcdGlmICh5eSA8IGVwc2lsb24pIHtcblx0XHRcdFx0XHR4ID0gMC43MDcxMDY3ODE7XG5cdFx0XHRcdFx0eSA9IDA7XG5cdFx0XHRcdFx0eiA9IDAuNzA3MTA2NzgxO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHkgPSBNYXRoLnNxcnQoeXkpO1xuXHRcdFx0XHRcdHggPSB4eSAvIHk7XG5cdFx0XHRcdFx0eiA9IHl6IC8geTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gbTMzIGlzIHRoZSBsYXJnZXN0IGRpYWdvbmFsIHRlcm0gc28gYmFzZSByZXN1bHQgb24gdGhpc1xuXG5cdFx0XHRcdGlmICh6eiA8IGVwc2lsb24pIHtcblx0XHRcdFx0XHR4ID0gMC43MDcxMDY3ODE7XG5cdFx0XHRcdFx0eSA9IDAuNzA3MTA2NzgxO1xuXHRcdFx0XHRcdHogPSAwO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHogPSBNYXRoLnNxcnQoenopO1xuXHRcdFx0XHRcdHggPSB4eiAvIHo7XG5cdFx0XHRcdFx0eSA9IHl6IC8gejtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5zZXQoeCwgeSwgeiwgYW5nbGUpO1xuXHRcdFx0cmV0dXJuIHRoaXM7IC8vIHJldHVybiAxODAgZGVnIHJvdGF0aW9uXG5cdFx0fVxuXG5cdFx0Ly8gYXMgd2UgaGF2ZSByZWFjaGVkIGhlcmUgdGhlcmUgYXJlIG5vIHNpbmd1bGFyaXRpZXMgc28gd2UgY2FuIGhhbmRsZSBub3JtYWxseVxuXG5cdFx0bGV0IHMgPSBNYXRoLnNxcnQoKG0zMiAtIG0yMykgKiAobTMyIC0gbTIzKSArIChtMTMgLSBtMzEpICogKG0xMyAtIG0zMSkgKyAobTIxIC0gbTEyKSAqIChtMjEgLSBtMTIpKTsgLy8gdXNlZCB0byBub3JtYWxpemVcblxuXHRcdGlmIChNYXRoLmFicyhzKSA8IDAuMDAxKSBzID0gMTtcblxuXHRcdC8vIHByZXZlbnQgZGl2aWRlIGJ5IHplcm8sIHNob3VsZCBub3QgaGFwcGVuIGlmIG1hdHJpeCBpcyBvcnRob2dvbmFsIGFuZCBzaG91bGQgYmVcblx0XHQvLyBjYXVnaHQgYnkgc2luZ3VsYXJpdHkgdGVzdCBhYm92ZSwgYnV0IEkndmUgbGVmdCBpdCBpbiBqdXN0IGluIGNhc2VcblxuXHRcdHRoaXMueCA9IChtMzIgLSBtMjMpIC8gcztcblx0XHR0aGlzLnkgPSAobTEzIC0gbTMxKSAvIHM7XG5cdFx0dGhpcy56ID0gKG0yMSAtIG0xMikgLyBzO1xuXHRcdHRoaXMudyA9IE1hdGguYWNvcygobTExICsgbTIyICsgbTMzIC0gMSkgLyAyKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRtaW4odikge1xuXHRcdHRoaXMueCA9IE1hdGgubWluKHRoaXMueCwgdi54KTtcblx0XHR0aGlzLnkgPSBNYXRoLm1pbih0aGlzLnksIHYueSk7XG5cdFx0dGhpcy56ID0gTWF0aC5taW4odGhpcy56LCB2LnopO1xuXHRcdHRoaXMudyA9IE1hdGgubWluKHRoaXMudywgdi53KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRtYXgodikge1xuXHRcdHRoaXMueCA9IE1hdGgubWF4KHRoaXMueCwgdi54KTtcblx0XHR0aGlzLnkgPSBNYXRoLm1heCh0aGlzLnksIHYueSk7XG5cdFx0dGhpcy56ID0gTWF0aC5tYXgodGhpcy56LCB2LnopO1xuXHRcdHRoaXMudyA9IE1hdGgubWF4KHRoaXMudywgdi53KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRjbGFtcChtaW4sIG1heCkge1xuXHRcdC8vIGFzc3VtZXMgbWluIDwgbWF4LCBjb21wb25lbnR3aXNlXG5cblx0XHR0aGlzLnggPSBNYXRoLm1heChtaW4ueCwgTWF0aC5taW4obWF4LngsIHRoaXMueCkpO1xuXHRcdHRoaXMueSA9IE1hdGgubWF4KG1pbi55LCBNYXRoLm1pbihtYXgueSwgdGhpcy55KSk7XG5cdFx0dGhpcy56ID0gTWF0aC5tYXgobWluLnosIE1hdGgubWluKG1heC56LCB0aGlzLnopKTtcblx0XHR0aGlzLncgPSBNYXRoLm1heChtaW4udywgTWF0aC5taW4obWF4LncsIHRoaXMudykpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGNsYW1wU2NhbGFyKG1pblZhbCwgbWF4VmFsKSB7XG5cdFx0dGhpcy54ID0gTWF0aC5tYXgobWluVmFsLCBNYXRoLm1pbihtYXhWYWwsIHRoaXMueCkpO1xuXHRcdHRoaXMueSA9IE1hdGgubWF4KG1pblZhbCwgTWF0aC5taW4obWF4VmFsLCB0aGlzLnkpKTtcblx0XHR0aGlzLnogPSBNYXRoLm1heChtaW5WYWwsIE1hdGgubWluKG1heFZhbCwgdGhpcy56KSk7XG5cdFx0dGhpcy53ID0gTWF0aC5tYXgobWluVmFsLCBNYXRoLm1pbihtYXhWYWwsIHRoaXMudykpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGNsYW1wTGVuZ3RoKG1pbiwgbWF4KSB7XG5cdFx0Y29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcblx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIobGVuZ3RoIHx8IDEpLm11bHRpcGx5U2NhbGFyKE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCBsZW5ndGgpKSk7XG5cdH1cblx0Zmxvb3IoKSB7XG5cdFx0dGhpcy54ID0gTWF0aC5mbG9vcih0aGlzLngpO1xuXHRcdHRoaXMueSA9IE1hdGguZmxvb3IodGhpcy55KTtcblx0XHR0aGlzLnogPSBNYXRoLmZsb29yKHRoaXMueik7XG5cdFx0dGhpcy53ID0gTWF0aC5mbG9vcih0aGlzLncpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGNlaWwoKSB7XG5cdFx0dGhpcy54ID0gTWF0aC5jZWlsKHRoaXMueCk7XG5cdFx0dGhpcy55ID0gTWF0aC5jZWlsKHRoaXMueSk7XG5cdFx0dGhpcy56ID0gTWF0aC5jZWlsKHRoaXMueik7XG5cdFx0dGhpcy53ID0gTWF0aC5jZWlsKHRoaXMudyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0cm91bmQoKSB7XG5cdFx0dGhpcy54ID0gTWF0aC5yb3VuZCh0aGlzLngpO1xuXHRcdHRoaXMueSA9IE1hdGgucm91bmQodGhpcy55KTtcblx0XHR0aGlzLnogPSBNYXRoLnJvdW5kKHRoaXMueik7XG5cdFx0dGhpcy53ID0gTWF0aC5yb3VuZCh0aGlzLncpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHJvdW5kVG9aZXJvKCkge1xuXHRcdHRoaXMueCA9IHRoaXMueCA8IDAgPyBNYXRoLmNlaWwodGhpcy54KSA6IE1hdGguZmxvb3IodGhpcy54KTtcblx0XHR0aGlzLnkgPSB0aGlzLnkgPCAwID8gTWF0aC5jZWlsKHRoaXMueSkgOiBNYXRoLmZsb29yKHRoaXMueSk7XG5cdFx0dGhpcy56ID0gdGhpcy56IDwgMCA/IE1hdGguY2VpbCh0aGlzLnopIDogTWF0aC5mbG9vcih0aGlzLnopO1xuXHRcdHRoaXMudyA9IHRoaXMudyA8IDAgPyBNYXRoLmNlaWwodGhpcy53KSA6IE1hdGguZmxvb3IodGhpcy53KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRuZWdhdGUoKSB7XG5cdFx0dGhpcy54ID0gLXRoaXMueDtcblx0XHR0aGlzLnkgPSAtdGhpcy55O1xuXHRcdHRoaXMueiA9IC10aGlzLno7XG5cdFx0dGhpcy53ID0gLXRoaXMudztcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRkb3Qodikge1xuXHRcdHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2LnkgKyB0aGlzLnogKiB2LnogKyB0aGlzLncgKiB2Lnc7XG5cdH1cblx0bGVuZ3RoU3EoKSB7XG5cdFx0cmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiArIHRoaXMudyAqIHRoaXMudztcblx0fVxuXHRsZW5ndGgoKSB7XG5cdFx0cmV0dXJuIE1hdGguc3FydCh0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKyB0aGlzLncgKiB0aGlzLncpO1xuXHR9XG5cdG1hbmhhdHRhbkxlbmd0aCgpIHtcblx0XHRyZXR1cm4gTWF0aC5hYnModGhpcy54KSArIE1hdGguYWJzKHRoaXMueSkgKyBNYXRoLmFicyh0aGlzLnopICsgTWF0aC5hYnModGhpcy53KTtcblx0fVxuXHRub3JtYWxpemUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKHRoaXMubGVuZ3RoKCkgfHwgMSk7XG5cdH1cblx0c2V0TGVuZ3RoKGxlbmd0aCkge1xuXHRcdHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKGxlbmd0aCk7XG5cdH1cblx0bGVycCh2LCBhbHBoYSkge1xuXHRcdHRoaXMueCArPSAodi54IC0gdGhpcy54KSAqIGFscGhhO1xuXHRcdHRoaXMueSArPSAodi55IC0gdGhpcy55KSAqIGFscGhhO1xuXHRcdHRoaXMueiArPSAodi56IC0gdGhpcy56KSAqIGFscGhhO1xuXHRcdHRoaXMudyArPSAodi53IC0gdGhpcy53KSAqIGFscGhhO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGxlcnBWZWN0b3JzKHYxLCB2MiwgYWxwaGEpIHtcblx0XHR0aGlzLnggPSB2MS54ICsgKHYyLnggLSB2MS54KSAqIGFscGhhO1xuXHRcdHRoaXMueSA9IHYxLnkgKyAodjIueSAtIHYxLnkpICogYWxwaGE7XG5cdFx0dGhpcy56ID0gdjEueiArICh2Mi56IC0gdjEueikgKiBhbHBoYTtcblx0XHR0aGlzLncgPSB2MS53ICsgKHYyLncgLSB2MS53KSAqIGFscGhhO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGVxdWFscyh2KSB7XG5cdFx0cmV0dXJuIHYueCA9PT0gdGhpcy54ICYmIHYueSA9PT0gdGhpcy55ICYmIHYueiA9PT0gdGhpcy56ICYmIHYudyA9PT0gdGhpcy53O1xuXHR9XG5cdGZyb21BcnJheShhcnJheSwgb2Zmc2V0ID0gMCkge1xuXHRcdHRoaXMueCA9IGFycmF5W29mZnNldF07XG5cdFx0dGhpcy55ID0gYXJyYXlbb2Zmc2V0ICsgMV07XG5cdFx0dGhpcy56ID0gYXJyYXlbb2Zmc2V0ICsgMl07XG5cdFx0dGhpcy53ID0gYXJyYXlbb2Zmc2V0ICsgM107XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0dG9BcnJheShhcnJheSA9IFtdLCBvZmZzZXQgPSAwKSB7XG5cdFx0YXJyYXlbb2Zmc2V0XSA9IHRoaXMueDtcblx0XHRhcnJheVtvZmZzZXQgKyAxXSA9IHRoaXMueTtcblx0XHRhcnJheVtvZmZzZXQgKyAyXSA9IHRoaXMuejtcblx0XHRhcnJheVtvZmZzZXQgKyAzXSA9IHRoaXMudztcblx0XHRyZXR1cm4gYXJyYXk7XG5cdH1cblx0ZnJvbUJ1ZmZlckF0dHJpYnV0ZShhdHRyaWJ1dGUsIGluZGV4KSB7XG5cdFx0dGhpcy54ID0gYXR0cmlidXRlLmdldFgoaW5kZXgpO1xuXHRcdHRoaXMueSA9IGF0dHJpYnV0ZS5nZXRZKGluZGV4KTtcblx0XHR0aGlzLnogPSBhdHRyaWJ1dGUuZ2V0WihpbmRleCk7XG5cdFx0dGhpcy53ID0gYXR0cmlidXRlLmdldFcoaW5kZXgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHJhbmRvbSgpIHtcblx0XHR0aGlzLnggPSBNYXRoLnJhbmRvbSgpO1xuXHRcdHRoaXMueSA9IE1hdGgucmFuZG9tKCk7XG5cdFx0dGhpcy56ID0gTWF0aC5yYW5kb20oKTtcblx0XHR0aGlzLncgPSBNYXRoLnJhbmRvbSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdCpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcblx0XHR5aWVsZCB0aGlzLng7XG5cdFx0eWllbGQgdGhpcy55O1xuXHRcdHlpZWxkIHRoaXMuejtcblx0XHR5aWVsZCB0aGlzLnc7XG5cdH1cbn1cblxuLypcbiBJbiBvcHRpb25zLCB3ZSBjYW4gc3BlY2lmeTpcbiAqIFRleHR1cmUgcGFyYW1ldGVycyBmb3IgYW4gYXV0by1nZW5lcmF0ZWQgdGFyZ2V0IHRleHR1cmVcbiAqIGRlcHRoQnVmZmVyL3N0ZW5jaWxCdWZmZXI6IEJvb2xlYW5zIHRvIGluZGljYXRlIGlmIHdlIHNob3VsZCBnZW5lcmF0ZSB0aGVzZSBidWZmZXJzXG4qL1xuY2xhc3MgV2ViR0xSZW5kZXJUYXJnZXQgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXIge1xuXHRjb25zdHJ1Y3Rvcih3aWR0aCA9IDEsIGhlaWdodCA9IDEsIG9wdGlvbnMgPSB7fSkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5pc1dlYkdMUmVuZGVyVGFyZ2V0ID0gdHJ1ZTtcblx0XHR0aGlzLndpZHRoID0gd2lkdGg7XG5cdFx0dGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0dGhpcy5kZXB0aCA9IDE7XG5cdFx0dGhpcy5zY2lzc29yID0gbmV3IFZlY3RvcjQoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cdFx0dGhpcy5zY2lzc29yVGVzdCA9IGZhbHNlO1xuXHRcdHRoaXMudmlld3BvcnQgPSBuZXcgVmVjdG9yNCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblx0XHRjb25zdCBpbWFnZSA9IHtcblx0XHRcdHdpZHRoOiB3aWR0aCxcblx0XHRcdGhlaWdodDogaGVpZ2h0LFxuXHRcdFx0ZGVwdGg6IDFcblx0XHR9O1xuXHRcdHRoaXMudGV4dHVyZSA9IG5ldyBUZXh0dXJlKGltYWdlLCBvcHRpb25zLm1hcHBpbmcsIG9wdGlvbnMud3JhcFMsIG9wdGlvbnMud3JhcFQsIG9wdGlvbnMubWFnRmlsdGVyLCBvcHRpb25zLm1pbkZpbHRlciwgb3B0aW9ucy5mb3JtYXQsIG9wdGlvbnMudHlwZSwgb3B0aW9ucy5hbmlzb3Ryb3B5LCBvcHRpb25zLmVuY29kaW5nKTtcblx0XHR0aGlzLnRleHR1cmUuaXNSZW5kZXJUYXJnZXRUZXh0dXJlID0gdHJ1ZTtcblx0XHR0aGlzLnRleHR1cmUuZmxpcFkgPSBmYWxzZTtcblx0XHR0aGlzLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gb3B0aW9ucy5nZW5lcmF0ZU1pcG1hcHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZ2VuZXJhdGVNaXBtYXBzIDogZmFsc2U7XG5cdFx0dGhpcy50ZXh0dXJlLmludGVybmFsRm9ybWF0ID0gb3B0aW9ucy5pbnRlcm5hbEZvcm1hdCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5pbnRlcm5hbEZvcm1hdCA6IG51bGw7XG5cdFx0dGhpcy50ZXh0dXJlLm1pbkZpbHRlciA9IG9wdGlvbnMubWluRmlsdGVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1pbkZpbHRlciA6IExpbmVhckZpbHRlcjtcblx0XHR0aGlzLmRlcHRoQnVmZmVyID0gb3B0aW9ucy5kZXB0aEJ1ZmZlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kZXB0aEJ1ZmZlciA6IHRydWU7XG5cdFx0dGhpcy5zdGVuY2lsQnVmZmVyID0gb3B0aW9ucy5zdGVuY2lsQnVmZmVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0ZW5jaWxCdWZmZXIgOiBmYWxzZTtcblx0XHR0aGlzLmRlcHRoVGV4dHVyZSA9IG9wdGlvbnMuZGVwdGhUZXh0dXJlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRlcHRoVGV4dHVyZSA6IG51bGw7XG5cdFx0dGhpcy5zYW1wbGVzID0gb3B0aW9ucy5zYW1wbGVzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnNhbXBsZXMgOiAwO1xuXHR9XG5cdHNldFNpemUod2lkdGgsIGhlaWdodCwgZGVwdGggPSAxKSB7XG5cdFx0aWYgKHRoaXMud2lkdGggIT09IHdpZHRoIHx8IHRoaXMuaGVpZ2h0ICE9PSBoZWlnaHQgfHwgdGhpcy5kZXB0aCAhPT0gZGVwdGgpIHtcblx0XHRcdHRoaXMud2lkdGggPSB3aWR0aDtcblx0XHRcdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdFx0dGhpcy5kZXB0aCA9IGRlcHRoO1xuXHRcdFx0dGhpcy50ZXh0dXJlLmltYWdlLndpZHRoID0gd2lkdGg7XG5cdFx0XHR0aGlzLnRleHR1cmUuaW1hZ2UuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdFx0dGhpcy50ZXh0dXJlLmltYWdlLmRlcHRoID0gZGVwdGg7XG5cdFx0XHR0aGlzLmRpc3Bvc2UoKTtcblx0XHR9XG5cdFx0dGhpcy52aWV3cG9ydC5zZXQoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cdFx0dGhpcy5zY2lzc29yLnNldCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblx0fVxuXHRjbG9uZSgpIHtcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpO1xuXHR9XG5cdGNvcHkoc291cmNlKSB7XG5cdFx0dGhpcy53aWR0aCA9IHNvdXJjZS53aWR0aDtcblx0XHR0aGlzLmhlaWdodCA9IHNvdXJjZS5oZWlnaHQ7XG5cdFx0dGhpcy5kZXB0aCA9IHNvdXJjZS5kZXB0aDtcblx0XHR0aGlzLnZpZXdwb3J0LmNvcHkoc291cmNlLnZpZXdwb3J0KTtcblx0XHR0aGlzLnRleHR1cmUgPSBzb3VyY2UudGV4dHVyZS5jbG9uZSgpO1xuXHRcdHRoaXMudGV4dHVyZS5pc1JlbmRlclRhcmdldFRleHR1cmUgPSB0cnVlO1xuXG5cdFx0Ly8gZW5zdXJlIGltYWdlIG9iamVjdCBpcyBub3Qgc2hhcmVkLCBzZWUgIzIwMzI4XG5cblx0XHRjb25zdCBpbWFnZSA9IE9iamVjdC5hc3NpZ24oe30sIHNvdXJjZS50ZXh0dXJlLmltYWdlKTtcblx0XHR0aGlzLnRleHR1cmUuc291cmNlID0gbmV3IFNvdXJjZShpbWFnZSk7XG5cdFx0dGhpcy5kZXB0aEJ1ZmZlciA9IHNvdXJjZS5kZXB0aEJ1ZmZlcjtcblx0XHR0aGlzLnN0ZW5jaWxCdWZmZXIgPSBzb3VyY2Uuc3RlbmNpbEJ1ZmZlcjtcblx0XHRpZiAoc291cmNlLmRlcHRoVGV4dHVyZSAhPT0gbnVsbCkgdGhpcy5kZXB0aFRleHR1cmUgPSBzb3VyY2UuZGVwdGhUZXh0dXJlLmNsb25lKCk7XG5cdFx0dGhpcy5zYW1wbGVzID0gc291cmNlLnNhbXBsZXM7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0ZGlzcG9zZSgpIHtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoe1xuXHRcdFx0dHlwZTogJ2Rpc3Bvc2UnXG5cdFx0fSk7XG5cdH1cbn1cblxuY2xhc3MgRGF0YUFycmF5VGV4dHVyZSBleHRlbmRzIFRleHR1cmUge1xuXHRjb25zdHJ1Y3RvcihkYXRhID0gbnVsbCwgd2lkdGggPSAxLCBoZWlnaHQgPSAxLCBkZXB0aCA9IDEpIHtcblx0XHRzdXBlcihudWxsKTtcblx0XHR0aGlzLmlzRGF0YUFycmF5VGV4dHVyZSA9IHRydWU7XG5cdFx0dGhpcy5pbWFnZSA9IHtcblx0XHRcdGRhdGEsXG5cdFx0XHR3aWR0aCxcblx0XHRcdGhlaWdodCxcblx0XHRcdGRlcHRoXG5cdFx0fTtcblx0XHR0aGlzLm1hZ0ZpbHRlciA9IE5lYXJlc3RGaWx0ZXI7XG5cdFx0dGhpcy5taW5GaWx0ZXIgPSBOZWFyZXN0RmlsdGVyO1xuXHRcdHRoaXMud3JhcFIgPSBDbGFtcFRvRWRnZVdyYXBwaW5nO1xuXHRcdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG5cdFx0dGhpcy5mbGlwWSA9IGZhbHNlO1xuXHRcdHRoaXMudW5wYWNrQWxpZ25tZW50ID0gMTtcblx0fVxufVxuXG5jbGFzcyBXZWJHTEFycmF5UmVuZGVyVGFyZ2V0IGV4dGVuZHMgV2ViR0xSZW5kZXJUYXJnZXQge1xuXHRjb25zdHJ1Y3Rvcih3aWR0aCA9IDEsIGhlaWdodCA9IDEsIGRlcHRoID0gMSkge1xuXHRcdHN1cGVyKHdpZHRoLCBoZWlnaHQpO1xuXHRcdHRoaXMuaXNXZWJHTEFycmF5UmVuZGVyVGFyZ2V0ID0gdHJ1ZTtcblx0XHR0aGlzLmRlcHRoID0gZGVwdGg7XG5cdFx0dGhpcy50ZXh0dXJlID0gbmV3IERhdGFBcnJheVRleHR1cmUobnVsbCwgd2lkdGgsIGhlaWdodCwgZGVwdGgpO1xuXHRcdHRoaXMudGV4dHVyZS5pc1JlbmRlclRhcmdldFRleHR1cmUgPSB0cnVlO1xuXHR9XG59XG5cbmNsYXNzIERhdGEzRFRleHR1cmUgZXh0ZW5kcyBUZXh0dXJlIHtcblx0Y29uc3RydWN0b3IoZGF0YSA9IG51bGwsIHdpZHRoID0gMSwgaGVpZ2h0ID0gMSwgZGVwdGggPSAxKSB7XG5cdFx0Ly8gV2UncmUgZ29pbmcgdG8gYWRkIC5zZXRYWFgoKSBtZXRob2RzIGZvciBzZXR0aW5nIHByb3BlcnRpZXMgbGF0ZXIuXG5cdFx0Ly8gVXNlcnMgY2FuIHN0aWxsIHNldCBpbiBEYXRhVGV4dHVyZTNEIGRpcmVjdGx5LlxuXHRcdC8vXG5cdFx0Ly9cdGNvbnN0IHRleHR1cmUgPSBuZXcgVEhSRUUuRGF0YVRleHR1cmUzRCggZGF0YSwgd2lkdGgsIGhlaWdodCwgZGVwdGggKTtcblx0XHQvLyBcdHRleHR1cmUuYW5pc290cm9weSA9IDE2O1xuXHRcdC8vXG5cdFx0Ly8gU2VlICMxNDgzOVxuXG5cdFx0c3VwZXIobnVsbCk7XG5cdFx0dGhpcy5pc0RhdGEzRFRleHR1cmUgPSB0cnVlO1xuXHRcdHRoaXMuaW1hZ2UgPSB7XG5cdFx0XHRkYXRhLFxuXHRcdFx0d2lkdGgsXG5cdFx0XHRoZWlnaHQsXG5cdFx0XHRkZXB0aFxuXHRcdH07XG5cdFx0dGhpcy5tYWdGaWx0ZXIgPSBOZWFyZXN0RmlsdGVyO1xuXHRcdHRoaXMubWluRmlsdGVyID0gTmVhcmVzdEZpbHRlcjtcblx0XHR0aGlzLndyYXBSID0gQ2xhbXBUb0VkZ2VXcmFwcGluZztcblx0XHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXHRcdHRoaXMuZmxpcFkgPSBmYWxzZTtcblx0XHR0aGlzLnVucGFja0FsaWdubWVudCA9IDE7XG5cdH1cbn1cblxuY2xhc3MgV2ViR0wzRFJlbmRlclRhcmdldCBleHRlbmRzIFdlYkdMUmVuZGVyVGFyZ2V0IHtcblx0Y29uc3RydWN0b3Iod2lkdGggPSAxLCBoZWlnaHQgPSAxLCBkZXB0aCA9IDEpIHtcblx0XHRzdXBlcih3aWR0aCwgaGVpZ2h0KTtcblx0XHR0aGlzLmlzV2ViR0wzRFJlbmRlclRhcmdldCA9IHRydWU7XG5cdFx0dGhpcy5kZXB0aCA9IGRlcHRoO1xuXHRcdHRoaXMudGV4dHVyZSA9IG5ldyBEYXRhM0RUZXh0dXJlKG51bGwsIHdpZHRoLCBoZWlnaHQsIGRlcHRoKTtcblx0XHR0aGlzLnRleHR1cmUuaXNSZW5kZXJUYXJnZXRUZXh0dXJlID0gdHJ1ZTtcblx0fVxufVxuXG5jbGFzcyBXZWJHTE11bHRpcGxlUmVuZGVyVGFyZ2V0cyBleHRlbmRzIFdlYkdMUmVuZGVyVGFyZ2V0IHtcblx0Y29uc3RydWN0b3Iod2lkdGggPSAxLCBoZWlnaHQgPSAxLCBjb3VudCA9IDEsIG9wdGlvbnMgPSB7fSkge1xuXHRcdHN1cGVyKHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpO1xuXHRcdHRoaXMuaXNXZWJHTE11bHRpcGxlUmVuZGVyVGFyZ2V0cyA9IHRydWU7XG5cdFx0Y29uc3QgdGV4dHVyZSA9IHRoaXMudGV4dHVyZTtcblx0XHR0aGlzLnRleHR1cmUgPSBbXTtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcblx0XHRcdHRoaXMudGV4dHVyZVtpXSA9IHRleHR1cmUuY2xvbmUoKTtcblx0XHRcdHRoaXMudGV4dHVyZVtpXS5pc1JlbmRlclRhcmdldFRleHR1cmUgPSB0cnVlO1xuXHRcdH1cblx0fVxuXHRzZXRTaXplKHdpZHRoLCBoZWlnaHQsIGRlcHRoID0gMSkge1xuXHRcdGlmICh0aGlzLndpZHRoICE9PSB3aWR0aCB8fCB0aGlzLmhlaWdodCAhPT0gaGVpZ2h0IHx8IHRoaXMuZGVwdGggIT09IGRlcHRoKSB7XG5cdFx0XHR0aGlzLndpZHRoID0gd2lkdGg7XG5cdFx0XHR0aGlzLmhlaWdodCA9IGhlaWdodDtcblx0XHRcdHRoaXMuZGVwdGggPSBkZXB0aDtcblx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IHRoaXMudGV4dHVyZS5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMudGV4dHVyZVtpXS5pbWFnZS53aWR0aCA9IHdpZHRoO1xuXHRcdFx0XHR0aGlzLnRleHR1cmVbaV0uaW1hZ2UuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdFx0XHR0aGlzLnRleHR1cmVbaV0uaW1hZ2UuZGVwdGggPSBkZXB0aDtcblx0XHRcdH1cblx0XHRcdHRoaXMuZGlzcG9zZSgpO1xuXHRcdH1cblx0XHR0aGlzLnZpZXdwb3J0LnNldCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblx0XHR0aGlzLnNjaXNzb3Iuc2V0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGNvcHkoc291cmNlKSB7XG5cdFx0dGhpcy5kaXNwb3NlKCk7XG5cdFx0dGhpcy53aWR0aCA9IHNvdXJjZS53aWR0aDtcblx0XHR0aGlzLmhlaWdodCA9IHNvdXJjZS5oZWlnaHQ7XG5cdFx0dGhpcy5kZXB0aCA9IHNvdXJjZS5kZXB0aDtcblx0XHR0aGlzLnZpZXdwb3J0LnNldCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cdFx0dGhpcy5zY2lzc29yLnNldCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cdFx0dGhpcy5kZXB0aEJ1ZmZlciA9IHNvdXJjZS5kZXB0aEJ1ZmZlcjtcblx0XHR0aGlzLnN0ZW5jaWxCdWZmZXIgPSBzb3VyY2Uuc3RlbmNpbEJ1ZmZlcjtcblx0XHRpZiAoc291cmNlLmRlcHRoVGV4dHVyZSAhPT0gbnVsbCkgdGhpcy5kZXB0aFRleHR1cmUgPSBzb3VyY2UuZGVwdGhUZXh0dXJlLmNsb25lKCk7XG5cdFx0dGhpcy50ZXh0dXJlLmxlbmd0aCA9IDA7XG5cdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gc291cmNlLnRleHR1cmUubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0dGhpcy50ZXh0dXJlW2ldID0gc291cmNlLnRleHR1cmVbaV0uY2xvbmUoKTtcblx0XHRcdHRoaXMudGV4dHVyZVtpXS5pc1JlbmRlclRhcmdldFRleHR1cmUgPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufVxuXG5jbGFzcyBRdWF0ZXJuaW9uIHtcblx0Y29uc3RydWN0b3IoeCA9IDAsIHkgPSAwLCB6ID0gMCwgdyA9IDEpIHtcblx0XHR0aGlzLmlzUXVhdGVybmlvbiA9IHRydWU7XG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5feiA9IHo7XG5cdFx0dGhpcy5fdyA9IHc7XG5cdH1cblx0c3RhdGljIHNsZXJwRmxhdChkc3QsIGRzdE9mZnNldCwgc3JjMCwgc3JjT2Zmc2V0MCwgc3JjMSwgc3JjT2Zmc2V0MSwgdCkge1xuXHRcdC8vIGZ1enotZnJlZSwgYXJyYXktYmFzZWQgUXVhdGVybmlvbiBTTEVSUCBvcGVyYXRpb25cblxuXHRcdGxldCB4MCA9IHNyYzBbc3JjT2Zmc2V0MCArIDBdLFxuXHRcdFx0eTAgPSBzcmMwW3NyY09mZnNldDAgKyAxXSxcblx0XHRcdHowID0gc3JjMFtzcmNPZmZzZXQwICsgMl0sXG5cdFx0XHR3MCA9IHNyYzBbc3JjT2Zmc2V0MCArIDNdO1xuXHRcdGNvbnN0IHgxID0gc3JjMVtzcmNPZmZzZXQxICsgMF0sXG5cdFx0XHR5MSA9IHNyYzFbc3JjT2Zmc2V0MSArIDFdLFxuXHRcdFx0ejEgPSBzcmMxW3NyY09mZnNldDEgKyAyXSxcblx0XHRcdHcxID0gc3JjMVtzcmNPZmZzZXQxICsgM107XG5cdFx0aWYgKHQgPT09IDApIHtcblx0XHRcdGRzdFtkc3RPZmZzZXQgKyAwXSA9IHgwO1xuXHRcdFx0ZHN0W2RzdE9mZnNldCArIDFdID0geTA7XG5cdFx0XHRkc3RbZHN0T2Zmc2V0ICsgMl0gPSB6MDtcblx0XHRcdGRzdFtkc3RPZmZzZXQgKyAzXSA9IHcwO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAodCA9PT0gMSkge1xuXHRcdFx0ZHN0W2RzdE9mZnNldCArIDBdID0geDE7XG5cdFx0XHRkc3RbZHN0T2Zmc2V0ICsgMV0gPSB5MTtcblx0XHRcdGRzdFtkc3RPZmZzZXQgKyAyXSA9IHoxO1xuXHRcdFx0ZHN0W2RzdE9mZnNldCArIDNdID0gdzE7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmICh3MCAhPT0gdzEgfHwgeDAgIT09IHgxIHx8IHkwICE9PSB5MSB8fCB6MCAhPT0gejEpIHtcblx0XHRcdGxldCBzID0gMSAtIHQ7XG5cdFx0XHRjb25zdCBjb3MgPSB4MCAqIHgxICsgeTAgKiB5MSArIHowICogejEgKyB3MCAqIHcxLFxuXHRcdFx0XHRkaXIgPSBjb3MgPj0gMCA/IDEgOiAtMSxcblx0XHRcdFx0c3FyU2luID0gMSAtIGNvcyAqIGNvcztcblxuXHRcdFx0Ly8gU2tpcCB0aGUgU2xlcnAgZm9yIHRpbnkgc3RlcHMgdG8gYXZvaWQgbnVtZXJpYyBwcm9ibGVtczpcblx0XHRcdGlmIChzcXJTaW4gPiBOdW1iZXIuRVBTSUxPTikge1xuXHRcdFx0XHRjb25zdCBzaW4gPSBNYXRoLnNxcnQoc3FyU2luKSxcblx0XHRcdFx0XHRsZW4gPSBNYXRoLmF0YW4yKHNpbiwgY29zICogZGlyKTtcblx0XHRcdFx0cyA9IE1hdGguc2luKHMgKiBsZW4pIC8gc2luO1xuXHRcdFx0XHR0ID0gTWF0aC5zaW4odCAqIGxlbikgLyBzaW47XG5cdFx0XHR9XG5cdFx0XHRjb25zdCB0RGlyID0gdCAqIGRpcjtcblx0XHRcdHgwID0geDAgKiBzICsgeDEgKiB0RGlyO1xuXHRcdFx0eTAgPSB5MCAqIHMgKyB5MSAqIHREaXI7XG5cdFx0XHR6MCA9IHowICogcyArIHoxICogdERpcjtcblx0XHRcdHcwID0gdzAgKiBzICsgdzEgKiB0RGlyO1xuXG5cdFx0XHQvLyBOb3JtYWxpemUgaW4gY2FzZSB3ZSBqdXN0IGRpZCBhIGxlcnA6XG5cdFx0XHRpZiAocyA9PT0gMSAtIHQpIHtcblx0XHRcdFx0Y29uc3QgZiA9IDEgLyBNYXRoLnNxcnQoeDAgKiB4MCArIHkwICogeTAgKyB6MCAqIHowICsgdzAgKiB3MCk7XG5cdFx0XHRcdHgwICo9IGY7XG5cdFx0XHRcdHkwICo9IGY7XG5cdFx0XHRcdHowICo9IGY7XG5cdFx0XHRcdHcwICo9IGY7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGRzdFtkc3RPZmZzZXRdID0geDA7XG5cdFx0ZHN0W2RzdE9mZnNldCArIDFdID0geTA7XG5cdFx0ZHN0W2RzdE9mZnNldCArIDJdID0gejA7XG5cdFx0ZHN0W2RzdE9mZnNldCArIDNdID0gdzA7XG5cdH1cblx0c3RhdGljIG11bHRpcGx5UXVhdGVybmlvbnNGbGF0KGRzdCwgZHN0T2Zmc2V0LCBzcmMwLCBzcmNPZmZzZXQwLCBzcmMxLCBzcmNPZmZzZXQxKSB7XG5cdFx0Y29uc3QgeDAgPSBzcmMwW3NyY09mZnNldDBdO1xuXHRcdGNvbnN0IHkwID0gc3JjMFtzcmNPZmZzZXQwICsgMV07XG5cdFx0Y29uc3QgejAgPSBzcmMwW3NyY09mZnNldDAgKyAyXTtcblx0XHRjb25zdCB3MCA9IHNyYzBbc3JjT2Zmc2V0MCArIDNdO1xuXHRcdGNvbnN0IHgxID0gc3JjMVtzcmNPZmZzZXQxXTtcblx0XHRjb25zdCB5MSA9IHNyYzFbc3JjT2Zmc2V0MSArIDFdO1xuXHRcdGNvbnN0IHoxID0gc3JjMVtzcmNPZmZzZXQxICsgMl07XG5cdFx0Y29uc3QgdzEgPSBzcmMxW3NyY09mZnNldDEgKyAzXTtcblx0XHRkc3RbZHN0T2Zmc2V0XSA9IHgwICogdzEgKyB3MCAqIHgxICsgeTAgKiB6MSAtIHowICogeTE7XG5cdFx0ZHN0W2RzdE9mZnNldCArIDFdID0geTAgKiB3MSArIHcwICogeTEgKyB6MCAqIHgxIC0geDAgKiB6MTtcblx0XHRkc3RbZHN0T2Zmc2V0ICsgMl0gPSB6MCAqIHcxICsgdzAgKiB6MSArIHgwICogeTEgLSB5MCAqIHgxO1xuXHRcdGRzdFtkc3RPZmZzZXQgKyAzXSA9IHcwICogdzEgLSB4MCAqIHgxIC0geTAgKiB5MSAtIHowICogejE7XG5cdFx0cmV0dXJuIGRzdDtcblx0fVxuXHRnZXQgeCgpIHtcblx0XHRyZXR1cm4gdGhpcy5feDtcblx0fVxuXHRzZXQgeCh2YWx1ZSkge1xuXHRcdHRoaXMuX3ggPSB2YWx1ZTtcblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cdH1cblx0Z2V0IHkoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3k7XG5cdH1cblx0c2V0IHkodmFsdWUpIHtcblx0XHR0aGlzLl95ID0gdmFsdWU7XG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXHR9XG5cdGdldCB6KCkge1xuXHRcdHJldHVybiB0aGlzLl96O1xuXHR9XG5cdHNldCB6KHZhbHVlKSB7XG5cdFx0dGhpcy5feiA9IHZhbHVlO1xuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblx0fVxuXHRnZXQgdygpIHtcblx0XHRyZXR1cm4gdGhpcy5fdztcblx0fVxuXHRzZXQgdyh2YWx1ZSkge1xuXHRcdHRoaXMuX3cgPSB2YWx1ZTtcblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cdH1cblx0c2V0KHgsIHksIHosIHcpIHtcblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl96ID0gejtcblx0XHR0aGlzLl93ID0gdztcblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0Y2xvbmUoKSB7XG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3osIHRoaXMuX3cpO1xuXHR9XG5cdGNvcHkocXVhdGVybmlvbikge1xuXHRcdHRoaXMuX3ggPSBxdWF0ZXJuaW9uLng7XG5cdFx0dGhpcy5feSA9IHF1YXRlcm5pb24ueTtcblx0XHR0aGlzLl96ID0gcXVhdGVybmlvbi56O1xuXHRcdHRoaXMuX3cgPSBxdWF0ZXJuaW9uLnc7XG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHNldEZyb21FdWxlcihldWxlciwgdXBkYXRlKSB7XG5cdFx0Y29uc3QgeCA9IGV1bGVyLl94LFxuXHRcdFx0eSA9IGV1bGVyLl95LFxuXHRcdFx0eiA9IGV1bGVyLl96LFxuXHRcdFx0b3JkZXIgPSBldWxlci5fb3JkZXI7XG5cblx0XHQvLyBodHRwOi8vd3d3Lm1hdGh3b3Jrcy5jb20vbWF0bGFiY2VudHJhbC9maWxlZXhjaGFuZ2UvXG5cdFx0Ly8gXHQyMDY5Ni1mdW5jdGlvbi10by1jb252ZXJ0LWJldHdlZW4tZGNtLWV1bGVyLWFuZ2xlcy1xdWF0ZXJuaW9ucy1hbmQtZXVsZXItdmVjdG9ycy9cblx0XHQvL1x0Y29udGVudC9TcGluQ2FsYy5tXG5cblx0XHRjb25zdCBjb3MgPSBNYXRoLmNvcztcblx0XHRjb25zdCBzaW4gPSBNYXRoLnNpbjtcblx0XHRjb25zdCBjMSA9IGNvcyh4IC8gMik7XG5cdFx0Y29uc3QgYzIgPSBjb3MoeSAvIDIpO1xuXHRcdGNvbnN0IGMzID0gY29zKHogLyAyKTtcblx0XHRjb25zdCBzMSA9IHNpbih4IC8gMik7XG5cdFx0Y29uc3QgczIgPSBzaW4oeSAvIDIpO1xuXHRcdGNvbnN0IHMzID0gc2luKHogLyAyKTtcblx0XHRzd2l0Y2ggKG9yZGVyKSB7XG5cdFx0XHRjYXNlICdYWVonOlxuXHRcdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuXHRcdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ1lYWic6XG5cdFx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7XG5cdFx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XG5cdFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG5cdFx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnWlhZJzpcblx0XHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcblx0XHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcblx0XHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMztcblx0XHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdaWVgnOlxuXHRcdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xuXHRcdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ1laWCc6XG5cdFx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7XG5cdFx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XG5cdFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG5cdFx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnWFpZJzpcblx0XHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcblx0XHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcblx0XHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMztcblx0XHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlF1YXRlcm5pb246IC5zZXRGcm9tRXVsZXIoKSBlbmNvdW50ZXJlZCBhbiB1bmtub3duIG9yZGVyOiAnICsgb3JkZXIpO1xuXHRcdH1cblx0XHRpZiAodXBkYXRlICE9PSBmYWxzZSkgdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHNldEZyb21BeGlzQW5nbGUoYXhpcywgYW5nbGUpIHtcblx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvYW5nbGVUb1F1YXRlcm5pb24vaW5kZXguaHRtXG5cblx0XHQvLyBhc3N1bWVzIGF4aXMgaXMgbm9ybWFsaXplZFxuXG5cdFx0Y29uc3QgaGFsZkFuZ2xlID0gYW5nbGUgLyAyLFxuXHRcdFx0cyA9IE1hdGguc2luKGhhbGZBbmdsZSk7XG5cdFx0dGhpcy5feCA9IGF4aXMueCAqIHM7XG5cdFx0dGhpcy5feSA9IGF4aXMueSAqIHM7XG5cdFx0dGhpcy5feiA9IGF4aXMueiAqIHM7XG5cdFx0dGhpcy5fdyA9IE1hdGguY29zKGhhbGZBbmdsZSk7XG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHNldEZyb21Sb3RhdGlvbk1hdHJpeChtKSB7XG5cdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL21hdHJpeFRvUXVhdGVybmlvbi9pbmRleC5odG1cblxuXHRcdC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXG5cblx0XHRjb25zdCB0ZSA9IG0uZWxlbWVudHMsXG5cdFx0XHRtMTEgPSB0ZVswXSxcblx0XHRcdG0xMiA9IHRlWzRdLFxuXHRcdFx0bTEzID0gdGVbOF0sXG5cdFx0XHRtMjEgPSB0ZVsxXSxcblx0XHRcdG0yMiA9IHRlWzVdLFxuXHRcdFx0bTIzID0gdGVbOV0sXG5cdFx0XHRtMzEgPSB0ZVsyXSxcblx0XHRcdG0zMiA9IHRlWzZdLFxuXHRcdFx0bTMzID0gdGVbMTBdLFxuXHRcdFx0dHJhY2UgPSBtMTEgKyBtMjIgKyBtMzM7XG5cdFx0aWYgKHRyYWNlID4gMCkge1xuXHRcdFx0Y29uc3QgcyA9IDAuNSAvIE1hdGguc3FydCh0cmFjZSArIDEuMCk7XG5cdFx0XHR0aGlzLl93ID0gMC4yNSAvIHM7XG5cdFx0XHR0aGlzLl94ID0gKG0zMiAtIG0yMykgKiBzO1xuXHRcdFx0dGhpcy5feSA9IChtMTMgLSBtMzEpICogcztcblx0XHRcdHRoaXMuX3ogPSAobTIxIC0gbTEyKSAqIHM7XG5cdFx0fSBlbHNlIGlmIChtMTEgPiBtMjIgJiYgbTExID4gbTMzKSB7XG5cdFx0XHRjb25zdCBzID0gMi4wICogTWF0aC5zcXJ0KDEuMCArIG0xMSAtIG0yMiAtIG0zMyk7XG5cdFx0XHR0aGlzLl93ID0gKG0zMiAtIG0yMykgLyBzO1xuXHRcdFx0dGhpcy5feCA9IDAuMjUgKiBzO1xuXHRcdFx0dGhpcy5feSA9IChtMTIgKyBtMjEpIC8gcztcblx0XHRcdHRoaXMuX3ogPSAobTEzICsgbTMxKSAvIHM7XG5cdFx0fSBlbHNlIGlmIChtMjIgPiBtMzMpIHtcblx0XHRcdGNvbnN0IHMgPSAyLjAgKiBNYXRoLnNxcnQoMS4wICsgbTIyIC0gbTExIC0gbTMzKTtcblx0XHRcdHRoaXMuX3cgPSAobTEzIC0gbTMxKSAvIHM7XG5cdFx0XHR0aGlzLl94ID0gKG0xMiArIG0yMSkgLyBzO1xuXHRcdFx0dGhpcy5feSA9IDAuMjUgKiBzO1xuXHRcdFx0dGhpcy5feiA9IChtMjMgKyBtMzIpIC8gcztcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3QgcyA9IDIuMCAqIE1hdGguc3FydCgxLjAgKyBtMzMgLSBtMTEgLSBtMjIpO1xuXHRcdFx0dGhpcy5fdyA9IChtMjEgLSBtMTIpIC8gcztcblx0XHRcdHRoaXMuX3ggPSAobTEzICsgbTMxKSAvIHM7XG5cdFx0XHR0aGlzLl95ID0gKG0yMyArIG0zMikgLyBzO1xuXHRcdFx0dGhpcy5feiA9IDAuMjUgKiBzO1xuXHRcdH1cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0c2V0RnJvbVVuaXRWZWN0b3JzKHZGcm9tLCB2VG8pIHtcblx0XHQvLyBhc3N1bWVzIGRpcmVjdGlvbiB2ZWN0b3JzIHZGcm9tIGFuZCB2VG8gYXJlIG5vcm1hbGl6ZWRcblxuXHRcdGxldCByID0gdkZyb20uZG90KHZUbykgKyAxO1xuXHRcdGlmIChyIDwgTnVtYmVyLkVQU0lMT04pIHtcblx0XHRcdC8vIHZGcm9tIGFuZCB2VG8gcG9pbnQgaW4gb3Bwb3NpdGUgZGlyZWN0aW9uc1xuXG5cdFx0XHRyID0gMDtcblx0XHRcdGlmIChNYXRoLmFicyh2RnJvbS54KSA+IE1hdGguYWJzKHZGcm9tLnopKSB7XG5cdFx0XHRcdHRoaXMuX3ggPSAtdkZyb20ueTtcblx0XHRcdFx0dGhpcy5feSA9IHZGcm9tLng7XG5cdFx0XHRcdHRoaXMuX3ogPSAwO1xuXHRcdFx0XHR0aGlzLl93ID0gcjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX3ggPSAwO1xuXHRcdFx0XHR0aGlzLl95ID0gLXZGcm9tLno7XG5cdFx0XHRcdHRoaXMuX3ogPSB2RnJvbS55O1xuXHRcdFx0XHR0aGlzLl93ID0gcjtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gY3Jvc3NWZWN0b3JzKCB2RnJvbSwgdlRvICk7IC8vIGlubGluZWQgdG8gYXZvaWQgY3ljbGljIGRlcGVuZGVuY3kgb24gVmVjdG9yM1xuXG5cdFx0XHR0aGlzLl94ID0gdkZyb20ueSAqIHZUby56IC0gdkZyb20ueiAqIHZUby55O1xuXHRcdFx0dGhpcy5feSA9IHZGcm9tLnogKiB2VG8ueCAtIHZGcm9tLnggKiB2VG8uejtcblx0XHRcdHRoaXMuX3ogPSB2RnJvbS54ICogdlRvLnkgLSB2RnJvbS55ICogdlRvLng7XG5cdFx0XHR0aGlzLl93ID0gcjtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKCk7XG5cdH1cblx0YW5nbGVUbyhxKSB7XG5cdFx0cmV0dXJuIDIgKiBNYXRoLmFjb3MoTWF0aC5hYnMoY2xhbXAodGhpcy5kb3QocSksIC0xLCAxKSkpO1xuXHR9XG5cdHJvdGF0ZVRvd2FyZHMocSwgc3RlcCkge1xuXHRcdGNvbnN0IGFuZ2xlID0gdGhpcy5hbmdsZVRvKHEpO1xuXHRcdGlmIChhbmdsZSA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cdFx0Y29uc3QgdCA9IE1hdGgubWluKDEsIHN0ZXAgLyBhbmdsZSk7XG5cdFx0dGhpcy5zbGVycChxLCB0KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRpZGVudGl0eSgpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXQoMCwgMCwgMCwgMSk7XG5cdH1cblx0aW52ZXJ0KCkge1xuXHRcdC8vIHF1YXRlcm5pb24gaXMgYXNzdW1lZCB0byBoYXZlIHVuaXQgbGVuZ3RoXG5cblx0XHRyZXR1cm4gdGhpcy5jb25qdWdhdGUoKTtcblx0fVxuXHRjb25qdWdhdGUoKSB7XG5cdFx0dGhpcy5feCAqPSAtMTtcblx0XHR0aGlzLl95ICo9IC0xO1xuXHRcdHRoaXMuX3ogKj0gLTE7XG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGRvdCh2KSB7XG5cdFx0cmV0dXJuIHRoaXMuX3ggKiB2Ll94ICsgdGhpcy5feSAqIHYuX3kgKyB0aGlzLl96ICogdi5feiArIHRoaXMuX3cgKiB2Ll93O1xuXHR9XG5cdGxlbmd0aFNxKCkge1xuXHRcdHJldHVybiB0aGlzLl94ICogdGhpcy5feCArIHRoaXMuX3kgKiB0aGlzLl95ICsgdGhpcy5feiAqIHRoaXMuX3ogKyB0aGlzLl93ICogdGhpcy5fdztcblx0fVxuXHRsZW5ndGgoKSB7XG5cdFx0cmV0dXJuIE1hdGguc3FydCh0aGlzLl94ICogdGhpcy5feCArIHRoaXMuX3kgKiB0aGlzLl95ICsgdGhpcy5feiAqIHRoaXMuX3ogKyB0aGlzLl93ICogdGhpcy5fdyk7XG5cdH1cblx0bm9ybWFsaXplKCkge1xuXHRcdGxldCBsID0gdGhpcy5sZW5ndGgoKTtcblx0XHRpZiAobCA9PT0gMCkge1xuXHRcdFx0dGhpcy5feCA9IDA7XG5cdFx0XHR0aGlzLl95ID0gMDtcblx0XHRcdHRoaXMuX3ogPSAwO1xuXHRcdFx0dGhpcy5fdyA9IDE7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGwgPSAxIC8gbDtcblx0XHRcdHRoaXMuX3ggPSB0aGlzLl94ICogbDtcblx0XHRcdHRoaXMuX3kgPSB0aGlzLl95ICogbDtcblx0XHRcdHRoaXMuX3ogPSB0aGlzLl96ICogbDtcblx0XHRcdHRoaXMuX3cgPSB0aGlzLl93ICogbDtcblx0XHR9XG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdG11bHRpcGx5KHEpIHtcblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKHRoaXMsIHEpO1xuXHR9XG5cdHByZW11bHRpcGx5KHEpIHtcblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKHEsIHRoaXMpO1xuXHR9XG5cdG11bHRpcGx5UXVhdGVybmlvbnMoYSwgYikge1xuXHRcdC8vIGZyb20gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9yZWFsTm9ybWVkQWxnZWJyYS9xdWF0ZXJuaW9ucy9jb2RlL2luZGV4Lmh0bVxuXG5cdFx0Y29uc3QgcWF4ID0gYS5feCxcblx0XHRcdHFheSA9IGEuX3ksXG5cdFx0XHRxYXogPSBhLl96LFxuXHRcdFx0cWF3ID0gYS5fdztcblx0XHRjb25zdCBxYnggPSBiLl94LFxuXHRcdFx0cWJ5ID0gYi5feSxcblx0XHRcdHFieiA9IGIuX3osXG5cdFx0XHRxYncgPSBiLl93O1xuXHRcdHRoaXMuX3ggPSBxYXggKiBxYncgKyBxYXcgKiBxYnggKyBxYXkgKiBxYnogLSBxYXogKiBxYnk7XG5cdFx0dGhpcy5feSA9IHFheSAqIHFidyArIHFhdyAqIHFieSArIHFheiAqIHFieCAtIHFheCAqIHFiejtcblx0XHR0aGlzLl96ID0gcWF6ICogcWJ3ICsgcWF3ICogcWJ6ICsgcWF4ICogcWJ5IC0gcWF5ICogcWJ4O1xuXHRcdHRoaXMuX3cgPSBxYXcgKiBxYncgLSBxYXggKiBxYnggLSBxYXkgKiBxYnkgLSBxYXogKiBxYno7XG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHNsZXJwKHFiLCB0KSB7XG5cdFx0aWYgKHQgPT09IDApIHJldHVybiB0aGlzO1xuXHRcdGlmICh0ID09PSAxKSByZXR1cm4gdGhpcy5jb3B5KHFiKTtcblx0XHRjb25zdCB4ID0gdGhpcy5feCxcblx0XHRcdHkgPSB0aGlzLl95LFxuXHRcdFx0eiA9IHRoaXMuX3osXG5cdFx0XHR3ID0gdGhpcy5fdztcblxuXHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvcmVhbE5vcm1lZEFsZ2VicmEvcXVhdGVybmlvbnMvc2xlcnAvXG5cblx0XHRsZXQgY29zSGFsZlRoZXRhID0gdyAqIHFiLl93ICsgeCAqIHFiLl94ICsgeSAqIHFiLl95ICsgeiAqIHFiLl96O1xuXHRcdGlmIChjb3NIYWxmVGhldGEgPCAwKSB7XG5cdFx0XHR0aGlzLl93ID0gLXFiLl93O1xuXHRcdFx0dGhpcy5feCA9IC1xYi5feDtcblx0XHRcdHRoaXMuX3kgPSAtcWIuX3k7XG5cdFx0XHR0aGlzLl96ID0gLXFiLl96O1xuXHRcdFx0Y29zSGFsZlRoZXRhID0gLWNvc0hhbGZUaGV0YTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5jb3B5KHFiKTtcblx0XHR9XG5cdFx0aWYgKGNvc0hhbGZUaGV0YSA+PSAxLjApIHtcblx0XHRcdHRoaXMuX3cgPSB3O1xuXHRcdFx0dGhpcy5feCA9IHg7XG5cdFx0XHR0aGlzLl95ID0geTtcblx0XHRcdHRoaXMuX3ogPSB6O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGNvbnN0IHNxclNpbkhhbGZUaGV0YSA9IDEuMCAtIGNvc0hhbGZUaGV0YSAqIGNvc0hhbGZUaGV0YTtcblx0XHRpZiAoc3FyU2luSGFsZlRoZXRhIDw9IE51bWJlci5FUFNJTE9OKSB7XG5cdFx0XHRjb25zdCBzID0gMSAtIHQ7XG5cdFx0XHR0aGlzLl93ID0gcyAqIHcgKyB0ICogdGhpcy5fdztcblx0XHRcdHRoaXMuX3ggPSBzICogeCArIHQgKiB0aGlzLl94O1xuXHRcdFx0dGhpcy5feSA9IHMgKiB5ICsgdCAqIHRoaXMuX3k7XG5cdFx0XHR0aGlzLl96ID0gcyAqIHogKyB0ICogdGhpcy5fejtcblx0XHRcdHRoaXMubm9ybWFsaXplKCk7XG5cdFx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0Y29uc3Qgc2luSGFsZlRoZXRhID0gTWF0aC5zcXJ0KHNxclNpbkhhbGZUaGV0YSk7XG5cdFx0Y29uc3QgaGFsZlRoZXRhID0gTWF0aC5hdGFuMihzaW5IYWxmVGhldGEsIGNvc0hhbGZUaGV0YSk7XG5cdFx0Y29uc3QgcmF0aW9BID0gTWF0aC5zaW4oKDEgLSB0KSAqIGhhbGZUaGV0YSkgLyBzaW5IYWxmVGhldGEsXG5cdFx0XHRyYXRpb0IgPSBNYXRoLnNpbih0ICogaGFsZlRoZXRhKSAvIHNpbkhhbGZUaGV0YTtcblx0XHR0aGlzLl93ID0gdyAqIHJhdGlvQSArIHRoaXMuX3cgKiByYXRpb0I7XG5cdFx0dGhpcy5feCA9IHggKiByYXRpb0EgKyB0aGlzLl94ICogcmF0aW9CO1xuXHRcdHRoaXMuX3kgPSB5ICogcmF0aW9BICsgdGhpcy5feSAqIHJhdGlvQjtcblx0XHR0aGlzLl96ID0geiAqIHJhdGlvQSArIHRoaXMuX3ogKiByYXRpb0I7XG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHNsZXJwUXVhdGVybmlvbnMocWEsIHFiLCB0KSB7XG5cdFx0cmV0dXJuIHRoaXMuY29weShxYSkuc2xlcnAocWIsIHQpO1xuXHR9XG5cdHJhbmRvbSgpIHtcblx0XHQvLyBEZXJpdmVkIGZyb20gaHR0cDovL3BsYW5uaW5nLmNzLnVpdWMuZWR1L25vZGUxOTguaHRtbFxuXHRcdC8vIE5vdGUsIHRoaXMgc291cmNlIHVzZXMgdywgeCwgeSwgeiBvcmRlcmluZyxcblx0XHQvLyBzbyB3ZSBzd2FwIHRoZSBvcmRlciBiZWxvdy5cblxuXHRcdGNvbnN0IHUxID0gTWF0aC5yYW5kb20oKTtcblx0XHRjb25zdCBzcXJ0MXUxID0gTWF0aC5zcXJ0KDEgLSB1MSk7XG5cdFx0Y29uc3Qgc3FydHUxID0gTWF0aC5zcXJ0KHUxKTtcblx0XHRjb25zdCB1MiA9IDIgKiBNYXRoLlBJICogTWF0aC5yYW5kb20oKTtcblx0XHRjb25zdCB1MyA9IDIgKiBNYXRoLlBJICogTWF0aC5yYW5kb20oKTtcblx0XHRyZXR1cm4gdGhpcy5zZXQoc3FydDF1MSAqIE1hdGguY29zKHUyKSwgc3FydHUxICogTWF0aC5zaW4odTMpLCBzcXJ0dTEgKiBNYXRoLmNvcyh1MyksIHNxcnQxdTEgKiBNYXRoLnNpbih1MikpO1xuXHR9XG5cdGVxdWFscyhxdWF0ZXJuaW9uKSB7XG5cdFx0cmV0dXJuIHF1YXRlcm5pb24uX3ggPT09IHRoaXMuX3ggJiYgcXVhdGVybmlvbi5feSA9PT0gdGhpcy5feSAmJiBxdWF0ZXJuaW9uLl96ID09PSB0aGlzLl96ICYmIHF1YXRlcm5pb24uX3cgPT09IHRoaXMuX3c7XG5cdH1cblx0ZnJvbUFycmF5KGFycmF5LCBvZmZzZXQgPSAwKSB7XG5cdFx0dGhpcy5feCA9IGFycmF5W29mZnNldF07XG5cdFx0dGhpcy5feSA9IGFycmF5W29mZnNldCArIDFdO1xuXHRcdHRoaXMuX3ogPSBhcnJheVtvZmZzZXQgKyAyXTtcblx0XHR0aGlzLl93ID0gYXJyYXlbb2Zmc2V0ICsgM107XG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHRvQXJyYXkoYXJyYXkgPSBbXSwgb2Zmc2V0ID0gMCkge1xuXHRcdGFycmF5W29mZnNldF0gPSB0aGlzLl94O1xuXHRcdGFycmF5W29mZnNldCArIDFdID0gdGhpcy5feTtcblx0XHRhcnJheVtvZmZzZXQgKyAyXSA9IHRoaXMuX3o7XG5cdFx0YXJyYXlbb2Zmc2V0ICsgM10gPSB0aGlzLl93O1xuXHRcdHJldHVybiBhcnJheTtcblx0fVxuXHRmcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZSwgaW5kZXgpIHtcblx0XHR0aGlzLl94ID0gYXR0cmlidXRlLmdldFgoaW5kZXgpO1xuXHRcdHRoaXMuX3kgPSBhdHRyaWJ1dGUuZ2V0WShpbmRleCk7XG5cdFx0dGhpcy5feiA9IGF0dHJpYnV0ZS5nZXRaKGluZGV4KTtcblx0XHR0aGlzLl93ID0gYXR0cmlidXRlLmdldFcoaW5kZXgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdF9vbkNoYW5nZShjYWxsYmFjaykge1xuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2sgPSBjYWxsYmFjaztcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRfb25DaGFuZ2VDYWxsYmFjaygpIHt9XG5cdCpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcblx0XHR5aWVsZCB0aGlzLl94O1xuXHRcdHlpZWxkIHRoaXMuX3k7XG5cdFx0eWllbGQgdGhpcy5fejtcblx0XHR5aWVsZCB0aGlzLl93O1xuXHR9XG59XG5cbmNsYXNzIFZlY3RvcjMge1xuXHRjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIHogPSAwKSB7XG5cdFx0VmVjdG9yMy5wcm90b3R5cGUuaXNWZWN0b3IzID0gdHJ1ZTtcblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7XG5cdFx0dGhpcy56ID0gejtcblx0fVxuXHRzZXQoeCwgeSwgeikge1xuXHRcdGlmICh6ID09PSB1bmRlZmluZWQpIHogPSB0aGlzLno7IC8vIHNwcml0ZS5zY2FsZS5zZXQoeCx5KVxuXG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXHRcdHRoaXMueiA9IHo7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0c2V0U2NhbGFyKHNjYWxhcikge1xuXHRcdHRoaXMueCA9IHNjYWxhcjtcblx0XHR0aGlzLnkgPSBzY2FsYXI7XG5cdFx0dGhpcy56ID0gc2NhbGFyO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHNldFgoeCkge1xuXHRcdHRoaXMueCA9IHg7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0c2V0WSh5KSB7XG5cdFx0dGhpcy55ID0geTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRzZXRaKHopIHtcblx0XHR0aGlzLnogPSB6O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHNldENvbXBvbmVudChpbmRleCwgdmFsdWUpIHtcblx0XHRzd2l0Y2ggKGluZGV4KSB7XG5cdFx0XHRjYXNlIDA6XG5cdFx0XHRcdHRoaXMueCA9IHZhbHVlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgMTpcblx0XHRcdFx0dGhpcy55ID0gdmFsdWU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHR0aGlzLnogPSB2YWx1ZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4KTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0Z2V0Q29tcG9uZW50KGluZGV4KSB7XG5cdFx0c3dpdGNoIChpbmRleCkge1xuXHRcdFx0Y2FzZSAwOlxuXHRcdFx0XHRyZXR1cm4gdGhpcy54O1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRyZXR1cm4gdGhpcy55O1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHRyZXR1cm4gdGhpcy56O1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCk7XG5cdFx0fVxuXHR9XG5cdGNsb25lKCkge1xuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLngsIHRoaXMueSwgdGhpcy56KTtcblx0fVxuXHRjb3B5KHYpIHtcblx0XHR0aGlzLnggPSB2Lng7XG5cdFx0dGhpcy55ID0gdi55O1xuXHRcdHRoaXMueiA9IHYuejtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRhZGQodikge1xuXHRcdHRoaXMueCArPSB2Lng7XG5cdFx0dGhpcy55ICs9IHYueTtcblx0XHR0aGlzLnogKz0gdi56O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGFkZFNjYWxhcihzKSB7XG5cdFx0dGhpcy54ICs9IHM7XG5cdFx0dGhpcy55ICs9IHM7XG5cdFx0dGhpcy56ICs9IHM7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0YWRkVmVjdG9ycyhhLCBiKSB7XG5cdFx0dGhpcy54ID0gYS54ICsgYi54O1xuXHRcdHRoaXMueSA9IGEueSArIGIueTtcblx0XHR0aGlzLnogPSBhLnogKyBiLno7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0YWRkU2NhbGVkVmVjdG9yKHYsIHMpIHtcblx0XHR0aGlzLnggKz0gdi54ICogcztcblx0XHR0aGlzLnkgKz0gdi55ICogcztcblx0XHR0aGlzLnogKz0gdi56ICogcztcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRzdWIodikge1xuXHRcdHRoaXMueCAtPSB2Lng7XG5cdFx0dGhpcy55IC09IHYueTtcblx0XHR0aGlzLnogLT0gdi56O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHN1YlNjYWxhcihzKSB7XG5cdFx0dGhpcy54IC09IHM7XG5cdFx0dGhpcy55IC09IHM7XG5cdFx0dGhpcy56IC09IHM7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0c3ViVmVjdG9ycyhhLCBiKSB7XG5cdFx0dGhpcy54ID0gYS54IC0gYi54O1xuXHRcdHRoaXMueSA9IGEueSAtIGIueTtcblx0XHR0aGlzLnogPSBhLnogLSBiLno7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0bXVsdGlwbHkodikge1xuXHRcdHRoaXMueCAqPSB2Lng7XG5cdFx0dGhpcy55ICo9IHYueTtcblx0XHR0aGlzLnogKj0gdi56O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdG11bHRpcGx5U2NhbGFyKHNjYWxhcikge1xuXHRcdHRoaXMueCAqPSBzY2FsYXI7XG5cdFx0dGhpcy55ICo9IHNjYWxhcjtcblx0XHR0aGlzLnogKj0gc2NhbGFyO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdG11bHRpcGx5VmVjdG9ycyhhLCBiKSB7XG5cdFx0dGhpcy54ID0gYS54ICogYi54O1xuXHRcdHRoaXMueSA9IGEueSAqIGIueTtcblx0XHR0aGlzLnogPSBhLnogKiBiLno7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0YXBwbHlFdWxlcihldWxlcikge1xuXHRcdHJldHVybiB0aGlzLmFwcGx5UXVhdGVybmlvbihfcXVhdGVybmlvbiQ0LnNldEZyb21FdWxlcihldWxlcikpO1xuXHR9XG5cdGFwcGx5QXhpc0FuZ2xlKGF4aXMsIGFuZ2xlKSB7XG5cdFx0cmV0dXJuIHRoaXMuYXBwbHlRdWF0ZXJuaW9uKF9xdWF0ZXJuaW9uJDQuc2V0RnJvbUF4aXNBbmdsZShheGlzLCBhbmdsZSkpO1xuXHR9XG5cdGFwcGx5TWF0cml4MyhtKSB7XG5cdFx0Y29uc3QgeCA9IHRoaXMueCxcblx0XHRcdHkgPSB0aGlzLnksXG5cdFx0XHR6ID0gdGhpcy56O1xuXHRcdGNvbnN0IGUgPSBtLmVsZW1lbnRzO1xuXHRcdHRoaXMueCA9IGVbMF0gKiB4ICsgZVszXSAqIHkgKyBlWzZdICogejtcblx0XHR0aGlzLnkgPSBlWzFdICogeCArIGVbNF0gKiB5ICsgZVs3XSAqIHo7XG5cdFx0dGhpcy56ID0gZVsyXSAqIHggKyBlWzVdICogeSArIGVbOF0gKiB6O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGFwcGx5Tm9ybWFsTWF0cml4KG0pIHtcblx0XHRyZXR1cm4gdGhpcy5hcHBseU1hdHJpeDMobSkubm9ybWFsaXplKCk7XG5cdH1cblx0YXBwbHlNYXRyaXg0KG0pIHtcblx0XHRjb25zdCB4ID0gdGhpcy54LFxuXHRcdFx0eSA9IHRoaXMueSxcblx0XHRcdHogPSB0aGlzLno7XG5cdFx0Y29uc3QgZSA9IG0uZWxlbWVudHM7XG5cdFx0Y29uc3QgdyA9IDEgLyAoZVszXSAqIHggKyBlWzddICogeSArIGVbMTFdICogeiArIGVbMTVdKTtcblx0XHR0aGlzLnggPSAoZVswXSAqIHggKyBlWzRdICogeSArIGVbOF0gKiB6ICsgZVsxMl0pICogdztcblx0XHR0aGlzLnkgPSAoZVsxXSAqIHggKyBlWzVdICogeSArIGVbOV0gKiB6ICsgZVsxM10pICogdztcblx0XHR0aGlzLnogPSAoZVsyXSAqIHggKyBlWzZdICogeSArIGVbMTBdICogeiArIGVbMTRdKSAqIHc7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0YXBwbHlRdWF0ZXJuaW9uKHEpIHtcblx0XHRjb25zdCB4ID0gdGhpcy54LFxuXHRcdFx0eSA9IHRoaXMueSxcblx0XHRcdHogPSB0aGlzLno7XG5cdFx0Y29uc3QgcXggPSBxLngsXG5cdFx0XHRxeSA9IHEueSxcblx0XHRcdHF6ID0gcS56LFxuXHRcdFx0cXcgPSBxLnc7XG5cblx0XHQvLyBjYWxjdWxhdGUgcXVhdCAqIHZlY3RvclxuXG5cdFx0Y29uc3QgaXggPSBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHk7XG5cdFx0Y29uc3QgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHo7XG5cdFx0Y29uc3QgaXogPSBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHg7XG5cdFx0Y29uc3QgaXcgPSAtcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6O1xuXG5cdFx0Ly8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuXG5cdFx0dGhpcy54ID0gaXggKiBxdyArIGl3ICogLXF4ICsgaXkgKiAtcXogLSBpeiAqIC1xeTtcblx0XHR0aGlzLnkgPSBpeSAqIHF3ICsgaXcgKiAtcXkgKyBpeiAqIC1xeCAtIGl4ICogLXF6O1xuXHRcdHRoaXMueiA9IGl6ICogcXcgKyBpdyAqIC1xeiArIGl4ICogLXF5IC0gaXkgKiAtcXg7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0cHJvamVjdChjYW1lcmEpIHtcblx0XHRyZXR1cm4gdGhpcy5hcHBseU1hdHJpeDQoY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSkuYXBwbHlNYXRyaXg0KGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4KTtcblx0fVxuXHR1bnByb2plY3QoY2FtZXJhKSB7XG5cdFx0cmV0dXJuIHRoaXMuYXBwbHlNYXRyaXg0KGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZSkuYXBwbHlNYXRyaXg0KGNhbWVyYS5tYXRyaXhXb3JsZCk7XG5cdH1cblx0dHJhbnNmb3JtRGlyZWN0aW9uKG0pIHtcblx0XHQvLyBpbnB1dDogVEhSRUUuTWF0cml4NCBhZmZpbmUgbWF0cml4XG5cdFx0Ly8gdmVjdG9yIGludGVycHJldGVkIGFzIGEgZGlyZWN0aW9uXG5cblx0XHRjb25zdCB4ID0gdGhpcy54LFxuXHRcdFx0eSA9IHRoaXMueSxcblx0XHRcdHogPSB0aGlzLno7XG5cdFx0Y29uc3QgZSA9IG0uZWxlbWVudHM7XG5cdFx0dGhpcy54ID0gZVswXSAqIHggKyBlWzRdICogeSArIGVbOF0gKiB6O1xuXHRcdHRoaXMueSA9IGVbMV0gKiB4ICsgZVs1XSAqIHkgKyBlWzldICogejtcblx0XHR0aGlzLnogPSBlWzJdICogeCArIGVbNl0gKiB5ICsgZVsxMF0gKiB6O1xuXHRcdHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpO1xuXHR9XG5cdGRpdmlkZSh2KSB7XG5cdFx0dGhpcy54IC89IHYueDtcblx0XHR0aGlzLnkgLz0gdi55O1xuXHRcdHRoaXMueiAvPSB2Lno7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0ZGl2aWRlU2NhbGFyKHNjYWxhcikge1xuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKDEgLyBzY2FsYXIpO1xuXHR9XG5cdG1pbih2KSB7XG5cdFx0dGhpcy54ID0gTWF0aC5taW4odGhpcy54LCB2LngpO1xuXHRcdHRoaXMueSA9IE1hdGgubWluKHRoaXMueSwgdi55KTtcblx0XHR0aGlzLnogPSBNYXRoLm1pbih0aGlzLnosIHYueik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0bWF4KHYpIHtcblx0XHR0aGlzLnggPSBNYXRoLm1heCh0aGlzLngsIHYueCk7XG5cdFx0dGhpcy55ID0gTWF0aC5tYXgodGhpcy55LCB2LnkpO1xuXHRcdHRoaXMueiA9IE1hdGgubWF4KHRoaXMueiwgdi56KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRjbGFtcChtaW4sIG1heCkge1xuXHRcdC8vIGFzc3VtZXMgbWluIDwgbWF4LCBjb21wb25lbnR3aXNlXG5cblx0XHR0aGlzLnggPSBNYXRoLm1heChtaW4ueCwgTWF0aC5taW4obWF4LngsIHRoaXMueCkpO1xuXHRcdHRoaXMueSA9IE1hdGgubWF4KG1pbi55LCBNYXRoLm1pbihtYXgueSwgdGhpcy55KSk7XG5cdFx0dGhpcy56ID0gTWF0aC5tYXgobWluLnosIE1hdGgubWluKG1heC56LCB0aGlzLnopKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRjbGFtcFNjYWxhcihtaW5WYWwsIG1heFZhbCkge1xuXHRcdHRoaXMueCA9IE1hdGgubWF4KG1pblZhbCwgTWF0aC5taW4obWF4VmFsLCB0aGlzLngpKTtcblx0XHR0aGlzLnkgPSBNYXRoLm1heChtaW5WYWwsIE1hdGgubWluKG1heFZhbCwgdGhpcy55KSk7XG5cdFx0dGhpcy56ID0gTWF0aC5tYXgobWluVmFsLCBNYXRoLm1pbihtYXhWYWwsIHRoaXMueikpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGNsYW1wTGVuZ3RoKG1pbiwgbWF4KSB7XG5cdFx0Y29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcblx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIobGVuZ3RoIHx8IDEpLm11bHRpcGx5U2NhbGFyKE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCBsZW5ndGgpKSk7XG5cdH1cblx0Zmxvb3IoKSB7XG5cdFx0dGhpcy54ID0gTWF0aC5mbG9vcih0aGlzLngpO1xuXHRcdHRoaXMueSA9IE1hdGguZmxvb3IodGhpcy55KTtcblx0XHR0aGlzLnogPSBNYXRoLmZsb29yKHRoaXMueik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0Y2VpbCgpIHtcblx0XHR0aGlzLnggPSBNYXRoLmNlaWwodGhpcy54KTtcblx0XHR0aGlzLnkgPSBNYXRoLmNlaWwodGhpcy55KTtcblx0XHR0aGlzLnogPSBNYXRoLmNlaWwodGhpcy56KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRyb3VuZCgpIHtcblx0XHR0aGlzLnggPSBNYXRoLnJvdW5kKHRoaXMueCk7XG5cdFx0dGhpcy55ID0gTWF0aC5yb3VuZCh0aGlzLnkpO1xuXHRcdHRoaXMueiA9IE1hdGgucm91bmQodGhpcy56KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRyb3VuZFRvWmVybygpIHtcblx0XHR0aGlzLnggPSB0aGlzLnggPCAwID8gTWF0aC5jZWlsKHRoaXMueCkgOiBNYXRoLmZsb29yKHRoaXMueCk7XG5cdFx0dGhpcy55ID0gdGhpcy55IDwgMCA/IE1hdGguY2VpbCh0aGlzLnkpIDogTWF0aC5mbG9vcih0aGlzLnkpO1xuXHRcdHRoaXMueiA9IHRoaXMueiA8IDAgPyBNYXRoLmNlaWwodGhpcy56KSA6IE1hdGguZmxvb3IodGhpcy56KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRuZWdhdGUoKSB7XG5cdFx0dGhpcy54ID0gLXRoaXMueDtcblx0XHR0aGlzLnkgPSAtdGhpcy55O1xuXHRcdHRoaXMueiA9IC10aGlzLno7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0ZG90KHYpIHtcblx0XHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55ICsgdGhpcy56ICogdi56O1xuXHR9XG5cblx0Ly8gVE9ETyBsZW5ndGhTcXVhcmVkP1xuXG5cdGxlbmd0aFNxKCkge1xuXHRcdHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLno7XG5cdH1cblx0bGVuZ3RoKCkge1xuXHRcdHJldHVybiBNYXRoLnNxcnQodGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56KTtcblx0fVxuXHRtYW5oYXR0YW5MZW5ndGgoKSB7XG5cdFx0cmV0dXJuIE1hdGguYWJzKHRoaXMueCkgKyBNYXRoLmFicyh0aGlzLnkpICsgTWF0aC5hYnModGhpcy56KTtcblx0fVxuXHRub3JtYWxpemUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKHRoaXMubGVuZ3RoKCkgfHwgMSk7XG5cdH1cblx0c2V0TGVuZ3RoKGxlbmd0aCkge1xuXHRcdHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKGxlbmd0aCk7XG5cdH1cblx0bGVycCh2LCBhbHBoYSkge1xuXHRcdHRoaXMueCArPSAodi54IC0gdGhpcy54KSAqIGFscGhhO1xuXHRcdHRoaXMueSArPSAodi55IC0gdGhpcy55KSAqIGFscGhhO1xuXHRcdHRoaXMueiArPSAodi56IC0gdGhpcy56KSAqIGFscGhhO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGxlcnBWZWN0b3JzKHYxLCB2MiwgYWxwaGEpIHtcblx0XHR0aGlzLnggPSB2MS54ICsgKHYyLnggLSB2MS54KSAqIGFscGhhO1xuXHRcdHRoaXMueSA9IHYxLnkgKyAodjIueSAtIHYxLnkpICogYWxwaGE7XG5cdFx0dGhpcy56ID0gdjEueiArICh2Mi56IC0gdjEueikgKiBhbHBoYTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRjcm9zcyh2KSB7XG5cdFx0cmV0dXJuIHRoaXMuY3Jvc3NWZWN0b3JzKHRoaXMsIHYpO1xuXHR9XG5cdGNyb3NzVmVjdG9ycyhhLCBiKSB7XG5cdFx0Y29uc3QgYXggPSBhLngsXG5cdFx0XHRheSA9IGEueSxcblx0XHRcdGF6ID0gYS56O1xuXHRcdGNvbnN0IGJ4ID0gYi54LFxuXHRcdFx0YnkgPSBiLnksXG5cdFx0XHRieiA9IGIuejtcblx0XHR0aGlzLnggPSBheSAqIGJ6IC0gYXogKiBieTtcblx0XHR0aGlzLnkgPSBheiAqIGJ4IC0gYXggKiBiejtcblx0XHR0aGlzLnogPSBheCAqIGJ5IC0gYXkgKiBieDtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRwcm9qZWN0T25WZWN0b3Iodikge1xuXHRcdGNvbnN0IGRlbm9taW5hdG9yID0gdi5sZW5ndGhTcSgpO1xuXHRcdGlmIChkZW5vbWluYXRvciA9PT0gMCkgcmV0dXJuIHRoaXMuc2V0KDAsIDAsIDApO1xuXHRcdGNvbnN0IHNjYWxhciA9IHYuZG90KHRoaXMpIC8gZGVub21pbmF0b3I7XG5cdFx0cmV0dXJuIHRoaXMuY29weSh2KS5tdWx0aXBseVNjYWxhcihzY2FsYXIpO1xuXHR9XG5cdHByb2plY3RPblBsYW5lKHBsYW5lTm9ybWFsKSB7XG5cdFx0X3ZlY3RvciRjLmNvcHkodGhpcykucHJvamVjdE9uVmVjdG9yKHBsYW5lTm9ybWFsKTtcblx0XHRyZXR1cm4gdGhpcy5zdWIoX3ZlY3RvciRjKTtcblx0fVxuXHRyZWZsZWN0KG5vcm1hbCkge1xuXHRcdC8vIHJlZmxlY3QgaW5jaWRlbnQgdmVjdG9yIG9mZiBwbGFuZSBvcnRob2dvbmFsIHRvIG5vcm1hbFxuXHRcdC8vIG5vcm1hbCBpcyBhc3N1bWVkIHRvIGhhdmUgdW5pdCBsZW5ndGhcblxuXHRcdHJldHVybiB0aGlzLnN1YihfdmVjdG9yJGMuY29weShub3JtYWwpLm11bHRpcGx5U2NhbGFyKDIgKiB0aGlzLmRvdChub3JtYWwpKSk7XG5cdH1cblx0YW5nbGVUbyh2KSB7XG5cdFx0Y29uc3QgZGVub21pbmF0b3IgPSBNYXRoLnNxcnQodGhpcy5sZW5ndGhTcSgpICogdi5sZW5ndGhTcSgpKTtcblx0XHRpZiAoZGVub21pbmF0b3IgPT09IDApIHJldHVybiBNYXRoLlBJIC8gMjtcblx0XHRjb25zdCB0aGV0YSA9IHRoaXMuZG90KHYpIC8gZGVub21pbmF0b3I7XG5cblx0XHQvLyBjbGFtcCwgdG8gaGFuZGxlIG51bWVyaWNhbCBwcm9ibGVtc1xuXG5cdFx0cmV0dXJuIE1hdGguYWNvcyhjbGFtcCh0aGV0YSwgLTEsIDEpKTtcblx0fVxuXHRkaXN0YW5jZVRvKHYpIHtcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQodikpO1xuXHR9XG5cdGRpc3RhbmNlVG9TcXVhcmVkKHYpIHtcblx0XHRjb25zdCBkeCA9IHRoaXMueCAtIHYueCxcblx0XHRcdGR5ID0gdGhpcy55IC0gdi55LFxuXHRcdFx0ZHogPSB0aGlzLnogLSB2Lno7XG5cdFx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkejtcblx0fVxuXHRtYW5oYXR0YW5EaXN0YW5jZVRvKHYpIHtcblx0XHRyZXR1cm4gTWF0aC5hYnModGhpcy54IC0gdi54KSArIE1hdGguYWJzKHRoaXMueSAtIHYueSkgKyBNYXRoLmFicyh0aGlzLnogLSB2LnopO1xuXHR9XG5cdHNldEZyb21TcGhlcmljYWwocykge1xuXHRcdHJldHVybiB0aGlzLnNldEZyb21TcGhlcmljYWxDb29yZHMocy5yYWRpdXMsIHMucGhpLCBzLnRoZXRhKTtcblx0fVxuXHRzZXRGcm9tU3BoZXJpY2FsQ29vcmRzKHJhZGl1cywgcGhpLCB0aGV0YSkge1xuXHRcdGNvbnN0IHNpblBoaVJhZGl1cyA9IE1hdGguc2luKHBoaSkgKiByYWRpdXM7XG5cdFx0dGhpcy54ID0gc2luUGhpUmFkaXVzICogTWF0aC5zaW4odGhldGEpO1xuXHRcdHRoaXMueSA9IE1hdGguY29zKHBoaSkgKiByYWRpdXM7XG5cdFx0dGhpcy56ID0gc2luUGhpUmFkaXVzICogTWF0aC5jb3ModGhldGEpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHNldEZyb21DeWxpbmRyaWNhbChjKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0RnJvbUN5bGluZHJpY2FsQ29vcmRzKGMucmFkaXVzLCBjLnRoZXRhLCBjLnkpO1xuXHR9XG5cdHNldEZyb21DeWxpbmRyaWNhbENvb3JkcyhyYWRpdXMsIHRoZXRhLCB5KSB7XG5cdFx0dGhpcy54ID0gcmFkaXVzICogTWF0aC5zaW4odGhldGEpO1xuXHRcdHRoaXMueSA9IHk7XG5cdFx0dGhpcy56ID0gcmFkaXVzICogTWF0aC5jb3ModGhldGEpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHNldEZyb21NYXRyaXhQb3NpdGlvbihtKSB7XG5cdFx0Y29uc3QgZSA9IG0uZWxlbWVudHM7XG5cdFx0dGhpcy54ID0gZVsxMl07XG5cdFx0dGhpcy55ID0gZVsxM107XG5cdFx0dGhpcy56ID0gZVsxNF07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0c2V0RnJvbU1hdHJpeFNjYWxlKG0pIHtcblx0XHRjb25zdCBzeCA9IHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbihtLCAwKS5sZW5ndGgoKTtcblx0XHRjb25zdCBzeSA9IHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbihtLCAxKS5sZW5ndGgoKTtcblx0XHRjb25zdCBzeiA9IHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbihtLCAyKS5sZW5ndGgoKTtcblx0XHR0aGlzLnggPSBzeDtcblx0XHR0aGlzLnkgPSBzeTtcblx0XHR0aGlzLnogPSBzejtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRzZXRGcm9tTWF0cml4Q29sdW1uKG0sIGluZGV4KSB7XG5cdFx0cmV0dXJuIHRoaXMuZnJvbUFycmF5KG0uZWxlbWVudHMsIGluZGV4ICogNCk7XG5cdH1cblx0c2V0RnJvbU1hdHJpeDNDb2x1bW4obSwgaW5kZXgpIHtcblx0XHRyZXR1cm4gdGhpcy5mcm9tQXJyYXkobS5lbGVtZW50cywgaW5kZXggKiAzKTtcblx0fVxuXHRzZXRGcm9tRXVsZXIoZSkge1xuXHRcdHRoaXMueCA9IGUuX3g7XG5cdFx0dGhpcy55ID0gZS5feTtcblx0XHR0aGlzLnogPSBlLl96O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGVxdWFscyh2KSB7XG5cdFx0cmV0dXJuIHYueCA9PT0gdGhpcy54ICYmIHYueSA9PT0gdGhpcy55ICYmIHYueiA9PT0gdGhpcy56O1xuXHR9XG5cdGZyb21BcnJheShhcnJheSwgb2Zmc2V0ID0gMCkge1xuXHRcdHRoaXMueCA9IGFycmF5W29mZnNldF07XG5cdFx0dGhpcy55ID0gYXJyYXlbb2Zmc2V0ICsgMV07XG5cdFx0dGhpcy56ID0gYXJyYXlbb2Zmc2V0ICsgMl07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0dG9BcnJheShhcnJheSA9IFtdLCBvZmZzZXQgPSAwKSB7XG5cdFx0YXJyYXlbb2Zmc2V0XSA9IHRoaXMueDtcblx0XHRhcnJheVtvZmZzZXQgKyAxXSA9IHRoaXMueTtcblx0XHRhcnJheVtvZmZzZXQgKyAyXSA9IHRoaXMuejtcblx0XHRyZXR1cm4gYXJyYXk7XG5cdH1cblx0ZnJvbUJ1ZmZlckF0dHJpYnV0ZShhdHRyaWJ1dGUsIGluZGV4KSB7XG5cdFx0dGhpcy54ID0gYXR0cmlidXRlLmdldFgoaW5kZXgpO1xuXHRcdHRoaXMueSA9IGF0dHJpYnV0ZS5nZXRZKGluZGV4KTtcblx0XHR0aGlzLnogPSBhdHRyaWJ1dGUuZ2V0WihpbmRleCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0cmFuZG9tKCkge1xuXHRcdHRoaXMueCA9IE1hdGgucmFuZG9tKCk7XG5cdFx0dGhpcy55ID0gTWF0aC5yYW5kb20oKTtcblx0XHR0aGlzLnogPSBNYXRoLnJhbmRvbSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHJhbmRvbURpcmVjdGlvbigpIHtcblx0XHQvLyBEZXJpdmVkIGZyb20gaHR0cHM6Ly9tYXRod29ybGQud29sZnJhbS5jb20vU3BoZXJlUG9pbnRQaWNraW5nLmh0bWxcblxuXHRcdGNvbnN0IHUgPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAyO1xuXHRcdGNvbnN0IHQgPSBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDI7XG5cdFx0Y29uc3QgZiA9IE1hdGguc3FydCgxIC0gdSAqKiAyKTtcblx0XHR0aGlzLnggPSBmICogTWF0aC5jb3ModCk7XG5cdFx0dGhpcy55ID0gZiAqIE1hdGguc2luKHQpO1xuXHRcdHRoaXMueiA9IHU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0KltTeW1ib2wuaXRlcmF0b3JdKCkge1xuXHRcdHlpZWxkIHRoaXMueDtcblx0XHR5aWVsZCB0aGlzLnk7XG5cdFx0eWllbGQgdGhpcy56O1xuXHR9XG59XG5jb25zdCBfdmVjdG9yJGMgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9xdWF0ZXJuaW9uJDQgPSAvKkBfX1BVUkVfXyovbmV3IFF1YXRlcm5pb24oKTtcblxuY2xhc3MgQm94MyB7XG5cdGNvbnN0cnVjdG9yKG1pbiA9IG5ldyBWZWN0b3IzKCtJbmZpbml0eSwgK0luZmluaXR5LCArSW5maW5pdHkpLCBtYXggPSBuZXcgVmVjdG9yMygtSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5KSkge1xuXHRcdHRoaXMuaXNCb3gzID0gdHJ1ZTtcblx0XHR0aGlzLm1pbiA9IG1pbjtcblx0XHR0aGlzLm1heCA9IG1heDtcblx0fVxuXHRzZXQobWluLCBtYXgpIHtcblx0XHR0aGlzLm1pbi5jb3B5KG1pbik7XG5cdFx0dGhpcy5tYXguY29weShtYXgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHNldEZyb21BcnJheShhcnJheSkge1xuXHRcdGxldCBtaW5YID0gK0luZmluaXR5O1xuXHRcdGxldCBtaW5ZID0gK0luZmluaXR5O1xuXHRcdGxldCBtaW5aID0gK0luZmluaXR5O1xuXHRcdGxldCBtYXhYID0gLUluZmluaXR5O1xuXHRcdGxldCBtYXhZID0gLUluZmluaXR5O1xuXHRcdGxldCBtYXhaID0gLUluZmluaXR5O1xuXHRcdGZvciAobGV0IGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSArPSAzKSB7XG5cdFx0XHRjb25zdCB4ID0gYXJyYXlbaV07XG5cdFx0XHRjb25zdCB5ID0gYXJyYXlbaSArIDFdO1xuXHRcdFx0Y29uc3QgeiA9IGFycmF5W2kgKyAyXTtcblx0XHRcdGlmICh4IDwgbWluWCkgbWluWCA9IHg7XG5cdFx0XHRpZiAoeSA8IG1pblkpIG1pblkgPSB5O1xuXHRcdFx0aWYgKHogPCBtaW5aKSBtaW5aID0gejtcblx0XHRcdGlmICh4ID4gbWF4WCkgbWF4WCA9IHg7XG5cdFx0XHRpZiAoeSA+IG1heFkpIG1heFkgPSB5O1xuXHRcdFx0aWYgKHogPiBtYXhaKSBtYXhaID0gejtcblx0XHR9XG5cdFx0dGhpcy5taW4uc2V0KG1pblgsIG1pblksIG1pblopO1xuXHRcdHRoaXMubWF4LnNldChtYXhYLCBtYXhZLCBtYXhaKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRzZXRGcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZSkge1xuXHRcdGxldCBtaW5YID0gK0luZmluaXR5O1xuXHRcdGxldCBtaW5ZID0gK0luZmluaXR5O1xuXHRcdGxldCBtaW5aID0gK0luZmluaXR5O1xuXHRcdGxldCBtYXhYID0gLUluZmluaXR5O1xuXHRcdGxldCBtYXhZID0gLUluZmluaXR5O1xuXHRcdGxldCBtYXhaID0gLUluZmluaXR5O1xuXHRcdGZvciAobGV0IGkgPSAwLCBsID0gYXR0cmlidXRlLmNvdW50OyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRjb25zdCB4ID0gYXR0cmlidXRlLmdldFgoaSk7XG5cdFx0XHRjb25zdCB5ID0gYXR0cmlidXRlLmdldFkoaSk7XG5cdFx0XHRjb25zdCB6ID0gYXR0cmlidXRlLmdldFooaSk7XG5cdFx0XHRpZiAoeCA8IG1pblgpIG1pblggPSB4O1xuXHRcdFx0aWYgKHkgPCBtaW5ZKSBtaW5ZID0geTtcblx0XHRcdGlmICh6IDwgbWluWikgbWluWiA9IHo7XG5cdFx0XHRpZiAoeCA+IG1heFgpIG1heFggPSB4O1xuXHRcdFx0aWYgKHkgPiBtYXhZKSBtYXhZID0geTtcblx0XHRcdGlmICh6ID4gbWF4WikgbWF4WiA9IHo7XG5cdFx0fVxuXHRcdHRoaXMubWluLnNldChtaW5YLCBtaW5ZLCBtaW5aKTtcblx0XHR0aGlzLm1heC5zZXQobWF4WCwgbWF4WSwgbWF4Wik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0c2V0RnJvbVBvaW50cyhwb2ludHMpIHtcblx0XHR0aGlzLm1ha2VFbXB0eSgpO1xuXHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHR0aGlzLmV4cGFuZEJ5UG9pbnQocG9pbnRzW2ldKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0c2V0RnJvbUNlbnRlckFuZFNpemUoY2VudGVyLCBzaXplKSB7XG5cdFx0Y29uc3QgaGFsZlNpemUgPSBfdmVjdG9yJGIuY29weShzaXplKS5tdWx0aXBseVNjYWxhcigwLjUpO1xuXHRcdHRoaXMubWluLmNvcHkoY2VudGVyKS5zdWIoaGFsZlNpemUpO1xuXHRcdHRoaXMubWF4LmNvcHkoY2VudGVyKS5hZGQoaGFsZlNpemUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHNldEZyb21PYmplY3Qob2JqZWN0LCBwcmVjaXNlID0gZmFsc2UpIHtcblx0XHR0aGlzLm1ha2VFbXB0eSgpO1xuXHRcdHJldHVybiB0aGlzLmV4cGFuZEJ5T2JqZWN0KG9iamVjdCwgcHJlY2lzZSk7XG5cdH1cblx0Y2xvbmUoKSB7XG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKTtcblx0fVxuXHRjb3B5KGJveCkge1xuXHRcdHRoaXMubWluLmNvcHkoYm94Lm1pbik7XG5cdFx0dGhpcy5tYXguY29weShib3gubWF4KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRtYWtlRW1wdHkoKSB7XG5cdFx0dGhpcy5taW4ueCA9IHRoaXMubWluLnkgPSB0aGlzLm1pbi56ID0gK0luZmluaXR5O1xuXHRcdHRoaXMubWF4LnggPSB0aGlzLm1heC55ID0gdGhpcy5tYXgueiA9IC1JbmZpbml0eTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRpc0VtcHR5KCkge1xuXHRcdC8vIHRoaXMgaXMgYSBtb3JlIHJvYnVzdCBjaGVjayBmb3IgZW1wdHkgdGhhbiAoIHZvbHVtZSA8PSAwICkgYmVjYXVzZSB2b2x1bWUgY2FuIGdldCBwb3NpdGl2ZSB3aXRoIHR3byBuZWdhdGl2ZSBheGVzXG5cblx0XHRyZXR1cm4gdGhpcy5tYXgueCA8IHRoaXMubWluLnggfHwgdGhpcy5tYXgueSA8IHRoaXMubWluLnkgfHwgdGhpcy5tYXgueiA8IHRoaXMubWluLno7XG5cdH1cblx0Z2V0Q2VudGVyKHRhcmdldCkge1xuXHRcdHJldHVybiB0aGlzLmlzRW1wdHkoKSA/IHRhcmdldC5zZXQoMCwgMCwgMCkgOiB0YXJnZXQuYWRkVmVjdG9ycyh0aGlzLm1pbiwgdGhpcy5tYXgpLm11bHRpcGx5U2NhbGFyKDAuNSk7XG5cdH1cblx0Z2V0U2l6ZSh0YXJnZXQpIHtcblx0XHRyZXR1cm4gdGhpcy5pc0VtcHR5KCkgPyB0YXJnZXQuc2V0KDAsIDAsIDApIDogdGFyZ2V0LnN1YlZlY3RvcnModGhpcy5tYXgsIHRoaXMubWluKTtcblx0fVxuXHRleHBhbmRCeVBvaW50KHBvaW50KSB7XG5cdFx0dGhpcy5taW4ubWluKHBvaW50KTtcblx0XHR0aGlzLm1heC5tYXgocG9pbnQpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGV4cGFuZEJ5VmVjdG9yKHZlY3Rvcikge1xuXHRcdHRoaXMubWluLnN1Yih2ZWN0b3IpO1xuXHRcdHRoaXMubWF4LmFkZCh2ZWN0b3IpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGV4cGFuZEJ5U2NhbGFyKHNjYWxhcikge1xuXHRcdHRoaXMubWluLmFkZFNjYWxhcigtc2NhbGFyKTtcblx0XHR0aGlzLm1heC5hZGRTY2FsYXIoc2NhbGFyKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRleHBhbmRCeU9iamVjdChvYmplY3QsIHByZWNpc2UgPSBmYWxzZSkge1xuXHRcdC8vIENvbXB1dGVzIHRoZSB3b3JsZC1heGlzLWFsaWduZWQgYm91bmRpbmcgYm94IG9mIGFuIG9iamVjdCAoaW5jbHVkaW5nIGl0cyBjaGlsZHJlbiksXG5cdFx0Ly8gYWNjb3VudGluZyBmb3IgYm90aCB0aGUgb2JqZWN0J3MsIGFuZCBjaGlsZHJlbidzLCB3b3JsZCB0cmFuc2Zvcm1zXG5cblx0XHRvYmplY3QudXBkYXRlV29ybGRNYXRyaXgoZmFsc2UsIGZhbHNlKTtcblx0XHRjb25zdCBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcblx0XHRpZiAoZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aWYgKHByZWNpc2UgJiYgZ2VvbWV0cnkuYXR0cmlidXRlcyAhPSB1bmRlZmluZWQgJiYgZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGNvbnN0IHBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBwb3NpdGlvbi5jb3VudDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdF92ZWN0b3IkYi5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uLCBpKS5hcHBseU1hdHJpeDQob2JqZWN0Lm1hdHJpeFdvcmxkKTtcblx0XHRcdFx0XHR0aGlzLmV4cGFuZEJ5UG9pbnQoX3ZlY3RvciRiKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKGdlb21ldHJ5LmJvdW5kaW5nQm94ID09PSBudWxsKSB7XG5cdFx0XHRcdFx0Z2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0X2JveCQzLmNvcHkoZ2VvbWV0cnkuYm91bmRpbmdCb3gpO1xuXHRcdFx0XHRfYm94JDMuYXBwbHlNYXRyaXg0KG9iamVjdC5tYXRyaXhXb3JsZCk7XG5cdFx0XHRcdHRoaXMudW5pb24oX2JveCQzKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Y29uc3QgY2hpbGRyZW4gPSBvYmplY3QuY2hpbGRyZW47XG5cdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHRoaXMuZXhwYW5kQnlPYmplY3QoY2hpbGRyZW5baV0sIHByZWNpc2UpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRjb250YWluc1BvaW50KHBvaW50KSB7XG5cdFx0cmV0dXJuIHBvaW50LnggPCB0aGlzLm1pbi54IHx8IHBvaW50LnggPiB0aGlzLm1heC54IHx8IHBvaW50LnkgPCB0aGlzLm1pbi55IHx8IHBvaW50LnkgPiB0aGlzLm1heC55IHx8IHBvaW50LnogPCB0aGlzLm1pbi56IHx8IHBvaW50LnogPiB0aGlzLm1heC56ID8gZmFsc2UgOiB0cnVlO1xuXHR9XG5cdGNvbnRhaW5zQm94KGJveCkge1xuXHRcdHJldHVybiB0aGlzLm1pbi54IDw9IGJveC5taW4ueCAmJiBib3gubWF4LnggPD0gdGhpcy5tYXgueCAmJiB0aGlzLm1pbi55IDw9IGJveC5taW4ueSAmJiBib3gubWF4LnkgPD0gdGhpcy5tYXgueSAmJiB0aGlzLm1pbi56IDw9IGJveC5taW4ueiAmJiBib3gubWF4LnogPD0gdGhpcy5tYXguejtcblx0fVxuXHRnZXRQYXJhbWV0ZXIocG9pbnQsIHRhcmdldCkge1xuXHRcdC8vIFRoaXMgY2FuIHBvdGVudGlhbGx5IGhhdmUgYSBkaXZpZGUgYnkgemVybyBpZiB0aGUgYm94XG5cdFx0Ly8gaGFzIGEgc2l6ZSBkaW1lbnNpb24gb2YgMC5cblxuXHRcdHJldHVybiB0YXJnZXQuc2V0KChwb2ludC54IC0gdGhpcy5taW4ueCkgLyAodGhpcy5tYXgueCAtIHRoaXMubWluLngpLCAocG9pbnQueSAtIHRoaXMubWluLnkpIC8gKHRoaXMubWF4LnkgLSB0aGlzLm1pbi55KSwgKHBvaW50LnogLSB0aGlzLm1pbi56KSAvICh0aGlzLm1heC56IC0gdGhpcy5taW4ueikpO1xuXHR9XG5cdGludGVyc2VjdHNCb3goYm94KSB7XG5cdFx0Ly8gdXNpbmcgNiBzcGxpdHRpbmcgcGxhbmVzIHRvIHJ1bGUgb3V0IGludGVyc2VjdGlvbnMuXG5cdFx0cmV0dXJuIGJveC5tYXgueCA8IHRoaXMubWluLnggfHwgYm94Lm1pbi54ID4gdGhpcy5tYXgueCB8fCBib3gubWF4LnkgPCB0aGlzLm1pbi55IHx8IGJveC5taW4ueSA+IHRoaXMubWF4LnkgfHwgYm94Lm1heC56IDwgdGhpcy5taW4ueiB8fCBib3gubWluLnogPiB0aGlzLm1heC56ID8gZmFsc2UgOiB0cnVlO1xuXHR9XG5cdGludGVyc2VjdHNTcGhlcmUoc3BoZXJlKSB7XG5cdFx0Ly8gRmluZCB0aGUgcG9pbnQgb24gdGhlIEFBQkIgY2xvc2VzdCB0byB0aGUgc3BoZXJlIGNlbnRlci5cblx0XHR0aGlzLmNsYW1wUG9pbnQoc3BoZXJlLmNlbnRlciwgX3ZlY3RvciRiKTtcblxuXHRcdC8vIElmIHRoYXQgcG9pbnQgaXMgaW5zaWRlIHRoZSBzcGhlcmUsIHRoZSBBQUJCIGFuZCBzcGhlcmUgaW50ZXJzZWN0LlxuXHRcdHJldHVybiBfdmVjdG9yJGIuZGlzdGFuY2VUb1NxdWFyZWQoc3BoZXJlLmNlbnRlcikgPD0gc3BoZXJlLnJhZGl1cyAqIHNwaGVyZS5yYWRpdXM7XG5cdH1cblx0aW50ZXJzZWN0c1BsYW5lKHBsYW5lKSB7XG5cdFx0Ly8gV2UgY29tcHV0ZSB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBkb3QgcHJvZHVjdCB2YWx1ZXMuIElmIHRob3NlIHZhbHVlc1xuXHRcdC8vIGFyZSBvbiB0aGUgc2FtZSBzaWRlIChiYWNrIG9yIGZyb250KSBvZiB0aGUgcGxhbmUsIHRoZW4gdGhlcmUgaXMgbm8gaW50ZXJzZWN0aW9uLlxuXG5cdFx0bGV0IG1pbiwgbWF4O1xuXHRcdGlmIChwbGFuZS5ub3JtYWwueCA+IDApIHtcblx0XHRcdG1pbiA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5taW4ueDtcblx0XHRcdG1heCA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5tYXgueDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWluID0gcGxhbmUubm9ybWFsLnggKiB0aGlzLm1heC54O1xuXHRcdFx0bWF4ID0gcGxhbmUubm9ybWFsLnggKiB0aGlzLm1pbi54O1xuXHRcdH1cblx0XHRpZiAocGxhbmUubm9ybWFsLnkgPiAwKSB7XG5cdFx0XHRtaW4gKz0gcGxhbmUubm9ybWFsLnkgKiB0aGlzLm1pbi55O1xuXHRcdFx0bWF4ICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5tYXgueTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWluICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5tYXgueTtcblx0XHRcdG1heCArPSBwbGFuZS5ub3JtYWwueSAqIHRoaXMubWluLnk7XG5cdFx0fVxuXHRcdGlmIChwbGFuZS5ub3JtYWwueiA+IDApIHtcblx0XHRcdG1pbiArPSBwbGFuZS5ub3JtYWwueiAqIHRoaXMubWluLno7XG5cdFx0XHRtYXggKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1heC56O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtaW4gKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1heC56O1xuXHRcdFx0bWF4ICs9IHBsYW5lLm5vcm1hbC56ICogdGhpcy5taW4uejtcblx0XHR9XG5cdFx0cmV0dXJuIG1pbiA8PSAtcGxhbmUuY29uc3RhbnQgJiYgbWF4ID49IC1wbGFuZS5jb25zdGFudDtcblx0fVxuXHRpbnRlcnNlY3RzVHJpYW5nbGUodHJpYW5nbGUpIHtcblx0XHRpZiAodGhpcy5pc0VtcHR5KCkpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBjb21wdXRlIGJveCBjZW50ZXIgYW5kIGV4dGVudHNcblx0XHR0aGlzLmdldENlbnRlcihfY2VudGVyKTtcblx0XHRfZXh0ZW50cy5zdWJWZWN0b3JzKHRoaXMubWF4LCBfY2VudGVyKTtcblxuXHRcdC8vIHRyYW5zbGF0ZSB0cmlhbmdsZSB0byBhYWJiIG9yaWdpblxuXHRcdF92MCQyLnN1YlZlY3RvcnModHJpYW5nbGUuYSwgX2NlbnRlcik7XG5cdFx0X3YxJDcuc3ViVmVjdG9ycyh0cmlhbmdsZS5iLCBfY2VudGVyKTtcblx0XHRfdjIkNC5zdWJWZWN0b3JzKHRyaWFuZ2xlLmMsIF9jZW50ZXIpO1xuXG5cdFx0Ly8gY29tcHV0ZSBlZGdlIHZlY3RvcnMgZm9yIHRyaWFuZ2xlXG5cdFx0X2YwLnN1YlZlY3RvcnMoX3YxJDcsIF92MCQyKTtcblx0XHRfZjEuc3ViVmVjdG9ycyhfdjIkNCwgX3YxJDcpO1xuXHRcdF9mMi5zdWJWZWN0b3JzKF92MCQyLCBfdjIkNCk7XG5cblx0XHQvLyB0ZXN0IGFnYWluc3QgYXhlcyB0aGF0IGFyZSBnaXZlbiBieSBjcm9zcyBwcm9kdWN0IGNvbWJpbmF0aW9ucyBvZiB0aGUgZWRnZXMgb2YgdGhlIHRyaWFuZ2xlIGFuZCB0aGUgZWRnZXMgb2YgdGhlIGFhYmJcblx0XHQvLyBtYWtlIGFuIGF4aXMgdGVzdGluZyBvZiBlYWNoIG9mIHRoZSAzIHNpZGVzIG9mIHRoZSBhYWJiIGFnYWluc3QgZWFjaCBvZiB0aGUgMyBzaWRlcyBvZiB0aGUgdHJpYW5nbGUgPSA5IGF4aXMgb2Ygc2VwYXJhdGlvblxuXHRcdC8vIGF4aXNfaWogPSB1X2kgeCBmX2ogKHUwLCB1MSwgdTIgPSBmYWNlIG5vcm1hbHMgb2YgYWFiYiA9IHgseSx6IGF4ZXMgdmVjdG9ycyBzaW5jZSBhYWJiIGlzIGF4aXMgYWxpZ25lZClcblx0XHRsZXQgYXhlcyA9IFswLCAtX2YwLnosIF9mMC55LCAwLCAtX2YxLnosIF9mMS55LCAwLCAtX2YyLnosIF9mMi55LCBfZjAueiwgMCwgLV9mMC54LCBfZjEueiwgMCwgLV9mMS54LCBfZjIueiwgMCwgLV9mMi54LCAtX2YwLnksIF9mMC54LCAwLCAtX2YxLnksIF9mMS54LCAwLCAtX2YyLnksIF9mMi54LCAwXTtcblx0XHRpZiAoIXNhdEZvckF4ZXMoYXhlcywgX3YwJDIsIF92MSQ3LCBfdjIkNCwgX2V4dGVudHMpKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gdGVzdCAzIGZhY2Ugbm9ybWFscyBmcm9tIHRoZSBhYWJiXG5cdFx0YXhlcyA9IFsxLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAxXTtcblx0XHRpZiAoIXNhdEZvckF4ZXMoYXhlcywgX3YwJDIsIF92MSQ3LCBfdjIkNCwgX2V4dGVudHMpKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gZmluYWxseSB0ZXN0aW5nIHRoZSBmYWNlIG5vcm1hbCBvZiB0aGUgdHJpYW5nbGVcblx0XHQvLyB1c2UgYWxyZWFkeSBleGlzdGluZyB0cmlhbmdsZSBlZGdlIHZlY3RvcnMgaGVyZVxuXHRcdF90cmlhbmdsZU5vcm1hbC5jcm9zc1ZlY3RvcnMoX2YwLCBfZjEpO1xuXHRcdGF4ZXMgPSBbX3RyaWFuZ2xlTm9ybWFsLngsIF90cmlhbmdsZU5vcm1hbC55LCBfdHJpYW5nbGVOb3JtYWwuel07XG5cdFx0cmV0dXJuIHNhdEZvckF4ZXMoYXhlcywgX3YwJDIsIF92MSQ3LCBfdjIkNCwgX2V4dGVudHMpO1xuXHR9XG5cdGNsYW1wUG9pbnQocG9pbnQsIHRhcmdldCkge1xuXHRcdHJldHVybiB0YXJnZXQuY29weShwb2ludCkuY2xhbXAodGhpcy5taW4sIHRoaXMubWF4KTtcblx0fVxuXHRkaXN0YW5jZVRvUG9pbnQocG9pbnQpIHtcblx0XHRjb25zdCBjbGFtcGVkUG9pbnQgPSBfdmVjdG9yJGIuY29weShwb2ludCkuY2xhbXAodGhpcy5taW4sIHRoaXMubWF4KTtcblx0XHRyZXR1cm4gY2xhbXBlZFBvaW50LnN1Yihwb2ludCkubGVuZ3RoKCk7XG5cdH1cblx0Z2V0Qm91bmRpbmdTcGhlcmUodGFyZ2V0KSB7XG5cdFx0dGhpcy5nZXRDZW50ZXIodGFyZ2V0LmNlbnRlcik7XG5cdFx0dGFyZ2V0LnJhZGl1cyA9IHRoaXMuZ2V0U2l6ZShfdmVjdG9yJGIpLmxlbmd0aCgpICogMC41O1xuXHRcdHJldHVybiB0YXJnZXQ7XG5cdH1cblx0aW50ZXJzZWN0KGJveCkge1xuXHRcdHRoaXMubWluLm1heChib3gubWluKTtcblx0XHR0aGlzLm1heC5taW4oYm94Lm1heCk7XG5cblx0XHQvLyBlbnN1cmUgdGhhdCBpZiB0aGVyZSBpcyBubyBvdmVybGFwLCB0aGUgcmVzdWx0IGlzIGZ1bGx5IGVtcHR5LCBub3Qgc2xpZ2h0bHkgZW1wdHkgd2l0aCBub24taW5mLytpbmYgdmFsdWVzIHRoYXQgd2lsbCBjYXVzZSBzdWJzZXF1ZW5jZSBpbnRlcnNlY3RzIHRvIGVycm9uZW91c2x5IHJldHVybiB2YWxpZCB2YWx1ZXMuXG5cdFx0aWYgKHRoaXMuaXNFbXB0eSgpKSB0aGlzLm1ha2VFbXB0eSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHVuaW9uKGJveCkge1xuXHRcdHRoaXMubWluLm1pbihib3gubWluKTtcblx0XHR0aGlzLm1heC5tYXgoYm94Lm1heCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0YXBwbHlNYXRyaXg0KG1hdHJpeCkge1xuXHRcdC8vIHRyYW5zZm9ybSBvZiBlbXB0eSBib3ggaXMgYW4gZW1wdHkgYm94LlxuXHRcdGlmICh0aGlzLmlzRW1wdHkoKSkgcmV0dXJuIHRoaXM7XG5cblx0XHQvLyBOT1RFOiBJIGFtIHVzaW5nIGEgYmluYXJ5IHBhdHRlcm4gdG8gc3BlY2lmeSBhbGwgMl4zIGNvbWJpbmF0aW9ucyBiZWxvd1xuXHRcdF9wb2ludHNbMF0uc2V0KHRoaXMubWluLngsIHRoaXMubWluLnksIHRoaXMubWluLnopLmFwcGx5TWF0cml4NChtYXRyaXgpOyAvLyAwMDBcblx0XHRfcG9pbnRzWzFdLnNldCh0aGlzLm1pbi54LCB0aGlzLm1pbi55LCB0aGlzLm1heC56KS5hcHBseU1hdHJpeDQobWF0cml4KTsgLy8gMDAxXG5cdFx0X3BvaW50c1syXS5zZXQodGhpcy5taW4ueCwgdGhpcy5tYXgueSwgdGhpcy5taW4ueikuYXBwbHlNYXRyaXg0KG1hdHJpeCk7IC8vIDAxMFxuXHRcdF9wb2ludHNbM10uc2V0KHRoaXMubWluLngsIHRoaXMubWF4LnksIHRoaXMubWF4LnopLmFwcGx5TWF0cml4NChtYXRyaXgpOyAvLyAwMTFcblx0XHRfcG9pbnRzWzRdLnNldCh0aGlzLm1heC54LCB0aGlzLm1pbi55LCB0aGlzLm1pbi56KS5hcHBseU1hdHJpeDQobWF0cml4KTsgLy8gMTAwXG5cdFx0X3BvaW50c1s1XS5zZXQodGhpcy5tYXgueCwgdGhpcy5taW4ueSwgdGhpcy5tYXgueikuYXBwbHlNYXRyaXg0KG1hdHJpeCk7IC8vIDEwMVxuXHRcdF9wb2ludHNbNl0uc2V0KHRoaXMubWF4LngsIHRoaXMubWF4LnksIHRoaXMubWluLnopLmFwcGx5TWF0cml4NChtYXRyaXgpOyAvLyAxMTBcblx0XHRfcG9pbnRzWzddLnNldCh0aGlzLm1heC54LCB0aGlzLm1heC55LCB0aGlzLm1heC56KS5hcHBseU1hdHJpeDQobWF0cml4KTsgLy8gMTExXG5cblx0XHR0aGlzLnNldEZyb21Qb2ludHMoX3BvaW50cyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0dHJhbnNsYXRlKG9mZnNldCkge1xuXHRcdHRoaXMubWluLmFkZChvZmZzZXQpO1xuXHRcdHRoaXMubWF4LmFkZChvZmZzZXQpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGVxdWFscyhib3gpIHtcblx0XHRyZXR1cm4gYm94Lm1pbi5lcXVhbHModGhpcy5taW4pICYmIGJveC5tYXguZXF1YWxzKHRoaXMubWF4KTtcblx0fVxufVxuY29uc3QgX3BvaW50cyA9IFsvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKSwgLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCksIC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpLCAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKSwgLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCksIC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpLCAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKSwgLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCldO1xuY29uc3QgX3ZlY3RvciRiID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5jb25zdCBfYm94JDMgPSAvKkBfX1BVUkVfXyovbmV3IEJveDMoKTtcblxuLy8gdHJpYW5nbGUgY2VudGVyZWQgdmVydGljZXNcblxuY29uc3QgX3YwJDIgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF92MSQ3ID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5jb25zdCBfdjIkNCA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG4vLyB0cmlhbmdsZSBlZGdlIHZlY3RvcnNcblxuY29uc3QgX2YwID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5jb25zdCBfZjEgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9mMiA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuY29uc3QgX2NlbnRlciA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuY29uc3QgX2V4dGVudHMgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF90cmlhbmdsZU5vcm1hbCA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuY29uc3QgX3Rlc3RBeGlzID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5mdW5jdGlvbiBzYXRGb3JBeGVzKGF4ZXMsIHYwLCB2MSwgdjIsIGV4dGVudHMpIHtcblx0Zm9yIChsZXQgaSA9IDAsIGogPSBheGVzLmxlbmd0aCAtIDM7IGkgPD0gajsgaSArPSAzKSB7XG5cdFx0X3Rlc3RBeGlzLmZyb21BcnJheShheGVzLCBpKTtcblx0XHQvLyBwcm9qZWN0IHRoZSBhYWJiIG9udG8gdGhlIHNlcGFyYXRpbmcgYXhpc1xuXHRcdGNvbnN0IHIgPSBleHRlbnRzLnggKiBNYXRoLmFicyhfdGVzdEF4aXMueCkgKyBleHRlbnRzLnkgKiBNYXRoLmFicyhfdGVzdEF4aXMueSkgKyBleHRlbnRzLnogKiBNYXRoLmFicyhfdGVzdEF4aXMueik7XG5cdFx0Ly8gcHJvamVjdCBhbGwgMyB2ZXJ0aWNlcyBvZiB0aGUgdHJpYW5nbGUgb250byB0aGUgc2VwYXJhdGluZyBheGlzXG5cdFx0Y29uc3QgcDAgPSB2MC5kb3QoX3Rlc3RBeGlzKTtcblx0XHRjb25zdCBwMSA9IHYxLmRvdChfdGVzdEF4aXMpO1xuXHRcdGNvbnN0IHAyID0gdjIuZG90KF90ZXN0QXhpcyk7XG5cdFx0Ly8gYWN0dWFsIHRlc3QsIGJhc2ljYWxseSBzZWUgaWYgZWl0aGVyIG9mIHRoZSBtb3N0IGV4dHJlbWUgb2YgdGhlIHRyaWFuZ2xlIHBvaW50cyBpbnRlcnNlY3RzIHJcblx0XHRpZiAoTWF0aC5tYXgoLU1hdGgubWF4KHAwLCBwMSwgcDIpLCBNYXRoLm1pbihwMCwgcDEsIHAyKSkgPiByKSB7XG5cdFx0XHQvLyBwb2ludHMgb2YgdGhlIHByb2plY3RlZCB0cmlhbmdsZSBhcmUgb3V0c2lkZSB0aGUgcHJvamVjdGVkIGhhbGYtbGVuZ3RoIG9mIHRoZSBhYWJiXG5cdFx0XHQvLyB0aGUgYXhpcyBpcyBzZXBhcmF0aW5nIGFuZCB3ZSBjYW4gZXhpdFxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuY29uc3QgX2JveCQyID0gLypAX19QVVJFX18qL25ldyBCb3gzKCk7XG5jb25zdCBfdjEkNiA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuY29uc3QgX3YyJDMgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcbmNsYXNzIFNwaGVyZSB7XG5cdGNvbnN0cnVjdG9yKGNlbnRlciA9IG5ldyBWZWN0b3IzKCksIHJhZGl1cyA9IC0xKSB7XG5cdFx0dGhpcy5jZW50ZXIgPSBjZW50ZXI7XG5cdFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XG5cdH1cblx0c2V0KGNlbnRlciwgcmFkaXVzKSB7XG5cdFx0dGhpcy5jZW50ZXIuY29weShjZW50ZXIpO1xuXHRcdHRoaXMucmFkaXVzID0gcmFkaXVzO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHNldEZyb21Qb2ludHMocG9pbnRzLCBvcHRpb25hbENlbnRlcikge1xuXHRcdGNvbnN0IGNlbnRlciA9IHRoaXMuY2VudGVyO1xuXHRcdGlmIChvcHRpb25hbENlbnRlciAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjZW50ZXIuY29weShvcHRpb25hbENlbnRlcik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdF9ib3gkMi5zZXRGcm9tUG9pbnRzKHBvaW50cykuZ2V0Q2VudGVyKGNlbnRlcik7XG5cdFx0fVxuXHRcdGxldCBtYXhSYWRpdXNTcSA9IDA7XG5cdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdG1heFJhZGl1c1NxID0gTWF0aC5tYXgobWF4UmFkaXVzU3EsIGNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZChwb2ludHNbaV0pKTtcblx0XHR9XG5cdFx0dGhpcy5yYWRpdXMgPSBNYXRoLnNxcnQobWF4UmFkaXVzU3EpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGNvcHkoc3BoZXJlKSB7XG5cdFx0dGhpcy5jZW50ZXIuY29weShzcGhlcmUuY2VudGVyKTtcblx0XHR0aGlzLnJhZGl1cyA9IHNwaGVyZS5yYWRpdXM7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0aXNFbXB0eSgpIHtcblx0XHRyZXR1cm4gdGhpcy5yYWRpdXMgPCAwO1xuXHR9XG5cdG1ha2VFbXB0eSgpIHtcblx0XHR0aGlzLmNlbnRlci5zZXQoMCwgMCwgMCk7XG5cdFx0dGhpcy5yYWRpdXMgPSAtMTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRjb250YWluc1BvaW50KHBvaW50KSB7XG5cdFx0cmV0dXJuIHBvaW50LmRpc3RhbmNlVG9TcXVhcmVkKHRoaXMuY2VudGVyKSA8PSB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzO1xuXHR9XG5cdGRpc3RhbmNlVG9Qb2ludChwb2ludCkge1xuXHRcdHJldHVybiBwb2ludC5kaXN0YW5jZVRvKHRoaXMuY2VudGVyKSAtIHRoaXMucmFkaXVzO1xuXHR9XG5cdGludGVyc2VjdHNTcGhlcmUoc3BoZXJlKSB7XG5cdFx0Y29uc3QgcmFkaXVzU3VtID0gdGhpcy5yYWRpdXMgKyBzcGhlcmUucmFkaXVzO1xuXHRcdHJldHVybiBzcGhlcmUuY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKHRoaXMuY2VudGVyKSA8PSByYWRpdXNTdW0gKiByYWRpdXNTdW07XG5cdH1cblx0aW50ZXJzZWN0c0JveChib3gpIHtcblx0XHRyZXR1cm4gYm94LmludGVyc2VjdHNTcGhlcmUodGhpcyk7XG5cdH1cblx0aW50ZXJzZWN0c1BsYW5lKHBsYW5lKSB7XG5cdFx0cmV0dXJuIE1hdGguYWJzKHBsYW5lLmRpc3RhbmNlVG9Qb2ludCh0aGlzLmNlbnRlcikpIDw9IHRoaXMucmFkaXVzO1xuXHR9XG5cdGNsYW1wUG9pbnQocG9pbnQsIHRhcmdldCkge1xuXHRcdGNvbnN0IGRlbHRhTGVuZ3RoU3EgPSB0aGlzLmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZChwb2ludCk7XG5cdFx0dGFyZ2V0LmNvcHkocG9pbnQpO1xuXHRcdGlmIChkZWx0YUxlbmd0aFNxID4gdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cykge1xuXHRcdFx0dGFyZ2V0LnN1Yih0aGlzLmNlbnRlcikubm9ybWFsaXplKCk7XG5cdFx0XHR0YXJnZXQubXVsdGlwbHlTY2FsYXIodGhpcy5yYWRpdXMpLmFkZCh0aGlzLmNlbnRlcik7XG5cdFx0fVxuXHRcdHJldHVybiB0YXJnZXQ7XG5cdH1cblx0Z2V0Qm91bmRpbmdCb3godGFyZ2V0KSB7XG5cdFx0aWYgKHRoaXMuaXNFbXB0eSgpKSB7XG5cdFx0XHQvLyBFbXB0eSBzcGhlcmUgcHJvZHVjZXMgZW1wdHkgYm91bmRpbmcgYm94XG5cdFx0XHR0YXJnZXQubWFrZUVtcHR5KCk7XG5cdFx0XHRyZXR1cm4gdGFyZ2V0O1xuXHRcdH1cblx0XHR0YXJnZXQuc2V0KHRoaXMuY2VudGVyLCB0aGlzLmNlbnRlcik7XG5cdFx0dGFyZ2V0LmV4cGFuZEJ5U2NhbGFyKHRoaXMucmFkaXVzKTtcblx0XHRyZXR1cm4gdGFyZ2V0O1xuXHR9XG5cdGFwcGx5TWF0cml4NChtYXRyaXgpIHtcblx0XHR0aGlzLmNlbnRlci5hcHBseU1hdHJpeDQobWF0cml4KTtcblx0XHR0aGlzLnJhZGl1cyA9IHRoaXMucmFkaXVzICogbWF0cml4LmdldE1heFNjYWxlT25BeGlzKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0dHJhbnNsYXRlKG9mZnNldCkge1xuXHRcdHRoaXMuY2VudGVyLmFkZChvZmZzZXQpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGV4cGFuZEJ5UG9pbnQocG9pbnQpIHtcblx0XHRpZiAodGhpcy5pc0VtcHR5KCkpIHtcblx0XHRcdHRoaXMuY2VudGVyLmNvcHkocG9pbnQpO1xuXHRcdFx0dGhpcy5yYWRpdXMgPSAwO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdF92MSQ2LnN1YlZlY3RvcnMocG9pbnQsIHRoaXMuY2VudGVyKTtcblx0XHRjb25zdCBsZW5ndGhTcSA9IF92MSQ2Lmxlbmd0aFNxKCk7XG5cdFx0aWYgKGxlbmd0aFNxID4gdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cykge1xuXHRcdFx0Ly8gY2FsY3VsYXRlIHRoZSBtaW5pbWFsIHNwaGVyZVxuXG5cdFx0XHRjb25zdCBsZW5ndGggPSBNYXRoLnNxcnQobGVuZ3RoU3EpO1xuXHRcdFx0Y29uc3QgZGVsdGEgPSAobGVuZ3RoIC0gdGhpcy5yYWRpdXMpICogMC41O1xuXHRcdFx0dGhpcy5jZW50ZXIuYWRkU2NhbGVkVmVjdG9yKF92MSQ2LCBkZWx0YSAvIGxlbmd0aCk7XG5cdFx0XHR0aGlzLnJhZGl1cyArPSBkZWx0YTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0dW5pb24oc3BoZXJlKSB7XG5cdFx0aWYgKHNwaGVyZS5pc0VtcHR5KCkpIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAodGhpcy5pc0VtcHR5KCkpIHtcblx0XHRcdHRoaXMuY29weShzcGhlcmUpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICh0aGlzLmNlbnRlci5lcXVhbHMoc3BoZXJlLmNlbnRlcikgPT09IHRydWUpIHtcblx0XHRcdHRoaXMucmFkaXVzID0gTWF0aC5tYXgodGhpcy5yYWRpdXMsIHNwaGVyZS5yYWRpdXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRfdjIkMy5zdWJWZWN0b3JzKHNwaGVyZS5jZW50ZXIsIHRoaXMuY2VudGVyKS5zZXRMZW5ndGgoc3BoZXJlLnJhZGl1cyk7XG5cdFx0XHR0aGlzLmV4cGFuZEJ5UG9pbnQoX3YxJDYuY29weShzcGhlcmUuY2VudGVyKS5hZGQoX3YyJDMpKTtcblx0XHRcdHRoaXMuZXhwYW5kQnlQb2ludChfdjEkNi5jb3B5KHNwaGVyZS5jZW50ZXIpLnN1YihfdjIkMykpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRlcXVhbHMoc3BoZXJlKSB7XG5cdFx0cmV0dXJuIHNwaGVyZS5jZW50ZXIuZXF1YWxzKHRoaXMuY2VudGVyKSAmJiBzcGhlcmUucmFkaXVzID09PSB0aGlzLnJhZGl1cztcblx0fVxuXHRjbG9uZSgpIHtcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpO1xuXHR9XG59XG5cbmNvbnN0IF92ZWN0b3IkYSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuY29uc3QgX3NlZ0NlbnRlciA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuY29uc3QgX3NlZ0RpciA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuY29uc3QgX2RpZmYgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9lZGdlMSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuY29uc3QgX2VkZ2UyID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5jb25zdCBfbm9ybWFsJDEgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcbmNsYXNzIFJheSB7XG5cdGNvbnN0cnVjdG9yKG9yaWdpbiA9IG5ldyBWZWN0b3IzKCksIGRpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKDAsIDAsIC0xKSkge1xuXHRcdHRoaXMub3JpZ2luID0gb3JpZ2luO1xuXHRcdHRoaXMuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuXHR9XG5cdHNldChvcmlnaW4sIGRpcmVjdGlvbikge1xuXHRcdHRoaXMub3JpZ2luLmNvcHkob3JpZ2luKTtcblx0XHR0aGlzLmRpcmVjdGlvbi5jb3B5KGRpcmVjdGlvbik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0Y29weShyYXkpIHtcblx0XHR0aGlzLm9yaWdpbi5jb3B5KHJheS5vcmlnaW4pO1xuXHRcdHRoaXMuZGlyZWN0aW9uLmNvcHkocmF5LmRpcmVjdGlvbik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0YXQodCwgdGFyZ2V0KSB7XG5cdFx0cmV0dXJuIHRhcmdldC5jb3B5KHRoaXMuZGlyZWN0aW9uKS5tdWx0aXBseVNjYWxhcih0KS5hZGQodGhpcy5vcmlnaW4pO1xuXHR9XG5cdGxvb2tBdCh2KSB7XG5cdFx0dGhpcy5kaXJlY3Rpb24uY29weSh2KS5zdWIodGhpcy5vcmlnaW4pLm5vcm1hbGl6ZSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHJlY2FzdCh0KSB7XG5cdFx0dGhpcy5vcmlnaW4uY29weSh0aGlzLmF0KHQsIF92ZWN0b3IkYSkpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGNsb3Nlc3RQb2ludFRvUG9pbnQocG9pbnQsIHRhcmdldCkge1xuXHRcdHRhcmdldC5zdWJWZWN0b3JzKHBvaW50LCB0aGlzLm9yaWdpbik7XG5cdFx0Y29uc3QgZGlyZWN0aW9uRGlzdGFuY2UgPSB0YXJnZXQuZG90KHRoaXMuZGlyZWN0aW9uKTtcblx0XHRpZiAoZGlyZWN0aW9uRGlzdGFuY2UgPCAwKSB7XG5cdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkodGhpcy5vcmlnaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkodGhpcy5kaXJlY3Rpb24pLm11bHRpcGx5U2NhbGFyKGRpcmVjdGlvbkRpc3RhbmNlKS5hZGQodGhpcy5vcmlnaW4pO1xuXHR9XG5cdGRpc3RhbmNlVG9Qb2ludChwb2ludCkge1xuXHRcdHJldHVybiBNYXRoLnNxcnQodGhpcy5kaXN0YW5jZVNxVG9Qb2ludChwb2ludCkpO1xuXHR9XG5cdGRpc3RhbmNlU3FUb1BvaW50KHBvaW50KSB7XG5cdFx0Y29uc3QgZGlyZWN0aW9uRGlzdGFuY2UgPSBfdmVjdG9yJGEuc3ViVmVjdG9ycyhwb2ludCwgdGhpcy5vcmlnaW4pLmRvdCh0aGlzLmRpcmVjdGlvbik7XG5cblx0XHQvLyBwb2ludCBiZWhpbmQgdGhlIHJheVxuXG5cdFx0aWYgKGRpcmVjdGlvbkRpc3RhbmNlIDwgMCkge1xuXHRcdFx0cmV0dXJuIHRoaXMub3JpZ2luLmRpc3RhbmNlVG9TcXVhcmVkKHBvaW50KTtcblx0XHR9XG5cdFx0X3ZlY3RvciRhLmNvcHkodGhpcy5kaXJlY3Rpb24pLm11bHRpcGx5U2NhbGFyKGRpcmVjdGlvbkRpc3RhbmNlKS5hZGQodGhpcy5vcmlnaW4pO1xuXHRcdHJldHVybiBfdmVjdG9yJGEuZGlzdGFuY2VUb1NxdWFyZWQocG9pbnQpO1xuXHR9XG5cdGRpc3RhbmNlU3FUb1NlZ21lbnQodjAsIHYxLCBvcHRpb25hbFBvaW50T25SYXksIG9wdGlvbmFsUG9pbnRPblNlZ21lbnQpIHtcblx0XHQvLyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9wbWpvbmlhay9HZW9tZXRyaWNUb29scy9ibG9iL21hc3Rlci9HVEVuZ2luZS9JbmNsdWRlL01hdGhlbWF0aWNzL0d0ZURpc3RSYXlTZWdtZW50Lmhcblx0XHQvLyBJdCByZXR1cm5zIHRoZSBtaW4gZGlzdGFuY2UgYmV0d2VlbiB0aGUgcmF5IGFuZCB0aGUgc2VnbWVudFxuXHRcdC8vIGRlZmluZWQgYnkgdjAgYW5kIHYxXG5cdFx0Ly8gSXQgY2FuIGFsc28gc2V0IHR3byBvcHRpb25hbCB0YXJnZXRzIDpcblx0XHQvLyAtIFRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSByYXlcblx0XHQvLyAtIFRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSBzZWdtZW50XG5cblx0XHRfc2VnQ2VudGVyLmNvcHkodjApLmFkZCh2MSkubXVsdGlwbHlTY2FsYXIoMC41KTtcblx0XHRfc2VnRGlyLmNvcHkodjEpLnN1Yih2MCkubm9ybWFsaXplKCk7XG5cdFx0X2RpZmYuY29weSh0aGlzLm9yaWdpbikuc3ViKF9zZWdDZW50ZXIpO1xuXHRcdGNvbnN0IHNlZ0V4dGVudCA9IHYwLmRpc3RhbmNlVG8odjEpICogMC41O1xuXHRcdGNvbnN0IGEwMSA9IC10aGlzLmRpcmVjdGlvbi5kb3QoX3NlZ0Rpcik7XG5cdFx0Y29uc3QgYjAgPSBfZGlmZi5kb3QodGhpcy5kaXJlY3Rpb24pO1xuXHRcdGNvbnN0IGIxID0gLV9kaWZmLmRvdChfc2VnRGlyKTtcblx0XHRjb25zdCBjID0gX2RpZmYubGVuZ3RoU3EoKTtcblx0XHRjb25zdCBkZXQgPSBNYXRoLmFicygxIC0gYTAxICogYTAxKTtcblx0XHRsZXQgczAsIHMxLCBzcXJEaXN0LCBleHREZXQ7XG5cdFx0aWYgKGRldCA+IDApIHtcblx0XHRcdC8vIFRoZSByYXkgYW5kIHNlZ21lbnQgYXJlIG5vdCBwYXJhbGxlbC5cblxuXHRcdFx0czAgPSBhMDEgKiBiMSAtIGIwO1xuXHRcdFx0czEgPSBhMDEgKiBiMCAtIGIxO1xuXHRcdFx0ZXh0RGV0ID0gc2VnRXh0ZW50ICogZGV0O1xuXHRcdFx0aWYgKHMwID49IDApIHtcblx0XHRcdFx0aWYgKHMxID49IC1leHREZXQpIHtcblx0XHRcdFx0XHRpZiAoczEgPD0gZXh0RGV0KSB7XG5cdFx0XHRcdFx0XHQvLyByZWdpb24gMFxuXHRcdFx0XHRcdFx0Ly8gTWluaW11bSBhdCBpbnRlcmlvciBwb2ludHMgb2YgcmF5IGFuZCBzZWdtZW50LlxuXG5cdFx0XHRcdFx0XHRjb25zdCBpbnZEZXQgPSAxIC8gZGV0O1xuXHRcdFx0XHRcdFx0czAgKj0gaW52RGV0O1xuXHRcdFx0XHRcdFx0czEgKj0gaW52RGV0O1xuXHRcdFx0XHRcdFx0c3FyRGlzdCA9IHMwICogKHMwICsgYTAxICogczEgKyAyICogYjApICsgczEgKiAoYTAxICogczAgKyBzMSArIDIgKiBiMSkgKyBjO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyByZWdpb24gMVxuXG5cdFx0XHRcdFx0XHRzMSA9IHNlZ0V4dGVudDtcblx0XHRcdFx0XHRcdHMwID0gTWF0aC5tYXgoMCwgLShhMDEgKiBzMSArIGIwKSk7XG5cdFx0XHRcdFx0XHRzcXJEaXN0ID0gLXMwICogczAgKyBzMSAqIChzMSArIDIgKiBiMSkgKyBjO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyByZWdpb24gNVxuXG5cdFx0XHRcdFx0czEgPSAtc2VnRXh0ZW50O1xuXHRcdFx0XHRcdHMwID0gTWF0aC5tYXgoMCwgLShhMDEgKiBzMSArIGIwKSk7XG5cdFx0XHRcdFx0c3FyRGlzdCA9IC1zMCAqIHMwICsgczEgKiAoczEgKyAyICogYjEpICsgYztcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHMxIDw9IC1leHREZXQpIHtcblx0XHRcdFx0XHQvLyByZWdpb24gNFxuXG5cdFx0XHRcdFx0czAgPSBNYXRoLm1heCgwLCAtKC1hMDEgKiBzZWdFeHRlbnQgKyBiMCkpO1xuXHRcdFx0XHRcdHMxID0gczAgPiAwID8gLXNlZ0V4dGVudCA6IE1hdGgubWluKE1hdGgubWF4KC1zZWdFeHRlbnQsIC1iMSksIHNlZ0V4dGVudCk7XG5cdFx0XHRcdFx0c3FyRGlzdCA9IC1zMCAqIHMwICsgczEgKiAoczEgKyAyICogYjEpICsgYztcblx0XHRcdFx0fSBlbHNlIGlmIChzMSA8PSBleHREZXQpIHtcblx0XHRcdFx0XHQvLyByZWdpb24gM1xuXG5cdFx0XHRcdFx0czAgPSAwO1xuXHRcdFx0XHRcdHMxID0gTWF0aC5taW4oTWF0aC5tYXgoLXNlZ0V4dGVudCwgLWIxKSwgc2VnRXh0ZW50KTtcblx0XHRcdFx0XHRzcXJEaXN0ID0gczEgKiAoczEgKyAyICogYjEpICsgYztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyByZWdpb24gMlxuXG5cdFx0XHRcdFx0czAgPSBNYXRoLm1heCgwLCAtKGEwMSAqIHNlZ0V4dGVudCArIGIwKSk7XG5cdFx0XHRcdFx0czEgPSBzMCA+IDAgPyBzZWdFeHRlbnQgOiBNYXRoLm1pbihNYXRoLm1heCgtc2VnRXh0ZW50LCAtYjEpLCBzZWdFeHRlbnQpO1xuXHRcdFx0XHRcdHNxckRpc3QgPSAtczAgKiBzMCArIHMxICogKHMxICsgMiAqIGIxKSArIGM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gUmF5IGFuZCBzZWdtZW50IGFyZSBwYXJhbGxlbC5cblxuXHRcdFx0czEgPSBhMDEgPiAwID8gLXNlZ0V4dGVudCA6IHNlZ0V4dGVudDtcblx0XHRcdHMwID0gTWF0aC5tYXgoMCwgLShhMDEgKiBzMSArIGIwKSk7XG5cdFx0XHRzcXJEaXN0ID0gLXMwICogczAgKyBzMSAqIChzMSArIDIgKiBiMSkgKyBjO1xuXHRcdH1cblx0XHRpZiAob3B0aW9uYWxQb2ludE9uUmF5KSB7XG5cdFx0XHRvcHRpb25hbFBvaW50T25SYXkuY29weSh0aGlzLmRpcmVjdGlvbikubXVsdGlwbHlTY2FsYXIoczApLmFkZCh0aGlzLm9yaWdpbik7XG5cdFx0fVxuXHRcdGlmIChvcHRpb25hbFBvaW50T25TZWdtZW50KSB7XG5cdFx0XHRvcHRpb25hbFBvaW50T25TZWdtZW50LmNvcHkoX3NlZ0RpcikubXVsdGlwbHlTY2FsYXIoczEpLmFkZChfc2VnQ2VudGVyKTtcblx0XHR9XG5cdFx0cmV0dXJuIHNxckRpc3Q7XG5cdH1cblx0aW50ZXJzZWN0U3BoZXJlKHNwaGVyZSwgdGFyZ2V0KSB7XG5cdFx0X3ZlY3RvciRhLnN1YlZlY3RvcnMoc3BoZXJlLmNlbnRlciwgdGhpcy5vcmlnaW4pO1xuXHRcdGNvbnN0IHRjYSA9IF92ZWN0b3IkYS5kb3QodGhpcy5kaXJlY3Rpb24pO1xuXHRcdGNvbnN0IGQyID0gX3ZlY3RvciRhLmRvdChfdmVjdG9yJGEpIC0gdGNhICogdGNhO1xuXHRcdGNvbnN0IHJhZGl1czIgPSBzcGhlcmUucmFkaXVzICogc3BoZXJlLnJhZGl1cztcblx0XHRpZiAoZDIgPiByYWRpdXMyKSByZXR1cm4gbnVsbDtcblx0XHRjb25zdCB0aGMgPSBNYXRoLnNxcnQocmFkaXVzMiAtIGQyKTtcblxuXHRcdC8vIHQwID0gZmlyc3QgaW50ZXJzZWN0IHBvaW50IC0gZW50cmFuY2Ugb24gZnJvbnQgb2Ygc3BoZXJlXG5cdFx0Y29uc3QgdDAgPSB0Y2EgLSB0aGM7XG5cblx0XHQvLyB0MSA9IHNlY29uZCBpbnRlcnNlY3QgcG9pbnQgLSBleGl0IHBvaW50IG9uIGJhY2sgb2Ygc3BoZXJlXG5cdFx0Y29uc3QgdDEgPSB0Y2EgKyB0aGM7XG5cblx0XHQvLyB0ZXN0IHRvIHNlZSBpZiBib3RoIHQwIGFuZCB0MSBhcmUgYmVoaW5kIHRoZSByYXkgLSBpZiBzbywgcmV0dXJuIG51bGxcblx0XHRpZiAodDAgPCAwICYmIHQxIDwgMCkgcmV0dXJuIG51bGw7XG5cblx0XHQvLyB0ZXN0IHRvIHNlZSBpZiB0MCBpcyBiZWhpbmQgdGhlIHJheTpcblx0XHQvLyBpZiBpdCBpcywgdGhlIHJheSBpcyBpbnNpZGUgdGhlIHNwaGVyZSwgc28gcmV0dXJuIHRoZSBzZWNvbmQgZXhpdCBwb2ludCBzY2FsZWQgYnkgdDEsXG5cdFx0Ly8gaW4gb3JkZXIgdG8gYWx3YXlzIHJldHVybiBhbiBpbnRlcnNlY3QgcG9pbnQgdGhhdCBpcyBpbiBmcm9udCBvZiB0aGUgcmF5LlxuXHRcdGlmICh0MCA8IDApIHJldHVybiB0aGlzLmF0KHQxLCB0YXJnZXQpO1xuXG5cdFx0Ly8gZWxzZSB0MCBpcyBpbiBmcm9udCBvZiB0aGUgcmF5LCBzbyByZXR1cm4gdGhlIGZpcnN0IGNvbGxpc2lvbiBwb2ludCBzY2FsZWQgYnkgdDBcblx0XHRyZXR1cm4gdGhpcy5hdCh0MCwgdGFyZ2V0KTtcblx0fVxuXHRpbnRlcnNlY3RzU3BoZXJlKHNwaGVyZSkge1xuXHRcdHJldHVybiB0aGlzLmRpc3RhbmNlU3FUb1BvaW50KHNwaGVyZS5jZW50ZXIpIDw9IHNwaGVyZS5yYWRpdXMgKiBzcGhlcmUucmFkaXVzO1xuXHR9XG5cdGRpc3RhbmNlVG9QbGFuZShwbGFuZSkge1xuXHRcdGNvbnN0IGRlbm9taW5hdG9yID0gcGxhbmUubm9ybWFsLmRvdCh0aGlzLmRpcmVjdGlvbik7XG5cdFx0aWYgKGRlbm9taW5hdG9yID09PSAwKSB7XG5cdFx0XHQvLyBsaW5lIGlzIGNvcGxhbmFyLCByZXR1cm4gb3JpZ2luXG5cdFx0XHRpZiAocGxhbmUuZGlzdGFuY2VUb1BvaW50KHRoaXMub3JpZ2luKSA9PT0gMCkge1xuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTnVsbCBpcyBwcmVmZXJhYmxlIHRvIHVuZGVmaW5lZCBzaW5jZSB1bmRlZmluZWQgbWVhbnMuLi4uIGl0IGlzIHVuZGVmaW5lZFxuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0Y29uc3QgdCA9IC0odGhpcy5vcmlnaW4uZG90KHBsYW5lLm5vcm1hbCkgKyBwbGFuZS5jb25zdGFudCkgLyBkZW5vbWluYXRvcjtcblxuXHRcdC8vIFJldHVybiBpZiB0aGUgcmF5IG5ldmVyIGludGVyc2VjdHMgdGhlIHBsYW5lXG5cblx0XHRyZXR1cm4gdCA+PSAwID8gdCA6IG51bGw7XG5cdH1cblx0aW50ZXJzZWN0UGxhbmUocGxhbmUsIHRhcmdldCkge1xuXHRcdGNvbnN0IHQgPSB0aGlzLmRpc3RhbmNlVG9QbGFuZShwbGFuZSk7XG5cdFx0aWYgKHQgPT09IG51bGwpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5hdCh0LCB0YXJnZXQpO1xuXHR9XG5cdGludGVyc2VjdHNQbGFuZShwbGFuZSkge1xuXHRcdC8vIGNoZWNrIGlmIHRoZSByYXkgbGllcyBvbiB0aGUgcGxhbmUgZmlyc3RcblxuXHRcdGNvbnN0IGRpc3RUb1BvaW50ID0gcGxhbmUuZGlzdGFuY2VUb1BvaW50KHRoaXMub3JpZ2luKTtcblx0XHRpZiAoZGlzdFRvUG9pbnQgPT09IDApIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRjb25zdCBkZW5vbWluYXRvciA9IHBsYW5lLm5vcm1hbC5kb3QodGhpcy5kaXJlY3Rpb24pO1xuXHRcdGlmIChkZW5vbWluYXRvciAqIGRpc3RUb1BvaW50IDwgMCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gcmF5IG9yaWdpbiBpcyBiZWhpbmQgdGhlIHBsYW5lIChhbmQgaXMgcG9pbnRpbmcgYmVoaW5kIGl0KVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdGludGVyc2VjdEJveChib3gsIHRhcmdldCkge1xuXHRcdGxldCB0bWluLCB0bWF4LCB0eW1pbiwgdHltYXgsIHR6bWluLCB0em1heDtcblx0XHRjb25zdCBpbnZkaXJ4ID0gMSAvIHRoaXMuZGlyZWN0aW9uLngsXG5cdFx0XHRpbnZkaXJ5ID0gMSAvIHRoaXMuZGlyZWN0aW9uLnksXG5cdFx0XHRpbnZkaXJ6ID0gMSAvIHRoaXMuZGlyZWN0aW9uLno7XG5cdFx0Y29uc3Qgb3JpZ2luID0gdGhpcy5vcmlnaW47XG5cdFx0aWYgKGludmRpcnggPj0gMCkge1xuXHRcdFx0dG1pbiA9IChib3gubWluLnggLSBvcmlnaW4ueCkgKiBpbnZkaXJ4O1xuXHRcdFx0dG1heCA9IChib3gubWF4LnggLSBvcmlnaW4ueCkgKiBpbnZkaXJ4O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0bWluID0gKGJveC5tYXgueCAtIG9yaWdpbi54KSAqIGludmRpcng7XG5cdFx0XHR0bWF4ID0gKGJveC5taW4ueCAtIG9yaWdpbi54KSAqIGludmRpcng7XG5cdFx0fVxuXHRcdGlmIChpbnZkaXJ5ID49IDApIHtcblx0XHRcdHR5bWluID0gKGJveC5taW4ueSAtIG9yaWdpbi55KSAqIGludmRpcnk7XG5cdFx0XHR0eW1heCA9IChib3gubWF4LnkgLSBvcmlnaW4ueSkgKiBpbnZkaXJ5O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0eW1pbiA9IChib3gubWF4LnkgLSBvcmlnaW4ueSkgKiBpbnZkaXJ5O1xuXHRcdFx0dHltYXggPSAoYm94Lm1pbi55IC0gb3JpZ2luLnkpICogaW52ZGlyeTtcblx0XHR9XG5cdFx0aWYgKHRtaW4gPiB0eW1heCB8fCB0eW1pbiA+IHRtYXgpIHJldHVybiBudWxsO1xuXHRcdGlmICh0eW1pbiA+IHRtaW4gfHwgaXNOYU4odG1pbikpIHRtaW4gPSB0eW1pbjtcblx0XHRpZiAodHltYXggPCB0bWF4IHx8IGlzTmFOKHRtYXgpKSB0bWF4ID0gdHltYXg7XG5cdFx0aWYgKGludmRpcnogPj0gMCkge1xuXHRcdFx0dHptaW4gPSAoYm94Lm1pbi56IC0gb3JpZ2luLnopICogaW52ZGlyejtcblx0XHRcdHR6bWF4ID0gKGJveC5tYXgueiAtIG9yaWdpbi56KSAqIGludmRpcno7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHR6bWluID0gKGJveC5tYXgueiAtIG9yaWdpbi56KSAqIGludmRpcno7XG5cdFx0XHR0em1heCA9IChib3gubWluLnogLSBvcmlnaW4ueikgKiBpbnZkaXJ6O1xuXHRcdH1cblx0XHRpZiAodG1pbiA+IHR6bWF4IHx8IHR6bWluID4gdG1heCkgcmV0dXJuIG51bGw7XG5cdFx0aWYgKHR6bWluID4gdG1pbiB8fCB0bWluICE9PSB0bWluKSB0bWluID0gdHptaW47XG5cdFx0aWYgKHR6bWF4IDwgdG1heCB8fCB0bWF4ICE9PSB0bWF4KSB0bWF4ID0gdHptYXg7XG5cblx0XHQvL3JldHVybiBwb2ludCBjbG9zZXN0IHRvIHRoZSByYXkgKHBvc2l0aXZlIHNpZGUpXG5cblx0XHRpZiAodG1heCA8IDApIHJldHVybiBudWxsO1xuXHRcdHJldHVybiB0aGlzLmF0KHRtaW4gPj0gMCA/IHRtaW4gOiB0bWF4LCB0YXJnZXQpO1xuXHR9XG5cdGludGVyc2VjdHNCb3goYm94KSB7XG5cdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0Qm94KGJveCwgX3ZlY3RvciRhKSAhPT0gbnVsbDtcblx0fVxuXHRpbnRlcnNlY3RUcmlhbmdsZShhLCBiLCBjLCBiYWNrZmFjZUN1bGxpbmcsIHRhcmdldCkge1xuXHRcdC8vIENvbXB1dGUgdGhlIG9mZnNldCBvcmlnaW4sIGVkZ2VzLCBhbmQgbm9ybWFsLlxuXG5cdFx0Ly8gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vcG1qb25pYWsvR2VvbWV0cmljVG9vbHMvYmxvYi9tYXN0ZXIvR1RFbmdpbmUvSW5jbHVkZS9NYXRoZW1hdGljcy9HdGVJbnRyUmF5M1RyaWFuZ2xlMy5oXG5cblx0XHRfZWRnZTEuc3ViVmVjdG9ycyhiLCBhKTtcblx0XHRfZWRnZTIuc3ViVmVjdG9ycyhjLCBhKTtcblx0XHRfbm9ybWFsJDEuY3Jvc3NWZWN0b3JzKF9lZGdlMSwgX2VkZ2UyKTtcblxuXHRcdC8vIFNvbHZlIFEgKyB0KkQgPSBiMSpFMSArIGIyKkUyIChRID0ga0RpZmYsIEQgPSByYXkgZGlyZWN0aW9uLFxuXHRcdC8vIEUxID0ga0VkZ2UxLCBFMiA9IGtFZGdlMiwgTiA9IENyb3NzKEUxLEUyKSkgYnlcblx0XHQvL1x0IHxEb3QoRCxOKXwqYjEgPSBzaWduKERvdChELE4pKSpEb3QoRCxDcm9zcyhRLEUyKSlcblx0XHQvL1x0IHxEb3QoRCxOKXwqYjIgPSBzaWduKERvdChELE4pKSpEb3QoRCxDcm9zcyhFMSxRKSlcblx0XHQvL1x0IHxEb3QoRCxOKXwqdCA9IC1zaWduKERvdChELE4pKSpEb3QoUSxOKVxuXHRcdGxldCBEZE4gPSB0aGlzLmRpcmVjdGlvbi5kb3QoX25vcm1hbCQxKTtcblx0XHRsZXQgc2lnbjtcblx0XHRpZiAoRGROID4gMCkge1xuXHRcdFx0aWYgKGJhY2tmYWNlQ3VsbGluZykgcmV0dXJuIG51bGw7XG5cdFx0XHRzaWduID0gMTtcblx0XHR9IGVsc2UgaWYgKERkTiA8IDApIHtcblx0XHRcdHNpZ24gPSAtMTtcblx0XHRcdERkTiA9IC1EZE47XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHRfZGlmZi5zdWJWZWN0b3JzKHRoaXMub3JpZ2luLCBhKTtcblx0XHRjb25zdCBEZFF4RTIgPSBzaWduICogdGhpcy5kaXJlY3Rpb24uZG90KF9lZGdlMi5jcm9zc1ZlY3RvcnMoX2RpZmYsIF9lZGdlMikpO1xuXG5cdFx0Ly8gYjEgPCAwLCBubyBpbnRlcnNlY3Rpb25cblx0XHRpZiAoRGRReEUyIDwgMCkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdGNvbnN0IERkRTF4USA9IHNpZ24gKiB0aGlzLmRpcmVjdGlvbi5kb3QoX2VkZ2UxLmNyb3NzKF9kaWZmKSk7XG5cblx0XHQvLyBiMiA8IDAsIG5vIGludGVyc2VjdGlvblxuXHRcdGlmIChEZEUxeFEgPCAwKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHQvLyBiMStiMiA+IDEsIG5vIGludGVyc2VjdGlvblxuXHRcdGlmIChEZFF4RTIgKyBEZEUxeFEgPiBEZE4pIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdC8vIExpbmUgaW50ZXJzZWN0cyB0cmlhbmdsZSwgY2hlY2sgaWYgcmF5IGRvZXMuXG5cdFx0Y29uc3QgUWROID0gLXNpZ24gKiBfZGlmZi5kb3QoX25vcm1hbCQxKTtcblxuXHRcdC8vIHQgPCAwLCBubyBpbnRlcnNlY3Rpb25cblx0XHRpZiAoUWROIDwgMCkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0Ly8gUmF5IGludGVyc2VjdHMgdHJpYW5nbGUuXG5cdFx0cmV0dXJuIHRoaXMuYXQoUWROIC8gRGROLCB0YXJnZXQpO1xuXHR9XG5cdGFwcGx5TWF0cml4NChtYXRyaXg0KSB7XG5cdFx0dGhpcy5vcmlnaW4uYXBwbHlNYXRyaXg0KG1hdHJpeDQpO1xuXHRcdHRoaXMuZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbihtYXRyaXg0KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRlcXVhbHMocmF5KSB7XG5cdFx0cmV0dXJuIHJheS5vcmlnaW4uZXF1YWxzKHRoaXMub3JpZ2luKSAmJiByYXkuZGlyZWN0aW9uLmVxdWFscyh0aGlzLmRpcmVjdGlvbik7XG5cdH1cblx0Y2xvbmUoKSB7XG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKTtcblx0fVxufVxuXG5jbGFzcyBNYXRyaXg0IHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0TWF0cml4NC5wcm90b3R5cGUuaXNNYXRyaXg0ID0gdHJ1ZTtcblx0XHR0aGlzLmVsZW1lbnRzID0gWzEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDFdO1xuXHR9XG5cdHNldChuMTEsIG4xMiwgbjEzLCBuMTQsIG4yMSwgbjIyLCBuMjMsIG4yNCwgbjMxLCBuMzIsIG4zMywgbjM0LCBuNDEsIG40MiwgbjQzLCBuNDQpIHtcblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0dGVbMF0gPSBuMTE7XG5cdFx0dGVbNF0gPSBuMTI7XG5cdFx0dGVbOF0gPSBuMTM7XG5cdFx0dGVbMTJdID0gbjE0O1xuXHRcdHRlWzFdID0gbjIxO1xuXHRcdHRlWzVdID0gbjIyO1xuXHRcdHRlWzldID0gbjIzO1xuXHRcdHRlWzEzXSA9IG4yNDtcblx0XHR0ZVsyXSA9IG4zMTtcblx0XHR0ZVs2XSA9IG4zMjtcblx0XHR0ZVsxMF0gPSBuMzM7XG5cdFx0dGVbMTRdID0gbjM0O1xuXHRcdHRlWzNdID0gbjQxO1xuXHRcdHRlWzddID0gbjQyO1xuXHRcdHRlWzExXSA9IG40Mztcblx0XHR0ZVsxNV0gPSBuNDQ7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0aWRlbnRpdHkoKSB7XG5cdFx0dGhpcy5zZXQoMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0Y2xvbmUoKSB7XG5cdFx0cmV0dXJuIG5ldyBNYXRyaXg0KCkuZnJvbUFycmF5KHRoaXMuZWxlbWVudHMpO1xuXHR9XG5cdGNvcHkobSkge1xuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRjb25zdCBtZSA9IG0uZWxlbWVudHM7XG5cdFx0dGVbMF0gPSBtZVswXTtcblx0XHR0ZVsxXSA9IG1lWzFdO1xuXHRcdHRlWzJdID0gbWVbMl07XG5cdFx0dGVbM10gPSBtZVszXTtcblx0XHR0ZVs0XSA9IG1lWzRdO1xuXHRcdHRlWzVdID0gbWVbNV07XG5cdFx0dGVbNl0gPSBtZVs2XTtcblx0XHR0ZVs3XSA9IG1lWzddO1xuXHRcdHRlWzhdID0gbWVbOF07XG5cdFx0dGVbOV0gPSBtZVs5XTtcblx0XHR0ZVsxMF0gPSBtZVsxMF07XG5cdFx0dGVbMTFdID0gbWVbMTFdO1xuXHRcdHRlWzEyXSA9IG1lWzEyXTtcblx0XHR0ZVsxM10gPSBtZVsxM107XG5cdFx0dGVbMTRdID0gbWVbMTRdO1xuXHRcdHRlWzE1XSA9IG1lWzE1XTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRjb3B5UG9zaXRpb24obSkge1xuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cyxcblx0XHRcdG1lID0gbS5lbGVtZW50cztcblx0XHR0ZVsxMl0gPSBtZVsxMl07XG5cdFx0dGVbMTNdID0gbWVbMTNdO1xuXHRcdHRlWzE0XSA9IG1lWzE0XTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRzZXRGcm9tTWF0cml4MyhtKSB7XG5cdFx0Y29uc3QgbWUgPSBtLmVsZW1lbnRzO1xuXHRcdHRoaXMuc2V0KG1lWzBdLCBtZVszXSwgbWVbNl0sIDAsIG1lWzFdLCBtZVs0XSwgbWVbN10sIDAsIG1lWzJdLCBtZVs1XSwgbWVbOF0sIDAsIDAsIDAsIDAsIDEpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGV4dHJhY3RCYXNpcyh4QXhpcywgeUF4aXMsIHpBeGlzKSB7XG5cdFx0eEF4aXMuc2V0RnJvbU1hdHJpeENvbHVtbih0aGlzLCAwKTtcblx0XHR5QXhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKHRoaXMsIDEpO1xuXHRcdHpBeGlzLnNldEZyb21NYXRyaXhDb2x1bW4odGhpcywgMik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0bWFrZUJhc2lzKHhBeGlzLCB5QXhpcywgekF4aXMpIHtcblx0XHR0aGlzLnNldCh4QXhpcy54LCB5QXhpcy54LCB6QXhpcy54LCAwLCB4QXhpcy55LCB5QXhpcy55LCB6QXhpcy55LCAwLCB4QXhpcy56LCB5QXhpcy56LCB6QXhpcy56LCAwLCAwLCAwLCAwLCAxKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRleHRyYWN0Um90YXRpb24obSkge1xuXHRcdC8vIHRoaXMgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgcmVmbGVjdGlvbiBtYXRyaWNlc1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdGNvbnN0IG1lID0gbS5lbGVtZW50cztcblx0XHRjb25zdCBzY2FsZVggPSAxIC8gX3YxJDUuc2V0RnJvbU1hdHJpeENvbHVtbihtLCAwKS5sZW5ndGgoKTtcblx0XHRjb25zdCBzY2FsZVkgPSAxIC8gX3YxJDUuc2V0RnJvbU1hdHJpeENvbHVtbihtLCAxKS5sZW5ndGgoKTtcblx0XHRjb25zdCBzY2FsZVogPSAxIC8gX3YxJDUuc2V0RnJvbU1hdHJpeENvbHVtbihtLCAyKS5sZW5ndGgoKTtcblx0XHR0ZVswXSA9IG1lWzBdICogc2NhbGVYO1xuXHRcdHRlWzFdID0gbWVbMV0gKiBzY2FsZVg7XG5cdFx0dGVbMl0gPSBtZVsyXSAqIHNjYWxlWDtcblx0XHR0ZVszXSA9IDA7XG5cdFx0dGVbNF0gPSBtZVs0XSAqIHNjYWxlWTtcblx0XHR0ZVs1XSA9IG1lWzVdICogc2NhbGVZO1xuXHRcdHRlWzZdID0gbWVbNl0gKiBzY2FsZVk7XG5cdFx0dGVbN10gPSAwO1xuXHRcdHRlWzhdID0gbWVbOF0gKiBzY2FsZVo7XG5cdFx0dGVbOV0gPSBtZVs5XSAqIHNjYWxlWjtcblx0XHR0ZVsxMF0gPSBtZVsxMF0gKiBzY2FsZVo7XG5cdFx0dGVbMTFdID0gMDtcblx0XHR0ZVsxMl0gPSAwO1xuXHRcdHRlWzEzXSA9IDA7XG5cdFx0dGVbMTRdID0gMDtcblx0XHR0ZVsxNV0gPSAxO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdG1ha2VSb3RhdGlvbkZyb21FdWxlcihldWxlcikge1xuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRjb25zdCB4ID0gZXVsZXIueCxcblx0XHRcdHkgPSBldWxlci55LFxuXHRcdFx0eiA9IGV1bGVyLno7XG5cdFx0Y29uc3QgYSA9IE1hdGguY29zKHgpLFxuXHRcdFx0YiA9IE1hdGguc2luKHgpO1xuXHRcdGNvbnN0IGMgPSBNYXRoLmNvcyh5KSxcblx0XHRcdGQgPSBNYXRoLnNpbih5KTtcblx0XHRjb25zdCBlID0gTWF0aC5jb3MoeiksXG5cdFx0XHRmID0gTWF0aC5zaW4oeik7XG5cdFx0aWYgKGV1bGVyLm9yZGVyID09PSAnWFlaJykge1xuXHRcdFx0Y29uc3QgYWUgPSBhICogZSxcblx0XHRcdFx0YWYgPSBhICogZixcblx0XHRcdFx0YmUgPSBiICogZSxcblx0XHRcdFx0YmYgPSBiICogZjtcblx0XHRcdHRlWzBdID0gYyAqIGU7XG5cdFx0XHR0ZVs0XSA9IC1jICogZjtcblx0XHRcdHRlWzhdID0gZDtcblx0XHRcdHRlWzFdID0gYWYgKyBiZSAqIGQ7XG5cdFx0XHR0ZVs1XSA9IGFlIC0gYmYgKiBkO1xuXHRcdFx0dGVbOV0gPSAtYiAqIGM7XG5cdFx0XHR0ZVsyXSA9IGJmIC0gYWUgKiBkO1xuXHRcdFx0dGVbNl0gPSBiZSArIGFmICogZDtcblx0XHRcdHRlWzEwXSA9IGEgKiBjO1xuXHRcdH0gZWxzZSBpZiAoZXVsZXIub3JkZXIgPT09ICdZWFonKSB7XG5cdFx0XHRjb25zdCBjZSA9IGMgKiBlLFxuXHRcdFx0XHRjZiA9IGMgKiBmLFxuXHRcdFx0XHRkZSA9IGQgKiBlLFxuXHRcdFx0XHRkZiA9IGQgKiBmO1xuXHRcdFx0dGVbMF0gPSBjZSArIGRmICogYjtcblx0XHRcdHRlWzRdID0gZGUgKiBiIC0gY2Y7XG5cdFx0XHR0ZVs4XSA9IGEgKiBkO1xuXHRcdFx0dGVbMV0gPSBhICogZjtcblx0XHRcdHRlWzVdID0gYSAqIGU7XG5cdFx0XHR0ZVs5XSA9IC1iO1xuXHRcdFx0dGVbMl0gPSBjZiAqIGIgLSBkZTtcblx0XHRcdHRlWzZdID0gZGYgKyBjZSAqIGI7XG5cdFx0XHR0ZVsxMF0gPSBhICogYztcblx0XHR9IGVsc2UgaWYgKGV1bGVyLm9yZGVyID09PSAnWlhZJykge1xuXHRcdFx0Y29uc3QgY2UgPSBjICogZSxcblx0XHRcdFx0Y2YgPSBjICogZixcblx0XHRcdFx0ZGUgPSBkICogZSxcblx0XHRcdFx0ZGYgPSBkICogZjtcblx0XHRcdHRlWzBdID0gY2UgLSBkZiAqIGI7XG5cdFx0XHR0ZVs0XSA9IC1hICogZjtcblx0XHRcdHRlWzhdID0gZGUgKyBjZiAqIGI7XG5cdFx0XHR0ZVsxXSA9IGNmICsgZGUgKiBiO1xuXHRcdFx0dGVbNV0gPSBhICogZTtcblx0XHRcdHRlWzldID0gZGYgLSBjZSAqIGI7XG5cdFx0XHR0ZVsyXSA9IC1hICogZDtcblx0XHRcdHRlWzZdID0gYjtcblx0XHRcdHRlWzEwXSA9IGEgKiBjO1xuXHRcdH0gZWxzZSBpZiAoZXVsZXIub3JkZXIgPT09ICdaWVgnKSB7XG5cdFx0XHRjb25zdCBhZSA9IGEgKiBlLFxuXHRcdFx0XHRhZiA9IGEgKiBmLFxuXHRcdFx0XHRiZSA9IGIgKiBlLFxuXHRcdFx0XHRiZiA9IGIgKiBmO1xuXHRcdFx0dGVbMF0gPSBjICogZTtcblx0XHRcdHRlWzRdID0gYmUgKiBkIC0gYWY7XG5cdFx0XHR0ZVs4XSA9IGFlICogZCArIGJmO1xuXHRcdFx0dGVbMV0gPSBjICogZjtcblx0XHRcdHRlWzVdID0gYmYgKiBkICsgYWU7XG5cdFx0XHR0ZVs5XSA9IGFmICogZCAtIGJlO1xuXHRcdFx0dGVbMl0gPSAtZDtcblx0XHRcdHRlWzZdID0gYiAqIGM7XG5cdFx0XHR0ZVsxMF0gPSBhICogYztcblx0XHR9IGVsc2UgaWYgKGV1bGVyLm9yZGVyID09PSAnWVpYJykge1xuXHRcdFx0Y29uc3QgYWMgPSBhICogYyxcblx0XHRcdFx0YWQgPSBhICogZCxcblx0XHRcdFx0YmMgPSBiICogYyxcblx0XHRcdFx0YmQgPSBiICogZDtcblx0XHRcdHRlWzBdID0gYyAqIGU7XG5cdFx0XHR0ZVs0XSA9IGJkIC0gYWMgKiBmO1xuXHRcdFx0dGVbOF0gPSBiYyAqIGYgKyBhZDtcblx0XHRcdHRlWzFdID0gZjtcblx0XHRcdHRlWzVdID0gYSAqIGU7XG5cdFx0XHR0ZVs5XSA9IC1iICogZTtcblx0XHRcdHRlWzJdID0gLWQgKiBlO1xuXHRcdFx0dGVbNl0gPSBhZCAqIGYgKyBiYztcblx0XHRcdHRlWzEwXSA9IGFjIC0gYmQgKiBmO1xuXHRcdH0gZWxzZSBpZiAoZXVsZXIub3JkZXIgPT09ICdYWlknKSB7XG5cdFx0XHRjb25zdCBhYyA9IGEgKiBjLFxuXHRcdFx0XHRhZCA9IGEgKiBkLFxuXHRcdFx0XHRiYyA9IGIgKiBjLFxuXHRcdFx0XHRiZCA9IGIgKiBkO1xuXHRcdFx0dGVbMF0gPSBjICogZTtcblx0XHRcdHRlWzRdID0gLWY7XG5cdFx0XHR0ZVs4XSA9IGQgKiBlO1xuXHRcdFx0dGVbMV0gPSBhYyAqIGYgKyBiZDtcblx0XHRcdHRlWzVdID0gYSAqIGU7XG5cdFx0XHR0ZVs5XSA9IGFkICogZiAtIGJjO1xuXHRcdFx0dGVbMl0gPSBiYyAqIGYgLSBhZDtcblx0XHRcdHRlWzZdID0gYiAqIGU7XG5cdFx0XHR0ZVsxMF0gPSBiZCAqIGYgKyBhYztcblx0XHR9XG5cblx0XHQvLyBib3R0b20gcm93XG5cdFx0dGVbM10gPSAwO1xuXHRcdHRlWzddID0gMDtcblx0XHR0ZVsxMV0gPSAwO1xuXG5cdFx0Ly8gbGFzdCBjb2x1bW5cblx0XHR0ZVsxMl0gPSAwO1xuXHRcdHRlWzEzXSA9IDA7XG5cdFx0dGVbMTRdID0gMDtcblx0XHR0ZVsxNV0gPSAxO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdG1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKHEpIHtcblx0XHRyZXR1cm4gdGhpcy5jb21wb3NlKF96ZXJvLCBxLCBfb25lKTtcblx0fVxuXHRsb29rQXQoZXllLCB0YXJnZXQsIHVwKSB7XG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdF96LnN1YlZlY3RvcnMoZXllLCB0YXJnZXQpO1xuXHRcdGlmIChfei5sZW5ndGhTcSgpID09PSAwKSB7XG5cdFx0XHQvLyBleWUgYW5kIHRhcmdldCBhcmUgaW4gdGhlIHNhbWUgcG9zaXRpb25cblxuXHRcdFx0X3oueiA9IDE7XG5cdFx0fVxuXHRcdF96Lm5vcm1hbGl6ZSgpO1xuXHRcdF94LmNyb3NzVmVjdG9ycyh1cCwgX3opO1xuXHRcdGlmIChfeC5sZW5ndGhTcSgpID09PSAwKSB7XG5cdFx0XHQvLyB1cCBhbmQgeiBhcmUgcGFyYWxsZWxcblxuXHRcdFx0aWYgKE1hdGguYWJzKHVwLnopID09PSAxKSB7XG5cdFx0XHRcdF96LnggKz0gMC4wMDAxO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0X3oueiArPSAwLjAwMDE7XG5cdFx0XHR9XG5cdFx0XHRfei5ub3JtYWxpemUoKTtcblx0XHRcdF94LmNyb3NzVmVjdG9ycyh1cCwgX3opO1xuXHRcdH1cblx0XHRfeC5ub3JtYWxpemUoKTtcblx0XHRfeS5jcm9zc1ZlY3RvcnMoX3osIF94KTtcblx0XHR0ZVswXSA9IF94Lng7XG5cdFx0dGVbNF0gPSBfeS54O1xuXHRcdHRlWzhdID0gX3oueDtcblx0XHR0ZVsxXSA9IF94Lnk7XG5cdFx0dGVbNV0gPSBfeS55O1xuXHRcdHRlWzldID0gX3oueTtcblx0XHR0ZVsyXSA9IF94Lno7XG5cdFx0dGVbNl0gPSBfeS56O1xuXHRcdHRlWzEwXSA9IF96Lno7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0bXVsdGlwbHkobSkge1xuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXModGhpcywgbSk7XG5cdH1cblx0cHJlbXVsdGlwbHkobSkge1xuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMobSwgdGhpcyk7XG5cdH1cblx0bXVsdGlwbHlNYXRyaWNlcyhhLCBiKSB7XG5cdFx0Y29uc3QgYWUgPSBhLmVsZW1lbnRzO1xuXHRcdGNvbnN0IGJlID0gYi5lbGVtZW50cztcblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0Y29uc3QgYTExID0gYWVbMF0sXG5cdFx0XHRhMTIgPSBhZVs0XSxcblx0XHRcdGExMyA9IGFlWzhdLFxuXHRcdFx0YTE0ID0gYWVbMTJdO1xuXHRcdGNvbnN0IGEyMSA9IGFlWzFdLFxuXHRcdFx0YTIyID0gYWVbNV0sXG5cdFx0XHRhMjMgPSBhZVs5XSxcblx0XHRcdGEyNCA9IGFlWzEzXTtcblx0XHRjb25zdCBhMzEgPSBhZVsyXSxcblx0XHRcdGEzMiA9IGFlWzZdLFxuXHRcdFx0YTMzID0gYWVbMTBdLFxuXHRcdFx0YTM0ID0gYWVbMTRdO1xuXHRcdGNvbnN0IGE0MSA9IGFlWzNdLFxuXHRcdFx0YTQyID0gYWVbN10sXG5cdFx0XHRhNDMgPSBhZVsxMV0sXG5cdFx0XHRhNDQgPSBhZVsxNV07XG5cdFx0Y29uc3QgYjExID0gYmVbMF0sXG5cdFx0XHRiMTIgPSBiZVs0XSxcblx0XHRcdGIxMyA9IGJlWzhdLFxuXHRcdFx0YjE0ID0gYmVbMTJdO1xuXHRcdGNvbnN0IGIyMSA9IGJlWzFdLFxuXHRcdFx0YjIyID0gYmVbNV0sXG5cdFx0XHRiMjMgPSBiZVs5XSxcblx0XHRcdGIyNCA9IGJlWzEzXTtcblx0XHRjb25zdCBiMzEgPSBiZVsyXSxcblx0XHRcdGIzMiA9IGJlWzZdLFxuXHRcdFx0YjMzID0gYmVbMTBdLFxuXHRcdFx0YjM0ID0gYmVbMTRdO1xuXHRcdGNvbnN0IGI0MSA9IGJlWzNdLFxuXHRcdFx0YjQyID0gYmVbN10sXG5cdFx0XHRiNDMgPSBiZVsxMV0sXG5cdFx0XHRiNDQgPSBiZVsxNV07XG5cdFx0dGVbMF0gPSBhMTEgKiBiMTEgKyBhMTIgKiBiMjEgKyBhMTMgKiBiMzEgKyBhMTQgKiBiNDE7XG5cdFx0dGVbNF0gPSBhMTEgKiBiMTIgKyBhMTIgKiBiMjIgKyBhMTMgKiBiMzIgKyBhMTQgKiBiNDI7XG5cdFx0dGVbOF0gPSBhMTEgKiBiMTMgKyBhMTIgKiBiMjMgKyBhMTMgKiBiMzMgKyBhMTQgKiBiNDM7XG5cdFx0dGVbMTJdID0gYTExICogYjE0ICsgYTEyICogYjI0ICsgYTEzICogYjM0ICsgYTE0ICogYjQ0O1xuXHRcdHRlWzFdID0gYTIxICogYjExICsgYTIyICogYjIxICsgYTIzICogYjMxICsgYTI0ICogYjQxO1xuXHRcdHRlWzVdID0gYTIxICogYjEyICsgYTIyICogYjIyICsgYTIzICogYjMyICsgYTI0ICogYjQyO1xuXHRcdHRlWzldID0gYTIxICogYjEzICsgYTIyICogYjIzICsgYTIzICogYjMzICsgYTI0ICogYjQzO1xuXHRcdHRlWzEzXSA9IGEyMSAqIGIxNCArIGEyMiAqIGIyNCArIGEyMyAqIGIzNCArIGEyNCAqIGI0NDtcblx0XHR0ZVsyXSA9IGEzMSAqIGIxMSArIGEzMiAqIGIyMSArIGEzMyAqIGIzMSArIGEzNCAqIGI0MTtcblx0XHR0ZVs2XSA9IGEzMSAqIGIxMiArIGEzMiAqIGIyMiArIGEzMyAqIGIzMiArIGEzNCAqIGI0Mjtcblx0XHR0ZVsxMF0gPSBhMzEgKiBiMTMgKyBhMzIgKiBiMjMgKyBhMzMgKiBiMzMgKyBhMzQgKiBiNDM7XG5cdFx0dGVbMTRdID0gYTMxICogYjE0ICsgYTMyICogYjI0ICsgYTMzICogYjM0ICsgYTM0ICogYjQ0O1xuXHRcdHRlWzNdID0gYTQxICogYjExICsgYTQyICogYjIxICsgYTQzICogYjMxICsgYTQ0ICogYjQxO1xuXHRcdHRlWzddID0gYTQxICogYjEyICsgYTQyICogYjIyICsgYTQzICogYjMyICsgYTQ0ICogYjQyO1xuXHRcdHRlWzExXSA9IGE0MSAqIGIxMyArIGE0MiAqIGIyMyArIGE0MyAqIGIzMyArIGE0NCAqIGI0Mztcblx0XHR0ZVsxNV0gPSBhNDEgKiBiMTQgKyBhNDIgKiBiMjQgKyBhNDMgKiBiMzQgKyBhNDQgKiBiNDQ7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0bXVsdGlwbHlTY2FsYXIocykge1xuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHR0ZVswXSAqPSBzO1xuXHRcdHRlWzRdICo9IHM7XG5cdFx0dGVbOF0gKj0gcztcblx0XHR0ZVsxMl0gKj0gcztcblx0XHR0ZVsxXSAqPSBzO1xuXHRcdHRlWzVdICo9IHM7XG5cdFx0dGVbOV0gKj0gcztcblx0XHR0ZVsxM10gKj0gcztcblx0XHR0ZVsyXSAqPSBzO1xuXHRcdHRlWzZdICo9IHM7XG5cdFx0dGVbMTBdICo9IHM7XG5cdFx0dGVbMTRdICo9IHM7XG5cdFx0dGVbM10gKj0gcztcblx0XHR0ZVs3XSAqPSBzO1xuXHRcdHRlWzExXSAqPSBzO1xuXHRcdHRlWzE1XSAqPSBzO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGRldGVybWluYW50KCkge1xuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRjb25zdCBuMTEgPSB0ZVswXSxcblx0XHRcdG4xMiA9IHRlWzRdLFxuXHRcdFx0bjEzID0gdGVbOF0sXG5cdFx0XHRuMTQgPSB0ZVsxMl07XG5cdFx0Y29uc3QgbjIxID0gdGVbMV0sXG5cdFx0XHRuMjIgPSB0ZVs1XSxcblx0XHRcdG4yMyA9IHRlWzldLFxuXHRcdFx0bjI0ID0gdGVbMTNdO1xuXHRcdGNvbnN0IG4zMSA9IHRlWzJdLFxuXHRcdFx0bjMyID0gdGVbNl0sXG5cdFx0XHRuMzMgPSB0ZVsxMF0sXG5cdFx0XHRuMzQgPSB0ZVsxNF07XG5cdFx0Y29uc3QgbjQxID0gdGVbM10sXG5cdFx0XHRuNDIgPSB0ZVs3XSxcblx0XHRcdG40MyA9IHRlWzExXSxcblx0XHRcdG40NCA9IHRlWzE1XTtcblxuXHRcdC8vVE9ETzogbWFrZSB0aGlzIG1vcmUgZWZmaWNpZW50XG5cdFx0Ly8oIGJhc2VkIG9uIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvbWF0cml4L2Z1bmN0aW9ucy9pbnZlcnNlL2ZvdXJEL2luZGV4Lmh0bSApXG5cblx0XHRyZXR1cm4gbjQxICogKCtuMTQgKiBuMjMgKiBuMzIgLSBuMTMgKiBuMjQgKiBuMzIgLSBuMTQgKiBuMjIgKiBuMzMgKyBuMTIgKiBuMjQgKiBuMzMgKyBuMTMgKiBuMjIgKiBuMzQgLSBuMTIgKiBuMjMgKiBuMzQpICsgbjQyICogKCtuMTEgKiBuMjMgKiBuMzQgLSBuMTEgKiBuMjQgKiBuMzMgKyBuMTQgKiBuMjEgKiBuMzMgLSBuMTMgKiBuMjEgKiBuMzQgKyBuMTMgKiBuMjQgKiBuMzEgLSBuMTQgKiBuMjMgKiBuMzEpICsgbjQzICogKCtuMTEgKiBuMjQgKiBuMzIgLSBuMTEgKiBuMjIgKiBuMzQgLSBuMTQgKiBuMjEgKiBuMzIgKyBuMTIgKiBuMjEgKiBuMzQgKyBuMTQgKiBuMjIgKiBuMzEgLSBuMTIgKiBuMjQgKiBuMzEpICsgbjQ0ICogKC1uMTMgKiBuMjIgKiBuMzEgLSBuMTEgKiBuMjMgKiBuMzIgKyBuMTEgKiBuMjIgKiBuMzMgKyBuMTMgKiBuMjEgKiBuMzIgLSBuMTIgKiBuMjEgKiBuMzMgKyBuMTIgKiBuMjMgKiBuMzEpO1xuXHR9XG5cdHRyYW5zcG9zZSgpIHtcblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0bGV0IHRtcDtcblx0XHR0bXAgPSB0ZVsxXTtcblx0XHR0ZVsxXSA9IHRlWzRdO1xuXHRcdHRlWzRdID0gdG1wO1xuXHRcdHRtcCA9IHRlWzJdO1xuXHRcdHRlWzJdID0gdGVbOF07XG5cdFx0dGVbOF0gPSB0bXA7XG5cdFx0dG1wID0gdGVbNl07XG5cdFx0dGVbNl0gPSB0ZVs5XTtcblx0XHR0ZVs5XSA9IHRtcDtcblx0XHR0bXAgPSB0ZVszXTtcblx0XHR0ZVszXSA9IHRlWzEyXTtcblx0XHR0ZVsxMl0gPSB0bXA7XG5cdFx0dG1wID0gdGVbN107XG5cdFx0dGVbN10gPSB0ZVsxM107XG5cdFx0dGVbMTNdID0gdG1wO1xuXHRcdHRtcCA9IHRlWzExXTtcblx0XHR0ZVsxMV0gPSB0ZVsxNF07XG5cdFx0dGVbMTRdID0gdG1wO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHNldFBvc2l0aW9uKHgsIHksIHopIHtcblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0aWYgKHguaXNWZWN0b3IzKSB7XG5cdFx0XHR0ZVsxMl0gPSB4Lng7XG5cdFx0XHR0ZVsxM10gPSB4Lnk7XG5cdFx0XHR0ZVsxNF0gPSB4Lno7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRlWzEyXSA9IHg7XG5cdFx0XHR0ZVsxM10gPSB5O1xuXHRcdFx0dGVbMTRdID0gejtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0aW52ZXJ0KCkge1xuXHRcdC8vIGJhc2VkIG9uIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvbWF0cml4L2Z1bmN0aW9ucy9pbnZlcnNlL2ZvdXJEL2luZGV4Lmh0bVxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cyxcblx0XHRcdG4xMSA9IHRlWzBdLFxuXHRcdFx0bjIxID0gdGVbMV0sXG5cdFx0XHRuMzEgPSB0ZVsyXSxcblx0XHRcdG40MSA9IHRlWzNdLFxuXHRcdFx0bjEyID0gdGVbNF0sXG5cdFx0XHRuMjIgPSB0ZVs1XSxcblx0XHRcdG4zMiA9IHRlWzZdLFxuXHRcdFx0bjQyID0gdGVbN10sXG5cdFx0XHRuMTMgPSB0ZVs4XSxcblx0XHRcdG4yMyA9IHRlWzldLFxuXHRcdFx0bjMzID0gdGVbMTBdLFxuXHRcdFx0bjQzID0gdGVbMTFdLFxuXHRcdFx0bjE0ID0gdGVbMTJdLFxuXHRcdFx0bjI0ID0gdGVbMTNdLFxuXHRcdFx0bjM0ID0gdGVbMTRdLFxuXHRcdFx0bjQ0ID0gdGVbMTVdLFxuXHRcdFx0dDExID0gbjIzICogbjM0ICogbjQyIC0gbjI0ICogbjMzICogbjQyICsgbjI0ICogbjMyICogbjQzIC0gbjIyICogbjM0ICogbjQzIC0gbjIzICogbjMyICogbjQ0ICsgbjIyICogbjMzICogbjQ0LFxuXHRcdFx0dDEyID0gbjE0ICogbjMzICogbjQyIC0gbjEzICogbjM0ICogbjQyIC0gbjE0ICogbjMyICogbjQzICsgbjEyICogbjM0ICogbjQzICsgbjEzICogbjMyICogbjQ0IC0gbjEyICogbjMzICogbjQ0LFxuXHRcdFx0dDEzID0gbjEzICogbjI0ICogbjQyIC0gbjE0ICogbjIzICogbjQyICsgbjE0ICogbjIyICogbjQzIC0gbjEyICogbjI0ICogbjQzIC0gbjEzICogbjIyICogbjQ0ICsgbjEyICogbjIzICogbjQ0LFxuXHRcdFx0dDE0ID0gbjE0ICogbjIzICogbjMyIC0gbjEzICogbjI0ICogbjMyIC0gbjE0ICogbjIyICogbjMzICsgbjEyICogbjI0ICogbjMzICsgbjEzICogbjIyICogbjM0IC0gbjEyICogbjIzICogbjM0O1xuXHRcdGNvbnN0IGRldCA9IG4xMSAqIHQxMSArIG4yMSAqIHQxMiArIG4zMSAqIHQxMyArIG40MSAqIHQxNDtcblx0XHRpZiAoZGV0ID09PSAwKSByZXR1cm4gdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG5cdFx0Y29uc3QgZGV0SW52ID0gMSAvIGRldDtcblx0XHR0ZVswXSA9IHQxMSAqIGRldEludjtcblx0XHR0ZVsxXSA9IChuMjQgKiBuMzMgKiBuNDEgLSBuMjMgKiBuMzQgKiBuNDEgLSBuMjQgKiBuMzEgKiBuNDMgKyBuMjEgKiBuMzQgKiBuNDMgKyBuMjMgKiBuMzEgKiBuNDQgLSBuMjEgKiBuMzMgKiBuNDQpICogZGV0SW52O1xuXHRcdHRlWzJdID0gKG4yMiAqIG4zNCAqIG40MSAtIG4yNCAqIG4zMiAqIG40MSArIG4yNCAqIG4zMSAqIG40MiAtIG4yMSAqIG4zNCAqIG40MiAtIG4yMiAqIG4zMSAqIG40NCArIG4yMSAqIG4zMiAqIG40NCkgKiBkZXRJbnY7XG5cdFx0dGVbM10gPSAobjIzICogbjMyICogbjQxIC0gbjIyICogbjMzICogbjQxIC0gbjIzICogbjMxICogbjQyICsgbjIxICogbjMzICogbjQyICsgbjIyICogbjMxICogbjQzIC0gbjIxICogbjMyICogbjQzKSAqIGRldEludjtcblx0XHR0ZVs0XSA9IHQxMiAqIGRldEludjtcblx0XHR0ZVs1XSA9IChuMTMgKiBuMzQgKiBuNDEgLSBuMTQgKiBuMzMgKiBuNDEgKyBuMTQgKiBuMzEgKiBuNDMgLSBuMTEgKiBuMzQgKiBuNDMgLSBuMTMgKiBuMzEgKiBuNDQgKyBuMTEgKiBuMzMgKiBuNDQpICogZGV0SW52O1xuXHRcdHRlWzZdID0gKG4xNCAqIG4zMiAqIG40MSAtIG4xMiAqIG4zNCAqIG40MSAtIG4xNCAqIG4zMSAqIG40MiArIG4xMSAqIG4zNCAqIG40MiArIG4xMiAqIG4zMSAqIG40NCAtIG4xMSAqIG4zMiAqIG40NCkgKiBkZXRJbnY7XG5cdFx0dGVbN10gPSAobjEyICogbjMzICogbjQxIC0gbjEzICogbjMyICogbjQxICsgbjEzICogbjMxICogbjQyIC0gbjExICogbjMzICogbjQyIC0gbjEyICogbjMxICogbjQzICsgbjExICogbjMyICogbjQzKSAqIGRldEludjtcblx0XHR0ZVs4XSA9IHQxMyAqIGRldEludjtcblx0XHR0ZVs5XSA9IChuMTQgKiBuMjMgKiBuNDEgLSBuMTMgKiBuMjQgKiBuNDEgLSBuMTQgKiBuMjEgKiBuNDMgKyBuMTEgKiBuMjQgKiBuNDMgKyBuMTMgKiBuMjEgKiBuNDQgLSBuMTEgKiBuMjMgKiBuNDQpICogZGV0SW52O1xuXHRcdHRlWzEwXSA9IChuMTIgKiBuMjQgKiBuNDEgLSBuMTQgKiBuMjIgKiBuNDEgKyBuMTQgKiBuMjEgKiBuNDIgLSBuMTEgKiBuMjQgKiBuNDIgLSBuMTIgKiBuMjEgKiBuNDQgKyBuMTEgKiBuMjIgKiBuNDQpICogZGV0SW52O1xuXHRcdHRlWzExXSA9IChuMTMgKiBuMjIgKiBuNDEgLSBuMTIgKiBuMjMgKiBuNDEgLSBuMTMgKiBuMjEgKiBuNDIgKyBuMTEgKiBuMjMgKiBuNDIgKyBuMTIgKiBuMjEgKiBuNDMgLSBuMTEgKiBuMjIgKiBuNDMpICogZGV0SW52O1xuXHRcdHRlWzEyXSA9IHQxNCAqIGRldEludjtcblx0XHR0ZVsxM10gPSAobjEzICogbjI0ICogbjMxIC0gbjE0ICogbjIzICogbjMxICsgbjE0ICogbjIxICogbjMzIC0gbjExICogbjI0ICogbjMzIC0gbjEzICogbjIxICogbjM0ICsgbjExICogbjIzICogbjM0KSAqIGRldEludjtcblx0XHR0ZVsxNF0gPSAobjE0ICogbjIyICogbjMxIC0gbjEyICogbjI0ICogbjMxIC0gbjE0ICogbjIxICogbjMyICsgbjExICogbjI0ICogbjMyICsgbjEyICogbjIxICogbjM0IC0gbjExICogbjIyICogbjM0KSAqIGRldEludjtcblx0XHR0ZVsxNV0gPSAobjEyICogbjIzICogbjMxIC0gbjEzICogbjIyICogbjMxICsgbjEzICogbjIxICogbjMyIC0gbjExICogbjIzICogbjMyIC0gbjEyICogbjIxICogbjMzICsgbjExICogbjIyICogbjMzKSAqIGRldEludjtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRzY2FsZSh2KSB7XG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdGNvbnN0IHggPSB2LngsXG5cdFx0XHR5ID0gdi55LFxuXHRcdFx0eiA9IHYuejtcblx0XHR0ZVswXSAqPSB4O1xuXHRcdHRlWzRdICo9IHk7XG5cdFx0dGVbOF0gKj0gejtcblx0XHR0ZVsxXSAqPSB4O1xuXHRcdHRlWzVdICo9IHk7XG5cdFx0dGVbOV0gKj0gejtcblx0XHR0ZVsyXSAqPSB4O1xuXHRcdHRlWzZdICo9IHk7XG5cdFx0dGVbMTBdICo9IHo7XG5cdFx0dGVbM10gKj0geDtcblx0XHR0ZVs3XSAqPSB5O1xuXHRcdHRlWzExXSAqPSB6O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGdldE1heFNjYWxlT25BeGlzKCkge1xuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRjb25zdCBzY2FsZVhTcSA9IHRlWzBdICogdGVbMF0gKyB0ZVsxXSAqIHRlWzFdICsgdGVbMl0gKiB0ZVsyXTtcblx0XHRjb25zdCBzY2FsZVlTcSA9IHRlWzRdICogdGVbNF0gKyB0ZVs1XSAqIHRlWzVdICsgdGVbNl0gKiB0ZVs2XTtcblx0XHRjb25zdCBzY2FsZVpTcSA9IHRlWzhdICogdGVbOF0gKyB0ZVs5XSAqIHRlWzldICsgdGVbMTBdICogdGVbMTBdO1xuXHRcdHJldHVybiBNYXRoLnNxcnQoTWF0aC5tYXgoc2NhbGVYU3EsIHNjYWxlWVNxLCBzY2FsZVpTcSkpO1xuXHR9XG5cdG1ha2VUcmFuc2xhdGlvbih4LCB5LCB6KSB7XG5cdFx0dGhpcy5zZXQoMSwgMCwgMCwgeCwgMCwgMSwgMCwgeSwgMCwgMCwgMSwgeiwgMCwgMCwgMCwgMSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0bWFrZVJvdGF0aW9uWCh0aGV0YSkge1xuXHRcdGNvbnN0IGMgPSBNYXRoLmNvcyh0aGV0YSksXG5cdFx0XHRzID0gTWF0aC5zaW4odGhldGEpO1xuXHRcdHRoaXMuc2V0KDEsIDAsIDAsIDAsIDAsIGMsIC1zLCAwLCAwLCBzLCBjLCAwLCAwLCAwLCAwLCAxKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRtYWtlUm90YXRpb25ZKHRoZXRhKSB7XG5cdFx0Y29uc3QgYyA9IE1hdGguY29zKHRoZXRhKSxcblx0XHRcdHMgPSBNYXRoLnNpbih0aGV0YSk7XG5cdFx0dGhpcy5zZXQoYywgMCwgcywgMCwgMCwgMSwgMCwgMCwgLXMsIDAsIGMsIDAsIDAsIDAsIDAsIDEpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdG1ha2VSb3RhdGlvbloodGhldGEpIHtcblx0XHRjb25zdCBjID0gTWF0aC5jb3ModGhldGEpLFxuXHRcdFx0cyA9IE1hdGguc2luKHRoZXRhKTtcblx0XHR0aGlzLnNldChjLCAtcywgMCwgMCwgcywgYywgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0bWFrZVJvdGF0aW9uQXhpcyhheGlzLCBhbmdsZSkge1xuXHRcdC8vIEJhc2VkIG9uIGh0dHA6Ly93d3cuZ2FtZWRldi5uZXQvcmVmZXJlbmNlL2FydGljbGVzL2FydGljbGUxMTk5LmFzcFxuXG5cdFx0Y29uc3QgYyA9IE1hdGguY29zKGFuZ2xlKTtcblx0XHRjb25zdCBzID0gTWF0aC5zaW4oYW5nbGUpO1xuXHRcdGNvbnN0IHQgPSAxIC0gYztcblx0XHRjb25zdCB4ID0gYXhpcy54LFxuXHRcdFx0eSA9IGF4aXMueSxcblx0XHRcdHogPSBheGlzLno7XG5cdFx0Y29uc3QgdHggPSB0ICogeCxcblx0XHRcdHR5ID0gdCAqIHk7XG5cdFx0dGhpcy5zZXQodHggKiB4ICsgYywgdHggKiB5IC0gcyAqIHosIHR4ICogeiArIHMgKiB5LCAwLCB0eCAqIHkgKyBzICogeiwgdHkgKiB5ICsgYywgdHkgKiB6IC0gcyAqIHgsIDAsIHR4ICogeiAtIHMgKiB5LCB0eSAqIHogKyBzICogeCwgdCAqIHogKiB6ICsgYywgMCwgMCwgMCwgMCwgMSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0bWFrZVNjYWxlKHgsIHksIHopIHtcblx0XHR0aGlzLnNldCh4LCAwLCAwLCAwLCAwLCB5LCAwLCAwLCAwLCAwLCB6LCAwLCAwLCAwLCAwLCAxKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRtYWtlU2hlYXIoeHksIHh6LCB5eCwgeXosIHp4LCB6eSkge1xuXHRcdHRoaXMuc2V0KDEsIHl4LCB6eCwgMCwgeHksIDEsIHp5LCAwLCB4eiwgeXosIDEsIDAsIDAsIDAsIDAsIDEpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGNvbXBvc2UocG9zaXRpb24sIHF1YXRlcm5pb24sIHNjYWxlKSB7XG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdGNvbnN0IHggPSBxdWF0ZXJuaW9uLl94LFxuXHRcdFx0eSA9IHF1YXRlcm5pb24uX3ksXG5cdFx0XHR6ID0gcXVhdGVybmlvbi5feixcblx0XHRcdHcgPSBxdWF0ZXJuaW9uLl93O1xuXHRcdGNvbnN0IHgyID0geCArIHgsXG5cdFx0XHR5MiA9IHkgKyB5LFxuXHRcdFx0ejIgPSB6ICsgejtcblx0XHRjb25zdCB4eCA9IHggKiB4Mixcblx0XHRcdHh5ID0geCAqIHkyLFxuXHRcdFx0eHogPSB4ICogejI7XG5cdFx0Y29uc3QgeXkgPSB5ICogeTIsXG5cdFx0XHR5eiA9IHkgKiB6Mixcblx0XHRcdHp6ID0geiAqIHoyO1xuXHRcdGNvbnN0IHd4ID0gdyAqIHgyLFxuXHRcdFx0d3kgPSB3ICogeTIsXG5cdFx0XHR3eiA9IHcgKiB6Mjtcblx0XHRjb25zdCBzeCA9IHNjYWxlLngsXG5cdFx0XHRzeSA9IHNjYWxlLnksXG5cdFx0XHRzeiA9IHNjYWxlLno7XG5cdFx0dGVbMF0gPSAoMSAtICh5eSArIHp6KSkgKiBzeDtcblx0XHR0ZVsxXSA9ICh4eSArIHd6KSAqIHN4O1xuXHRcdHRlWzJdID0gKHh6IC0gd3kpICogc3g7XG5cdFx0dGVbM10gPSAwO1xuXHRcdHRlWzRdID0gKHh5IC0gd3opICogc3k7XG5cdFx0dGVbNV0gPSAoMSAtICh4eCArIHp6KSkgKiBzeTtcblx0XHR0ZVs2XSA9ICh5eiArIHd4KSAqIHN5O1xuXHRcdHRlWzddID0gMDtcblx0XHR0ZVs4XSA9ICh4eiArIHd5KSAqIHN6O1xuXHRcdHRlWzldID0gKHl6IC0gd3gpICogc3o7XG5cdFx0dGVbMTBdID0gKDEgLSAoeHggKyB5eSkpICogc3o7XG5cdFx0dGVbMTFdID0gMDtcblx0XHR0ZVsxMl0gPSBwb3NpdGlvbi54O1xuXHRcdHRlWzEzXSA9IHBvc2l0aW9uLnk7XG5cdFx0dGVbMTRdID0gcG9zaXRpb24uejtcblx0XHR0ZVsxNV0gPSAxO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGRlY29tcG9zZShwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUpIHtcblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0bGV0IHN4ID0gX3YxJDUuc2V0KHRlWzBdLCB0ZVsxXSwgdGVbMl0pLmxlbmd0aCgpO1xuXHRcdGNvbnN0IHN5ID0gX3YxJDUuc2V0KHRlWzRdLCB0ZVs1XSwgdGVbNl0pLmxlbmd0aCgpO1xuXHRcdGNvbnN0IHN6ID0gX3YxJDUuc2V0KHRlWzhdLCB0ZVs5XSwgdGVbMTBdKS5sZW5ndGgoKTtcblxuXHRcdC8vIGlmIGRldGVybWluZSBpcyBuZWdhdGl2ZSwgd2UgbmVlZCB0byBpbnZlcnQgb25lIHNjYWxlXG5cdFx0Y29uc3QgZGV0ID0gdGhpcy5kZXRlcm1pbmFudCgpO1xuXHRcdGlmIChkZXQgPCAwKSBzeCA9IC1zeDtcblx0XHRwb3NpdGlvbi54ID0gdGVbMTJdO1xuXHRcdHBvc2l0aW9uLnkgPSB0ZVsxM107XG5cdFx0cG9zaXRpb24ueiA9IHRlWzE0XTtcblxuXHRcdC8vIHNjYWxlIHRoZSByb3RhdGlvbiBwYXJ0XG5cdFx0X20xJDIuY29weSh0aGlzKTtcblx0XHRjb25zdCBpbnZTWCA9IDEgLyBzeDtcblx0XHRjb25zdCBpbnZTWSA9IDEgLyBzeTtcblx0XHRjb25zdCBpbnZTWiA9IDEgLyBzejtcblx0XHRfbTEkMi5lbGVtZW50c1swXSAqPSBpbnZTWDtcblx0XHRfbTEkMi5lbGVtZW50c1sxXSAqPSBpbnZTWDtcblx0XHRfbTEkMi5lbGVtZW50c1syXSAqPSBpbnZTWDtcblx0XHRfbTEkMi5lbGVtZW50c1s0XSAqPSBpbnZTWTtcblx0XHRfbTEkMi5lbGVtZW50c1s1XSAqPSBpbnZTWTtcblx0XHRfbTEkMi5lbGVtZW50c1s2XSAqPSBpbnZTWTtcblx0XHRfbTEkMi5lbGVtZW50c1s4XSAqPSBpbnZTWjtcblx0XHRfbTEkMi5lbGVtZW50c1s5XSAqPSBpbnZTWjtcblx0XHRfbTEkMi5lbGVtZW50c1sxMF0gKj0gaW52U1o7XG5cdFx0cXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoX20xJDIpO1xuXHRcdHNjYWxlLnggPSBzeDtcblx0XHRzY2FsZS55ID0gc3k7XG5cdFx0c2NhbGUueiA9IHN6O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdG1ha2VQZXJzcGVjdGl2ZShsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhcikge1xuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRjb25zdCB4ID0gMiAqIG5lYXIgLyAocmlnaHQgLSBsZWZ0KTtcblx0XHRjb25zdCB5ID0gMiAqIG5lYXIgLyAodG9wIC0gYm90dG9tKTtcblx0XHRjb25zdCBhID0gKHJpZ2h0ICsgbGVmdCkgLyAocmlnaHQgLSBsZWZ0KTtcblx0XHRjb25zdCBiID0gKHRvcCArIGJvdHRvbSkgLyAodG9wIC0gYm90dG9tKTtcblx0XHRjb25zdCBjID0gLShmYXIgKyBuZWFyKSAvIChmYXIgLSBuZWFyKTtcblx0XHRjb25zdCBkID0gLTIgKiBmYXIgKiBuZWFyIC8gKGZhciAtIG5lYXIpO1xuXHRcdHRlWzBdID0geDtcblx0XHR0ZVs0XSA9IDA7XG5cdFx0dGVbOF0gPSBhO1xuXHRcdHRlWzEyXSA9IDA7XG5cdFx0dGVbMV0gPSAwO1xuXHRcdHRlWzVdID0geTtcblx0XHR0ZVs5XSA9IGI7XG5cdFx0dGVbMTNdID0gMDtcblx0XHR0ZVsyXSA9IDA7XG5cdFx0dGVbNl0gPSAwO1xuXHRcdHRlWzEwXSA9IGM7XG5cdFx0dGVbMTRdID0gZDtcblx0XHR0ZVszXSA9IDA7XG5cdFx0dGVbN10gPSAwO1xuXHRcdHRlWzExXSA9IC0xO1xuXHRcdHRlWzE1XSA9IDA7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0bWFrZU9ydGhvZ3JhcGhpYyhsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhcikge1xuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRjb25zdCB3ID0gMS4wIC8gKHJpZ2h0IC0gbGVmdCk7XG5cdFx0Y29uc3QgaCA9IDEuMCAvICh0b3AgLSBib3R0b20pO1xuXHRcdGNvbnN0IHAgPSAxLjAgLyAoZmFyIC0gbmVhcik7XG5cdFx0Y29uc3QgeCA9IChyaWdodCArIGxlZnQpICogdztcblx0XHRjb25zdCB5ID0gKHRvcCArIGJvdHRvbSkgKiBoO1xuXHRcdGNvbnN0IHogPSAoZmFyICsgbmVhcikgKiBwO1xuXHRcdHRlWzBdID0gMiAqIHc7XG5cdFx0dGVbNF0gPSAwO1xuXHRcdHRlWzhdID0gMDtcblx0XHR0ZVsxMl0gPSAteDtcblx0XHR0ZVsxXSA9IDA7XG5cdFx0dGVbNV0gPSAyICogaDtcblx0XHR0ZVs5XSA9IDA7XG5cdFx0dGVbMTNdID0gLXk7XG5cdFx0dGVbMl0gPSAwO1xuXHRcdHRlWzZdID0gMDtcblx0XHR0ZVsxMF0gPSAtMiAqIHA7XG5cdFx0dGVbMTRdID0gLXo7XG5cdFx0dGVbM10gPSAwO1xuXHRcdHRlWzddID0gMDtcblx0XHR0ZVsxMV0gPSAwO1xuXHRcdHRlWzE1XSA9IDE7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0ZXF1YWxzKG1hdHJpeCkge1xuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRjb25zdCBtZSA9IG1hdHJpeC5lbGVtZW50cztcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcblx0XHRcdGlmICh0ZVtpXSAhPT0gbWVbaV0pIHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0ZnJvbUFycmF5KGFycmF5LCBvZmZzZXQgPSAwKSB7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG5cdFx0XHR0aGlzLmVsZW1lbnRzW2ldID0gYXJyYXlbaSArIG9mZnNldF07XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHRvQXJyYXkoYXJyYXkgPSBbXSwgb2Zmc2V0ID0gMCkge1xuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRhcnJheVtvZmZzZXRdID0gdGVbMF07XG5cdFx0YXJyYXlbb2Zmc2V0ICsgMV0gPSB0ZVsxXTtcblx0XHRhcnJheVtvZmZzZXQgKyAyXSA9IHRlWzJdO1xuXHRcdGFycmF5W29mZnNldCArIDNdID0gdGVbM107XG5cdFx0YXJyYXlbb2Zmc2V0ICsgNF0gPSB0ZVs0XTtcblx0XHRhcnJheVtvZmZzZXQgKyA1XSA9IHRlWzVdO1xuXHRcdGFycmF5W29mZnNldCArIDZdID0gdGVbNl07XG5cdFx0YXJyYXlbb2Zmc2V0ICsgN10gPSB0ZVs3XTtcblx0XHRhcnJheVtvZmZzZXQgKyA4XSA9IHRlWzhdO1xuXHRcdGFycmF5W29mZnNldCArIDldID0gdGVbOV07XG5cdFx0YXJyYXlbb2Zmc2V0ICsgMTBdID0gdGVbMTBdO1xuXHRcdGFycmF5W29mZnNldCArIDExXSA9IHRlWzExXTtcblx0XHRhcnJheVtvZmZzZXQgKyAxMl0gPSB0ZVsxMl07XG5cdFx0YXJyYXlbb2Zmc2V0ICsgMTNdID0gdGVbMTNdO1xuXHRcdGFycmF5W29mZnNldCArIDE0XSA9IHRlWzE0XTtcblx0XHRhcnJheVtvZmZzZXQgKyAxNV0gPSB0ZVsxNV07XG5cdFx0cmV0dXJuIGFycmF5O1xuXHR9XG59XG5jb25zdCBfdjEkNSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuY29uc3QgX20xJDIgPSAvKkBfX1BVUkVfXyovbmV3IE1hdHJpeDQoKTtcbmNvbnN0IF96ZXJvID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKDAsIDAsIDApO1xuY29uc3QgX29uZSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygxLCAxLCAxKTtcbmNvbnN0IF94ID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5jb25zdCBfeSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuY29uc3QgX3ogPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuY29uc3QgX21hdHJpeCQxID0gLypAX19QVVJFX18qL25ldyBNYXRyaXg0KCk7XG5jb25zdCBfcXVhdGVybmlvbiQzID0gLypAX19QVVJFX18qL25ldyBRdWF0ZXJuaW9uKCk7XG5jbGFzcyBFdWxlciB7XG5cdGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgeiA9IDAsIG9yZGVyID0gRXVsZXIuRGVmYXVsdE9yZGVyKSB7XG5cdFx0dGhpcy5pc0V1bGVyID0gdHJ1ZTtcblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl96ID0gejtcblx0XHR0aGlzLl9vcmRlciA9IG9yZGVyO1xuXHR9XG5cdGdldCB4KCkge1xuXHRcdHJldHVybiB0aGlzLl94O1xuXHR9XG5cdHNldCB4KHZhbHVlKSB7XG5cdFx0dGhpcy5feCA9IHZhbHVlO1xuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblx0fVxuXHRnZXQgeSgpIHtcblx0XHRyZXR1cm4gdGhpcy5feTtcblx0fVxuXHRzZXQgeSh2YWx1ZSkge1xuXHRcdHRoaXMuX3kgPSB2YWx1ZTtcblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cdH1cblx0Z2V0IHooKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3o7XG5cdH1cblx0c2V0IHoodmFsdWUpIHtcblx0XHR0aGlzLl96ID0gdmFsdWU7XG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXHR9XG5cdGdldCBvcmRlcigpIHtcblx0XHRyZXR1cm4gdGhpcy5fb3JkZXI7XG5cdH1cblx0c2V0IG9yZGVyKHZhbHVlKSB7XG5cdFx0dGhpcy5fb3JkZXIgPSB2YWx1ZTtcblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cdH1cblx0c2V0KHgsIHksIHosIG9yZGVyID0gdGhpcy5fb3JkZXIpIHtcblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl96ID0gejtcblx0XHR0aGlzLl9vcmRlciA9IG9yZGVyO1xuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRjbG9uZSgpIHtcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiwgdGhpcy5fb3JkZXIpO1xuXHR9XG5cdGNvcHkoZXVsZXIpIHtcblx0XHR0aGlzLl94ID0gZXVsZXIuX3g7XG5cdFx0dGhpcy5feSA9IGV1bGVyLl95O1xuXHRcdHRoaXMuX3ogPSBldWxlci5fejtcblx0XHR0aGlzLl9vcmRlciA9IGV1bGVyLl9vcmRlcjtcblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0c2V0RnJvbVJvdGF0aW9uTWF0cml4KG0sIG9yZGVyID0gdGhpcy5fb3JkZXIsIHVwZGF0ZSA9IHRydWUpIHtcblx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuXG5cdFx0Y29uc3QgdGUgPSBtLmVsZW1lbnRzO1xuXHRcdGNvbnN0IG0xMSA9IHRlWzBdLFxuXHRcdFx0bTEyID0gdGVbNF0sXG5cdFx0XHRtMTMgPSB0ZVs4XTtcblx0XHRjb25zdCBtMjEgPSB0ZVsxXSxcblx0XHRcdG0yMiA9IHRlWzVdLFxuXHRcdFx0bTIzID0gdGVbOV07XG5cdFx0Y29uc3QgbTMxID0gdGVbMl0sXG5cdFx0XHRtMzIgPSB0ZVs2XSxcblx0XHRcdG0zMyA9IHRlWzEwXTtcblx0XHRzd2l0Y2ggKG9yZGVyKSB7XG5cdFx0XHRjYXNlICdYWVonOlxuXHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hc2luKGNsYW1wKG0xMywgLTEsIDEpKTtcblx0XHRcdFx0aWYgKE1hdGguYWJzKG0xMykgPCAwLjk5OTk5OTkpIHtcblx0XHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMigtbTIzLCBtMzMpO1xuXHRcdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKC1tMTIsIG0xMSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIobTMyLCBtMjIpO1xuXHRcdFx0XHRcdHRoaXMuX3ogPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnWVhaJzpcblx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXNpbigtY2xhbXAobTIzLCAtMSwgMSkpO1xuXHRcdFx0XHRpZiAoTWF0aC5hYnMobTIzKSA8IDAuOTk5OTk5OSkge1xuXHRcdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKG0xMywgbTMzKTtcblx0XHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMihtMjEsIG0yMik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoLW0zMSwgbTExKTtcblx0XHRcdFx0XHR0aGlzLl96ID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ1pYWSc6XG5cdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmFzaW4oY2xhbXAobTMyLCAtMSwgMSkpO1xuXHRcdFx0XHRpZiAoTWF0aC5hYnMobTMyKSA8IDAuOTk5OTk5OSkge1xuXHRcdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKC1tMzEsIG0zMyk7XG5cdFx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoLW0xMiwgbTIyKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl95ID0gMDtcblx0XHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMihtMjEsIG0xMSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdaWVgnOlxuXHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hc2luKC1jbGFtcChtMzEsIC0xLCAxKSk7XG5cdFx0XHRcdGlmIChNYXRoLmFicyhtMzEpIDwgMC45OTk5OTk5KSB7XG5cdFx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIobTMyLCBtMzMpO1xuXHRcdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKG0yMSwgbTExKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl94ID0gMDtcblx0XHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMigtbTEyLCBtMjIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnWVpYJzpcblx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXNpbihjbGFtcChtMjEsIC0xLCAxKSk7XG5cdFx0XHRcdGlmIChNYXRoLmFicyhtMjEpIDwgMC45OTk5OTk5KSB7XG5cdFx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoLW0yMywgbTIyKTtcblx0XHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMigtbTMxLCBtMTEpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX3ggPSAwO1xuXHRcdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKG0xMywgbTMzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ1haWSc6XG5cdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmFzaW4oLWNsYW1wKG0xMiwgLTEsIDEpKTtcblx0XHRcdFx0aWYgKE1hdGguYWJzKG0xMikgPCAwLjk5OTk5OTkpIHtcblx0XHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMihtMzIsIG0yMik7XG5cdFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIobTEzLCBtMTEpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKC1tMjMsIG0zMyk7XG5cdFx0XHRcdFx0dGhpcy5feSA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkV1bGVyOiAuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCkgZW5jb3VudGVyZWQgYW4gdW5rbm93biBvcmRlcjogJyArIG9yZGVyKTtcblx0XHR9XG5cdFx0dGhpcy5fb3JkZXIgPSBvcmRlcjtcblx0XHRpZiAodXBkYXRlID09PSB0cnVlKSB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0c2V0RnJvbVF1YXRlcm5pb24ocSwgb3JkZXIsIHVwZGF0ZSkge1xuXHRcdF9tYXRyaXgkMS5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbihxKTtcblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tUm90YXRpb25NYXRyaXgoX21hdHJpeCQxLCBvcmRlciwgdXBkYXRlKTtcblx0fVxuXHRzZXRGcm9tVmVjdG9yMyh2LCBvcmRlciA9IHRoaXMuX29yZGVyKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0KHYueCwgdi55LCB2LnosIG9yZGVyKTtcblx0fVxuXHRyZW9yZGVyKG5ld09yZGVyKSB7XG5cdFx0Ly8gV0FSTklORzogdGhpcyBkaXNjYXJkcyByZXZvbHV0aW9uIGluZm9ybWF0aW9uIC1iaG91c3RvblxuXG5cdFx0X3F1YXRlcm5pb24kMy5zZXRGcm9tRXVsZXIodGhpcyk7XG5cdFx0cmV0dXJuIHRoaXMuc2V0RnJvbVF1YXRlcm5pb24oX3F1YXRlcm5pb24kMywgbmV3T3JkZXIpO1xuXHR9XG5cdGVxdWFscyhldWxlcikge1xuXHRcdHJldHVybiBldWxlci5feCA9PT0gdGhpcy5feCAmJiBldWxlci5feSA9PT0gdGhpcy5feSAmJiBldWxlci5feiA9PT0gdGhpcy5feiAmJiBldWxlci5fb3JkZXIgPT09IHRoaXMuX29yZGVyO1xuXHR9XG5cdGZyb21BcnJheShhcnJheSkge1xuXHRcdHRoaXMuX3ggPSBhcnJheVswXTtcblx0XHR0aGlzLl95ID0gYXJyYXlbMV07XG5cdFx0dGhpcy5feiA9IGFycmF5WzJdO1xuXHRcdGlmIChhcnJheVszXSAhPT0gdW5kZWZpbmVkKSB0aGlzLl9vcmRlciA9IGFycmF5WzNdO1xuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHR0b0FycmF5KGFycmF5ID0gW10sIG9mZnNldCA9IDApIHtcblx0XHRhcnJheVtvZmZzZXRdID0gdGhpcy5feDtcblx0XHRhcnJheVtvZmZzZXQgKyAxXSA9IHRoaXMuX3k7XG5cdFx0YXJyYXlbb2Zmc2V0ICsgMl0gPSB0aGlzLl96O1xuXHRcdGFycmF5W29mZnNldCArIDNdID0gdGhpcy5fb3JkZXI7XG5cdFx0cmV0dXJuIGFycmF5O1xuXHR9XG5cdF9vbkNoYW5nZShjYWxsYmFjaykge1xuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2sgPSBjYWxsYmFjaztcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRfb25DaGFuZ2VDYWxsYmFjaygpIHt9XG5cdCpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcblx0XHR5aWVsZCB0aGlzLl94O1xuXHRcdHlpZWxkIHRoaXMuX3k7XG5cdFx0eWllbGQgdGhpcy5fejtcblx0XHR5aWVsZCB0aGlzLl9vcmRlcjtcblx0fVxuXG5cdC8vIEBkZXByZWNhdGVkIHNpbmNlIHIxMzgsIDAyY2YwZGYxY2I0NTc1ZDU4NDJmZWY5Yzg1YmI1YTg5ZmUwMjBkNTNcblxuXHR0b1ZlY3RvcjMoKSB7XG5cdFx0Y29uc29sZS5lcnJvcignVEhSRUUuRXVsZXI6IC50b1ZlY3RvcjMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVmVjdG9yMy5zZXRGcm9tRXVsZXIoKSBpbnN0ZWFkJyk7XG5cdH1cbn1cbkV1bGVyLkRlZmF1bHRPcmRlciA9ICdYWVonO1xuRXVsZXIuUm90YXRpb25PcmRlcnMgPSBbJ1hZWicsICdZWlgnLCAnWlhZJywgJ1haWScsICdZWFonLCAnWllYJ107XG5cbmNsYXNzIExheWVycyB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHRoaXMubWFzayA9IDEgfCAwO1xuXHR9XG5cdHNldChjaGFubmVsKSB7XG5cdFx0dGhpcy5tYXNrID0gKDEgPDwgY2hhbm5lbCB8IDApID4+PiAwO1xuXHR9XG5cdGVuYWJsZShjaGFubmVsKSB7XG5cdFx0dGhpcy5tYXNrIHw9IDEgPDwgY2hhbm5lbCB8IDA7XG5cdH1cblx0ZW5hYmxlQWxsKCkge1xuXHRcdHRoaXMubWFzayA9IDB4ZmZmZmZmZmYgfCAwO1xuXHR9XG5cdHRvZ2dsZShjaGFubmVsKSB7XG5cdFx0dGhpcy5tYXNrIF49IDEgPDwgY2hhbm5lbCB8IDA7XG5cdH1cblx0ZGlzYWJsZShjaGFubmVsKSB7XG5cdFx0dGhpcy5tYXNrICY9IH4oMSA8PCBjaGFubmVsIHwgMCk7XG5cdH1cblx0ZGlzYWJsZUFsbCgpIHtcblx0XHR0aGlzLm1hc2sgPSAwO1xuXHR9XG5cdHRlc3QobGF5ZXJzKSB7XG5cdFx0cmV0dXJuICh0aGlzLm1hc2sgJiBsYXllcnMubWFzaykgIT09IDA7XG5cdH1cblx0aXNFbmFibGVkKGNoYW5uZWwpIHtcblx0XHRyZXR1cm4gKHRoaXMubWFzayAmICgxIDw8IGNoYW5uZWwgfCAwKSkgIT09IDA7XG5cdH1cbn1cblxubGV0IF9vYmplY3QzRElkID0gMDtcbmNvbnN0IF92MSQ0ID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5jb25zdCBfcTEgPSAvKkBfX1BVUkVfXyovbmV3IFF1YXRlcm5pb24oKTtcbmNvbnN0IF9tMSQxID0gLypAX19QVVJFX18qL25ldyBNYXRyaXg0KCk7XG5jb25zdCBfdGFyZ2V0ID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5jb25zdCBfcG9zaXRpb24kMyA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuY29uc3QgX3NjYWxlJDIgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9xdWF0ZXJuaW9uJDIgPSAvKkBfX1BVUkVfXyovbmV3IFF1YXRlcm5pb24oKTtcbmNvbnN0IF94QXhpcyA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygxLCAwLCAwKTtcbmNvbnN0IF95QXhpcyA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygwLCAxLCAwKTtcbmNvbnN0IF96QXhpcyA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygwLCAwLCAxKTtcbmNvbnN0IF9hZGRlZEV2ZW50ID0ge1xuXHR0eXBlOiAnYWRkZWQnXG59O1xuY29uc3QgX3JlbW92ZWRFdmVudCA9IHtcblx0dHlwZTogJ3JlbW92ZWQnXG59O1xuY2xhc3MgT2JqZWN0M0QgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXIge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuaXNPYmplY3QzRCA9IHRydWU7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdpZCcsIHtcblx0XHRcdHZhbHVlOiBfb2JqZWN0M0RJZCsrXG5cdFx0fSk7XG5cdFx0dGhpcy51dWlkID0gZ2VuZXJhdGVVVUlEKCk7XG5cdFx0dGhpcy5uYW1lID0gJyc7XG5cdFx0dGhpcy50eXBlID0gJ09iamVjdDNEJztcblx0XHR0aGlzLnBhcmVudCA9IG51bGw7XG5cdFx0dGhpcy5jaGlsZHJlbiA9IFtdO1xuXHRcdHRoaXMudXAgPSBPYmplY3QzRC5EZWZhdWx0VXAuY2xvbmUoKTtcblx0XHRjb25zdCBwb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3Qgcm90YXRpb24gPSBuZXcgRXVsZXIoKTtcblx0XHRjb25zdCBxdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcblx0XHRjb25zdCBzY2FsZSA9IG5ldyBWZWN0b3IzKDEsIDEsIDEpO1xuXHRcdGZ1bmN0aW9uIG9uUm90YXRpb25DaGFuZ2UoKSB7XG5cdFx0XHRxdWF0ZXJuaW9uLnNldEZyb21FdWxlcihyb3RhdGlvbiwgZmFsc2UpO1xuXHRcdH1cblx0XHRmdW5jdGlvbiBvblF1YXRlcm5pb25DaGFuZ2UoKSB7XG5cdFx0XHRyb3RhdGlvbi5zZXRGcm9tUXVhdGVybmlvbihxdWF0ZXJuaW9uLCB1bmRlZmluZWQsIGZhbHNlKTtcblx0XHR9XG5cdFx0cm90YXRpb24uX29uQ2hhbmdlKG9uUm90YXRpb25DaGFuZ2UpO1xuXHRcdHF1YXRlcm5pb24uX29uQ2hhbmdlKG9uUXVhdGVybmlvbkNoYW5nZSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuXHRcdFx0cG9zaXRpb246IHtcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZTogcG9zaXRpb25cblx0XHRcdH0sXG5cdFx0XHRyb3RhdGlvbjoge1xuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiByb3RhdGlvblxuXHRcdFx0fSxcblx0XHRcdHF1YXRlcm5pb246IHtcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZTogcXVhdGVybmlvblxuXHRcdFx0fSxcblx0XHRcdHNjYWxlOiB7XG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHNjYWxlXG5cdFx0XHR9LFxuXHRcdFx0bW9kZWxWaWV3TWF0cml4OiB7XG5cdFx0XHRcdHZhbHVlOiBuZXcgTWF0cml4NCgpXG5cdFx0XHR9LFxuXHRcdFx0bm9ybWFsTWF0cml4OiB7XG5cdFx0XHRcdHZhbHVlOiBuZXcgTWF0cml4MygpXG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0dGhpcy5tYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuXHRcdHRoaXMubWF0cml4V29ybGQgPSBuZXcgTWF0cml4NCgpO1xuXHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IE9iamVjdDNELkRlZmF1bHRNYXRyaXhBdXRvVXBkYXRlO1xuXHRcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXHRcdHRoaXMubWF0cml4V29ybGRBdXRvVXBkYXRlID0gT2JqZWN0M0QuRGVmYXVsdE1hdHJpeFdvcmxkQXV0b1VwZGF0ZTsgLy8gY2hlY2tlZCBieSB0aGUgcmVuZGVyZXJcblxuXHRcdHRoaXMubGF5ZXJzID0gbmV3IExheWVycygpO1xuXHRcdHRoaXMudmlzaWJsZSA9IHRydWU7XG5cdFx0dGhpcy5jYXN0U2hhZG93ID0gZmFsc2U7XG5cdFx0dGhpcy5yZWNlaXZlU2hhZG93ID0gZmFsc2U7XG5cdFx0dGhpcy5mcnVzdHVtQ3VsbGVkID0gdHJ1ZTtcblx0XHR0aGlzLnJlbmRlck9yZGVyID0gMDtcblx0XHR0aGlzLmFuaW1hdGlvbnMgPSBbXTtcblx0XHR0aGlzLnVzZXJEYXRhID0ge307XG5cdH1cblx0b25CZWZvcmVSZW5kZXIoKSB7fVxuXHRvbkFmdGVyUmVuZGVyKCkge31cblx0YXBwbHlNYXRyaXg0KG1hdHJpeCkge1xuXHRcdGlmICh0aGlzLm1hdHJpeEF1dG9VcGRhdGUpIHRoaXMudXBkYXRlTWF0cml4KCk7XG5cdFx0dGhpcy5tYXRyaXgucHJlbXVsdGlwbHkobWF0cml4KTtcblx0XHR0aGlzLm1hdHJpeC5kZWNvbXBvc2UodGhpcy5wb3NpdGlvbiwgdGhpcy5xdWF0ZXJuaW9uLCB0aGlzLnNjYWxlKTtcblx0fVxuXHRhcHBseVF1YXRlcm5pb24ocSkge1xuXHRcdHRoaXMucXVhdGVybmlvbi5wcmVtdWx0aXBseShxKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRzZXRSb3RhdGlvbkZyb21BeGlzQW5nbGUoYXhpcywgYW5nbGUpIHtcblx0XHQvLyBhc3N1bWVzIGF4aXMgaXMgbm9ybWFsaXplZFxuXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoYXhpcywgYW5nbGUpO1xuXHR9XG5cdHNldFJvdGF0aW9uRnJvbUV1bGVyKGV1bGVyKSB7XG5cdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21FdWxlcihldWxlciwgdHJ1ZSk7XG5cdH1cblx0c2V0Um90YXRpb25Gcm9tTWF0cml4KG0pIHtcblx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeChtKTtcblx0fVxuXHRzZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKHEpIHtcblx0XHQvLyBhc3N1bWVzIHEgaXMgbm9ybWFsaXplZFxuXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLmNvcHkocSk7XG5cdH1cblx0cm90YXRlT25BeGlzKGF4aXMsIGFuZ2xlKSB7XG5cdFx0Ly8gcm90YXRlIG9iamVjdCBvbiBheGlzIGluIG9iamVjdCBzcGFjZVxuXHRcdC8vIGF4aXMgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cblx0XHRfcTEuc2V0RnJvbUF4aXNBbmdsZShheGlzLCBhbmdsZSk7XG5cdFx0dGhpcy5xdWF0ZXJuaW9uLm11bHRpcGx5KF9xMSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0cm90YXRlT25Xb3JsZEF4aXMoYXhpcywgYW5nbGUpIHtcblx0XHQvLyByb3RhdGUgb2JqZWN0IG9uIGF4aXMgaW4gd29ybGQgc3BhY2Vcblx0XHQvLyBheGlzIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXHRcdC8vIG1ldGhvZCBhc3N1bWVzIG5vIHJvdGF0ZWQgcGFyZW50XG5cblx0XHRfcTEuc2V0RnJvbUF4aXNBbmdsZShheGlzLCBhbmdsZSk7XG5cdFx0dGhpcy5xdWF0ZXJuaW9uLnByZW11bHRpcGx5KF9xMSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0cm90YXRlWChhbmdsZSkge1xuXHRcdHJldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyhfeEF4aXMsIGFuZ2xlKTtcblx0fVxuXHRyb3RhdGVZKGFuZ2xlKSB7XG5cdFx0cmV0dXJuIHRoaXMucm90YXRlT25BeGlzKF95QXhpcywgYW5nbGUpO1xuXHR9XG5cdHJvdGF0ZVooYW5nbGUpIHtcblx0XHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoX3pBeGlzLCBhbmdsZSk7XG5cdH1cblx0dHJhbnNsYXRlT25BeGlzKGF4aXMsIGRpc3RhbmNlKSB7XG5cdFx0Ly8gdHJhbnNsYXRlIG9iamVjdCBieSBkaXN0YW5jZSBhbG9uZyBheGlzIGluIG9iamVjdCBzcGFjZVxuXHRcdC8vIGF4aXMgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cblx0XHRfdjEkNC5jb3B5KGF4aXMpLmFwcGx5UXVhdGVybmlvbih0aGlzLnF1YXRlcm5pb24pO1xuXHRcdHRoaXMucG9zaXRpb24uYWRkKF92MSQ0Lm11bHRpcGx5U2NhbGFyKGRpc3RhbmNlKSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0dHJhbnNsYXRlWChkaXN0YW5jZSkge1xuXHRcdHJldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyhfeEF4aXMsIGRpc3RhbmNlKTtcblx0fVxuXHR0cmFuc2xhdGVZKGRpc3RhbmNlKSB7XG5cdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKF95QXhpcywgZGlzdGFuY2UpO1xuXHR9XG5cdHRyYW5zbGF0ZVooZGlzdGFuY2UpIHtcblx0XHRyZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoX3pBeGlzLCBkaXN0YW5jZSk7XG5cdH1cblx0bG9jYWxUb1dvcmxkKHZlY3Rvcikge1xuXHRcdHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KHRoaXMubWF0cml4V29ybGQpO1xuXHR9XG5cdHdvcmxkVG9Mb2NhbCh2ZWN0b3IpIHtcblx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NChfbTEkMS5jb3B5KHRoaXMubWF0cml4V29ybGQpLmludmVydCgpKTtcblx0fVxuXHRsb29rQXQoeCwgeSwgeikge1xuXHRcdC8vIFRoaXMgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgb2JqZWN0cyBoYXZpbmcgbm9uLXVuaWZvcm1seS1zY2FsZWQgcGFyZW50KHMpXG5cblx0XHRpZiAoeC5pc1ZlY3RvcjMpIHtcblx0XHRcdF90YXJnZXQuY29weSh4KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0X3RhcmdldC5zZXQoeCwgeSwgeik7XG5cdFx0fVxuXHRcdGNvbnN0IHBhcmVudCA9IHRoaXMucGFyZW50O1xuXHRcdHRoaXMudXBkYXRlV29ybGRNYXRyaXgodHJ1ZSwgZmFsc2UpO1xuXHRcdF9wb3NpdGlvbiQzLnNldEZyb21NYXRyaXhQb3NpdGlvbih0aGlzLm1hdHJpeFdvcmxkKTtcblx0XHRpZiAodGhpcy5pc0NhbWVyYSB8fCB0aGlzLmlzTGlnaHQpIHtcblx0XHRcdF9tMSQxLmxvb2tBdChfcG9zaXRpb24kMywgX3RhcmdldCwgdGhpcy51cCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdF9tMSQxLmxvb2tBdChfdGFyZ2V0LCBfcG9zaXRpb24kMywgdGhpcy51cCk7XG5cdFx0fVxuXHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoX20xJDEpO1xuXHRcdGlmIChwYXJlbnQpIHtcblx0XHRcdF9tMSQxLmV4dHJhY3RSb3RhdGlvbihwYXJlbnQubWF0cml4V29ybGQpO1xuXHRcdFx0X3ExLnNldEZyb21Sb3RhdGlvbk1hdHJpeChfbTEkMSk7XG5cdFx0XHR0aGlzLnF1YXRlcm5pb24ucHJlbXVsdGlwbHkoX3ExLmludmVydCgpKTtcblx0XHR9XG5cdH1cblx0YWRkKG9iamVjdCkge1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dGhpcy5hZGQoYXJndW1lbnRzW2ldKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAob2JqZWN0ID09PSB0aGlzKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5PYmplY3QzRC5hZGQ6IG9iamVjdCBjYW5cXCd0IGJlIGFkZGVkIGFzIGEgY2hpbGQgb2YgaXRzZWxmLicsIG9iamVjdCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKG9iamVjdCAmJiBvYmplY3QuaXNPYmplY3QzRCkge1xuXHRcdFx0aWYgKG9iamVjdC5wYXJlbnQgIT09IG51bGwpIHtcblx0XHRcdFx0b2JqZWN0LnBhcmVudC5yZW1vdmUob2JqZWN0KTtcblx0XHRcdH1cblx0XHRcdG9iamVjdC5wYXJlbnQgPSB0aGlzO1xuXHRcdFx0dGhpcy5jaGlsZHJlbi5wdXNoKG9iamVjdCk7XG5cdFx0XHRvYmplY3QuZGlzcGF0Y2hFdmVudChfYWRkZWRFdmVudCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLk9iamVjdDNELmFkZDogb2JqZWN0IG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5PYmplY3QzRC4nLCBvYmplY3QpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRyZW1vdmUob2JqZWN0KSB7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR0aGlzLnJlbW92ZShhcmd1bWVudHNbaV0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGNvbnN0IGluZGV4ID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKG9iamVjdCk7XG5cdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0b2JqZWN0LnBhcmVudCA9IG51bGw7XG5cdFx0XHR0aGlzLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRvYmplY3QuZGlzcGF0Y2hFdmVudChfcmVtb3ZlZEV2ZW50KTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0cmVtb3ZlRnJvbVBhcmVudCgpIHtcblx0XHRjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcblx0XHRpZiAocGFyZW50ICE9PSBudWxsKSB7XG5cdFx0XHRwYXJlbnQucmVtb3ZlKHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRjbGVhcigpIHtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IG9iamVjdCA9IHRoaXMuY2hpbGRyZW5baV07XG5cdFx0XHRvYmplY3QucGFyZW50ID0gbnVsbDtcblx0XHRcdG9iamVjdC5kaXNwYXRjaEV2ZW50KF9yZW1vdmVkRXZlbnQpO1xuXHRcdH1cblx0XHR0aGlzLmNoaWxkcmVuLmxlbmd0aCA9IDA7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0YXR0YWNoKG9iamVjdCkge1xuXHRcdC8vIGFkZHMgb2JqZWN0IGFzIGEgY2hpbGQgb2YgdGhpcywgd2hpbGUgbWFpbnRhaW5pbmcgdGhlIG9iamVjdCdzIHdvcmxkIHRyYW5zZm9ybVxuXG5cdFx0Ly8gTm90ZTogVGhpcyBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCBzY2VuZSBncmFwaHMgaGF2aW5nIG5vbi11bmlmb3JtbHktc2NhbGVkIG5vZGVzKHMpXG5cblx0XHR0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KHRydWUsIGZhbHNlKTtcblx0XHRfbTEkMS5jb3B5KHRoaXMubWF0cml4V29ybGQpLmludmVydCgpO1xuXHRcdGlmIChvYmplY3QucGFyZW50ICE9PSBudWxsKSB7XG5cdFx0XHRvYmplY3QucGFyZW50LnVwZGF0ZVdvcmxkTWF0cml4KHRydWUsIGZhbHNlKTtcblx0XHRcdF9tMSQxLm11bHRpcGx5KG9iamVjdC5wYXJlbnQubWF0cml4V29ybGQpO1xuXHRcdH1cblx0XHRvYmplY3QuYXBwbHlNYXRyaXg0KF9tMSQxKTtcblx0XHR0aGlzLmFkZChvYmplY3QpO1xuXHRcdG9iamVjdC51cGRhdGVXb3JsZE1hdHJpeChmYWxzZSwgdHJ1ZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0Z2V0T2JqZWN0QnlJZChpZCkge1xuXHRcdHJldHVybiB0aGlzLmdldE9iamVjdEJ5UHJvcGVydHkoJ2lkJywgaWQpO1xuXHR9XG5cdGdldE9iamVjdEJ5TmFtZShuYW1lKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlQcm9wZXJ0eSgnbmFtZScsIG5hbWUpO1xuXHR9XG5cdGdldE9iamVjdEJ5UHJvcGVydHkobmFtZSwgdmFsdWUpIHtcblx0XHRpZiAodGhpc1tuYW1lXSA9PT0gdmFsdWUpIHJldHVybiB0aGlzO1xuXHRcdGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGNvbnN0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcblx0XHRcdGNvbnN0IG9iamVjdCA9IGNoaWxkLmdldE9iamVjdEJ5UHJvcGVydHkobmFtZSwgdmFsdWUpO1xuXHRcdFx0aWYgKG9iamVjdCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHJldHVybiBvYmplY3Q7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdH1cblx0Z2V0V29ybGRQb3NpdGlvbih0YXJnZXQpIHtcblx0XHR0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KHRydWUsIGZhbHNlKTtcblx0XHRyZXR1cm4gdGFyZ2V0LnNldEZyb21NYXRyaXhQb3NpdGlvbih0aGlzLm1hdHJpeFdvcmxkKTtcblx0fVxuXHRnZXRXb3JsZFF1YXRlcm5pb24odGFyZ2V0KSB7XG5cdFx0dGhpcy51cGRhdGVXb3JsZE1hdHJpeCh0cnVlLCBmYWxzZSk7XG5cdFx0dGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoX3Bvc2l0aW9uJDMsIHRhcmdldCwgX3NjYWxlJDIpO1xuXHRcdHJldHVybiB0YXJnZXQ7XG5cdH1cblx0Z2V0V29ybGRTY2FsZSh0YXJnZXQpIHtcblx0XHR0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KHRydWUsIGZhbHNlKTtcblx0XHR0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZShfcG9zaXRpb24kMywgX3F1YXRlcm5pb24kMiwgdGFyZ2V0KTtcblx0XHRyZXR1cm4gdGFyZ2V0O1xuXHR9XG5cdGdldFdvcmxkRGlyZWN0aW9uKHRhcmdldCkge1xuXHRcdHRoaXMudXBkYXRlV29ybGRNYXRyaXgodHJ1ZSwgZmFsc2UpO1xuXHRcdGNvbnN0IGUgPSB0aGlzLm1hdHJpeFdvcmxkLmVsZW1lbnRzO1xuXHRcdHJldHVybiB0YXJnZXQuc2V0KGVbOF0sIGVbOV0sIGVbMTBdKS5ub3JtYWxpemUoKTtcblx0fVxuXHRyYXljYXN0KCkge31cblx0dHJhdmVyc2UoY2FsbGJhY2spIHtcblx0XHRjYWxsYmFjayh0aGlzKTtcblx0XHRjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG5cdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGNoaWxkcmVuW2ldLnRyYXZlcnNlKGNhbGxiYWNrKTtcblx0XHR9XG5cdH1cblx0dHJhdmVyc2VWaXNpYmxlKGNhbGxiYWNrKSB7XG5cdFx0aWYgKHRoaXMudmlzaWJsZSA9PT0gZmFsc2UpIHJldHVybjtcblx0XHRjYWxsYmFjayh0aGlzKTtcblx0XHRjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG5cdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGNoaWxkcmVuW2ldLnRyYXZlcnNlVmlzaWJsZShjYWxsYmFjayk7XG5cdFx0fVxuXHR9XG5cdHRyYXZlcnNlQW5jZXN0b3JzKGNhbGxiYWNrKSB7XG5cdFx0Y29uc3QgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG5cdFx0aWYgKHBhcmVudCAhPT0gbnVsbCkge1xuXHRcdFx0Y2FsbGJhY2socGFyZW50KTtcblx0XHRcdHBhcmVudC50cmF2ZXJzZUFuY2VzdG9ycyhjYWxsYmFjayk7XG5cdFx0fVxuXHR9XG5cdHVwZGF0ZU1hdHJpeCgpIHtcblx0XHR0aGlzLm1hdHJpeC5jb21wb3NlKHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSk7XG5cdFx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0fVxuXHR1cGRhdGVNYXRyaXhXb3JsZChmb3JjZSkge1xuXHRcdGlmICh0aGlzLm1hdHJpeEF1dG9VcGRhdGUpIHRoaXMudXBkYXRlTWF0cml4KCk7XG5cdFx0aWYgKHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSB8fCBmb3JjZSkge1xuXHRcdFx0aWYgKHRoaXMucGFyZW50ID09PSBudWxsKSB7XG5cdFx0XHRcdHRoaXMubWF0cml4V29ybGQuY29weSh0aGlzLm1hdHJpeCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLm1hdHJpeFdvcmxkLm11bHRpcGx5TWF0cmljZXModGhpcy5wYXJlbnQubWF0cml4V29ybGQsIHRoaXMubWF0cml4KTtcblx0XHRcdH1cblx0XHRcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXHRcdFx0Zm9yY2UgPSB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIHVwZGF0ZSBjaGlsZHJlblxuXG5cdFx0Y29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXHRcdGZvciAobGV0IGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXHRcdFx0aWYgKGNoaWxkLm1hdHJpeFdvcmxkQXV0b1VwZGF0ZSA9PT0gdHJ1ZSB8fCBmb3JjZSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRjaGlsZC51cGRhdGVNYXRyaXhXb3JsZChmb3JjZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHVwZGF0ZVdvcmxkTWF0cml4KHVwZGF0ZVBhcmVudHMsIHVwZGF0ZUNoaWxkcmVuKSB7XG5cdFx0Y29uc3QgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG5cdFx0aWYgKHVwZGF0ZVBhcmVudHMgPT09IHRydWUgJiYgcGFyZW50ICE9PSBudWxsICYmIHBhcmVudC5tYXRyaXhXb3JsZEF1dG9VcGRhdGUgPT09IHRydWUpIHtcblx0XHRcdHBhcmVudC51cGRhdGVXb3JsZE1hdHJpeCh0cnVlLCBmYWxzZSk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLm1hdHJpeEF1dG9VcGRhdGUpIHRoaXMudXBkYXRlTWF0cml4KCk7XG5cdFx0aWYgKHRoaXMucGFyZW50ID09PSBudWxsKSB7XG5cdFx0XHR0aGlzLm1hdHJpeFdvcmxkLmNvcHkodGhpcy5tYXRyaXgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLm1hdHJpeFdvcmxkLm11bHRpcGx5TWF0cmljZXModGhpcy5wYXJlbnQubWF0cml4V29ybGQsIHRoaXMubWF0cml4KTtcblx0XHR9XG5cblx0XHQvLyB1cGRhdGUgY2hpbGRyZW5cblxuXHRcdGlmICh1cGRhdGVDaGlsZHJlbiA9PT0gdHJ1ZSkge1xuXHRcdFx0Y29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcblx0XHRcdFx0aWYgKGNoaWxkLm1hdHJpeFdvcmxkQXV0b1VwZGF0ZSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdGNoaWxkLnVwZGF0ZVdvcmxkTWF0cml4KGZhbHNlLCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHR0b0pTT04obWV0YSkge1xuXHRcdC8vIG1ldGEgaXMgYSBzdHJpbmcgd2hlbiBjYWxsZWQgZnJvbSBKU09OLnN0cmluZ2lmeVxuXHRcdGNvbnN0IGlzUm9vdE9iamVjdCA9IG1ldGEgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgbWV0YSA9PT0gJ3N0cmluZyc7XG5cdFx0Y29uc3Qgb3V0cHV0ID0ge307XG5cblx0XHQvLyBtZXRhIGlzIGEgaGFzaCB1c2VkIHRvIGNvbGxlY3QgZ2VvbWV0cmllcywgbWF0ZXJpYWxzLlxuXHRcdC8vIG5vdCBwcm92aWRpbmcgaXQgaW1wbGllcyB0aGF0IHRoaXMgaXMgdGhlIHJvb3Qgb2JqZWN0XG5cdFx0Ly8gYmVpbmcgc2VyaWFsaXplZC5cblx0XHRpZiAoaXNSb290T2JqZWN0KSB7XG5cdFx0XHQvLyBpbml0aWFsaXplIG1ldGEgb2JqXG5cdFx0XHRtZXRhID0ge1xuXHRcdFx0XHRnZW9tZXRyaWVzOiB7fSxcblx0XHRcdFx0bWF0ZXJpYWxzOiB7fSxcblx0XHRcdFx0dGV4dHVyZXM6IHt9LFxuXHRcdFx0XHRpbWFnZXM6IHt9LFxuXHRcdFx0XHRzaGFwZXM6IHt9LFxuXHRcdFx0XHRza2VsZXRvbnM6IHt9LFxuXHRcdFx0XHRhbmltYXRpb25zOiB7fSxcblx0XHRcdFx0bm9kZXM6IHt9XG5cdFx0XHR9O1xuXHRcdFx0b3V0cHV0Lm1ldGFkYXRhID0ge1xuXHRcdFx0XHR2ZXJzaW9uOiA0LjUsXG5cdFx0XHRcdHR5cGU6ICdPYmplY3QnLFxuXHRcdFx0XHRnZW5lcmF0b3I6ICdPYmplY3QzRC50b0pTT04nXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIHN0YW5kYXJkIE9iamVjdDNEIHNlcmlhbGl6YXRpb25cblxuXHRcdGNvbnN0IG9iamVjdCA9IHt9O1xuXHRcdG9iamVjdC51dWlkID0gdGhpcy51dWlkO1xuXHRcdG9iamVjdC50eXBlID0gdGhpcy50eXBlO1xuXHRcdGlmICh0aGlzLm5hbWUgIT09ICcnKSBvYmplY3QubmFtZSA9IHRoaXMubmFtZTtcblx0XHRpZiAodGhpcy5jYXN0U2hhZG93ID09PSB0cnVlKSBvYmplY3QuY2FzdFNoYWRvdyA9IHRydWU7XG5cdFx0aWYgKHRoaXMucmVjZWl2ZVNoYWRvdyA9PT0gdHJ1ZSkgb2JqZWN0LnJlY2VpdmVTaGFkb3cgPSB0cnVlO1xuXHRcdGlmICh0aGlzLnZpc2libGUgPT09IGZhbHNlKSBvYmplY3QudmlzaWJsZSA9IGZhbHNlO1xuXHRcdGlmICh0aGlzLmZydXN0dW1DdWxsZWQgPT09IGZhbHNlKSBvYmplY3QuZnJ1c3R1bUN1bGxlZCA9IGZhbHNlO1xuXHRcdGlmICh0aGlzLnJlbmRlck9yZGVyICE9PSAwKSBvYmplY3QucmVuZGVyT3JkZXIgPSB0aGlzLnJlbmRlck9yZGVyO1xuXHRcdGlmIChKU09OLnN0cmluZ2lmeSh0aGlzLnVzZXJEYXRhKSAhPT0gJ3t9Jykgb2JqZWN0LnVzZXJEYXRhID0gdGhpcy51c2VyRGF0YTtcblx0XHRvYmplY3QubGF5ZXJzID0gdGhpcy5sYXllcnMubWFzaztcblx0XHRvYmplY3QubWF0cml4ID0gdGhpcy5tYXRyaXgudG9BcnJheSgpO1xuXHRcdGlmICh0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPT09IGZhbHNlKSBvYmplY3QubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0Ly8gb2JqZWN0IHNwZWNpZmljIHByb3BlcnRpZXNcblxuXHRcdGlmICh0aGlzLmlzSW5zdGFuY2VkTWVzaCkge1xuXHRcdFx0b2JqZWN0LnR5cGUgPSAnSW5zdGFuY2VkTWVzaCc7XG5cdFx0XHRvYmplY3QuY291bnQgPSB0aGlzLmNvdW50O1xuXHRcdFx0b2JqZWN0Lmluc3RhbmNlTWF0cml4ID0gdGhpcy5pbnN0YW5jZU1hdHJpeC50b0pTT04oKTtcblx0XHRcdGlmICh0aGlzLmluc3RhbmNlQ29sb3IgIT09IG51bGwpIG9iamVjdC5pbnN0YW5jZUNvbG9yID0gdGhpcy5pbnN0YW5jZUNvbG9yLnRvSlNPTigpO1xuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRmdW5jdGlvbiBzZXJpYWxpemUobGlicmFyeSwgZWxlbWVudCkge1xuXHRcdFx0aWYgKGxpYnJhcnlbZWxlbWVudC51dWlkXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGxpYnJhcnlbZWxlbWVudC51dWlkXSA9IGVsZW1lbnQudG9KU09OKG1ldGEpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGVsZW1lbnQudXVpZDtcblx0XHR9XG5cdFx0aWYgKHRoaXMuaXNTY2VuZSkge1xuXHRcdFx0aWYgKHRoaXMuYmFja2dyb3VuZCkge1xuXHRcdFx0XHRpZiAodGhpcy5iYWNrZ3JvdW5kLmlzQ29sb3IpIHtcblx0XHRcdFx0XHRvYmplY3QuYmFja2dyb3VuZCA9IHRoaXMuYmFja2dyb3VuZC50b0pTT04oKTtcblx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLmJhY2tncm91bmQuaXNUZXh0dXJlKSB7XG5cdFx0XHRcdFx0b2JqZWN0LmJhY2tncm91bmQgPSB0aGlzLmJhY2tncm91bmQudG9KU09OKG1ldGEpLnV1aWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLmVudmlyb25tZW50ICYmIHRoaXMuZW52aXJvbm1lbnQuaXNUZXh0dXJlICYmIHRoaXMuZW52aXJvbm1lbnQuaXNSZW5kZXJUYXJnZXRUZXh0dXJlICE9PSB0cnVlKSB7XG5cdFx0XHRcdG9iamVjdC5lbnZpcm9ubWVudCA9IHRoaXMuZW52aXJvbm1lbnQudG9KU09OKG1ldGEpLnV1aWQ7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0aGlzLmlzTWVzaCB8fCB0aGlzLmlzTGluZSB8fCB0aGlzLmlzUG9pbnRzKSB7XG5cdFx0XHRvYmplY3QuZ2VvbWV0cnkgPSBzZXJpYWxpemUobWV0YS5nZW9tZXRyaWVzLCB0aGlzLmdlb21ldHJ5KTtcblx0XHRcdGNvbnN0IHBhcmFtZXRlcnMgPSB0aGlzLmdlb21ldHJ5LnBhcmFtZXRlcnM7XG5cdFx0XHRpZiAocGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICYmIHBhcmFtZXRlcnMuc2hhcGVzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y29uc3Qgc2hhcGVzID0gcGFyYW1ldGVycy5zaGFwZXM7XG5cdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KHNoYXBlcykpIHtcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHNoYXBlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdGNvbnN0IHNoYXBlID0gc2hhcGVzW2ldO1xuXHRcdFx0XHRcdFx0c2VyaWFsaXplKG1ldGEuc2hhcGVzLCBzaGFwZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNlcmlhbGl6ZShtZXRhLnNoYXBlcywgc2hhcGVzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAodGhpcy5pc1NraW5uZWRNZXNoKSB7XG5cdFx0XHRvYmplY3QuYmluZE1vZGUgPSB0aGlzLmJpbmRNb2RlO1xuXHRcdFx0b2JqZWN0LmJpbmRNYXRyaXggPSB0aGlzLmJpbmRNYXRyaXgudG9BcnJheSgpO1xuXHRcdFx0aWYgKHRoaXMuc2tlbGV0b24gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRzZXJpYWxpemUobWV0YS5za2VsZXRvbnMsIHRoaXMuc2tlbGV0b24pO1xuXHRcdFx0XHRvYmplY3Quc2tlbGV0b24gPSB0aGlzLnNrZWxldG9uLnV1aWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICh0aGlzLm1hdGVyaWFsICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KHRoaXMubWF0ZXJpYWwpKSB7XG5cdFx0XHRcdGNvbnN0IHV1aWRzID0gW107XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5tYXRlcmlhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHR1dWlkcy5wdXNoKHNlcmlhbGl6ZShtZXRhLm1hdGVyaWFscywgdGhpcy5tYXRlcmlhbFtpXSkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG9iamVjdC5tYXRlcmlhbCA9IHV1aWRzO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2JqZWN0Lm1hdGVyaWFsID0gc2VyaWFsaXplKG1ldGEubWF0ZXJpYWxzLCB0aGlzLm1hdGVyaWFsKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0aWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuXHRcdFx0b2JqZWN0LmNoaWxkcmVuID0gW107XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0b2JqZWN0LmNoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlbltpXS50b0pTT04obWV0YSkub2JqZWN0KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0aWYgKHRoaXMuYW5pbWF0aW9ucy5sZW5ndGggPiAwKSB7XG5cdFx0XHRvYmplY3QuYW5pbWF0aW9ucyA9IFtdO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmFuaW1hdGlvbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zW2ldO1xuXHRcdFx0XHRvYmplY3QuYW5pbWF0aW9ucy5wdXNoKHNlcmlhbGl6ZShtZXRhLmFuaW1hdGlvbnMsIGFuaW1hdGlvbikpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoaXNSb290T2JqZWN0KSB7XG5cdFx0XHRjb25zdCBnZW9tZXRyaWVzID0gZXh0cmFjdEZyb21DYWNoZShtZXRhLmdlb21ldHJpZXMpO1xuXHRcdFx0Y29uc3QgbWF0ZXJpYWxzID0gZXh0cmFjdEZyb21DYWNoZShtZXRhLm1hdGVyaWFscyk7XG5cdFx0XHRjb25zdCB0ZXh0dXJlcyA9IGV4dHJhY3RGcm9tQ2FjaGUobWV0YS50ZXh0dXJlcyk7XG5cdFx0XHRjb25zdCBpbWFnZXMgPSBleHRyYWN0RnJvbUNhY2hlKG1ldGEuaW1hZ2VzKTtcblx0XHRcdGNvbnN0IHNoYXBlcyA9IGV4dHJhY3RGcm9tQ2FjaGUobWV0YS5zaGFwZXMpO1xuXHRcdFx0Y29uc3Qgc2tlbGV0b25zID0gZXh0cmFjdEZyb21DYWNoZShtZXRhLnNrZWxldG9ucyk7XG5cdFx0XHRjb25zdCBhbmltYXRpb25zID0gZXh0cmFjdEZyb21DYWNoZShtZXRhLmFuaW1hdGlvbnMpO1xuXHRcdFx0Y29uc3Qgbm9kZXMgPSBleHRyYWN0RnJvbUNhY2hlKG1ldGEubm9kZXMpO1xuXHRcdFx0aWYgKGdlb21ldHJpZXMubGVuZ3RoID4gMCkgb3V0cHV0Lmdlb21ldHJpZXMgPSBnZW9tZXRyaWVzO1xuXHRcdFx0aWYgKG1hdGVyaWFscy5sZW5ndGggPiAwKSBvdXRwdXQubWF0ZXJpYWxzID0gbWF0ZXJpYWxzO1xuXHRcdFx0aWYgKHRleHR1cmVzLmxlbmd0aCA+IDApIG91dHB1dC50ZXh0dXJlcyA9IHRleHR1cmVzO1xuXHRcdFx0aWYgKGltYWdlcy5sZW5ndGggPiAwKSBvdXRwdXQuaW1hZ2VzID0gaW1hZ2VzO1xuXHRcdFx0aWYgKHNoYXBlcy5sZW5ndGggPiAwKSBvdXRwdXQuc2hhcGVzID0gc2hhcGVzO1xuXHRcdFx0aWYgKHNrZWxldG9ucy5sZW5ndGggPiAwKSBvdXRwdXQuc2tlbGV0b25zID0gc2tlbGV0b25zO1xuXHRcdFx0aWYgKGFuaW1hdGlvbnMubGVuZ3RoID4gMCkgb3V0cHV0LmFuaW1hdGlvbnMgPSBhbmltYXRpb25zO1xuXHRcdFx0aWYgKG5vZGVzLmxlbmd0aCA+IDApIG91dHB1dC5ub2RlcyA9IG5vZGVzO1xuXHRcdH1cblx0XHRvdXRwdXQub2JqZWN0ID0gb2JqZWN0O1xuXHRcdHJldHVybiBvdXRwdXQ7XG5cblx0XHQvLyBleHRyYWN0IGRhdGEgZnJvbSB0aGUgY2FjaGUgaGFzaFxuXHRcdC8vIHJlbW92ZSBtZXRhZGF0YSBvbiBlYWNoIGl0ZW1cblx0XHQvLyBhbmQgcmV0dXJuIGFzIGFycmF5XG5cdFx0ZnVuY3Rpb24gZXh0cmFjdEZyb21DYWNoZShjYWNoZSkge1xuXHRcdFx0Y29uc3QgdmFsdWVzID0gW107XG5cdFx0XHRmb3IgKGNvbnN0IGtleSBpbiBjYWNoZSkge1xuXHRcdFx0XHRjb25zdCBkYXRhID0gY2FjaGVba2V5XTtcblx0XHRcdFx0ZGVsZXRlIGRhdGEubWV0YWRhdGE7XG5cdFx0XHRcdHZhbHVlcy5wdXNoKGRhdGEpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHR9XG5cdH1cblx0Y2xvbmUocmVjdXJzaXZlKSB7XG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzLCByZWN1cnNpdmUpO1xuXHR9XG5cdGNvcHkoc291cmNlLCByZWN1cnNpdmUgPSB0cnVlKSB7XG5cdFx0dGhpcy5uYW1lID0gc291cmNlLm5hbWU7XG5cdFx0dGhpcy51cC5jb3B5KHNvdXJjZS51cCk7XG5cdFx0dGhpcy5wb3NpdGlvbi5jb3B5KHNvdXJjZS5wb3NpdGlvbik7XG5cdFx0dGhpcy5yb3RhdGlvbi5vcmRlciA9IHNvdXJjZS5yb3RhdGlvbi5vcmRlcjtcblx0XHR0aGlzLnF1YXRlcm5pb24uY29weShzb3VyY2UucXVhdGVybmlvbik7XG5cdFx0dGhpcy5zY2FsZS5jb3B5KHNvdXJjZS5zY2FsZSk7XG5cdFx0dGhpcy5tYXRyaXguY29weShzb3VyY2UubWF0cml4KTtcblx0XHR0aGlzLm1hdHJpeFdvcmxkLmNvcHkoc291cmNlLm1hdHJpeFdvcmxkKTtcblx0XHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBzb3VyY2UubWF0cml4QXV0b1VwZGF0ZTtcblx0XHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSBzb3VyY2UubWF0cml4V29ybGROZWVkc1VwZGF0ZTtcblx0XHR0aGlzLm1hdHJpeFdvcmxkQXV0b1VwZGF0ZSA9IHNvdXJjZS5tYXRyaXhXb3JsZEF1dG9VcGRhdGU7XG5cdFx0dGhpcy5sYXllcnMubWFzayA9IHNvdXJjZS5sYXllcnMubWFzaztcblx0XHR0aGlzLnZpc2libGUgPSBzb3VyY2UudmlzaWJsZTtcblx0XHR0aGlzLmNhc3RTaGFkb3cgPSBzb3VyY2UuY2FzdFNoYWRvdztcblx0XHR0aGlzLnJlY2VpdmVTaGFkb3cgPSBzb3VyY2UucmVjZWl2ZVNoYWRvdztcblx0XHR0aGlzLmZydXN0dW1DdWxsZWQgPSBzb3VyY2UuZnJ1c3R1bUN1bGxlZDtcblx0XHR0aGlzLnJlbmRlck9yZGVyID0gc291cmNlLnJlbmRlck9yZGVyO1xuXHRcdHRoaXMudXNlckRhdGEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHNvdXJjZS51c2VyRGF0YSkpO1xuXHRcdGlmIChyZWN1cnNpdmUgPT09IHRydWUpIHtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGNoaWxkID0gc291cmNlLmNoaWxkcmVuW2ldO1xuXHRcdFx0XHR0aGlzLmFkZChjaGlsZC5jbG9uZSgpKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn1cbk9iamVjdDNELkRlZmF1bHRVcCA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygwLCAxLCAwKTtcbk9iamVjdDNELkRlZmF1bHRNYXRyaXhBdXRvVXBkYXRlID0gdHJ1ZTtcbk9iamVjdDNELkRlZmF1bHRNYXRyaXhXb3JsZEF1dG9VcGRhdGUgPSB0cnVlO1xuXG5jb25zdCBfdjAkMSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuY29uc3QgX3YxJDMgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF92MiQyID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5jb25zdCBfdjMkMSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuY29uc3QgX3ZhYiA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuY29uc3QgX3ZhYyA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuY29uc3QgX3ZiYyA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuY29uc3QgX3ZhcCA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuY29uc3QgX3ZicCA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuY29uc3QgX3ZjcCA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuY2xhc3MgVHJpYW5nbGUge1xuXHRjb25zdHJ1Y3RvcihhID0gbmV3IFZlY3RvcjMoKSwgYiA9IG5ldyBWZWN0b3IzKCksIGMgPSBuZXcgVmVjdG9yMygpKSB7XG5cdFx0dGhpcy5hID0gYTtcblx0XHR0aGlzLmIgPSBiO1xuXHRcdHRoaXMuYyA9IGM7XG5cdH1cblx0c3RhdGljIGdldE5vcm1hbChhLCBiLCBjLCB0YXJnZXQpIHtcblx0XHR0YXJnZXQuc3ViVmVjdG9ycyhjLCBiKTtcblx0XHRfdjAkMS5zdWJWZWN0b3JzKGEsIGIpO1xuXHRcdHRhcmdldC5jcm9zcyhfdjAkMSk7XG5cdFx0Y29uc3QgdGFyZ2V0TGVuZ3RoU3EgPSB0YXJnZXQubGVuZ3RoU3EoKTtcblx0XHRpZiAodGFyZ2V0TGVuZ3RoU3EgPiAwKSB7XG5cdFx0XHRyZXR1cm4gdGFyZ2V0Lm11bHRpcGx5U2NhbGFyKDEgLyBNYXRoLnNxcnQodGFyZ2V0TGVuZ3RoU3EpKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRhcmdldC5zZXQoMCwgMCwgMCk7XG5cdH1cblxuXHQvLyBzdGF0aWMvaW5zdGFuY2UgbWV0aG9kIHRvIGNhbGN1bGF0ZSBiYXJ5Y2VudHJpYyBjb29yZGluYXRlc1xuXHQvLyBiYXNlZCBvbjogaHR0cDovL3d3dy5ibGFja3Bhd24uY29tL3RleHRzL3BvaW50aW5wb2x5L2RlZmF1bHQuaHRtbFxuXHRzdGF0aWMgZ2V0QmFyeWNvb3JkKHBvaW50LCBhLCBiLCBjLCB0YXJnZXQpIHtcblx0XHRfdjAkMS5zdWJWZWN0b3JzKGMsIGEpO1xuXHRcdF92MSQzLnN1YlZlY3RvcnMoYiwgYSk7XG5cdFx0X3YyJDIuc3ViVmVjdG9ycyhwb2ludCwgYSk7XG5cdFx0Y29uc3QgZG90MDAgPSBfdjAkMS5kb3QoX3YwJDEpO1xuXHRcdGNvbnN0IGRvdDAxID0gX3YwJDEuZG90KF92MSQzKTtcblx0XHRjb25zdCBkb3QwMiA9IF92MCQxLmRvdChfdjIkMik7XG5cdFx0Y29uc3QgZG90MTEgPSBfdjEkMy5kb3QoX3YxJDMpO1xuXHRcdGNvbnN0IGRvdDEyID0gX3YxJDMuZG90KF92MiQyKTtcblx0XHRjb25zdCBkZW5vbSA9IGRvdDAwICogZG90MTEgLSBkb3QwMSAqIGRvdDAxO1xuXG5cdFx0Ly8gY29sbGluZWFyIG9yIHNpbmd1bGFyIHRyaWFuZ2xlXG5cdFx0aWYgKGRlbm9tID09PSAwKSB7XG5cdFx0XHQvLyBhcmJpdHJhcnkgbG9jYXRpb24gb3V0c2lkZSBvZiB0cmlhbmdsZT9cblx0XHRcdC8vIG5vdCBzdXJlIGlmIHRoaXMgaXMgdGhlIGJlc3QgaWRlYSwgbWF5YmUgc2hvdWxkIGJlIHJldHVybmluZyB1bmRlZmluZWRcblx0XHRcdHJldHVybiB0YXJnZXQuc2V0KC0yLCAtMSwgLTEpO1xuXHRcdH1cblx0XHRjb25zdCBpbnZEZW5vbSA9IDEgLyBkZW5vbTtcblx0XHRjb25zdCB1ID0gKGRvdDExICogZG90MDIgLSBkb3QwMSAqIGRvdDEyKSAqIGludkRlbm9tO1xuXHRcdGNvbnN0IHYgPSAoZG90MDAgKiBkb3QxMiAtIGRvdDAxICogZG90MDIpICogaW52RGVub207XG5cblx0XHQvLyBiYXJ5Y2VudHJpYyBjb29yZGluYXRlcyBtdXN0IGFsd2F5cyBzdW0gdG8gMVxuXHRcdHJldHVybiB0YXJnZXQuc2V0KDEgLSB1IC0gdiwgdiwgdSk7XG5cdH1cblx0c3RhdGljIGNvbnRhaW5zUG9pbnQocG9pbnQsIGEsIGIsIGMpIHtcblx0XHR0aGlzLmdldEJhcnljb29yZChwb2ludCwgYSwgYiwgYywgX3YzJDEpO1xuXHRcdHJldHVybiBfdjMkMS54ID49IDAgJiYgX3YzJDEueSA+PSAwICYmIF92MyQxLnggKyBfdjMkMS55IDw9IDE7XG5cdH1cblx0c3RhdGljIGdldFVWKHBvaW50LCBwMSwgcDIsIHAzLCB1djEsIHV2MiwgdXYzLCB0YXJnZXQpIHtcblx0XHR0aGlzLmdldEJhcnljb29yZChwb2ludCwgcDEsIHAyLCBwMywgX3YzJDEpO1xuXHRcdHRhcmdldC5zZXQoMCwgMCk7XG5cdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3Rvcih1djEsIF92MyQxLngpO1xuXHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IodXYyLCBfdjMkMS55KTtcblx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKHV2MywgX3YzJDEueik7XG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fVxuXHRzdGF0aWMgaXNGcm9udEZhY2luZyhhLCBiLCBjLCBkaXJlY3Rpb24pIHtcblx0XHRfdjAkMS5zdWJWZWN0b3JzKGMsIGIpO1xuXHRcdF92MSQzLnN1YlZlY3RvcnMoYSwgYik7XG5cblx0XHQvLyBzdHJpY3RseSBmcm9udCBmYWNpbmdcblx0XHRyZXR1cm4gX3YwJDEuY3Jvc3MoX3YxJDMpLmRvdChkaXJlY3Rpb24pIDwgMCA/IHRydWUgOiBmYWxzZTtcblx0fVxuXHRzZXQoYSwgYiwgYykge1xuXHRcdHRoaXMuYS5jb3B5KGEpO1xuXHRcdHRoaXMuYi5jb3B5KGIpO1xuXHRcdHRoaXMuYy5jb3B5KGMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHNldEZyb21Qb2ludHNBbmRJbmRpY2VzKHBvaW50cywgaTAsIGkxLCBpMikge1xuXHRcdHRoaXMuYS5jb3B5KHBvaW50c1tpMF0pO1xuXHRcdHRoaXMuYi5jb3B5KHBvaW50c1tpMV0pO1xuXHRcdHRoaXMuYy5jb3B5KHBvaW50c1tpMl0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHNldEZyb21BdHRyaWJ1dGVBbmRJbmRpY2VzKGF0dHJpYnV0ZSwgaTAsIGkxLCBpMikge1xuXHRcdHRoaXMuYS5mcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZSwgaTApO1xuXHRcdHRoaXMuYi5mcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZSwgaTEpO1xuXHRcdHRoaXMuYy5mcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZSwgaTIpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGNsb25lKCkge1xuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyk7XG5cdH1cblx0Y29weSh0cmlhbmdsZSkge1xuXHRcdHRoaXMuYS5jb3B5KHRyaWFuZ2xlLmEpO1xuXHRcdHRoaXMuYi5jb3B5KHRyaWFuZ2xlLmIpO1xuXHRcdHRoaXMuYy5jb3B5KHRyaWFuZ2xlLmMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGdldEFyZWEoKSB7XG5cdFx0X3YwJDEuc3ViVmVjdG9ycyh0aGlzLmMsIHRoaXMuYik7XG5cdFx0X3YxJDMuc3ViVmVjdG9ycyh0aGlzLmEsIHRoaXMuYik7XG5cdFx0cmV0dXJuIF92MCQxLmNyb3NzKF92MSQzKS5sZW5ndGgoKSAqIDAuNTtcblx0fVxuXHRnZXRNaWRwb2ludCh0YXJnZXQpIHtcblx0XHRyZXR1cm4gdGFyZ2V0LmFkZFZlY3RvcnModGhpcy5hLCB0aGlzLmIpLmFkZCh0aGlzLmMpLm11bHRpcGx5U2NhbGFyKDEgLyAzKTtcblx0fVxuXHRnZXROb3JtYWwodGFyZ2V0KSB7XG5cdFx0cmV0dXJuIFRyaWFuZ2xlLmdldE5vcm1hbCh0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCB0YXJnZXQpO1xuXHR9XG5cdGdldFBsYW5lKHRhcmdldCkge1xuXHRcdHJldHVybiB0YXJnZXQuc2V0RnJvbUNvcGxhbmFyUG9pbnRzKHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMpO1xuXHR9XG5cdGdldEJhcnljb29yZChwb2ludCwgdGFyZ2V0KSB7XG5cdFx0cmV0dXJuIFRyaWFuZ2xlLmdldEJhcnljb29yZChwb2ludCwgdGhpcy5hLCB0aGlzLmIsIHRoaXMuYywgdGFyZ2V0KTtcblx0fVxuXHRnZXRVVihwb2ludCwgdXYxLCB1djIsIHV2MywgdGFyZ2V0KSB7XG5cdFx0cmV0dXJuIFRyaWFuZ2xlLmdldFVWKHBvaW50LCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCB1djEsIHV2MiwgdXYzLCB0YXJnZXQpO1xuXHR9XG5cdGNvbnRhaW5zUG9pbnQocG9pbnQpIHtcblx0XHRyZXR1cm4gVHJpYW5nbGUuY29udGFpbnNQb2ludChwb2ludCwgdGhpcy5hLCB0aGlzLmIsIHRoaXMuYyk7XG5cdH1cblx0aXNGcm9udEZhY2luZyhkaXJlY3Rpb24pIHtcblx0XHRyZXR1cm4gVHJpYW5nbGUuaXNGcm9udEZhY2luZyh0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCBkaXJlY3Rpb24pO1xuXHR9XG5cdGludGVyc2VjdHNCb3goYm94KSB7XG5cdFx0cmV0dXJuIGJveC5pbnRlcnNlY3RzVHJpYW5nbGUodGhpcyk7XG5cdH1cblx0Y2xvc2VzdFBvaW50VG9Qb2ludChwLCB0YXJnZXQpIHtcblx0XHRjb25zdCBhID0gdGhpcy5hLFxuXHRcdFx0YiA9IHRoaXMuYixcblx0XHRcdGMgPSB0aGlzLmM7XG5cdFx0bGV0IHYsIHc7XG5cblx0XHQvLyBhbGdvcml0aG0gdGhhbmtzIHRvIFJlYWwtVGltZSBDb2xsaXNpb24gRGV0ZWN0aW9uIGJ5IENocmlzdGVyIEVyaWNzb24sXG5cdFx0Ly8gcHVibGlzaGVkIGJ5IE1vcmdhbiBLYXVmbWFubiBQdWJsaXNoZXJzLCAoYykgMjAwNSBFbHNldmllciBJbmMuLFxuXHRcdC8vIHVuZGVyIHRoZSBhY2NvbXBhbnlpbmcgbGljZW5zZTsgc2VlIGNoYXB0ZXIgNS4xLjUgZm9yIGRldGFpbGVkIGV4cGxhbmF0aW9uLlxuXHRcdC8vIGJhc2ljYWxseSwgd2UncmUgZGlzdGluZ3Vpc2hpbmcgd2hpY2ggb2YgdGhlIHZvcm9ub2kgcmVnaW9ucyBvZiB0aGUgdHJpYW5nbGVcblx0XHQvLyB0aGUgcG9pbnQgbGllcyBpbiB3aXRoIHRoZSBtaW5pbXVtIGFtb3VudCBvZiByZWR1bmRhbnQgY29tcHV0YXRpb24uXG5cblx0XHRfdmFiLnN1YlZlY3RvcnMoYiwgYSk7XG5cdFx0X3ZhYy5zdWJWZWN0b3JzKGMsIGEpO1xuXHRcdF92YXAuc3ViVmVjdG9ycyhwLCBhKTtcblx0XHRjb25zdCBkMSA9IF92YWIuZG90KF92YXApO1xuXHRcdGNvbnN0IGQyID0gX3ZhYy5kb3QoX3ZhcCk7XG5cdFx0aWYgKGQxIDw9IDAgJiYgZDIgPD0gMCkge1xuXHRcdFx0Ly8gdmVydGV4IHJlZ2lvbiBvZiBBOyBiYXJ5Y2VudHJpYyBjb29yZHMgKDEsIDAsIDApXG5cdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoYSk7XG5cdFx0fVxuXHRcdF92YnAuc3ViVmVjdG9ycyhwLCBiKTtcblx0XHRjb25zdCBkMyA9IF92YWIuZG90KF92YnApO1xuXHRcdGNvbnN0IGQ0ID0gX3ZhYy5kb3QoX3ZicCk7XG5cdFx0aWYgKGQzID49IDAgJiYgZDQgPD0gZDMpIHtcblx0XHRcdC8vIHZlcnRleCByZWdpb24gb2YgQjsgYmFyeWNlbnRyaWMgY29vcmRzICgwLCAxLCAwKVxuXHRcdFx0cmV0dXJuIHRhcmdldC5jb3B5KGIpO1xuXHRcdH1cblx0XHRjb25zdCB2YyA9IGQxICogZDQgLSBkMyAqIGQyO1xuXHRcdGlmICh2YyA8PSAwICYmIGQxID49IDAgJiYgZDMgPD0gMCkge1xuXHRcdFx0diA9IGQxIC8gKGQxIC0gZDMpO1xuXHRcdFx0Ly8gZWRnZSByZWdpb24gb2YgQUI7IGJhcnljZW50cmljIGNvb3JkcyAoMS12LCB2LCAwKVxuXHRcdFx0cmV0dXJuIHRhcmdldC5jb3B5KGEpLmFkZFNjYWxlZFZlY3RvcihfdmFiLCB2KTtcblx0XHR9XG5cdFx0X3ZjcC5zdWJWZWN0b3JzKHAsIGMpO1xuXHRcdGNvbnN0IGQ1ID0gX3ZhYi5kb3QoX3ZjcCk7XG5cdFx0Y29uc3QgZDYgPSBfdmFjLmRvdChfdmNwKTtcblx0XHRpZiAoZDYgPj0gMCAmJiBkNSA8PSBkNikge1xuXHRcdFx0Ly8gdmVydGV4IHJlZ2lvbiBvZiBDOyBiYXJ5Y2VudHJpYyBjb29yZHMgKDAsIDAsIDEpXG5cdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoYyk7XG5cdFx0fVxuXHRcdGNvbnN0IHZiID0gZDUgKiBkMiAtIGQxICogZDY7XG5cdFx0aWYgKHZiIDw9IDAgJiYgZDIgPj0gMCAmJiBkNiA8PSAwKSB7XG5cdFx0XHR3ID0gZDIgLyAoZDIgLSBkNik7XG5cdFx0XHQvLyBlZGdlIHJlZ2lvbiBvZiBBQzsgYmFyeWNlbnRyaWMgY29vcmRzICgxLXcsIDAsIHcpXG5cdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoYSkuYWRkU2NhbGVkVmVjdG9yKF92YWMsIHcpO1xuXHRcdH1cblx0XHRjb25zdCB2YSA9IGQzICogZDYgLSBkNSAqIGQ0O1xuXHRcdGlmICh2YSA8PSAwICYmIGQ0IC0gZDMgPj0gMCAmJiBkNSAtIGQ2ID49IDApIHtcblx0XHRcdF92YmMuc3ViVmVjdG9ycyhjLCBiKTtcblx0XHRcdHcgPSAoZDQgLSBkMykgLyAoZDQgLSBkMyArIChkNSAtIGQ2KSk7XG5cdFx0XHQvLyBlZGdlIHJlZ2lvbiBvZiBCQzsgYmFyeWNlbnRyaWMgY29vcmRzICgwLCAxLXcsIHcpXG5cdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoYikuYWRkU2NhbGVkVmVjdG9yKF92YmMsIHcpOyAvLyBlZGdlIHJlZ2lvbiBvZiBCQ1xuXHRcdH1cblxuXHRcdC8vIGZhY2UgcmVnaW9uXG5cdFx0Y29uc3QgZGVub20gPSAxIC8gKHZhICsgdmIgKyB2Yyk7XG5cdFx0Ly8gdSA9IHZhICogZGVub21cblx0XHR2ID0gdmIgKiBkZW5vbTtcblx0XHR3ID0gdmMgKiBkZW5vbTtcblx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoYSkuYWRkU2NhbGVkVmVjdG9yKF92YWIsIHYpLmFkZFNjYWxlZFZlY3RvcihfdmFjLCB3KTtcblx0fVxuXHRlcXVhbHModHJpYW5nbGUpIHtcblx0XHRyZXR1cm4gdHJpYW5nbGUuYS5lcXVhbHModGhpcy5hKSAmJiB0cmlhbmdsZS5iLmVxdWFscyh0aGlzLmIpICYmIHRyaWFuZ2xlLmMuZXF1YWxzKHRoaXMuYyk7XG5cdH1cbn1cblxubGV0IG1hdGVyaWFsSWQgPSAwO1xuY2xhc3MgTWF0ZXJpYWwgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXIge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuaXNNYXRlcmlhbCA9IHRydWU7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdpZCcsIHtcblx0XHRcdHZhbHVlOiBtYXRlcmlhbElkKytcblx0XHR9KTtcblx0XHR0aGlzLnV1aWQgPSBnZW5lcmF0ZVVVSUQoKTtcblx0XHR0aGlzLm5hbWUgPSAnJztcblx0XHR0aGlzLnR5cGUgPSAnTWF0ZXJpYWwnO1xuXHRcdHRoaXMuYmxlbmRpbmcgPSBOb3JtYWxCbGVuZGluZztcblx0XHR0aGlzLnNpZGUgPSBGcm9udFNpZGU7XG5cdFx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBmYWxzZTtcblx0XHR0aGlzLm9wYWNpdHkgPSAxO1xuXHRcdHRoaXMudHJhbnNwYXJlbnQgPSBmYWxzZTtcblx0XHR0aGlzLmJsZW5kU3JjID0gU3JjQWxwaGFGYWN0b3I7XG5cdFx0dGhpcy5ibGVuZERzdCA9IE9uZU1pbnVzU3JjQWxwaGFGYWN0b3I7XG5cdFx0dGhpcy5ibGVuZEVxdWF0aW9uID0gQWRkRXF1YXRpb247XG5cdFx0dGhpcy5ibGVuZFNyY0FscGhhID0gbnVsbDtcblx0XHR0aGlzLmJsZW5kRHN0QWxwaGEgPSBudWxsO1xuXHRcdHRoaXMuYmxlbmRFcXVhdGlvbkFscGhhID0gbnVsbDtcblx0XHR0aGlzLmRlcHRoRnVuYyA9IExlc3NFcXVhbERlcHRoO1xuXHRcdHRoaXMuZGVwdGhUZXN0ID0gdHJ1ZTtcblx0XHR0aGlzLmRlcHRoV3JpdGUgPSB0cnVlO1xuXHRcdHRoaXMuc3RlbmNpbFdyaXRlTWFzayA9IDB4ZmY7XG5cdFx0dGhpcy5zdGVuY2lsRnVuYyA9IEFsd2F5c1N0ZW5jaWxGdW5jO1xuXHRcdHRoaXMuc3RlbmNpbFJlZiA9IDA7XG5cdFx0dGhpcy5zdGVuY2lsRnVuY01hc2sgPSAweGZmO1xuXHRcdHRoaXMuc3RlbmNpbEZhaWwgPSBLZWVwU3RlbmNpbE9wO1xuXHRcdHRoaXMuc3RlbmNpbFpGYWlsID0gS2VlcFN0ZW5jaWxPcDtcblx0XHR0aGlzLnN0ZW5jaWxaUGFzcyA9IEtlZXBTdGVuY2lsT3A7XG5cdFx0dGhpcy5zdGVuY2lsV3JpdGUgPSBmYWxzZTtcblx0XHR0aGlzLmNsaXBwaW5nUGxhbmVzID0gbnVsbDtcblx0XHR0aGlzLmNsaXBJbnRlcnNlY3Rpb24gPSBmYWxzZTtcblx0XHR0aGlzLmNsaXBTaGFkb3dzID0gZmFsc2U7XG5cdFx0dGhpcy5zaGFkb3dTaWRlID0gbnVsbDtcblx0XHR0aGlzLmNvbG9yV3JpdGUgPSB0cnVlO1xuXHRcdHRoaXMucHJlY2lzaW9uID0gbnVsbDsgLy8gb3ZlcnJpZGUgdGhlIHJlbmRlcmVyJ3MgZGVmYXVsdCBwcmVjaXNpb24gZm9yIHRoaXMgbWF0ZXJpYWxcblxuXHRcdHRoaXMucG9seWdvbk9mZnNldCA9IGZhbHNlO1xuXHRcdHRoaXMucG9seWdvbk9mZnNldEZhY3RvciA9IDA7XG5cdFx0dGhpcy5wb2x5Z29uT2Zmc2V0VW5pdHMgPSAwO1xuXHRcdHRoaXMuZGl0aGVyaW5nID0gZmFsc2U7XG5cdFx0dGhpcy5hbHBoYVRvQ292ZXJhZ2UgPSBmYWxzZTtcblx0XHR0aGlzLnByZW11bHRpcGxpZWRBbHBoYSA9IGZhbHNlO1xuXHRcdHRoaXMudmlzaWJsZSA9IHRydWU7XG5cdFx0dGhpcy50b25lTWFwcGVkID0gdHJ1ZTtcblx0XHR0aGlzLnVzZXJEYXRhID0ge307XG5cdFx0dGhpcy52ZXJzaW9uID0gMDtcblx0XHR0aGlzLl9hbHBoYVRlc3QgPSAwO1xuXHR9XG5cdGdldCBhbHBoYVRlc3QoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FscGhhVGVzdDtcblx0fVxuXHRzZXQgYWxwaGFUZXN0KHZhbHVlKSB7XG5cdFx0aWYgKHRoaXMuX2FscGhhVGVzdCA+IDAgIT09IHZhbHVlID4gMCkge1xuXHRcdFx0dGhpcy52ZXJzaW9uKys7XG5cdFx0fVxuXHRcdHRoaXMuX2FscGhhVGVzdCA9IHZhbHVlO1xuXHR9XG5cdG9uQnVpbGQoKSB7fVxuXHRvbkJlZm9yZVJlbmRlcigpIHt9XG5cdG9uQmVmb3JlQ29tcGlsZSgpIHt9XG5cdGN1c3RvbVByb2dyYW1DYWNoZUtleSgpIHtcblx0XHRyZXR1cm4gdGhpcy5vbkJlZm9yZUNvbXBpbGUudG9TdHJpbmcoKTtcblx0fVxuXHRzZXRWYWx1ZXModmFsdWVzKSB7XG5cdFx0aWYgKHZhbHVlcyA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cdFx0Zm9yIChjb25zdCBrZXkgaW4gdmFsdWVzKSB7XG5cdFx0XHRjb25zdCBuZXdWYWx1ZSA9IHZhbHVlc1trZXldO1xuXHRcdFx0aWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5NYXRlcmlhbDogXFwnJyArIGtleSArICdcXCcgcGFyYW1ldGVyIGlzIHVuZGVmaW5lZC4nKTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzW2tleV07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS4nICsgdGhpcy50eXBlICsgJzogXFwnJyArIGtleSArICdcXCcgaXMgbm90IGEgcHJvcGVydHkgb2YgdGhpcyBtYXRlcmlhbC4nKTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlICYmIGN1cnJlbnRWYWx1ZS5pc0NvbG9yKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZS5zZXQobmV3VmFsdWUpO1xuXHRcdFx0fSBlbHNlIGlmIChjdXJyZW50VmFsdWUgJiYgY3VycmVudFZhbHVlLmlzVmVjdG9yMyAmJiBuZXdWYWx1ZSAmJiBuZXdWYWx1ZS5pc1ZlY3RvcjMpIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlLmNvcHkobmV3VmFsdWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpc1trZXldID0gbmV3VmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHRvSlNPTihtZXRhKSB7XG5cdFx0Y29uc3QgaXNSb290T2JqZWN0ID0gbWV0YSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBtZXRhID09PSAnc3RyaW5nJztcblx0XHRpZiAoaXNSb290T2JqZWN0KSB7XG5cdFx0XHRtZXRhID0ge1xuXHRcdFx0XHR0ZXh0dXJlczoge30sXG5cdFx0XHRcdGltYWdlczoge31cblx0XHRcdH07XG5cdFx0fVxuXHRcdGNvbnN0IGRhdGEgPSB7XG5cdFx0XHRtZXRhZGF0YToge1xuXHRcdFx0XHR2ZXJzaW9uOiA0LjUsXG5cdFx0XHRcdHR5cGU6ICdNYXRlcmlhbCcsXG5cdFx0XHRcdGdlbmVyYXRvcjogJ01hdGVyaWFsLnRvSlNPTidcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Ly8gc3RhbmRhcmQgTWF0ZXJpYWwgc2VyaWFsaXphdGlvblxuXHRcdGRhdGEudXVpZCA9IHRoaXMudXVpZDtcblx0XHRkYXRhLnR5cGUgPSB0aGlzLnR5cGU7XG5cdFx0aWYgKHRoaXMubmFtZSAhPT0gJycpIGRhdGEubmFtZSA9IHRoaXMubmFtZTtcblx0XHRpZiAodGhpcy5jb2xvciAmJiB0aGlzLmNvbG9yLmlzQ29sb3IpIGRhdGEuY29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpO1xuXHRcdGlmICh0aGlzLnJvdWdobmVzcyAhPT0gdW5kZWZpbmVkKSBkYXRhLnJvdWdobmVzcyA9IHRoaXMucm91Z2huZXNzO1xuXHRcdGlmICh0aGlzLm1ldGFsbmVzcyAhPT0gdW5kZWZpbmVkKSBkYXRhLm1ldGFsbmVzcyA9IHRoaXMubWV0YWxuZXNzO1xuXHRcdGlmICh0aGlzLnNoZWVuICE9PSB1bmRlZmluZWQpIGRhdGEuc2hlZW4gPSB0aGlzLnNoZWVuO1xuXHRcdGlmICh0aGlzLnNoZWVuQ29sb3IgJiYgdGhpcy5zaGVlbkNvbG9yLmlzQ29sb3IpIGRhdGEuc2hlZW5Db2xvciA9IHRoaXMuc2hlZW5Db2xvci5nZXRIZXgoKTtcblx0XHRpZiAodGhpcy5zaGVlblJvdWdobmVzcyAhPT0gdW5kZWZpbmVkKSBkYXRhLnNoZWVuUm91Z2huZXNzID0gdGhpcy5zaGVlblJvdWdobmVzcztcblx0XHRpZiAodGhpcy5lbWlzc2l2ZSAmJiB0aGlzLmVtaXNzaXZlLmlzQ29sb3IpIGRhdGEuZW1pc3NpdmUgPSB0aGlzLmVtaXNzaXZlLmdldEhleCgpO1xuXHRcdGlmICh0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ICYmIHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgIT09IDEpIGRhdGEuZW1pc3NpdmVJbnRlbnNpdHkgPSB0aGlzLmVtaXNzaXZlSW50ZW5zaXR5O1xuXHRcdGlmICh0aGlzLnNwZWN1bGFyICYmIHRoaXMuc3BlY3VsYXIuaXNDb2xvcikgZGF0YS5zcGVjdWxhciA9IHRoaXMuc3BlY3VsYXIuZ2V0SGV4KCk7XG5cdFx0aWYgKHRoaXMuc3BlY3VsYXJJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCkgZGF0YS5zcGVjdWxhckludGVuc2l0eSA9IHRoaXMuc3BlY3VsYXJJbnRlbnNpdHk7XG5cdFx0aWYgKHRoaXMuc3BlY3VsYXJDb2xvciAmJiB0aGlzLnNwZWN1bGFyQ29sb3IuaXNDb2xvcikgZGF0YS5zcGVjdWxhckNvbG9yID0gdGhpcy5zcGVjdWxhckNvbG9yLmdldEhleCgpO1xuXHRcdGlmICh0aGlzLnNoaW5pbmVzcyAhPT0gdW5kZWZpbmVkKSBkYXRhLnNoaW5pbmVzcyA9IHRoaXMuc2hpbmluZXNzO1xuXHRcdGlmICh0aGlzLmNsZWFyY29hdCAhPT0gdW5kZWZpbmVkKSBkYXRhLmNsZWFyY29hdCA9IHRoaXMuY2xlYXJjb2F0O1xuXHRcdGlmICh0aGlzLmNsZWFyY29hdFJvdWdobmVzcyAhPT0gdW5kZWZpbmVkKSBkYXRhLmNsZWFyY29hdFJvdWdobmVzcyA9IHRoaXMuY2xlYXJjb2F0Um91Z2huZXNzO1xuXHRcdGlmICh0aGlzLmNsZWFyY29hdE1hcCAmJiB0aGlzLmNsZWFyY29hdE1hcC5pc1RleHR1cmUpIHtcblx0XHRcdGRhdGEuY2xlYXJjb2F0TWFwID0gdGhpcy5jbGVhcmNvYXRNYXAudG9KU09OKG1ldGEpLnV1aWQ7XG5cdFx0fVxuXHRcdGlmICh0aGlzLmNsZWFyY29hdFJvdWdobmVzc01hcCAmJiB0aGlzLmNsZWFyY29hdFJvdWdobmVzc01hcC5pc1RleHR1cmUpIHtcblx0XHRcdGRhdGEuY2xlYXJjb2F0Um91Z2huZXNzTWFwID0gdGhpcy5jbGVhcmNvYXRSb3VnaG5lc3NNYXAudG9KU09OKG1ldGEpLnV1aWQ7XG5cdFx0fVxuXHRcdGlmICh0aGlzLmNsZWFyY29hdE5vcm1hbE1hcCAmJiB0aGlzLmNsZWFyY29hdE5vcm1hbE1hcC5pc1RleHR1cmUpIHtcblx0XHRcdGRhdGEuY2xlYXJjb2F0Tm9ybWFsTWFwID0gdGhpcy5jbGVhcmNvYXROb3JtYWxNYXAudG9KU09OKG1ldGEpLnV1aWQ7XG5cdFx0XHRkYXRhLmNsZWFyY29hdE5vcm1hbFNjYWxlID0gdGhpcy5jbGVhcmNvYXROb3JtYWxTY2FsZS50b0FycmF5KCk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLmlyaWRlc2NlbmNlICE9PSB1bmRlZmluZWQpIGRhdGEuaXJpZGVzY2VuY2UgPSB0aGlzLmlyaWRlc2NlbmNlO1xuXHRcdGlmICh0aGlzLmlyaWRlc2NlbmNlSU9SICE9PSB1bmRlZmluZWQpIGRhdGEuaXJpZGVzY2VuY2VJT1IgPSB0aGlzLmlyaWRlc2NlbmNlSU9SO1xuXHRcdGlmICh0aGlzLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2UgIT09IHVuZGVmaW5lZCkgZGF0YS5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlID0gdGhpcy5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlO1xuXHRcdGlmICh0aGlzLmlyaWRlc2NlbmNlTWFwICYmIHRoaXMuaXJpZGVzY2VuY2VNYXAuaXNUZXh0dXJlKSB7XG5cdFx0XHRkYXRhLmlyaWRlc2NlbmNlTWFwID0gdGhpcy5pcmlkZXNjZW5jZU1hcC50b0pTT04obWV0YSkudXVpZDtcblx0XHR9XG5cdFx0aWYgKHRoaXMuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAgJiYgdGhpcy5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcC5pc1RleHR1cmUpIHtcblx0XHRcdGRhdGEuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAgPSB0aGlzLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwLnRvSlNPTihtZXRhKS51dWlkO1xuXHRcdH1cblx0XHRpZiAodGhpcy5tYXAgJiYgdGhpcy5tYXAuaXNUZXh0dXJlKSBkYXRhLm1hcCA9IHRoaXMubWFwLnRvSlNPTihtZXRhKS51dWlkO1xuXHRcdGlmICh0aGlzLm1hdGNhcCAmJiB0aGlzLm1hdGNhcC5pc1RleHR1cmUpIGRhdGEubWF0Y2FwID0gdGhpcy5tYXRjYXAudG9KU09OKG1ldGEpLnV1aWQ7XG5cdFx0aWYgKHRoaXMuYWxwaGFNYXAgJiYgdGhpcy5hbHBoYU1hcC5pc1RleHR1cmUpIGRhdGEuYWxwaGFNYXAgPSB0aGlzLmFscGhhTWFwLnRvSlNPTihtZXRhKS51dWlkO1xuXHRcdGlmICh0aGlzLmxpZ2h0TWFwICYmIHRoaXMubGlnaHRNYXAuaXNUZXh0dXJlKSB7XG5cdFx0XHRkYXRhLmxpZ2h0TWFwID0gdGhpcy5saWdodE1hcC50b0pTT04obWV0YSkudXVpZDtcblx0XHRcdGRhdGEubGlnaHRNYXBJbnRlbnNpdHkgPSB0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5O1xuXHRcdH1cblx0XHRpZiAodGhpcy5hb01hcCAmJiB0aGlzLmFvTWFwLmlzVGV4dHVyZSkge1xuXHRcdFx0ZGF0YS5hb01hcCA9IHRoaXMuYW9NYXAudG9KU09OKG1ldGEpLnV1aWQ7XG5cdFx0XHRkYXRhLmFvTWFwSW50ZW5zaXR5ID0gdGhpcy5hb01hcEludGVuc2l0eTtcblx0XHR9XG5cdFx0aWYgKHRoaXMuYnVtcE1hcCAmJiB0aGlzLmJ1bXBNYXAuaXNUZXh0dXJlKSB7XG5cdFx0XHRkYXRhLmJ1bXBNYXAgPSB0aGlzLmJ1bXBNYXAudG9KU09OKG1ldGEpLnV1aWQ7XG5cdFx0XHRkYXRhLmJ1bXBTY2FsZSA9IHRoaXMuYnVtcFNjYWxlO1xuXHRcdH1cblx0XHRpZiAodGhpcy5ub3JtYWxNYXAgJiYgdGhpcy5ub3JtYWxNYXAuaXNUZXh0dXJlKSB7XG5cdFx0XHRkYXRhLm5vcm1hbE1hcCA9IHRoaXMubm9ybWFsTWFwLnRvSlNPTihtZXRhKS51dWlkO1xuXHRcdFx0ZGF0YS5ub3JtYWxNYXBUeXBlID0gdGhpcy5ub3JtYWxNYXBUeXBlO1xuXHRcdFx0ZGF0YS5ub3JtYWxTY2FsZSA9IHRoaXMubm9ybWFsU2NhbGUudG9BcnJheSgpO1xuXHRcdH1cblx0XHRpZiAodGhpcy5kaXNwbGFjZW1lbnRNYXAgJiYgdGhpcy5kaXNwbGFjZW1lbnRNYXAuaXNUZXh0dXJlKSB7XG5cdFx0XHRkYXRhLmRpc3BsYWNlbWVudE1hcCA9IHRoaXMuZGlzcGxhY2VtZW50TWFwLnRvSlNPTihtZXRhKS51dWlkO1xuXHRcdFx0ZGF0YS5kaXNwbGFjZW1lbnRTY2FsZSA9IHRoaXMuZGlzcGxhY2VtZW50U2NhbGU7XG5cdFx0XHRkYXRhLmRpc3BsYWNlbWVudEJpYXMgPSB0aGlzLmRpc3BsYWNlbWVudEJpYXM7XG5cdFx0fVxuXHRcdGlmICh0aGlzLnJvdWdobmVzc01hcCAmJiB0aGlzLnJvdWdobmVzc01hcC5pc1RleHR1cmUpIGRhdGEucm91Z2huZXNzTWFwID0gdGhpcy5yb3VnaG5lc3NNYXAudG9KU09OKG1ldGEpLnV1aWQ7XG5cdFx0aWYgKHRoaXMubWV0YWxuZXNzTWFwICYmIHRoaXMubWV0YWxuZXNzTWFwLmlzVGV4dHVyZSkgZGF0YS5tZXRhbG5lc3NNYXAgPSB0aGlzLm1ldGFsbmVzc01hcC50b0pTT04obWV0YSkudXVpZDtcblx0XHRpZiAodGhpcy5lbWlzc2l2ZU1hcCAmJiB0aGlzLmVtaXNzaXZlTWFwLmlzVGV4dHVyZSkgZGF0YS5lbWlzc2l2ZU1hcCA9IHRoaXMuZW1pc3NpdmVNYXAudG9KU09OKG1ldGEpLnV1aWQ7XG5cdFx0aWYgKHRoaXMuc3BlY3VsYXJNYXAgJiYgdGhpcy5zcGVjdWxhck1hcC5pc1RleHR1cmUpIGRhdGEuc3BlY3VsYXJNYXAgPSB0aGlzLnNwZWN1bGFyTWFwLnRvSlNPTihtZXRhKS51dWlkO1xuXHRcdGlmICh0aGlzLnNwZWN1bGFySW50ZW5zaXR5TWFwICYmIHRoaXMuc3BlY3VsYXJJbnRlbnNpdHlNYXAuaXNUZXh0dXJlKSBkYXRhLnNwZWN1bGFySW50ZW5zaXR5TWFwID0gdGhpcy5zcGVjdWxhckludGVuc2l0eU1hcC50b0pTT04obWV0YSkudXVpZDtcblx0XHRpZiAodGhpcy5zcGVjdWxhckNvbG9yTWFwICYmIHRoaXMuc3BlY3VsYXJDb2xvck1hcC5pc1RleHR1cmUpIGRhdGEuc3BlY3VsYXJDb2xvck1hcCA9IHRoaXMuc3BlY3VsYXJDb2xvck1hcC50b0pTT04obWV0YSkudXVpZDtcblx0XHRpZiAodGhpcy5lbnZNYXAgJiYgdGhpcy5lbnZNYXAuaXNUZXh0dXJlKSB7XG5cdFx0XHRkYXRhLmVudk1hcCA9IHRoaXMuZW52TWFwLnRvSlNPTihtZXRhKS51dWlkO1xuXHRcdFx0aWYgKHRoaXMuY29tYmluZSAhPT0gdW5kZWZpbmVkKSBkYXRhLmNvbWJpbmUgPSB0aGlzLmNvbWJpbmU7XG5cdFx0fVxuXHRcdGlmICh0aGlzLmVudk1hcEludGVuc2l0eSAhPT0gdW5kZWZpbmVkKSBkYXRhLmVudk1hcEludGVuc2l0eSA9IHRoaXMuZW52TWFwSW50ZW5zaXR5O1xuXHRcdGlmICh0aGlzLnJlZmxlY3Rpdml0eSAhPT0gdW5kZWZpbmVkKSBkYXRhLnJlZmxlY3Rpdml0eSA9IHRoaXMucmVmbGVjdGl2aXR5O1xuXHRcdGlmICh0aGlzLnJlZnJhY3Rpb25SYXRpbyAhPT0gdW5kZWZpbmVkKSBkYXRhLnJlZnJhY3Rpb25SYXRpbyA9IHRoaXMucmVmcmFjdGlvblJhdGlvO1xuXHRcdGlmICh0aGlzLmdyYWRpZW50TWFwICYmIHRoaXMuZ3JhZGllbnRNYXAuaXNUZXh0dXJlKSB7XG5cdFx0XHRkYXRhLmdyYWRpZW50TWFwID0gdGhpcy5ncmFkaWVudE1hcC50b0pTT04obWV0YSkudXVpZDtcblx0XHR9XG5cdFx0aWYgKHRoaXMudHJhbnNtaXNzaW9uICE9PSB1bmRlZmluZWQpIGRhdGEudHJhbnNtaXNzaW9uID0gdGhpcy50cmFuc21pc3Npb247XG5cdFx0aWYgKHRoaXMudHJhbnNtaXNzaW9uTWFwICYmIHRoaXMudHJhbnNtaXNzaW9uTWFwLmlzVGV4dHVyZSkgZGF0YS50cmFuc21pc3Npb25NYXAgPSB0aGlzLnRyYW5zbWlzc2lvbk1hcC50b0pTT04obWV0YSkudXVpZDtcblx0XHRpZiAodGhpcy50aGlja25lc3MgIT09IHVuZGVmaW5lZCkgZGF0YS50aGlja25lc3MgPSB0aGlzLnRoaWNrbmVzcztcblx0XHRpZiAodGhpcy50aGlja25lc3NNYXAgJiYgdGhpcy50aGlja25lc3NNYXAuaXNUZXh0dXJlKSBkYXRhLnRoaWNrbmVzc01hcCA9IHRoaXMudGhpY2tuZXNzTWFwLnRvSlNPTihtZXRhKS51dWlkO1xuXHRcdGlmICh0aGlzLmF0dGVudWF0aW9uRGlzdGFuY2UgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmF0dGVudWF0aW9uRGlzdGFuY2UgIT09IEluZmluaXR5KSBkYXRhLmF0dGVudWF0aW9uRGlzdGFuY2UgPSB0aGlzLmF0dGVudWF0aW9uRGlzdGFuY2U7XG5cdFx0aWYgKHRoaXMuYXR0ZW51YXRpb25Db2xvciAhPT0gdW5kZWZpbmVkKSBkYXRhLmF0dGVudWF0aW9uQ29sb3IgPSB0aGlzLmF0dGVudWF0aW9uQ29sb3IuZ2V0SGV4KCk7XG5cdFx0aWYgKHRoaXMuc2l6ZSAhPT0gdW5kZWZpbmVkKSBkYXRhLnNpemUgPSB0aGlzLnNpemU7XG5cdFx0aWYgKHRoaXMuc2hhZG93U2lkZSAhPT0gbnVsbCkgZGF0YS5zaGFkb3dTaWRlID0gdGhpcy5zaGFkb3dTaWRlO1xuXHRcdGlmICh0aGlzLnNpemVBdHRlbnVhdGlvbiAhPT0gdW5kZWZpbmVkKSBkYXRhLnNpemVBdHRlbnVhdGlvbiA9IHRoaXMuc2l6ZUF0dGVudWF0aW9uO1xuXHRcdGlmICh0aGlzLmJsZW5kaW5nICE9PSBOb3JtYWxCbGVuZGluZykgZGF0YS5ibGVuZGluZyA9IHRoaXMuYmxlbmRpbmc7XG5cdFx0aWYgKHRoaXMuc2lkZSAhPT0gRnJvbnRTaWRlKSBkYXRhLnNpZGUgPSB0aGlzLnNpZGU7XG5cdFx0aWYgKHRoaXMudmVydGV4Q29sb3JzKSBkYXRhLnZlcnRleENvbG9ycyA9IHRydWU7XG5cdFx0aWYgKHRoaXMub3BhY2l0eSA8IDEpIGRhdGEub3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcblx0XHRpZiAodGhpcy50cmFuc3BhcmVudCA9PT0gdHJ1ZSkgZGF0YS50cmFuc3BhcmVudCA9IHRoaXMudHJhbnNwYXJlbnQ7XG5cdFx0ZGF0YS5kZXB0aEZ1bmMgPSB0aGlzLmRlcHRoRnVuYztcblx0XHRkYXRhLmRlcHRoVGVzdCA9IHRoaXMuZGVwdGhUZXN0O1xuXHRcdGRhdGEuZGVwdGhXcml0ZSA9IHRoaXMuZGVwdGhXcml0ZTtcblx0XHRkYXRhLmNvbG9yV3JpdGUgPSB0aGlzLmNvbG9yV3JpdGU7XG5cdFx0ZGF0YS5zdGVuY2lsV3JpdGUgPSB0aGlzLnN0ZW5jaWxXcml0ZTtcblx0XHRkYXRhLnN0ZW5jaWxXcml0ZU1hc2sgPSB0aGlzLnN0ZW5jaWxXcml0ZU1hc2s7XG5cdFx0ZGF0YS5zdGVuY2lsRnVuYyA9IHRoaXMuc3RlbmNpbEZ1bmM7XG5cdFx0ZGF0YS5zdGVuY2lsUmVmID0gdGhpcy5zdGVuY2lsUmVmO1xuXHRcdGRhdGEuc3RlbmNpbEZ1bmNNYXNrID0gdGhpcy5zdGVuY2lsRnVuY01hc2s7XG5cdFx0ZGF0YS5zdGVuY2lsRmFpbCA9IHRoaXMuc3RlbmNpbEZhaWw7XG5cdFx0ZGF0YS5zdGVuY2lsWkZhaWwgPSB0aGlzLnN0ZW5jaWxaRmFpbDtcblx0XHRkYXRhLnN0ZW5jaWxaUGFzcyA9IHRoaXMuc3RlbmNpbFpQYXNzO1xuXG5cdFx0Ly8gcm90YXRpb24gKFNwcml0ZU1hdGVyaWFsKVxuXHRcdGlmICh0aGlzLnJvdGF0aW9uICE9PSB1bmRlZmluZWQgJiYgdGhpcy5yb3RhdGlvbiAhPT0gMCkgZGF0YS5yb3RhdGlvbiA9IHRoaXMucm90YXRpb247XG5cdFx0aWYgKHRoaXMucG9seWdvbk9mZnNldCA9PT0gdHJ1ZSkgZGF0YS5wb2x5Z29uT2Zmc2V0ID0gdHJ1ZTtcblx0XHRpZiAodGhpcy5wb2x5Z29uT2Zmc2V0RmFjdG9yICE9PSAwKSBkYXRhLnBvbHlnb25PZmZzZXRGYWN0b3IgPSB0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3I7XG5cdFx0aWYgKHRoaXMucG9seWdvbk9mZnNldFVuaXRzICE9PSAwKSBkYXRhLnBvbHlnb25PZmZzZXRVbml0cyA9IHRoaXMucG9seWdvbk9mZnNldFVuaXRzO1xuXHRcdGlmICh0aGlzLmxpbmV3aWR0aCAhPT0gdW5kZWZpbmVkICYmIHRoaXMubGluZXdpZHRoICE9PSAxKSBkYXRhLmxpbmV3aWR0aCA9IHRoaXMubGluZXdpZHRoO1xuXHRcdGlmICh0aGlzLmRhc2hTaXplICE9PSB1bmRlZmluZWQpIGRhdGEuZGFzaFNpemUgPSB0aGlzLmRhc2hTaXplO1xuXHRcdGlmICh0aGlzLmdhcFNpemUgIT09IHVuZGVmaW5lZCkgZGF0YS5nYXBTaXplID0gdGhpcy5nYXBTaXplO1xuXHRcdGlmICh0aGlzLnNjYWxlICE9PSB1bmRlZmluZWQpIGRhdGEuc2NhbGUgPSB0aGlzLnNjYWxlO1xuXHRcdGlmICh0aGlzLmRpdGhlcmluZyA9PT0gdHJ1ZSkgZGF0YS5kaXRoZXJpbmcgPSB0cnVlO1xuXHRcdGlmICh0aGlzLmFscGhhVGVzdCA+IDApIGRhdGEuYWxwaGFUZXN0ID0gdGhpcy5hbHBoYVRlc3Q7XG5cdFx0aWYgKHRoaXMuYWxwaGFUb0NvdmVyYWdlID09PSB0cnVlKSBkYXRhLmFscGhhVG9Db3ZlcmFnZSA9IHRoaXMuYWxwaGFUb0NvdmVyYWdlO1xuXHRcdGlmICh0aGlzLnByZW11bHRpcGxpZWRBbHBoYSA9PT0gdHJ1ZSkgZGF0YS5wcmVtdWx0aXBsaWVkQWxwaGEgPSB0aGlzLnByZW11bHRpcGxpZWRBbHBoYTtcblx0XHRpZiAodGhpcy53aXJlZnJhbWUgPT09IHRydWUpIGRhdGEud2lyZWZyYW1lID0gdGhpcy53aXJlZnJhbWU7XG5cdFx0aWYgKHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID4gMSkgZGF0YS53aXJlZnJhbWVMaW5ld2lkdGggPSB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aDtcblx0XHRpZiAodGhpcy53aXJlZnJhbWVMaW5lY2FwICE9PSAncm91bmQnKSBkYXRhLndpcmVmcmFtZUxpbmVjYXAgPSB0aGlzLndpcmVmcmFtZUxpbmVjYXA7XG5cdFx0aWYgKHRoaXMud2lyZWZyYW1lTGluZWpvaW4gIT09ICdyb3VuZCcpIGRhdGEud2lyZWZyYW1lTGluZWpvaW4gPSB0aGlzLndpcmVmcmFtZUxpbmVqb2luO1xuXHRcdGlmICh0aGlzLmZsYXRTaGFkaW5nID09PSB0cnVlKSBkYXRhLmZsYXRTaGFkaW5nID0gdGhpcy5mbGF0U2hhZGluZztcblx0XHRpZiAodGhpcy52aXNpYmxlID09PSBmYWxzZSkgZGF0YS52aXNpYmxlID0gZmFsc2U7XG5cdFx0aWYgKHRoaXMudG9uZU1hcHBlZCA9PT0gZmFsc2UpIGRhdGEudG9uZU1hcHBlZCA9IGZhbHNlO1xuXHRcdGlmICh0aGlzLmZvZyA9PT0gZmFsc2UpIGRhdGEuZm9nID0gZmFsc2U7XG5cdFx0aWYgKEpTT04uc3RyaW5naWZ5KHRoaXMudXNlckRhdGEpICE9PSAne30nKSBkYXRhLnVzZXJEYXRhID0gdGhpcy51c2VyRGF0YTtcblxuXHRcdC8vIFRPRE86IENvcGllZCBmcm9tIE9iamVjdDNELnRvSlNPTlxuXG5cdFx0ZnVuY3Rpb24gZXh0cmFjdEZyb21DYWNoZShjYWNoZSkge1xuXHRcdFx0Y29uc3QgdmFsdWVzID0gW107XG5cdFx0XHRmb3IgKGNvbnN0IGtleSBpbiBjYWNoZSkge1xuXHRcdFx0XHRjb25zdCBkYXRhID0gY2FjaGVba2V5XTtcblx0XHRcdFx0ZGVsZXRlIGRhdGEubWV0YWRhdGE7XG5cdFx0XHRcdHZhbHVlcy5wdXNoKGRhdGEpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHR9XG5cdFx0aWYgKGlzUm9vdE9iamVjdCkge1xuXHRcdFx0Y29uc3QgdGV4dHVyZXMgPSBleHRyYWN0RnJvbUNhY2hlKG1ldGEudGV4dHVyZXMpO1xuXHRcdFx0Y29uc3QgaW1hZ2VzID0gZXh0cmFjdEZyb21DYWNoZShtZXRhLmltYWdlcyk7XG5cdFx0XHRpZiAodGV4dHVyZXMubGVuZ3RoID4gMCkgZGF0YS50ZXh0dXJlcyA9IHRleHR1cmVzO1xuXHRcdFx0aWYgKGltYWdlcy5sZW5ndGggPiAwKSBkYXRhLmltYWdlcyA9IGltYWdlcztcblx0XHR9XG5cdFx0cmV0dXJuIGRhdGE7XG5cdH1cblx0Y2xvbmUoKSB7XG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKTtcblx0fVxuXHRjb3B5KHNvdXJjZSkge1xuXHRcdHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xuXHRcdHRoaXMuYmxlbmRpbmcgPSBzb3VyY2UuYmxlbmRpbmc7XG5cdFx0dGhpcy5zaWRlID0gc291cmNlLnNpZGU7XG5cdFx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBzb3VyY2UudmVydGV4Q29sb3JzO1xuXHRcdHRoaXMub3BhY2l0eSA9IHNvdXJjZS5vcGFjaXR5O1xuXHRcdHRoaXMudHJhbnNwYXJlbnQgPSBzb3VyY2UudHJhbnNwYXJlbnQ7XG5cdFx0dGhpcy5ibGVuZFNyYyA9IHNvdXJjZS5ibGVuZFNyYztcblx0XHR0aGlzLmJsZW5kRHN0ID0gc291cmNlLmJsZW5kRHN0O1xuXHRcdHRoaXMuYmxlbmRFcXVhdGlvbiA9IHNvdXJjZS5ibGVuZEVxdWF0aW9uO1xuXHRcdHRoaXMuYmxlbmRTcmNBbHBoYSA9IHNvdXJjZS5ibGVuZFNyY0FscGhhO1xuXHRcdHRoaXMuYmxlbmREc3RBbHBoYSA9IHNvdXJjZS5ibGVuZERzdEFscGhhO1xuXHRcdHRoaXMuYmxlbmRFcXVhdGlvbkFscGhhID0gc291cmNlLmJsZW5kRXF1YXRpb25BbHBoYTtcblx0XHR0aGlzLmRlcHRoRnVuYyA9IHNvdXJjZS5kZXB0aEZ1bmM7XG5cdFx0dGhpcy5kZXB0aFRlc3QgPSBzb3VyY2UuZGVwdGhUZXN0O1xuXHRcdHRoaXMuZGVwdGhXcml0ZSA9IHNvdXJjZS5kZXB0aFdyaXRlO1xuXHRcdHRoaXMuc3RlbmNpbFdyaXRlTWFzayA9IHNvdXJjZS5zdGVuY2lsV3JpdGVNYXNrO1xuXHRcdHRoaXMuc3RlbmNpbEZ1bmMgPSBzb3VyY2Uuc3RlbmNpbEZ1bmM7XG5cdFx0dGhpcy5zdGVuY2lsUmVmID0gc291cmNlLnN0ZW5jaWxSZWY7XG5cdFx0dGhpcy5zdGVuY2lsRnVuY01hc2sgPSBzb3VyY2Uuc3RlbmNpbEZ1bmNNYXNrO1xuXHRcdHRoaXMuc3RlbmNpbEZhaWwgPSBzb3VyY2Uuc3RlbmNpbEZhaWw7XG5cdFx0dGhpcy5zdGVuY2lsWkZhaWwgPSBzb3VyY2Uuc3RlbmNpbFpGYWlsO1xuXHRcdHRoaXMuc3RlbmNpbFpQYXNzID0gc291cmNlLnN0ZW5jaWxaUGFzcztcblx0XHR0aGlzLnN0ZW5jaWxXcml0ZSA9IHNvdXJjZS5zdGVuY2lsV3JpdGU7XG5cdFx0Y29uc3Qgc3JjUGxhbmVzID0gc291cmNlLmNsaXBwaW5nUGxhbmVzO1xuXHRcdGxldCBkc3RQbGFuZXMgPSBudWxsO1xuXHRcdGlmIChzcmNQbGFuZXMgIT09IG51bGwpIHtcblx0XHRcdGNvbnN0IG4gPSBzcmNQbGFuZXMubGVuZ3RoO1xuXHRcdFx0ZHN0UGxhbmVzID0gbmV3IEFycmF5KG4pO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgIT09IG47ICsraSkge1xuXHRcdFx0XHRkc3RQbGFuZXNbaV0gPSBzcmNQbGFuZXNbaV0uY2xvbmUoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5jbGlwcGluZ1BsYW5lcyA9IGRzdFBsYW5lcztcblx0XHR0aGlzLmNsaXBJbnRlcnNlY3Rpb24gPSBzb3VyY2UuY2xpcEludGVyc2VjdGlvbjtcblx0XHR0aGlzLmNsaXBTaGFkb3dzID0gc291cmNlLmNsaXBTaGFkb3dzO1xuXHRcdHRoaXMuc2hhZG93U2lkZSA9IHNvdXJjZS5zaGFkb3dTaWRlO1xuXHRcdHRoaXMuY29sb3JXcml0ZSA9IHNvdXJjZS5jb2xvcldyaXRlO1xuXHRcdHRoaXMucHJlY2lzaW9uID0gc291cmNlLnByZWNpc2lvbjtcblx0XHR0aGlzLnBvbHlnb25PZmZzZXQgPSBzb3VyY2UucG9seWdvbk9mZnNldDtcblx0XHR0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3IgPSBzb3VyY2UucG9seWdvbk9mZnNldEZhY3Rvcjtcblx0XHR0aGlzLnBvbHlnb25PZmZzZXRVbml0cyA9IHNvdXJjZS5wb2x5Z29uT2Zmc2V0VW5pdHM7XG5cdFx0dGhpcy5kaXRoZXJpbmcgPSBzb3VyY2UuZGl0aGVyaW5nO1xuXHRcdHRoaXMuYWxwaGFUZXN0ID0gc291cmNlLmFscGhhVGVzdDtcblx0XHR0aGlzLmFscGhhVG9Db3ZlcmFnZSA9IHNvdXJjZS5hbHBoYVRvQ292ZXJhZ2U7XG5cdFx0dGhpcy5wcmVtdWx0aXBsaWVkQWxwaGEgPSBzb3VyY2UucHJlbXVsdGlwbGllZEFscGhhO1xuXHRcdHRoaXMudmlzaWJsZSA9IHNvdXJjZS52aXNpYmxlO1xuXHRcdHRoaXMudG9uZU1hcHBlZCA9IHNvdXJjZS50b25lTWFwcGVkO1xuXHRcdHRoaXMudXNlckRhdGEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHNvdXJjZS51c2VyRGF0YSkpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGRpc3Bvc2UoKSB7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KHtcblx0XHRcdHR5cGU6ICdkaXNwb3NlJ1xuXHRcdH0pO1xuXHR9XG5cdHNldCBuZWVkc1VwZGF0ZSh2YWx1ZSkge1xuXHRcdGlmICh2YWx1ZSA9PT0gdHJ1ZSkgdGhpcy52ZXJzaW9uKys7XG5cdH1cbn1cblxuY2xhc3MgTWVzaEJhc2ljTWF0ZXJpYWwgZXh0ZW5kcyBNYXRlcmlhbCB7XG5cdGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuaXNNZXNoQmFzaWNNYXRlcmlhbCA9IHRydWU7XG5cdFx0dGhpcy50eXBlID0gJ01lc2hCYXNpY01hdGVyaWFsJztcblx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKDB4ZmZmZmZmKTsgLy8gZW1pc3NpdmVcblxuXHRcdHRoaXMubWFwID0gbnVsbDtcblx0XHR0aGlzLmxpZ2h0TWFwID0gbnVsbDtcblx0XHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gMS4wO1xuXHRcdHRoaXMuYW9NYXAgPSBudWxsO1xuXHRcdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSAxLjA7XG5cdFx0dGhpcy5zcGVjdWxhck1hcCA9IG51bGw7XG5cdFx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XG5cdFx0dGhpcy5lbnZNYXAgPSBudWxsO1xuXHRcdHRoaXMuY29tYmluZSA9IE11bHRpcGx5T3BlcmF0aW9uO1xuXHRcdHRoaXMucmVmbGVjdGl2aXR5ID0gMTtcblx0XHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IDAuOTg7XG5cdFx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gJ3JvdW5kJztcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gJ3JvdW5kJztcblx0XHR0aGlzLmZvZyA9IHRydWU7XG5cdFx0dGhpcy5zZXRWYWx1ZXMocGFyYW1ldGVycyk7XG5cdH1cblx0Y29weShzb3VyY2UpIHtcblx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0dGhpcy5jb2xvci5jb3B5KHNvdXJjZS5jb2xvcik7XG5cdFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXHRcdHRoaXMubGlnaHRNYXAgPSBzb3VyY2UubGlnaHRNYXA7XG5cdFx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IHNvdXJjZS5saWdodE1hcEludGVuc2l0eTtcblx0XHR0aGlzLmFvTWFwID0gc291cmNlLmFvTWFwO1xuXHRcdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSBzb3VyY2UuYW9NYXBJbnRlbnNpdHk7XG5cdFx0dGhpcy5zcGVjdWxhck1hcCA9IHNvdXJjZS5zcGVjdWxhck1hcDtcblx0XHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xuXHRcdHRoaXMuZW52TWFwID0gc291cmNlLmVudk1hcDtcblx0XHR0aGlzLmNvbWJpbmUgPSBzb3VyY2UuY29tYmluZTtcblx0XHR0aGlzLnJlZmxlY3Rpdml0eSA9IHNvdXJjZS5yZWZsZWN0aXZpdHk7XG5cdFx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSBzb3VyY2UucmVmcmFjdGlvblJhdGlvO1xuXHRcdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gc291cmNlLndpcmVmcmFtZUxpbmVjYXA7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9IHNvdXJjZS53aXJlZnJhbWVMaW5lam9pbjtcblx0XHR0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn1cblxuY29uc3QgX3ZlY3RvciQ5ID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5jb25zdCBfdmVjdG9yMiQxID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IyKCk7XG5jbGFzcyBCdWZmZXJBdHRyaWJ1dGUge1xuXHRjb25zdHJ1Y3RvcihhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQpIHtcblx0XHRpZiAoQXJyYXkuaXNBcnJheShhcnJheSkpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZTogYXJyYXkgc2hvdWxkIGJlIGEgVHlwZWQgQXJyYXkuJyk7XG5cdFx0fVxuXHRcdHRoaXMuaXNCdWZmZXJBdHRyaWJ1dGUgPSB0cnVlO1xuXHRcdHRoaXMubmFtZSA9ICcnO1xuXHRcdHRoaXMuYXJyYXkgPSBhcnJheTtcblx0XHR0aGlzLml0ZW1TaXplID0gaXRlbVNpemU7XG5cdFx0dGhpcy5jb3VudCA9IGFycmF5ICE9PSB1bmRlZmluZWQgPyBhcnJheS5sZW5ndGggLyBpdGVtU2l6ZSA6IDA7XG5cdFx0dGhpcy5ub3JtYWxpemVkID0gbm9ybWFsaXplZCA9PT0gdHJ1ZTtcblx0XHR0aGlzLnVzYWdlID0gU3RhdGljRHJhd1VzYWdlO1xuXHRcdHRoaXMudXBkYXRlUmFuZ2UgPSB7XG5cdFx0XHRvZmZzZXQ6IDAsXG5cdFx0XHRjb3VudDogLTFcblx0XHR9O1xuXHRcdHRoaXMudmVyc2lvbiA9IDA7XG5cdH1cblx0b25VcGxvYWRDYWxsYmFjaygpIHt9XG5cdHNldCBuZWVkc1VwZGF0ZSh2YWx1ZSkge1xuXHRcdGlmICh2YWx1ZSA9PT0gdHJ1ZSkgdGhpcy52ZXJzaW9uKys7XG5cdH1cblx0c2V0VXNhZ2UodmFsdWUpIHtcblx0XHR0aGlzLnVzYWdlID0gdmFsdWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0Y29weShzb3VyY2UpIHtcblx0XHR0aGlzLm5hbWUgPSBzb3VyY2UubmFtZTtcblx0XHR0aGlzLmFycmF5ID0gbmV3IHNvdXJjZS5hcnJheS5jb25zdHJ1Y3Rvcihzb3VyY2UuYXJyYXkpO1xuXHRcdHRoaXMuaXRlbVNpemUgPSBzb3VyY2UuaXRlbVNpemU7XG5cdFx0dGhpcy5jb3VudCA9IHNvdXJjZS5jb3VudDtcblx0XHR0aGlzLm5vcm1hbGl6ZWQgPSBzb3VyY2Uubm9ybWFsaXplZDtcblx0XHR0aGlzLnVzYWdlID0gc291cmNlLnVzYWdlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGNvcHlBdChpbmRleDEsIGF0dHJpYnV0ZSwgaW5kZXgyKSB7XG5cdFx0aW5kZXgxICo9IHRoaXMuaXRlbVNpemU7XG5cdFx0aW5kZXgyICo9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcblx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMuaXRlbVNpemU7IGkgPCBsOyBpKyspIHtcblx0XHRcdHRoaXMuYXJyYXlbaW5kZXgxICsgaV0gPSBhdHRyaWJ1dGUuYXJyYXlbaW5kZXgyICsgaV07XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGNvcHlBcnJheShhcnJheSkge1xuXHRcdHRoaXMuYXJyYXkuc2V0KGFycmF5KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRhcHBseU1hdHJpeDMobSkge1xuXHRcdGlmICh0aGlzLml0ZW1TaXplID09PSAyKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMuY291bnQ7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0X3ZlY3RvcjIkMS5mcm9tQnVmZmVyQXR0cmlidXRlKHRoaXMsIGkpO1xuXHRcdFx0XHRfdmVjdG9yMiQxLmFwcGx5TWF0cml4MyhtKTtcblx0XHRcdFx0dGhpcy5zZXRYWShpLCBfdmVjdG9yMiQxLngsIF92ZWN0b3IyJDEueSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0aGlzLml0ZW1TaXplID09PSAzKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMuY291bnQ7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0X3ZlY3RvciQ5LmZyb21CdWZmZXJBdHRyaWJ1dGUodGhpcywgaSk7XG5cdFx0XHRcdF92ZWN0b3IkOS5hcHBseU1hdHJpeDMobSk7XG5cdFx0XHRcdHRoaXMuc2V0WFlaKGksIF92ZWN0b3IkOS54LCBfdmVjdG9yJDkueSwgX3ZlY3RvciQ5LnopO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRhcHBseU1hdHJpeDQobSkge1xuXHRcdGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5jb3VudDsgaSA8IGw7IGkrKykge1xuXHRcdFx0X3ZlY3RvciQ5LmZyb21CdWZmZXJBdHRyaWJ1dGUodGhpcywgaSk7XG5cdFx0XHRfdmVjdG9yJDkuYXBwbHlNYXRyaXg0KG0pO1xuXHRcdFx0dGhpcy5zZXRYWVooaSwgX3ZlY3RvciQ5LngsIF92ZWN0b3IkOS55LCBfdmVjdG9yJDkueik7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGFwcGx5Tm9ybWFsTWF0cml4KG0pIHtcblx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMuY291bnQ7IGkgPCBsOyBpKyspIHtcblx0XHRcdF92ZWN0b3IkOS5mcm9tQnVmZmVyQXR0cmlidXRlKHRoaXMsIGkpO1xuXHRcdFx0X3ZlY3RvciQ5LmFwcGx5Tm9ybWFsTWF0cml4KG0pO1xuXHRcdFx0dGhpcy5zZXRYWVooaSwgX3ZlY3RvciQ5LngsIF92ZWN0b3IkOS55LCBfdmVjdG9yJDkueik7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHRyYW5zZm9ybURpcmVjdGlvbihtKSB7XG5cdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLmNvdW50OyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRfdmVjdG9yJDkuZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0aGlzLCBpKTtcblx0XHRcdF92ZWN0b3IkOS50cmFuc2Zvcm1EaXJlY3Rpb24obSk7XG5cdFx0XHR0aGlzLnNldFhZWihpLCBfdmVjdG9yJDkueCwgX3ZlY3RvciQ5LnksIF92ZWN0b3IkOS56KTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0c2V0KHZhbHVlLCBvZmZzZXQgPSAwKSB7XG5cdFx0Ly8gTWF0Y2hpbmcgQnVmZmVyQXR0cmlidXRlIGNvbnN0cnVjdG9yLCBkbyBub3Qgbm9ybWFsaXplIHRoZSBhcnJheS5cblx0XHR0aGlzLmFycmF5LnNldCh2YWx1ZSwgb2Zmc2V0KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRnZXRYKGluZGV4KSB7XG5cdFx0bGV0IHggPSB0aGlzLmFycmF5W2luZGV4ICogdGhpcy5pdGVtU2l6ZV07XG5cdFx0aWYgKHRoaXMubm9ybWFsaXplZCkgeCA9IGRlbm9ybWFsaXplKHgsIHRoaXMuYXJyYXkpO1xuXHRcdHJldHVybiB4O1xuXHR9XG5cdHNldFgoaW5kZXgsIHgpIHtcblx0XHRpZiAodGhpcy5ub3JtYWxpemVkKSB4ID0gbm9ybWFsaXplKHgsIHRoaXMuYXJyYXkpO1xuXHRcdHRoaXMuYXJyYXlbaW5kZXggKiB0aGlzLml0ZW1TaXplXSA9IHg7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0Z2V0WShpbmRleCkge1xuXHRcdGxldCB5ID0gdGhpcy5hcnJheVtpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAxXTtcblx0XHRpZiAodGhpcy5ub3JtYWxpemVkKSB5ID0gZGVub3JtYWxpemUoeSwgdGhpcy5hcnJheSk7XG5cdFx0cmV0dXJuIHk7XG5cdH1cblx0c2V0WShpbmRleCwgeSkge1xuXHRcdGlmICh0aGlzLm5vcm1hbGl6ZWQpIHkgPSBub3JtYWxpemUoeSwgdGhpcy5hcnJheSk7XG5cdFx0dGhpcy5hcnJheVtpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAxXSA9IHk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0Z2V0WihpbmRleCkge1xuXHRcdGxldCB6ID0gdGhpcy5hcnJheVtpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAyXTtcblx0XHRpZiAodGhpcy5ub3JtYWxpemVkKSB6ID0gZGVub3JtYWxpemUoeiwgdGhpcy5hcnJheSk7XG5cdFx0cmV0dXJuIHo7XG5cdH1cblx0c2V0WihpbmRleCwgeikge1xuXHRcdGlmICh0aGlzLm5vcm1hbGl6ZWQpIHogPSBub3JtYWxpemUoeiwgdGhpcy5hcnJheSk7XG5cdFx0dGhpcy5hcnJheVtpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAyXSA9IHo7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0Z2V0VyhpbmRleCkge1xuXHRcdGxldCB3ID0gdGhpcy5hcnJheVtpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAzXTtcblx0XHRpZiAodGhpcy5ub3JtYWxpemVkKSB3ID0gZGVub3JtYWxpemUodywgdGhpcy5hcnJheSk7XG5cdFx0cmV0dXJuIHc7XG5cdH1cblx0c2V0VyhpbmRleCwgdykge1xuXHRcdGlmICh0aGlzLm5vcm1hbGl6ZWQpIHcgPSBub3JtYWxpemUodywgdGhpcy5hcnJheSk7XG5cdFx0dGhpcy5hcnJheVtpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAzXSA9IHc7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0c2V0WFkoaW5kZXgsIHgsIHkpIHtcblx0XHRpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xuXHRcdGlmICh0aGlzLm5vcm1hbGl6ZWQpIHtcblx0XHRcdHggPSBub3JtYWxpemUoeCwgdGhpcy5hcnJheSk7XG5cdFx0XHR5ID0gbm9ybWFsaXplKHksIHRoaXMuYXJyYXkpO1xuXHRcdH1cblx0XHR0aGlzLmFycmF5W2luZGV4ICsgMF0gPSB4O1xuXHRcdHRoaXMuYXJyYXlbaW5kZXggKyAxXSA9IHk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0c2V0WFlaKGluZGV4LCB4LCB5LCB6KSB7XG5cdFx0aW5kZXggKj0gdGhpcy5pdGVtU2l6ZTtcblx0XHRpZiAodGhpcy5ub3JtYWxpemVkKSB7XG5cdFx0XHR4ID0gbm9ybWFsaXplKHgsIHRoaXMuYXJyYXkpO1xuXHRcdFx0eSA9IG5vcm1hbGl6ZSh5LCB0aGlzLmFycmF5KTtcblx0XHRcdHogPSBub3JtYWxpemUoeiwgdGhpcy5hcnJheSk7XG5cdFx0fVxuXHRcdHRoaXMuYXJyYXlbaW5kZXggKyAwXSA9IHg7XG5cdFx0dGhpcy5hcnJheVtpbmRleCArIDFdID0geTtcblx0XHR0aGlzLmFycmF5W2luZGV4ICsgMl0gPSB6O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHNldFhZWlcoaW5kZXgsIHgsIHksIHosIHcpIHtcblx0XHRpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xuXHRcdGlmICh0aGlzLm5vcm1hbGl6ZWQpIHtcblx0XHRcdHggPSBub3JtYWxpemUoeCwgdGhpcy5hcnJheSk7XG5cdFx0XHR5ID0gbm9ybWFsaXplKHksIHRoaXMuYXJyYXkpO1xuXHRcdFx0eiA9IG5vcm1hbGl6ZSh6LCB0aGlzLmFycmF5KTtcblx0XHRcdHcgPSBub3JtYWxpemUodywgdGhpcy5hcnJheSk7XG5cdFx0fVxuXHRcdHRoaXMuYXJyYXlbaW5kZXggKyAwXSA9IHg7XG5cdFx0dGhpcy5hcnJheVtpbmRleCArIDFdID0geTtcblx0XHR0aGlzLmFycmF5W2luZGV4ICsgMl0gPSB6O1xuXHRcdHRoaXMuYXJyYXlbaW5kZXggKyAzXSA9IHc7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0b25VcGxvYWQoY2FsbGJhY2spIHtcblx0XHR0aGlzLm9uVXBsb2FkQ2FsbGJhY2sgPSBjYWxsYmFjaztcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRjbG9uZSgpIHtcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5hcnJheSwgdGhpcy5pdGVtU2l6ZSkuY29weSh0aGlzKTtcblx0fVxuXHR0b0pTT04oKSB7XG5cdFx0Y29uc3QgZGF0YSA9IHtcblx0XHRcdGl0ZW1TaXplOiB0aGlzLml0ZW1TaXplLFxuXHRcdFx0dHlwZTogdGhpcy5hcnJheS5jb25zdHJ1Y3Rvci5uYW1lLFxuXHRcdFx0YXJyYXk6IEFycmF5LmZyb20odGhpcy5hcnJheSksXG5cdFx0XHRub3JtYWxpemVkOiB0aGlzLm5vcm1hbGl6ZWRcblx0XHR9O1xuXHRcdGlmICh0aGlzLm5hbWUgIT09ICcnKSBkYXRhLm5hbWUgPSB0aGlzLm5hbWU7XG5cdFx0aWYgKHRoaXMudXNhZ2UgIT09IFN0YXRpY0RyYXdVc2FnZSkgZGF0YS51c2FnZSA9IHRoaXMudXNhZ2U7XG5cdFx0aWYgKHRoaXMudXBkYXRlUmFuZ2Uub2Zmc2V0ICE9PSAwIHx8IHRoaXMudXBkYXRlUmFuZ2UuY291bnQgIT09IC0xKSBkYXRhLnVwZGF0ZVJhbmdlID0gdGhpcy51cGRhdGVSYW5nZTtcblx0XHRyZXR1cm4gZGF0YTtcblx0fVxuXG5cdC8vIEBkZXByZWNhdGVkXG5cblx0Y29weUNvbG9yc0FycmF5KCkge1xuXHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZTogY29weUNvbG9yc0FycmF5KCkgd2FzIHJlbW92ZWQgaW4gcjE0NC4nKTtcblx0fVxuXHRjb3B5VmVjdG9yMnNBcnJheSgpIHtcblx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5CdWZmZXJBdHRyaWJ1dGU6IGNvcHlWZWN0b3Iyc0FycmF5KCkgd2FzIHJlbW92ZWQgaW4gcjE0NC4nKTtcblx0fVxuXHRjb3B5VmVjdG9yM3NBcnJheSgpIHtcblx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5CdWZmZXJBdHRyaWJ1dGU6IGNvcHlWZWN0b3Izc0FycmF5KCkgd2FzIHJlbW92ZWQgaW4gcjE0NC4nKTtcblx0fVxuXHRjb3B5VmVjdG9yNHNBcnJheSgpIHtcblx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5CdWZmZXJBdHRyaWJ1dGU6IGNvcHlWZWN0b3I0c0FycmF5KCkgd2FzIHJlbW92ZWQgaW4gcjE0NC4nKTtcblx0fVxufVxuXG4vL1xuXG5jbGFzcyBJbnQ4QnVmZmVyQXR0cmlidXRlIGV4dGVuZHMgQnVmZmVyQXR0cmlidXRlIHtcblx0Y29uc3RydWN0b3IoYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkKSB7XG5cdFx0c3VwZXIobmV3IEludDhBcnJheShhcnJheSksIGl0ZW1TaXplLCBub3JtYWxpemVkKTtcblx0fVxufVxuY2xhc3MgVWludDhCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBCdWZmZXJBdHRyaWJ1dGUge1xuXHRjb25zdHJ1Y3RvcihhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQpIHtcblx0XHRzdXBlcihuZXcgVWludDhBcnJheShhcnJheSksIGl0ZW1TaXplLCBub3JtYWxpemVkKTtcblx0fVxufVxuY2xhc3MgVWludDhDbGFtcGVkQnVmZmVyQXR0cmlidXRlIGV4dGVuZHMgQnVmZmVyQXR0cmlidXRlIHtcblx0Y29uc3RydWN0b3IoYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkKSB7XG5cdFx0c3VwZXIobmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGFycmF5KSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQpO1xuXHR9XG59XG5jbGFzcyBJbnQxNkJ1ZmZlckF0dHJpYnV0ZSBleHRlbmRzIEJ1ZmZlckF0dHJpYnV0ZSB7XG5cdGNvbnN0cnVjdG9yKGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCkge1xuXHRcdHN1cGVyKG5ldyBJbnQxNkFycmF5KGFycmF5KSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQpO1xuXHR9XG59XG5jbGFzcyBVaW50MTZCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBCdWZmZXJBdHRyaWJ1dGUge1xuXHRjb25zdHJ1Y3RvcihhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQpIHtcblx0XHRzdXBlcihuZXcgVWludDE2QXJyYXkoYXJyYXkpLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCk7XG5cdH1cbn1cbmNsYXNzIEludDMyQnVmZmVyQXR0cmlidXRlIGV4dGVuZHMgQnVmZmVyQXR0cmlidXRlIHtcblx0Y29uc3RydWN0b3IoYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkKSB7XG5cdFx0c3VwZXIobmV3IEludDMyQXJyYXkoYXJyYXkpLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCk7XG5cdH1cbn1cbmNsYXNzIFVpbnQzMkJ1ZmZlckF0dHJpYnV0ZSBleHRlbmRzIEJ1ZmZlckF0dHJpYnV0ZSB7XG5cdGNvbnN0cnVjdG9yKGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCkge1xuXHRcdHN1cGVyKG5ldyBVaW50MzJBcnJheShhcnJheSksIGl0ZW1TaXplLCBub3JtYWxpemVkKTtcblx0fVxufVxuY2xhc3MgRmxvYXQxNkJ1ZmZlckF0dHJpYnV0ZSBleHRlbmRzIEJ1ZmZlckF0dHJpYnV0ZSB7XG5cdGNvbnN0cnVjdG9yKGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCkge1xuXHRcdHN1cGVyKG5ldyBVaW50MTZBcnJheShhcnJheSksIGl0ZW1TaXplLCBub3JtYWxpemVkKTtcblx0XHR0aGlzLmlzRmxvYXQxNkJ1ZmZlckF0dHJpYnV0ZSA9IHRydWU7XG5cdH1cbn1cbmNsYXNzIEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBCdWZmZXJBdHRyaWJ1dGUge1xuXHRjb25zdHJ1Y3RvcihhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQpIHtcblx0XHRzdXBlcihuZXcgRmxvYXQzMkFycmF5KGFycmF5KSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQpO1xuXHR9XG59XG5jbGFzcyBGbG9hdDY0QnVmZmVyQXR0cmlidXRlIGV4dGVuZHMgQnVmZmVyQXR0cmlidXRlIHtcblx0Y29uc3RydWN0b3IoYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkKSB7XG5cdFx0c3VwZXIobmV3IEZsb2F0NjRBcnJheShhcnJheSksIGl0ZW1TaXplLCBub3JtYWxpemVkKTtcblx0fVxufVxuXG5sZXQgX2lkJDEgPSAwO1xuY29uc3QgX20xID0gLypAX19QVVJFX18qL25ldyBNYXRyaXg0KCk7XG5jb25zdCBfb2JqID0gLypAX19QVVJFX18qL25ldyBPYmplY3QzRCgpO1xuY29uc3QgX29mZnNldCA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuY29uc3QgX2JveCQxID0gLypAX19QVVJFX18qL25ldyBCb3gzKCk7XG5jb25zdCBfYm94TW9ycGhUYXJnZXRzID0gLypAX19QVVJFX18qL25ldyBCb3gzKCk7XG5jb25zdCBfdmVjdG9yJDggPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcbmNsYXNzIEJ1ZmZlckdlb21ldHJ5IGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLmlzQnVmZmVyR2VvbWV0cnkgPSB0cnVlO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaWQnLCB7XG5cdFx0XHR2YWx1ZTogX2lkJDErK1xuXHRcdH0pO1xuXHRcdHRoaXMudXVpZCA9IGdlbmVyYXRlVVVJRCgpO1xuXHRcdHRoaXMubmFtZSA9ICcnO1xuXHRcdHRoaXMudHlwZSA9ICdCdWZmZXJHZW9tZXRyeSc7XG5cdFx0dGhpcy5pbmRleCA9IG51bGw7XG5cdFx0dGhpcy5hdHRyaWJ1dGVzID0ge307XG5cdFx0dGhpcy5tb3JwaEF0dHJpYnV0ZXMgPSB7fTtcblx0XHR0aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlID0gZmFsc2U7XG5cdFx0dGhpcy5ncm91cHMgPSBbXTtcblx0XHR0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcblx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcblx0XHR0aGlzLmRyYXdSYW5nZSA9IHtcblx0XHRcdHN0YXJ0OiAwLFxuXHRcdFx0Y291bnQ6IEluZmluaXR5XG5cdFx0fTtcblx0XHR0aGlzLnVzZXJEYXRhID0ge307XG5cdH1cblx0Z2V0SW5kZXgoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaW5kZXg7XG5cdH1cblx0c2V0SW5kZXgoaW5kZXgpIHtcblx0XHRpZiAoQXJyYXkuaXNBcnJheShpbmRleCkpIHtcblx0XHRcdHRoaXMuaW5kZXggPSBuZXcgKGFycmF5TmVlZHNVaW50MzIoaW5kZXgpID8gVWludDMyQnVmZmVyQXR0cmlidXRlIDogVWludDE2QnVmZmVyQXR0cmlidXRlKShpbmRleCwgMSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuaW5kZXggPSBpbmRleDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0Z2V0QXR0cmlidXRlKG5hbWUpIHtcblx0XHRyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW25hbWVdO1xuXHR9XG5cdHNldEF0dHJpYnV0ZShuYW1lLCBhdHRyaWJ1dGUpIHtcblx0XHR0aGlzLmF0dHJpYnV0ZXNbbmFtZV0gPSBhdHRyaWJ1dGU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0ZGVsZXRlQXR0cmlidXRlKG5hbWUpIHtcblx0XHRkZWxldGUgdGhpcy5hdHRyaWJ1dGVzW25hbWVdO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGhhc0F0dHJpYnV0ZShuYW1lKSB7XG5cdFx0cmV0dXJuIHRoaXMuYXR0cmlidXRlc1tuYW1lXSAhPT0gdW5kZWZpbmVkO1xuXHR9XG5cdGFkZEdyb3VwKHN0YXJ0LCBjb3VudCwgbWF0ZXJpYWxJbmRleCA9IDApIHtcblx0XHR0aGlzLmdyb3Vwcy5wdXNoKHtcblx0XHRcdHN0YXJ0OiBzdGFydCxcblx0XHRcdGNvdW50OiBjb3VudCxcblx0XHRcdG1hdGVyaWFsSW5kZXg6IG1hdGVyaWFsSW5kZXhcblx0XHR9KTtcblx0fVxuXHRjbGVhckdyb3VwcygpIHtcblx0XHR0aGlzLmdyb3VwcyA9IFtdO1xuXHR9XG5cdHNldERyYXdSYW5nZShzdGFydCwgY291bnQpIHtcblx0XHR0aGlzLmRyYXdSYW5nZS5zdGFydCA9IHN0YXJ0O1xuXHRcdHRoaXMuZHJhd1JhbmdlLmNvdW50ID0gY291bnQ7XG5cdH1cblx0YXBwbHlNYXRyaXg0KG1hdHJpeCkge1xuXHRcdGNvbnN0IHBvc2l0aW9uID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdGlmIChwb3NpdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRwb3NpdGlvbi5hcHBseU1hdHJpeDQobWF0cml4KTtcblx0XHRcdHBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHR9XG5cdFx0Y29uc3Qgbm9ybWFsID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbDtcblx0XHRpZiAobm9ybWFsICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGNvbnN0IG5vcm1hbE1hdHJpeCA9IG5ldyBNYXRyaXgzKCkuZ2V0Tm9ybWFsTWF0cml4KG1hdHJpeCk7XG5cdFx0XHRub3JtYWwuYXBwbHlOb3JtYWxNYXRyaXgobm9ybWFsTWF0cml4KTtcblx0XHRcdG5vcm1hbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0fVxuXHRcdGNvbnN0IHRhbmdlbnQgPSB0aGlzLmF0dHJpYnV0ZXMudGFuZ2VudDtcblx0XHRpZiAodGFuZ2VudCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0YW5nZW50LnRyYW5zZm9ybURpcmVjdGlvbihtYXRyaXgpO1xuXHRcdFx0dGFuZ2VudC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0fVxuXHRcdGlmICh0aGlzLmJvdW5kaW5nQm94ICE9PSBudWxsKSB7XG5cdFx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuXHRcdH1cblx0XHRpZiAodGhpcy5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCkge1xuXHRcdFx0dGhpcy5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0YXBwbHlRdWF0ZXJuaW9uKHEpIHtcblx0XHRfbTEubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24ocSk7XG5cdFx0dGhpcy5hcHBseU1hdHJpeDQoX20xKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRyb3RhdGVYKGFuZ2xlKSB7XG5cdFx0Ly8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB4LWF4aXNcblxuXHRcdF9tMS5tYWtlUm90YXRpb25YKGFuZ2xlKTtcblx0XHR0aGlzLmFwcGx5TWF0cml4NChfbTEpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHJvdGF0ZVkoYW5nbGUpIHtcblx0XHQvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHktYXhpc1xuXG5cdFx0X20xLm1ha2VSb3RhdGlvblkoYW5nbGUpO1xuXHRcdHRoaXMuYXBwbHlNYXRyaXg0KF9tMSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0cm90YXRlWihhbmdsZSkge1xuXHRcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgei1heGlzXG5cblx0XHRfbTEubWFrZVJvdGF0aW9uWihhbmdsZSk7XG5cdFx0dGhpcy5hcHBseU1hdHJpeDQoX20xKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHR0cmFuc2xhdGUoeCwgeSwgeikge1xuXHRcdC8vIHRyYW5zbGF0ZSBnZW9tZXRyeVxuXG5cdFx0X20xLm1ha2VUcmFuc2xhdGlvbih4LCB5LCB6KTtcblx0XHR0aGlzLmFwcGx5TWF0cml4NChfbTEpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHNjYWxlKHgsIHksIHopIHtcblx0XHQvLyBzY2FsZSBnZW9tZXRyeVxuXG5cdFx0X20xLm1ha2VTY2FsZSh4LCB5LCB6KTtcblx0XHR0aGlzLmFwcGx5TWF0cml4NChfbTEpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGxvb2tBdCh2ZWN0b3IpIHtcblx0XHRfb2JqLmxvb2tBdCh2ZWN0b3IpO1xuXHRcdF9vYmoudXBkYXRlTWF0cml4KCk7XG5cdFx0dGhpcy5hcHBseU1hdHJpeDQoX29iai5tYXRyaXgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGNlbnRlcigpIHtcblx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuXHRcdHRoaXMuYm91bmRpbmdCb3guZ2V0Q2VudGVyKF9vZmZzZXQpLm5lZ2F0ZSgpO1xuXHRcdHRoaXMudHJhbnNsYXRlKF9vZmZzZXQueCwgX29mZnNldC55LCBfb2Zmc2V0LnopO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHNldEZyb21Qb2ludHMocG9pbnRzKSB7XG5cdFx0Y29uc3QgcG9zaXRpb24gPSBbXTtcblx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuXHRcdFx0cG9zaXRpb24ucHVzaChwb2ludC54LCBwb2ludC55LCBwb2ludC56IHx8IDApO1xuXHRcdH1cblx0XHR0aGlzLnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbiwgMykpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGNvbXB1dGVCb3VuZGluZ0JveCgpIHtcblx0XHRpZiAodGhpcy5ib3VuZGluZ0JveCA9PT0gbnVsbCkge1xuXHRcdFx0dGhpcy5ib3VuZGluZ0JveCA9IG5ldyBCb3gzKCk7XG5cdFx0fVxuXHRcdGNvbnN0IHBvc2l0aW9uID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlc1Bvc2l0aW9uID0gdGhpcy5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0aWYgKHBvc2l0aW9uICYmIHBvc2l0aW9uLmlzR0xCdWZmZXJBdHRyaWJ1dGUpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveCgpOiBHTEJ1ZmZlckF0dHJpYnV0ZSByZXF1aXJlcyBhIG1hbnVhbCBib3VuZGluZyBib3guIEFsdGVybmF0aXZlbHkgc2V0IFwibWVzaC5mcnVzdHVtQ3VsbGVkXCIgdG8gXCJmYWxzZVwiLicsIHRoaXMpO1xuXHRcdFx0dGhpcy5ib3VuZGluZ0JveC5zZXQobmV3IFZlY3RvcjMoLUluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eSksIG5ldyBWZWN0b3IzKCtJbmZpbml0eSwgK0luZmluaXR5LCArSW5maW5pdHkpKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKHBvc2l0aW9uICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuYm91bmRpbmdCb3guc2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbik7XG5cblx0XHRcdC8vIHByb2Nlc3MgbW9ycGggYXR0cmlidXRlcyBpZiBwcmVzZW50XG5cblx0XHRcdGlmIChtb3JwaEF0dHJpYnV0ZXNQb3NpdGlvbikge1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSBtb3JwaEF0dHJpYnV0ZXNQb3NpdGlvbi5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRcdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGUgPSBtb3JwaEF0dHJpYnV0ZXNQb3NpdGlvbltpXTtcblx0XHRcdFx0XHRfYm94JDEuc2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZShtb3JwaEF0dHJpYnV0ZSk7XG5cdFx0XHRcdFx0aWYgKHRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmUpIHtcblx0XHRcdFx0XHRcdF92ZWN0b3IkOC5hZGRWZWN0b3JzKHRoaXMuYm91bmRpbmdCb3gubWluLCBfYm94JDEubWluKTtcblx0XHRcdFx0XHRcdHRoaXMuYm91bmRpbmdCb3guZXhwYW5kQnlQb2ludChfdmVjdG9yJDgpO1xuXHRcdFx0XHRcdFx0X3ZlY3RvciQ4LmFkZFZlY3RvcnModGhpcy5ib3VuZGluZ0JveC5tYXgsIF9ib3gkMS5tYXgpO1xuXHRcdFx0XHRcdFx0dGhpcy5ib3VuZGluZ0JveC5leHBhbmRCeVBvaW50KF92ZWN0b3IkOCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMuYm91bmRpbmdCb3guZXhwYW5kQnlQb2ludChfYm94JDEubWluKTtcblx0XHRcdFx0XHRcdHRoaXMuYm91bmRpbmdCb3guZXhwYW5kQnlQb2ludChfYm94JDEubWF4KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5ib3VuZGluZ0JveC5tYWtlRW1wdHkoKTtcblx0XHR9XG5cdFx0aWYgKGlzTmFOKHRoaXMuYm91bmRpbmdCb3gubWluLngpIHx8IGlzTmFOKHRoaXMuYm91bmRpbmdCb3gubWluLnkpIHx8IGlzTmFOKHRoaXMuYm91bmRpbmdCb3gubWluLnopKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3goKTogQ29tcHV0ZWQgbWluL21heCBoYXZlIE5hTiB2YWx1ZXMuIFRoZSBcInBvc2l0aW9uXCIgYXR0cmlidXRlIGlzIGxpa2VseSB0byBoYXZlIE5hTiB2YWx1ZXMuJywgdGhpcyk7XG5cdFx0fVxuXHR9XG5cdGNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpIHtcblx0XHRpZiAodGhpcy5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCkge1xuXHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBTcGhlcmUoKTtcblx0XHR9XG5cdFx0Y29uc3QgcG9zaXRpb24gPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGVzUG9zaXRpb24gPSB0aGlzLm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRpZiAocG9zaXRpb24gJiYgcG9zaXRpb24uaXNHTEJ1ZmZlckF0dHJpYnV0ZSkge1xuXHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuQnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk6IEdMQnVmZmVyQXR0cmlidXRlIHJlcXVpcmVzIGEgbWFudWFsIGJvdW5kaW5nIHNwaGVyZS4gQWx0ZXJuYXRpdmVseSBzZXQgXCJtZXNoLmZydXN0dW1DdWxsZWRcIiB0byBcImZhbHNlXCIuJywgdGhpcyk7XG5cdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlLnNldChuZXcgVmVjdG9yMygpLCBJbmZpbml0eSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmIChwb3NpdGlvbikge1xuXHRcdFx0Ly8gZmlyc3QsIGZpbmQgdGhlIGNlbnRlciBvZiB0aGUgYm91bmRpbmcgc3BoZXJlXG5cblx0XHRcdGNvbnN0IGNlbnRlciA9IHRoaXMuYm91bmRpbmdTcGhlcmUuY2VudGVyO1xuXHRcdFx0X2JveCQxLnNldEZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb24pO1xuXG5cdFx0XHQvLyBwcm9jZXNzIG1vcnBoIGF0dHJpYnV0ZXMgaWYgcHJlc2VudFxuXG5cdFx0XHRpZiAobW9ycGhBdHRyaWJ1dGVzUG9zaXRpb24pIHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gbW9ycGhBdHRyaWJ1dGVzUG9zaXRpb24ubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVzUG9zaXRpb25baV07XG5cdFx0XHRcdFx0X2JveE1vcnBoVGFyZ2V0cy5zZXRGcm9tQnVmZmVyQXR0cmlidXRlKG1vcnBoQXR0cmlidXRlKTtcblx0XHRcdFx0XHRpZiAodGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZSkge1xuXHRcdFx0XHRcdFx0X3ZlY3RvciQ4LmFkZFZlY3RvcnMoX2JveCQxLm1pbiwgX2JveE1vcnBoVGFyZ2V0cy5taW4pO1xuXHRcdFx0XHRcdFx0X2JveCQxLmV4cGFuZEJ5UG9pbnQoX3ZlY3RvciQ4KTtcblx0XHRcdFx0XHRcdF92ZWN0b3IkOC5hZGRWZWN0b3JzKF9ib3gkMS5tYXgsIF9ib3hNb3JwaFRhcmdldHMubWF4KTtcblx0XHRcdFx0XHRcdF9ib3gkMS5leHBhbmRCeVBvaW50KF92ZWN0b3IkOCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdF9ib3gkMS5leHBhbmRCeVBvaW50KF9ib3hNb3JwaFRhcmdldHMubWluKTtcblx0XHRcdFx0XHRcdF9ib3gkMS5leHBhbmRCeVBvaW50KF9ib3hNb3JwaFRhcmdldHMubWF4KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdF9ib3gkMS5nZXRDZW50ZXIoY2VudGVyKTtcblxuXHRcdFx0Ly8gc2Vjb25kLCB0cnkgdG8gZmluZCBhIGJvdW5kaW5nU3BoZXJlIHdpdGggYSByYWRpdXMgc21hbGxlciB0aGFuIHRoZVxuXHRcdFx0Ly8gYm91bmRpbmdTcGhlcmUgb2YgdGhlIGJvdW5kaW5nQm94OiBzcXJ0KDMpIHNtYWxsZXIgaW4gdGhlIGJlc3QgY2FzZVxuXG5cdFx0XHRsZXQgbWF4UmFkaXVzU3EgPSAwO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gcG9zaXRpb24uY291bnQ7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRcdF92ZWN0b3IkOC5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uLCBpKTtcblx0XHRcdFx0bWF4UmFkaXVzU3EgPSBNYXRoLm1heChtYXhSYWRpdXNTcSwgY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKF92ZWN0b3IkOCkpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBwcm9jZXNzIG1vcnBoIGF0dHJpYnV0ZXMgaWYgcHJlc2VudFxuXG5cdFx0XHRpZiAobW9ycGhBdHRyaWJ1dGVzUG9zaXRpb24pIHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gbW9ycGhBdHRyaWJ1dGVzUG9zaXRpb24ubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVzUG9zaXRpb25baV07XG5cdFx0XHRcdFx0Y29uc3QgbW9ycGhUYXJnZXRzUmVsYXRpdmUgPSB0aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlO1xuXHRcdFx0XHRcdGZvciAobGV0IGogPSAwLCBqbCA9IG1vcnBoQXR0cmlidXRlLmNvdW50OyBqIDwgamw7IGorKykge1xuXHRcdFx0XHRcdFx0X3ZlY3RvciQ4LmZyb21CdWZmZXJBdHRyaWJ1dGUobW9ycGhBdHRyaWJ1dGUsIGopO1xuXHRcdFx0XHRcdFx0aWYgKG1vcnBoVGFyZ2V0c1JlbGF0aXZlKSB7XG5cdFx0XHRcdFx0XHRcdF9vZmZzZXQuZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbiwgaik7XG5cdFx0XHRcdFx0XHRcdF92ZWN0b3IkOC5hZGQoX29mZnNldCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtYXhSYWRpdXNTcSA9IE1hdGgubWF4KG1heFJhZGl1c1NxLCBjZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoX3ZlY3RvciQ4KSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cyA9IE1hdGguc3FydChtYXhSYWRpdXNTcSk7XG5cdFx0XHRpZiAoaXNOYU4odGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXMpKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpOiBDb21wdXRlZCByYWRpdXMgaXMgTmFOLiBUaGUgXCJwb3NpdGlvblwiIGF0dHJpYnV0ZSBpcyBsaWtlbHkgdG8gaGF2ZSBOYU4gdmFsdWVzLicsIHRoaXMpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRjb21wdXRlVGFuZ2VudHMoKSB7XG5cdFx0Y29uc3QgaW5kZXggPSB0aGlzLmluZGV4O1xuXHRcdGNvbnN0IGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG5cblx0XHQvLyBiYXNlZCBvbiBodHRwOi8vd3d3LnRlcmF0aG9uLmNvbS9jb2RlL3RhbmdlbnQuaHRtbFxuXHRcdC8vIChwZXIgdmVydGV4IHRhbmdlbnRzKVxuXG5cdFx0aWYgKGluZGV4ID09PSBudWxsIHx8IGF0dHJpYnV0ZXMucG9zaXRpb24gPT09IHVuZGVmaW5lZCB8fCBhdHRyaWJ1dGVzLm5vcm1hbCA9PT0gdW5kZWZpbmVkIHx8IGF0dHJpYnV0ZXMudXYgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5jb21wdXRlVGFuZ2VudHMoKSBmYWlsZWQuIE1pc3NpbmcgcmVxdWlyZWQgYXR0cmlidXRlcyAoaW5kZXgsIHBvc2l0aW9uLCBub3JtYWwgb3IgdXYpJyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGNvbnN0IGluZGljZXMgPSBpbmRleC5hcnJheTtcblx0XHRjb25zdCBwb3NpdGlvbnMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXHRcdGNvbnN0IG5vcm1hbHMgPSBhdHRyaWJ1dGVzLm5vcm1hbC5hcnJheTtcblx0XHRjb25zdCB1dnMgPSBhdHRyaWJ1dGVzLnV2LmFycmF5O1xuXHRcdGNvbnN0IG5WZXJ0aWNlcyA9IHBvc2l0aW9ucy5sZW5ndGggLyAzO1xuXHRcdGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgndGFuZ2VudCcpID09PSBmYWxzZSkge1xuXHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ3RhbmdlbnQnLCBuZXcgQnVmZmVyQXR0cmlidXRlKG5ldyBGbG9hdDMyQXJyYXkoNCAqIG5WZXJ0aWNlcyksIDQpKTtcblx0XHR9XG5cdFx0Y29uc3QgdGFuZ2VudHMgPSB0aGlzLmdldEF0dHJpYnV0ZSgndGFuZ2VudCcpLmFycmF5O1xuXHRcdGNvbnN0IHRhbjEgPSBbXSxcblx0XHRcdHRhbjIgPSBbXTtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5WZXJ0aWNlczsgaSsrKSB7XG5cdFx0XHR0YW4xW2ldID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdHRhbjJbaV0gPSBuZXcgVmVjdG9yMygpO1xuXHRcdH1cblx0XHRjb25zdCB2QSA9IG5ldyBWZWN0b3IzKCksXG5cdFx0XHR2QiA9IG5ldyBWZWN0b3IzKCksXG5cdFx0XHR2QyA9IG5ldyBWZWN0b3IzKCksXG5cdFx0XHR1dkEgPSBuZXcgVmVjdG9yMigpLFxuXHRcdFx0dXZCID0gbmV3IFZlY3RvcjIoKSxcblx0XHRcdHV2QyA9IG5ldyBWZWN0b3IyKCksXG5cdFx0XHRzZGlyID0gbmV3IFZlY3RvcjMoKSxcblx0XHRcdHRkaXIgPSBuZXcgVmVjdG9yMygpO1xuXHRcdGZ1bmN0aW9uIGhhbmRsZVRyaWFuZ2xlKGEsIGIsIGMpIHtcblx0XHRcdHZBLmZyb21BcnJheShwb3NpdGlvbnMsIGEgKiAzKTtcblx0XHRcdHZCLmZyb21BcnJheShwb3NpdGlvbnMsIGIgKiAzKTtcblx0XHRcdHZDLmZyb21BcnJheShwb3NpdGlvbnMsIGMgKiAzKTtcblx0XHRcdHV2QS5mcm9tQXJyYXkodXZzLCBhICogMik7XG5cdFx0XHR1dkIuZnJvbUFycmF5KHV2cywgYiAqIDIpO1xuXHRcdFx0dXZDLmZyb21BcnJheSh1dnMsIGMgKiAyKTtcblx0XHRcdHZCLnN1Yih2QSk7XG5cdFx0XHR2Qy5zdWIodkEpO1xuXHRcdFx0dXZCLnN1Yih1dkEpO1xuXHRcdFx0dXZDLnN1Yih1dkEpO1xuXHRcdFx0Y29uc3QgciA9IDEuMCAvICh1dkIueCAqIHV2Qy55IC0gdXZDLnggKiB1dkIueSk7XG5cblx0XHRcdC8vIHNpbGVudGx5IGlnbm9yZSBkZWdlbmVyYXRlIHV2IHRyaWFuZ2xlcyBoYXZpbmcgY29pbmNpZGVudCBvciBjb2xpbmVhciB2ZXJ0aWNlc1xuXG5cdFx0XHRpZiAoIWlzRmluaXRlKHIpKSByZXR1cm47XG5cdFx0XHRzZGlyLmNvcHkodkIpLm11bHRpcGx5U2NhbGFyKHV2Qy55KS5hZGRTY2FsZWRWZWN0b3IodkMsIC11dkIueSkubXVsdGlwbHlTY2FsYXIocik7XG5cdFx0XHR0ZGlyLmNvcHkodkMpLm11bHRpcGx5U2NhbGFyKHV2Qi54KS5hZGRTY2FsZWRWZWN0b3IodkIsIC11dkMueCkubXVsdGlwbHlTY2FsYXIocik7XG5cdFx0XHR0YW4xW2FdLmFkZChzZGlyKTtcblx0XHRcdHRhbjFbYl0uYWRkKHNkaXIpO1xuXHRcdFx0dGFuMVtjXS5hZGQoc2Rpcik7XG5cdFx0XHR0YW4yW2FdLmFkZCh0ZGlyKTtcblx0XHRcdHRhbjJbYl0uYWRkKHRkaXIpO1xuXHRcdFx0dGFuMltjXS5hZGQodGRpcik7XG5cdFx0fVxuXHRcdGxldCBncm91cHMgPSB0aGlzLmdyb3Vwcztcblx0XHRpZiAoZ3JvdXBzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0Z3JvdXBzID0gW3tcblx0XHRcdFx0c3RhcnQ6IDAsXG5cdFx0XHRcdGNvdW50OiBpbmRpY2VzLmxlbmd0aFxuXHRcdFx0fV07XG5cdFx0fVxuXHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG5cdFx0XHRjb25zdCBncm91cCA9IGdyb3Vwc1tpXTtcblx0XHRcdGNvbnN0IHN0YXJ0ID0gZ3JvdXAuc3RhcnQ7XG5cdFx0XHRjb25zdCBjb3VudCA9IGdyb3VwLmNvdW50O1xuXHRcdFx0Zm9yIChsZXQgaiA9IHN0YXJ0LCBqbCA9IHN0YXJ0ICsgY291bnQ7IGogPCBqbDsgaiArPSAzKSB7XG5cdFx0XHRcdGhhbmRsZVRyaWFuZ2xlKGluZGljZXNbaiArIDBdLCBpbmRpY2VzW2ogKyAxXSwgaW5kaWNlc1tqICsgMl0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRjb25zdCB0bXAgPSBuZXcgVmVjdG9yMygpLFxuXHRcdFx0dG1wMiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgbiA9IG5ldyBWZWN0b3IzKCksXG5cdFx0XHRuMiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0ZnVuY3Rpb24gaGFuZGxlVmVydGV4KHYpIHtcblx0XHRcdG4uZnJvbUFycmF5KG5vcm1hbHMsIHYgKiAzKTtcblx0XHRcdG4yLmNvcHkobik7XG5cdFx0XHRjb25zdCB0ID0gdGFuMVt2XTtcblxuXHRcdFx0Ly8gR3JhbS1TY2htaWR0IG9ydGhvZ29uYWxpemVcblxuXHRcdFx0dG1wLmNvcHkodCk7XG5cdFx0XHR0bXAuc3ViKG4ubXVsdGlwbHlTY2FsYXIobi5kb3QodCkpKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0Ly8gQ2FsY3VsYXRlIGhhbmRlZG5lc3NcblxuXHRcdFx0dG1wMi5jcm9zc1ZlY3RvcnMobjIsIHQpO1xuXHRcdFx0Y29uc3QgdGVzdCA9IHRtcDIuZG90KHRhbjJbdl0pO1xuXHRcdFx0Y29uc3QgdyA9IHRlc3QgPCAwLjAgPyAtMS4wIDogMS4wO1xuXHRcdFx0dGFuZ2VudHNbdiAqIDRdID0gdG1wLng7XG5cdFx0XHR0YW5nZW50c1t2ICogNCArIDFdID0gdG1wLnk7XG5cdFx0XHR0YW5nZW50c1t2ICogNCArIDJdID0gdG1wLno7XG5cdFx0XHR0YW5nZW50c1t2ICogNCArIDNdID0gdztcblx0XHR9XG5cdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcblx0XHRcdGNvbnN0IGdyb3VwID0gZ3JvdXBzW2ldO1xuXHRcdFx0Y29uc3Qgc3RhcnQgPSBncm91cC5zdGFydDtcblx0XHRcdGNvbnN0IGNvdW50ID0gZ3JvdXAuY291bnQ7XG5cdFx0XHRmb3IgKGxldCBqID0gc3RhcnQsIGpsID0gc3RhcnQgKyBjb3VudDsgaiA8IGpsOyBqICs9IDMpIHtcblx0XHRcdFx0aGFuZGxlVmVydGV4KGluZGljZXNbaiArIDBdKTtcblx0XHRcdFx0aGFuZGxlVmVydGV4KGluZGljZXNbaiArIDFdKTtcblx0XHRcdFx0aGFuZGxlVmVydGV4KGluZGljZXNbaiArIDJdKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Y29tcHV0ZVZlcnRleE5vcm1hbHMoKSB7XG5cdFx0Y29uc3QgaW5kZXggPSB0aGlzLmluZGV4O1xuXHRcdGNvbnN0IHBvc2l0aW9uQXR0cmlidXRlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJyk7XG5cdFx0aWYgKHBvc2l0aW9uQXR0cmlidXRlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGxldCBub3JtYWxBdHRyaWJ1dGUgPSB0aGlzLmdldEF0dHJpYnV0ZSgnbm9ybWFsJyk7XG5cdFx0XHRpZiAobm9ybWFsQXR0cmlidXRlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0bm9ybWFsQXR0cmlidXRlID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZShuZXcgRmxvYXQzMkFycmF5KHBvc2l0aW9uQXR0cmlidXRlLmNvdW50ICogMyksIDMpO1xuXHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSgnbm9ybWFsJywgbm9ybWFsQXR0cmlidXRlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHJlc2V0IGV4aXN0aW5nIG5vcm1hbHMgdG8gemVyb1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IG5vcm1hbEF0dHJpYnV0ZS5jb3VudDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUuc2V0WFlaKGksIDAsIDAsIDApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRjb25zdCBwQSA9IG5ldyBWZWN0b3IzKCksXG5cdFx0XHRcdHBCID0gbmV3IFZlY3RvcjMoKSxcblx0XHRcdFx0cEMgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0Y29uc3QgbkEgPSBuZXcgVmVjdG9yMygpLFxuXHRcdFx0XHRuQiA9IG5ldyBWZWN0b3IzKCksXG5cdFx0XHRcdG5DID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdGNvbnN0IGNiID0gbmV3IFZlY3RvcjMoKSxcblx0XHRcdFx0YWIgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHQvLyBpbmRleGVkIGVsZW1lbnRzXG5cblx0XHRcdGlmIChpbmRleCkge1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSBpbmRleC5jb3VudDsgaSA8IGlsOyBpICs9IDMpIHtcblx0XHRcdFx0XHRjb25zdCB2QSA9IGluZGV4LmdldFgoaSArIDApO1xuXHRcdFx0XHRcdGNvbnN0IHZCID0gaW5kZXguZ2V0WChpICsgMSk7XG5cdFx0XHRcdFx0Y29uc3QgdkMgPSBpbmRleC5nZXRYKGkgKyAyKTtcblx0XHRcdFx0XHRwQS5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uQXR0cmlidXRlLCB2QSk7XG5cdFx0XHRcdFx0cEIuZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbkF0dHJpYnV0ZSwgdkIpO1xuXHRcdFx0XHRcdHBDLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25BdHRyaWJ1dGUsIHZDKTtcblx0XHRcdFx0XHRjYi5zdWJWZWN0b3JzKHBDLCBwQik7XG5cdFx0XHRcdFx0YWIuc3ViVmVjdG9ycyhwQSwgcEIpO1xuXHRcdFx0XHRcdGNiLmNyb3NzKGFiKTtcblx0XHRcdFx0XHRuQS5mcm9tQnVmZmVyQXR0cmlidXRlKG5vcm1hbEF0dHJpYnV0ZSwgdkEpO1xuXHRcdFx0XHRcdG5CLmZyb21CdWZmZXJBdHRyaWJ1dGUobm9ybWFsQXR0cmlidXRlLCB2Qik7XG5cdFx0XHRcdFx0bkMuZnJvbUJ1ZmZlckF0dHJpYnV0ZShub3JtYWxBdHRyaWJ1dGUsIHZDKTtcblx0XHRcdFx0XHRuQS5hZGQoY2IpO1xuXHRcdFx0XHRcdG5CLmFkZChjYik7XG5cdFx0XHRcdFx0bkMuYWRkKGNiKTtcblx0XHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUuc2V0WFlaKHZBLCBuQS54LCBuQS55LCBuQS56KTtcblx0XHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUuc2V0WFlaKHZCLCBuQi54LCBuQi55LCBuQi56KTtcblx0XHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUuc2V0WFlaKHZDLCBuQy54LCBuQy55LCBuQy56KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gbm9uLWluZGV4ZWQgZWxlbWVudHMgKHVuY29ubmVjdGVkIHRyaWFuZ2xlIHNvdXApXG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gcG9zaXRpb25BdHRyaWJ1dGUuY291bnQ7IGkgPCBpbDsgaSArPSAzKSB7XG5cdFx0XHRcdFx0cEEuZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbkF0dHJpYnV0ZSwgaSArIDApO1xuXHRcdFx0XHRcdHBCLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25BdHRyaWJ1dGUsIGkgKyAxKTtcblx0XHRcdFx0XHRwQy5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uQXR0cmlidXRlLCBpICsgMik7XG5cdFx0XHRcdFx0Y2Iuc3ViVmVjdG9ycyhwQywgcEIpO1xuXHRcdFx0XHRcdGFiLnN1YlZlY3RvcnMocEEsIHBCKTtcblx0XHRcdFx0XHRjYi5jcm9zcyhhYik7XG5cdFx0XHRcdFx0bm9ybWFsQXR0cmlidXRlLnNldFhZWihpICsgMCwgY2IueCwgY2IueSwgY2Iueik7XG5cdFx0XHRcdFx0bm9ybWFsQXR0cmlidXRlLnNldFhZWihpICsgMSwgY2IueCwgY2IueSwgY2Iueik7XG5cdFx0XHRcdFx0bm9ybWFsQXR0cmlidXRlLnNldFhZWihpICsgMiwgY2IueCwgY2IueSwgY2Iueik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMubm9ybWFsaXplTm9ybWFscygpO1xuXHRcdFx0bm9ybWFsQXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHR9XG5cdH1cblxuXHQvLyBAZGVwcmVjYXRlZCBzaW5jZSByMTQ0XG5cblx0bWVyZ2UoKSB7XG5cdFx0Y29uc29sZS5lcnJvcignVEhSRUUuQnVmZmVyR2VvbWV0cnkubWVyZ2UoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlscy5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoKSBpbnN0ZWFkLicpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdG5vcm1hbGl6ZU5vcm1hbHMoKSB7XG5cdFx0Y29uc3Qgbm9ybWFscyA9IHRoaXMuYXR0cmlidXRlcy5ub3JtYWw7XG5cdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gbm9ybWFscy5jb3VudDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdF92ZWN0b3IkOC5mcm9tQnVmZmVyQXR0cmlidXRlKG5vcm1hbHMsIGkpO1xuXHRcdFx0X3ZlY3RvciQ4Lm5vcm1hbGl6ZSgpO1xuXHRcdFx0bm9ybWFscy5zZXRYWVooaSwgX3ZlY3RvciQ4LngsIF92ZWN0b3IkOC55LCBfdmVjdG9yJDgueik7XG5cdFx0fVxuXHR9XG5cdHRvTm9uSW5kZXhlZCgpIHtcblx0XHRmdW5jdGlvbiBjb252ZXJ0QnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZSwgaW5kaWNlcykge1xuXHRcdFx0Y29uc3QgYXJyYXkgPSBhdHRyaWJ1dGUuYXJyYXk7XG5cdFx0XHRjb25zdCBpdGVtU2l6ZSA9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcblx0XHRcdGNvbnN0IG5vcm1hbGl6ZWQgPSBhdHRyaWJ1dGUubm9ybWFsaXplZDtcblx0XHRcdGNvbnN0IGFycmF5MiA9IG5ldyBhcnJheS5jb25zdHJ1Y3RvcihpbmRpY2VzLmxlbmd0aCAqIGl0ZW1TaXplKTtcblx0XHRcdGxldCBpbmRleCA9IDAsXG5cdFx0XHRcdGluZGV4MiA9IDA7XG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGluZGljZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGlmIChhdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSkge1xuXHRcdFx0XHRcdGluZGV4ID0gaW5kaWNlc1tpXSAqIGF0dHJpYnV0ZS5kYXRhLnN0cmlkZSArIGF0dHJpYnV0ZS5vZmZzZXQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aW5kZXggPSBpbmRpY2VzW2ldICogaXRlbVNpemU7XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBpdGVtU2l6ZTsgaisrKSB7XG5cdFx0XHRcdFx0YXJyYXkyW2luZGV4MisrXSA9IGFycmF5W2luZGV4KytdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbmV3IEJ1ZmZlckF0dHJpYnV0ZShhcnJheTIsIGl0ZW1TaXplLCBub3JtYWxpemVkKTtcblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0aWYgKHRoaXMuaW5kZXggPT09IG51bGwpIHtcblx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuQnVmZmVyR2VvbWV0cnkudG9Ob25JbmRleGVkKCk6IEJ1ZmZlckdlb21ldHJ5IGlzIGFscmVhZHkgbm9uLWluZGV4ZWQuJyk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0Y29uc3QgZ2VvbWV0cnkyID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdFx0Y29uc3QgaW5kaWNlcyA9IHRoaXMuaW5kZXguYXJyYXk7XG5cdFx0Y29uc3QgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcblxuXHRcdC8vIGF0dHJpYnV0ZXNcblxuXHRcdGZvciAoY29uc3QgbmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG5cdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuXHRcdFx0Y29uc3QgbmV3QXR0cmlidXRlID0gY29udmVydEJ1ZmZlckF0dHJpYnV0ZShhdHRyaWJ1dGUsIGluZGljZXMpO1xuXHRcdFx0Z2VvbWV0cnkyLnNldEF0dHJpYnV0ZShuYW1lLCBuZXdBdHRyaWJ1dGUpO1xuXHRcdH1cblxuXHRcdC8vIG1vcnBoIGF0dHJpYnV0ZXNcblxuXHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlcyA9IHRoaXMubW9ycGhBdHRyaWJ1dGVzO1xuXHRcdGZvciAoY29uc3QgbmFtZSBpbiBtb3JwaEF0dHJpYnV0ZXMpIHtcblx0XHRcdGNvbnN0IG1vcnBoQXJyYXkgPSBbXTtcblx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVzW25hbWVdOyAvLyBtb3JwaEF0dHJpYnV0ZTogYXJyYXkgb2YgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZXNcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gbW9ycGhBdHRyaWJ1dGUubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBtb3JwaEF0dHJpYnV0ZVtpXTtcblx0XHRcdFx0Y29uc3QgbmV3QXR0cmlidXRlID0gY29udmVydEJ1ZmZlckF0dHJpYnV0ZShhdHRyaWJ1dGUsIGluZGljZXMpO1xuXHRcdFx0XHRtb3JwaEFycmF5LnB1c2gobmV3QXR0cmlidXRlKTtcblx0XHRcdH1cblx0XHRcdGdlb21ldHJ5Mi5tb3JwaEF0dHJpYnV0ZXNbbmFtZV0gPSBtb3JwaEFycmF5O1xuXHRcdH1cblx0XHRnZW9tZXRyeTIubW9ycGhUYXJnZXRzUmVsYXRpdmUgPSB0aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlO1xuXG5cdFx0Ly8gZ3JvdXBzXG5cblx0XHRjb25zdCBncm91cHMgPSB0aGlzLmdyb3Vwcztcblx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGNvbnN0IGdyb3VwID0gZ3JvdXBzW2ldO1xuXHRcdFx0Z2VvbWV0cnkyLmFkZEdyb3VwKGdyb3VwLnN0YXJ0LCBncm91cC5jb3VudCwgZ3JvdXAubWF0ZXJpYWxJbmRleCk7XG5cdFx0fVxuXHRcdHJldHVybiBnZW9tZXRyeTI7XG5cdH1cblx0dG9KU09OKCkge1xuXHRcdGNvbnN0IGRhdGEgPSB7XG5cdFx0XHRtZXRhZGF0YToge1xuXHRcdFx0XHR2ZXJzaW9uOiA0LjUsXG5cdFx0XHRcdHR5cGU6ICdCdWZmZXJHZW9tZXRyeScsXG5cdFx0XHRcdGdlbmVyYXRvcjogJ0J1ZmZlckdlb21ldHJ5LnRvSlNPTidcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Ly8gc3RhbmRhcmQgQnVmZmVyR2VvbWV0cnkgc2VyaWFsaXphdGlvblxuXG5cdFx0ZGF0YS51dWlkID0gdGhpcy51dWlkO1xuXHRcdGRhdGEudHlwZSA9IHRoaXMudHlwZTtcblx0XHRpZiAodGhpcy5uYW1lICE9PSAnJykgZGF0YS5uYW1lID0gdGhpcy5uYW1lO1xuXHRcdGlmIChPYmplY3Qua2V5cyh0aGlzLnVzZXJEYXRhKS5sZW5ndGggPiAwKSBkYXRhLnVzZXJEYXRhID0gdGhpcy51c2VyRGF0YTtcblx0XHRpZiAodGhpcy5wYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGNvbnN0IHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XG5cdFx0XHRmb3IgKGNvbnN0IGtleSBpbiBwYXJhbWV0ZXJzKSB7XG5cdFx0XHRcdGlmIChwYXJhbWV0ZXJzW2tleV0gIT09IHVuZGVmaW5lZCkgZGF0YVtrZXldID0gcGFyYW1ldGVyc1trZXldO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdFx0Ly8gZm9yIHNpbXBsaWNpdHkgdGhlIGNvZGUgYXNzdW1lcyBhdHRyaWJ1dGVzIGFyZSBub3Qgc2hhcmVkIGFjcm9zcyBnZW9tZXRyaWVzLCBzZWUgIzE1ODExXG5cblx0XHRkYXRhLmRhdGEgPSB7XG5cdFx0XHRhdHRyaWJ1dGVzOiB7fVxuXHRcdH07XG5cdFx0Y29uc3QgaW5kZXggPSB0aGlzLmluZGV4O1xuXHRcdGlmIChpbmRleCAhPT0gbnVsbCkge1xuXHRcdFx0ZGF0YS5kYXRhLmluZGV4ID0ge1xuXHRcdFx0XHR0eXBlOiBpbmRleC5hcnJheS5jb25zdHJ1Y3Rvci5uYW1lLFxuXHRcdFx0XHRhcnJheTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaW5kZXguYXJyYXkpXG5cdFx0XHR9O1xuXHRcdH1cblx0XHRjb25zdCBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuXHRcdGZvciAoY29uc3Qga2V5IGluIGF0dHJpYnV0ZXMpIHtcblx0XHRcdGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNba2V5XTtcblx0XHRcdGRhdGEuZGF0YS5hdHRyaWJ1dGVzW2tleV0gPSBhdHRyaWJ1dGUudG9KU09OKGRhdGEuZGF0YSk7XG5cdFx0fVxuXHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlcyA9IHt9O1xuXHRcdGxldCBoYXNNb3JwaEF0dHJpYnV0ZXMgPSBmYWxzZTtcblx0XHRmb3IgKGNvbnN0IGtleSBpbiB0aGlzLm1vcnBoQXR0cmlidXRlcykge1xuXHRcdFx0Y29uc3QgYXR0cmlidXRlQXJyYXkgPSB0aGlzLm1vcnBoQXR0cmlidXRlc1trZXldO1xuXHRcdFx0Y29uc3QgYXJyYXkgPSBbXTtcblx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IGF0dHJpYnV0ZUFycmF5Lmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlQXJyYXlbaV07XG5cdFx0XHRcdGFycmF5LnB1c2goYXR0cmlidXRlLnRvSlNPTihkYXRhLmRhdGEpKTtcblx0XHRcdH1cblx0XHRcdGlmIChhcnJheS5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdG1vcnBoQXR0cmlidXRlc1trZXldID0gYXJyYXk7XG5cdFx0XHRcdGhhc01vcnBoQXR0cmlidXRlcyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChoYXNNb3JwaEF0dHJpYnV0ZXMpIHtcblx0XHRcdGRhdGEuZGF0YS5tb3JwaEF0dHJpYnV0ZXMgPSBtb3JwaEF0dHJpYnV0ZXM7XG5cdFx0XHRkYXRhLmRhdGEubW9ycGhUYXJnZXRzUmVsYXRpdmUgPSB0aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlO1xuXHRcdH1cblx0XHRjb25zdCBncm91cHMgPSB0aGlzLmdyb3Vwcztcblx0XHRpZiAoZ3JvdXBzLmxlbmd0aCA+IDApIHtcblx0XHRcdGRhdGEuZGF0YS5ncm91cHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGdyb3VwcykpO1xuXHRcdH1cblx0XHRjb25zdCBib3VuZGluZ1NwaGVyZSA9IHRoaXMuYm91bmRpbmdTcGhlcmU7XG5cdFx0aWYgKGJvdW5kaW5nU3BoZXJlICE9PSBudWxsKSB7XG5cdFx0XHRkYXRhLmRhdGEuYm91bmRpbmdTcGhlcmUgPSB7XG5cdFx0XHRcdGNlbnRlcjogYm91bmRpbmdTcGhlcmUuY2VudGVyLnRvQXJyYXkoKSxcblx0XHRcdFx0cmFkaXVzOiBib3VuZGluZ1NwaGVyZS5yYWRpdXNcblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiBkYXRhO1xuXHR9XG5cdGNsb25lKCkge1xuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyk7XG5cdH1cblx0Y29weShzb3VyY2UpIHtcblx0XHQvLyByZXNldFxuXG5cdFx0dGhpcy5pbmRleCA9IG51bGw7XG5cdFx0dGhpcy5hdHRyaWJ1dGVzID0ge307XG5cdFx0dGhpcy5tb3JwaEF0dHJpYnV0ZXMgPSB7fTtcblx0XHR0aGlzLmdyb3VwcyA9IFtdO1xuXHRcdHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xuXHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBudWxsO1xuXG5cdFx0Ly8gdXNlZCBmb3Igc3RvcmluZyBjbG9uZWQsIHNoYXJlZCBkYXRhXG5cblx0XHRjb25zdCBkYXRhID0ge307XG5cblx0XHQvLyBuYW1lXG5cblx0XHR0aGlzLm5hbWUgPSBzb3VyY2UubmFtZTtcblxuXHRcdC8vIGluZGV4XG5cblx0XHRjb25zdCBpbmRleCA9IHNvdXJjZS5pbmRleDtcblx0XHRpZiAoaW5kZXggIT09IG51bGwpIHtcblx0XHRcdHRoaXMuc2V0SW5kZXgoaW5kZXguY2xvbmUoZGF0YSkpO1xuXHRcdH1cblxuXHRcdC8vIGF0dHJpYnV0ZXNcblxuXHRcdGNvbnN0IGF0dHJpYnV0ZXMgPSBzb3VyY2UuYXR0cmlidXRlcztcblx0XHRmb3IgKGNvbnN0IG5hbWUgaW4gYXR0cmlidXRlcykge1xuXHRcdFx0Y29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1tuYW1lXTtcblx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsIGF0dHJpYnV0ZS5jbG9uZShkYXRhKSk7XG5cdFx0fVxuXG5cdFx0Ly8gbW9ycGggYXR0cmlidXRlc1xuXG5cdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGVzID0gc291cmNlLm1vcnBoQXR0cmlidXRlcztcblx0XHRmb3IgKGNvbnN0IG5hbWUgaW4gbW9ycGhBdHRyaWJ1dGVzKSB7XG5cdFx0XHRjb25zdCBhcnJheSA9IFtdO1xuXHRcdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGUgPSBtb3JwaEF0dHJpYnV0ZXNbbmFtZV07IC8vIG1vcnBoQXR0cmlidXRlOiBhcnJheSBvZiBGbG9hdDMyQnVmZmVyQXR0cmlidXRlc1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IG1vcnBoQXR0cmlidXRlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRhcnJheS5wdXNoKG1vcnBoQXR0cmlidXRlW2ldLmNsb25lKGRhdGEpKTtcblx0XHRcdH1cblx0XHRcdHRoaXMubW9ycGhBdHRyaWJ1dGVzW25hbWVdID0gYXJyYXk7XG5cdFx0fVxuXHRcdHRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmUgPSBzb3VyY2UubW9ycGhUYXJnZXRzUmVsYXRpdmU7XG5cblx0XHQvLyBncm91cHNcblxuXHRcdGNvbnN0IGdyb3VwcyA9IHNvdXJjZS5ncm91cHM7XG5cdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBncm91cHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRjb25zdCBncm91cCA9IGdyb3Vwc1tpXTtcblx0XHRcdHRoaXMuYWRkR3JvdXAoZ3JvdXAuc3RhcnQsIGdyb3VwLmNvdW50LCBncm91cC5tYXRlcmlhbEluZGV4KTtcblx0XHR9XG5cblx0XHQvLyBib3VuZGluZyBib3hcblxuXHRcdGNvbnN0IGJvdW5kaW5nQm94ID0gc291cmNlLmJvdW5kaW5nQm94O1xuXHRcdGlmIChib3VuZGluZ0JveCAhPT0gbnVsbCkge1xuXHRcdFx0dGhpcy5ib3VuZGluZ0JveCA9IGJvdW5kaW5nQm94LmNsb25lKCk7XG5cdFx0fVxuXG5cdFx0Ly8gYm91bmRpbmcgc3BoZXJlXG5cblx0XHRjb25zdCBib3VuZGluZ1NwaGVyZSA9IHNvdXJjZS5ib3VuZGluZ1NwaGVyZTtcblx0XHRpZiAoYm91bmRpbmdTcGhlcmUgIT09IG51bGwpIHtcblx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBib3VuZGluZ1NwaGVyZS5jbG9uZSgpO1xuXHRcdH1cblxuXHRcdC8vIGRyYXcgcmFuZ2VcblxuXHRcdHRoaXMuZHJhd1JhbmdlLnN0YXJ0ID0gc291cmNlLmRyYXdSYW5nZS5zdGFydDtcblx0XHR0aGlzLmRyYXdSYW5nZS5jb3VudCA9IHNvdXJjZS5kcmF3UmFuZ2UuY291bnQ7XG5cblx0XHQvLyB1c2VyIGRhdGFcblxuXHRcdHRoaXMudXNlckRhdGEgPSBzb3VyY2UudXNlckRhdGE7XG5cblx0XHQvLyBnZW9tZXRyeSBnZW5lcmF0b3IgcGFyYW1ldGVyc1xuXG5cdFx0aWYgKHNvdXJjZS5wYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQpIHRoaXMucGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHNvdXJjZS5wYXJhbWV0ZXJzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRkaXNwb3NlKCkge1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudCh7XG5cdFx0XHR0eXBlOiAnZGlzcG9zZSdcblx0XHR9KTtcblx0fVxufVxuXG5jb25zdCBfaW52ZXJzZU1hdHJpeCQyID0gLypAX19QVVJFX18qL25ldyBNYXRyaXg0KCk7XG5jb25zdCBfcmF5JDIgPSAvKkBfX1BVUkVfXyovbmV3IFJheSgpO1xuY29uc3QgX3NwaGVyZSQzID0gLypAX19QVVJFX18qL25ldyBTcGhlcmUoKTtcbmNvbnN0IF92QSQxID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5jb25zdCBfdkIkMSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuY29uc3QgX3ZDJDEgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF90ZW1wQSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuY29uc3QgX3RlbXBCID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5jb25zdCBfdGVtcEMgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9tb3JwaEEgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9tb3JwaEIgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9tb3JwaEMgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF91dkEkMSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMigpO1xuY29uc3QgX3V2QiQxID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IyKCk7XG5jb25zdCBfdXZDJDEgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjIoKTtcbmNvbnN0IF9pbnRlcnNlY3Rpb25Qb2ludCA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuY29uc3QgX2ludGVyc2VjdGlvblBvaW50V29ybGQgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcbmNsYXNzIE1lc2ggZXh0ZW5kcyBPYmplY3QzRCB7XG5cdGNvbnN0cnVjdG9yKGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCksIG1hdGVyaWFsID0gbmV3IE1lc2hCYXNpY01hdGVyaWFsKCkpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuaXNNZXNoID0gdHJ1ZTtcblx0XHR0aGlzLnR5cGUgPSAnTWVzaCc7XG5cdFx0dGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5O1xuXHRcdHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbDtcblx0XHR0aGlzLnVwZGF0ZU1vcnBoVGFyZ2V0cygpO1xuXHR9XG5cdGNvcHkoc291cmNlLCByZWN1cnNpdmUpIHtcblx0XHRzdXBlci5jb3B5KHNvdXJjZSwgcmVjdXJzaXZlKTtcblx0XHRpZiAoc291cmNlLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyA9IHNvdXJjZS5tb3JwaFRhcmdldEluZmx1ZW5jZXMuc2xpY2UoKTtcblx0XHR9XG5cdFx0aWYgKHNvdXJjZS5tb3JwaFRhcmdldERpY3Rpb25hcnkgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnkgPSBPYmplY3QuYXNzaWduKHt9LCBzb3VyY2UubW9ycGhUYXJnZXREaWN0aW9uYXJ5KTtcblx0XHR9XG5cdFx0dGhpcy5tYXRlcmlhbCA9IHNvdXJjZS5tYXRlcmlhbDtcblx0XHR0aGlzLmdlb21ldHJ5ID0gc291cmNlLmdlb21ldHJ5O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHVwZGF0ZU1vcnBoVGFyZ2V0cygpIHtcblx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGVzID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzO1xuXHRcdGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhtb3JwaEF0dHJpYnV0ZXMpO1xuXHRcdGlmIChrZXlzLmxlbmd0aCA+IDApIHtcblx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVzW2tleXNbMF1dO1xuXHRcdFx0aWYgKG1vcnBoQXR0cmlidXRlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMgPSBbXTtcblx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnkgPSB7fTtcblx0XHRcdFx0Zm9yIChsZXQgbSA9IDAsIG1sID0gbW9ycGhBdHRyaWJ1dGUubGVuZ3RoOyBtIDwgbWw7IG0rKykge1xuXHRcdFx0XHRcdGNvbnN0IG5hbWUgPSBtb3JwaEF0dHJpYnV0ZVttXS5uYW1lIHx8IFN0cmluZyhtKTtcblx0XHRcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5wdXNoKDApO1xuXHRcdFx0XHRcdHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5W25hbWVdID0gbTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyYXljYXN0KHJheWNhc3RlciwgaW50ZXJzZWN0cykge1xuXHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblx0XHRjb25zdCBtYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWw7XG5cdFx0Y29uc3QgbWF0cml4V29ybGQgPSB0aGlzLm1hdHJpeFdvcmxkO1xuXHRcdGlmIChtYXRlcmlhbCA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cblx0XHQvLyBDaGVja2luZyBib3VuZGluZ1NwaGVyZSBkaXN0YW5jZSB0byByYXlcblxuXHRcdGlmIChnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCkgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cdFx0X3NwaGVyZSQzLmNvcHkoZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUpO1xuXHRcdF9zcGhlcmUkMy5hcHBseU1hdHJpeDQobWF0cml4V29ybGQpO1xuXHRcdGlmIChyYXljYXN0ZXIucmF5LmludGVyc2VjdHNTcGhlcmUoX3NwaGVyZSQzKSA9PT0gZmFsc2UpIHJldHVybjtcblxuXHRcdC8vXG5cblx0XHRfaW52ZXJzZU1hdHJpeCQyLmNvcHkobWF0cml4V29ybGQpLmludmVydCgpO1xuXHRcdF9yYXkkMi5jb3B5KHJheWNhc3Rlci5yYXkpLmFwcGx5TWF0cml4NChfaW52ZXJzZU1hdHJpeCQyKTtcblxuXHRcdC8vIENoZWNrIGJvdW5kaW5nQm94IGJlZm9yZSBjb250aW51aW5nXG5cblx0XHRpZiAoZ2VvbWV0cnkuYm91bmRpbmdCb3ggIT09IG51bGwpIHtcblx0XHRcdGlmIChfcmF5JDIuaW50ZXJzZWN0c0JveChnZW9tZXRyeS5ib3VuZGluZ0JveCkgPT09IGZhbHNlKSByZXR1cm47XG5cdFx0fVxuXHRcdGxldCBpbnRlcnNlY3Rpb247XG5cdFx0Y29uc3QgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcblx0XHRjb25zdCBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0Y29uc3QgbW9ycGhQb3NpdGlvbiA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRjb25zdCBtb3JwaFRhcmdldHNSZWxhdGl2ZSA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1JlbGF0aXZlO1xuXHRcdGNvbnN0IHV2ID0gZ2VvbWV0cnkuYXR0cmlidXRlcy51djtcblx0XHRjb25zdCB1djIgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnV2Mjtcblx0XHRjb25zdCBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XG5cdFx0Y29uc3QgZHJhd1JhbmdlID0gZ2VvbWV0cnkuZHJhd1JhbmdlO1xuXHRcdGlmIChpbmRleCAhPT0gbnVsbCkge1xuXHRcdFx0Ly8gaW5kZXhlZCBidWZmZXIgZ2VvbWV0cnlcblxuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkobWF0ZXJpYWwpKSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRcdFx0Y29uc3QgZ3JvdXAgPSBncm91cHNbaV07XG5cdFx0XHRcdFx0Y29uc3QgZ3JvdXBNYXRlcmlhbCA9IG1hdGVyaWFsW2dyb3VwLm1hdGVyaWFsSW5kZXhdO1xuXHRcdFx0XHRcdGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoZ3JvdXAuc3RhcnQsIGRyYXdSYW5nZS5zdGFydCk7XG5cdFx0XHRcdFx0Y29uc3QgZW5kID0gTWF0aC5taW4oaW5kZXguY291bnQsIE1hdGgubWluKGdyb3VwLnN0YXJ0ICsgZ3JvdXAuY291bnQsIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCkpO1xuXHRcdFx0XHRcdGZvciAobGV0IGogPSBzdGFydCwgamwgPSBlbmQ7IGogPCBqbDsgaiArPSAzKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBhID0gaW5kZXguZ2V0WChqKTtcblx0XHRcdFx0XHRcdGNvbnN0IGIgPSBpbmRleC5nZXRYKGogKyAxKTtcblx0XHRcdFx0XHRcdGNvbnN0IGMgPSBpbmRleC5nZXRYKGogKyAyKTtcblx0XHRcdFx0XHRcdGludGVyc2VjdGlvbiA9IGNoZWNrQnVmZmVyR2VvbWV0cnlJbnRlcnNlY3Rpb24odGhpcywgZ3JvdXBNYXRlcmlhbCwgcmF5Y2FzdGVyLCBfcmF5JDIsIHBvc2l0aW9uLCBtb3JwaFBvc2l0aW9uLCBtb3JwaFRhcmdldHNSZWxhdGl2ZSwgdXYsIHV2MiwgYSwgYiwgYyk7XG5cdFx0XHRcdFx0XHRpZiAoaW50ZXJzZWN0aW9uKSB7XG5cdFx0XHRcdFx0XHRcdGludGVyc2VjdGlvbi5mYWNlSW5kZXggPSBNYXRoLmZsb29yKGogLyAzKTsgLy8gdHJpYW5nbGUgbnVtYmVyIGluIGluZGV4ZWQgYnVmZmVyIHNlbWFudGljc1xuXHRcdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24uZmFjZS5tYXRlcmlhbEluZGV4ID0gZ3JvdXAubWF0ZXJpYWxJbmRleDtcblx0XHRcdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKGludGVyc2VjdGlvbik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zdCBzdGFydCA9IE1hdGgubWF4KDAsIGRyYXdSYW5nZS5zdGFydCk7XG5cdFx0XHRcdGNvbnN0IGVuZCA9IE1hdGgubWluKGluZGV4LmNvdW50LCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQpO1xuXHRcdFx0XHRmb3IgKGxldCBpID0gc3RhcnQsIGlsID0gZW5kOyBpIDwgaWw7IGkgKz0gMykge1xuXHRcdFx0XHRcdGNvbnN0IGEgPSBpbmRleC5nZXRYKGkpO1xuXHRcdFx0XHRcdGNvbnN0IGIgPSBpbmRleC5nZXRYKGkgKyAxKTtcblx0XHRcdFx0XHRjb25zdCBjID0gaW5kZXguZ2V0WChpICsgMik7XG5cdFx0XHRcdFx0aW50ZXJzZWN0aW9uID0gY2hlY2tCdWZmZXJHZW9tZXRyeUludGVyc2VjdGlvbih0aGlzLCBtYXRlcmlhbCwgcmF5Y2FzdGVyLCBfcmF5JDIsIHBvc2l0aW9uLCBtb3JwaFBvc2l0aW9uLCBtb3JwaFRhcmdldHNSZWxhdGl2ZSwgdXYsIHV2MiwgYSwgYiwgYyk7XG5cdFx0XHRcdFx0aWYgKGludGVyc2VjdGlvbikge1xuXHRcdFx0XHRcdFx0aW50ZXJzZWN0aW9uLmZhY2VJbmRleCA9IE1hdGguZmxvb3IoaSAvIDMpOyAvLyB0cmlhbmdsZSBudW1iZXIgaW4gaW5kZXhlZCBidWZmZXIgc2VtYW50aWNzXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goaW50ZXJzZWN0aW9uKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHBvc2l0aW9uICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdC8vIG5vbi1pbmRleGVkIGJ1ZmZlciBnZW9tZXRyeVxuXG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShtYXRlcmlhbCkpIHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCBncm91cCA9IGdyb3Vwc1tpXTtcblx0XHRcdFx0XHRjb25zdCBncm91cE1hdGVyaWFsID0gbWF0ZXJpYWxbZ3JvdXAubWF0ZXJpYWxJbmRleF07XG5cdFx0XHRcdFx0Y29uc3Qgc3RhcnQgPSBNYXRoLm1heChncm91cC5zdGFydCwgZHJhd1JhbmdlLnN0YXJ0KTtcblx0XHRcdFx0XHRjb25zdCBlbmQgPSBNYXRoLm1pbihwb3NpdGlvbi5jb3VudCwgTWF0aC5taW4oZ3JvdXAuc3RhcnQgKyBncm91cC5jb3VudCwgZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50KSk7XG5cdFx0XHRcdFx0Zm9yIChsZXQgaiA9IHN0YXJ0LCBqbCA9IGVuZDsgaiA8IGpsOyBqICs9IDMpIHtcblx0XHRcdFx0XHRcdGNvbnN0IGEgPSBqO1xuXHRcdFx0XHRcdFx0Y29uc3QgYiA9IGogKyAxO1xuXHRcdFx0XHRcdFx0Y29uc3QgYyA9IGogKyAyO1xuXHRcdFx0XHRcdFx0aW50ZXJzZWN0aW9uID0gY2hlY2tCdWZmZXJHZW9tZXRyeUludGVyc2VjdGlvbih0aGlzLCBncm91cE1hdGVyaWFsLCByYXljYXN0ZXIsIF9yYXkkMiwgcG9zaXRpb24sIG1vcnBoUG9zaXRpb24sIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLCB1diwgdXYyLCBhLCBiLCBjKTtcblx0XHRcdFx0XHRcdGlmIChpbnRlcnNlY3Rpb24pIHtcblx0XHRcdFx0XHRcdFx0aW50ZXJzZWN0aW9uLmZhY2VJbmRleCA9IE1hdGguZmxvb3IoaiAvIDMpOyAvLyB0cmlhbmdsZSBudW1iZXIgaW4gbm9uLWluZGV4ZWQgYnVmZmVyIHNlbWFudGljc1xuXHRcdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24uZmFjZS5tYXRlcmlhbEluZGV4ID0gZ3JvdXAubWF0ZXJpYWxJbmRleDtcblx0XHRcdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKGludGVyc2VjdGlvbik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zdCBzdGFydCA9IE1hdGgubWF4KDAsIGRyYXdSYW5nZS5zdGFydCk7XG5cdFx0XHRcdGNvbnN0IGVuZCA9IE1hdGgubWluKHBvc2l0aW9uLmNvdW50LCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQpO1xuXHRcdFx0XHRmb3IgKGxldCBpID0gc3RhcnQsIGlsID0gZW5kOyBpIDwgaWw7IGkgKz0gMykge1xuXHRcdFx0XHRcdGNvbnN0IGEgPSBpO1xuXHRcdFx0XHRcdGNvbnN0IGIgPSBpICsgMTtcblx0XHRcdFx0XHRjb25zdCBjID0gaSArIDI7XG5cdFx0XHRcdFx0aW50ZXJzZWN0aW9uID0gY2hlY2tCdWZmZXJHZW9tZXRyeUludGVyc2VjdGlvbih0aGlzLCBtYXRlcmlhbCwgcmF5Y2FzdGVyLCBfcmF5JDIsIHBvc2l0aW9uLCBtb3JwaFBvc2l0aW9uLCBtb3JwaFRhcmdldHNSZWxhdGl2ZSwgdXYsIHV2MiwgYSwgYiwgYyk7XG5cdFx0XHRcdFx0aWYgKGludGVyc2VjdGlvbikge1xuXHRcdFx0XHRcdFx0aW50ZXJzZWN0aW9uLmZhY2VJbmRleCA9IE1hdGguZmxvb3IoaSAvIDMpOyAvLyB0cmlhbmdsZSBudW1iZXIgaW4gbm9uLWluZGV4ZWQgYnVmZmVyIHNlbWFudGljc1xuXHRcdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKGludGVyc2VjdGlvbik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5mdW5jdGlvbiBjaGVja0ludGVyc2VjdGlvbihvYmplY3QsIG1hdGVyaWFsLCByYXljYXN0ZXIsIHJheSwgcEEsIHBCLCBwQywgcG9pbnQpIHtcblx0bGV0IGludGVyc2VjdDtcblx0aWYgKG1hdGVyaWFsLnNpZGUgPT09IEJhY2tTaWRlKSB7XG5cdFx0aW50ZXJzZWN0ID0gcmF5LmludGVyc2VjdFRyaWFuZ2xlKHBDLCBwQiwgcEEsIHRydWUsIHBvaW50KTtcblx0fSBlbHNlIHtcblx0XHRpbnRlcnNlY3QgPSByYXkuaW50ZXJzZWN0VHJpYW5nbGUocEEsIHBCLCBwQywgbWF0ZXJpYWwuc2lkZSAhPT0gRG91YmxlU2lkZSwgcG9pbnQpO1xuXHR9XG5cdGlmIChpbnRlcnNlY3QgPT09IG51bGwpIHJldHVybiBudWxsO1xuXHRfaW50ZXJzZWN0aW9uUG9pbnRXb3JsZC5jb3B5KHBvaW50KTtcblx0X2ludGVyc2VjdGlvblBvaW50V29ybGQuYXBwbHlNYXRyaXg0KG9iamVjdC5tYXRyaXhXb3JsZCk7XG5cdGNvbnN0IGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyhfaW50ZXJzZWN0aW9uUG9pbnRXb3JsZCk7XG5cdGlmIChkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhcikgcmV0dXJuIG51bGw7XG5cdHJldHVybiB7XG5cdFx0ZGlzdGFuY2U6IGRpc3RhbmNlLFxuXHRcdHBvaW50OiBfaW50ZXJzZWN0aW9uUG9pbnRXb3JsZC5jbG9uZSgpLFxuXHRcdG9iamVjdDogb2JqZWN0XG5cdH07XG59XG5mdW5jdGlvbiBjaGVja0J1ZmZlckdlb21ldHJ5SW50ZXJzZWN0aW9uKG9iamVjdCwgbWF0ZXJpYWwsIHJheWNhc3RlciwgcmF5LCBwb3NpdGlvbiwgbW9ycGhQb3NpdGlvbiwgbW9ycGhUYXJnZXRzUmVsYXRpdmUsIHV2LCB1djIsIGEsIGIsIGMpIHtcblx0X3ZBJDEuZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbiwgYSk7XG5cdF92QiQxLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb24sIGIpO1xuXHRfdkMkMS5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uLCBjKTtcblx0Y29uc3QgbW9ycGhJbmZsdWVuY2VzID0gb2JqZWN0Lm1vcnBoVGFyZ2V0SW5mbHVlbmNlcztcblx0aWYgKG1vcnBoUG9zaXRpb24gJiYgbW9ycGhJbmZsdWVuY2VzKSB7XG5cdFx0X21vcnBoQS5zZXQoMCwgMCwgMCk7XG5cdFx0X21vcnBoQi5zZXQoMCwgMCwgMCk7XG5cdFx0X21vcnBoQy5zZXQoMCwgMCwgMCk7XG5cdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gbW9ycGhQb3NpdGlvbi5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRjb25zdCBpbmZsdWVuY2UgPSBtb3JwaEluZmx1ZW5jZXNbaV07XG5cdFx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZSA9IG1vcnBoUG9zaXRpb25baV07XG5cdFx0XHRpZiAoaW5mbHVlbmNlID09PSAwKSBjb250aW51ZTtcblx0XHRcdF90ZW1wQS5mcm9tQnVmZmVyQXR0cmlidXRlKG1vcnBoQXR0cmlidXRlLCBhKTtcblx0XHRcdF90ZW1wQi5mcm9tQnVmZmVyQXR0cmlidXRlKG1vcnBoQXR0cmlidXRlLCBiKTtcblx0XHRcdF90ZW1wQy5mcm9tQnVmZmVyQXR0cmlidXRlKG1vcnBoQXR0cmlidXRlLCBjKTtcblx0XHRcdGlmIChtb3JwaFRhcmdldHNSZWxhdGl2ZSkge1xuXHRcdFx0XHRfbW9ycGhBLmFkZFNjYWxlZFZlY3RvcihfdGVtcEEsIGluZmx1ZW5jZSk7XG5cdFx0XHRcdF9tb3JwaEIuYWRkU2NhbGVkVmVjdG9yKF90ZW1wQiwgaW5mbHVlbmNlKTtcblx0XHRcdFx0X21vcnBoQy5hZGRTY2FsZWRWZWN0b3IoX3RlbXBDLCBpbmZsdWVuY2UpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0X21vcnBoQS5hZGRTY2FsZWRWZWN0b3IoX3RlbXBBLnN1YihfdkEkMSksIGluZmx1ZW5jZSk7XG5cdFx0XHRcdF9tb3JwaEIuYWRkU2NhbGVkVmVjdG9yKF90ZW1wQi5zdWIoX3ZCJDEpLCBpbmZsdWVuY2UpO1xuXHRcdFx0XHRfbW9ycGhDLmFkZFNjYWxlZFZlY3RvcihfdGVtcEMuc3ViKF92QyQxKSwgaW5mbHVlbmNlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0X3ZBJDEuYWRkKF9tb3JwaEEpO1xuXHRcdF92QiQxLmFkZChfbW9ycGhCKTtcblx0XHRfdkMkMS5hZGQoX21vcnBoQyk7XG5cdH1cblx0aWYgKG9iamVjdC5pc1NraW5uZWRNZXNoKSB7XG5cdFx0b2JqZWN0LmJvbmVUcmFuc2Zvcm0oYSwgX3ZBJDEpO1xuXHRcdG9iamVjdC5ib25lVHJhbnNmb3JtKGIsIF92QiQxKTtcblx0XHRvYmplY3QuYm9uZVRyYW5zZm9ybShjLCBfdkMkMSk7XG5cdH1cblx0Y29uc3QgaW50ZXJzZWN0aW9uID0gY2hlY2tJbnRlcnNlY3Rpb24ob2JqZWN0LCBtYXRlcmlhbCwgcmF5Y2FzdGVyLCByYXksIF92QSQxLCBfdkIkMSwgX3ZDJDEsIF9pbnRlcnNlY3Rpb25Qb2ludCk7XG5cdGlmIChpbnRlcnNlY3Rpb24pIHtcblx0XHRpZiAodXYpIHtcblx0XHRcdF91dkEkMS5mcm9tQnVmZmVyQXR0cmlidXRlKHV2LCBhKTtcblx0XHRcdF91dkIkMS5mcm9tQnVmZmVyQXR0cmlidXRlKHV2LCBiKTtcblx0XHRcdF91dkMkMS5mcm9tQnVmZmVyQXR0cmlidXRlKHV2LCBjKTtcblx0XHRcdGludGVyc2VjdGlvbi51diA9IFRyaWFuZ2xlLmdldFVWKF9pbnRlcnNlY3Rpb25Qb2ludCwgX3ZBJDEsIF92QiQxLCBfdkMkMSwgX3V2QSQxLCBfdXZCJDEsIF91dkMkMSwgbmV3IFZlY3RvcjIoKSk7XG5cdFx0fVxuXHRcdGlmICh1djIpIHtcblx0XHRcdF91dkEkMS5mcm9tQnVmZmVyQXR0cmlidXRlKHV2MiwgYSk7XG5cdFx0XHRfdXZCJDEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSh1djIsIGIpO1xuXHRcdFx0X3V2QyQxLmZyb21CdWZmZXJBdHRyaWJ1dGUodXYyLCBjKTtcblx0XHRcdGludGVyc2VjdGlvbi51djIgPSBUcmlhbmdsZS5nZXRVVihfaW50ZXJzZWN0aW9uUG9pbnQsIF92QSQxLCBfdkIkMSwgX3ZDJDEsIF91dkEkMSwgX3V2QiQxLCBfdXZDJDEsIG5ldyBWZWN0b3IyKCkpO1xuXHRcdH1cblx0XHRjb25zdCBmYWNlID0ge1xuXHRcdFx0YTogYSxcblx0XHRcdGI6IGIsXG5cdFx0XHRjOiBjLFxuXHRcdFx0bm9ybWFsOiBuZXcgVmVjdG9yMygpLFxuXHRcdFx0bWF0ZXJpYWxJbmRleDogMFxuXHRcdH07XG5cdFx0VHJpYW5nbGUuZ2V0Tm9ybWFsKF92QSQxLCBfdkIkMSwgX3ZDJDEsIGZhY2Uubm9ybWFsKTtcblx0XHRpbnRlcnNlY3Rpb24uZmFjZSA9IGZhY2U7XG5cdH1cblx0cmV0dXJuIGludGVyc2VjdGlvbjtcbn1cblxuY2xhc3MgQm94R2VvbWV0cnkgZXh0ZW5kcyBCdWZmZXJHZW9tZXRyeSB7XG5cdGNvbnN0cnVjdG9yKHdpZHRoID0gMSwgaGVpZ2h0ID0gMSwgZGVwdGggPSAxLCB3aWR0aFNlZ21lbnRzID0gMSwgaGVpZ2h0U2VnbWVudHMgPSAxLCBkZXB0aFNlZ21lbnRzID0gMSkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy50eXBlID0gJ0JveEdlb21ldHJ5Jztcblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHR3aWR0aDogd2lkdGgsXG5cdFx0XHRoZWlnaHQ6IGhlaWdodCxcblx0XHRcdGRlcHRoOiBkZXB0aCxcblx0XHRcdHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXG5cdFx0XHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXG5cdFx0XHRkZXB0aFNlZ21lbnRzOiBkZXB0aFNlZ21lbnRzXG5cdFx0fTtcblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cblx0XHQvLyBzZWdtZW50c1xuXG5cdFx0d2lkdGhTZWdtZW50cyA9IE1hdGguZmxvb3Iod2lkdGhTZWdtZW50cyk7XG5cdFx0aGVpZ2h0U2VnbWVudHMgPSBNYXRoLmZsb29yKGhlaWdodFNlZ21lbnRzKTtcblx0XHRkZXB0aFNlZ21lbnRzID0gTWF0aC5mbG9vcihkZXB0aFNlZ21lbnRzKTtcblxuXHRcdC8vIGJ1ZmZlcnNcblxuXHRcdGNvbnN0IGluZGljZXMgPSBbXTtcblx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcblx0XHRjb25zdCB1dnMgPSBbXTtcblxuXHRcdC8vIGhlbHBlciB2YXJpYWJsZXNcblxuXHRcdGxldCBudW1iZXJPZlZlcnRpY2VzID0gMDtcblx0XHRsZXQgZ3JvdXBTdGFydCA9IDA7XG5cblx0XHQvLyBidWlsZCBlYWNoIHNpZGUgb2YgdGhlIGJveCBnZW9tZXRyeVxuXG5cdFx0YnVpbGRQbGFuZSgneicsICd5JywgJ3gnLCAtMSwgLTEsIGRlcHRoLCBoZWlnaHQsIHdpZHRoLCBkZXB0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgMCk7IC8vIHB4XG5cdFx0YnVpbGRQbGFuZSgneicsICd5JywgJ3gnLCAxLCAtMSwgZGVwdGgsIGhlaWdodCwgLXdpZHRoLCBkZXB0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgMSk7IC8vIG54XG5cdFx0YnVpbGRQbGFuZSgneCcsICd6JywgJ3knLCAxLCAxLCB3aWR0aCwgZGVwdGgsIGhlaWdodCwgd2lkdGhTZWdtZW50cywgZGVwdGhTZWdtZW50cywgMik7IC8vIHB5XG5cdFx0YnVpbGRQbGFuZSgneCcsICd6JywgJ3knLCAxLCAtMSwgd2lkdGgsIGRlcHRoLCAtaGVpZ2h0LCB3aWR0aFNlZ21lbnRzLCBkZXB0aFNlZ21lbnRzLCAzKTsgLy8gbnlcblx0XHRidWlsZFBsYW5lKCd4JywgJ3knLCAneicsIDEsIC0xLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIDQpOyAvLyBwelxuXHRcdGJ1aWxkUGxhbmUoJ3gnLCAneScsICd6JywgLTEsIC0xLCB3aWR0aCwgaGVpZ2h0LCAtZGVwdGgsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCA1KTsgLy8gbnpcblxuXHRcdC8vIGJ1aWxkIGdlb21ldHJ5XG5cblx0XHR0aGlzLnNldEluZGV4KGluZGljZXMpO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHZlcnRpY2VzLCAzKSk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKG5vcm1hbHMsIDMpKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSgndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh1dnMsIDIpKTtcblx0XHRmdW5jdGlvbiBidWlsZFBsYW5lKHUsIHYsIHcsIHVkaXIsIHZkaXIsIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCBncmlkWCwgZ3JpZFksIG1hdGVyaWFsSW5kZXgpIHtcblx0XHRcdGNvbnN0IHNlZ21lbnRXaWR0aCA9IHdpZHRoIC8gZ3JpZFg7XG5cdFx0XHRjb25zdCBzZWdtZW50SGVpZ2h0ID0gaGVpZ2h0IC8gZ3JpZFk7XG5cdFx0XHRjb25zdCB3aWR0aEhhbGYgPSB3aWR0aCAvIDI7XG5cdFx0XHRjb25zdCBoZWlnaHRIYWxmID0gaGVpZ2h0IC8gMjtcblx0XHRcdGNvbnN0IGRlcHRoSGFsZiA9IGRlcHRoIC8gMjtcblx0XHRcdGNvbnN0IGdyaWRYMSA9IGdyaWRYICsgMTtcblx0XHRcdGNvbnN0IGdyaWRZMSA9IGdyaWRZICsgMTtcblx0XHRcdGxldCB2ZXJ0ZXhDb3VudGVyID0gMDtcblx0XHRcdGxldCBncm91cENvdW50ID0gMDtcblx0XHRcdGNvbnN0IHZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdC8vIGdlbmVyYXRlIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcblxuXHRcdFx0Zm9yIChsZXQgaXkgPSAwOyBpeSA8IGdyaWRZMTsgaXkrKykge1xuXHRcdFx0XHRjb25zdCB5ID0gaXkgKiBzZWdtZW50SGVpZ2h0IC0gaGVpZ2h0SGFsZjtcblx0XHRcdFx0Zm9yIChsZXQgaXggPSAwOyBpeCA8IGdyaWRYMTsgaXgrKykge1xuXHRcdFx0XHRcdGNvbnN0IHggPSBpeCAqIHNlZ21lbnRXaWR0aCAtIHdpZHRoSGFsZjtcblxuXHRcdFx0XHRcdC8vIHNldCB2YWx1ZXMgdG8gY29ycmVjdCB2ZWN0b3IgY29tcG9uZW50XG5cblx0XHRcdFx0XHR2ZWN0b3JbdV0gPSB4ICogdWRpcjtcblx0XHRcdFx0XHR2ZWN0b3Jbdl0gPSB5ICogdmRpcjtcblx0XHRcdFx0XHR2ZWN0b3Jbd10gPSBkZXB0aEhhbGY7XG5cblx0XHRcdFx0XHQvLyBub3cgYXBwbHkgdmVjdG9yIHRvIHZlcnRleCBidWZmZXJcblxuXHRcdFx0XHRcdHZlcnRpY2VzLnB1c2godmVjdG9yLngsIHZlY3Rvci55LCB2ZWN0b3Iueik7XG5cblx0XHRcdFx0XHQvLyBzZXQgdmFsdWVzIHRvIGNvcnJlY3QgdmVjdG9yIGNvbXBvbmVudFxuXG5cdFx0XHRcdFx0dmVjdG9yW3VdID0gMDtcblx0XHRcdFx0XHR2ZWN0b3Jbdl0gPSAwO1xuXHRcdFx0XHRcdHZlY3Rvclt3XSA9IGRlcHRoID4gMCA/IDEgOiAtMTtcblxuXHRcdFx0XHRcdC8vIG5vdyBhcHBseSB2ZWN0b3IgdG8gbm9ybWFsIGJ1ZmZlclxuXG5cdFx0XHRcdFx0bm9ybWFscy5wdXNoKHZlY3Rvci54LCB2ZWN0b3IueSwgdmVjdG9yLnopO1xuXG5cdFx0XHRcdFx0Ly8gdXZzXG5cblx0XHRcdFx0XHR1dnMucHVzaChpeCAvIGdyaWRYKTtcblx0XHRcdFx0XHR1dnMucHVzaCgxIC0gaXkgLyBncmlkWSk7XG5cblx0XHRcdFx0XHQvLyBjb3VudGVyc1xuXG5cdFx0XHRcdFx0dmVydGV4Q291bnRlciArPSAxO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGluZGljZXNcblxuXHRcdFx0Ly8gMS4geW91IG5lZWQgdGhyZWUgaW5kaWNlcyB0byBkcmF3IGEgc2luZ2xlIGZhY2Vcblx0XHRcdC8vIDIuIGEgc2luZ2xlIHNlZ21lbnQgY29uc2lzdHMgb2YgdHdvIGZhY2VzXG5cdFx0XHQvLyAzLiBzbyB3ZSBuZWVkIHRvIGdlbmVyYXRlIHNpeCAoMiozKSBpbmRpY2VzIHBlciBzZWdtZW50XG5cblx0XHRcdGZvciAobGV0IGl5ID0gMDsgaXkgPCBncmlkWTsgaXkrKykge1xuXHRcdFx0XHRmb3IgKGxldCBpeCA9IDA7IGl4IDwgZ3JpZFg7IGl4KyspIHtcblx0XHRcdFx0XHRjb25zdCBhID0gbnVtYmVyT2ZWZXJ0aWNlcyArIGl4ICsgZ3JpZFgxICogaXk7XG5cdFx0XHRcdFx0Y29uc3QgYiA9IG51bWJlck9mVmVydGljZXMgKyBpeCArIGdyaWRYMSAqIChpeSArIDEpO1xuXHRcdFx0XHRcdGNvbnN0IGMgPSBudW1iZXJPZlZlcnRpY2VzICsgKGl4ICsgMSkgKyBncmlkWDEgKiAoaXkgKyAxKTtcblx0XHRcdFx0XHRjb25zdCBkID0gbnVtYmVyT2ZWZXJ0aWNlcyArIChpeCArIDEpICsgZ3JpZFgxICogaXk7XG5cblx0XHRcdFx0XHQvLyBmYWNlc1xuXG5cdFx0XHRcdFx0aW5kaWNlcy5wdXNoKGEsIGIsIGQpO1xuXHRcdFx0XHRcdGluZGljZXMucHVzaChiLCBjLCBkKTtcblxuXHRcdFx0XHRcdC8vIGluY3JlYXNlIGNvdW50ZXJcblxuXHRcdFx0XHRcdGdyb3VwQ291bnQgKz0gNjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBhZGQgYSBncm91cCB0byB0aGUgZ2VvbWV0cnkuIHRoaXMgd2lsbCBlbnN1cmUgbXVsdGkgbWF0ZXJpYWwgc3VwcG9ydFxuXG5cdFx0XHRzY29wZS5hZGRHcm91cChncm91cFN0YXJ0LCBncm91cENvdW50LCBtYXRlcmlhbEluZGV4KTtcblxuXHRcdFx0Ly8gY2FsY3VsYXRlIG5ldyBzdGFydCB2YWx1ZSBmb3IgZ3JvdXBzXG5cblx0XHRcdGdyb3VwU3RhcnQgKz0gZ3JvdXBDb3VudDtcblxuXHRcdFx0Ly8gdXBkYXRlIHRvdGFsIG51bWJlciBvZiB2ZXJ0aWNlc1xuXG5cdFx0XHRudW1iZXJPZlZlcnRpY2VzICs9IHZlcnRleENvdW50ZXI7XG5cdFx0fVxuXHR9XG5cdHN0YXRpYyBmcm9tSlNPTihkYXRhKSB7XG5cdFx0cmV0dXJuIG5ldyBCb3hHZW9tZXRyeShkYXRhLndpZHRoLCBkYXRhLmhlaWdodCwgZGF0YS5kZXB0aCwgZGF0YS53aWR0aFNlZ21lbnRzLCBkYXRhLmhlaWdodFNlZ21lbnRzLCBkYXRhLmRlcHRoU2VnbWVudHMpO1xuXHR9XG59XG5cbi8qKlxuICogVW5pZm9ybSBVdGlsaXRpZXNcbiAqL1xuXG5mdW5jdGlvbiBjbG9uZVVuaWZvcm1zKHNyYykge1xuXHRjb25zdCBkc3QgPSB7fTtcblx0Zm9yIChjb25zdCB1IGluIHNyYykge1xuXHRcdGRzdFt1XSA9IHt9O1xuXHRcdGZvciAoY29uc3QgcCBpbiBzcmNbdV0pIHtcblx0XHRcdGNvbnN0IHByb3BlcnR5ID0gc3JjW3VdW3BdO1xuXHRcdFx0aWYgKHByb3BlcnR5ICYmIChwcm9wZXJ0eS5pc0NvbG9yIHx8IHByb3BlcnR5LmlzTWF0cml4MyB8fCBwcm9wZXJ0eS5pc01hdHJpeDQgfHwgcHJvcGVydHkuaXNWZWN0b3IyIHx8IHByb3BlcnR5LmlzVmVjdG9yMyB8fCBwcm9wZXJ0eS5pc1ZlY3RvcjQgfHwgcHJvcGVydHkuaXNUZXh0dXJlIHx8IHByb3BlcnR5LmlzUXVhdGVybmlvbikpIHtcblx0XHRcdFx0ZHN0W3VdW3BdID0gcHJvcGVydHkuY2xvbmUoKTtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwcm9wZXJ0eSkpIHtcblx0XHRcdFx0ZHN0W3VdW3BdID0gcHJvcGVydHkuc2xpY2UoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRzdFt1XVtwXSA9IHByb3BlcnR5O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gZHN0O1xufVxuZnVuY3Rpb24gbWVyZ2VVbmlmb3Jtcyh1bmlmb3Jtcykge1xuXHRjb25zdCBtZXJnZWQgPSB7fTtcblx0Zm9yIChsZXQgdSA9IDA7IHUgPCB1bmlmb3Jtcy5sZW5ndGg7IHUrKykge1xuXHRcdGNvbnN0IHRtcCA9IGNsb25lVW5pZm9ybXModW5pZm9ybXNbdV0pO1xuXHRcdGZvciAoY29uc3QgcCBpbiB0bXApIHtcblx0XHRcdG1lcmdlZFtwXSA9IHRtcFtwXTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG1lcmdlZDtcbn1cbmZ1bmN0aW9uIGNsb25lVW5pZm9ybXNHcm91cHMoc3JjKSB7XG5cdGNvbnN0IGRzdCA9IFtdO1xuXHRmb3IgKGxldCB1ID0gMDsgdSA8IHNyYy5sZW5ndGg7IHUrKykge1xuXHRcdGRzdC5wdXNoKHNyY1t1XS5jbG9uZSgpKTtcblx0fVxuXHRyZXR1cm4gZHN0O1xufVxuXG4vLyBMZWdhY3lcblxuY29uc3QgVW5pZm9ybXNVdGlscyA9IHtcblx0Y2xvbmU6IGNsb25lVW5pZm9ybXMsXG5cdG1lcmdlOiBtZXJnZVVuaWZvcm1zXG59O1xuXG52YXIgZGVmYXVsdF92ZXJ0ZXggPSBcInZvaWQgbWFpbigpIHtcXG5cXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XFxufVwiO1xuXG52YXIgZGVmYXVsdF9mcmFnbWVudCA9IFwidm9pZCBtYWluKCkge1xcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIDEuMCwgMC4wLCAwLjAsIDEuMCApO1xcbn1cIjtcblxuY2xhc3MgU2hhZGVyTWF0ZXJpYWwgZXh0ZW5kcyBNYXRlcmlhbCB7XG5cdGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuaXNTaGFkZXJNYXRlcmlhbCA9IHRydWU7XG5cdFx0dGhpcy50eXBlID0gJ1NoYWRlck1hdGVyaWFsJztcblx0XHR0aGlzLmRlZmluZXMgPSB7fTtcblx0XHR0aGlzLnVuaWZvcm1zID0ge307XG5cdFx0dGhpcy51bmlmb3Jtc0dyb3VwcyA9IFtdO1xuXHRcdHRoaXMudmVydGV4U2hhZGVyID0gZGVmYXVsdF92ZXJ0ZXg7XG5cdFx0dGhpcy5mcmFnbWVudFNoYWRlciA9IGRlZmF1bHRfZnJhZ21lbnQ7XG5cdFx0dGhpcy5saW5ld2lkdGggPSAxO1xuXHRcdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuXHRcdHRoaXMuZm9nID0gZmFsc2U7IC8vIHNldCB0byB1c2Ugc2NlbmUgZm9nXG5cdFx0dGhpcy5saWdodHMgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBzY2VuZSBsaWdodHNcblx0XHR0aGlzLmNsaXBwaW5nID0gZmFsc2U7IC8vIHNldCB0byB1c2UgdXNlci1kZWZpbmVkIGNsaXBwaW5nIHBsYW5lc1xuXG5cdFx0dGhpcy5leHRlbnNpb25zID0ge1xuXHRcdFx0ZGVyaXZhdGl2ZXM6IGZhbHNlLFxuXHRcdFx0Ly8gc2V0IHRvIHVzZSBkZXJpdmF0aXZlc1xuXHRcdFx0ZnJhZ0RlcHRoOiBmYWxzZSxcblx0XHRcdC8vIHNldCB0byB1c2UgZnJhZ21lbnQgZGVwdGggdmFsdWVzXG5cdFx0XHRkcmF3QnVmZmVyczogZmFsc2UsXG5cdFx0XHQvLyBzZXQgdG8gdXNlIGRyYXcgYnVmZmVyc1xuXHRcdFx0c2hhZGVyVGV4dHVyZUxPRDogZmFsc2UgLy8gc2V0IHRvIHVzZSBzaGFkZXIgdGV4dHVyZSBMT0Rcblx0XHR9O1xuXG5cdFx0Ly8gV2hlbiByZW5kZXJlZCBnZW9tZXRyeSBkb2Vzbid0IGluY2x1ZGUgdGhlc2UgYXR0cmlidXRlcyBidXQgdGhlIG1hdGVyaWFsIGRvZXMsXG5cdFx0Ly8gdXNlIHRoZXNlIGRlZmF1bHQgdmFsdWVzIGluIFdlYkdMLiBUaGlzIGF2b2lkcyBlcnJvcnMgd2hlbiBidWZmZXIgZGF0YSBpcyBtaXNzaW5nLlxuXHRcdHRoaXMuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlcyA9IHtcblx0XHRcdCdjb2xvcic6IFsxLCAxLCAxXSxcblx0XHRcdCd1dic6IFswLCAwXSxcblx0XHRcdCd1djInOiBbMCwgMF1cblx0XHR9O1xuXHRcdHRoaXMuaW5kZXgwQXR0cmlidXRlTmFtZSA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLnVuaWZvcm1zTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXHRcdHRoaXMuZ2xzbFZlcnNpb24gPSBudWxsO1xuXHRcdGlmIChwYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKHBhcmFtZXRlcnMpO1xuXHRcdH1cblx0fVxuXHRjb3B5KHNvdXJjZSkge1xuXHRcdHN1cGVyLmNvcHkoc291cmNlKTtcblx0XHR0aGlzLmZyYWdtZW50U2hhZGVyID0gc291cmNlLmZyYWdtZW50U2hhZGVyO1xuXHRcdHRoaXMudmVydGV4U2hhZGVyID0gc291cmNlLnZlcnRleFNoYWRlcjtcblx0XHR0aGlzLnVuaWZvcm1zID0gY2xvbmVVbmlmb3Jtcyhzb3VyY2UudW5pZm9ybXMpO1xuXHRcdHRoaXMudW5pZm9ybXNHcm91cHMgPSBjbG9uZVVuaWZvcm1zR3JvdXBzKHNvdXJjZS51bmlmb3Jtc0dyb3Vwcyk7XG5cdFx0dGhpcy5kZWZpbmVzID0gT2JqZWN0LmFzc2lnbih7fSwgc291cmNlLmRlZmluZXMpO1xuXHRcdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XG5cdFx0dGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xuXHRcdHRoaXMubGlnaHRzID0gc291cmNlLmxpZ2h0cztcblx0XHR0aGlzLmNsaXBwaW5nID0gc291cmNlLmNsaXBwaW5nO1xuXHRcdHRoaXMuZXh0ZW5zaW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHNvdXJjZS5leHRlbnNpb25zKTtcblx0XHR0aGlzLmdsc2xWZXJzaW9uID0gc291cmNlLmdsc2xWZXJzaW9uO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHRvSlNPTihtZXRhKSB7XG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTihtZXRhKTtcblx0XHRkYXRhLmdsc2xWZXJzaW9uID0gdGhpcy5nbHNsVmVyc2lvbjtcblx0XHRkYXRhLnVuaWZvcm1zID0ge307XG5cdFx0Zm9yIChjb25zdCBuYW1lIGluIHRoaXMudW5pZm9ybXMpIHtcblx0XHRcdGNvbnN0IHVuaWZvcm0gPSB0aGlzLnVuaWZvcm1zW25hbWVdO1xuXHRcdFx0Y29uc3QgdmFsdWUgPSB1bmlmb3JtLnZhbHVlO1xuXHRcdFx0aWYgKHZhbHVlICYmIHZhbHVlLmlzVGV4dHVyZSkge1xuXHRcdFx0XHRkYXRhLnVuaWZvcm1zW25hbWVdID0ge1xuXHRcdFx0XHRcdHR5cGU6ICd0Jyxcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWUudG9KU09OKG1ldGEpLnV1aWRcblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSBpZiAodmFsdWUgJiYgdmFsdWUuaXNDb2xvcikge1xuXHRcdFx0XHRkYXRhLnVuaWZvcm1zW25hbWVdID0ge1xuXHRcdFx0XHRcdHR5cGU6ICdjJyxcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWUuZ2V0SGV4KClcblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSBpZiAodmFsdWUgJiYgdmFsdWUuaXNWZWN0b3IyKSB7XG5cdFx0XHRcdGRhdGEudW5pZm9ybXNbbmFtZV0gPSB7XG5cdFx0XHRcdFx0dHlwZTogJ3YyJyxcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWUudG9BcnJheSgpXG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2UgaWYgKHZhbHVlICYmIHZhbHVlLmlzVmVjdG9yMykge1xuXHRcdFx0XHRkYXRhLnVuaWZvcm1zW25hbWVdID0ge1xuXHRcdFx0XHRcdHR5cGU6ICd2MycsXG5cdFx0XHRcdFx0dmFsdWU6IHZhbHVlLnRvQXJyYXkoKVxuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIGlmICh2YWx1ZSAmJiB2YWx1ZS5pc1ZlY3RvcjQpIHtcblx0XHRcdFx0ZGF0YS51bmlmb3Jtc1tuYW1lXSA9IHtcblx0XHRcdFx0XHR0eXBlOiAndjQnLFxuXHRcdFx0XHRcdHZhbHVlOiB2YWx1ZS50b0FycmF5KClcblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSBpZiAodmFsdWUgJiYgdmFsdWUuaXNNYXRyaXgzKSB7XG5cdFx0XHRcdGRhdGEudW5pZm9ybXNbbmFtZV0gPSB7XG5cdFx0XHRcdFx0dHlwZTogJ20zJyxcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWUudG9BcnJheSgpXG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2UgaWYgKHZhbHVlICYmIHZhbHVlLmlzTWF0cml4NCkge1xuXHRcdFx0XHRkYXRhLnVuaWZvcm1zW25hbWVdID0ge1xuXHRcdFx0XHRcdHR5cGU6ICdtNCcsXG5cdFx0XHRcdFx0dmFsdWU6IHZhbHVlLnRvQXJyYXkoKVxuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGF0YS51bmlmb3Jtc1tuYW1lXSA9IHtcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWVcblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvLyBub3RlOiB0aGUgYXJyYXkgdmFyaWFudHMgdjJ2LCB2M3YsIHY0diwgbTR2IGFuZCB0diBhcmUgbm90IHN1cHBvcnRlZCBzbyBmYXJcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoT2JqZWN0LmtleXModGhpcy5kZWZpbmVzKS5sZW5ndGggPiAwKSBkYXRhLmRlZmluZXMgPSB0aGlzLmRlZmluZXM7XG5cdFx0ZGF0YS52ZXJ0ZXhTaGFkZXIgPSB0aGlzLnZlcnRleFNoYWRlcjtcblx0XHRkYXRhLmZyYWdtZW50U2hhZGVyID0gdGhpcy5mcmFnbWVudFNoYWRlcjtcblx0XHRjb25zdCBleHRlbnNpb25zID0ge307XG5cdFx0Zm9yIChjb25zdCBrZXkgaW4gdGhpcy5leHRlbnNpb25zKSB7XG5cdFx0XHRpZiAodGhpcy5leHRlbnNpb25zW2tleV0gPT09IHRydWUpIGV4dGVuc2lvbnNba2V5XSA9IHRydWU7XG5cdFx0fVxuXHRcdGlmIChPYmplY3Qua2V5cyhleHRlbnNpb25zKS5sZW5ndGggPiAwKSBkYXRhLmV4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xuXHRcdHJldHVybiBkYXRhO1xuXHR9XG59XG5cbmNsYXNzIENhbWVyYSBleHRlbmRzIE9iamVjdDNEIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLmlzQ2FtZXJhID0gdHJ1ZTtcblx0XHR0aGlzLnR5cGUgPSAnQ2FtZXJhJztcblx0XHR0aGlzLm1hdHJpeFdvcmxkSW52ZXJzZSA9IG5ldyBNYXRyaXg0KCk7XG5cdFx0dGhpcy5wcm9qZWN0aW9uTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblx0XHR0aGlzLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlID0gbmV3IE1hdHJpeDQoKTtcblx0fVxuXHRjb3B5KHNvdXJjZSwgcmVjdXJzaXZlKSB7XG5cdFx0c3VwZXIuY29weShzb3VyY2UsIHJlY3Vyc2l2ZSk7XG5cdFx0dGhpcy5tYXRyaXhXb3JsZEludmVyc2UuY29weShzb3VyY2UubWF0cml4V29ybGRJbnZlcnNlKTtcblx0XHR0aGlzLnByb2plY3Rpb25NYXRyaXguY29weShzb3VyY2UucHJvamVjdGlvbk1hdHJpeCk7XG5cdFx0dGhpcy5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZS5jb3B5KHNvdXJjZS5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0Z2V0V29ybGREaXJlY3Rpb24odGFyZ2V0KSB7XG5cdFx0dGhpcy51cGRhdGVXb3JsZE1hdHJpeCh0cnVlLCBmYWxzZSk7XG5cdFx0Y29uc3QgZSA9IHRoaXMubWF0cml4V29ybGQuZWxlbWVudHM7XG5cdFx0cmV0dXJuIHRhcmdldC5zZXQoLWVbOF0sIC1lWzldLCAtZVsxMF0pLm5vcm1hbGl6ZSgpO1xuXHR9XG5cdHVwZGF0ZU1hdHJpeFdvcmxkKGZvcmNlKSB7XG5cdFx0c3VwZXIudXBkYXRlTWF0cml4V29ybGQoZm9yY2UpO1xuXHRcdHRoaXMubWF0cml4V29ybGRJbnZlcnNlLmNvcHkodGhpcy5tYXRyaXhXb3JsZCkuaW52ZXJ0KCk7XG5cdH1cblx0dXBkYXRlV29ybGRNYXRyaXgodXBkYXRlUGFyZW50cywgdXBkYXRlQ2hpbGRyZW4pIHtcblx0XHRzdXBlci51cGRhdGVXb3JsZE1hdHJpeCh1cGRhdGVQYXJlbnRzLCB1cGRhdGVDaGlsZHJlbik7XG5cdFx0dGhpcy5tYXRyaXhXb3JsZEludmVyc2UuY29weSh0aGlzLm1hdHJpeFdvcmxkKS5pbnZlcnQoKTtcblx0fVxuXHRjbG9uZSgpIHtcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpO1xuXHR9XG59XG5cbmNsYXNzIFBlcnNwZWN0aXZlQ2FtZXJhIGV4dGVuZHMgQ2FtZXJhIHtcblx0Y29uc3RydWN0b3IoZm92ID0gNTAsIGFzcGVjdCA9IDEsIG5lYXIgPSAwLjEsIGZhciA9IDIwMDApIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuaXNQZXJzcGVjdGl2ZUNhbWVyYSA9IHRydWU7XG5cdFx0dGhpcy50eXBlID0gJ1BlcnNwZWN0aXZlQ2FtZXJhJztcblx0XHR0aGlzLmZvdiA9IGZvdjtcblx0XHR0aGlzLnpvb20gPSAxO1xuXHRcdHRoaXMubmVhciA9IG5lYXI7XG5cdFx0dGhpcy5mYXIgPSBmYXI7XG5cdFx0dGhpcy5mb2N1cyA9IDEwO1xuXHRcdHRoaXMuYXNwZWN0ID0gYXNwZWN0O1xuXHRcdHRoaXMudmlldyA9IG51bGw7XG5cdFx0dGhpcy5maWxtR2F1Z2UgPSAzNTsgLy8gd2lkdGggb2YgdGhlIGZpbG0gKGRlZmF1bHQgaW4gbWlsbGltZXRlcnMpXG5cdFx0dGhpcy5maWxtT2Zmc2V0ID0gMDsgLy8gaG9yaXpvbnRhbCBmaWxtIG9mZnNldCAoc2FtZSB1bml0IGFzIGdhdWdlKVxuXG5cdFx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cdH1cblx0Y29weShzb3VyY2UsIHJlY3Vyc2l2ZSkge1xuXHRcdHN1cGVyLmNvcHkoc291cmNlLCByZWN1cnNpdmUpO1xuXHRcdHRoaXMuZm92ID0gc291cmNlLmZvdjtcblx0XHR0aGlzLnpvb20gPSBzb3VyY2Uuem9vbTtcblx0XHR0aGlzLm5lYXIgPSBzb3VyY2UubmVhcjtcblx0XHR0aGlzLmZhciA9IHNvdXJjZS5mYXI7XG5cdFx0dGhpcy5mb2N1cyA9IHNvdXJjZS5mb2N1cztcblx0XHR0aGlzLmFzcGVjdCA9IHNvdXJjZS5hc3BlY3Q7XG5cdFx0dGhpcy52aWV3ID0gc291cmNlLnZpZXcgPT09IG51bGwgPyBudWxsIDogT2JqZWN0LmFzc2lnbih7fSwgc291cmNlLnZpZXcpO1xuXHRcdHRoaXMuZmlsbUdhdWdlID0gc291cmNlLmZpbG1HYXVnZTtcblx0XHR0aGlzLmZpbG1PZmZzZXQgPSBzb3VyY2UuZmlsbU9mZnNldDtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBGT1YgYnkgZm9jYWwgbGVuZ3RoIGluIHJlc3BlY3QgdG8gdGhlIGN1cnJlbnQgLmZpbG1HYXVnZS5cblx0ICpcblx0ICogVGhlIGRlZmF1bHQgZmlsbSBnYXVnZSBpcyAzNSwgc28gdGhhdCB0aGUgZm9jYWwgbGVuZ3RoIGNhbiBiZSBzcGVjaWZpZWQgZm9yXG5cdCAqIGEgMzVtbSAoZnVsbCBmcmFtZSkgY2FtZXJhLlxuXHQgKlxuXHQgKiBWYWx1ZXMgZm9yIGZvY2FsIGxlbmd0aCBhbmQgZmlsbSBnYXVnZSBtdXN0IGhhdmUgdGhlIHNhbWUgdW5pdC5cblx0ICovXG5cdHNldEZvY2FsTGVuZ3RoKGZvY2FsTGVuZ3RoKSB7XG5cdFx0LyoqIHNlZSB7QGxpbmsgaHR0cDovL3d3dy5ib2JhdGtpbnMuY29tL3Bob3RvZ3JhcGh5L3RlY2huaWNhbC9maWVsZF9vZl92aWV3Lmh0bWx9ICovXG5cdFx0Y29uc3QgdkV4dGVudFNsb3BlID0gMC41ICogdGhpcy5nZXRGaWxtSGVpZ2h0KCkgLyBmb2NhbExlbmd0aDtcblx0XHR0aGlzLmZvdiA9IFJBRDJERUcgKiAyICogTWF0aC5hdGFuKHZFeHRlbnRTbG9wZSk7XG5cdFx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cdH1cblxuXHQvKipcblx0ICogQ2FsY3VsYXRlcyB0aGUgZm9jYWwgbGVuZ3RoIGZyb20gdGhlIGN1cnJlbnQgLmZvdiBhbmQgLmZpbG1HYXVnZS5cblx0ICovXG5cdGdldEZvY2FsTGVuZ3RoKCkge1xuXHRcdGNvbnN0IHZFeHRlbnRTbG9wZSA9IE1hdGgudGFuKERFRzJSQUQgKiAwLjUgKiB0aGlzLmZvdik7XG5cdFx0cmV0dXJuIDAuNSAqIHRoaXMuZ2V0RmlsbUhlaWdodCgpIC8gdkV4dGVudFNsb3BlO1xuXHR9XG5cdGdldEVmZmVjdGl2ZUZPVigpIHtcblx0XHRyZXR1cm4gUkFEMkRFRyAqIDIgKiBNYXRoLmF0YW4oTWF0aC50YW4oREVHMlJBRCAqIDAuNSAqIHRoaXMuZm92KSAvIHRoaXMuem9vbSk7XG5cdH1cblx0Z2V0RmlsbVdpZHRoKCkge1xuXHRcdC8vIGZpbG0gbm90IGNvbXBsZXRlbHkgY292ZXJlZCBpbiBwb3J0cmFpdCBmb3JtYXQgKGFzcGVjdCA8IDEpXG5cdFx0cmV0dXJuIHRoaXMuZmlsbUdhdWdlICogTWF0aC5taW4odGhpcy5hc3BlY3QsIDEpO1xuXHR9XG5cdGdldEZpbG1IZWlnaHQoKSB7XG5cdFx0Ly8gZmlsbSBub3QgY29tcGxldGVseSBjb3ZlcmVkIGluIGxhbmRzY2FwZSBmb3JtYXQgKGFzcGVjdCA+IDEpXG5cdFx0cmV0dXJuIHRoaXMuZmlsbUdhdWdlIC8gTWF0aC5tYXgodGhpcy5hc3BlY3QsIDEpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgYW4gb2Zmc2V0IGluIGEgbGFyZ2VyIGZydXN0dW0uIFRoaXMgaXMgdXNlZnVsIGZvciBtdWx0aS13aW5kb3cgb3Jcblx0ICogbXVsdGktbW9uaXRvci9tdWx0aS1tYWNoaW5lIHNldHVwcy5cblx0ICpcblx0ICogRm9yIGV4YW1wbGUsIGlmIHlvdSBoYXZlIDN4MiBtb25pdG9ycyBhbmQgZWFjaCBtb25pdG9yIGlzIDE5MjB4MTA4MCBhbmRcblx0ICogdGhlIG1vbml0b3JzIGFyZSBpbiBncmlkIGxpa2UgdGhpc1xuXHQgKlxuXHQgKlx0ICstLS0rLS0tKy0tLStcblx0ICpcdCB8IEEgfCBCIHwgQyB8XG5cdCAqXHQgKy0tLSstLS0rLS0tK1xuXHQgKlx0IHwgRCB8IEUgfCBGIHxcblx0ICpcdCArLS0tKy0tLSstLS0rXG5cdCAqXG5cdCAqIHRoZW4gZm9yIGVhY2ggbW9uaXRvciB5b3Ugd291bGQgY2FsbCBpdCBsaWtlIHRoaXNcblx0ICpcblx0ICpcdCBjb25zdCB3ID0gMTkyMDtcblx0ICpcdCBjb25zdCBoID0gMTA4MDtcblx0ICpcdCBjb25zdCBmdWxsV2lkdGggPSB3ICogMztcblx0ICpcdCBjb25zdCBmdWxsSGVpZ2h0ID0gaCAqIDI7XG5cdCAqXG5cdCAqXHQgLS1BLS1cblx0ICpcdCBjYW1lcmEuc2V0Vmlld09mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMCwgaCAqIDAsIHcsIGggKTtcblx0ICpcdCAtLUItLVxuXHQgKlx0IGNhbWVyYS5zZXRWaWV3T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAxLCBoICogMCwgdywgaCApO1xuXHQgKlx0IC0tQy0tXG5cdCAqXHQgY2FtZXJhLnNldFZpZXdPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDIsIGggKiAwLCB3LCBoICk7XG5cdCAqXHQgLS1ELS1cblx0ICpcdCBjYW1lcmEuc2V0Vmlld09mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMCwgaCAqIDEsIHcsIGggKTtcblx0ICpcdCAtLUUtLVxuXHQgKlx0IGNhbWVyYS5zZXRWaWV3T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAxLCBoICogMSwgdywgaCApO1xuXHQgKlx0IC0tRi0tXG5cdCAqXHQgY2FtZXJhLnNldFZpZXdPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDIsIGggKiAxLCB3LCBoICk7XG5cdCAqXG5cdCAqXHQgTm90ZSB0aGVyZSBpcyBubyByZWFzb24gbW9uaXRvcnMgaGF2ZSB0byBiZSB0aGUgc2FtZSBzaXplIG9yIGluIGEgZ3JpZC5cblx0ICovXG5cdHNldFZpZXdPZmZzZXQoZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0dGhpcy5hc3BlY3QgPSBmdWxsV2lkdGggLyBmdWxsSGVpZ2h0O1xuXHRcdGlmICh0aGlzLnZpZXcgPT09IG51bGwpIHtcblx0XHRcdHRoaXMudmlldyA9IHtcblx0XHRcdFx0ZW5hYmxlZDogdHJ1ZSxcblx0XHRcdFx0ZnVsbFdpZHRoOiAxLFxuXHRcdFx0XHRmdWxsSGVpZ2h0OiAxLFxuXHRcdFx0XHRvZmZzZXRYOiAwLFxuXHRcdFx0XHRvZmZzZXRZOiAwLFxuXHRcdFx0XHR3aWR0aDogMSxcblx0XHRcdFx0aGVpZ2h0OiAxXG5cdFx0XHR9O1xuXHRcdH1cblx0XHR0aGlzLnZpZXcuZW5hYmxlZCA9IHRydWU7XG5cdFx0dGhpcy52aWV3LmZ1bGxXaWR0aCA9IGZ1bGxXaWR0aDtcblx0XHR0aGlzLnZpZXcuZnVsbEhlaWdodCA9IGZ1bGxIZWlnaHQ7XG5cdFx0dGhpcy52aWV3Lm9mZnNldFggPSB4O1xuXHRcdHRoaXMudmlldy5vZmZzZXRZID0geTtcblx0XHR0aGlzLnZpZXcud2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLnZpZXcuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXHR9XG5cdGNsZWFyVmlld09mZnNldCgpIHtcblx0XHRpZiAodGhpcy52aWV3ICE9PSBudWxsKSB7XG5cdFx0XHR0aGlzLnZpZXcuZW5hYmxlZCA9IGZhbHNlO1xuXHRcdH1cblx0XHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblx0fVxuXHR1cGRhdGVQcm9qZWN0aW9uTWF0cml4KCkge1xuXHRcdGNvbnN0IG5lYXIgPSB0aGlzLm5lYXI7XG5cdFx0bGV0IHRvcCA9IG5lYXIgKiBNYXRoLnRhbihERUcyUkFEICogMC41ICogdGhpcy5mb3YpIC8gdGhpcy56b29tO1xuXHRcdGxldCBoZWlnaHQgPSAyICogdG9wO1xuXHRcdGxldCB3aWR0aCA9IHRoaXMuYXNwZWN0ICogaGVpZ2h0O1xuXHRcdGxldCBsZWZ0ID0gLTAuNSAqIHdpZHRoO1xuXHRcdGNvbnN0IHZpZXcgPSB0aGlzLnZpZXc7XG5cdFx0aWYgKHRoaXMudmlldyAhPT0gbnVsbCAmJiB0aGlzLnZpZXcuZW5hYmxlZCkge1xuXHRcdFx0Y29uc3QgZnVsbFdpZHRoID0gdmlldy5mdWxsV2lkdGgsXG5cdFx0XHRcdGZ1bGxIZWlnaHQgPSB2aWV3LmZ1bGxIZWlnaHQ7XG5cdFx0XHRsZWZ0ICs9IHZpZXcub2Zmc2V0WCAqIHdpZHRoIC8gZnVsbFdpZHRoO1xuXHRcdFx0dG9wIC09IHZpZXcub2Zmc2V0WSAqIGhlaWdodCAvIGZ1bGxIZWlnaHQ7XG5cdFx0XHR3aWR0aCAqPSB2aWV3LndpZHRoIC8gZnVsbFdpZHRoO1xuXHRcdFx0aGVpZ2h0ICo9IHZpZXcuaGVpZ2h0IC8gZnVsbEhlaWdodDtcblx0XHR9XG5cdFx0Y29uc3Qgc2tldyA9IHRoaXMuZmlsbU9mZnNldDtcblx0XHRpZiAoc2tldyAhPT0gMCkgbGVmdCArPSBuZWFyICogc2tldyAvIHRoaXMuZ2V0RmlsbVdpZHRoKCk7XG5cdFx0dGhpcy5wcm9qZWN0aW9uTWF0cml4Lm1ha2VQZXJzcGVjdGl2ZShsZWZ0LCBsZWZ0ICsgd2lkdGgsIHRvcCwgdG9wIC0gaGVpZ2h0LCBuZWFyLCB0aGlzLmZhcik7XG5cdFx0dGhpcy5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZS5jb3B5KHRoaXMucHJvamVjdGlvbk1hdHJpeCkuaW52ZXJ0KCk7XG5cdH1cblx0dG9KU09OKG1ldGEpIHtcblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKG1ldGEpO1xuXHRcdGRhdGEub2JqZWN0LmZvdiA9IHRoaXMuZm92O1xuXHRcdGRhdGEub2JqZWN0Lnpvb20gPSB0aGlzLnpvb207XG5cdFx0ZGF0YS5vYmplY3QubmVhciA9IHRoaXMubmVhcjtcblx0XHRkYXRhLm9iamVjdC5mYXIgPSB0aGlzLmZhcjtcblx0XHRkYXRhLm9iamVjdC5mb2N1cyA9IHRoaXMuZm9jdXM7XG5cdFx0ZGF0YS5vYmplY3QuYXNwZWN0ID0gdGhpcy5hc3BlY3Q7XG5cdFx0aWYgKHRoaXMudmlldyAhPT0gbnVsbCkgZGF0YS5vYmplY3QudmlldyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMudmlldyk7XG5cdFx0ZGF0YS5vYmplY3QuZmlsbUdhdWdlID0gdGhpcy5maWxtR2F1Z2U7XG5cdFx0ZGF0YS5vYmplY3QuZmlsbU9mZnNldCA9IHRoaXMuZmlsbU9mZnNldDtcblx0XHRyZXR1cm4gZGF0YTtcblx0fVxufVxuXG5jb25zdCBmb3YgPSA5MCxcblx0YXNwZWN0ID0gMTtcbmNsYXNzIEN1YmVDYW1lcmEgZXh0ZW5kcyBPYmplY3QzRCB7XG5cdGNvbnN0cnVjdG9yKG5lYXIsIGZhciwgcmVuZGVyVGFyZ2V0KSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLnR5cGUgPSAnQ3ViZUNhbWVyYSc7XG5cdFx0dGhpcy5yZW5kZXJUYXJnZXQgPSByZW5kZXJUYXJnZXQ7XG5cdFx0Y29uc3QgY2FtZXJhUFggPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoZm92LCBhc3BlY3QsIG5lYXIsIGZhcik7XG5cdFx0Y2FtZXJhUFgubGF5ZXJzID0gdGhpcy5sYXllcnM7XG5cdFx0Y2FtZXJhUFgudXAuc2V0KDAsIC0xLCAwKTtcblx0XHRjYW1lcmFQWC5sb29rQXQobmV3IFZlY3RvcjMoMSwgMCwgMCkpO1xuXHRcdHRoaXMuYWRkKGNhbWVyYVBYKTtcblx0XHRjb25zdCBjYW1lcmFOWCA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYShmb3YsIGFzcGVjdCwgbmVhciwgZmFyKTtcblx0XHRjYW1lcmFOWC5sYXllcnMgPSB0aGlzLmxheWVycztcblx0XHRjYW1lcmFOWC51cC5zZXQoMCwgLTEsIDApO1xuXHRcdGNhbWVyYU5YLmxvb2tBdChuZXcgVmVjdG9yMygtMSwgMCwgMCkpO1xuXHRcdHRoaXMuYWRkKGNhbWVyYU5YKTtcblx0XHRjb25zdCBjYW1lcmFQWSA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYShmb3YsIGFzcGVjdCwgbmVhciwgZmFyKTtcblx0XHRjYW1lcmFQWS5sYXllcnMgPSB0aGlzLmxheWVycztcblx0XHRjYW1lcmFQWS51cC5zZXQoMCwgMCwgMSk7XG5cdFx0Y2FtZXJhUFkubG9va0F0KG5ldyBWZWN0b3IzKDAsIDEsIDApKTtcblx0XHR0aGlzLmFkZChjYW1lcmFQWSk7XG5cdFx0Y29uc3QgY2FtZXJhTlkgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoZm92LCBhc3BlY3QsIG5lYXIsIGZhcik7XG5cdFx0Y2FtZXJhTlkubGF5ZXJzID0gdGhpcy5sYXllcnM7XG5cdFx0Y2FtZXJhTlkudXAuc2V0KDAsIDAsIC0xKTtcblx0XHRjYW1lcmFOWS5sb29rQXQobmV3IFZlY3RvcjMoMCwgLTEsIDApKTtcblx0XHR0aGlzLmFkZChjYW1lcmFOWSk7XG5cdFx0Y29uc3QgY2FtZXJhUFogPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoZm92LCBhc3BlY3QsIG5lYXIsIGZhcik7XG5cdFx0Y2FtZXJhUFoubGF5ZXJzID0gdGhpcy5sYXllcnM7XG5cdFx0Y2FtZXJhUFoudXAuc2V0KDAsIC0xLCAwKTtcblx0XHRjYW1lcmFQWi5sb29rQXQobmV3IFZlY3RvcjMoMCwgMCwgMSkpO1xuXHRcdHRoaXMuYWRkKGNhbWVyYVBaKTtcblx0XHRjb25zdCBjYW1lcmFOWiA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYShmb3YsIGFzcGVjdCwgbmVhciwgZmFyKTtcblx0XHRjYW1lcmFOWi5sYXllcnMgPSB0aGlzLmxheWVycztcblx0XHRjYW1lcmFOWi51cC5zZXQoMCwgLTEsIDApO1xuXHRcdGNhbWVyYU5aLmxvb2tBdChuZXcgVmVjdG9yMygwLCAwLCAtMSkpO1xuXHRcdHRoaXMuYWRkKGNhbWVyYU5aKTtcblx0fVxuXHR1cGRhdGUocmVuZGVyZXIsIHNjZW5lKSB7XG5cdFx0aWYgKHRoaXMucGFyZW50ID09PSBudWxsKSB0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cdFx0Y29uc3QgcmVuZGVyVGFyZ2V0ID0gdGhpcy5yZW5kZXJUYXJnZXQ7XG5cdFx0Y29uc3QgW2NhbWVyYVBYLCBjYW1lcmFOWCwgY2FtZXJhUFksIGNhbWVyYU5ZLCBjYW1lcmFQWiwgY2FtZXJhTlpdID0gdGhpcy5jaGlsZHJlbjtcblx0XHRjb25zdCBjdXJyZW50UmVuZGVyVGFyZ2V0ID0gcmVuZGVyZXIuZ2V0UmVuZGVyVGFyZ2V0KCk7XG5cdFx0Y29uc3QgY3VycmVudFRvbmVNYXBwaW5nID0gcmVuZGVyZXIudG9uZU1hcHBpbmc7XG5cdFx0Y29uc3QgY3VycmVudFhyRW5hYmxlZCA9IHJlbmRlcmVyLnhyLmVuYWJsZWQ7XG5cdFx0cmVuZGVyZXIudG9uZU1hcHBpbmcgPSBOb1RvbmVNYXBwaW5nO1xuXHRcdHJlbmRlcmVyLnhyLmVuYWJsZWQgPSBmYWxzZTtcblx0XHRjb25zdCBnZW5lcmF0ZU1pcG1hcHMgPSByZW5kZXJUYXJnZXQudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHM7XG5cdFx0cmVuZGVyVGFyZ2V0LnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCwgMCk7XG5cdFx0cmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmFQWCk7XG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCwgMSk7XG5cdFx0cmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmFOWCk7XG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCwgMik7XG5cdFx0cmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmFQWSk7XG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCwgMyk7XG5cdFx0cmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmFOWSk7XG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCwgNCk7XG5cdFx0cmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmFQWik7XG5cdFx0cmVuZGVyVGFyZ2V0LnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZ2VuZXJhdGVNaXBtYXBzO1xuXHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQsIDUpO1xuXHRcdHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhTlopO1xuXHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldChjdXJyZW50UmVuZGVyVGFyZ2V0KTtcblx0XHRyZW5kZXJlci50b25lTWFwcGluZyA9IGN1cnJlbnRUb25lTWFwcGluZztcblx0XHRyZW5kZXJlci54ci5lbmFibGVkID0gY3VycmVudFhyRW5hYmxlZDtcblx0XHRyZW5kZXJUYXJnZXQudGV4dHVyZS5uZWVkc1BNUkVNVXBkYXRlID0gdHJ1ZTtcblx0fVxufVxuXG5jbGFzcyBDdWJlVGV4dHVyZSBleHRlbmRzIFRleHR1cmUge1xuXHRjb25zdHJ1Y3RvcihpbWFnZXMsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSwgZW5jb2RpbmcpIHtcblx0XHRpbWFnZXMgPSBpbWFnZXMgIT09IHVuZGVmaW5lZCA/IGltYWdlcyA6IFtdO1xuXHRcdG1hcHBpbmcgPSBtYXBwaW5nICE9PSB1bmRlZmluZWQgPyBtYXBwaW5nIDogQ3ViZVJlZmxlY3Rpb25NYXBwaW5nO1xuXHRcdHN1cGVyKGltYWdlcywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5LCBlbmNvZGluZyk7XG5cdFx0dGhpcy5pc0N1YmVUZXh0dXJlID0gdHJ1ZTtcblx0XHR0aGlzLmZsaXBZID0gZmFsc2U7XG5cdH1cblx0Z2V0IGltYWdlcygpIHtcblx0XHRyZXR1cm4gdGhpcy5pbWFnZTtcblx0fVxuXHRzZXQgaW1hZ2VzKHZhbHVlKSB7XG5cdFx0dGhpcy5pbWFnZSA9IHZhbHVlO1xuXHR9XG59XG5cbmNsYXNzIFdlYkdMQ3ViZVJlbmRlclRhcmdldCBleHRlbmRzIFdlYkdMUmVuZGVyVGFyZ2V0IHtcblx0Y29uc3RydWN0b3Ioc2l6ZSA9IDEsIG9wdGlvbnMgPSB7fSkge1xuXHRcdHN1cGVyKHNpemUsIHNpemUsIG9wdGlvbnMpO1xuXHRcdHRoaXMuaXNXZWJHTEN1YmVSZW5kZXJUYXJnZXQgPSB0cnVlO1xuXHRcdGNvbnN0IGltYWdlID0ge1xuXHRcdFx0d2lkdGg6IHNpemUsXG5cdFx0XHRoZWlnaHQ6IHNpemUsXG5cdFx0XHRkZXB0aDogMVxuXHRcdH07XG5cdFx0Y29uc3QgaW1hZ2VzID0gW2ltYWdlLCBpbWFnZSwgaW1hZ2UsIGltYWdlLCBpbWFnZSwgaW1hZ2VdO1xuXHRcdHRoaXMudGV4dHVyZSA9IG5ldyBDdWJlVGV4dHVyZShpbWFnZXMsIG9wdGlvbnMubWFwcGluZywgb3B0aW9ucy53cmFwUywgb3B0aW9ucy53cmFwVCwgb3B0aW9ucy5tYWdGaWx0ZXIsIG9wdGlvbnMubWluRmlsdGVyLCBvcHRpb25zLmZvcm1hdCwgb3B0aW9ucy50eXBlLCBvcHRpb25zLmFuaXNvdHJvcHksIG9wdGlvbnMuZW5jb2RpbmcpO1xuXG5cdFx0Ly8gQnkgY29udmVudGlvbiAtLSBsaWtlbHkgYmFzZWQgb24gdGhlIFJlbmRlck1hbiBzcGVjIGZyb20gdGhlIDE5OTAncyAtLSBjdWJlIG1hcHMgYXJlIHNwZWNpZmllZCBieSBXZWJHTCAoYW5kIHRocmVlLmpzKVxuXHRcdC8vIGluIGEgY29vcmRpbmF0ZSBzeXN0ZW0gaW4gd2hpY2ggcG9zaXRpdmUteCBpcyB0byB0aGUgcmlnaHQgd2hlbiBsb29raW5nIHVwIHRoZSBwb3NpdGl2ZS16IGF4aXMgLS0gaW4gb3RoZXIgd29yZHMsXG5cdFx0Ly8gaW4gYSBsZWZ0LWhhbmRlZCBjb29yZGluYXRlIHN5c3RlbS4gQnkgY29udGludWluZyB0aGlzIGNvbnZlbnRpb24sIHByZWV4aXN0aW5nIGN1YmUgbWFwcyBjb250aW51ZWQgdG8gcmVuZGVyIGNvcnJlY3RseS5cblxuXHRcdC8vIHRocmVlLmpzIHVzZXMgYSByaWdodC1oYW5kZWQgY29vcmRpbmF0ZSBzeXN0ZW0uIFNvIGVudmlyb25tZW50IG1hcHMgdXNlZCBpbiB0aHJlZS5qcyBhcHBlYXIgdG8gaGF2ZSBweCBhbmQgbnggc3dhcHBlZFxuXHRcdC8vIGFuZCB0aGUgZmxhZyBpc1JlbmRlclRhcmdldFRleHR1cmUgY29udHJvbHMgdGhpcyBjb252ZXJzaW9uLiBUaGUgZmxpcCBpcyBub3QgcmVxdWlyZWQgd2hlbiB1c2luZyBXZWJHTEN1YmVSZW5kZXJUYXJnZXQudGV4dHVyZVxuXHRcdC8vIGFzIGEgY3ViZSB0ZXh0dXJlICh0aGlzIGlzIGRldGVjdGVkIHdoZW4gaXNSZW5kZXJUYXJnZXRUZXh0dXJlIGlzIHNldCB0byB0cnVlIGZvciBjdWJlIHRleHR1cmVzKS5cblxuXHRcdHRoaXMudGV4dHVyZS5pc1JlbmRlclRhcmdldFRleHR1cmUgPSB0cnVlO1xuXHRcdHRoaXMudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBvcHRpb25zLmdlbmVyYXRlTWlwbWFwcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5nZW5lcmF0ZU1pcG1hcHMgOiBmYWxzZTtcblx0XHR0aGlzLnRleHR1cmUubWluRmlsdGVyID0gb3B0aW9ucy5taW5GaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubWluRmlsdGVyIDogTGluZWFyRmlsdGVyO1xuXHR9XG5cdGZyb21FcXVpcmVjdGFuZ3VsYXJUZXh0dXJlKHJlbmRlcmVyLCB0ZXh0dXJlKSB7XG5cdFx0dGhpcy50ZXh0dXJlLnR5cGUgPSB0ZXh0dXJlLnR5cGU7XG5cdFx0dGhpcy50ZXh0dXJlLmVuY29kaW5nID0gdGV4dHVyZS5lbmNvZGluZztcblx0XHR0aGlzLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHM7XG5cdFx0dGhpcy50ZXh0dXJlLm1pbkZpbHRlciA9IHRleHR1cmUubWluRmlsdGVyO1xuXHRcdHRoaXMudGV4dHVyZS5tYWdGaWx0ZXIgPSB0ZXh0dXJlLm1hZ0ZpbHRlcjtcblx0XHRjb25zdCBzaGFkZXIgPSB7XG5cdFx0XHR1bmlmb3Jtczoge1xuXHRcdFx0XHR0RXF1aXJlY3Q6IHtcblx0XHRcdFx0XHR2YWx1ZTogbnVsbFxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dmVydGV4U2hhZGVyOiAvKiBnbHNsICovYFxuXG5cdFx0XHRcdHZhcnlpbmcgdmVjMyB2V29ybGREaXJlY3Rpb247XG5cblx0XHRcdFx0dmVjMyB0cmFuc2Zvcm1EaXJlY3Rpb24oIGluIHZlYzMgZGlyLCBpbiBtYXQ0IG1hdHJpeCApIHtcblxuXHRcdFx0XHRcdHJldHVybiBub3JtYWxpemUoICggbWF0cml4ICogdmVjNCggZGlyLCAwLjAgKSApLnh5eiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2b2lkIG1haW4oKSB7XG5cblx0XHRcdFx0XHR2V29ybGREaXJlY3Rpb24gPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIHBvc2l0aW9uLCBtb2RlbE1hdHJpeCApO1xuXG5cdFx0XHRcdFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cblx0XHRcdFx0XHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XG5cblx0XHRcdFx0fVxuXHRcdFx0YCxcblx0XHRcdGZyYWdtZW50U2hhZGVyOiAvKiBnbHNsICovYFxuXG5cdFx0XHRcdHVuaWZvcm0gc2FtcGxlcjJEIHRFcXVpcmVjdDtcblxuXHRcdFx0XHR2YXJ5aW5nIHZlYzMgdldvcmxkRGlyZWN0aW9uO1xuXG5cdFx0XHRcdCNpbmNsdWRlIDxjb21tb24+XG5cblx0XHRcdFx0dm9pZCBtYWluKCkge1xuXG5cdFx0XHRcdFx0dmVjMyBkaXJlY3Rpb24gPSBub3JtYWxpemUoIHZXb3JsZERpcmVjdGlvbiApO1xuXG5cdFx0XHRcdFx0dmVjMiBzYW1wbGVVViA9IGVxdWlyZWN0VXYoIGRpcmVjdGlvbiApO1xuXG5cdFx0XHRcdFx0Z2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCB0RXF1aXJlY3QsIHNhbXBsZVVWICk7XG5cblx0XHRcdFx0fVxuXHRcdFx0YFxuXHRcdH07XG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSBuZXcgQm94R2VvbWV0cnkoNSwgNSwgNSk7XG5cdFx0Y29uc3QgbWF0ZXJpYWwgPSBuZXcgU2hhZGVyTWF0ZXJpYWwoe1xuXHRcdFx0bmFtZTogJ0N1YmVtYXBGcm9tRXF1aXJlY3QnLFxuXHRcdFx0dW5pZm9ybXM6IGNsb25lVW5pZm9ybXMoc2hhZGVyLnVuaWZvcm1zKSxcblx0XHRcdHZlcnRleFNoYWRlcjogc2hhZGVyLnZlcnRleFNoYWRlcixcblx0XHRcdGZyYWdtZW50U2hhZGVyOiBzaGFkZXIuZnJhZ21lbnRTaGFkZXIsXG5cdFx0XHRzaWRlOiBCYWNrU2lkZSxcblx0XHRcdGJsZW5kaW5nOiBOb0JsZW5kaW5nXG5cdFx0fSk7XG5cdFx0bWF0ZXJpYWwudW5pZm9ybXMudEVxdWlyZWN0LnZhbHVlID0gdGV4dHVyZTtcblx0XHRjb25zdCBtZXNoID0gbmV3IE1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcblx0XHRjb25zdCBjdXJyZW50TWluRmlsdGVyID0gdGV4dHVyZS5taW5GaWx0ZXI7XG5cblx0XHQvLyBBdm9pZCBibHVycmVkIHBvbGVzXG5cdFx0aWYgKHRleHR1cmUubWluRmlsdGVyID09PSBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIpIHRleHR1cmUubWluRmlsdGVyID0gTGluZWFyRmlsdGVyO1xuXHRcdGNvbnN0IGNhbWVyYSA9IG5ldyBDdWJlQ2FtZXJhKDEsIDEwLCB0aGlzKTtcblx0XHRjYW1lcmEudXBkYXRlKHJlbmRlcmVyLCBtZXNoKTtcblx0XHR0ZXh0dXJlLm1pbkZpbHRlciA9IGN1cnJlbnRNaW5GaWx0ZXI7XG5cdFx0bWVzaC5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdFx0bWVzaC5tYXRlcmlhbC5kaXNwb3NlKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0Y2xlYXIocmVuZGVyZXIsIGNvbG9yLCBkZXB0aCwgc3RlbmNpbCkge1xuXHRcdGNvbnN0IGN1cnJlbnRSZW5kZXJUYXJnZXQgPSByZW5kZXJlci5nZXRSZW5kZXJUYXJnZXQoKTtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xuXHRcdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHRoaXMsIGkpO1xuXHRcdFx0cmVuZGVyZXIuY2xlYXIoY29sb3IsIGRlcHRoLCBzdGVuY2lsKTtcblx0XHR9XG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KGN1cnJlbnRSZW5kZXJUYXJnZXQpO1xuXHR9XG59XG5cbmNvbnN0IF92ZWN0b3IxID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5jb25zdCBfdmVjdG9yMiA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuY29uc3QgX25vcm1hbE1hdHJpeCA9IC8qQF9fUFVSRV9fKi9uZXcgTWF0cml4MygpO1xuY2xhc3MgUGxhbmUge1xuXHRjb25zdHJ1Y3Rvcihub3JtYWwgPSBuZXcgVmVjdG9yMygxLCAwLCAwKSwgY29uc3RhbnQgPSAwKSB7XG5cdFx0dGhpcy5pc1BsYW5lID0gdHJ1ZTtcblxuXHRcdC8vIG5vcm1hbCBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcblxuXHRcdHRoaXMubm9ybWFsID0gbm9ybWFsO1xuXHRcdHRoaXMuY29uc3RhbnQgPSBjb25zdGFudDtcblx0fVxuXHRzZXQobm9ybWFsLCBjb25zdGFudCkge1xuXHRcdHRoaXMubm9ybWFsLmNvcHkobm9ybWFsKTtcblx0XHR0aGlzLmNvbnN0YW50ID0gY29uc3RhbnQ7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0c2V0Q29tcG9uZW50cyh4LCB5LCB6LCB3KSB7XG5cdFx0dGhpcy5ub3JtYWwuc2V0KHgsIHksIHopO1xuXHRcdHRoaXMuY29uc3RhbnQgPSB3O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50KG5vcm1hbCwgcG9pbnQpIHtcblx0XHR0aGlzLm5vcm1hbC5jb3B5KG5vcm1hbCk7XG5cdFx0dGhpcy5jb25zdGFudCA9IC1wb2ludC5kb3QodGhpcy5ub3JtYWwpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHNldEZyb21Db3BsYW5hclBvaW50cyhhLCBiLCBjKSB7XG5cdFx0Y29uc3Qgbm9ybWFsID0gX3ZlY3RvcjEuc3ViVmVjdG9ycyhjLCBiKS5jcm9zcyhfdmVjdG9yMi5zdWJWZWN0b3JzKGEsIGIpKS5ub3JtYWxpemUoKTtcblxuXHRcdC8vIFE6IHNob3VsZCBhbiBlcnJvciBiZSB0aHJvd24gaWYgbm9ybWFsIGlzIHplcm8gKGUuZy4gZGVnZW5lcmF0ZSBwbGFuZSk/XG5cblx0XHR0aGlzLnNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50KG5vcm1hbCwgYSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0Y29weShwbGFuZSkge1xuXHRcdHRoaXMubm9ybWFsLmNvcHkocGxhbmUubm9ybWFsKTtcblx0XHR0aGlzLmNvbnN0YW50ID0gcGxhbmUuY29uc3RhbnQ7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0bm9ybWFsaXplKCkge1xuXHRcdC8vIE5vdGU6IHdpbGwgbGVhZCB0byBhIGRpdmlkZSBieSB6ZXJvIGlmIHRoZSBwbGFuZSBpcyBpbnZhbGlkLlxuXG5cdFx0Y29uc3QgaW52ZXJzZU5vcm1hbExlbmd0aCA9IDEuMCAvIHRoaXMubm9ybWFsLmxlbmd0aCgpO1xuXHRcdHRoaXMubm9ybWFsLm11bHRpcGx5U2NhbGFyKGludmVyc2VOb3JtYWxMZW5ndGgpO1xuXHRcdHRoaXMuY29uc3RhbnQgKj0gaW52ZXJzZU5vcm1hbExlbmd0aDtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRuZWdhdGUoKSB7XG5cdFx0dGhpcy5jb25zdGFudCAqPSAtMTtcblx0XHR0aGlzLm5vcm1hbC5uZWdhdGUoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRkaXN0YW5jZVRvUG9pbnQocG9pbnQpIHtcblx0XHRyZXR1cm4gdGhpcy5ub3JtYWwuZG90KHBvaW50KSArIHRoaXMuY29uc3RhbnQ7XG5cdH1cblx0ZGlzdGFuY2VUb1NwaGVyZShzcGhlcmUpIHtcblx0XHRyZXR1cm4gdGhpcy5kaXN0YW5jZVRvUG9pbnQoc3BoZXJlLmNlbnRlcikgLSBzcGhlcmUucmFkaXVzO1xuXHR9XG5cdHByb2plY3RQb2ludChwb2ludCwgdGFyZ2V0KSB7XG5cdFx0cmV0dXJuIHRhcmdldC5jb3B5KHRoaXMubm9ybWFsKS5tdWx0aXBseVNjYWxhcigtdGhpcy5kaXN0YW5jZVRvUG9pbnQocG9pbnQpKS5hZGQocG9pbnQpO1xuXHR9XG5cdGludGVyc2VjdExpbmUobGluZSwgdGFyZ2V0KSB7XG5cdFx0Y29uc3QgZGlyZWN0aW9uID0gbGluZS5kZWx0YShfdmVjdG9yMSk7XG5cdFx0Y29uc3QgZGVub21pbmF0b3IgPSB0aGlzLm5vcm1hbC5kb3QoZGlyZWN0aW9uKTtcblx0XHRpZiAoZGVub21pbmF0b3IgPT09IDApIHtcblx0XHRcdC8vIGxpbmUgaXMgY29wbGFuYXIsIHJldHVybiBvcmlnaW5cblx0XHRcdGlmICh0aGlzLmRpc3RhbmNlVG9Qb2ludChsaW5lLnN0YXJ0KSA9PT0gMCkge1xuXHRcdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkobGluZS5zdGFydCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFVuc3VyZSBpZiB0aGlzIGlzIHRoZSBjb3JyZWN0IG1ldGhvZCB0byBoYW5kbGUgdGhpcyBjYXNlLlxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdGNvbnN0IHQgPSAtKGxpbmUuc3RhcnQuZG90KHRoaXMubm9ybWFsKSArIHRoaXMuY29uc3RhbnQpIC8gZGVub21pbmF0b3I7XG5cdFx0aWYgKHQgPCAwIHx8IHQgPiAxKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIHRhcmdldC5jb3B5KGRpcmVjdGlvbikubXVsdGlwbHlTY2FsYXIodCkuYWRkKGxpbmUuc3RhcnQpO1xuXHR9XG5cdGludGVyc2VjdHNMaW5lKGxpbmUpIHtcblx0XHQvLyBOb3RlOiB0aGlzIHRlc3RzIGlmIGEgbGluZSBpbnRlcnNlY3RzIHRoZSBwbGFuZSwgbm90IHdoZXRoZXIgaXQgKG9yIGl0cyBlbmQtcG9pbnRzKSBhcmUgY29wbGFuYXIgd2l0aCBpdC5cblxuXHRcdGNvbnN0IHN0YXJ0U2lnbiA9IHRoaXMuZGlzdGFuY2VUb1BvaW50KGxpbmUuc3RhcnQpO1xuXHRcdGNvbnN0IGVuZFNpZ24gPSB0aGlzLmRpc3RhbmNlVG9Qb2ludChsaW5lLmVuZCk7XG5cdFx0cmV0dXJuIHN0YXJ0U2lnbiA8IDAgJiYgZW5kU2lnbiA+IDAgfHwgZW5kU2lnbiA8IDAgJiYgc3RhcnRTaWduID4gMDtcblx0fVxuXHRpbnRlcnNlY3RzQm94KGJveCkge1xuXHRcdHJldHVybiBib3guaW50ZXJzZWN0c1BsYW5lKHRoaXMpO1xuXHR9XG5cdGludGVyc2VjdHNTcGhlcmUoc3BoZXJlKSB7XG5cdFx0cmV0dXJuIHNwaGVyZS5pbnRlcnNlY3RzUGxhbmUodGhpcyk7XG5cdH1cblx0Y29wbGFuYXJQb2ludCh0YXJnZXQpIHtcblx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkodGhpcy5ub3JtYWwpLm11bHRpcGx5U2NhbGFyKC10aGlzLmNvbnN0YW50KTtcblx0fVxuXHRhcHBseU1hdHJpeDQobWF0cml4LCBvcHRpb25hbE5vcm1hbE1hdHJpeCkge1xuXHRcdGNvbnN0IG5vcm1hbE1hdHJpeCA9IG9wdGlvbmFsTm9ybWFsTWF0cml4IHx8IF9ub3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KG1hdHJpeCk7XG5cdFx0Y29uc3QgcmVmZXJlbmNlUG9pbnQgPSB0aGlzLmNvcGxhbmFyUG9pbnQoX3ZlY3RvcjEpLmFwcGx5TWF0cml4NChtYXRyaXgpO1xuXHRcdGNvbnN0IG5vcm1hbCA9IHRoaXMubm9ybWFsLmFwcGx5TWF0cml4Myhub3JtYWxNYXRyaXgpLm5vcm1hbGl6ZSgpO1xuXHRcdHRoaXMuY29uc3RhbnQgPSAtcmVmZXJlbmNlUG9pbnQuZG90KG5vcm1hbCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0dHJhbnNsYXRlKG9mZnNldCkge1xuXHRcdHRoaXMuY29uc3RhbnQgLT0gb2Zmc2V0LmRvdCh0aGlzLm5vcm1hbCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0ZXF1YWxzKHBsYW5lKSB7XG5cdFx0cmV0dXJuIHBsYW5lLm5vcm1hbC5lcXVhbHModGhpcy5ub3JtYWwpICYmIHBsYW5lLmNvbnN0YW50ID09PSB0aGlzLmNvbnN0YW50O1xuXHR9XG5cdGNsb25lKCkge1xuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyk7XG5cdH1cbn1cblxuY29uc3QgX3NwaGVyZSQyID0gLypAX19QVVJFX18qL25ldyBTcGhlcmUoKTtcbmNvbnN0IF92ZWN0b3IkNyA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuY2xhc3MgRnJ1c3R1bSB7XG5cdGNvbnN0cnVjdG9yKHAwID0gbmV3IFBsYW5lKCksIHAxID0gbmV3IFBsYW5lKCksIHAyID0gbmV3IFBsYW5lKCksIHAzID0gbmV3IFBsYW5lKCksIHA0ID0gbmV3IFBsYW5lKCksIHA1ID0gbmV3IFBsYW5lKCkpIHtcblx0XHR0aGlzLnBsYW5lcyA9IFtwMCwgcDEsIHAyLCBwMywgcDQsIHA1XTtcblx0fVxuXHRzZXQocDAsIHAxLCBwMiwgcDMsIHA0LCBwNSkge1xuXHRcdGNvbnN0IHBsYW5lcyA9IHRoaXMucGxhbmVzO1xuXHRcdHBsYW5lc1swXS5jb3B5KHAwKTtcblx0XHRwbGFuZXNbMV0uY29weShwMSk7XG5cdFx0cGxhbmVzWzJdLmNvcHkocDIpO1xuXHRcdHBsYW5lc1szXS5jb3B5KHAzKTtcblx0XHRwbGFuZXNbNF0uY29weShwNCk7XG5cdFx0cGxhbmVzWzVdLmNvcHkocDUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGNvcHkoZnJ1c3R1bSkge1xuXHRcdGNvbnN0IHBsYW5lcyA9IHRoaXMucGxhbmVzO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG5cdFx0XHRwbGFuZXNbaV0uY29weShmcnVzdHVtLnBsYW5lc1tpXSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHNldEZyb21Qcm9qZWN0aW9uTWF0cml4KG0pIHtcblx0XHRjb25zdCBwbGFuZXMgPSB0aGlzLnBsYW5lcztcblx0XHRjb25zdCBtZSA9IG0uZWxlbWVudHM7XG5cdFx0Y29uc3QgbWUwID0gbWVbMF0sXG5cdFx0XHRtZTEgPSBtZVsxXSxcblx0XHRcdG1lMiA9IG1lWzJdLFxuXHRcdFx0bWUzID0gbWVbM107XG5cdFx0Y29uc3QgbWU0ID0gbWVbNF0sXG5cdFx0XHRtZTUgPSBtZVs1XSxcblx0XHRcdG1lNiA9IG1lWzZdLFxuXHRcdFx0bWU3ID0gbWVbN107XG5cdFx0Y29uc3QgbWU4ID0gbWVbOF0sXG5cdFx0XHRtZTkgPSBtZVs5XSxcblx0XHRcdG1lMTAgPSBtZVsxMF0sXG5cdFx0XHRtZTExID0gbWVbMTFdO1xuXHRcdGNvbnN0IG1lMTIgPSBtZVsxMl0sXG5cdFx0XHRtZTEzID0gbWVbMTNdLFxuXHRcdFx0bWUxNCA9IG1lWzE0XSxcblx0XHRcdG1lMTUgPSBtZVsxNV07XG5cdFx0cGxhbmVzWzBdLnNldENvbXBvbmVudHMobWUzIC0gbWUwLCBtZTcgLSBtZTQsIG1lMTEgLSBtZTgsIG1lMTUgLSBtZTEyKS5ub3JtYWxpemUoKTtcblx0XHRwbGFuZXNbMV0uc2V0Q29tcG9uZW50cyhtZTMgKyBtZTAsIG1lNyArIG1lNCwgbWUxMSArIG1lOCwgbWUxNSArIG1lMTIpLm5vcm1hbGl6ZSgpO1xuXHRcdHBsYW5lc1syXS5zZXRDb21wb25lbnRzKG1lMyArIG1lMSwgbWU3ICsgbWU1LCBtZTExICsgbWU5LCBtZTE1ICsgbWUxMykubm9ybWFsaXplKCk7XG5cdFx0cGxhbmVzWzNdLnNldENvbXBvbmVudHMobWUzIC0gbWUxLCBtZTcgLSBtZTUsIG1lMTEgLSBtZTksIG1lMTUgLSBtZTEzKS5ub3JtYWxpemUoKTtcblx0XHRwbGFuZXNbNF0uc2V0Q29tcG9uZW50cyhtZTMgLSBtZTIsIG1lNyAtIG1lNiwgbWUxMSAtIG1lMTAsIG1lMTUgLSBtZTE0KS5ub3JtYWxpemUoKTtcblx0XHRwbGFuZXNbNV0uc2V0Q29tcG9uZW50cyhtZTMgKyBtZTIsIG1lNyArIG1lNiwgbWUxMSArIG1lMTAsIG1lMTUgKyBtZTE0KS5ub3JtYWxpemUoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRpbnRlcnNlY3RzT2JqZWN0KG9iamVjdCkge1xuXHRcdGNvbnN0IGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuXHRcdGlmIChnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCkgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cdFx0X3NwaGVyZSQyLmNvcHkoZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUpLmFwcGx5TWF0cml4NChvYmplY3QubWF0cml4V29ybGQpO1xuXHRcdHJldHVybiB0aGlzLmludGVyc2VjdHNTcGhlcmUoX3NwaGVyZSQyKTtcblx0fVxuXHRpbnRlcnNlY3RzU3ByaXRlKHNwcml0ZSkge1xuXHRcdF9zcGhlcmUkMi5jZW50ZXIuc2V0KDAsIDAsIDApO1xuXHRcdF9zcGhlcmUkMi5yYWRpdXMgPSAwLjcwNzEwNjc4MTE4NjU0NzY7XG5cdFx0X3NwaGVyZSQyLmFwcGx5TWF0cml4NChzcHJpdGUubWF0cml4V29ybGQpO1xuXHRcdHJldHVybiB0aGlzLmludGVyc2VjdHNTcGhlcmUoX3NwaGVyZSQyKTtcblx0fVxuXHRpbnRlcnNlY3RzU3BoZXJlKHNwaGVyZSkge1xuXHRcdGNvbnN0IHBsYW5lcyA9IHRoaXMucGxhbmVzO1xuXHRcdGNvbnN0IGNlbnRlciA9IHNwaGVyZS5jZW50ZXI7XG5cdFx0Y29uc3QgbmVnUmFkaXVzID0gLXNwaGVyZS5yYWRpdXM7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcblx0XHRcdGNvbnN0IGRpc3RhbmNlID0gcGxhbmVzW2ldLmRpc3RhbmNlVG9Qb2ludChjZW50ZXIpO1xuXHRcdFx0aWYgKGRpc3RhbmNlIDwgbmVnUmFkaXVzKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0aW50ZXJzZWN0c0JveChib3gpIHtcblx0XHRjb25zdCBwbGFuZXMgPSB0aGlzLnBsYW5lcztcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xuXHRcdFx0Y29uc3QgcGxhbmUgPSBwbGFuZXNbaV07XG5cblx0XHRcdC8vIGNvcm5lciBhdCBtYXggZGlzdGFuY2VcblxuXHRcdFx0X3ZlY3RvciQ3LnggPSBwbGFuZS5ub3JtYWwueCA+IDAgPyBib3gubWF4LnggOiBib3gubWluLng7XG5cdFx0XHRfdmVjdG9yJDcueSA9IHBsYW5lLm5vcm1hbC55ID4gMCA/IGJveC5tYXgueSA6IGJveC5taW4ueTtcblx0XHRcdF92ZWN0b3IkNy56ID0gcGxhbmUubm9ybWFsLnogPiAwID8gYm94Lm1heC56IDogYm94Lm1pbi56O1xuXHRcdFx0aWYgKHBsYW5lLmRpc3RhbmNlVG9Qb2ludChfdmVjdG9yJDcpIDwgMCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdGNvbnRhaW5zUG9pbnQocG9pbnQpIHtcblx0XHRjb25zdCBwbGFuZXMgPSB0aGlzLnBsYW5lcztcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xuXHRcdFx0aWYgKHBsYW5lc1tpXS5kaXN0YW5jZVRvUG9pbnQocG9pbnQpIDwgMCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdGNsb25lKCkge1xuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyk7XG5cdH1cbn1cblxuZnVuY3Rpb24gV2ViR0xBbmltYXRpb24oKSB7XG5cdGxldCBjb250ZXh0ID0gbnVsbDtcblx0bGV0IGlzQW5pbWF0aW5nID0gZmFsc2U7XG5cdGxldCBhbmltYXRpb25Mb29wID0gbnVsbDtcblx0bGV0IHJlcXVlc3RJZCA9IG51bGw7XG5cdGZ1bmN0aW9uIG9uQW5pbWF0aW9uRnJhbWUodGltZSwgZnJhbWUpIHtcblx0XHRhbmltYXRpb25Mb29wKHRpbWUsIGZyYW1lKTtcblx0XHRyZXF1ZXN0SWQgPSBjb250ZXh0LnJlcXVlc3RBbmltYXRpb25GcmFtZShvbkFuaW1hdGlvbkZyYW1lKTtcblx0fVxuXHRyZXR1cm4ge1xuXHRcdHN0YXJ0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoaXNBbmltYXRpbmcgPT09IHRydWUpIHJldHVybjtcblx0XHRcdGlmIChhbmltYXRpb25Mb29wID09PSBudWxsKSByZXR1cm47XG5cdFx0XHRyZXF1ZXN0SWQgPSBjb250ZXh0LnJlcXVlc3RBbmltYXRpb25GcmFtZShvbkFuaW1hdGlvbkZyYW1lKTtcblx0XHRcdGlzQW5pbWF0aW5nID0gdHJ1ZTtcblx0XHR9LFxuXHRcdHN0b3A6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGNvbnRleHQuY2FuY2VsQW5pbWF0aW9uRnJhbWUocmVxdWVzdElkKTtcblx0XHRcdGlzQW5pbWF0aW5nID0gZmFsc2U7XG5cdFx0fSxcblx0XHRzZXRBbmltYXRpb25Mb29wOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblx0XHRcdGFuaW1hdGlvbkxvb3AgPSBjYWxsYmFjaztcblx0XHR9LFxuXHRcdHNldENvbnRleHQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0Y29udGV4dCA9IHZhbHVlO1xuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gV2ViR0xBdHRyaWJ1dGVzKGdsLCBjYXBhYmlsaXRpZXMpIHtcblx0Y29uc3QgaXNXZWJHTDIgPSBjYXBhYmlsaXRpZXMuaXNXZWJHTDI7XG5cdGNvbnN0IGJ1ZmZlcnMgPSBuZXcgV2Vha01hcCgpO1xuXHRmdW5jdGlvbiBjcmVhdGVCdWZmZXIoYXR0cmlidXRlLCBidWZmZXJUeXBlKSB7XG5cdFx0Y29uc3QgYXJyYXkgPSBhdHRyaWJ1dGUuYXJyYXk7XG5cdFx0Y29uc3QgdXNhZ2UgPSBhdHRyaWJ1dGUudXNhZ2U7XG5cdFx0Y29uc3QgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG5cdFx0Z2wuYmluZEJ1ZmZlcihidWZmZXJUeXBlLCBidWZmZXIpO1xuXHRcdGdsLmJ1ZmZlckRhdGEoYnVmZmVyVHlwZSwgYXJyYXksIHVzYWdlKTtcblx0XHRhdHRyaWJ1dGUub25VcGxvYWRDYWxsYmFjaygpO1xuXHRcdGxldCB0eXBlO1xuXHRcdGlmIChhcnJheSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkge1xuXHRcdFx0dHlwZSA9IGdsLkZMT0FUO1xuXHRcdH0gZWxzZSBpZiAoYXJyYXkgaW5zdGFuY2VvZiBVaW50MTZBcnJheSkge1xuXHRcdFx0aWYgKGF0dHJpYnV0ZS5pc0Zsb2F0MTZCdWZmZXJBdHRyaWJ1dGUpIHtcblx0XHRcdFx0aWYgKGlzV2ViR0wyKSB7XG5cdFx0XHRcdFx0dHlwZSA9IGdsLkhBTEZfRkxPQVQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdUSFJFRS5XZWJHTEF0dHJpYnV0ZXM6IFVzYWdlIG9mIEZsb2F0MTZCdWZmZXJBdHRyaWJ1dGUgcmVxdWlyZXMgV2ViR0wyLicpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0eXBlID0gZ2wuVU5TSUdORURfU0hPUlQ7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChhcnJheSBpbnN0YW5jZW9mIEludDE2QXJyYXkpIHtcblx0XHRcdHR5cGUgPSBnbC5TSE9SVDtcblx0XHR9IGVsc2UgaWYgKGFycmF5IGluc3RhbmNlb2YgVWludDMyQXJyYXkpIHtcblx0XHRcdHR5cGUgPSBnbC5VTlNJR05FRF9JTlQ7XG5cdFx0fSBlbHNlIGlmIChhcnJheSBpbnN0YW5jZW9mIEludDMyQXJyYXkpIHtcblx0XHRcdHR5cGUgPSBnbC5JTlQ7XG5cdFx0fSBlbHNlIGlmIChhcnJheSBpbnN0YW5jZW9mIEludDhBcnJheSkge1xuXHRcdFx0dHlwZSA9IGdsLkJZVEU7XG5cdFx0fSBlbHNlIGlmIChhcnJheSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcblx0XHRcdHR5cGUgPSBnbC5VTlNJR05FRF9CWVRFO1xuXHRcdH0gZWxzZSBpZiAoYXJyYXkgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkge1xuXHRcdFx0dHlwZSA9IGdsLlVOU0lHTkVEX0JZVEU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignVEhSRUUuV2ViR0xBdHRyaWJ1dGVzOiBVbnN1cHBvcnRlZCBidWZmZXIgZGF0YSBmb3JtYXQ6ICcgKyBhcnJheSk7XG5cdFx0fVxuXHRcdHJldHVybiB7XG5cdFx0XHRidWZmZXI6IGJ1ZmZlcixcblx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRieXRlc1BlckVsZW1lbnQ6IGFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuXHRcdFx0dmVyc2lvbjogYXR0cmlidXRlLnZlcnNpb25cblx0XHR9O1xuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUJ1ZmZlcihidWZmZXIsIGF0dHJpYnV0ZSwgYnVmZmVyVHlwZSkge1xuXHRcdGNvbnN0IGFycmF5ID0gYXR0cmlidXRlLmFycmF5O1xuXHRcdGNvbnN0IHVwZGF0ZVJhbmdlID0gYXR0cmlidXRlLnVwZGF0ZVJhbmdlO1xuXHRcdGdsLmJpbmRCdWZmZXIoYnVmZmVyVHlwZSwgYnVmZmVyKTtcblx0XHRpZiAodXBkYXRlUmFuZ2UuY291bnQgPT09IC0xKSB7XG5cdFx0XHQvLyBOb3QgdXNpbmcgdXBkYXRlIHJhbmdlc1xuXG5cdFx0XHRnbC5idWZmZXJTdWJEYXRhKGJ1ZmZlclR5cGUsIDAsIGFycmF5KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKGlzV2ViR0wyKSB7XG5cdFx0XHRcdGdsLmJ1ZmZlclN1YkRhdGEoYnVmZmVyVHlwZSwgdXBkYXRlUmFuZ2Uub2Zmc2V0ICogYXJyYXkuQllURVNfUEVSX0VMRU1FTlQsIGFycmF5LCB1cGRhdGVSYW5nZS5vZmZzZXQsIHVwZGF0ZVJhbmdlLmNvdW50KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGdsLmJ1ZmZlclN1YkRhdGEoYnVmZmVyVHlwZSwgdXBkYXRlUmFuZ2Uub2Zmc2V0ICogYXJyYXkuQllURVNfUEVSX0VMRU1FTlQsIGFycmF5LnN1YmFycmF5KHVwZGF0ZVJhbmdlLm9mZnNldCwgdXBkYXRlUmFuZ2Uub2Zmc2V0ICsgdXBkYXRlUmFuZ2UuY291bnQpKTtcblx0XHRcdH1cblx0XHRcdHVwZGF0ZVJhbmdlLmNvdW50ID0gLTE7IC8vIHJlc2V0IHJhbmdlXG5cdFx0fVxuXHR9XG5cblx0Ly9cblxuXHRmdW5jdGlvbiBnZXQoYXR0cmlidXRlKSB7XG5cdFx0aWYgKGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKSBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGUuZGF0YTtcblx0XHRyZXR1cm4gYnVmZmVycy5nZXQoYXR0cmlidXRlKTtcblx0fVxuXHRmdW5jdGlvbiByZW1vdmUoYXR0cmlidXRlKSB7XG5cdFx0aWYgKGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKSBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGUuZGF0YTtcblx0XHRjb25zdCBkYXRhID0gYnVmZmVycy5nZXQoYXR0cmlidXRlKTtcblx0XHRpZiAoZGF0YSkge1xuXHRcdFx0Z2wuZGVsZXRlQnVmZmVyKGRhdGEuYnVmZmVyKTtcblx0XHRcdGJ1ZmZlcnMuZGVsZXRlKGF0dHJpYnV0ZSk7XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZShhdHRyaWJ1dGUsIGJ1ZmZlclR5cGUpIHtcblx0XHRpZiAoYXR0cmlidXRlLmlzR0xCdWZmZXJBdHRyaWJ1dGUpIHtcblx0XHRcdGNvbnN0IGNhY2hlZCA9IGJ1ZmZlcnMuZ2V0KGF0dHJpYnV0ZSk7XG5cdFx0XHRpZiAoIWNhY2hlZCB8fCBjYWNoZWQudmVyc2lvbiA8IGF0dHJpYnV0ZS52ZXJzaW9uKSB7XG5cdFx0XHRcdGJ1ZmZlcnMuc2V0KGF0dHJpYnV0ZSwge1xuXHRcdFx0XHRcdGJ1ZmZlcjogYXR0cmlidXRlLmJ1ZmZlcixcblx0XHRcdFx0XHR0eXBlOiBhdHRyaWJ1dGUudHlwZSxcblx0XHRcdFx0XHRieXRlc1BlckVsZW1lbnQ6IGF0dHJpYnV0ZS5lbGVtZW50U2l6ZSxcblx0XHRcdFx0XHR2ZXJzaW9uOiBhdHRyaWJ1dGUudmVyc2lvblxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKSBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGUuZGF0YTtcblx0XHRjb25zdCBkYXRhID0gYnVmZmVycy5nZXQoYXR0cmlidXRlKTtcblx0XHRpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRidWZmZXJzLnNldChhdHRyaWJ1dGUsIGNyZWF0ZUJ1ZmZlcihhdHRyaWJ1dGUsIGJ1ZmZlclR5cGUpKTtcblx0XHR9IGVsc2UgaWYgKGRhdGEudmVyc2lvbiA8IGF0dHJpYnV0ZS52ZXJzaW9uKSB7XG5cdFx0XHR1cGRhdGVCdWZmZXIoZGF0YS5idWZmZXIsIGF0dHJpYnV0ZSwgYnVmZmVyVHlwZSk7XG5cdFx0XHRkYXRhLnZlcnNpb24gPSBhdHRyaWJ1dGUudmVyc2lvbjtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHtcblx0XHRnZXQ6IGdldCxcblx0XHRyZW1vdmU6IHJlbW92ZSxcblx0XHR1cGRhdGU6IHVwZGF0ZVxuXHR9O1xufVxuXG5jbGFzcyBQbGFuZUdlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXHRjb25zdHJ1Y3Rvcih3aWR0aCA9IDEsIGhlaWdodCA9IDEsIHdpZHRoU2VnbWVudHMgPSAxLCBoZWlnaHRTZWdtZW50cyA9IDEpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMudHlwZSA9ICdQbGFuZUdlb21ldHJ5Jztcblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHR3aWR0aDogd2lkdGgsXG5cdFx0XHRoZWlnaHQ6IGhlaWdodCxcblx0XHRcdHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXG5cdFx0XHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHNcblx0XHR9O1xuXHRcdGNvbnN0IHdpZHRoX2hhbGYgPSB3aWR0aCAvIDI7XG5cdFx0Y29uc3QgaGVpZ2h0X2hhbGYgPSBoZWlnaHQgLyAyO1xuXHRcdGNvbnN0IGdyaWRYID0gTWF0aC5mbG9vcih3aWR0aFNlZ21lbnRzKTtcblx0XHRjb25zdCBncmlkWSA9IE1hdGguZmxvb3IoaGVpZ2h0U2VnbWVudHMpO1xuXHRcdGNvbnN0IGdyaWRYMSA9IGdyaWRYICsgMTtcblx0XHRjb25zdCBncmlkWTEgPSBncmlkWSArIDE7XG5cdFx0Y29uc3Qgc2VnbWVudF93aWR0aCA9IHdpZHRoIC8gZ3JpZFg7XG5cdFx0Y29uc3Qgc2VnbWVudF9oZWlnaHQgPSBoZWlnaHQgLyBncmlkWTtcblxuXHRcdC8vXG5cblx0XHRjb25zdCBpbmRpY2VzID0gW107XG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblx0XHRjb25zdCBub3JtYWxzID0gW107XG5cdFx0Y29uc3QgdXZzID0gW107XG5cdFx0Zm9yIChsZXQgaXkgPSAwOyBpeSA8IGdyaWRZMTsgaXkrKykge1xuXHRcdFx0Y29uc3QgeSA9IGl5ICogc2VnbWVudF9oZWlnaHQgLSBoZWlnaHRfaGFsZjtcblx0XHRcdGZvciAobGV0IGl4ID0gMDsgaXggPCBncmlkWDE7IGl4KyspIHtcblx0XHRcdFx0Y29uc3QgeCA9IGl4ICogc2VnbWVudF93aWR0aCAtIHdpZHRoX2hhbGY7XG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goeCwgLXksIDApO1xuXHRcdFx0XHRub3JtYWxzLnB1c2goMCwgMCwgMSk7XG5cdFx0XHRcdHV2cy5wdXNoKGl4IC8gZ3JpZFgpO1xuXHRcdFx0XHR1dnMucHVzaCgxIC0gaXkgLyBncmlkWSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGZvciAobGV0IGl5ID0gMDsgaXkgPCBncmlkWTsgaXkrKykge1xuXHRcdFx0Zm9yIChsZXQgaXggPSAwOyBpeCA8IGdyaWRYOyBpeCsrKSB7XG5cdFx0XHRcdGNvbnN0IGEgPSBpeCArIGdyaWRYMSAqIGl5O1xuXHRcdFx0XHRjb25zdCBiID0gaXggKyBncmlkWDEgKiAoaXkgKyAxKTtcblx0XHRcdFx0Y29uc3QgYyA9IGl4ICsgMSArIGdyaWRYMSAqIChpeSArIDEpO1xuXHRcdFx0XHRjb25zdCBkID0gaXggKyAxICsgZ3JpZFgxICogaXk7XG5cdFx0XHRcdGluZGljZXMucHVzaChhLCBiLCBkKTtcblx0XHRcdFx0aW5kaWNlcy5wdXNoKGIsIGMsIGQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLnNldEluZGV4KGluZGljZXMpO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHZlcnRpY2VzLCAzKSk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKG5vcm1hbHMsIDMpKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSgndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh1dnMsIDIpKTtcblx0fVxuXHRzdGF0aWMgZnJvbUpTT04oZGF0YSkge1xuXHRcdHJldHVybiBuZXcgUGxhbmVHZW9tZXRyeShkYXRhLndpZHRoLCBkYXRhLmhlaWdodCwgZGF0YS53aWR0aFNlZ21lbnRzLCBkYXRhLmhlaWdodFNlZ21lbnRzKTtcblx0fVxufVxuXG52YXIgYWxwaGFtYXBfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfQUxQSEFNQVBcXG5cXHRkaWZmdXNlQ29sb3IuYSAqPSB0ZXh0dXJlMkQoIGFscGhhTWFwLCB2VXYgKS5nO1xcbiNlbmRpZlwiO1xuXG52YXIgYWxwaGFtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9BTFBIQU1BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGFscGhhTWFwO1xcbiNlbmRpZlwiO1xuXG52YXIgYWxwaGF0ZXN0X2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0FMUEhBVEVTVFxcblxcdGlmICggZGlmZnVzZUNvbG9yLmEgPCBhbHBoYVRlc3QgKSBkaXNjYXJkO1xcbiNlbmRpZlwiO1xuXG52YXIgYWxwaGF0ZXN0X3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfQUxQSEFURVNUXFxuXFx0dW5pZm9ybSBmbG9hdCBhbHBoYVRlc3Q7XFxuI2VuZGlmXCI7XG5cbnZhciBhb21hcF9mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9BT01BUFxcblxcdGZsb2F0IGFtYmllbnRPY2NsdXNpb24gPSAoIHRleHR1cmUyRCggYW9NYXAsIHZVdjIgKS5yIC0gMS4wICkgKiBhb01hcEludGVuc2l0eSArIDEuMDtcXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKj0gYW1iaWVudE9jY2x1c2lvbjtcXG5cXHQjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApICYmIGRlZmluZWQoIFNUQU5EQVJEIClcXG5cXHRcXHRmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZ2VvbWV0cnkudmlld0RpciApICk7XFxuXFx0XFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3RTcGVjdWxhciAqPSBjb21wdXRlU3BlY3VsYXJPY2NsdXNpb24oIGRvdE5WLCBhbWJpZW50T2NjbHVzaW9uLCBtYXRlcmlhbC5yb3VnaG5lc3MgKTtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIjtcblxudmFyIGFvbWFwX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfQU9NQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBhb01hcDtcXG5cXHR1bmlmb3JtIGZsb2F0IGFvTWFwSW50ZW5zaXR5O1xcbiNlbmRpZlwiO1xuXG52YXIgYmVnaW5fdmVydGV4ID0gXCJ2ZWMzIHRyYW5zZm9ybWVkID0gdmVjMyggcG9zaXRpb24gKTtcIjtcblxudmFyIGJlZ2lubm9ybWFsX3ZlcnRleCA9IFwidmVjMyBvYmplY3ROb3JtYWwgPSB2ZWMzKCBub3JtYWwgKTtcXG4jaWZkZWYgVVNFX1RBTkdFTlRcXG5cXHR2ZWMzIG9iamVjdFRhbmdlbnQgPSB2ZWMzKCB0YW5nZW50Lnh5eiApO1xcbiNlbmRpZlwiO1xuXG52YXIgYnNkZnMgPSBcInZlYzMgQlJERl9MYW1iZXJ0KCBjb25zdCBpbiB2ZWMzIGRpZmZ1c2VDb2xvciApIHtcXG5cXHRyZXR1cm4gUkVDSVBST0NBTF9QSSAqIGRpZmZ1c2VDb2xvcjtcXG59XFxudmVjMyBGX1NjaGxpY2soIGNvbnN0IGluIHZlYzMgZjAsIGNvbnN0IGluIGZsb2F0IGY5MCwgY29uc3QgaW4gZmxvYXQgZG90VkggKSB7XFxuXFx0ZmxvYXQgZnJlc25lbCA9IGV4cDIoICggLSA1LjU1NDczICogZG90VkggLSA2Ljk4MzE2ICkgKiBkb3RWSCApO1xcblxcdHJldHVybiBmMCAqICggMS4wIC0gZnJlc25lbCApICsgKCBmOTAgKiBmcmVzbmVsICk7XFxufVxcbmZsb2F0IEZfU2NobGljayggY29uc3QgaW4gZmxvYXQgZjAsIGNvbnN0IGluIGZsb2F0IGY5MCwgY29uc3QgaW4gZmxvYXQgZG90VkggKSB7XFxuXFx0ZmxvYXQgZnJlc25lbCA9IGV4cDIoICggLSA1LjU1NDczICogZG90VkggLSA2Ljk4MzE2ICkgKiBkb3RWSCApO1xcblxcdHJldHVybiBmMCAqICggMS4wIC0gZnJlc25lbCApICsgKCBmOTAgKiBmcmVzbmVsICk7XFxufVxcbnZlYzMgU2NobGlja190b19GMCggY29uc3QgaW4gdmVjMyBmLCBjb25zdCBpbiBmbG9hdCBmOTAsIGNvbnN0IGluIGZsb2F0IGRvdFZIICkge1xcblx0XHRmbG9hdCB4ID0gY2xhbXAoIDEuMCAtIGRvdFZILCAwLjAsIDEuMCApO1xcblx0XHRmbG9hdCB4MiA9IHggKiB4O1xcblx0XHRmbG9hdCB4NSA9IGNsYW1wKCB4ICogeDIgKiB4MiwgMC4wLCAwLjk5OTkgKTtcXG5cdFx0cmV0dXJuICggZiAtIHZlYzMoIGY5MCApICogeDUgKSAvICggMS4wIC0geDUgKTtcXG59XFxuZmxvYXQgVl9HR1hfU21pdGhDb3JyZWxhdGVkKCBjb25zdCBpbiBmbG9hdCBhbHBoYSwgY29uc3QgaW4gZmxvYXQgZG90TkwsIGNvbnN0IGluIGZsb2F0IGRvdE5WICkge1xcblxcdGZsb2F0IGEyID0gcG93MiggYWxwaGEgKTtcXG5cXHRmbG9hdCBndiA9IGRvdE5MICogc3FydCggYTIgKyAoIDEuMCAtIGEyICkgKiBwb3cyKCBkb3ROViApICk7XFxuXFx0ZmxvYXQgZ2wgPSBkb3ROViAqIHNxcnQoIGEyICsgKCAxLjAgLSBhMiApICogcG93MiggZG90TkwgKSApO1xcblxcdHJldHVybiAwLjUgLyBtYXgoIGd2ICsgZ2wsIEVQU0lMT04gKTtcXG59XFxuZmxvYXQgRF9HR1goIGNvbnN0IGluIGZsb2F0IGFscGhhLCBjb25zdCBpbiBmbG9hdCBkb3ROSCApIHtcXG5cXHRmbG9hdCBhMiA9IHBvdzIoIGFscGhhICk7XFxuXFx0ZmxvYXQgZGVub20gPSBwb3cyKCBkb3ROSCApICogKCBhMiAtIDEuMCApICsgMS4wO1xcblxcdHJldHVybiBSRUNJUFJPQ0FMX1BJICogYTIgLyBwb3cyKCBkZW5vbSApO1xcbn1cXG52ZWMzIEJSREZfR0dYKCBjb25zdCBpbiB2ZWMzIGxpZ2h0RGlyLCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIHZlYzMgbm9ybWFsLCBjb25zdCBpbiB2ZWMzIGYwLCBjb25zdCBpbiBmbG9hdCBmOTAsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHtcXG5cXHRmbG9hdCBhbHBoYSA9IHBvdzIoIHJvdWdobmVzcyApO1xcblxcdHZlYzMgaGFsZkRpciA9IG5vcm1hbGl6ZSggbGlnaHREaXIgKyB2aWV3RGlyICk7XFxuXFx0ZmxvYXQgZG90TkwgPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGxpZ2h0RGlyICkgKTtcXG5cXHRmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgdmlld0RpciApICk7XFxuXFx0ZmxvYXQgZG90TkggPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGhhbGZEaXIgKSApO1xcblxcdGZsb2F0IGRvdFZIID0gc2F0dXJhdGUoIGRvdCggdmlld0RpciwgaGFsZkRpciApICk7XFxuXFx0dmVjMyBGID0gRl9TY2hsaWNrKCBmMCwgZjkwLCBkb3RWSCApO1xcblxcdGZsb2F0IFYgPSBWX0dHWF9TbWl0aENvcnJlbGF0ZWQoIGFscGhhLCBkb3ROTCwgZG90TlYgKTtcXG5cXHRmbG9hdCBEID0gRF9HR1goIGFscGhhLCBkb3ROSCApO1xcblxcdHJldHVybiBGICogKCBWICogRCApO1xcbn1cXG4jaWZkZWYgVVNFX0lSSURFU0NFTkNFXFxuXFx0dmVjMyBCUkRGX0dHWF9JcmlkZXNjZW5jZSggY29uc3QgaW4gdmVjMyBsaWdodERpciwgY29uc3QgaW4gdmVjMyB2aWV3RGlyLCBjb25zdCBpbiB2ZWMzIG5vcm1hbCwgY29uc3QgaW4gdmVjMyBmMCwgY29uc3QgaW4gZmxvYXQgZjkwLCBjb25zdCBpbiBmbG9hdCBpcmlkZXNjZW5jZSwgY29uc3QgaW4gdmVjMyBpcmlkZXNjZW5jZUZyZXNuZWwsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHtcXG5cXHRcXHRmbG9hdCBhbHBoYSA9IHBvdzIoIHJvdWdobmVzcyApO1xcblxcdFxcdHZlYzMgaGFsZkRpciA9IG5vcm1hbGl6ZSggbGlnaHREaXIgKyB2aWV3RGlyICk7XFxuXFx0XFx0ZmxvYXQgZG90TkwgPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGxpZ2h0RGlyICkgKTtcXG5cXHRcXHRmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgdmlld0RpciApICk7XFxuXFx0XFx0ZmxvYXQgZG90TkggPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGhhbGZEaXIgKSApO1xcblxcdFxcdGZsb2F0IGRvdFZIID0gc2F0dXJhdGUoIGRvdCggdmlld0RpciwgaGFsZkRpciApICk7XFxuXFx0XFx0dmVjMyBGID0gbWl4KCBGX1NjaGxpY2soIGYwLCBmOTAsIGRvdFZIICksIGlyaWRlc2NlbmNlRnJlc25lbCwgaXJpZGVzY2VuY2UgKTtcXG5cXHRcXHRmbG9hdCBWID0gVl9HR1hfU21pdGhDb3JyZWxhdGVkKCBhbHBoYSwgZG90TkwsIGRvdE5WICk7XFxuXFx0XFx0ZmxvYXQgRCA9IERfR0dYKCBhbHBoYSwgZG90TkggKTtcXG5cXHRcXHRyZXR1cm4gRiAqICggViAqIEQgKTtcXG5cXHR9XFxuI2VuZGlmXFxudmVjMiBMVENfVXYoIGNvbnN0IGluIHZlYzMgTiwgY29uc3QgaW4gdmVjMyBWLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MgKSB7XFxuXFx0Y29uc3QgZmxvYXQgTFVUX1NJWkUgPSA2NC4wO1xcblxcdGNvbnN0IGZsb2F0IExVVF9TQ0FMRSA9ICggTFVUX1NJWkUgLSAxLjAgKSAvIExVVF9TSVpFO1xcblxcdGNvbnN0IGZsb2F0IExVVF9CSUFTID0gMC41IC8gTFVUX1NJWkU7XFxuXFx0ZmxvYXQgZG90TlYgPSBzYXR1cmF0ZSggZG90KCBOLCBWICkgKTtcXG5cXHR2ZWMyIHV2ID0gdmVjMiggcm91Z2huZXNzLCBzcXJ0KCAxLjAgLSBkb3ROViApICk7XFxuXFx0dXYgPSB1diAqIExVVF9TQ0FMRSArIExVVF9CSUFTO1xcblxcdHJldHVybiB1djtcXG59XFxuZmxvYXQgTFRDX0NsaXBwZWRTcGhlcmVGb3JtRmFjdG9yKCBjb25zdCBpbiB2ZWMzIGYgKSB7XFxuXFx0ZmxvYXQgbCA9IGxlbmd0aCggZiApO1xcblxcdHJldHVybiBtYXgoICggbCAqIGwgKyBmLnogKSAvICggbCArIDEuMCApLCAwLjAgKTtcXG59XFxudmVjMyBMVENfRWRnZVZlY3RvckZvcm1GYWN0b3IoIGNvbnN0IGluIHZlYzMgdjEsIGNvbnN0IGluIHZlYzMgdjIgKSB7XFxuXFx0ZmxvYXQgeCA9IGRvdCggdjEsIHYyICk7XFxuXFx0ZmxvYXQgeSA9IGFicyggeCApO1xcblxcdGZsb2F0IGEgPSAwLjg1NDM5ODUgKyAoIDAuNDk2NTE1NSArIDAuMDE0NTIwNiAqIHkgKSAqIHk7XFxuXFx0ZmxvYXQgYiA9IDMuNDE3NTk0MCArICggNC4xNjE2NzI0ICsgeSApICogeTtcXG5cXHRmbG9hdCB2ID0gYSAvIGI7XFxuXFx0ZmxvYXQgdGhldGFfc2ludGhldGEgPSAoIHggPiAwLjAgKSA/IHYgOiAwLjUgKiBpbnZlcnNlc3FydCggbWF4KCAxLjAgLSB4ICogeCwgMWUtNyApICkgLSB2O1xcblxcdHJldHVybiBjcm9zcyggdjEsIHYyICkgKiB0aGV0YV9zaW50aGV0YTtcXG59XFxudmVjMyBMVENfRXZhbHVhdGUoIGNvbnN0IGluIHZlYzMgTiwgY29uc3QgaW4gdmVjMyBWLCBjb25zdCBpbiB2ZWMzIFAsIGNvbnN0IGluIG1hdDMgbUludiwgY29uc3QgaW4gdmVjMyByZWN0Q29vcmRzWyA0IF0gKSB7XFxuXFx0dmVjMyB2MSA9IHJlY3RDb29yZHNbIDEgXSAtIHJlY3RDb29yZHNbIDAgXTtcXG5cXHR2ZWMzIHYyID0gcmVjdENvb3Jkc1sgMyBdIC0gcmVjdENvb3Jkc1sgMCBdO1xcblxcdHZlYzMgbGlnaHROb3JtYWwgPSBjcm9zcyggdjEsIHYyICk7XFxuXFx0aWYoIGRvdCggbGlnaHROb3JtYWwsIFAgLSByZWN0Q29vcmRzWyAwIF0gKSA8IDAuMCApIHJldHVybiB2ZWMzKCAwLjAgKTtcXG5cXHR2ZWMzIFQxLCBUMjtcXG5cXHRUMSA9IG5vcm1hbGl6ZSggViAtIE4gKiBkb3QoIFYsIE4gKSApO1xcblxcdFQyID0gLSBjcm9zcyggTiwgVDEgKTtcXG5cXHRtYXQzIG1hdCA9IG1JbnYgKiB0cmFuc3Bvc2VNYXQzKCBtYXQzKCBUMSwgVDIsIE4gKSApO1xcblxcdHZlYzMgY29vcmRzWyA0IF07XFxuXFx0Y29vcmRzWyAwIF0gPSBtYXQgKiAoIHJlY3RDb29yZHNbIDAgXSAtIFAgKTtcXG5cXHRjb29yZHNbIDEgXSA9IG1hdCAqICggcmVjdENvb3Jkc1sgMSBdIC0gUCApO1xcblxcdGNvb3Jkc1sgMiBdID0gbWF0ICogKCByZWN0Q29vcmRzWyAyIF0gLSBQICk7XFxuXFx0Y29vcmRzWyAzIF0gPSBtYXQgKiAoIHJlY3RDb29yZHNbIDMgXSAtIFAgKTtcXG5cXHRjb29yZHNbIDAgXSA9IG5vcm1hbGl6ZSggY29vcmRzWyAwIF0gKTtcXG5cXHRjb29yZHNbIDEgXSA9IG5vcm1hbGl6ZSggY29vcmRzWyAxIF0gKTtcXG5cXHRjb29yZHNbIDIgXSA9IG5vcm1hbGl6ZSggY29vcmRzWyAyIF0gKTtcXG5cXHRjb29yZHNbIDMgXSA9IG5vcm1hbGl6ZSggY29vcmRzWyAzIF0gKTtcXG5cXHR2ZWMzIHZlY3RvckZvcm1GYWN0b3IgPSB2ZWMzKCAwLjAgKTtcXG5cXHR2ZWN0b3JGb3JtRmFjdG9yICs9IExUQ19FZGdlVmVjdG9yRm9ybUZhY3RvciggY29vcmRzWyAwIF0sIGNvb3Jkc1sgMSBdICk7XFxuXFx0dmVjdG9yRm9ybUZhY3RvciArPSBMVENfRWRnZVZlY3RvckZvcm1GYWN0b3IoIGNvb3Jkc1sgMSBdLCBjb29yZHNbIDIgXSApO1xcblxcdHZlY3RvckZvcm1GYWN0b3IgKz0gTFRDX0VkZ2VWZWN0b3JGb3JtRmFjdG9yKCBjb29yZHNbIDIgXSwgY29vcmRzWyAzIF0gKTtcXG5cXHR2ZWN0b3JGb3JtRmFjdG9yICs9IExUQ19FZGdlVmVjdG9yRm9ybUZhY3RvciggY29vcmRzWyAzIF0sIGNvb3Jkc1sgMCBdICk7XFxuXFx0ZmxvYXQgcmVzdWx0ID0gTFRDX0NsaXBwZWRTcGhlcmVGb3JtRmFjdG9yKCB2ZWN0b3JGb3JtRmFjdG9yICk7XFxuXFx0cmV0dXJuIHZlYzMoIHJlc3VsdCApO1xcbn1cXG5mbG9hdCBHX0JsaW5uUGhvbmdfSW1wbGljaXQoICkge1xcblxcdHJldHVybiAwLjI1O1xcbn1cXG5mbG9hdCBEX0JsaW5uUGhvbmcoIGNvbnN0IGluIGZsb2F0IHNoaW5pbmVzcywgY29uc3QgaW4gZmxvYXQgZG90TkggKSB7XFxuXFx0cmV0dXJuIFJFQ0lQUk9DQUxfUEkgKiAoIHNoaW5pbmVzcyAqIDAuNSArIDEuMCApICogcG93KCBkb3ROSCwgc2hpbmluZXNzICk7XFxufVxcbnZlYzMgQlJERl9CbGlublBob25nKCBjb25zdCBpbiB2ZWMzIGxpZ2h0RGlyLCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIHZlYzMgbm9ybWFsLCBjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IHNoaW5pbmVzcyApIHtcXG5cXHR2ZWMzIGhhbGZEaXIgPSBub3JtYWxpemUoIGxpZ2h0RGlyICsgdmlld0RpciApO1xcblxcdGZsb2F0IGRvdE5IID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCBoYWxmRGlyICkgKTtcXG5cXHRmbG9hdCBkb3RWSCA9IHNhdHVyYXRlKCBkb3QoIHZpZXdEaXIsIGhhbGZEaXIgKSApO1xcblxcdHZlYzMgRiA9IEZfU2NobGljayggc3BlY3VsYXJDb2xvciwgMS4wLCBkb3RWSCApO1xcblxcdGZsb2F0IEcgPSBHX0JsaW5uUGhvbmdfSW1wbGljaXQoICk7XFxuXFx0ZmxvYXQgRCA9IERfQmxpbm5QaG9uZyggc2hpbmluZXNzLCBkb3ROSCApO1xcblxcdHJldHVybiBGICogKCBHICogRCApO1xcbn1cXG4jaWYgZGVmaW5lZCggVVNFX1NIRUVOIClcXG5mbG9hdCBEX0NoYXJsaWUoIGZsb2F0IHJvdWdobmVzcywgZmxvYXQgZG90TkggKSB7XFxuXFx0ZmxvYXQgYWxwaGEgPSBwb3cyKCByb3VnaG5lc3MgKTtcXG5cXHRmbG9hdCBpbnZBbHBoYSA9IDEuMCAvIGFscGhhO1xcblxcdGZsb2F0IGNvczJoID0gZG90TkggKiBkb3ROSDtcXG5cXHRmbG9hdCBzaW4yaCA9IG1heCggMS4wIC0gY29zMmgsIDAuMDA3ODEyNSApO1xcblxcdHJldHVybiAoIDIuMCArIGludkFscGhhICkgKiBwb3coIHNpbjJoLCBpbnZBbHBoYSAqIDAuNSApIC8gKCAyLjAgKiBQSSApO1xcbn1cXG5mbG9hdCBWX05ldWJlbHQoIGZsb2F0IGRvdE5WLCBmbG9hdCBkb3ROTCApIHtcXG5cXHRyZXR1cm4gc2F0dXJhdGUoIDEuMCAvICggNC4wICogKCBkb3ROTCArIGRvdE5WIC0gZG90TkwgKiBkb3ROViApICkgKTtcXG59XFxudmVjMyBCUkRGX1NoZWVuKCBjb25zdCBpbiB2ZWMzIGxpZ2h0RGlyLCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIHZlYzMgbm9ybWFsLCB2ZWMzIHNoZWVuQ29sb3IsIGNvbnN0IGluIGZsb2F0IHNoZWVuUm91Z2huZXNzICkge1xcblxcdHZlYzMgaGFsZkRpciA9IG5vcm1hbGl6ZSggbGlnaHREaXIgKyB2aWV3RGlyICk7XFxuXFx0ZmxvYXQgZG90TkwgPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGxpZ2h0RGlyICkgKTtcXG5cXHRmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgdmlld0RpciApICk7XFxuXFx0ZmxvYXQgZG90TkggPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGhhbGZEaXIgKSApO1xcblxcdGZsb2F0IEQgPSBEX0NoYXJsaWUoIHNoZWVuUm91Z2huZXNzLCBkb3ROSCApO1xcblxcdGZsb2F0IFYgPSBWX05ldWJlbHQoIGRvdE5WLCBkb3ROTCApO1xcblxcdHJldHVybiBzaGVlbkNvbG9yICogKCBEICogViApO1xcbn1cXG4jZW5kaWZcIjtcblxudmFyIGlyaWRlc2NlbmNlX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0lSSURFU0NFTkNFXFxuXFx0Y29uc3QgbWF0MyBYWVpfVE9fUkVDNzA5ID0gbWF0MyhcXG5cXHRcXHQgMy4yNDA0NTQyLCAtMC45NjkyNjYwLFx0MC4wNTU2NDM0LFxcblxcdFxcdC0xLjUzNzEzODUsXHQxLjg3NjAxMDgsIC0wLjIwNDAyNTksXFxuXFx0XFx0LTAuNDk4NTMxNCxcdDAuMDQxNTU2MCxcdDEuMDU3MjI1MlxcblxcdCk7XFxuXFx0dmVjMyBGcmVzbmVsMFRvSW9yKCB2ZWMzIGZyZXNuZWwwICkge1xcblxcdFxcdHZlYzMgc3FydEYwID0gc3FydCggZnJlc25lbDAgKTtcXG5cXHRcXHRyZXR1cm4gKCB2ZWMzKCAxLjAgKSArIHNxcnRGMCApIC8gKCB2ZWMzKCAxLjAgKSAtIHNxcnRGMCApO1xcblxcdH1cXG5cXHR2ZWMzIElvclRvRnJlc25lbDAoIHZlYzMgdHJhbnNtaXR0ZWRJb3IsIGZsb2F0IGluY2lkZW50SW9yICkge1xcblxcdFxcdHJldHVybiBwb3cyKCAoIHRyYW5zbWl0dGVkSW9yIC0gdmVjMyggaW5jaWRlbnRJb3IgKSApIC8gKCB0cmFuc21pdHRlZElvciArIHZlYzMoIGluY2lkZW50SW9yICkgKSApO1xcblxcdH1cXG5cXHRmbG9hdCBJb3JUb0ZyZXNuZWwwKCBmbG9hdCB0cmFuc21pdHRlZElvciwgZmxvYXQgaW5jaWRlbnRJb3IgKSB7XFxuXFx0XFx0cmV0dXJuIHBvdzIoICggdHJhbnNtaXR0ZWRJb3IgLSBpbmNpZGVudElvciApIC8gKCB0cmFuc21pdHRlZElvciArIGluY2lkZW50SW9yICkpO1xcblxcdH1cXG5cXHR2ZWMzIGV2YWxTZW5zaXRpdml0eSggZmxvYXQgT1BELCB2ZWMzIHNoaWZ0ICkge1xcblxcdFxcdGZsb2F0IHBoYXNlID0gMi4wICogUEkgKiBPUEQgKiAxLjBlLTk7XFxuXFx0XFx0dmVjMyB2YWwgPSB2ZWMzKCA1LjQ4NTZlLTEzLCA0LjQyMDFlLTEzLCA1LjI0ODFlLTEzICk7XFxuXFx0XFx0dmVjMyBwb3MgPSB2ZWMzKCAxLjY4MTBlKzA2LCAxLjc5NTNlKzA2LCAyLjIwODRlKzA2ICk7XFxuXFx0XFx0dmVjMyB2YXIgPSB2ZWMzKCA0LjMyNzhlKzA5LCA5LjMwNDZlKzA5LCA2LjYxMjFlKzA5ICk7XFxuXFx0XFx0dmVjMyB4eXogPSB2YWwgKiBzcXJ0KCAyLjAgKiBQSSAqIHZhciApICogY29zKCBwb3MgKiBwaGFzZSArIHNoaWZ0ICkgKiBleHAoIC0gcG93MiggcGhhc2UgKSAqIHZhciApO1xcblxcdFxcdHh5ei54ICs9IDkuNzQ3MGUtMTQgKiBzcXJ0KCAyLjAgKiBQSSAqIDQuNTI4MmUrMDkgKSAqIGNvcyggMi4yMzk5ZSswNiAqIHBoYXNlICsgc2hpZnRbIDAgXSApICogZXhwKCAtIDQuNTI4MmUrMDkgKiBwb3cyKCBwaGFzZSApICk7XFxuXFx0XFx0eHl6IC89IDEuMDY4NWUtNztcXG5cXHRcXHR2ZWMzIHJnYiA9IFhZWl9UT19SRUM3MDkgKiB4eXo7XFxuXFx0XFx0cmV0dXJuIHJnYjtcXG5cXHR9XFxuXFx0dmVjMyBldmFsSXJpZGVzY2VuY2UoIGZsb2F0IG91dHNpZGVJT1IsIGZsb2F0IGV0YTIsIGZsb2F0IGNvc1RoZXRhMSwgZmxvYXQgdGhpbkZpbG1UaGlja25lc3MsIHZlYzMgYmFzZUYwICkge1xcblxcdFxcdHZlYzMgSTtcXG5cXHRcXHRmbG9hdCBpcmlkZXNjZW5jZUlPUiA9IG1peCggb3V0c2lkZUlPUiwgZXRhMiwgc21vb3Roc3RlcCggMC4wLCAwLjAzLCB0aGluRmlsbVRoaWNrbmVzcyApICk7XFxuXFx0XFx0ZmxvYXQgc2luVGhldGEyU3EgPSBwb3cyKCBvdXRzaWRlSU9SIC8gaXJpZGVzY2VuY2VJT1IgKSAqICggMS4wIC0gcG93MiggY29zVGhldGExICkgKTtcXG5cXHRcXHRmbG9hdCBjb3NUaGV0YTJTcSA9IDEuMCAtIHNpblRoZXRhMlNxO1xcblxcdFxcdGlmICggY29zVGhldGEyU3EgPCAwLjAgKSB7XFxuXFx0XFx0XFx0IHJldHVybiB2ZWMzKCAxLjAgKTtcXG5cXHRcXHR9XFxuXFx0XFx0ZmxvYXQgY29zVGhldGEyID0gc3FydCggY29zVGhldGEyU3EgKTtcXG5cXHRcXHRmbG9hdCBSMCA9IElvclRvRnJlc25lbDAoIGlyaWRlc2NlbmNlSU9SLCBvdXRzaWRlSU9SICk7XFxuXFx0XFx0ZmxvYXQgUjEyID0gRl9TY2hsaWNrKCBSMCwgMS4wLCBjb3NUaGV0YTEgKTtcXG5cXHRcXHRmbG9hdCBSMjEgPSBSMTI7XFxuXFx0XFx0ZmxvYXQgVDEyMSA9IDEuMCAtIFIxMjtcXG5cXHRcXHRmbG9hdCBwaGkxMiA9IDAuMDtcXG5cXHRcXHRpZiAoIGlyaWRlc2NlbmNlSU9SIDwgb3V0c2lkZUlPUiApIHBoaTEyID0gUEk7XFxuXFx0XFx0ZmxvYXQgcGhpMjEgPSBQSSAtIHBoaTEyO1xcblxcdFxcdHZlYzMgYmFzZUlPUiA9IEZyZXNuZWwwVG9Jb3IoIGNsYW1wKCBiYXNlRjAsIDAuMCwgMC45OTk5ICkgKTtcXHRcXHR2ZWMzIFIxID0gSW9yVG9GcmVzbmVsMCggYmFzZUlPUiwgaXJpZGVzY2VuY2VJT1IgKTtcXG5cXHRcXHR2ZWMzIFIyMyA9IEZfU2NobGljayggUjEsIDEuMCwgY29zVGhldGEyICk7XFxuXFx0XFx0dmVjMyBwaGkyMyA9IHZlYzMoIDAuMCApO1xcblxcdFxcdGlmICggYmFzZUlPUlsgMCBdIDwgaXJpZGVzY2VuY2VJT1IgKSBwaGkyM1sgMCBdID0gUEk7XFxuXFx0XFx0aWYgKCBiYXNlSU9SWyAxIF0gPCBpcmlkZXNjZW5jZUlPUiApIHBoaTIzWyAxIF0gPSBQSTtcXG5cXHRcXHRpZiAoIGJhc2VJT1JbIDIgXSA8IGlyaWRlc2NlbmNlSU9SICkgcGhpMjNbIDIgXSA9IFBJO1xcblxcdFxcdGZsb2F0IE9QRCA9IDIuMCAqIGlyaWRlc2NlbmNlSU9SICogdGhpbkZpbG1UaGlja25lc3MgKiBjb3NUaGV0YTI7XFxuXFx0XFx0dmVjMyBwaGkgPSB2ZWMzKCBwaGkyMSApICsgcGhpMjM7XFxuXFx0XFx0dmVjMyBSMTIzID0gY2xhbXAoIFIxMiAqIFIyMywgMWUtNSwgMC45OTk5ICk7XFxuXFx0XFx0dmVjMyByMTIzID0gc3FydCggUjEyMyApO1xcblxcdFxcdHZlYzMgUnMgPSBwb3cyKCBUMTIxICkgKiBSMjMgLyAoIHZlYzMoIDEuMCApIC0gUjEyMyApO1xcblxcdFxcdHZlYzMgQzAgPSBSMTIgKyBScztcXG5cXHRcXHRJID0gQzA7XFxuXFx0XFx0dmVjMyBDbSA9IFJzIC0gVDEyMTtcXG5cXHRcXHRmb3IgKCBpbnQgbSA9IDE7IG0gPD0gMjsgKysgbSApIHtcXG5cXHRcXHRcXHRDbSAqPSByMTIzO1xcblxcdFxcdFxcdHZlYzMgU20gPSAyLjAgKiBldmFsU2Vuc2l0aXZpdHkoIGZsb2F0KCBtICkgKiBPUEQsIGZsb2F0KCBtICkgKiBwaGkgKTtcXG5cXHRcXHRcXHRJICs9IENtICogU207XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiBtYXgoIEksIHZlYzMoIDAuMCApICk7XFxuXFx0fVxcbiNlbmRpZlwiO1xuXG52YXIgYnVtcG1hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0JVTVBNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBidW1wTWFwO1xcblxcdHVuaWZvcm0gZmxvYXQgYnVtcFNjYWxlO1xcblxcdHZlYzIgZEhkeHlfZndkKCkge1xcblxcdFxcdHZlYzIgZFNUZHggPSBkRmR4KCB2VXYgKTtcXG5cXHRcXHR2ZWMyIGRTVGR5ID0gZEZkeSggdlV2ICk7XFxuXFx0XFx0ZmxvYXQgSGxsID0gYnVtcFNjYWxlICogdGV4dHVyZTJEKCBidW1wTWFwLCB2VXYgKS54O1xcblxcdFxcdGZsb2F0IGRCeCA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdlV2ICsgZFNUZHggKS54IC0gSGxsO1xcblxcdFxcdGZsb2F0IGRCeSA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdlV2ICsgZFNUZHkgKS54IC0gSGxsO1xcblxcdFxcdHJldHVybiB2ZWMyKCBkQngsIGRCeSApO1xcblxcdH1cXG5cXHR2ZWMzIHBlcnR1cmJOb3JtYWxBcmIoIHZlYzMgc3VyZl9wb3MsIHZlYzMgc3VyZl9ub3JtLCB2ZWMyIGRIZHh5LCBmbG9hdCBmYWNlRGlyZWN0aW9uICkge1xcblxcdFxcdHZlYzMgdlNpZ21hWCA9IGRGZHgoIHN1cmZfcG9zLnh5eiApO1xcblxcdFxcdHZlYzMgdlNpZ21hWSA9IGRGZHkoIHN1cmZfcG9zLnh5eiApO1xcblxcdFxcdHZlYzMgdk4gPSBzdXJmX25vcm07XFxuXFx0XFx0dmVjMyBSMSA9IGNyb3NzKCB2U2lnbWFZLCB2TiApO1xcblxcdFxcdHZlYzMgUjIgPSBjcm9zcyggdk4sIHZTaWdtYVggKTtcXG5cXHRcXHRmbG9hdCBmRGV0ID0gZG90KCB2U2lnbWFYLCBSMSApICogZmFjZURpcmVjdGlvbjtcXG5cXHRcXHR2ZWMzIHZHcmFkID0gc2lnbiggZkRldCApICogKCBkSGR4eS54ICogUjEgKyBkSGR4eS55ICogUjIgKTtcXG5cXHRcXHRyZXR1cm4gbm9ybWFsaXplKCBhYnMoIGZEZXQgKSAqIHN1cmZfbm9ybSAtIHZHcmFkICk7XFxuXFx0fVxcbiNlbmRpZlwiO1xuXG52YXIgY2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50ID0gXCIjaWYgTlVNX0NMSVBQSU5HX1BMQU5FUyA+IDBcXG5cXHR2ZWM0IHBsYW5lO1xcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBVTklPTl9DTElQUElOR19QTEFORVM7IGkgKysgKSB7XFxuXFx0XFx0cGxhbmUgPSBjbGlwcGluZ1BsYW5lc1sgaSBdO1xcblxcdFxcdGlmICggZG90KCB2Q2xpcFBvc2l0aW9uLCBwbGFuZS54eXogKSA+IHBsYW5lLncgKSBkaXNjYXJkO1xcblxcdH1cXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxcblxcdCNpZiBVTklPTl9DTElQUElOR19QTEFORVMgPCBOVU1fQ0xJUFBJTkdfUExBTkVTXFxuXFx0XFx0Ym9vbCBjbGlwcGVkID0gdHJ1ZTtcXG5cXHRcXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0XFx0Zm9yICggaW50IGkgPSBVTklPTl9DTElQUElOR19QTEFORVM7IGkgPCBOVU1fQ0xJUFBJTkdfUExBTkVTOyBpICsrICkge1xcblxcdFxcdFxcdHBsYW5lID0gY2xpcHBpbmdQbGFuZXNbIGkgXTtcXG5cXHRcXHRcXHRjbGlwcGVkID0gKCBkb3QoIHZDbGlwUG9zaXRpb24sIHBsYW5lLnh5eiApID4gcGxhbmUudyApICYmIGNsaXBwZWQ7XFxuXFx0XFx0fVxcblxcdFxcdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXFxuXFx0XFx0aWYgKCBjbGlwcGVkICkgZGlzY2FyZDtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIjtcblxudmFyIGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50ID0gXCIjaWYgTlVNX0NMSVBQSU5HX1BMQU5FUyA+IDBcXG5cXHR2YXJ5aW5nIHZlYzMgdkNsaXBQb3NpdGlvbjtcXG5cXHR1bmlmb3JtIHZlYzQgY2xpcHBpbmdQbGFuZXNbIE5VTV9DTElQUElOR19QTEFORVMgXTtcXG4jZW5kaWZcIjtcblxudmFyIGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleCA9IFwiI2lmIE5VTV9DTElQUElOR19QTEFORVMgPiAwXFxuXFx0dmFyeWluZyB2ZWMzIHZDbGlwUG9zaXRpb247XFxuI2VuZGlmXCI7XG5cbnZhciBjbGlwcGluZ19wbGFuZXNfdmVydGV4ID0gXCIjaWYgTlVNX0NMSVBQSU5HX1BMQU5FUyA+IDBcXG5cXHR2Q2xpcFBvc2l0aW9uID0gLSBtdlBvc2l0aW9uLnh5ejtcXG4jZW5kaWZcIjtcblxudmFyIGNvbG9yX2ZyYWdtZW50ID0gXCIjaWYgZGVmaW5lZCggVVNFX0NPTE9SX0FMUEhBIClcXG5cXHRkaWZmdXNlQ29sb3IgKj0gdkNvbG9yO1xcbiNlbGlmIGRlZmluZWQoIFVTRV9DT0xPUiApXFxuXFx0ZGlmZnVzZUNvbG9yLnJnYiAqPSB2Q29sb3I7XFxuI2VuZGlmXCI7XG5cbnZhciBjb2xvcl9wYXJzX2ZyYWdtZW50ID0gXCIjaWYgZGVmaW5lZCggVVNFX0NPTE9SX0FMUEhBIClcXG5cXHR2YXJ5aW5nIHZlYzQgdkNvbG9yO1xcbiNlbGlmIGRlZmluZWQoIFVTRV9DT0xPUiApXFxuXFx0dmFyeWluZyB2ZWMzIHZDb2xvcjtcXG4jZW5kaWZcIjtcblxudmFyIGNvbG9yX3BhcnNfdmVydGV4ID0gXCIjaWYgZGVmaW5lZCggVVNFX0NPTE9SX0FMUEhBIClcXG5cXHR2YXJ5aW5nIHZlYzQgdkNvbG9yO1xcbiNlbGlmIGRlZmluZWQoIFVTRV9DT0xPUiApIHx8IGRlZmluZWQoIFVTRV9JTlNUQU5DSU5HX0NPTE9SIClcXG5cXHR2YXJ5aW5nIHZlYzMgdkNvbG9yO1xcbiNlbmRpZlwiO1xuXG52YXIgY29sb3JfdmVydGV4ID0gXCIjaWYgZGVmaW5lZCggVVNFX0NPTE9SX0FMUEhBIClcXG5cXHR2Q29sb3IgPSB2ZWM0KCAxLjAgKTtcXG4jZWxpZiBkZWZpbmVkKCBVU0VfQ09MT1IgKSB8fCBkZWZpbmVkKCBVU0VfSU5TVEFOQ0lOR19DT0xPUiApXFxuXFx0dkNvbG9yID0gdmVjMyggMS4wICk7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9DT0xPUlxcblxcdHZDb2xvciAqPSBjb2xvcjtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0lOU1RBTkNJTkdfQ09MT1JcXG5cXHR2Q29sb3IueHl6ICo9IGluc3RhbmNlQ29sb3IueHl6O1xcbiNlbmRpZlwiO1xuXG52YXIgY29tbW9uID0gXCIjZGVmaW5lIFBJIDMuMTQxNTkyNjUzNTg5NzkzXFxuI2RlZmluZSBQSTIgNi4yODMxODUzMDcxNzk1ODZcXG4jZGVmaW5lIFBJX0hBTEYgMS41NzA3OTYzMjY3OTQ4OTY2XFxuI2RlZmluZSBSRUNJUFJPQ0FMX1BJIDAuMzE4MzA5ODg2MTgzNzkwN1xcbiNkZWZpbmUgUkVDSVBST0NBTF9QSTIgMC4xNTkxNTQ5NDMwOTE4OTUzNVxcbiNkZWZpbmUgRVBTSUxPTiAxZS02XFxuI2lmbmRlZiBzYXR1cmF0ZVxcbiNkZWZpbmUgc2F0dXJhdGUoIGEgKSBjbGFtcCggYSwgMC4wLCAxLjAgKVxcbiNlbmRpZlxcbiNkZWZpbmUgd2hpdGVDb21wbGVtZW50KCBhICkgKCAxLjAgLSBzYXR1cmF0ZSggYSApIClcXG5mbG9hdCBwb3cyKCBjb25zdCBpbiBmbG9hdCB4ICkgeyByZXR1cm4geCp4OyB9XFxudmVjMyBwb3cyKCBjb25zdCBpbiB2ZWMzIHggKSB7IHJldHVybiB4Kng7IH1cXG5mbG9hdCBwb3czKCBjb25zdCBpbiBmbG9hdCB4ICkgeyByZXR1cm4geCp4Kng7IH1cXG5mbG9hdCBwb3c0KCBjb25zdCBpbiBmbG9hdCB4ICkgeyBmbG9hdCB4MiA9IHgqeDsgcmV0dXJuIHgyKngyOyB9XFxuZmxvYXQgbWF4MyggY29uc3QgaW4gdmVjMyB2ICkgeyByZXR1cm4gbWF4KCBtYXgoIHYueCwgdi55ICksIHYueiApOyB9XFxuZmxvYXQgYXZlcmFnZSggY29uc3QgaW4gdmVjMyB2ICkgeyByZXR1cm4gZG90KCB2LCB2ZWMzKCAwLjMzMzMzMzMgKSApOyB9XFxuaGlnaHAgZmxvYXQgcmFuZCggY29uc3QgaW4gdmVjMiB1diApIHtcXG5cXHRjb25zdCBoaWdocCBmbG9hdCBhID0gMTIuOTg5OCwgYiA9IDc4LjIzMywgYyA9IDQzNzU4LjU0NTM7XFxuXFx0aGlnaHAgZmxvYXQgZHQgPSBkb3QoIHV2Lnh5LCB2ZWMyKCBhLGIgKSApLCBzbiA9IG1vZCggZHQsIFBJICk7XFxuXFx0cmV0dXJuIGZyYWN0KCBzaW4oIHNuICkgKiBjICk7XFxufVxcbiNpZmRlZiBISUdIX1BSRUNJU0lPTlxcblxcdGZsb2F0IHByZWNpc2lvblNhZmVMZW5ndGgoIHZlYzMgdiApIHsgcmV0dXJuIGxlbmd0aCggdiApOyB9XFxuI2Vsc2VcXG5cXHRmbG9hdCBwcmVjaXNpb25TYWZlTGVuZ3RoKCB2ZWMzIHYgKSB7XFxuXFx0XFx0ZmxvYXQgbWF4Q29tcG9uZW50ID0gbWF4MyggYWJzKCB2ICkgKTtcXG5cXHRcXHRyZXR1cm4gbGVuZ3RoKCB2IC8gbWF4Q29tcG9uZW50ICkgKiBtYXhDb21wb25lbnQ7XFxuXFx0fVxcbiNlbmRpZlxcbnN0cnVjdCBJbmNpZGVudExpZ2h0IHtcXG5cXHR2ZWMzIGNvbG9yO1xcblxcdHZlYzMgZGlyZWN0aW9uO1xcblxcdGJvb2wgdmlzaWJsZTtcXG59O1xcbnN0cnVjdCBSZWZsZWN0ZWRMaWdodCB7XFxuXFx0dmVjMyBkaXJlY3REaWZmdXNlO1xcblxcdHZlYzMgZGlyZWN0U3BlY3VsYXI7XFxuXFx0dmVjMyBpbmRpcmVjdERpZmZ1c2U7XFxuXFx0dmVjMyBpbmRpcmVjdFNwZWN1bGFyO1xcbn07XFxuc3RydWN0IEdlb21ldHJpY0NvbnRleHQge1xcblxcdHZlYzMgcG9zaXRpb247XFxuXFx0dmVjMyBub3JtYWw7XFxuXFx0dmVjMyB2aWV3RGlyO1xcbiNpZmRlZiBVU0VfQ0xFQVJDT0FUXFxuXFx0dmVjMyBjbGVhcmNvYXROb3JtYWw7XFxuI2VuZGlmXFxufTtcXG52ZWMzIHRyYW5zZm9ybURpcmVjdGlvbiggaW4gdmVjMyBkaXIsIGluIG1hdDQgbWF0cml4ICkge1xcblxcdHJldHVybiBub3JtYWxpemUoICggbWF0cml4ICogdmVjNCggZGlyLCAwLjAgKSApLnh5eiApO1xcbn1cXG52ZWMzIGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIGluIHZlYzMgZGlyLCBpbiBtYXQ0IG1hdHJpeCApIHtcXG5cXHRyZXR1cm4gbm9ybWFsaXplKCAoIHZlYzQoIGRpciwgMC4wICkgKiBtYXRyaXggKS54eXogKTtcXG59XFxubWF0MyB0cmFuc3Bvc2VNYXQzKCBjb25zdCBpbiBtYXQzIG0gKSB7XFxuXFx0bWF0MyB0bXA7XFxuXFx0dG1wWyAwIF0gPSB2ZWMzKCBtWyAwIF0ueCwgbVsgMSBdLngsIG1bIDIgXS54ICk7XFxuXFx0dG1wWyAxIF0gPSB2ZWMzKCBtWyAwIF0ueSwgbVsgMSBdLnksIG1bIDIgXS55ICk7XFxuXFx0dG1wWyAyIF0gPSB2ZWMzKCBtWyAwIF0ueiwgbVsgMSBdLnosIG1bIDIgXS56ICk7XFxuXFx0cmV0dXJuIHRtcDtcXG59XFxuZmxvYXQgbHVtaW5hbmNlKCBjb25zdCBpbiB2ZWMzIHJnYiApIHtcXG5cXHRjb25zdCB2ZWMzIHdlaWdodHMgPSB2ZWMzKCAwLjIxMjY3MjksIDAuNzE1MTUyMiwgMC4wNzIxNzUwICk7XFxuXFx0cmV0dXJuIGRvdCggd2VpZ2h0cywgcmdiICk7XFxufVxcbmJvb2wgaXNQZXJzcGVjdGl2ZU1hdHJpeCggbWF0NCBtICkge1xcblxcdHJldHVybiBtWyAyIF1bIDMgXSA9PSAtIDEuMDtcXG59XFxudmVjMiBlcXVpcmVjdFV2KCBpbiB2ZWMzIGRpciApIHtcXG5cXHRmbG9hdCB1ID0gYXRhbiggZGlyLnosIGRpci54ICkgKiBSRUNJUFJPQ0FMX1BJMiArIDAuNTtcXG5cXHRmbG9hdCB2ID0gYXNpbiggY2xhbXAoIGRpci55LCAtIDEuMCwgMS4wICkgKSAqIFJFQ0lQUk9DQUxfUEkgKyAwLjU7XFxuXFx0cmV0dXJuIHZlYzIoIHUsIHYgKTtcXG59XCI7XG5cbnZhciBjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQgPSBcIiNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFX1VWXFxuXFx0I2RlZmluZSBjdWJlVVZfbWluTWlwTGV2ZWwgNC4wXFxuXFx0I2RlZmluZSBjdWJlVVZfbWluVGlsZVNpemUgMTYuMFxcblxcdGZsb2F0IGdldEZhY2UoIHZlYzMgZGlyZWN0aW9uICkge1xcblxcdFxcdHZlYzMgYWJzRGlyZWN0aW9uID0gYWJzKCBkaXJlY3Rpb24gKTtcXG5cXHRcXHRmbG9hdCBmYWNlID0gLSAxLjA7XFxuXFx0XFx0aWYgKCBhYnNEaXJlY3Rpb24ueCA+IGFic0RpcmVjdGlvbi56ICkge1xcblxcdFxcdFxcdGlmICggYWJzRGlyZWN0aW9uLnggPiBhYnNEaXJlY3Rpb24ueSApXFxuXFx0XFx0XFx0XFx0ZmFjZSA9IGRpcmVjdGlvbi54ID4gMC4wID8gMC4wIDogMy4wO1xcblxcdFxcdFxcdGVsc2VcXG5cXHRcXHRcXHRcXHRmYWNlID0gZGlyZWN0aW9uLnkgPiAwLjAgPyAxLjAgOiA0LjA7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRpZiAoIGFic0RpcmVjdGlvbi56ID4gYWJzRGlyZWN0aW9uLnkgKVxcblxcdFxcdFxcdFxcdGZhY2UgPSBkaXJlY3Rpb24ueiA+IDAuMCA/IDIuMCA6IDUuMDtcXG5cXHRcXHRcXHRlbHNlXFxuXFx0XFx0XFx0XFx0ZmFjZSA9IGRpcmVjdGlvbi55ID4gMC4wID8gMS4wIDogNC4wO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gZmFjZTtcXG5cXHR9XFxuXFx0dmVjMiBnZXRVViggdmVjMyBkaXJlY3Rpb24sIGZsb2F0IGZhY2UgKSB7XFxuXFx0XFx0dmVjMiB1djtcXG5cXHRcXHRpZiAoIGZhY2UgPT0gMC4wICkge1xcblxcdFxcdFxcdHV2ID0gdmVjMiggZGlyZWN0aW9uLnosIGRpcmVjdGlvbi55ICkgLyBhYnMoIGRpcmVjdGlvbi54ICk7XFxuXFx0XFx0fSBlbHNlIGlmICggZmFjZSA9PSAxLjAgKSB7XFxuXFx0XFx0XFx0dXYgPSB2ZWMyKCAtIGRpcmVjdGlvbi54LCAtIGRpcmVjdGlvbi56ICkgLyBhYnMoIGRpcmVjdGlvbi55ICk7XFxuXFx0XFx0fSBlbHNlIGlmICggZmFjZSA9PSAyLjAgKSB7XFxuXFx0XFx0XFx0dXYgPSB2ZWMyKCAtIGRpcmVjdGlvbi54LCBkaXJlY3Rpb24ueSApIC8gYWJzKCBkaXJlY3Rpb24ueiApO1xcblxcdFxcdH0gZWxzZSBpZiAoIGZhY2UgPT0gMy4wICkge1xcblxcdFxcdFxcdHV2ID0gdmVjMiggLSBkaXJlY3Rpb24ueiwgZGlyZWN0aW9uLnkgKSAvIGFicyggZGlyZWN0aW9uLnggKTtcXG5cXHRcXHR9IGVsc2UgaWYgKCBmYWNlID09IDQuMCApIHtcXG5cXHRcXHRcXHR1diA9IHZlYzIoIC0gZGlyZWN0aW9uLngsIGRpcmVjdGlvbi56ICkgLyBhYnMoIGRpcmVjdGlvbi55ICk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHR1diA9IHZlYzIoIGRpcmVjdGlvbi54LCBkaXJlY3Rpb24ueSApIC8gYWJzKCBkaXJlY3Rpb24ueiApO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gMC41ICogKCB1diArIDEuMCApO1xcblxcdH1cXG5cXHR2ZWMzIGJpbGluZWFyQ3ViZVVWKCBzYW1wbGVyMkQgZW52TWFwLCB2ZWMzIGRpcmVjdGlvbiwgZmxvYXQgbWlwSW50ICkge1xcblxcdFxcdGZsb2F0IGZhY2UgPSBnZXRGYWNlKCBkaXJlY3Rpb24gKTtcXG5cXHRcXHRmbG9hdCBmaWx0ZXJJbnQgPSBtYXgoIGN1YmVVVl9taW5NaXBMZXZlbCAtIG1pcEludCwgMC4wICk7XFxuXFx0XFx0bWlwSW50ID0gbWF4KCBtaXBJbnQsIGN1YmVVVl9taW5NaXBMZXZlbCApO1xcblxcdFxcdGZsb2F0IGZhY2VTaXplID0gZXhwMiggbWlwSW50ICk7XFxuXFx0XFx0dmVjMiB1diA9IGdldFVWKCBkaXJlY3Rpb24sIGZhY2UgKSAqICggZmFjZVNpemUgLSAyLjAgKSArIDEuMDtcXG5cXHRcXHRpZiAoIGZhY2UgPiAyLjAgKSB7XFxuXFx0XFx0XFx0dXYueSArPSBmYWNlU2l6ZTtcXG5cXHRcXHRcXHRmYWNlIC09IDMuMDtcXG5cXHRcXHR9XFxuXFx0XFx0dXYueCArPSBmYWNlICogZmFjZVNpemU7XFxuXFx0XFx0dXYueCArPSBmaWx0ZXJJbnQgKiAzLjAgKiBjdWJlVVZfbWluVGlsZVNpemU7XFxuXFx0XFx0dXYueSArPSA0LjAgKiAoIGV4cDIoIENVQkVVVl9NQVhfTUlQICkgLSBmYWNlU2l6ZSApO1xcblxcdFxcdHV2LnggKj0gQ1VCRVVWX1RFWEVMX1dJRFRIO1xcblxcdFxcdHV2LnkgKj0gQ1VCRVVWX1RFWEVMX0hFSUdIVDtcXG5cXHRcXHQjaWZkZWYgdGV4dHVyZTJER3JhZEVYVFxcblxcdFxcdFxcdHJldHVybiB0ZXh0dXJlMkRHcmFkRVhUKCBlbnZNYXAsIHV2LCB2ZWMyKCAwLjAgKSwgdmVjMiggMC4wICkgKS5yZ2I7XFxuXFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHRyZXR1cm4gdGV4dHVyZTJEKCBlbnZNYXAsIHV2ICkucmdiO1xcblxcdFxcdCNlbmRpZlxcblxcdH1cXG5cXHQjZGVmaW5lIGN1YmVVVl9yMCAxLjBcXG5cXHQjZGVmaW5lIGN1YmVVVl92MCAwLjMzOVxcblxcdCNkZWZpbmUgY3ViZVVWX20wIC0gMi4wXFxuXFx0I2RlZmluZSBjdWJlVVZfcjEgMC44XFxuXFx0I2RlZmluZSBjdWJlVVZfdjEgMC4yNzZcXG5cXHQjZGVmaW5lIGN1YmVVVl9tMSAtIDEuMFxcblxcdCNkZWZpbmUgY3ViZVVWX3I0IDAuNFxcblxcdCNkZWZpbmUgY3ViZVVWX3Y0IDAuMDQ2XFxuXFx0I2RlZmluZSBjdWJlVVZfbTQgMi4wXFxuXFx0I2RlZmluZSBjdWJlVVZfcjUgMC4zMDVcXG5cXHQjZGVmaW5lIGN1YmVVVl92NSAwLjAxNlxcblxcdCNkZWZpbmUgY3ViZVVWX201IDMuMFxcblxcdCNkZWZpbmUgY3ViZVVWX3I2IDAuMjFcXG5cXHQjZGVmaW5lIGN1YmVVVl92NiAwLjAwMzhcXG5cXHQjZGVmaW5lIGN1YmVVVl9tNiA0LjBcXG5cXHRmbG9hdCByb3VnaG5lc3NUb01pcCggZmxvYXQgcm91Z2huZXNzICkge1xcblxcdFxcdGZsb2F0IG1pcCA9IDAuMDtcXG5cXHRcXHRpZiAoIHJvdWdobmVzcyA+PSBjdWJlVVZfcjEgKSB7XFxuXFx0XFx0XFx0bWlwID0gKCBjdWJlVVZfcjAgLSByb3VnaG5lc3MgKSAqICggY3ViZVVWX20xIC0gY3ViZVVWX20wICkgLyAoIGN1YmVVVl9yMCAtIGN1YmVVVl9yMSApICsgY3ViZVVWX20wO1xcblxcdFxcdH0gZWxzZSBpZiAoIHJvdWdobmVzcyA+PSBjdWJlVVZfcjQgKSB7XFxuXFx0XFx0XFx0bWlwID0gKCBjdWJlVVZfcjEgLSByb3VnaG5lc3MgKSAqICggY3ViZVVWX200IC0gY3ViZVVWX20xICkgLyAoIGN1YmVVVl9yMSAtIGN1YmVVVl9yNCApICsgY3ViZVVWX20xO1xcblxcdFxcdH0gZWxzZSBpZiAoIHJvdWdobmVzcyA+PSBjdWJlVVZfcjUgKSB7XFxuXFx0XFx0XFx0bWlwID0gKCBjdWJlVVZfcjQgLSByb3VnaG5lc3MgKSAqICggY3ViZVVWX201IC0gY3ViZVVWX200ICkgLyAoIGN1YmVVVl9yNCAtIGN1YmVVVl9yNSApICsgY3ViZVVWX200O1xcblxcdFxcdH0gZWxzZSBpZiAoIHJvdWdobmVzcyA+PSBjdWJlVVZfcjYgKSB7XFxuXFx0XFx0XFx0bWlwID0gKCBjdWJlVVZfcjUgLSByb3VnaG5lc3MgKSAqICggY3ViZVVWX202IC0gY3ViZVVWX201ICkgLyAoIGN1YmVVVl9yNSAtIGN1YmVVVl9yNiApICsgY3ViZVVWX201O1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0bWlwID0gLSAyLjAgKiBsb2cyKCAxLjE2ICogcm91Z2huZXNzICk7XFx0XFx0fVxcblxcdFxcdHJldHVybiBtaXA7XFxuXFx0fVxcblxcdHZlYzQgdGV4dHVyZUN1YmVVViggc2FtcGxlcjJEIGVudk1hcCwgdmVjMyBzYW1wbGVEaXIsIGZsb2F0IHJvdWdobmVzcyApIHtcXG5cXHRcXHRmbG9hdCBtaXAgPSBjbGFtcCggcm91Z2huZXNzVG9NaXAoIHJvdWdobmVzcyApLCBjdWJlVVZfbTAsIENVQkVVVl9NQVhfTUlQICk7XFxuXFx0XFx0ZmxvYXQgbWlwRiA9IGZyYWN0KCBtaXAgKTtcXG5cXHRcXHRmbG9hdCBtaXBJbnQgPSBmbG9vciggbWlwICk7XFxuXFx0XFx0dmVjMyBjb2xvcjAgPSBiaWxpbmVhckN1YmVVViggZW52TWFwLCBzYW1wbGVEaXIsIG1pcEludCApO1xcblxcdFxcdGlmICggbWlwRiA9PSAwLjAgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHZlYzQoIGNvbG9yMCwgMS4wICk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHR2ZWMzIGNvbG9yMSA9IGJpbGluZWFyQ3ViZVVWKCBlbnZNYXAsIHNhbXBsZURpciwgbWlwSW50ICsgMS4wICk7XFxuXFx0XFx0XFx0cmV0dXJuIHZlYzQoIG1peCggY29sb3IwLCBjb2xvcjEsIG1pcEYgKSwgMS4wICk7XFxuXFx0XFx0fVxcblxcdH1cXG4jZW5kaWZcIjtcblxudmFyIGRlZmF1bHRub3JtYWxfdmVydGV4ID0gXCJ2ZWMzIHRyYW5zZm9ybWVkTm9ybWFsID0gb2JqZWN0Tm9ybWFsO1xcbiNpZmRlZiBVU0VfSU5TVEFOQ0lOR1xcblxcdG1hdDMgbSA9IG1hdDMoIGluc3RhbmNlTWF0cml4ICk7XFxuXFx0dHJhbnNmb3JtZWROb3JtYWwgLz0gdmVjMyggZG90KCBtWyAwIF0sIG1bIDAgXSApLCBkb3QoIG1bIDEgXSwgbVsgMSBdICksIGRvdCggbVsgMiBdLCBtWyAyIF0gKSApO1xcblxcdHRyYW5zZm9ybWVkTm9ybWFsID0gbSAqIHRyYW5zZm9ybWVkTm9ybWFsO1xcbiNlbmRpZlxcbnRyYW5zZm9ybWVkTm9ybWFsID0gbm9ybWFsTWF0cml4ICogdHJhbnNmb3JtZWROb3JtYWw7XFxuI2lmZGVmIEZMSVBfU0lERURcXG5cXHR0cmFuc2Zvcm1lZE5vcm1hbCA9IC0gdHJhbnNmb3JtZWROb3JtYWw7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9UQU5HRU5UXFxuXFx0dmVjMyB0cmFuc2Zvcm1lZFRhbmdlbnQgPSAoIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIG9iamVjdFRhbmdlbnQsIDAuMCApICkueHl6O1xcblxcdCNpZmRlZiBGTElQX1NJREVEXFxuXFx0XFx0dHJhbnNmb3JtZWRUYW5nZW50ID0gLSB0cmFuc2Zvcm1lZFRhbmdlbnQ7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG5cbnZhciBkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfRElTUExBQ0VNRU5UTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgZGlzcGxhY2VtZW50TWFwO1xcblxcdHVuaWZvcm0gZmxvYXQgZGlzcGxhY2VtZW50U2NhbGU7XFxuXFx0dW5pZm9ybSBmbG9hdCBkaXNwbGFjZW1lbnRCaWFzO1xcbiNlbmRpZlwiO1xuXG52YXIgZGlzcGxhY2VtZW50bWFwX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9ESVNQTEFDRU1FTlRNQVBcXG5cXHR0cmFuc2Zvcm1lZCArPSBub3JtYWxpemUoIG9iamVjdE5vcm1hbCApICogKCB0ZXh0dXJlMkQoIGRpc3BsYWNlbWVudE1hcCwgdlV2ICkueCAqIGRpc3BsYWNlbWVudFNjYWxlICsgZGlzcGxhY2VtZW50QmlhcyApO1xcbiNlbmRpZlwiO1xuXG52YXIgZW1pc3NpdmVtYXBfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfRU1JU1NJVkVNQVBcXG5cXHR2ZWM0IGVtaXNzaXZlQ29sb3IgPSB0ZXh0dXJlMkQoIGVtaXNzaXZlTWFwLCB2VXYgKTtcXG5cXHR0b3RhbEVtaXNzaXZlUmFkaWFuY2UgKj0gZW1pc3NpdmVDb2xvci5yZ2I7XFxuI2VuZGlmXCI7XG5cbnZhciBlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0VNSVNTSVZFTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgZW1pc3NpdmVNYXA7XFxuI2VuZGlmXCI7XG5cbnZhciBlbmNvZGluZ3NfZnJhZ21lbnQgPSBcImdsX0ZyYWdDb2xvciA9IGxpbmVhclRvT3V0cHV0VGV4ZWwoIGdsX0ZyYWdDb2xvciApO1wiO1xuXG52YXIgZW5jb2RpbmdzX3BhcnNfZnJhZ21lbnQgPSBcInZlYzQgTGluZWFyVG9MaW5lYXIoIGluIHZlYzQgdmFsdWUgKSB7XFxuXFx0cmV0dXJuIHZhbHVlO1xcbn1cXG52ZWM0IExpbmVhclRvc1JHQiggaW4gdmVjNCB2YWx1ZSApIHtcXG5cXHRyZXR1cm4gdmVjNCggbWl4KCBwb3coIHZhbHVlLnJnYiwgdmVjMyggMC40MTY2NiApICkgKiAxLjA1NSAtIHZlYzMoIDAuMDU1ICksIHZhbHVlLnJnYiAqIDEyLjkyLCB2ZWMzKCBsZXNzVGhhbkVxdWFsKCB2YWx1ZS5yZ2IsIHZlYzMoIDAuMDAzMTMwOCApICkgKSApLCB2YWx1ZS5hICk7XFxufVwiO1xuXG52YXIgZW52bWFwX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0VOVk1BUFxcblxcdCNpZmRlZiBFTlZfV09STERQT1NcXG5cXHRcXHR2ZWMzIGNhbWVyYVRvRnJhZztcXG5cXHRcXHRpZiAoIGlzT3J0aG9ncmFwaGljICkge1xcblxcdFxcdFxcdGNhbWVyYVRvRnJhZyA9IG5vcm1hbGl6ZSggdmVjMyggLSB2aWV3TWF0cml4WyAwIF1bIDIgXSwgLSB2aWV3TWF0cml4WyAxIF1bIDIgXSwgLSB2aWV3TWF0cml4WyAyIF1bIDIgXSApICk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRjYW1lcmFUb0ZyYWcgPSBub3JtYWxpemUoIHZXb3JsZFBvc2l0aW9uIC0gY2FtZXJhUG9zaXRpb24gKTtcXG5cXHRcXHR9XFxuXFx0XFx0dmVjMyB3b3JsZE5vcm1hbCA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIG5vcm1hbCwgdmlld01hdHJpeCApO1xcblxcdFxcdCNpZmRlZiBFTlZNQVBfTU9ERV9SRUZMRUNUSU9OXFxuXFx0XFx0XFx0dmVjMyByZWZsZWN0VmVjID0gcmVmbGVjdCggY2FtZXJhVG9GcmFnLCB3b3JsZE5vcm1hbCApO1xcblxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0dmVjMyByZWZsZWN0VmVjID0gcmVmcmFjdCggY2FtZXJhVG9GcmFnLCB3b3JsZE5vcm1hbCwgcmVmcmFjdGlvblJhdGlvICk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0I2Vsc2VcXG5cXHRcXHR2ZWMzIHJlZmxlY3RWZWMgPSB2UmVmbGVjdDtcXG5cXHQjZW5kaWZcXG5cXHQjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRVxcblxcdFxcdHZlYzQgZW52Q29sb3IgPSB0ZXh0dXJlQ3ViZSggZW52TWFwLCB2ZWMzKCBmbGlwRW52TWFwICogcmVmbGVjdFZlYy54LCByZWZsZWN0VmVjLnl6ICkgKTtcXG5cXHQjZWxzZVxcblxcdFxcdHZlYzQgZW52Q29sb3IgPSB2ZWM0KCAwLjAgKTtcXG5cXHQjZW5kaWZcXG5cXHQjaWZkZWYgRU5WTUFQX0JMRU5ESU5HX01VTFRJUExZXFxuXFx0XFx0b3V0Z29pbmdMaWdodCA9IG1peCggb3V0Z29pbmdMaWdodCwgb3V0Z29pbmdMaWdodCAqIGVudkNvbG9yLnh5eiwgc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eSApO1xcblxcdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9CTEVORElOR19NSVggKVxcblxcdFxcdG91dGdvaW5nTGlnaHQgPSBtaXgoIG91dGdvaW5nTGlnaHQsIGVudkNvbG9yLnh5eiwgc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eSApO1xcblxcdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9CTEVORElOR19BREQgKVxcblxcdFxcdG91dGdvaW5nTGlnaHQgKz0gZW52Q29sb3IueHl6ICogc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eTtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIjtcblxudmFyIGVudm1hcF9jb21tb25fcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9FTlZNQVBcXG5cXHR1bmlmb3JtIGZsb2F0IGVudk1hcEludGVuc2l0eTtcXG5cXHR1bmlmb3JtIGZsb2F0IGZsaXBFbnZNYXA7XFxuXFx0I2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVcXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXJDdWJlIGVudk1hcDtcXG5cXHQjZWxzZVxcblxcdFxcdHVuaWZvcm0gc2FtcGxlcjJEIGVudk1hcDtcXG5cXHQjZW5kaWZcXG5cXHRcXG4jZW5kaWZcIjtcblxudmFyIGVudm1hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0VOVk1BUFxcblxcdHVuaWZvcm0gZmxvYXQgcmVmbGVjdGl2aXR5O1xcblxcdCNpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApIHx8IGRlZmluZWQoIExBTUJFUlQgKVxcblxcdFxcdCNkZWZpbmUgRU5WX1dPUkxEUE9TXFxuXFx0I2VuZGlmXFxuXFx0I2lmZGVmIEVOVl9XT1JMRFBPU1xcblxcdFxcdHZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXG5cXHRcXHR1bmlmb3JtIGZsb2F0IHJlZnJhY3Rpb25SYXRpbztcXG5cXHQjZWxzZVxcblxcdFxcdHZhcnlpbmcgdmVjMyB2UmVmbGVjdDtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIjtcblxudmFyIGVudm1hcF9wYXJzX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9FTlZNQVBcXG5cXHQjaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggUEhPTkcgKSB8fCBkZWZpbmVkKCBMQU1CRVJUIClcXG5cXHRcXHQjZGVmaW5lIEVOVl9XT1JMRFBPU1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBFTlZfV09STERQT1NcXG5cXHRcXHRcXG5cXHRcXHR2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuXFx0I2Vsc2VcXG5cXHRcXHR2YXJ5aW5nIHZlYzMgdlJlZmxlY3Q7XFxuXFx0XFx0dW5pZm9ybSBmbG9hdCByZWZyYWN0aW9uUmF0aW87XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG5cbnZhciBlbnZtYXBfdmVydGV4ID0gXCIjaWZkZWYgVVNFX0VOVk1BUFxcblxcdCNpZmRlZiBFTlZfV09STERQT1NcXG5cXHRcXHR2V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24ueHl6O1xcblxcdCNlbHNlXFxuXFx0XFx0dmVjMyBjYW1lcmFUb1ZlcnRleDtcXG5cXHRcXHRpZiAoIGlzT3J0aG9ncmFwaGljICkge1xcblxcdFxcdFxcdGNhbWVyYVRvVmVydGV4ID0gbm9ybWFsaXplKCB2ZWMzKCAtIHZpZXdNYXRyaXhbIDAgXVsgMiBdLCAtIHZpZXdNYXRyaXhbIDEgXVsgMiBdLCAtIHZpZXdNYXRyaXhbIDIgXVsgMiBdICkgKTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdGNhbWVyYVRvVmVydGV4ID0gbm9ybWFsaXplKCB3b3JsZFBvc2l0aW9uLnh5eiAtIGNhbWVyYVBvc2l0aW9uICk7XFxuXFx0XFx0fVxcblxcdFxcdHZlYzMgd29ybGROb3JtYWwgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCB0cmFuc2Zvcm1lZE5vcm1hbCwgdmlld01hdHJpeCApO1xcblxcdFxcdCNpZmRlZiBFTlZNQVBfTU9ERV9SRUZMRUNUSU9OXFxuXFx0XFx0XFx0dlJlZmxlY3QgPSByZWZsZWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwgKTtcXG5cXHRcXHQjZWxzZVxcblxcdFxcdFxcdHZSZWZsZWN0ID0gcmVmcmFjdCggY2FtZXJhVG9WZXJ0ZXgsIHdvcmxkTm9ybWFsLCByZWZyYWN0aW9uUmF0aW8gKTtcXG5cXHRcXHQjZW5kaWZcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIjtcblxudmFyIGZvZ192ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfRk9HXFxuXFx0dkZvZ0RlcHRoID0gLSBtdlBvc2l0aW9uLno7XFxuI2VuZGlmXCI7XG5cbnZhciBmb2dfcGFyc192ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfRk9HXFxuXFx0dmFyeWluZyBmbG9hdCB2Rm9nRGVwdGg7XFxuI2VuZGlmXCI7XG5cbnZhciBmb2dfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfRk9HXFxuXFx0I2lmZGVmIEZPR19FWFAyXFxuXFx0XFx0ZmxvYXQgZm9nRmFjdG9yID0gMS4wIC0gZXhwKCAtIGZvZ0RlbnNpdHkgKiBmb2dEZW5zaXR5ICogdkZvZ0RlcHRoICogdkZvZ0RlcHRoICk7XFxuXFx0I2Vsc2VcXG5cXHRcXHRmbG9hdCBmb2dGYWN0b3IgPSBzbW9vdGhzdGVwKCBmb2dOZWFyLCBmb2dGYXIsIHZGb2dEZXB0aCApO1xcblxcdCNlbmRpZlxcblxcdGdsX0ZyYWdDb2xvci5yZ2IgPSBtaXgoIGdsX0ZyYWdDb2xvci5yZ2IsIGZvZ0NvbG9yLCBmb2dGYWN0b3IgKTtcXG4jZW5kaWZcIjtcblxudmFyIGZvZ19wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0ZPR1xcblxcdHVuaWZvcm0gdmVjMyBmb2dDb2xvcjtcXG5cXHR2YXJ5aW5nIGZsb2F0IHZGb2dEZXB0aDtcXG5cXHQjaWZkZWYgRk9HX0VYUDJcXG5cXHRcXHR1bmlmb3JtIGZsb2F0IGZvZ0RlbnNpdHk7XFxuXFx0I2Vsc2VcXG5cXHRcXHR1bmlmb3JtIGZsb2F0IGZvZ05lYXI7XFxuXFx0XFx0dW5pZm9ybSBmbG9hdCBmb2dGYXI7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG5cbnZhciBncmFkaWVudG1hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0dSQURJRU5UTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgZ3JhZGllbnRNYXA7XFxuI2VuZGlmXFxudmVjMyBnZXRHcmFkaWVudElycmFkaWFuY2UoIHZlYzMgbm9ybWFsLCB2ZWMzIGxpZ2h0RGlyZWN0aW9uICkge1xcblxcdGZsb2F0IGRvdE5MID0gZG90KCBub3JtYWwsIGxpZ2h0RGlyZWN0aW9uICk7XFxuXFx0dmVjMiBjb29yZCA9IHZlYzIoIGRvdE5MICogMC41ICsgMC41LCAwLjAgKTtcXG5cXHQjaWZkZWYgVVNFX0dSQURJRU5UTUFQXFxuXFx0XFx0cmV0dXJuIHZlYzMoIHRleHR1cmUyRCggZ3JhZGllbnRNYXAsIGNvb3JkICkuciApO1xcblxcdCNlbHNlXFxuXFx0XFx0dmVjMiBmdyA9IGZ3aWR0aCggY29vcmQgKSAqIDAuNTtcXG5cXHRcXHRyZXR1cm4gbWl4KCB2ZWMzKCAwLjcgKSwgdmVjMyggMS4wICksIHNtb290aHN0ZXAoIDAuNyAtIGZ3LngsIDAuNyArIGZ3LngsIGNvb3JkLnggKSApO1xcblxcdCNlbmRpZlxcbn1cIjtcblxudmFyIGxpZ2h0bWFwX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0xJR0hUTUFQXFxuXFx0dmVjNCBsaWdodE1hcFRleGVsID0gdGV4dHVyZTJEKCBsaWdodE1hcCwgdlV2MiApO1xcblxcdHZlYzMgbGlnaHRNYXBJcnJhZGlhbmNlID0gbGlnaHRNYXBUZXhlbC5yZ2IgKiBsaWdodE1hcEludGVuc2l0eTtcXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gbGlnaHRNYXBJcnJhZGlhbmNlO1xcbiNlbmRpZlwiO1xuXG52YXIgbGlnaHRtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9MSUdIVE1BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGxpZ2h0TWFwO1xcblxcdHVuaWZvcm0gZmxvYXQgbGlnaHRNYXBJbnRlbnNpdHk7XFxuI2VuZGlmXCI7XG5cbnZhciBsaWdodHNfbGFtYmVydF9mcmFnbWVudCA9IFwiTGFtYmVydE1hdGVyaWFsIG1hdGVyaWFsO1xcbm1hdGVyaWFsLmRpZmZ1c2VDb2xvciA9IGRpZmZ1c2VDb2xvci5yZ2I7XFxubWF0ZXJpYWwuc3BlY3VsYXJTdHJlbmd0aCA9IHNwZWN1bGFyU3RyZW5ndGg7XCI7XG5cbnZhciBsaWdodHNfbGFtYmVydF9wYXJzX2ZyYWdtZW50ID0gXCJ2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG5zdHJ1Y3QgTGFtYmVydE1hdGVyaWFsIHtcXG5cXHR2ZWMzIGRpZmZ1c2VDb2xvcjtcXG5cXHRmbG9hdCBzcGVjdWxhclN0cmVuZ3RoO1xcbn07XFxudm9pZCBSRV9EaXJlY3RfTGFtYmVydCggY29uc3QgaW4gSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodCwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gTGFtYmVydE1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXG5cXHRmbG9hdCBkb3ROTCA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICkgKTtcXG5cXHR2ZWMzIGlycmFkaWFuY2UgPSBkb3ROTCAqIGRpcmVjdExpZ2h0LmNvbG9yO1xcblxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKz0gaXJyYWRpYW5jZSAqIEJSREZfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7XFxufVxcbnZvaWQgUkVfSW5kaXJlY3REaWZmdXNlX0xhbWJlcnQoIGNvbnN0IGluIHZlYzMgaXJyYWRpYW5jZSwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gTGFtYmVydE1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gaXJyYWRpYW5jZSAqIEJSREZfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7XFxufVxcbiNkZWZpbmUgUkVfRGlyZWN0XFx0XFx0XFx0XFx0UkVfRGlyZWN0X0xhbWJlcnRcXG4jZGVmaW5lIFJFX0luZGlyZWN0RGlmZnVzZVxcdFxcdFJFX0luZGlyZWN0RGlmZnVzZV9MYW1iZXJ0XFxuI2RlZmluZSBNYXRlcmlhbF9MaWdodFByb2JlTE9EKCBtYXRlcmlhbCApXFx0KDApXCI7XG5cbnZhciBsaWdodHNfcGFyc19iZWdpbiA9IFwidW5pZm9ybSBib29sIHJlY2VpdmVTaGFkb3c7XFxudW5pZm9ybSB2ZWMzIGFtYmllbnRMaWdodENvbG9yO1xcbnVuaWZvcm0gdmVjMyBsaWdodFByb2JlWyA5IF07XFxudmVjMyBzaEdldElycmFkaWFuY2VBdCggaW4gdmVjMyBub3JtYWwsIGluIHZlYzMgc2hDb2VmZmljaWVudHNbIDkgXSApIHtcXG5cXHRmbG9hdCB4ID0gbm9ybWFsLngsIHkgPSBub3JtYWwueSwgeiA9IG5vcm1hbC56O1xcblxcdHZlYzMgcmVzdWx0ID0gc2hDb2VmZmljaWVudHNbIDAgXSAqIDAuODg2MjI3O1xcblxcdHJlc3VsdCArPSBzaENvZWZmaWNpZW50c1sgMSBdICogMi4wICogMC41MTE2NjQgKiB5O1xcblxcdHJlc3VsdCArPSBzaENvZWZmaWNpZW50c1sgMiBdICogMi4wICogMC41MTE2NjQgKiB6O1xcblxcdHJlc3VsdCArPSBzaENvZWZmaWNpZW50c1sgMyBdICogMi4wICogMC41MTE2NjQgKiB4O1xcblxcdHJlc3VsdCArPSBzaENvZWZmaWNpZW50c1sgNCBdICogMi4wICogMC40MjkwNDMgKiB4ICogeTtcXG5cXHRyZXN1bHQgKz0gc2hDb2VmZmljaWVudHNbIDUgXSAqIDIuMCAqIDAuNDI5MDQzICogeSAqIHo7XFxuXFx0cmVzdWx0ICs9IHNoQ29lZmZpY2llbnRzWyA2IF0gKiAoIDAuNzQzMTI1ICogeiAqIHogLSAwLjI0NzcwOCApO1xcblxcdHJlc3VsdCArPSBzaENvZWZmaWNpZW50c1sgNyBdICogMi4wICogMC40MjkwNDMgKiB4ICogejtcXG5cXHRyZXN1bHQgKz0gc2hDb2VmZmljaWVudHNbIDggXSAqIDAuNDI5MDQzICogKCB4ICogeCAtIHkgKiB5ICk7XFxuXFx0cmV0dXJuIHJlc3VsdDtcXG59XFxudmVjMyBnZXRMaWdodFByb2JlSXJyYWRpYW5jZSggY29uc3QgaW4gdmVjMyBsaWdodFByb2JlWyA5IF0sIGNvbnN0IGluIHZlYzMgbm9ybWFsICkge1xcblxcdHZlYzMgd29ybGROb3JtYWwgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBub3JtYWwsIHZpZXdNYXRyaXggKTtcXG5cXHR2ZWMzIGlycmFkaWFuY2UgPSBzaEdldElycmFkaWFuY2VBdCggd29ybGROb3JtYWwsIGxpZ2h0UHJvYmUgKTtcXG5cXHRyZXR1cm4gaXJyYWRpYW5jZTtcXG59XFxudmVjMyBnZXRBbWJpZW50TGlnaHRJcnJhZGlhbmNlKCBjb25zdCBpbiB2ZWMzIGFtYmllbnRMaWdodENvbG9yICkge1xcblxcdHZlYzMgaXJyYWRpYW5jZSA9IGFtYmllbnRMaWdodENvbG9yO1xcblxcdHJldHVybiBpcnJhZGlhbmNlO1xcbn1cXG5mbG9hdCBnZXREaXN0YW5jZUF0dGVudWF0aW9uKCBjb25zdCBpbiBmbG9hdCBsaWdodERpc3RhbmNlLCBjb25zdCBpbiBmbG9hdCBjdXRvZmZEaXN0YW5jZSwgY29uc3QgaW4gZmxvYXQgZGVjYXlFeHBvbmVudCApIHtcXG5cXHQjaWYgZGVmaW5lZCAoIFBIWVNJQ0FMTFlfQ09SUkVDVF9MSUdIVFMgKVxcblxcdFxcdGZsb2F0IGRpc3RhbmNlRmFsbG9mZiA9IDEuMCAvIG1heCggcG93KCBsaWdodERpc3RhbmNlLCBkZWNheUV4cG9uZW50ICksIDAuMDEgKTtcXG5cXHRcXHRpZiAoIGN1dG9mZkRpc3RhbmNlID4gMC4wICkge1xcblxcdFxcdFxcdGRpc3RhbmNlRmFsbG9mZiAqPSBwb3cyKCBzYXR1cmF0ZSggMS4wIC0gcG93NCggbGlnaHREaXN0YW5jZSAvIGN1dG9mZkRpc3RhbmNlICkgKSApO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gZGlzdGFuY2VGYWxsb2ZmO1xcblxcdCNlbHNlXFxuXFx0XFx0aWYgKCBjdXRvZmZEaXN0YW5jZSA+IDAuMCAmJiBkZWNheUV4cG9uZW50ID4gMC4wICkge1xcblxcdFxcdFxcdHJldHVybiBwb3coIHNhdHVyYXRlKCAtIGxpZ2h0RGlzdGFuY2UgLyBjdXRvZmZEaXN0YW5jZSArIDEuMCApLCBkZWNheUV4cG9uZW50ICk7XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiAxLjA7XFxuXFx0I2VuZGlmXFxufVxcbmZsb2F0IGdldFNwb3RBdHRlbnVhdGlvbiggY29uc3QgaW4gZmxvYXQgY29uZUNvc2luZSwgY29uc3QgaW4gZmxvYXQgcGVudW1icmFDb3NpbmUsIGNvbnN0IGluIGZsb2F0IGFuZ2xlQ29zaW5lICkge1xcblxcdHJldHVybiBzbW9vdGhzdGVwKCBjb25lQ29zaW5lLCBwZW51bWJyYUNvc2luZSwgYW5nbGVDb3NpbmUgKTtcXG59XFxuI2lmIE5VTV9ESVJfTElHSFRTID4gMFxcblxcdHN0cnVjdCBEaXJlY3Rpb25hbExpZ2h0IHtcXG5cXHRcXHR2ZWMzIGRpcmVjdGlvbjtcXG5cXHRcXHR2ZWMzIGNvbG9yO1xcblxcdH07XFxuXFx0dW5pZm9ybSBEaXJlY3Rpb25hbExpZ2h0IGRpcmVjdGlvbmFsTGlnaHRzWyBOVU1fRElSX0xJR0hUUyBdO1xcblxcdHZvaWQgZ2V0RGlyZWN0aW9uYWxMaWdodEluZm8oIGNvbnN0IGluIERpcmVjdGlvbmFsTGlnaHQgZGlyZWN0aW9uYWxMaWdodCwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgb3V0IEluY2lkZW50TGlnaHQgbGlnaHQgKSB7XFxuXFx0XFx0bGlnaHQuY29sb3IgPSBkaXJlY3Rpb25hbExpZ2h0LmNvbG9yO1xcblxcdFxcdGxpZ2h0LmRpcmVjdGlvbiA9IGRpcmVjdGlvbmFsTGlnaHQuZGlyZWN0aW9uO1xcblxcdFxcdGxpZ2h0LnZpc2libGUgPSB0cnVlO1xcblxcdH1cXG4jZW5kaWZcXG4jaWYgTlVNX1BPSU5UX0xJR0hUUyA+IDBcXG5cXHRzdHJ1Y3QgUG9pbnRMaWdodCB7XFxuXFx0XFx0dmVjMyBwb3NpdGlvbjtcXG5cXHRcXHR2ZWMzIGNvbG9yO1xcblxcdFxcdGZsb2F0IGRpc3RhbmNlO1xcblxcdFxcdGZsb2F0IGRlY2F5O1xcblxcdH07XFxuXFx0dW5pZm9ybSBQb2ludExpZ2h0IHBvaW50TGlnaHRzWyBOVU1fUE9JTlRfTElHSFRTIF07XFxuXFx0dm9pZCBnZXRQb2ludExpZ2h0SW5mbyggY29uc3QgaW4gUG9pbnRMaWdodCBwb2ludExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBvdXQgSW5jaWRlbnRMaWdodCBsaWdodCApIHtcXG5cXHRcXHR2ZWMzIGxWZWN0b3IgPSBwb2ludExpZ2h0LnBvc2l0aW9uIC0gZ2VvbWV0cnkucG9zaXRpb247XFxuXFx0XFx0bGlnaHQuZGlyZWN0aW9uID0gbm9ybWFsaXplKCBsVmVjdG9yICk7XFxuXFx0XFx0ZmxvYXQgbGlnaHREaXN0YW5jZSA9IGxlbmd0aCggbFZlY3RvciApO1xcblxcdFxcdGxpZ2h0LmNvbG9yID0gcG9pbnRMaWdodC5jb2xvcjtcXG5cXHRcXHRsaWdodC5jb2xvciAqPSBnZXREaXN0YW5jZUF0dGVudWF0aW9uKCBsaWdodERpc3RhbmNlLCBwb2ludExpZ2h0LmRpc3RhbmNlLCBwb2ludExpZ2h0LmRlY2F5ICk7XFxuXFx0XFx0bGlnaHQudmlzaWJsZSA9ICggbGlnaHQuY29sb3IgIT0gdmVjMyggMC4wICkgKTtcXG5cXHR9XFxuI2VuZGlmXFxuI2lmIE5VTV9TUE9UX0xJR0hUUyA+IDBcXG5cXHRzdHJ1Y3QgU3BvdExpZ2h0IHtcXG5cXHRcXHR2ZWMzIHBvc2l0aW9uO1xcblxcdFxcdHZlYzMgZGlyZWN0aW9uO1xcblxcdFxcdHZlYzMgY29sb3I7XFxuXFx0XFx0ZmxvYXQgZGlzdGFuY2U7XFxuXFx0XFx0ZmxvYXQgZGVjYXk7XFxuXFx0XFx0ZmxvYXQgY29uZUNvcztcXG5cXHRcXHRmbG9hdCBwZW51bWJyYUNvcztcXG5cXHR9O1xcblxcdHVuaWZvcm0gU3BvdExpZ2h0IHNwb3RMaWdodHNbIE5VTV9TUE9UX0xJR0hUUyBdO1xcblxcdHZvaWQgZ2V0U3BvdExpZ2h0SW5mbyggY29uc3QgaW4gU3BvdExpZ2h0IHNwb3RMaWdodCwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgb3V0IEluY2lkZW50TGlnaHQgbGlnaHQgKSB7XFxuXFx0XFx0dmVjMyBsVmVjdG9yID0gc3BvdExpZ2h0LnBvc2l0aW9uIC0gZ2VvbWV0cnkucG9zaXRpb247XFxuXFx0XFx0bGlnaHQuZGlyZWN0aW9uID0gbm9ybWFsaXplKCBsVmVjdG9yICk7XFxuXFx0XFx0ZmxvYXQgYW5nbGVDb3MgPSBkb3QoIGxpZ2h0LmRpcmVjdGlvbiwgc3BvdExpZ2h0LmRpcmVjdGlvbiApO1xcblxcdFxcdGZsb2F0IHNwb3RBdHRlbnVhdGlvbiA9IGdldFNwb3RBdHRlbnVhdGlvbiggc3BvdExpZ2h0LmNvbmVDb3MsIHNwb3RMaWdodC5wZW51bWJyYUNvcywgYW5nbGVDb3MgKTtcXG5cXHRcXHRpZiAoIHNwb3RBdHRlbnVhdGlvbiA+IDAuMCApIHtcXG5cXHRcXHRcXHRmbG9hdCBsaWdodERpc3RhbmNlID0gbGVuZ3RoKCBsVmVjdG9yICk7XFxuXFx0XFx0XFx0bGlnaHQuY29sb3IgPSBzcG90TGlnaHQuY29sb3IgKiBzcG90QXR0ZW51YXRpb247XFxuXFx0XFx0XFx0bGlnaHQuY29sb3IgKj0gZ2V0RGlzdGFuY2VBdHRlbnVhdGlvbiggbGlnaHREaXN0YW5jZSwgc3BvdExpZ2h0LmRpc3RhbmNlLCBzcG90TGlnaHQuZGVjYXkgKTtcXG5cXHRcXHRcXHRsaWdodC52aXNpYmxlID0gKCBsaWdodC5jb2xvciAhPSB2ZWMzKCAwLjAgKSApO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0bGlnaHQuY29sb3IgPSB2ZWMzKCAwLjAgKTtcXG5cXHRcXHRcXHRsaWdodC52aXNpYmxlID0gZmFsc2U7XFxuXFx0XFx0fVxcblxcdH1cXG4jZW5kaWZcXG4jaWYgTlVNX1JFQ1RfQVJFQV9MSUdIVFMgPiAwXFxuXFx0c3RydWN0IFJlY3RBcmVhTGlnaHQge1xcblxcdFxcdHZlYzMgY29sb3I7XFxuXFx0XFx0dmVjMyBwb3NpdGlvbjtcXG5cXHRcXHR2ZWMzIGhhbGZXaWR0aDtcXG5cXHRcXHR2ZWMzIGhhbGZIZWlnaHQ7XFxuXFx0fTtcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBsdGNfMTtcXHR1bmlmb3JtIHNhbXBsZXIyRCBsdGNfMjtcXG5cXHR1bmlmb3JtIFJlY3RBcmVhTGlnaHQgcmVjdEFyZWFMaWdodHNbIE5VTV9SRUNUX0FSRUFfTElHSFRTIF07XFxuI2VuZGlmXFxuI2lmIE5VTV9IRU1JX0xJR0hUUyA+IDBcXG5cXHRzdHJ1Y3QgSGVtaXNwaGVyZUxpZ2h0IHtcXG5cXHRcXHR2ZWMzIGRpcmVjdGlvbjtcXG5cXHRcXHR2ZWMzIHNreUNvbG9yO1xcblxcdFxcdHZlYzMgZ3JvdW5kQ29sb3I7XFxuXFx0fTtcXG5cXHR1bmlmb3JtIEhlbWlzcGhlcmVMaWdodCBoZW1pc3BoZXJlTGlnaHRzWyBOVU1fSEVNSV9MSUdIVFMgXTtcXG5cXHR2ZWMzIGdldEhlbWlzcGhlcmVMaWdodElycmFkaWFuY2UoIGNvbnN0IGluIEhlbWlzcGhlcmVMaWdodCBoZW1pTGlnaHQsIGNvbnN0IGluIHZlYzMgbm9ybWFsICkge1xcblxcdFxcdGZsb2F0IGRvdE5MID0gZG90KCBub3JtYWwsIGhlbWlMaWdodC5kaXJlY3Rpb24gKTtcXG5cXHRcXHRmbG9hdCBoZW1pRGlmZnVzZVdlaWdodCA9IDAuNSAqIGRvdE5MICsgMC41O1xcblxcdFxcdHZlYzMgaXJyYWRpYW5jZSA9IG1peCggaGVtaUxpZ2h0Lmdyb3VuZENvbG9yLCBoZW1pTGlnaHQuc2t5Q29sb3IsIGhlbWlEaWZmdXNlV2VpZ2h0ICk7XFxuXFx0XFx0cmV0dXJuIGlycmFkaWFuY2U7XFxuXFx0fVxcbiNlbmRpZlwiO1xuXG52YXIgZW52bWFwX3BoeXNpY2FsX3BhcnNfZnJhZ21lbnQgPSBcIiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQIClcXG5cXHR2ZWMzIGdldElCTElycmFkaWFuY2UoIGNvbnN0IGluIHZlYzMgbm9ybWFsICkge1xcblxcdFxcdCNpZiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9DVUJFX1VWIClcXG5cXHRcXHRcXHR2ZWMzIHdvcmxkTm9ybWFsID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggbm9ybWFsLCB2aWV3TWF0cml4ICk7XFxuXFx0XFx0XFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmVDdWJlVVYoIGVudk1hcCwgd29ybGROb3JtYWwsIDEuMCApO1xcblxcdFxcdFxcdHJldHVybiBQSSAqIGVudk1hcENvbG9yLnJnYiAqIGVudk1hcEludGVuc2l0eTtcXG5cXHRcXHQjZWxzZVxcblxcdFxcdFxcdHJldHVybiB2ZWMzKCAwLjAgKTtcXG5cXHRcXHQjZW5kaWZcXG5cXHR9XFxuXFx0dmVjMyBnZXRJQkxSYWRpYW5jZSggY29uc3QgaW4gdmVjMyB2aWV3RGlyLCBjb25zdCBpbiB2ZWMzIG5vcm1hbCwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzICkge1xcblxcdFxcdCNpZiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9DVUJFX1VWIClcXG5cXHRcXHRcXHR2ZWMzIHJlZmxlY3RWZWMgPSByZWZsZWN0KCAtIHZpZXdEaXIsIG5vcm1hbCApO1xcblxcdFxcdFxcdHJlZmxlY3RWZWMgPSBub3JtYWxpemUoIG1peCggcmVmbGVjdFZlYywgbm9ybWFsLCByb3VnaG5lc3MgKiByb3VnaG5lc3MpICk7XFxuXFx0XFx0XFx0cmVmbGVjdFZlYyA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIHJlZmxlY3RWZWMsIHZpZXdNYXRyaXggKTtcXG5cXHRcXHRcXHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZUN1YmVVViggZW52TWFwLCByZWZsZWN0VmVjLCByb3VnaG5lc3MgKTtcXG5cXHRcXHRcXHRyZXR1cm4gZW52TWFwQ29sb3IucmdiICogZW52TWFwSW50ZW5zaXR5O1xcblxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0cmV0dXJuIHZlYzMoIDAuMCApO1xcblxcdFxcdCNlbmRpZlxcblxcdH1cXG4jZW5kaWZcIjtcblxudmFyIGxpZ2h0c190b29uX2ZyYWdtZW50ID0gXCJUb29uTWF0ZXJpYWwgbWF0ZXJpYWw7XFxubWF0ZXJpYWwuZGlmZnVzZUNvbG9yID0gZGlmZnVzZUNvbG9yLnJnYjtcIjtcblxudmFyIGxpZ2h0c190b29uX3BhcnNfZnJhZ21lbnQgPSBcInZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcbnN0cnVjdCBUb29uTWF0ZXJpYWwge1xcblxcdHZlYzMgZGlmZnVzZUNvbG9yO1xcbn07XFxudm9pZCBSRV9EaXJlY3RfVG9vbiggY29uc3QgaW4gSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodCwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gVG9vbk1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXG5cXHR2ZWMzIGlycmFkaWFuY2UgPSBnZXRHcmFkaWVudElycmFkaWFuY2UoIGdlb21ldHJ5Lm5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICkgKiBkaXJlY3RMaWdodC5jb2xvcjtcXG5cXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICs9IGlycmFkaWFuY2UgKiBCUkRGX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApO1xcbn1cXG52b2lkIFJFX0luZGlyZWN0RGlmZnVzZV9Ub29uKCBjb25zdCBpbiB2ZWMzIGlycmFkaWFuY2UsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIFRvb25NYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7XFxuXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IGlycmFkaWFuY2UgKiBCUkRGX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApO1xcbn1cXG4jZGVmaW5lIFJFX0RpcmVjdFxcdFxcdFxcdFxcdFJFX0RpcmVjdF9Ub29uXFxuI2RlZmluZSBSRV9JbmRpcmVjdERpZmZ1c2VcXHRcXHRSRV9JbmRpcmVjdERpZmZ1c2VfVG9vblxcbiNkZWZpbmUgTWF0ZXJpYWxfTGlnaHRQcm9iZUxPRCggbWF0ZXJpYWwgKVxcdCgwKVwiO1xuXG52YXIgbGlnaHRzX3Bob25nX2ZyYWdtZW50ID0gXCJCbGlublBob25nTWF0ZXJpYWwgbWF0ZXJpYWw7XFxubWF0ZXJpYWwuZGlmZnVzZUNvbG9yID0gZGlmZnVzZUNvbG9yLnJnYjtcXG5tYXRlcmlhbC5zcGVjdWxhckNvbG9yID0gc3BlY3VsYXI7XFxubWF0ZXJpYWwuc3BlY3VsYXJTaGluaW5lc3MgPSBzaGluaW5lc3M7XFxubWF0ZXJpYWwuc3BlY3VsYXJTdHJlbmd0aCA9IHNwZWN1bGFyU3RyZW5ndGg7XCI7XG5cbnZhciBsaWdodHNfcGhvbmdfcGFyc19mcmFnbWVudCA9IFwidmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuc3RydWN0IEJsaW5uUGhvbmdNYXRlcmlhbCB7XFxuXFx0dmVjMyBkaWZmdXNlQ29sb3I7XFxuXFx0dmVjMyBzcGVjdWxhckNvbG9yO1xcblxcdGZsb2F0IHNwZWN1bGFyU2hpbmluZXNzO1xcblxcdGZsb2F0IHNwZWN1bGFyU3RyZW5ndGg7XFxufTtcXG52b2lkIFJFX0RpcmVjdF9CbGlublBob25nKCBjb25zdCBpbiBJbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBCbGlublBob25nTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkge1xcblxcdGZsb2F0IGRvdE5MID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKSApO1xcblxcdHZlYzMgaXJyYWRpYW5jZSA9IGRvdE5MICogZGlyZWN0TGlnaHQuY29sb3I7XFxuXFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTtcXG5cXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArPSBpcnJhZGlhbmNlICogQlJERl9CbGlublBob25nKCBkaXJlY3RMaWdodC5kaXJlY3Rpb24sIGdlb21ldHJ5LnZpZXdEaXIsIGdlb21ldHJ5Lm5vcm1hbCwgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJTaGluaW5lc3MgKSAqIG1hdGVyaWFsLnNwZWN1bGFyU3RyZW5ndGg7XFxufVxcbnZvaWQgUkVfSW5kaXJlY3REaWZmdXNlX0JsaW5uUGhvbmcoIGNvbnN0IGluIHZlYzMgaXJyYWRpYW5jZSwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gQmxpbm5QaG9uZ01hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gaXJyYWRpYW5jZSAqIEJSREZfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7XFxufVxcbiNkZWZpbmUgUkVfRGlyZWN0XFx0XFx0XFx0XFx0UkVfRGlyZWN0X0JsaW5uUGhvbmdcXG4jZGVmaW5lIFJFX0luZGlyZWN0RGlmZnVzZVxcdFxcdFJFX0luZGlyZWN0RGlmZnVzZV9CbGlublBob25nXFxuI2RlZmluZSBNYXRlcmlhbF9MaWdodFByb2JlTE9EKCBtYXRlcmlhbCApXFx0KDApXCI7XG5cbnZhciBsaWdodHNfcGh5c2ljYWxfZnJhZ21lbnQgPSBcIlBoeXNpY2FsTWF0ZXJpYWwgbWF0ZXJpYWw7XFxubWF0ZXJpYWwuZGlmZnVzZUNvbG9yID0gZGlmZnVzZUNvbG9yLnJnYiAqICggMS4wIC0gbWV0YWxuZXNzRmFjdG9yICk7XFxudmVjMyBkeHkgPSBtYXgoIGFicyggZEZkeCggZ2VvbWV0cnlOb3JtYWwgKSApLCBhYnMoIGRGZHkoIGdlb21ldHJ5Tm9ybWFsICkgKSApO1xcbmZsb2F0IGdlb21ldHJ5Um91Z2huZXNzID0gbWF4KCBtYXgoIGR4eS54LCBkeHkueSApLCBkeHkueiApO1xcbm1hdGVyaWFsLnJvdWdobmVzcyA9IG1heCggcm91Z2huZXNzRmFjdG9yLCAwLjA1MjUgKTttYXRlcmlhbC5yb3VnaG5lc3MgKz0gZ2VvbWV0cnlSb3VnaG5lc3M7XFxubWF0ZXJpYWwucm91Z2huZXNzID0gbWluKCBtYXRlcmlhbC5yb3VnaG5lc3MsIDEuMCApO1xcbiNpZmRlZiBJT1JcXG5cXHRtYXRlcmlhbC5pb3IgPSBpb3I7XFxuXFx0I2lmZGVmIFNQRUNVTEFSXFxuXFx0XFx0ZmxvYXQgc3BlY3VsYXJJbnRlbnNpdHlGYWN0b3IgPSBzcGVjdWxhckludGVuc2l0eTtcXG5cXHRcXHR2ZWMzIHNwZWN1bGFyQ29sb3JGYWN0b3IgPSBzcGVjdWxhckNvbG9yO1xcblxcdFxcdCNpZmRlZiBVU0VfU1BFQ1VMQVJJTlRFTlNJVFlNQVBcXG5cXHRcXHRcXHRzcGVjdWxhckludGVuc2l0eUZhY3RvciAqPSB0ZXh0dXJlMkQoIHNwZWN1bGFySW50ZW5zaXR5TWFwLCB2VXYgKS5hO1xcblxcdFxcdCNlbmRpZlxcblxcdFxcdCNpZmRlZiBVU0VfU1BFQ1VMQVJDT0xPUk1BUFxcblxcdFxcdFxcdHNwZWN1bGFyQ29sb3JGYWN0b3IgKj0gdGV4dHVyZTJEKCBzcGVjdWxhckNvbG9yTWFwLCB2VXYgKS5yZ2I7XFxuXFx0XFx0I2VuZGlmXFxuXFx0XFx0bWF0ZXJpYWwuc3BlY3VsYXJGOTAgPSBtaXgoIHNwZWN1bGFySW50ZW5zaXR5RmFjdG9yLCAxLjAsIG1ldGFsbmVzc0ZhY3RvciApO1xcblxcdCNlbHNlXFxuXFx0XFx0ZmxvYXQgc3BlY3VsYXJJbnRlbnNpdHlGYWN0b3IgPSAxLjA7XFxuXFx0XFx0dmVjMyBzcGVjdWxhckNvbG9yRmFjdG9yID0gdmVjMyggMS4wICk7XFxuXFx0XFx0bWF0ZXJpYWwuc3BlY3VsYXJGOTAgPSAxLjA7XFxuXFx0I2VuZGlmXFxuXFx0bWF0ZXJpYWwuc3BlY3VsYXJDb2xvciA9IG1peCggbWluKCBwb3cyKCAoIG1hdGVyaWFsLmlvciAtIDEuMCApIC8gKCBtYXRlcmlhbC5pb3IgKyAxLjAgKSApICogc3BlY3VsYXJDb2xvckZhY3RvciwgdmVjMyggMS4wICkgKSAqIHNwZWN1bGFySW50ZW5zaXR5RmFjdG9yLCBkaWZmdXNlQ29sb3IucmdiLCBtZXRhbG5lc3NGYWN0b3IgKTtcXG4jZWxzZVxcblxcdG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgPSBtaXgoIHZlYzMoIDAuMDQgKSwgZGlmZnVzZUNvbG9yLnJnYiwgbWV0YWxuZXNzRmFjdG9yICk7XFxuXFx0bWF0ZXJpYWwuc3BlY3VsYXJGOTAgPSAxLjA7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9DTEVBUkNPQVRcXG5cXHRtYXRlcmlhbC5jbGVhcmNvYXQgPSBjbGVhcmNvYXQ7XFxuXFx0bWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzID0gY2xlYXJjb2F0Um91Z2huZXNzO1xcblxcdG1hdGVyaWFsLmNsZWFyY29hdEYwID0gdmVjMyggMC4wNCApO1xcblxcdG1hdGVyaWFsLmNsZWFyY29hdEY5MCA9IDEuMDtcXG5cXHQjaWZkZWYgVVNFX0NMRUFSQ09BVE1BUFxcblxcdFxcdG1hdGVyaWFsLmNsZWFyY29hdCAqPSB0ZXh0dXJlMkQoIGNsZWFyY29hdE1hcCwgdlV2ICkueDtcXG5cXHQjZW5kaWZcXG5cXHQjaWZkZWYgVVNFX0NMRUFSQ09BVF9ST1VHSE5FU1NNQVBcXG5cXHRcXHRtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MgKj0gdGV4dHVyZTJEKCBjbGVhcmNvYXRSb3VnaG5lc3NNYXAsIHZVdiApLnk7XFxuXFx0I2VuZGlmXFxuXFx0bWF0ZXJpYWwuY2xlYXJjb2F0ID0gc2F0dXJhdGUoIG1hdGVyaWFsLmNsZWFyY29hdCApO1xcdG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzcyA9IG1heCggbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzLCAwLjA1MjUgKTtcXG5cXHRtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MgKz0gZ2VvbWV0cnlSb3VnaG5lc3M7XFxuXFx0bWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzID0gbWluKCBtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MsIDEuMCApO1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VcXG5cXHRtYXRlcmlhbC5pcmlkZXNjZW5jZSA9IGlyaWRlc2NlbmNlO1xcblxcdG1hdGVyaWFsLmlyaWRlc2NlbmNlSU9SID0gaXJpZGVzY2VuY2VJT1I7XFxuXFx0I2lmZGVmIFVTRV9JUklERVNDRU5DRU1BUFxcblxcdFxcdG1hdGVyaWFsLmlyaWRlc2NlbmNlICo9IHRleHR1cmUyRCggaXJpZGVzY2VuY2VNYXAsIHZVdiApLnI7XFxuXFx0I2VuZGlmXFxuXFx0I2lmZGVmIFVTRV9JUklERVNDRU5DRV9USElDS05FU1NNQVBcXG5cXHRcXHRtYXRlcmlhbC5pcmlkZXNjZW5jZVRoaWNrbmVzcyA9IChpcmlkZXNjZW5jZVRoaWNrbmVzc01heGltdW0gLSBpcmlkZXNjZW5jZVRoaWNrbmVzc01pbmltdW0pICogdGV4dHVyZTJEKCBpcmlkZXNjZW5jZVRoaWNrbmVzc01hcCwgdlV2ICkuZyArIGlyaWRlc2NlbmNlVGhpY2tuZXNzTWluaW11bTtcXG5cXHQjZWxzZVxcblxcdFxcdG1hdGVyaWFsLmlyaWRlc2NlbmNlVGhpY2tuZXNzID0gaXJpZGVzY2VuY2VUaGlja25lc3NNYXhpbXVtO1xcblxcdCNlbmRpZlxcbiNlbmRpZlxcbiNpZmRlZiBVU0VfU0hFRU5cXG5cXHRtYXRlcmlhbC5zaGVlbkNvbG9yID0gc2hlZW5Db2xvcjtcXG5cXHQjaWZkZWYgVVNFX1NIRUVOQ09MT1JNQVBcXG5cXHRcXHRtYXRlcmlhbC5zaGVlbkNvbG9yICo9IHRleHR1cmUyRCggc2hlZW5Db2xvck1hcCwgdlV2ICkucmdiO1xcblxcdCNlbmRpZlxcblxcdG1hdGVyaWFsLnNoZWVuUm91Z2huZXNzID0gY2xhbXAoIHNoZWVuUm91Z2huZXNzLCAwLjA3LCAxLjAgKTtcXG5cXHQjaWZkZWYgVVNFX1NIRUVOUk9VR0hORVNTTUFQXFxuXFx0XFx0bWF0ZXJpYWwuc2hlZW5Sb3VnaG5lc3MgKj0gdGV4dHVyZTJEKCBzaGVlblJvdWdobmVzc01hcCwgdlV2ICkuYTtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIjtcblxudmFyIGxpZ2h0c19waHlzaWNhbF9wYXJzX2ZyYWdtZW50ID0gXCJzdHJ1Y3QgUGh5c2ljYWxNYXRlcmlhbCB7XFxuXFx0dmVjMyBkaWZmdXNlQ29sb3I7XFxuXFx0ZmxvYXQgcm91Z2huZXNzO1xcblxcdHZlYzMgc3BlY3VsYXJDb2xvcjtcXG5cXHRmbG9hdCBzcGVjdWxhckY5MDtcXG5cXHQjaWZkZWYgVVNFX0NMRUFSQ09BVFxcblxcdFxcdGZsb2F0IGNsZWFyY29hdDtcXG5cXHRcXHRmbG9hdCBjbGVhcmNvYXRSb3VnaG5lc3M7XFxuXFx0XFx0dmVjMyBjbGVhcmNvYXRGMDtcXG5cXHRcXHRmbG9hdCBjbGVhcmNvYXRGOTA7XFxuXFx0I2VuZGlmXFxuXFx0I2lmZGVmIFVTRV9JUklERVNDRU5DRVxcblxcdFxcdGZsb2F0IGlyaWRlc2NlbmNlO1xcblxcdFxcdGZsb2F0IGlyaWRlc2NlbmNlSU9SO1xcblxcdFxcdGZsb2F0IGlyaWRlc2NlbmNlVGhpY2tuZXNzO1xcblxcdFxcdHZlYzMgaXJpZGVzY2VuY2VGcmVzbmVsO1xcblxcdFxcdHZlYzMgaXJpZGVzY2VuY2VGMDtcXG5cXHQjZW5kaWZcXG5cXHQjaWZkZWYgVVNFX1NIRUVOXFxuXFx0XFx0dmVjMyBzaGVlbkNvbG9yO1xcblxcdFxcdGZsb2F0IHNoZWVuUm91Z2huZXNzO1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBJT1JcXG5cXHRcXHRmbG9hdCBpb3I7XFxuXFx0I2VuZGlmXFxuXFx0I2lmZGVmIFVTRV9UUkFOU01JU1NJT05cXG5cXHRcXHRmbG9hdCB0cmFuc21pc3Npb247XFxuXFx0XFx0ZmxvYXQgdHJhbnNtaXNzaW9uQWxwaGE7XFxuXFx0XFx0ZmxvYXQgdGhpY2tuZXNzO1xcblxcdFxcdGZsb2F0IGF0dGVudWF0aW9uRGlzdGFuY2U7XFxuXFx0XFx0dmVjMyBhdHRlbnVhdGlvbkNvbG9yO1xcblxcdCNlbmRpZlxcbn07XFxudmVjMyBjbGVhcmNvYXRTcGVjdWxhciA9IHZlYzMoIDAuMCApO1xcbnZlYzMgc2hlZW5TcGVjdWxhciA9IHZlYzMoIDAuMCApO1xcbmZsb2F0IElCTFNoZWVuQlJERiggY29uc3QgaW4gdmVjMyBub3JtYWwsIGNvbnN0IGluIHZlYzMgdmlld0RpciwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzICkge1xcblxcdGZsb2F0IGRvdE5WID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCB2aWV3RGlyICkgKTtcXG5cXHRmbG9hdCByMiA9IHJvdWdobmVzcyAqIHJvdWdobmVzcztcXG5cXHRmbG9hdCBhID0gcm91Z2huZXNzIDwgMC4yNSA/IC0zMzkuMiAqIHIyICsgMTYxLjQgKiByb3VnaG5lc3MgLSAyNS45IDogLTguNDggKiByMiArIDE0LjMgKiByb3VnaG5lc3MgLSA5Ljk1O1xcblxcdGZsb2F0IGIgPSByb3VnaG5lc3MgPCAwLjI1ID8gNDQuMCAqIHIyIC0gMjMuNyAqIHJvdWdobmVzcyArIDMuMjYgOiAxLjk3ICogcjIgLSAzLjI3ICogcm91Z2huZXNzICsgMC43MjtcXG5cXHRmbG9hdCBERyA9IGV4cCggYSAqIGRvdE5WICsgYiApICsgKCByb3VnaG5lc3MgPCAwLjI1ID8gMC4wIDogMC4xICogKCByb3VnaG5lc3MgLSAwLjI1ICkgKTtcXG5cXHRyZXR1cm4gc2F0dXJhdGUoIERHICogUkVDSVBST0NBTF9QSSApO1xcbn1cXG52ZWMyIERGR0FwcHJveCggY29uc3QgaW4gdmVjMyBub3JtYWwsIGNvbnN0IGluIHZlYzMgdmlld0RpciwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzICkge1xcblxcdGZsb2F0IGRvdE5WID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCB2aWV3RGlyICkgKTtcXG5cXHRjb25zdCB2ZWM0IGMwID0gdmVjNCggLSAxLCAtIDAuMDI3NSwgLSAwLjU3MiwgMC4wMjIgKTtcXG5cXHRjb25zdCB2ZWM0IGMxID0gdmVjNCggMSwgMC4wNDI1LCAxLjA0LCAtIDAuMDQgKTtcXG5cXHR2ZWM0IHIgPSByb3VnaG5lc3MgKiBjMCArIGMxO1xcblxcdGZsb2F0IGEwMDQgPSBtaW4oIHIueCAqIHIueCwgZXhwMiggLSA5LjI4ICogZG90TlYgKSApICogci54ICsgci55O1xcblxcdHZlYzIgZmFiID0gdmVjMiggLSAxLjA0LCAxLjA0ICkgKiBhMDA0ICsgci56dztcXG5cXHRyZXR1cm4gZmFiO1xcbn1cXG52ZWMzIEVudmlyb25tZW50QlJERiggY29uc3QgaW4gdmVjMyBub3JtYWwsIGNvbnN0IGluIHZlYzMgdmlld0RpciwgY29uc3QgaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBjb25zdCBpbiBmbG9hdCBzcGVjdWxhckY5MCwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzICkge1xcblxcdHZlYzIgZmFiID0gREZHQXBwcm94KCBub3JtYWwsIHZpZXdEaXIsIHJvdWdobmVzcyApO1xcblxcdHJldHVybiBzcGVjdWxhckNvbG9yICogZmFiLnggKyBzcGVjdWxhckY5MCAqIGZhYi55O1xcbn1cXG4jaWZkZWYgVVNFX0lSSURFU0NFTkNFXFxudm9pZCBjb21wdXRlTXVsdGlzY2F0dGVyaW5nSXJpZGVzY2VuY2UoIGNvbnN0IGluIHZlYzMgbm9ybWFsLCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIHZlYzMgc3BlY3VsYXJDb2xvciwgY29uc3QgaW4gZmxvYXQgc3BlY3VsYXJGOTAsIGNvbnN0IGluIGZsb2F0IGlyaWRlc2NlbmNlLCBjb25zdCBpbiB2ZWMzIGlyaWRlc2NlbmNlRjAsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcywgaW5vdXQgdmVjMyBzaW5nbGVTY2F0dGVyLCBpbm91dCB2ZWMzIG11bHRpU2NhdHRlciApIHtcXG4jZWxzZVxcbnZvaWQgY29tcHV0ZU11bHRpc2NhdHRlcmluZyggY29uc3QgaW4gdmVjMyBub3JtYWwsIGNvbnN0IGluIHZlYzMgdmlld0RpciwgY29uc3QgaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBjb25zdCBpbiBmbG9hdCBzcGVjdWxhckY5MCwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzLCBpbm91dCB2ZWMzIHNpbmdsZVNjYXR0ZXIsIGlub3V0IHZlYzMgbXVsdGlTY2F0dGVyICkge1xcbiNlbmRpZlxcblxcdHZlYzIgZmFiID0gREZHQXBwcm94KCBub3JtYWwsIHZpZXdEaXIsIHJvdWdobmVzcyApO1xcblxcdCNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VcXG5cXHRcXHR2ZWMzIEZyID0gbWl4KCBzcGVjdWxhckNvbG9yLCBpcmlkZXNjZW5jZUYwLCBpcmlkZXNjZW5jZSApO1xcblxcdCNlbHNlXFxuXFx0XFx0dmVjMyBGciA9IHNwZWN1bGFyQ29sb3I7XFxuXFx0I2VuZGlmXFxuXFx0dmVjMyBGc3NFc3MgPSBGciAqIGZhYi54ICsgc3BlY3VsYXJGOTAgKiBmYWIueTtcXG5cXHRmbG9hdCBFc3MgPSBmYWIueCArIGZhYi55O1xcblxcdGZsb2F0IEVtcyA9IDEuMCAtIEVzcztcXG5cXHR2ZWMzIEZhdmcgPSBGciArICggMS4wIC0gRnIgKSAqIDAuMDQ3NjE5O1xcdHZlYzMgRm1zID0gRnNzRXNzICogRmF2ZyAvICggMS4wIC0gRW1zICogRmF2ZyApO1xcblxcdHNpbmdsZVNjYXR0ZXIgKz0gRnNzRXNzO1xcblxcdG11bHRpU2NhdHRlciArPSBGbXMgKiBFbXM7XFxufVxcbiNpZiBOVU1fUkVDVF9BUkVBX0xJR0hUUyA+IDBcXG5cXHR2b2lkIFJFX0RpcmVjdF9SZWN0QXJlYV9QaHlzaWNhbCggY29uc3QgaW4gUmVjdEFyZWFMaWdodCByZWN0QXJlYUxpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXG5cXHRcXHR2ZWMzIG5vcm1hbCA9IGdlb21ldHJ5Lm5vcm1hbDtcXG5cXHRcXHR2ZWMzIHZpZXdEaXIgPSBnZW9tZXRyeS52aWV3RGlyO1xcblxcdFxcdHZlYzMgcG9zaXRpb24gPSBnZW9tZXRyeS5wb3NpdGlvbjtcXG5cXHRcXHR2ZWMzIGxpZ2h0UG9zID0gcmVjdEFyZWFMaWdodC5wb3NpdGlvbjtcXG5cXHRcXHR2ZWMzIGhhbGZXaWR0aCA9IHJlY3RBcmVhTGlnaHQuaGFsZldpZHRoO1xcblxcdFxcdHZlYzMgaGFsZkhlaWdodCA9IHJlY3RBcmVhTGlnaHQuaGFsZkhlaWdodDtcXG5cXHRcXHR2ZWMzIGxpZ2h0Q29sb3IgPSByZWN0QXJlYUxpZ2h0LmNvbG9yO1xcblxcdFxcdGZsb2F0IHJvdWdobmVzcyA9IG1hdGVyaWFsLnJvdWdobmVzcztcXG5cXHRcXHR2ZWMzIHJlY3RDb29yZHNbIDQgXTtcXG5cXHRcXHRyZWN0Q29vcmRzWyAwIF0gPSBsaWdodFBvcyArIGhhbGZXaWR0aCAtIGhhbGZIZWlnaHQ7XFx0XFx0cmVjdENvb3Jkc1sgMSBdID0gbGlnaHRQb3MgLSBoYWxmV2lkdGggLSBoYWxmSGVpZ2h0O1xcblxcdFxcdHJlY3RDb29yZHNbIDIgXSA9IGxpZ2h0UG9zIC0gaGFsZldpZHRoICsgaGFsZkhlaWdodDtcXG5cXHRcXHRyZWN0Q29vcmRzWyAzIF0gPSBsaWdodFBvcyArIGhhbGZXaWR0aCArIGhhbGZIZWlnaHQ7XFxuXFx0XFx0dmVjMiB1diA9IExUQ19Vdiggbm9ybWFsLCB2aWV3RGlyLCByb3VnaG5lc3MgKTtcXG5cXHRcXHR2ZWM0IHQxID0gdGV4dHVyZTJEKCBsdGNfMSwgdXYgKTtcXG5cXHRcXHR2ZWM0IHQyID0gdGV4dHVyZTJEKCBsdGNfMiwgdXYgKTtcXG5cXHRcXHRtYXQzIG1JbnYgPSBtYXQzKFxcblxcdFxcdFxcdHZlYzMoIHQxLngsIDAsIHQxLnkgKSxcXG5cXHRcXHRcXHR2ZWMzKFx0XHQwLCAxLFx0XHQwICksXFxuXFx0XFx0XFx0dmVjMyggdDEueiwgMCwgdDEudyApXFxuXFx0XFx0KTtcXG5cXHRcXHR2ZWMzIGZyZXNuZWwgPSAoIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgKiB0Mi54ICsgKCB2ZWMzKCAxLjAgKSAtIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgKSAqIHQyLnkgKTtcXG5cXHRcXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArPSBsaWdodENvbG9yICogZnJlc25lbCAqIExUQ19FdmFsdWF0ZSggbm9ybWFsLCB2aWV3RGlyLCBwb3NpdGlvbiwgbUludiwgcmVjdENvb3JkcyApO1xcblxcdFxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKz0gbGlnaHRDb2xvciAqIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciAqIExUQ19FdmFsdWF0ZSggbm9ybWFsLCB2aWV3RGlyLCBwb3NpdGlvbiwgbWF0MyggMS4wICksIHJlY3RDb29yZHMgKTtcXG5cXHR9XFxuI2VuZGlmXFxudm9pZCBSRV9EaXJlY3RfUGh5c2ljYWwoIGNvbnN0IGluIEluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIFBoeXNpY2FsTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkge1xcblxcdGZsb2F0IGRvdE5MID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKSApO1xcblxcdHZlYzMgaXJyYWRpYW5jZSA9IGRvdE5MICogZGlyZWN0TGlnaHQuY29sb3I7XFxuXFx0I2lmZGVmIFVTRV9DTEVBUkNPQVRcXG5cXHRcXHRmbG9hdCBkb3ROTGNjID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkuY2xlYXJjb2F0Tm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKSApO1xcblxcdFxcdHZlYzMgY2NJcnJhZGlhbmNlID0gZG90TkxjYyAqIGRpcmVjdExpZ2h0LmNvbG9yO1xcblxcdFxcdGNsZWFyY29hdFNwZWN1bGFyICs9IGNjSXJyYWRpYW5jZSAqIEJSREZfR0dYKCBkaXJlY3RMaWdodC5kaXJlY3Rpb24sIGdlb21ldHJ5LnZpZXdEaXIsIGdlb21ldHJ5LmNsZWFyY29hdE5vcm1hbCwgbWF0ZXJpYWwuY2xlYXJjb2F0RjAsIG1hdGVyaWFsLmNsZWFyY29hdEY5MCwgbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzICk7XFxuXFx0I2VuZGlmXFxuXFx0I2lmZGVmIFVTRV9TSEVFTlxcblxcdFxcdHNoZWVuU3BlY3VsYXIgKz0gaXJyYWRpYW5jZSAqIEJSREZfU2hlZW4oIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiwgZ2VvbWV0cnkudmlld0RpciwgZ2VvbWV0cnkubm9ybWFsLCBtYXRlcmlhbC5zaGVlbkNvbG9yLCBtYXRlcmlhbC5zaGVlblJvdWdobmVzcyApO1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VcXG5cXHRcXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArPSBpcnJhZGlhbmNlICogQlJERl9HR1hfSXJpZGVzY2VuY2UoIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiwgZ2VvbWV0cnkudmlld0RpciwgZ2VvbWV0cnkubm9ybWFsLCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yLCBtYXRlcmlhbC5zcGVjdWxhckY5MCwgbWF0ZXJpYWwuaXJpZGVzY2VuY2UsIG1hdGVyaWFsLmlyaWRlc2NlbmNlRnJlc25lbCwgbWF0ZXJpYWwucm91Z2huZXNzICk7XFxuXFx0I2Vsc2VcXG5cXHRcXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArPSBpcnJhZGlhbmNlICogQlJERl9HR1goIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiwgZ2VvbWV0cnkudmlld0RpciwgZ2VvbWV0cnkubm9ybWFsLCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yLCBtYXRlcmlhbC5zcGVjdWxhckY5MCwgbWF0ZXJpYWwucm91Z2huZXNzICk7XFxuXFx0I2VuZGlmXFxuXFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTtcXG59XFxudm9pZCBSRV9JbmRpcmVjdERpZmZ1c2VfUGh5c2ljYWwoIGNvbnN0IGluIHZlYzMgaXJyYWRpYW5jZSwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gUGh5c2ljYWxNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7XFxuXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IGlycmFkaWFuY2UgKiBCUkRGX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApO1xcbn1cXG52b2lkIFJFX0luZGlyZWN0U3BlY3VsYXJfUGh5c2ljYWwoIGNvbnN0IGluIHZlYzMgcmFkaWFuY2UsIGNvbnN0IGluIHZlYzMgaXJyYWRpYW5jZSwgY29uc3QgaW4gdmVjMyBjbGVhcmNvYXRSYWRpYW5jZSwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gUGh5c2ljYWxNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQpIHtcXG5cXHQjaWZkZWYgVVNFX0NMRUFSQ09BVFxcblxcdFxcdGNsZWFyY29hdFNwZWN1bGFyICs9IGNsZWFyY29hdFJhZGlhbmNlICogRW52aXJvbm1lbnRCUkRGKCBnZW9tZXRyeS5jbGVhcmNvYXROb3JtYWwsIGdlb21ldHJ5LnZpZXdEaXIsIG1hdGVyaWFsLmNsZWFyY29hdEYwLCBtYXRlcmlhbC5jbGVhcmNvYXRGOTAsIG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzcyApO1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBVU0VfU0hFRU5cXG5cXHRcXHRzaGVlblNwZWN1bGFyICs9IGlycmFkaWFuY2UgKiBtYXRlcmlhbC5zaGVlbkNvbG9yICogSUJMU2hlZW5CUkRGKCBnZW9tZXRyeS5ub3JtYWwsIGdlb21ldHJ5LnZpZXdEaXIsIG1hdGVyaWFsLnNoZWVuUm91Z2huZXNzICk7XFxuXFx0I2VuZGlmXFxuXFx0dmVjMyBzaW5nbGVTY2F0dGVyaW5nID0gdmVjMyggMC4wICk7XFxuXFx0dmVjMyBtdWx0aVNjYXR0ZXJpbmcgPSB2ZWMzKCAwLjAgKTtcXG5cXHR2ZWMzIGNvc2luZVdlaWdodGVkSXJyYWRpYW5jZSA9IGlycmFkaWFuY2UgKiBSRUNJUFJPQ0FMX1BJO1xcblxcdCNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VcXG5cXHRcXHRjb21wdXRlTXVsdGlzY2F0dGVyaW5nSXJpZGVzY2VuY2UoIGdlb21ldHJ5Lm5vcm1hbCwgZ2VvbWV0cnkudmlld0RpciwgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJGOTAsIG1hdGVyaWFsLmlyaWRlc2NlbmNlLCBtYXRlcmlhbC5pcmlkZXNjZW5jZUZyZXNuZWwsIG1hdGVyaWFsLnJvdWdobmVzcywgc2luZ2xlU2NhdHRlcmluZywgbXVsdGlTY2F0dGVyaW5nICk7XFxuXFx0I2Vsc2VcXG5cXHRcXHRjb21wdXRlTXVsdGlzY2F0dGVyaW5nKCBnZW9tZXRyeS5ub3JtYWwsIGdlb21ldHJ5LnZpZXdEaXIsIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IsIG1hdGVyaWFsLnNwZWN1bGFyRjkwLCBtYXRlcmlhbC5yb3VnaG5lc3MsIHNpbmdsZVNjYXR0ZXJpbmcsIG11bHRpU2NhdHRlcmluZyApO1xcblxcdCNlbmRpZlxcblxcdHZlYzMgdG90YWxTY2F0dGVyaW5nID0gc2luZ2xlU2NhdHRlcmluZyArIG11bHRpU2NhdHRlcmluZztcXG5cXHR2ZWMzIGRpZmZ1c2UgPSBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKiAoIDEuMCAtIG1heCggbWF4KCB0b3RhbFNjYXR0ZXJpbmcuciwgdG90YWxTY2F0dGVyaW5nLmcgKSwgdG90YWxTY2F0dGVyaW5nLmIgKSApO1xcblxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIgKz0gcmFkaWFuY2UgKiBzaW5nbGVTY2F0dGVyaW5nO1xcblxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIgKz0gbXVsdGlTY2F0dGVyaW5nICogY29zaW5lV2VpZ2h0ZWRJcnJhZGlhbmNlO1xcblxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSBkaWZmdXNlICogY29zaW5lV2VpZ2h0ZWRJcnJhZGlhbmNlO1xcbn1cXG4jZGVmaW5lIFJFX0RpcmVjdFxcdFxcdFxcdFxcdFJFX0RpcmVjdF9QaHlzaWNhbFxcbiNkZWZpbmUgUkVfRGlyZWN0X1JlY3RBcmVhXFx0XFx0UkVfRGlyZWN0X1JlY3RBcmVhX1BoeXNpY2FsXFxuI2RlZmluZSBSRV9JbmRpcmVjdERpZmZ1c2VcXHRcXHRSRV9JbmRpcmVjdERpZmZ1c2VfUGh5c2ljYWxcXG4jZGVmaW5lIFJFX0luZGlyZWN0U3BlY3VsYXJcXHRcXHRSRV9JbmRpcmVjdFNwZWN1bGFyX1BoeXNpY2FsXFxuZmxvYXQgY29tcHV0ZVNwZWN1bGFyT2NjbHVzaW9uKCBjb25zdCBpbiBmbG9hdCBkb3ROViwgY29uc3QgaW4gZmxvYXQgYW1iaWVudE9jY2x1c2lvbiwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzICkge1xcblxcdHJldHVybiBzYXR1cmF0ZSggcG93KCBkb3ROViArIGFtYmllbnRPY2NsdXNpb24sIGV4cDIoIC0gMTYuMCAqIHJvdWdobmVzcyAtIDEuMCApICkgLSAxLjAgKyBhbWJpZW50T2NjbHVzaW9uICk7XFxufVwiO1xuXG52YXIgbGlnaHRzX2ZyYWdtZW50X2JlZ2luID0gXCJcXG5HZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5O1xcbmdlb21ldHJ5LnBvc2l0aW9uID0gLSB2Vmlld1Bvc2l0aW9uO1xcbmdlb21ldHJ5Lm5vcm1hbCA9IG5vcm1hbDtcXG5nZW9tZXRyeS52aWV3RGlyID0gKCBpc09ydGhvZ3JhcGhpYyApID8gdmVjMyggMCwgMCwgMSApIDogbm9ybWFsaXplKCB2Vmlld1Bvc2l0aW9uICk7XFxuI2lmZGVmIFVTRV9DTEVBUkNPQVRcXG5cXHRnZW9tZXRyeS5jbGVhcmNvYXROb3JtYWwgPSBjbGVhcmNvYXROb3JtYWw7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9JUklERVNDRU5DRVxcblxcdGZsb2F0IGRvdE5WaSA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgZ2VvbWV0cnkudmlld0RpciApICk7XFxuXFx0aWYgKCBtYXRlcmlhbC5pcmlkZXNjZW5jZVRoaWNrbmVzcyA9PSAwLjAgKSB7XFxuXFx0XFx0bWF0ZXJpYWwuaXJpZGVzY2VuY2UgPSAwLjA7XFxuXFx0fSBlbHNlIHtcXG5cXHRcXHRtYXRlcmlhbC5pcmlkZXNjZW5jZSA9IHNhdHVyYXRlKCBtYXRlcmlhbC5pcmlkZXNjZW5jZSApO1xcblxcdH1cXG5cXHRpZiAoIG1hdGVyaWFsLmlyaWRlc2NlbmNlID4gMC4wICkge1xcblxcdFxcdG1hdGVyaWFsLmlyaWRlc2NlbmNlRnJlc25lbCA9IGV2YWxJcmlkZXNjZW5jZSggMS4wLCBtYXRlcmlhbC5pcmlkZXNjZW5jZUlPUiwgZG90TlZpLCBtYXRlcmlhbC5pcmlkZXNjZW5jZVRoaWNrbmVzcywgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciApO1xcblxcdFxcdG1hdGVyaWFsLmlyaWRlc2NlbmNlRjAgPSBTY2hsaWNrX3RvX0YwKCBtYXRlcmlhbC5pcmlkZXNjZW5jZUZyZXNuZWwsIDEuMCwgZG90TlZpICk7XFxuXFx0fVxcbiNlbmRpZlxcbkluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQ7XFxuI2lmICggTlVNX1BPSU5UX0xJR0hUUyA+IDAgKSAmJiBkZWZpbmVkKCBSRV9EaXJlY3QgKVxcblxcdFBvaW50TGlnaHQgcG9pbnRMaWdodDtcXG5cXHQjaWYgZGVmaW5lZCggVVNFX1NIQURPV01BUCApICYmIE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTID4gMFxcblxcdFBvaW50TGlnaHRTaGFkb3cgcG9pbnRMaWdodFNoYWRvdztcXG5cXHQjZW5kaWZcXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1BPSU5UX0xJR0hUUzsgaSArKyApIHtcXG5cXHRcXHRwb2ludExpZ2h0ID0gcG9pbnRMaWdodHNbIGkgXTtcXG5cXHRcXHRnZXRQb2ludExpZ2h0SW5mbyggcG9pbnRMaWdodCwgZ2VvbWV0cnksIGRpcmVjdExpZ2h0ICk7XFxuXFx0XFx0I2lmIGRlZmluZWQoIFVTRV9TSEFET1dNQVAgKSAmJiAoIFVOUk9MTEVEX0xPT1BfSU5ERVggPCBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyApXFxuXFx0XFx0cG9pbnRMaWdodFNoYWRvdyA9IHBvaW50TGlnaHRTaGFkb3dzWyBpIF07XFxuXFx0XFx0ZGlyZWN0TGlnaHQuY29sb3IgKj0gYWxsKCBidmVjMiggZGlyZWN0TGlnaHQudmlzaWJsZSwgcmVjZWl2ZVNoYWRvdyApICkgPyBnZXRQb2ludFNoYWRvdyggcG9pbnRTaGFkb3dNYXBbIGkgXSwgcG9pbnRMaWdodFNoYWRvdy5zaGFkb3dNYXBTaXplLCBwb2ludExpZ2h0U2hhZG93LnNoYWRvd0JpYXMsIHBvaW50TGlnaHRTaGFkb3cuc2hhZG93UmFkaXVzLCB2UG9pbnRTaGFkb3dDb29yZFsgaSBdLCBwb2ludExpZ2h0U2hhZG93LnNoYWRvd0NhbWVyYU5lYXIsIHBvaW50TGlnaHRTaGFkb3cuc2hhZG93Q2FtZXJhRmFyICkgOiAxLjA7XFxuXFx0XFx0I2VuZGlmXFxuXFx0XFx0UkVfRGlyZWN0KCBkaXJlY3RMaWdodCwgZ2VvbWV0cnksIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xcblxcdH1cXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxcbiNlbmRpZlxcbiNpZiAoIE5VTV9TUE9UX0xJR0hUUyA+IDAgKSAmJiBkZWZpbmVkKCBSRV9EaXJlY3QgKVxcblxcdFNwb3RMaWdodCBzcG90TGlnaHQ7XFxuXFx0dmVjNCBzcG90Q29sb3I7XFxuXFx0dmVjMyBzcG90TGlnaHRDb29yZDtcXG5cXHRib29sIGluU3BvdExpZ2h0TWFwO1xcblxcdCNpZiBkZWZpbmVkKCBVU0VfU0hBRE9XTUFQICkgJiYgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHRTcG90TGlnaHRTaGFkb3cgc3BvdExpZ2h0U2hhZG93O1xcblxcdCNlbmRpZlxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fU1BPVF9MSUdIVFM7IGkgKysgKSB7XFxuXFx0XFx0c3BvdExpZ2h0ID0gc3BvdExpZ2h0c1sgaSBdO1xcblxcdFxcdGdldFNwb3RMaWdodEluZm8oIHNwb3RMaWdodCwgZ2VvbWV0cnksIGRpcmVjdExpZ2h0ICk7XFxuXFx0XFx0I2lmICggVU5ST0xMRURfTE9PUF9JTkRFWCA8IE5VTV9TUE9UX0xJR0hUX1NIQURPV1NfV0lUSF9NQVBTIClcXG5cXHRcXHQjZGVmaW5lIFNQT1RfTElHSFRfTUFQX0lOREVYIFVOUk9MTEVEX0xPT1BfSU5ERVhcXG5cXHRcXHQjZWxpZiAoIFVOUk9MTEVEX0xPT1BfSU5ERVggPCBOVU1fU1BPVF9MSUdIVF9TSEFET1dTIClcXG5cXHRcXHQjZGVmaW5lIFNQT1RfTElHSFRfTUFQX0lOREVYIE5VTV9TUE9UX0xJR0hUX01BUFNcXG5cXHRcXHQjZWxzZVxcblxcdFxcdCNkZWZpbmUgU1BPVF9MSUdIVF9NQVBfSU5ERVggKCBVTlJPTExFRF9MT09QX0lOREVYIC0gTlVNX1NQT1RfTElHSFRfU0hBRE9XUyArIE5VTV9TUE9UX0xJR0hUX1NIQURPV1NfV0lUSF9NQVBTIClcXG5cXHRcXHQjZW5kaWZcXG5cXHRcXHQjaWYgKCBTUE9UX0xJR0hUX01BUF9JTkRFWCA8IE5VTV9TUE9UX0xJR0hUX01BUFMgKVxcblxcdFxcdFxcdHNwb3RMaWdodENvb3JkID0gdlNwb3RMaWdodENvb3JkWyBpIF0ueHl6IC8gdlNwb3RMaWdodENvb3JkWyBpIF0udztcXG5cXHRcXHRcXHRpblNwb3RMaWdodE1hcCA9IGFsbCggbGVzc1RoYW4oIGFicyggc3BvdExpZ2h0Q29vcmQgKiAyLiAtIDEuICksIHZlYzMoIDEuMCApICkgKTtcXG5cXHRcXHRcXHRzcG90Q29sb3IgPSB0ZXh0dXJlMkQoIHNwb3RMaWdodE1hcFsgU1BPVF9MSUdIVF9NQVBfSU5ERVggXSwgc3BvdExpZ2h0Q29vcmQueHkgKTtcXG5cXHRcXHRcXHRkaXJlY3RMaWdodC5jb2xvciA9IGluU3BvdExpZ2h0TWFwID8gZGlyZWN0TGlnaHQuY29sb3IgKiBzcG90Q29sb3IucmdiIDogZGlyZWN0TGlnaHQuY29sb3I7XFxuXFx0XFx0I2VuZGlmXFxuXFx0XFx0I3VuZGVmIFNQT1RfTElHSFRfTUFQX0lOREVYXFxuXFx0XFx0I2lmIGRlZmluZWQoIFVTRV9TSEFET1dNQVAgKSAmJiAoIFVOUk9MTEVEX0xPT1BfSU5ERVggPCBOVU1fU1BPVF9MSUdIVF9TSEFET1dTIClcXG5cXHRcXHRzcG90TGlnaHRTaGFkb3cgPSBzcG90TGlnaHRTaGFkb3dzWyBpIF07XFxuXFx0XFx0ZGlyZWN0TGlnaHQuY29sb3IgKj0gYWxsKCBidmVjMiggZGlyZWN0TGlnaHQudmlzaWJsZSwgcmVjZWl2ZVNoYWRvdyApICkgPyBnZXRTaGFkb3coIHNwb3RTaGFkb3dNYXBbIGkgXSwgc3BvdExpZ2h0U2hhZG93LnNoYWRvd01hcFNpemUsIHNwb3RMaWdodFNoYWRvdy5zaGFkb3dCaWFzLCBzcG90TGlnaHRTaGFkb3cuc2hhZG93UmFkaXVzLCB2U3BvdExpZ2h0Q29vcmRbIGkgXSApIDogMS4wO1xcblxcdFxcdCNlbmRpZlxcblxcdFxcdFJFX0RpcmVjdCggZGlyZWN0TGlnaHQsIGdlb21ldHJ5LCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQgKTtcXG5cXHR9XFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcXG4jZW5kaWZcXG4jaWYgKCBOVU1fRElSX0xJR0hUUyA+IDAgKSAmJiBkZWZpbmVkKCBSRV9EaXJlY3QgKVxcblxcdERpcmVjdGlvbmFsTGlnaHQgZGlyZWN0aW9uYWxMaWdodDtcXG5cXHQjaWYgZGVmaW5lZCggVVNFX1NIQURPV01BUCApICYmIE5VTV9ESVJfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHREaXJlY3Rpb25hbExpZ2h0U2hhZG93IGRpcmVjdGlvbmFsTGlnaHRTaGFkb3c7XFxuXFx0I2VuZGlmXFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9ESVJfTElHSFRTOyBpICsrICkge1xcblxcdFxcdGRpcmVjdGlvbmFsTGlnaHQgPSBkaXJlY3Rpb25hbExpZ2h0c1sgaSBdO1xcblxcdFxcdGdldERpcmVjdGlvbmFsTGlnaHRJbmZvKCBkaXJlY3Rpb25hbExpZ2h0LCBnZW9tZXRyeSwgZGlyZWN0TGlnaHQgKTtcXG5cXHRcXHQjaWYgZGVmaW5lZCggVVNFX1NIQURPV01BUCApICYmICggVU5ST0xMRURfTE9PUF9JTkRFWCA8IE5VTV9ESVJfTElHSFRfU0hBRE9XUyApXFxuXFx0XFx0ZGlyZWN0aW9uYWxMaWdodFNoYWRvdyA9IGRpcmVjdGlvbmFsTGlnaHRTaGFkb3dzWyBpIF07XFxuXFx0XFx0ZGlyZWN0TGlnaHQuY29sb3IgKj0gYWxsKCBidmVjMiggZGlyZWN0TGlnaHQudmlzaWJsZSwgcmVjZWl2ZVNoYWRvdyApICkgPyBnZXRTaGFkb3coIGRpcmVjdGlvbmFsU2hhZG93TWFwWyBpIF0sIGRpcmVjdGlvbmFsTGlnaHRTaGFkb3cuc2hhZG93TWFwU2l6ZSwgZGlyZWN0aW9uYWxMaWdodFNoYWRvdy5zaGFkb3dCaWFzLCBkaXJlY3Rpb25hbExpZ2h0U2hhZG93LnNoYWRvd1JhZGl1cywgdkRpcmVjdGlvbmFsU2hhZG93Q29vcmRbIGkgXSApIDogMS4wO1xcblxcdFxcdCNlbmRpZlxcblxcdFxcdFJFX0RpcmVjdCggZGlyZWN0TGlnaHQsIGdlb21ldHJ5LCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQgKTtcXG5cXHR9XFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcXG4jZW5kaWZcXG4jaWYgKCBOVU1fUkVDVF9BUkVBX0xJR0hUUyA+IDAgKSAmJiBkZWZpbmVkKCBSRV9EaXJlY3RfUmVjdEFyZWEgKVxcblxcdFJlY3RBcmVhTGlnaHQgcmVjdEFyZWFMaWdodDtcXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1JFQ1RfQVJFQV9MSUdIVFM7IGkgKysgKSB7XFxuXFx0XFx0cmVjdEFyZWFMaWdodCA9IHJlY3RBcmVhTGlnaHRzWyBpIF07XFxuXFx0XFx0UkVfRGlyZWN0X1JlY3RBcmVhKCByZWN0QXJlYUxpZ2h0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7XFxuXFx0fVxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXFxuI2VuZGlmXFxuI2lmIGRlZmluZWQoIFJFX0luZGlyZWN0RGlmZnVzZSApXFxuXFx0dmVjMyBpYmxJcnJhZGlhbmNlID0gdmVjMyggMC4wICk7XFxuXFx0dmVjMyBpcnJhZGlhbmNlID0gZ2V0QW1iaWVudExpZ2h0SXJyYWRpYW5jZSggYW1iaWVudExpZ2h0Q29sb3IgKTtcXG5cXHRpcnJhZGlhbmNlICs9IGdldExpZ2h0UHJvYmVJcnJhZGlhbmNlKCBsaWdodFByb2JlLCBnZW9tZXRyeS5ub3JtYWwgKTtcXG5cXHQjaWYgKCBOVU1fSEVNSV9MSUdIVFMgPiAwIClcXG5cXHRcXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0XFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0hFTUlfTElHSFRTOyBpICsrICkge1xcblxcdFxcdFxcdGlycmFkaWFuY2UgKz0gZ2V0SGVtaXNwaGVyZUxpZ2h0SXJyYWRpYW5jZSggaGVtaXNwaGVyZUxpZ2h0c1sgaSBdLCBnZW9tZXRyeS5ub3JtYWwgKTtcXG5cXHRcXHR9XFxuXFx0XFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcXG5cXHQjZW5kaWZcXG4jZW5kaWZcXG4jaWYgZGVmaW5lZCggUkVfSW5kaXJlY3RTcGVjdWxhciApXFxuXFx0dmVjMyByYWRpYW5jZSA9IHZlYzMoIDAuMCApO1xcblxcdHZlYzMgY2xlYXJjb2F0UmFkaWFuY2UgPSB2ZWMzKCAwLjAgKTtcXG4jZW5kaWZcIjtcblxudmFyIGxpZ2h0c19mcmFnbWVudF9tYXBzID0gXCIjaWYgZGVmaW5lZCggUkVfSW5kaXJlY3REaWZmdXNlIClcXG5cXHQjaWZkZWYgVVNFX0xJR0hUTUFQXFxuXFx0XFx0dmVjNCBsaWdodE1hcFRleGVsID0gdGV4dHVyZTJEKCBsaWdodE1hcCwgdlV2MiApO1xcblxcdFxcdHZlYzMgbGlnaHRNYXBJcnJhZGlhbmNlID0gbGlnaHRNYXBUZXhlbC5yZ2IgKiBsaWdodE1hcEludGVuc2l0eTtcXG5cXHRcXHRpcnJhZGlhbmNlICs9IGxpZ2h0TWFwSXJyYWRpYW5jZTtcXG5cXHQjZW5kaWZcXG5cXHQjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApICYmIGRlZmluZWQoIFNUQU5EQVJEICkgJiYgZGVmaW5lZCggRU5WTUFQX1RZUEVfQ1VCRV9VViApXFxuXFx0XFx0aWJsSXJyYWRpYW5jZSArPSBnZXRJQkxJcnJhZGlhbmNlKCBnZW9tZXRyeS5ub3JtYWwgKTtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcXG4jaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApICYmIGRlZmluZWQoIFJFX0luZGlyZWN0U3BlY3VsYXIgKVxcblxcdHJhZGlhbmNlICs9IGdldElCTFJhZGlhbmNlKCBnZW9tZXRyeS52aWV3RGlyLCBnZW9tZXRyeS5ub3JtYWwsIG1hdGVyaWFsLnJvdWdobmVzcyApO1xcblxcdCNpZmRlZiBVU0VfQ0xFQVJDT0FUXFxuXFx0XFx0Y2xlYXJjb2F0UmFkaWFuY2UgKz0gZ2V0SUJMUmFkaWFuY2UoIGdlb21ldHJ5LnZpZXdEaXIsIGdlb21ldHJ5LmNsZWFyY29hdE5vcm1hbCwgbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzICk7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG5cbnZhciBsaWdodHNfZnJhZ21lbnRfZW5kID0gXCIjaWYgZGVmaW5lZCggUkVfSW5kaXJlY3REaWZmdXNlIClcXG5cXHRSRV9JbmRpcmVjdERpZmZ1c2UoIGlycmFkaWFuY2UsIGdlb21ldHJ5LCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQgKTtcXG4jZW5kaWZcXG4jaWYgZGVmaW5lZCggUkVfSW5kaXJlY3RTcGVjdWxhciApXFxuXFx0UkVfSW5kaXJlY3RTcGVjdWxhciggcmFkaWFuY2UsIGlibElycmFkaWFuY2UsIGNsZWFyY29hdFJhZGlhbmNlLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7XFxuI2VuZGlmXCI7XG5cbnZhciBsb2dkZXB0aGJ1Zl9mcmFnbWVudCA9IFwiI2lmIGRlZmluZWQoIFVTRV9MT0dERVBUSEJVRiApICYmIGRlZmluZWQoIFVTRV9MT0dERVBUSEJVRl9FWFQgKVxcblxcdGdsX0ZyYWdEZXB0aEVYVCA9IHZJc1BlcnNwZWN0aXZlID09IDAuMCA/IGdsX0ZyYWdDb29yZC56IDogbG9nMiggdkZyYWdEZXB0aCApICogbG9nRGVwdGhCdWZGQyAqIDAuNTtcXG4jZW5kaWZcIjtcblxudmFyIGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQgPSBcIiNpZiBkZWZpbmVkKCBVU0VfTE9HREVQVEhCVUYgKSAmJiBkZWZpbmVkKCBVU0VfTE9HREVQVEhCVUZfRVhUIClcXG5cXHR1bmlmb3JtIGZsb2F0IGxvZ0RlcHRoQnVmRkM7XFxuXFx0dmFyeWluZyBmbG9hdCB2RnJhZ0RlcHRoO1xcblxcdHZhcnlpbmcgZmxvYXQgdklzUGVyc3BlY3RpdmU7XFxuI2VuZGlmXCI7XG5cbnZhciBsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9MT0dERVBUSEJVRlxcblxcdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXFxuXFx0XFx0dmFyeWluZyBmbG9hdCB2RnJhZ0RlcHRoO1xcblxcdFxcdHZhcnlpbmcgZmxvYXQgdklzUGVyc3BlY3RpdmU7XFxuXFx0I2Vsc2VcXG5cXHRcXHR1bmlmb3JtIGZsb2F0IGxvZ0RlcHRoQnVmRkM7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG5cbnZhciBsb2dkZXB0aGJ1Zl92ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfTE9HREVQVEhCVUZcXG5cXHQjaWZkZWYgVVNFX0xPR0RFUFRIQlVGX0VYVFxcblxcdFxcdHZGcmFnRGVwdGggPSAxLjAgKyBnbF9Qb3NpdGlvbi53O1xcblxcdFxcdHZJc1BlcnNwZWN0aXZlID0gZmxvYXQoIGlzUGVyc3BlY3RpdmVNYXRyaXgoIHByb2plY3Rpb25NYXRyaXggKSApO1xcblxcdCNlbHNlXFxuXFx0XFx0aWYgKCBpc1BlcnNwZWN0aXZlTWF0cml4KCBwcm9qZWN0aW9uTWF0cml4ICkgKSB7XFxuXFx0XFx0XFx0Z2xfUG9zaXRpb24ueiA9IGxvZzIoIG1heCggRVBTSUxPTiwgZ2xfUG9zaXRpb24udyArIDEuMCApICkgKiBsb2dEZXB0aEJ1ZkZDIC0gMS4wO1xcblxcdFxcdFxcdGdsX1Bvc2l0aW9uLnogKj0gZ2xfUG9zaXRpb24udztcXG5cXHRcXHR9XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG5cbnZhciBtYXBfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfTUFQXFxuXFx0dmVjNCBzYW1wbGVkRGlmZnVzZUNvbG9yID0gdGV4dHVyZTJEKCBtYXAsIHZVdiApO1xcblxcdCNpZmRlZiBERUNPREVfVklERU9fVEVYVFVSRVxcblxcdFxcdHNhbXBsZWREaWZmdXNlQ29sb3IgPSB2ZWM0KCBtaXgoIHBvdyggc2FtcGxlZERpZmZ1c2VDb2xvci5yZ2IgKiAwLjk0Nzg2NzI5ODYgKyB2ZWMzKCAwLjA1MjEzMjcwMTQgKSwgdmVjMyggMi40ICkgKSwgc2FtcGxlZERpZmZ1c2VDb2xvci5yZ2IgKiAwLjA3NzM5OTM4MDgsIHZlYzMoIGxlc3NUaGFuRXF1YWwoIHNhbXBsZWREaWZmdXNlQ29sb3IucmdiLCB2ZWMzKCAwLjA0MDQ1ICkgKSApICksIHNhbXBsZWREaWZmdXNlQ29sb3IudyApO1xcblxcdCNlbmRpZlxcblxcdGRpZmZ1c2VDb2xvciAqPSBzYW1wbGVkRGlmZnVzZUNvbG9yO1xcbiNlbmRpZlwiO1xuXG52YXIgbWFwX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgbWFwO1xcbiNlbmRpZlwiO1xuXG52YXIgbWFwX3BhcnRpY2xlX2ZyYWdtZW50ID0gXCIjaWYgZGVmaW5lZCggVVNFX01BUCApIHx8IGRlZmluZWQoIFVTRV9BTFBIQU1BUCApXFxuXFx0dmVjMiB1diA9ICggdXZUcmFuc2Zvcm0gKiB2ZWMzKCBnbF9Qb2ludENvb3JkLngsIDEuMCAtIGdsX1BvaW50Q29vcmQueSwgMSApICkueHk7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9NQVBcXG5cXHRkaWZmdXNlQ29sb3IgKj0gdGV4dHVyZTJEKCBtYXAsIHV2ICk7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9BTFBIQU1BUFxcblxcdGRpZmZ1c2VDb2xvci5hICo9IHRleHR1cmUyRCggYWxwaGFNYXAsIHV2ICkuZztcXG4jZW5kaWZcIjtcblxudmFyIG1hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50ID0gXCIjaWYgZGVmaW5lZCggVVNFX01BUCApIHx8IGRlZmluZWQoIFVTRV9BTFBIQU1BUCApXFxuXFx0dW5pZm9ybSBtYXQzIHV2VHJhbnNmb3JtO1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgbWFwO1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfQUxQSEFNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBhbHBoYU1hcDtcXG4jZW5kaWZcIjtcblxudmFyIG1ldGFsbmVzc21hcF9mcmFnbWVudCA9IFwiZmxvYXQgbWV0YWxuZXNzRmFjdG9yID0gbWV0YWxuZXNzO1xcbiNpZmRlZiBVU0VfTUVUQUxORVNTTUFQXFxuXFx0dmVjNCB0ZXhlbE1ldGFsbmVzcyA9IHRleHR1cmUyRCggbWV0YWxuZXNzTWFwLCB2VXYgKTtcXG5cXHRtZXRhbG5lc3NGYWN0b3IgKj0gdGV4ZWxNZXRhbG5lc3MuYjtcXG4jZW5kaWZcIjtcblxudmFyIG1ldGFsbmVzc21hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX01FVEFMTkVTU01BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIG1ldGFsbmVzc01hcDtcXG4jZW5kaWZcIjtcblxudmFyIG1vcnBoY29sb3JfdmVydGV4ID0gXCIjaWYgZGVmaW5lZCggVVNFX01PUlBIQ09MT1JTICkgJiYgZGVmaW5lZCggTU9SUEhUQVJHRVRTX1RFWFRVUkUgKVxcblxcdHZDb2xvciAqPSBtb3JwaFRhcmdldEJhc2VJbmZsdWVuY2U7XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTU9SUEhUQVJHRVRTX0NPVU5UOyBpICsrICkge1xcblxcdFxcdCNpZiBkZWZpbmVkKCBVU0VfQ09MT1JfQUxQSEEgKVxcblxcdFxcdFxcdGlmICggbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBpIF0gIT0gMC4wICkgdkNvbG9yICs9IGdldE1vcnBoKCBnbF9WZXJ0ZXhJRCwgaSwgMiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBpIF07XFxuXFx0XFx0I2VsaWYgZGVmaW5lZCggVVNFX0NPTE9SIClcXG5cXHRcXHRcXHRpZiAoIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgaSBdICE9IDAuMCApIHZDb2xvciArPSBnZXRNb3JwaCggZ2xfVmVydGV4SUQsIGksIDIgKS5yZ2IgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXTtcXG5cXHRcXHQjZW5kaWZcXG5cXHR9XFxuI2VuZGlmXCI7XG5cbnZhciBtb3JwaG5vcm1hbF92ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfTU9SUEhOT1JNQUxTXFxuXFx0b2JqZWN0Tm9ybWFsICo9IG1vcnBoVGFyZ2V0QmFzZUluZmx1ZW5jZTtcXG5cXHQjaWZkZWYgTU9SUEhUQVJHRVRTX1RFWFRVUkVcXG5cXHRcXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBNT1JQSFRBUkdFVFNfQ09VTlQ7IGkgKysgKSB7XFxuXFx0XFx0XFx0aWYgKCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXSAhPSAwLjAgKSBvYmplY3ROb3JtYWwgKz0gZ2V0TW9ycGgoIGdsX1ZlcnRleElELCBpLCAxICkueHl6ICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBpIF07XFxuXFx0XFx0fVxcblxcdCNlbHNlXFxuXFx0XFx0b2JqZWN0Tm9ybWFsICs9IG1vcnBoTm9ybWFsMCAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMCBdO1xcblxcdFxcdG9iamVjdE5vcm1hbCArPSBtb3JwaE5vcm1hbDEgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDEgXTtcXG5cXHRcXHRvYmplY3ROb3JtYWwgKz0gbW9ycGhOb3JtYWwyICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAyIF07XFxuXFx0XFx0b2JqZWN0Tm9ybWFsICs9IG1vcnBoTm9ybWFsMyAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMyBdO1xcblxcdCNlbmRpZlxcbiNlbmRpZlwiO1xuXG52YXIgbW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfTU9SUEhUQVJHRVRTXFxuXFx0dW5pZm9ybSBmbG9hdCBtb3JwaFRhcmdldEJhc2VJbmZsdWVuY2U7XFxuXFx0I2lmZGVmIE1PUlBIVEFSR0VUU19URVhUVVJFXFxuXFx0XFx0dW5pZm9ybSBmbG9hdCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIE1PUlBIVEFSR0VUU19DT1VOVCBdO1xcblxcdFxcdHVuaWZvcm0gc2FtcGxlcjJEQXJyYXkgbW9ycGhUYXJnZXRzVGV4dHVyZTtcXG5cXHRcXHR1bmlmb3JtIGl2ZWMyIG1vcnBoVGFyZ2V0c1RleHR1cmVTaXplO1xcblxcdFxcdHZlYzQgZ2V0TW9ycGgoIGNvbnN0IGluIGludCB2ZXJ0ZXhJbmRleCwgY29uc3QgaW4gaW50IG1vcnBoVGFyZ2V0SW5kZXgsIGNvbnN0IGluIGludCBvZmZzZXQgKSB7XFxuXFx0XFx0XFx0aW50IHRleGVsSW5kZXggPSB2ZXJ0ZXhJbmRleCAqIE1PUlBIVEFSR0VUU19URVhUVVJFX1NUUklERSArIG9mZnNldDtcXG5cXHRcXHRcXHRpbnQgeSA9IHRleGVsSW5kZXggLyBtb3JwaFRhcmdldHNUZXh0dXJlU2l6ZS54O1xcblxcdFxcdFxcdGludCB4ID0gdGV4ZWxJbmRleCAtIHkgKiBtb3JwaFRhcmdldHNUZXh0dXJlU2l6ZS54O1xcblxcdFxcdFxcdGl2ZWMzIG1vcnBoVVYgPSBpdmVjMyggeCwgeSwgbW9ycGhUYXJnZXRJbmRleCApO1xcblxcdFxcdFxcdHJldHVybiB0ZXhlbEZldGNoKCBtb3JwaFRhcmdldHNUZXh0dXJlLCBtb3JwaFVWLCAwICk7XFxuXFx0XFx0fVxcblxcdCNlbHNlXFxuXFx0XFx0I2lmbmRlZiBVU0VfTU9SUEhOT1JNQUxTXFxuXFx0XFx0XFx0dW5pZm9ybSBmbG9hdCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDggXTtcXG5cXHRcXHQjZWxzZVxcblxcdFxcdFxcdHVuaWZvcm0gZmxvYXQgbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA0IF07XFxuXFx0XFx0I2VuZGlmXFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG5cbnZhciBtb3JwaHRhcmdldF92ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfTU9SUEhUQVJHRVRTXFxuXFx0dHJhbnNmb3JtZWQgKj0gbW9ycGhUYXJnZXRCYXNlSW5mbHVlbmNlO1xcblxcdCNpZmRlZiBNT1JQSFRBUkdFVFNfVEVYVFVSRVxcblxcdFxcdGZvciAoIGludCBpID0gMDsgaSA8IE1PUlBIVEFSR0VUU19DT1VOVDsgaSArKyApIHtcXG5cXHRcXHRcXHRpZiAoIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgaSBdICE9IDAuMCApIHRyYW5zZm9ybWVkICs9IGdldE1vcnBoKCBnbF9WZXJ0ZXhJRCwgaSwgMCApLnh5eiAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgaSBdO1xcblxcdFxcdH1cXG5cXHQjZWxzZVxcblxcdFxcdHRyYW5zZm9ybWVkICs9IG1vcnBoVGFyZ2V0MCAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMCBdO1xcblxcdFxcdHRyYW5zZm9ybWVkICs9IG1vcnBoVGFyZ2V0MSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMSBdO1xcblxcdFxcdHRyYW5zZm9ybWVkICs9IG1vcnBoVGFyZ2V0MiAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMiBdO1xcblxcdFxcdHRyYW5zZm9ybWVkICs9IG1vcnBoVGFyZ2V0MyAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMyBdO1xcblxcdFxcdCNpZm5kZWYgVVNFX01PUlBITk9STUFMU1xcblxcdFxcdFxcdHRyYW5zZm9ybWVkICs9IG1vcnBoVGFyZ2V0NCAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNCBdO1xcblxcdFxcdFxcdHRyYW5zZm9ybWVkICs9IG1vcnBoVGFyZ2V0NSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNSBdO1xcblxcdFxcdFxcdHRyYW5zZm9ybWVkICs9IG1vcnBoVGFyZ2V0NiAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNiBdO1xcblxcdFxcdFxcdHRyYW5zZm9ybWVkICs9IG1vcnBoVGFyZ2V0NyAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNyBdO1xcblxcdFxcdCNlbmRpZlxcblxcdCNlbmRpZlxcbiNlbmRpZlwiO1xuXG52YXIgbm9ybWFsX2ZyYWdtZW50X2JlZ2luID0gXCJmbG9hdCBmYWNlRGlyZWN0aW9uID0gZ2xfRnJvbnRGYWNpbmcgPyAxLjAgOiAtIDEuMDtcXG4jaWZkZWYgRkxBVF9TSEFERURcXG5cXHR2ZWMzIGZkeCA9IGRGZHgoIHZWaWV3UG9zaXRpb24gKTtcXG5cXHR2ZWMzIGZkeSA9IGRGZHkoIHZWaWV3UG9zaXRpb24gKTtcXG5cXHR2ZWMzIG5vcm1hbCA9IG5vcm1hbGl6ZSggY3Jvc3MoIGZkeCwgZmR5ICkgKTtcXG4jZWxzZVxcblxcdHZlYzMgbm9ybWFsID0gbm9ybWFsaXplKCB2Tm9ybWFsICk7XFxuXFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcdFxcdG5vcm1hbCA9IG5vcm1hbCAqIGZhY2VEaXJlY3Rpb247XFxuXFx0I2VuZGlmXFxuXFx0I2lmZGVmIFVTRV9UQU5HRU5UXFxuXFx0XFx0dmVjMyB0YW5nZW50ID0gbm9ybWFsaXplKCB2VGFuZ2VudCApO1xcblxcdFxcdHZlYzMgYml0YW5nZW50ID0gbm9ybWFsaXplKCB2Qml0YW5nZW50ICk7XFxuXFx0XFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcdFxcdFxcdHRhbmdlbnQgPSB0YW5nZW50ICogZmFjZURpcmVjdGlvbjtcXG5cXHRcXHRcXHRiaXRhbmdlbnQgPSBiaXRhbmdlbnQgKiBmYWNlRGlyZWN0aW9uO1xcblxcdFxcdCNlbmRpZlxcblxcdFxcdCNpZiBkZWZpbmVkKCBUQU5HRU5UU1BBQ0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX0NMRUFSQ09BVF9OT1JNQUxNQVAgKVxcblxcdFxcdFxcdG1hdDMgdlRCTiA9IG1hdDMoIHRhbmdlbnQsIGJpdGFuZ2VudCwgbm9ybWFsICk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0I2VuZGlmXFxuI2VuZGlmXFxudmVjMyBnZW9tZXRyeU5vcm1hbCA9IG5vcm1hbDtcIjtcblxudmFyIG5vcm1hbF9mcmFnbWVudF9tYXBzID0gXCIjaWZkZWYgT0JKRUNUU1BBQ0VfTk9STUFMTUFQXFxuXFx0bm9ybWFsID0gdGV4dHVyZTJEKCBub3JtYWxNYXAsIHZVdiApLnh5eiAqIDIuMCAtIDEuMDtcXG5cXHQjaWZkZWYgRkxJUF9TSURFRFxcblxcdFxcdG5vcm1hbCA9IC0gbm9ybWFsO1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBET1VCTEVfU0lERURcXG5cXHRcXHRub3JtYWwgPSBub3JtYWwgKiBmYWNlRGlyZWN0aW9uO1xcblxcdCNlbmRpZlxcblxcdG5vcm1hbCA9IG5vcm1hbGl6ZSggbm9ybWFsTWF0cml4ICogbm9ybWFsICk7XFxuI2VsaWYgZGVmaW5lZCggVEFOR0VOVFNQQUNFX05PUk1BTE1BUCApXFxuXFx0dmVjMyBtYXBOID0gdGV4dHVyZTJEKCBub3JtYWxNYXAsIHZVdiApLnh5eiAqIDIuMCAtIDEuMDtcXG5cXHRtYXBOLnh5ICo9IG5vcm1hbFNjYWxlO1xcblxcdCNpZmRlZiBVU0VfVEFOR0VOVFxcblxcdFxcdG5vcm1hbCA9IG5vcm1hbGl6ZSggdlRCTiAqIG1hcE4gKTtcXG5cXHQjZWxzZVxcblxcdFxcdG5vcm1hbCA9IHBlcnR1cmJOb3JtYWwyQXJiKCAtIHZWaWV3UG9zaXRpb24sIG5vcm1hbCwgbWFwTiwgZmFjZURpcmVjdGlvbiApO1xcblxcdCNlbmRpZlxcbiNlbGlmIGRlZmluZWQoIFVTRV9CVU1QTUFQIClcXG5cXHRub3JtYWwgPSBwZXJ0dXJiTm9ybWFsQXJiKCAtIHZWaWV3UG9zaXRpb24sIG5vcm1hbCwgZEhkeHlfZndkKCksIGZhY2VEaXJlY3Rpb24gKTtcXG4jZW5kaWZcIjtcblxudmFyIG5vcm1hbF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZuZGVmIEZMQVRfU0hBREVEXFxuXFx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuXFx0I2lmZGVmIFVTRV9UQU5HRU5UXFxuXFx0XFx0dmFyeWluZyB2ZWMzIHZUYW5nZW50O1xcblxcdFxcdHZhcnlpbmcgdmVjMyB2Qml0YW5nZW50O1xcblxcdCNlbmRpZlxcbiNlbmRpZlwiO1xuXG52YXIgbm9ybWFsX3BhcnNfdmVydGV4ID0gXCIjaWZuZGVmIEZMQVRfU0hBREVEXFxuXFx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuXFx0I2lmZGVmIFVTRV9UQU5HRU5UXFxuXFx0XFx0dmFyeWluZyB2ZWMzIHZUYW5nZW50O1xcblxcdFxcdHZhcnlpbmcgdmVjMyB2Qml0YW5nZW50O1xcblxcdCNlbmRpZlxcbiNlbmRpZlwiO1xuXG52YXIgbm9ybWFsX3ZlcnRleCA9IFwiI2lmbmRlZiBGTEFUX1NIQURFRFxcblxcdHZOb3JtYWwgPSBub3JtYWxpemUoIHRyYW5zZm9ybWVkTm9ybWFsICk7XFxuXFx0I2lmZGVmIFVTRV9UQU5HRU5UXFxuXFx0XFx0dlRhbmdlbnQgPSBub3JtYWxpemUoIHRyYW5zZm9ybWVkVGFuZ2VudCApO1xcblxcdFxcdHZCaXRhbmdlbnQgPSBub3JtYWxpemUoIGNyb3NzKCB2Tm9ybWFsLCB2VGFuZ2VudCApICogdGFuZ2VudC53ICk7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG5cbnZhciBub3JtYWxtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9OT1JNQUxNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBub3JtYWxNYXA7XFxuXFx0dW5pZm9ybSB2ZWMyIG5vcm1hbFNjYWxlO1xcbiNlbmRpZlxcbiNpZmRlZiBPQkpFQ1RTUEFDRV9OT1JNQUxNQVBcXG5cXHR1bmlmb3JtIG1hdDMgbm9ybWFsTWF0cml4O1xcbiNlbmRpZlxcbiNpZiAhIGRlZmluZWQgKCBVU0VfVEFOR0VOVCApICYmICggZGVmaW5lZCAoIFRBTkdFTlRTUEFDRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkICggVVNFX0NMRUFSQ09BVF9OT1JNQUxNQVAgKSApXFxuXFx0dmVjMyBwZXJ0dXJiTm9ybWFsMkFyYiggdmVjMyBleWVfcG9zLCB2ZWMzIHN1cmZfbm9ybSwgdmVjMyBtYXBOLCBmbG9hdCBmYWNlRGlyZWN0aW9uICkge1xcblxcdFxcdHZlYzMgcTAgPSBkRmR4KCBleWVfcG9zLnh5eiApO1xcblxcdFxcdHZlYzMgcTEgPSBkRmR5KCBleWVfcG9zLnh5eiApO1xcblxcdFxcdHZlYzIgc3QwID0gZEZkeCggdlV2LnN0ICk7XFxuXFx0XFx0dmVjMiBzdDEgPSBkRmR5KCB2VXYuc3QgKTtcXG5cXHRcXHR2ZWMzIE4gPSBzdXJmX25vcm07XFxuXFx0XFx0dmVjMyBxMXBlcnAgPSBjcm9zcyggcTEsIE4gKTtcXG5cXHRcXHR2ZWMzIHEwcGVycCA9IGNyb3NzKCBOLCBxMCApO1xcblxcdFxcdHZlYzMgVCA9IHExcGVycCAqIHN0MC54ICsgcTBwZXJwICogc3QxLng7XFxuXFx0XFx0dmVjMyBCID0gcTFwZXJwICogc3QwLnkgKyBxMHBlcnAgKiBzdDEueTtcXG5cXHRcXHRmbG9hdCBkZXQgPSBtYXgoIGRvdCggVCwgVCApLCBkb3QoIEIsIEIgKSApO1xcblxcdFxcdGZsb2F0IHNjYWxlID0gKCBkZXQgPT0gMC4wICkgPyAwLjAgOiBmYWNlRGlyZWN0aW9uICogaW52ZXJzZXNxcnQoIGRldCApO1xcblxcdFxcdHJldHVybiBub3JtYWxpemUoIFQgKiAoIG1hcE4ueCAqIHNjYWxlICkgKyBCICogKCBtYXBOLnkgKiBzY2FsZSApICsgTiAqIG1hcE4ueiApO1xcblxcdH1cXG4jZW5kaWZcIjtcblxudmFyIGNsZWFyY29hdF9ub3JtYWxfZnJhZ21lbnRfYmVnaW4gPSBcIiNpZmRlZiBVU0VfQ0xFQVJDT0FUXFxuXFx0dmVjMyBjbGVhcmNvYXROb3JtYWwgPSBnZW9tZXRyeU5vcm1hbDtcXG4jZW5kaWZcIjtcblxudmFyIGNsZWFyY29hdF9ub3JtYWxfZnJhZ21lbnRfbWFwcyA9IFwiI2lmZGVmIFVTRV9DTEVBUkNPQVRfTk9STUFMTUFQXFxuXFx0dmVjMyBjbGVhcmNvYXRNYXBOID0gdGV4dHVyZTJEKCBjbGVhcmNvYXROb3JtYWxNYXAsIHZVdiApLnh5eiAqIDIuMCAtIDEuMDtcXG5cXHRjbGVhcmNvYXRNYXBOLnh5ICo9IGNsZWFyY29hdE5vcm1hbFNjYWxlO1xcblxcdCNpZmRlZiBVU0VfVEFOR0VOVFxcblxcdFxcdGNsZWFyY29hdE5vcm1hbCA9IG5vcm1hbGl6ZSggdlRCTiAqIGNsZWFyY29hdE1hcE4gKTtcXG5cXHQjZWxzZVxcblxcdFxcdGNsZWFyY29hdE5vcm1hbCA9IHBlcnR1cmJOb3JtYWwyQXJiKCAtIHZWaWV3UG9zaXRpb24sIGNsZWFyY29hdE5vcm1hbCwgY2xlYXJjb2F0TWFwTiwgZmFjZURpcmVjdGlvbiApO1xcblxcdCNlbmRpZlxcbiNlbmRpZlwiO1xuXG52YXIgY2xlYXJjb2F0X3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfQ0xFQVJDT0FUTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgY2xlYXJjb2F0TWFwO1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfQ0xFQVJDT0FUX1JPVUdITkVTU01BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGNsZWFyY29hdFJvdWdobmVzc01hcDtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0NMRUFSQ09BVF9OT1JNQUxNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBjbGVhcmNvYXROb3JtYWxNYXA7XFxuXFx0dW5pZm9ybSB2ZWMyIGNsZWFyY29hdE5vcm1hbFNjYWxlO1xcbiNlbmRpZlwiO1xuXG52YXIgaXJpZGVzY2VuY2VfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9JUklERVNDRU5DRU1BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGlyaWRlc2NlbmNlTWFwO1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VfVEhJQ0tORVNTTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgaXJpZGVzY2VuY2VUaGlja25lc3NNYXA7XFxuI2VuZGlmXCI7XG5cbnZhciBvdXRwdXRfZnJhZ21lbnQgPSBcIiNpZmRlZiBPUEFRVUVcXG5kaWZmdXNlQ29sb3IuYSA9IDEuMDtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX1RSQU5TTUlTU0lPTlxcbmRpZmZ1c2VDb2xvci5hICo9IG1hdGVyaWFsLnRyYW5zbWlzc2lvbkFscGhhICsgMC4xO1xcbiNlbmRpZlxcbmdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XCI7XG5cbnZhciBwYWNraW5nID0gXCJ2ZWMzIHBhY2tOb3JtYWxUb1JHQiggY29uc3QgaW4gdmVjMyBub3JtYWwgKSB7XFxuXFx0cmV0dXJuIG5vcm1hbGl6ZSggbm9ybWFsICkgKiAwLjUgKyAwLjU7XFxufVxcbnZlYzMgdW5wYWNrUkdCVG9Ob3JtYWwoIGNvbnN0IGluIHZlYzMgcmdiICkge1xcblxcdHJldHVybiAyLjAgKiByZ2IueHl6IC0gMS4wO1xcbn1cXG5jb25zdCBmbG9hdCBQYWNrVXBzY2FsZSA9IDI1Ni4gLyAyNTUuO2NvbnN0IGZsb2F0IFVucGFja0Rvd25zY2FsZSA9IDI1NS4gLyAyNTYuO1xcbmNvbnN0IHZlYzMgUGFja0ZhY3RvcnMgPSB2ZWMzKCAyNTYuICogMjU2LiAqIDI1Ni4sIDI1Ni4gKiAyNTYuLCAyNTYuICk7XFxuY29uc3QgdmVjNCBVbnBhY2tGYWN0b3JzID0gVW5wYWNrRG93bnNjYWxlIC8gdmVjNCggUGFja0ZhY3RvcnMsIDEuICk7XFxuY29uc3QgZmxvYXQgU2hpZnRSaWdodDggPSAxLiAvIDI1Ni47XFxudmVjNCBwYWNrRGVwdGhUb1JHQkEoIGNvbnN0IGluIGZsb2F0IHYgKSB7XFxuXFx0dmVjNCByID0gdmVjNCggZnJhY3QoIHYgKiBQYWNrRmFjdG9ycyApLCB2ICk7XFxuXFx0ci55encgLT0gci54eXogKiBTaGlmdFJpZ2h0ODtcXHRyZXR1cm4gciAqIFBhY2tVcHNjYWxlO1xcbn1cXG5mbG9hdCB1bnBhY2tSR0JBVG9EZXB0aCggY29uc3QgaW4gdmVjNCB2ICkge1xcblxcdHJldHVybiBkb3QoIHYsIFVucGFja0ZhY3RvcnMgKTtcXG59XFxudmVjMiBwYWNrRGVwdGhUb1JHKCBpbiBoaWdocCBmbG9hdCB2ICkge1xcblxcdHJldHVybiBwYWNrRGVwdGhUb1JHQkEoIHYgKS55eDtcXG59XFxuZmxvYXQgdW5wYWNrUkdUb0RlcHRoKCBjb25zdCBpbiBoaWdocCB2ZWMyIHYgKSB7XFxuXFx0cmV0dXJuIHVucGFja1JHQkFUb0RlcHRoKCB2ZWM0KCB2Lnh5LCAwLjAsIDAuMCApICk7XFxufVxcbnZlYzQgcGFjazJIYWxmVG9SR0JBKCB2ZWMyIHYgKSB7XFxuXFx0dmVjNCByID0gdmVjNCggdi54LCBmcmFjdCggdi54ICogMjU1LjAgKSwgdi55LCBmcmFjdCggdi55ICogMjU1LjAgKSApO1xcblxcdHJldHVybiB2ZWM0KCByLnggLSByLnkgLyAyNTUuMCwgci55LCByLnogLSByLncgLyAyNTUuMCwgci53ICk7XFxufVxcbnZlYzIgdW5wYWNrUkdCQVRvMkhhbGYoIHZlYzQgdiApIHtcXG5cXHRyZXR1cm4gdmVjMiggdi54ICsgKCB2LnkgLyAyNTUuMCApLCB2LnogKyAoIHYudyAvIDI1NS4wICkgKTtcXG59XFxuZmxvYXQgdmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKCBjb25zdCBpbiBmbG9hdCB2aWV3WiwgY29uc3QgaW4gZmxvYXQgbmVhciwgY29uc3QgaW4gZmxvYXQgZmFyICkge1xcblxcdHJldHVybiAoIHZpZXdaICsgbmVhciApIC8gKCBuZWFyIC0gZmFyICk7XFxufVxcbmZsb2F0IG9ydGhvZ3JhcGhpY0RlcHRoVG9WaWV3WiggY29uc3QgaW4gZmxvYXQgbGluZWFyQ2xpcFosIGNvbnN0IGluIGZsb2F0IG5lYXIsIGNvbnN0IGluIGZsb2F0IGZhciApIHtcXG5cXHRyZXR1cm4gbGluZWFyQ2xpcFogKiAoIG5lYXIgLSBmYXIgKSAtIG5lYXI7XFxufVxcbmZsb2F0IHZpZXdaVG9QZXJzcGVjdGl2ZURlcHRoKCBjb25zdCBpbiBmbG9hdCB2aWV3WiwgY29uc3QgaW4gZmxvYXQgbmVhciwgY29uc3QgaW4gZmxvYXQgZmFyICkge1xcblxcdHJldHVybiAoICggbmVhciArIHZpZXdaICkgKiBmYXIgKSAvICggKCBmYXIgLSBuZWFyICkgKiB2aWV3WiApO1xcbn1cXG5mbG9hdCBwZXJzcGVjdGl2ZURlcHRoVG9WaWV3WiggY29uc3QgaW4gZmxvYXQgaW52Q2xpcFosIGNvbnN0IGluIGZsb2F0IG5lYXIsIGNvbnN0IGluIGZsb2F0IGZhciApIHtcXG5cXHRyZXR1cm4gKCBuZWFyICogZmFyICkgLyAoICggZmFyIC0gbmVhciApICogaW52Q2xpcFogLSBmYXIgKTtcXG59XCI7XG5cbnZhciBwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50ID0gXCIjaWZkZWYgUFJFTVVMVElQTElFRF9BTFBIQVxcblxcdGdsX0ZyYWdDb2xvci5yZ2IgKj0gZ2xfRnJhZ0NvbG9yLmE7XFxuI2VuZGlmXCI7XG5cbnZhciBwcm9qZWN0X3ZlcnRleCA9IFwidmVjNCBtdlBvc2l0aW9uID0gdmVjNCggdHJhbnNmb3JtZWQsIDEuMCApO1xcbiNpZmRlZiBVU0VfSU5TVEFOQ0lOR1xcblxcdG12UG9zaXRpb24gPSBpbnN0YW5jZU1hdHJpeCAqIG12UG9zaXRpb247XFxuI2VuZGlmXFxubXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIG12UG9zaXRpb247XFxuZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtcIjtcblxudmFyIGRpdGhlcmluZ19mcmFnbWVudCA9IFwiI2lmZGVmIERJVEhFUklOR1xcblxcdGdsX0ZyYWdDb2xvci5yZ2IgPSBkaXRoZXJpbmcoIGdsX0ZyYWdDb2xvci5yZ2IgKTtcXG4jZW5kaWZcIjtcblxudmFyIGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgRElUSEVSSU5HXFxuXFx0dmVjMyBkaXRoZXJpbmcoIHZlYzMgY29sb3IgKSB7XFxuXFx0XFx0ZmxvYXQgZ3JpZF9wb3NpdGlvbiA9IHJhbmQoIGdsX0ZyYWdDb29yZC54eSApO1xcblxcdFxcdHZlYzMgZGl0aGVyX3NoaWZ0X1JHQiA9IHZlYzMoIDAuMjUgLyAyNTUuMCwgLTAuMjUgLyAyNTUuMCwgMC4yNSAvIDI1NS4wICk7XFxuXFx0XFx0ZGl0aGVyX3NoaWZ0X1JHQiA9IG1peCggMi4wICogZGl0aGVyX3NoaWZ0X1JHQiwgLTIuMCAqIGRpdGhlcl9zaGlmdF9SR0IsIGdyaWRfcG9zaXRpb24gKTtcXG5cXHRcXHRyZXR1cm4gY29sb3IgKyBkaXRoZXJfc2hpZnRfUkdCO1xcblxcdH1cXG4jZW5kaWZcIjtcblxudmFyIHJvdWdobmVzc21hcF9mcmFnbWVudCA9IFwiZmxvYXQgcm91Z2huZXNzRmFjdG9yID0gcm91Z2huZXNzO1xcbiNpZmRlZiBVU0VfUk9VR0hORVNTTUFQXFxuXFx0dmVjNCB0ZXhlbFJvdWdobmVzcyA9IHRleHR1cmUyRCggcm91Z2huZXNzTWFwLCB2VXYgKTtcXG5cXHRyb3VnaG5lc3NGYWN0b3IgKj0gdGV4ZWxSb3VnaG5lc3MuZztcXG4jZW5kaWZcIjtcblxudmFyIHJvdWdobmVzc21hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX1JPVUdITkVTU01BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIHJvdWdobmVzc01hcDtcXG4jZW5kaWZcIjtcblxudmFyIHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWYgTlVNX1NQT1RfTElHSFRfQ09PUkRTID4gMFxcblx0dmFyeWluZyB2ZWM0IHZTcG90TGlnaHRDb29yZFsgTlVNX1NQT1RfTElHSFRfQ09PUkRTIF07XFxuI2VuZGlmXFxuI2lmIE5VTV9TUE9UX0xJR0hUX01BUFMgPiAwXFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBzcG90TGlnaHRNYXBbIE5VTV9TUE9UX0xJR0hUX01BUFMgXTtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX1NIQURPV01BUFxcblxcdCNpZiBOVU1fRElSX0xJR0hUX1NIQURPV1MgPiAwXFxuXFx0XFx0dW5pZm9ybSBzYW1wbGVyMkQgZGlyZWN0aW9uYWxTaGFkb3dNYXBbIE5VTV9ESVJfTElHSFRfU0hBRE9XUyBdO1xcblxcdFxcdHZhcnlpbmcgdmVjNCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgTlVNX0RJUl9MSUdIVF9TSEFET1dTIF07XFxuXFx0XFx0c3RydWN0IERpcmVjdGlvbmFsTGlnaHRTaGFkb3cge1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd0JpYXM7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93Tm9ybWFsQmlhcztcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0XFx0dmVjMiBzaGFkb3dNYXBTaXplO1xcblxcdFxcdH07XFxuXFx0XFx0dW5pZm9ybSBEaXJlY3Rpb25hbExpZ2h0U2hhZG93IGRpcmVjdGlvbmFsTGlnaHRTaGFkb3dzWyBOVU1fRElSX0xJR0hUX1NIQURPV1MgXTtcXG5cXHQjZW5kaWZcXG5cXHQjaWYgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXIyRCBzcG90U2hhZG93TWFwWyBOVU1fU1BPVF9MSUdIVF9TSEFET1dTIF07XFxuXFx0XFx0c3RydWN0IFNwb3RMaWdodFNoYWRvdyB7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93QmlhcztcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dOb3JtYWxCaWFzO1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd1JhZGl1cztcXG5cXHRcXHRcXHR2ZWMyIHNoYWRvd01hcFNpemU7XFxuXFx0XFx0fTtcXG5cXHRcXHR1bmlmb3JtIFNwb3RMaWdodFNoYWRvdyBzcG90TGlnaHRTaGFkb3dzWyBOVU1fU1BPVF9MSUdIVF9TSEFET1dTIF07XFxuXFx0I2VuZGlmXFxuXFx0I2lmIE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTID4gMFxcblxcdFxcdHVuaWZvcm0gc2FtcGxlcjJEIHBvaW50U2hhZG93TWFwWyBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyBdO1xcblxcdFxcdHZhcnlpbmcgdmVjNCB2UG9pbnRTaGFkb3dDb29yZFsgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgXTtcXG5cXHRcXHRzdHJ1Y3QgUG9pbnRMaWdodFNoYWRvdyB7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93QmlhcztcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dOb3JtYWxCaWFzO1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd1JhZGl1cztcXG5cXHRcXHRcXHR2ZWMyIHNoYWRvd01hcFNpemU7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93Q2FtZXJhTmVhcjtcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dDYW1lcmFGYXI7XFxuXFx0XFx0fTtcXG5cXHRcXHR1bmlmb3JtIFBvaW50TGlnaHRTaGFkb3cgcG9pbnRMaWdodFNoYWRvd3NbIE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTIF07XFxuXFx0I2VuZGlmXFxuXFx0ZmxvYXQgdGV4dHVyZTJEQ29tcGFyZSggc2FtcGxlcjJEIGRlcHRocywgdmVjMiB1diwgZmxvYXQgY29tcGFyZSApIHtcXG5cXHRcXHRyZXR1cm4gc3RlcCggY29tcGFyZSwgdW5wYWNrUkdCQVRvRGVwdGgoIHRleHR1cmUyRCggZGVwdGhzLCB1diApICkgKTtcXG5cXHR9XFxuXFx0dmVjMiB0ZXh0dXJlMkREaXN0cmlidXRpb24oIHNhbXBsZXIyRCBzaGFkb3csIHZlYzIgdXYgKSB7XFxuXFx0XFx0cmV0dXJuIHVucGFja1JHQkFUbzJIYWxmKCB0ZXh0dXJlMkQoIHNoYWRvdywgdXYgKSApO1xcblxcdH1cXG5cXHRmbG9hdCBWU01TaGFkb3cgKHNhbXBsZXIyRCBzaGFkb3csIHZlYzIgdXYsIGZsb2F0IGNvbXBhcmUgKXtcXG5cXHRcXHRmbG9hdCBvY2NsdXNpb24gPSAxLjA7XFxuXFx0XFx0dmVjMiBkaXN0cmlidXRpb24gPSB0ZXh0dXJlMkREaXN0cmlidXRpb24oIHNoYWRvdywgdXYgKTtcXG5cXHRcXHRmbG9hdCBoYXJkX3NoYWRvdyA9IHN0ZXAoIGNvbXBhcmUgLCBkaXN0cmlidXRpb24ueCApO1xcblxcdFxcdGlmIChoYXJkX3NoYWRvdyAhPSAxLjAgKSB7XFxuXFx0XFx0XFx0ZmxvYXQgZGlzdGFuY2UgPSBjb21wYXJlIC0gZGlzdHJpYnV0aW9uLnggO1xcblxcdFxcdFxcdGZsb2F0IHZhcmlhbmNlID0gbWF4KCAwLjAwMDAwLCBkaXN0cmlidXRpb24ueSAqIGRpc3RyaWJ1dGlvbi55ICk7XFxuXFx0XFx0XFx0ZmxvYXQgc29mdG5lc3NfcHJvYmFiaWxpdHkgPSB2YXJpYW5jZSAvICh2YXJpYW5jZSArIGRpc3RhbmNlICogZGlzdGFuY2UgKTtcXHRcXHRcXHRzb2Z0bmVzc19wcm9iYWJpbGl0eSA9IGNsYW1wKCAoIHNvZnRuZXNzX3Byb2JhYmlsaXR5IC0gMC4zICkgLyAoIDAuOTUgLSAwLjMgKSwgMC4wLCAxLjAgKTtcXHRcXHRcXHRvY2NsdXNpb24gPSBjbGFtcCggbWF4KCBoYXJkX3NoYWRvdywgc29mdG5lc3NfcHJvYmFiaWxpdHkgKSwgMC4wLCAxLjAgKTtcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIG9jY2x1c2lvbjtcXG5cXHR9XFxuXFx0ZmxvYXQgZ2V0U2hhZG93KCBzYW1wbGVyMkQgc2hhZG93TWFwLCB2ZWMyIHNoYWRvd01hcFNpemUsIGZsb2F0IHNoYWRvd0JpYXMsIGZsb2F0IHNoYWRvd1JhZGl1cywgdmVjNCBzaGFkb3dDb29yZCApIHtcXG5cXHRcXHRmbG9hdCBzaGFkb3cgPSAxLjA7XFxuXFx0XFx0c2hhZG93Q29vcmQueHl6IC89IHNoYWRvd0Nvb3JkLnc7XFxuXFx0XFx0c2hhZG93Q29vcmQueiArPSBzaGFkb3dCaWFzO1xcblxcdFxcdGJ2ZWM0IGluRnJ1c3R1bVZlYyA9IGJ2ZWM0ICggc2hhZG93Q29vcmQueCA+PSAwLjAsIHNoYWRvd0Nvb3JkLnggPD0gMS4wLCBzaGFkb3dDb29yZC55ID49IDAuMCwgc2hhZG93Q29vcmQueSA8PSAxLjAgKTtcXG5cXHRcXHRib29sIGluRnJ1c3R1bSA9IGFsbCggaW5GcnVzdHVtVmVjICk7XFxuXFx0XFx0YnZlYzIgZnJ1c3R1bVRlc3RWZWMgPSBidmVjMiggaW5GcnVzdHVtLCBzaGFkb3dDb29yZC56IDw9IDEuMCApO1xcblxcdFxcdGJvb2wgZnJ1c3R1bVRlc3QgPSBhbGwoIGZydXN0dW1UZXN0VmVjICk7XFxuXFx0XFx0aWYgKCBmcnVzdHVtVGVzdCApIHtcXG5cXHRcXHQjaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGIClcXG5cXHRcXHRcXHR2ZWMyIHRleGVsU2l6ZSA9IHZlYzIoIDEuMCApIC8gc2hhZG93TWFwU2l6ZTtcXG5cXHRcXHRcXHRmbG9hdCBkeDAgPSAtIHRleGVsU2l6ZS54ICogc2hhZG93UmFkaXVzO1xcblxcdFxcdFxcdGZsb2F0IGR5MCA9IC0gdGV4ZWxTaXplLnkgKiBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0XFx0ZmxvYXQgZHgxID0gKyB0ZXhlbFNpemUueCAqIHNoYWRvd1JhZGl1cztcXG5cXHRcXHRcXHRmbG9hdCBkeTEgPSArIHRleGVsU2l6ZS55ICogc2hhZG93UmFkaXVzO1xcblxcdFxcdFxcdGZsb2F0IGR4MiA9IGR4MCAvIDIuMDtcXG5cXHRcXHRcXHRmbG9hdCBkeTIgPSBkeTAgLyAyLjA7XFxuXFx0XFx0XFx0ZmxvYXQgZHgzID0gZHgxIC8gMi4wO1xcblxcdFxcdFxcdGZsb2F0IGR5MyA9IGR5MSAvIDIuMDtcXG5cXHRcXHRcXHRzaGFkb3cgPSAoXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkwICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkwICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkwICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MiwgZHkyICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkyICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MywgZHkyICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgMC4wICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MiwgMC4wICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgzLCAwLjAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCAwLjAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgyLCBkeTMgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTMgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgzLCBkeTMgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTEgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTEgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTEgKSwgc2hhZG93Q29vcmQueiApXFxuXFx0XFx0XFx0KSAqICggMS4wIC8gMTcuMCApO1xcblxcdFxcdCNlbGlmIGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRl9TT0ZUIClcXG5cXHRcXHRcXHR2ZWMyIHRleGVsU2l6ZSA9IHZlYzIoIDEuMCApIC8gc2hhZG93TWFwU2l6ZTtcXG5cXHRcXHRcXHRmbG9hdCBkeCA9IHRleGVsU2l6ZS54O1xcblxcdFxcdFxcdGZsb2F0IGR5ID0gdGV4ZWxTaXplLnk7XFxuXFx0XFx0XFx0dmVjMiB1diA9IHNoYWRvd0Nvb3JkLnh5O1xcblxcdFxcdFxcdHZlYzIgZiA9IGZyYWN0KCB1diAqIHNoYWRvd01hcFNpemUgKyAwLjUgKTtcXG5cXHRcXHRcXHR1diAtPSBmICogdGV4ZWxTaXplO1xcblxcdFxcdFxcdHNoYWRvdyA9IChcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2LCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCBkeCwgMC4wICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIDAuMCwgZHkgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdGV4ZWxTaXplLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdG1peCggdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIC1keCwgMC4wICksIHNoYWRvd0Nvb3JkLnogKSxcXG5cXHRcXHRcXHRcXHRcXHQgdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIDIuMCAqIGR4LCAwLjAgKSwgc2hhZG93Q29vcmQueiApLFxcblxcdFxcdFxcdFxcdFxcdCBmLnggKSArXFxuXFx0XFx0XFx0XFx0bWl4KCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggLWR4LCBkeSApLCBzaGFkb3dDb29yZC56ICksXFxuXFx0XFx0XFx0XFx0XFx0IHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCAyLjAgKiBkeCwgZHkgKSwgc2hhZG93Q29vcmQueiApLFxcblxcdFxcdFxcdFxcdFxcdCBmLnggKSArXFxuXFx0XFx0XFx0XFx0bWl4KCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggMC4wLCAtZHkgKSwgc2hhZG93Q29vcmQueiApLFxcblxcdFxcdFxcdFxcdFxcdCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggMC4wLCAyLjAgKiBkeSApLCBzaGFkb3dDb29yZC56ICksXFxuXFx0XFx0XFx0XFx0XFx0IGYueSApICtcXG5cXHRcXHRcXHRcXHRtaXgoIHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCBkeCwgLWR5ICksIHNoYWRvd0Nvb3JkLnogKSxcXG5cXHRcXHRcXHRcXHRcXHQgdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIGR4LCAyLjAgKiBkeSApLCBzaGFkb3dDb29yZC56ICksXFxuXFx0XFx0XFx0XFx0XFx0IGYueSApICtcXG5cXHRcXHRcXHRcXHRtaXgoIG1peCggdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIC1keCwgLWR5ICksIHNoYWRvd0Nvb3JkLnogKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCAyLjAgKiBkeCwgLWR5ICksIHNoYWRvd0Nvb3JkLnogKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcdGYueCApLFxcblxcdFxcdFxcdFxcdFxcdCBtaXgoIHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCAtZHgsIDIuMCAqIGR5ICksIHNoYWRvd0Nvb3JkLnogKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCAyLjAgKiBkeCwgMi4wICogZHkgKSwgc2hhZG93Q29vcmQueiApLFxcblxcdFxcdFxcdFxcdFxcdFxcdFx0Zi54ICksXFxuXFx0XFx0XFx0XFx0XFx0IGYueSApXFxuXFx0XFx0XFx0KSAqICggMS4wIC8gOS4wICk7XFxuXFx0XFx0I2VsaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfVlNNIClcXG5cXHRcXHRcXHRzaGFkb3cgPSBWU01TaGFkb3coIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHksIHNoYWRvd0Nvb3JkLnogKTtcXG5cXHRcXHQjZWxzZVxcblxcdFxcdFxcdHNoYWRvdyA9IHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHksIHNoYWRvd0Nvb3JkLnogKTtcXG5cXHRcXHQjZW5kaWZcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIHNoYWRvdztcXG5cXHR9XFxuXFx0dmVjMiBjdWJlVG9VViggdmVjMyB2LCBmbG9hdCB0ZXhlbFNpemVZICkge1xcblxcdFxcdHZlYzMgYWJzViA9IGFicyggdiApO1xcblxcdFxcdGZsb2F0IHNjYWxlVG9DdWJlID0gMS4wIC8gbWF4KCBhYnNWLngsIG1heCggYWJzVi55LCBhYnNWLnogKSApO1xcblxcdFxcdGFic1YgKj0gc2NhbGVUb0N1YmU7XFxuXFx0XFx0diAqPSBzY2FsZVRvQ3ViZSAqICggMS4wIC0gMi4wICogdGV4ZWxTaXplWSApO1xcblxcdFxcdHZlYzIgcGxhbmFyID0gdi54eTtcXG5cXHRcXHRmbG9hdCBhbG1vc3RBVGV4ZWwgPSAxLjUgKiB0ZXhlbFNpemVZO1xcblxcdFxcdGZsb2F0IGFsbW9zdE9uZSA9IDEuMCAtIGFsbW9zdEFUZXhlbDtcXG5cXHRcXHRpZiAoIGFic1YueiA+PSBhbG1vc3RPbmUgKSB7XFxuXFx0XFx0XFx0aWYgKCB2LnogPiAwLjAgKVxcblxcdFxcdFxcdFxcdHBsYW5hci54ID0gNC4wIC0gdi54O1xcblxcdFxcdH0gZWxzZSBpZiAoIGFic1YueCA+PSBhbG1vc3RPbmUgKSB7XFxuXFx0XFx0XFx0ZmxvYXQgc2lnblggPSBzaWduKCB2LnggKTtcXG5cXHRcXHRcXHRwbGFuYXIueCA9IHYueiAqIHNpZ25YICsgMi4wICogc2lnblg7XFxuXFx0XFx0fSBlbHNlIGlmICggYWJzVi55ID49IGFsbW9zdE9uZSApIHtcXG5cXHRcXHRcXHRmbG9hdCBzaWduWSA9IHNpZ24oIHYueSApO1xcblxcdFxcdFxcdHBsYW5hci54ID0gdi54ICsgMi4wICogc2lnblkgKyAyLjA7XFxuXFx0XFx0XFx0cGxhbmFyLnkgPSB2LnogKiBzaWduWSAtIDIuMDtcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIHZlYzIoIDAuMTI1LCAwLjI1ICkgKiBwbGFuYXIgKyB2ZWMyKCAwLjM3NSwgMC43NSApO1xcblxcdH1cXG5cXHRmbG9hdCBnZXRQb2ludFNoYWRvdyggc2FtcGxlcjJEIHNoYWRvd01hcCwgdmVjMiBzaGFkb3dNYXBTaXplLCBmbG9hdCBzaGFkb3dCaWFzLCBmbG9hdCBzaGFkb3dSYWRpdXMsIHZlYzQgc2hhZG93Q29vcmQsIGZsb2F0IHNoYWRvd0NhbWVyYU5lYXIsIGZsb2F0IHNoYWRvd0NhbWVyYUZhciApIHtcXG5cXHRcXHR2ZWMyIHRleGVsU2l6ZSA9IHZlYzIoIDEuMCApIC8gKCBzaGFkb3dNYXBTaXplICogdmVjMiggNC4wLCAyLjAgKSApO1xcblxcdFxcdHZlYzMgbGlnaHRUb1Bvc2l0aW9uID0gc2hhZG93Q29vcmQueHl6O1xcblxcdFxcdGZsb2F0IGRwID0gKCBsZW5ndGgoIGxpZ2h0VG9Qb3NpdGlvbiApIC0gc2hhZG93Q2FtZXJhTmVhciApIC8gKCBzaGFkb3dDYW1lcmFGYXIgLSBzaGFkb3dDYW1lcmFOZWFyICk7XFx0XFx0ZHAgKz0gc2hhZG93QmlhcztcXG5cXHRcXHR2ZWMzIGJkM0QgPSBub3JtYWxpemUoIGxpZ2h0VG9Qb3NpdGlvbiApO1xcblxcdFxcdCNpZiBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0YgKSB8fCBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0ZfU09GVCApIHx8IGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1ZTTSApXFxuXFx0XFx0XFx0dmVjMiBvZmZzZXQgPSB2ZWMyKCAtIDEsIDEgKSAqIHNoYWRvd1JhZGl1cyAqIHRleGVsU2l6ZS55O1xcblxcdFxcdFxcdHJldHVybiAoXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC54eXksIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueXl5LCB0ZXhlbFNpemUueSApLCBkcCApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnh5eCwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC55eXgsIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QsIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueHh5LCB0ZXhlbFNpemUueSApLCBkcCApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnl4eSwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC54eHgsIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueXh4LCB0ZXhlbFNpemUueSApLCBkcCApXFxuXFx0XFx0XFx0KSAqICggMS4wIC8gOS4wICk7XFxuXFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHRyZXR1cm4gdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCwgdGV4ZWxTaXplLnkgKSwgZHAgKTtcXG5cXHRcXHQjZW5kaWZcXG5cXHR9XFxuI2VuZGlmXCI7XG5cbnZhciBzaGFkb3dtYXBfcGFyc192ZXJ0ZXggPSBcIiNpZiBOVU1fU1BPVF9MSUdIVF9DT09SRFMgPiAwXFxuXHR1bmlmb3JtIG1hdDQgc3BvdExpZ2h0TWF0cml4WyBOVU1fU1BPVF9MSUdIVF9DT09SRFMgXTtcXG5cdHZhcnlpbmcgdmVjNCB2U3BvdExpZ2h0Q29vcmRbIE5VTV9TUE9UX0xJR0hUX0NPT1JEUyBdO1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFx0I2lmIE5VTV9ESVJfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHRcXHR1bmlmb3JtIG1hdDQgZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXhbIE5VTV9ESVJfTElHSFRfU0hBRE9XUyBdO1xcblxcdFxcdHZhcnlpbmcgdmVjNCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgTlVNX0RJUl9MSUdIVF9TSEFET1dTIF07XFxuXFx0XFx0c3RydWN0IERpcmVjdGlvbmFsTGlnaHRTaGFkb3cge1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd0JpYXM7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93Tm9ybWFsQmlhcztcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0XFx0dmVjMiBzaGFkb3dNYXBTaXplO1xcblxcdFxcdH07XFxuXFx0XFx0dW5pZm9ybSBEaXJlY3Rpb25hbExpZ2h0U2hhZG93IGRpcmVjdGlvbmFsTGlnaHRTaGFkb3dzWyBOVU1fRElSX0xJR0hUX1NIQURPV1MgXTtcXG5cXHQjZW5kaWZcXG5cXHQjaWYgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHRcXHRzdHJ1Y3QgU3BvdExpZ2h0U2hhZG93IHtcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dCaWFzO1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd05vcm1hbEJpYXM7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93UmFkaXVzO1xcblxcdFxcdFxcdHZlYzIgc2hhZG93TWFwU2l6ZTtcXG5cXHRcXHR9O1xcblxcdFxcdHVuaWZvcm0gU3BvdExpZ2h0U2hhZG93IHNwb3RMaWdodFNoYWRvd3NbIE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgXTtcXG5cXHQjZW5kaWZcXG5cXHQjaWYgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgPiAwXFxuXFx0XFx0dW5pZm9ybSBtYXQ0IHBvaW50U2hhZG93TWF0cml4WyBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyBdO1xcblxcdFxcdHZhcnlpbmcgdmVjNCB2UG9pbnRTaGFkb3dDb29yZFsgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgXTtcXG5cXHRcXHRzdHJ1Y3QgUG9pbnRMaWdodFNoYWRvdyB7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93QmlhcztcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dOb3JtYWxCaWFzO1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd1JhZGl1cztcXG5cXHRcXHRcXHR2ZWMyIHNoYWRvd01hcFNpemU7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93Q2FtZXJhTmVhcjtcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dDYW1lcmFGYXI7XFxuXFx0XFx0fTtcXG5cXHRcXHR1bmlmb3JtIFBvaW50TGlnaHRTaGFkb3cgcG9pbnRMaWdodFNoYWRvd3NbIE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTIF07XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG5cbnZhciBzaGFkb3dtYXBfdmVydGV4ID0gXCIjaWYgZGVmaW5lZCggVVNFX1NIQURPV01BUCApIHx8ICggTlVNX1NQT1RfTElHSFRfQ09PUkRTID4gMCApXFxuXFx0I2lmIE5VTV9ESVJfTElHSFRfU0hBRE9XUyA+IDAgfHwgTlVNX1NQT1RfTElHSFRfQ09PUkRTID4gMCB8fCBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHRcXHR2ZWMzIHNoYWRvd1dvcmxkTm9ybWFsID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggdHJhbnNmb3JtZWROb3JtYWwsIHZpZXdNYXRyaXggKTtcXG5cXHRcXHR2ZWM0IHNoYWRvd1dvcmxkUG9zaXRpb247XFxuXFx0I2VuZGlmXFxuXFx0I2lmIE5VTV9ESVJfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0RJUl9MSUdIVF9TSEFET1dTOyBpICsrICkge1xcblxcdFxcdHNoYWRvd1dvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uICsgdmVjNCggc2hhZG93V29ybGROb3JtYWwgKiBkaXJlY3Rpb25hbExpZ2h0U2hhZG93c1sgaSBdLnNoYWRvd05vcm1hbEJpYXMsIDAgKTtcXG5cXHRcXHR2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgaSBdID0gZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXhbIGkgXSAqIHNoYWRvd1dvcmxkUG9zaXRpb247XFxuXFx0fVxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXFxuXFx0I2VuZGlmXFxuXFx0I2lmIE5VTV9TUE9UX0xJR0hUX0NPT1JEUyA+IDBcXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1NQT1RfTElHSFRfQ09PUkRTOyBpICsrICkge1xcblxcdFxcdHNoYWRvd1dvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uO1xcblxcdFxcdCNpZiAoIGRlZmluZWQoIFVTRV9TSEFET1dNQVAgKSAmJiBVTlJPTExFRF9MT09QX0lOREVYIDwgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyApXFxuXFx0XFx0XFx0c2hhZG93V29ybGRQb3NpdGlvbi54eXogKz0gc2hhZG93V29ybGROb3JtYWwgKiBzcG90TGlnaHRTaGFkb3dzWyBpIF0uc2hhZG93Tm9ybWFsQmlhcztcXG5cXHRcXHQjZW5kaWZcXG5cXHRcXHR2U3BvdExpZ2h0Q29vcmRbIGkgXSA9IHNwb3RMaWdodE1hdHJpeFsgaSBdICogc2hhZG93V29ybGRQb3NpdGlvbjtcXG5cXHR9XFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcXG5cXHQjZW5kaWZcXG5cXHQjaWYgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgPiAwXFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTOyBpICsrICkge1xcblxcdFxcdHNoYWRvd1dvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uICsgdmVjNCggc2hhZG93V29ybGROb3JtYWwgKiBwb2ludExpZ2h0U2hhZG93c1sgaSBdLnNoYWRvd05vcm1hbEJpYXMsIDAgKTtcXG5cXHRcXHR2UG9pbnRTaGFkb3dDb29yZFsgaSBdID0gcG9pbnRTaGFkb3dNYXRyaXhbIGkgXSAqIHNoYWRvd1dvcmxkUG9zaXRpb247XFxuXFx0fVxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG5cbnZhciBzaGFkb3dtYXNrX3BhcnNfZnJhZ21lbnQgPSBcImZsb2F0IGdldFNoYWRvd01hc2soKSB7XFxuXFx0ZmxvYXQgc2hhZG93ID0gMS4wO1xcblxcdCNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFx0I2lmIE5VTV9ESVJfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHREaXJlY3Rpb25hbExpZ2h0U2hhZG93IGRpcmVjdGlvbmFsTGlnaHQ7XFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9ESVJfTElHSFRfU0hBRE9XUzsgaSArKyApIHtcXG5cXHRcXHRkaXJlY3Rpb25hbExpZ2h0ID0gZGlyZWN0aW9uYWxMaWdodFNoYWRvd3NbIGkgXTtcXG5cXHRcXHRzaGFkb3cgKj0gcmVjZWl2ZVNoYWRvdyA/IGdldFNoYWRvdyggZGlyZWN0aW9uYWxTaGFkb3dNYXBbIGkgXSwgZGlyZWN0aW9uYWxMaWdodC5zaGFkb3dNYXBTaXplLCBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvd0JpYXMsIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93UmFkaXVzLCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgaSBdICkgOiAxLjA7XFxuXFx0fVxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXFxuXFx0I2VuZGlmXFxuXFx0I2lmIE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgPiAwXFxuXFx0U3BvdExpZ2h0U2hhZG93IHNwb3RMaWdodDtcXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1NQT1RfTElHSFRfU0hBRE9XUzsgaSArKyApIHtcXG5cXHRcXHRzcG90TGlnaHQgPSBzcG90TGlnaHRTaGFkb3dzWyBpIF07XFxuXFx0XFx0c2hhZG93ICo9IHJlY2VpdmVTaGFkb3cgPyBnZXRTaGFkb3coIHNwb3RTaGFkb3dNYXBbIGkgXSwgc3BvdExpZ2h0LnNoYWRvd01hcFNpemUsIHNwb3RMaWdodC5zaGFkb3dCaWFzLCBzcG90TGlnaHQuc2hhZG93UmFkaXVzLCB2U3BvdExpZ2h0Q29vcmRbIGkgXSApIDogMS4wO1xcblxcdH1cXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxcblxcdCNlbmRpZlxcblxcdCNpZiBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHRQb2ludExpZ2h0U2hhZG93IHBvaW50TGlnaHQ7XFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTOyBpICsrICkge1xcblxcdFxcdHBvaW50TGlnaHQgPSBwb2ludExpZ2h0U2hhZG93c1sgaSBdO1xcblxcdFxcdHNoYWRvdyAqPSByZWNlaXZlU2hhZG93ID8gZ2V0UG9pbnRTaGFkb3coIHBvaW50U2hhZG93TWFwWyBpIF0sIHBvaW50TGlnaHQuc2hhZG93TWFwU2l6ZSwgcG9pbnRMaWdodC5zaGFkb3dCaWFzLCBwb2ludExpZ2h0LnNoYWRvd1JhZGl1cywgdlBvaW50U2hhZG93Q29vcmRbIGkgXSwgcG9pbnRMaWdodC5zaGFkb3dDYW1lcmFOZWFyLCBwb2ludExpZ2h0LnNoYWRvd0NhbWVyYUZhciApIDogMS4wO1xcblxcdH1cXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxcblxcdCNlbmRpZlxcblxcdCNlbmRpZlxcblxcdHJldHVybiBzaGFkb3c7XFxufVwiO1xuXG52YXIgc2tpbmJhc2VfdmVydGV4ID0gXCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFx0bWF0NCBib25lTWF0WCA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC54ICk7XFxuXFx0bWF0NCBib25lTWF0WSA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC55ICk7XFxuXFx0bWF0NCBib25lTWF0WiA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC56ICk7XFxuXFx0bWF0NCBib25lTWF0VyA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC53ICk7XFxuI2VuZGlmXCI7XG5cbnZhciBza2lubmluZ19wYXJzX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcdHVuaWZvcm0gbWF0NCBiaW5kTWF0cml4O1xcblxcdHVuaWZvcm0gbWF0NCBiaW5kTWF0cml4SW52ZXJzZTtcXG5cXHR1bmlmb3JtIGhpZ2hwIHNhbXBsZXIyRCBib25lVGV4dHVyZTtcXG5cXHR1bmlmb3JtIGludCBib25lVGV4dHVyZVNpemU7XFxuXFx0bWF0NCBnZXRCb25lTWF0cml4KCBjb25zdCBpbiBmbG9hdCBpICkge1xcblxcdFxcdGZsb2F0IGogPSBpICogNC4wO1xcblxcdFxcdGZsb2F0IHggPSBtb2QoIGosIGZsb2F0KCBib25lVGV4dHVyZVNpemUgKSApO1xcblxcdFxcdGZsb2F0IHkgPSBmbG9vciggaiAvIGZsb2F0KCBib25lVGV4dHVyZVNpemUgKSApO1xcblxcdFxcdGZsb2F0IGR4ID0gMS4wIC8gZmxvYXQoIGJvbmVUZXh0dXJlU2l6ZSApO1xcblxcdFxcdGZsb2F0IGR5ID0gMS4wIC8gZmxvYXQoIGJvbmVUZXh0dXJlU2l6ZSApO1xcblxcdFxcdHkgPSBkeSAqICggeSArIDAuNSApO1xcblxcdFxcdHZlYzQgdjEgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDAuNSApLCB5ICkgKTtcXG5cXHRcXHR2ZWM0IHYyID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAxLjUgKSwgeSApICk7XFxuXFx0XFx0dmVjNCB2MyA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMi41ICksIHkgKSApO1xcblxcdFxcdHZlYzQgdjQgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDMuNSApLCB5ICkgKTtcXG5cXHRcXHRtYXQ0IGJvbmUgPSBtYXQ0KCB2MSwgdjIsIHYzLCB2NCApO1xcblxcdFxcdHJldHVybiBib25lO1xcblxcdH1cXG4jZW5kaWZcIjtcblxudmFyIHNraW5uaW5nX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcdHZlYzQgc2tpblZlcnRleCA9IGJpbmRNYXRyaXggKiB2ZWM0KCB0cmFuc2Zvcm1lZCwgMS4wICk7XFxuXFx0dmVjNCBza2lubmVkID0gdmVjNCggMC4wICk7XFxuXFx0c2tpbm5lZCArPSBib25lTWF0WCAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lng7XFxuXFx0c2tpbm5lZCArPSBib25lTWF0WSAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lnk7XFxuXFx0c2tpbm5lZCArPSBib25lTWF0WiAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lno7XFxuXFx0c2tpbm5lZCArPSBib25lTWF0VyAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lnc7XFxuXFx0dHJhbnNmb3JtZWQgPSAoIGJpbmRNYXRyaXhJbnZlcnNlICogc2tpbm5lZCApLnh5ejtcXG4jZW5kaWZcIjtcblxudmFyIHNraW5ub3JtYWxfdmVydGV4ID0gXCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFx0bWF0NCBza2luTWF0cml4ID0gbWF0NCggMC4wICk7XFxuXFx0c2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LnggKiBib25lTWF0WDtcXG5cXHRza2luTWF0cml4ICs9IHNraW5XZWlnaHQueSAqIGJvbmVNYXRZO1xcblxcdHNraW5NYXRyaXggKz0gc2tpbldlaWdodC56ICogYm9uZU1hdFo7XFxuXFx0c2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LncgKiBib25lTWF0VztcXG5cXHRza2luTWF0cml4ID0gYmluZE1hdHJpeEludmVyc2UgKiBza2luTWF0cml4ICogYmluZE1hdHJpeDtcXG5cXHRvYmplY3ROb3JtYWwgPSB2ZWM0KCBza2luTWF0cml4ICogdmVjNCggb2JqZWN0Tm9ybWFsLCAwLjAgKSApLnh5ejtcXG5cXHQjaWZkZWYgVVNFX1RBTkdFTlRcXG5cXHRcXHRvYmplY3RUYW5nZW50ID0gdmVjNCggc2tpbk1hdHJpeCAqIHZlYzQoIG9iamVjdFRhbmdlbnQsIDAuMCApICkueHl6O1xcblxcdCNlbmRpZlxcbiNlbmRpZlwiO1xuXG52YXIgc3BlY3VsYXJtYXBfZnJhZ21lbnQgPSBcImZsb2F0IHNwZWN1bGFyU3RyZW5ndGg7XFxuI2lmZGVmIFVTRV9TUEVDVUxBUk1BUFxcblxcdHZlYzQgdGV4ZWxTcGVjdWxhciA9IHRleHR1cmUyRCggc3BlY3VsYXJNYXAsIHZVdiApO1xcblxcdHNwZWN1bGFyU3RyZW5ndGggPSB0ZXhlbFNwZWN1bGFyLnI7XFxuI2Vsc2VcXG5cXHRzcGVjdWxhclN0cmVuZ3RoID0gMS4wO1xcbiNlbmRpZlwiO1xuXG52YXIgc3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9TUEVDVUxBUk1BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIHNwZWN1bGFyTWFwO1xcbiNlbmRpZlwiO1xuXG52YXIgdG9uZW1hcHBpbmdfZnJhZ21lbnQgPSBcIiNpZiBkZWZpbmVkKCBUT05FX01BUFBJTkcgKVxcblxcdGdsX0ZyYWdDb2xvci5yZ2IgPSB0b25lTWFwcGluZyggZ2xfRnJhZ0NvbG9yLnJnYiApO1xcbiNlbmRpZlwiO1xuXG52YXIgdG9uZW1hcHBpbmdfcGFyc19mcmFnbWVudCA9IFwiI2lmbmRlZiBzYXR1cmF0ZVxcbiNkZWZpbmUgc2F0dXJhdGUoIGEgKSBjbGFtcCggYSwgMC4wLCAxLjAgKVxcbiNlbmRpZlxcbnVuaWZvcm0gZmxvYXQgdG9uZU1hcHBpbmdFeHBvc3VyZTtcXG52ZWMzIExpbmVhclRvbmVNYXBwaW5nKCB2ZWMzIGNvbG9yICkge1xcblxcdHJldHVybiB0b25lTWFwcGluZ0V4cG9zdXJlICogY29sb3I7XFxufVxcbnZlYzMgUmVpbmhhcmRUb25lTWFwcGluZyggdmVjMyBjb2xvciApIHtcXG5cXHRjb2xvciAqPSB0b25lTWFwcGluZ0V4cG9zdXJlO1xcblxcdHJldHVybiBzYXR1cmF0ZSggY29sb3IgLyAoIHZlYzMoIDEuMCApICsgY29sb3IgKSApO1xcbn1cXG52ZWMzIE9wdGltaXplZENpbmVvblRvbmVNYXBwaW5nKCB2ZWMzIGNvbG9yICkge1xcblxcdGNvbG9yICo9IHRvbmVNYXBwaW5nRXhwb3N1cmU7XFxuXFx0Y29sb3IgPSBtYXgoIHZlYzMoIDAuMCApLCBjb2xvciAtIDAuMDA0ICk7XFxuXFx0cmV0dXJuIHBvdyggKCBjb2xvciAqICggNi4yICogY29sb3IgKyAwLjUgKSApIC8gKCBjb2xvciAqICggNi4yICogY29sb3IgKyAxLjcgKSArIDAuMDYgKSwgdmVjMyggMi4yICkgKTtcXG59XFxudmVjMyBSUlRBbmRPRFRGaXQoIHZlYzMgdiApIHtcXG5cXHR2ZWMzIGEgPSB2ICogKCB2ICsgMC4wMjQ1Nzg2ICkgLSAwLjAwMDA5MDUzNztcXG5cXHR2ZWMzIGIgPSB2ICogKCAwLjk4MzcyOSAqIHYgKyAwLjQzMjk1MTAgKSArIDAuMjM4MDgxO1xcblxcdHJldHVybiBhIC8gYjtcXG59XFxudmVjMyBBQ0VTRmlsbWljVG9uZU1hcHBpbmcoIHZlYzMgY29sb3IgKSB7XFxuXFx0Y29uc3QgbWF0MyBBQ0VTSW5wdXRNYXQgPSBtYXQzKFxcblxcdFxcdHZlYzMoIDAuNTk3MTksIDAuMDc2MDAsIDAuMDI4NDAgKSxcXHRcXHR2ZWMzKCAwLjM1NDU4LCAwLjkwODM0LCAwLjEzMzgzICksXFxuXFx0XFx0dmVjMyggMC4wNDgyMywgMC4wMTU2NiwgMC44Mzc3NyApXFxuXFx0KTtcXG5cXHRjb25zdCBtYXQzIEFDRVNPdXRwdXRNYXQgPSBtYXQzKFxcblxcdFxcdHZlYzMoXHQxLjYwNDc1LCAtMC4xMDIwOCwgLTAuMDAzMjcgKSxcXHRcXHR2ZWMzKCAtMC41MzEwOCxcdDEuMTA4MTMsIC0wLjA3Mjc2ICksXFxuXFx0XFx0dmVjMyggLTAuMDczNjcsIC0wLjAwNjA1LFx0MS4wNzYwMiApXFxuXFx0KTtcXG5cXHRjb2xvciAqPSB0b25lTWFwcGluZ0V4cG9zdXJlIC8gMC42O1xcblxcdGNvbG9yID0gQUNFU0lucHV0TWF0ICogY29sb3I7XFxuXFx0Y29sb3IgPSBSUlRBbmRPRFRGaXQoIGNvbG9yICk7XFxuXFx0Y29sb3IgPSBBQ0VTT3V0cHV0TWF0ICogY29sb3I7XFxuXFx0cmV0dXJuIHNhdHVyYXRlKCBjb2xvciApO1xcbn1cXG52ZWMzIEN1c3RvbVRvbmVNYXBwaW5nKCB2ZWMzIGNvbG9yICkgeyByZXR1cm4gY29sb3I7IH1cIjtcblxudmFyIHRyYW5zbWlzc2lvbl9mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9UUkFOU01JU1NJT05cXG5cXHRtYXRlcmlhbC50cmFuc21pc3Npb24gPSB0cmFuc21pc3Npb247XFxuXFx0bWF0ZXJpYWwudHJhbnNtaXNzaW9uQWxwaGEgPSAxLjA7XFxuXFx0bWF0ZXJpYWwudGhpY2tuZXNzID0gdGhpY2tuZXNzO1xcblxcdG1hdGVyaWFsLmF0dGVudWF0aW9uRGlzdGFuY2UgPSBhdHRlbnVhdGlvbkRpc3RhbmNlO1xcblxcdG1hdGVyaWFsLmF0dGVudWF0aW9uQ29sb3IgPSBhdHRlbnVhdGlvbkNvbG9yO1xcblxcdCNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OTUFQXFxuXFx0XFx0bWF0ZXJpYWwudHJhbnNtaXNzaW9uICo9IHRleHR1cmUyRCggdHJhbnNtaXNzaW9uTWFwLCB2VXYgKS5yO1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBVU0VfVEhJQ0tORVNTTUFQXFxuXFx0XFx0bWF0ZXJpYWwudGhpY2tuZXNzICo9IHRleHR1cmUyRCggdGhpY2tuZXNzTWFwLCB2VXYgKS5nO1xcblxcdCNlbmRpZlxcblxcdHZlYzMgcG9zID0gdldvcmxkUG9zaXRpb247XFxuXFx0dmVjMyB2ID0gbm9ybWFsaXplKCBjYW1lcmFQb3NpdGlvbiAtIHBvcyApO1xcblxcdHZlYzMgbiA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIG5vcm1hbCwgdmlld01hdHJpeCApO1xcblxcdHZlYzQgdHJhbnNtaXNzaW9uID0gZ2V0SUJMVm9sdW1lUmVmcmFjdGlvbihcXG5cXHRcXHRuLCB2LCBtYXRlcmlhbC5yb3VnaG5lc3MsIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJGOTAsXFxuXFx0XFx0cG9zLCBtb2RlbE1hdHJpeCwgdmlld01hdHJpeCwgcHJvamVjdGlvbk1hdHJpeCwgbWF0ZXJpYWwuaW9yLCBtYXRlcmlhbC50aGlja25lc3MsXFxuXFx0XFx0bWF0ZXJpYWwuYXR0ZW51YXRpb25Db2xvciwgbWF0ZXJpYWwuYXR0ZW51YXRpb25EaXN0YW5jZSApO1xcblxcdG1hdGVyaWFsLnRyYW5zbWlzc2lvbkFscGhhID0gbWl4KCBtYXRlcmlhbC50cmFuc21pc3Npb25BbHBoYSwgdHJhbnNtaXNzaW9uLmEsIG1hdGVyaWFsLnRyYW5zbWlzc2lvbiApO1xcblxcdHRvdGFsRGlmZnVzZSA9IG1peCggdG90YWxEaWZmdXNlLCB0cmFuc21pc3Npb24ucmdiLCBtYXRlcmlhbC50cmFuc21pc3Npb24gKTtcXG4jZW5kaWZcIjtcblxudmFyIHRyYW5zbWlzc2lvbl9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX1RSQU5TTUlTU0lPTlxcblxcdHVuaWZvcm0gZmxvYXQgdHJhbnNtaXNzaW9uO1xcblxcdHVuaWZvcm0gZmxvYXQgdGhpY2tuZXNzO1xcblxcdHVuaWZvcm0gZmxvYXQgYXR0ZW51YXRpb25EaXN0YW5jZTtcXG5cXHR1bmlmb3JtIHZlYzMgYXR0ZW51YXRpb25Db2xvcjtcXG5cXHQjaWZkZWYgVVNFX1RSQU5TTUlTU0lPTk1BUFxcblxcdFxcdHVuaWZvcm0gc2FtcGxlcjJEIHRyYW5zbWlzc2lvbk1hcDtcXG5cXHQjZW5kaWZcXG5cXHQjaWZkZWYgVVNFX1RISUNLTkVTU01BUFxcblxcdFxcdHVuaWZvcm0gc2FtcGxlcjJEIHRoaWNrbmVzc01hcDtcXG5cXHQjZW5kaWZcXG5cXHR1bmlmb3JtIHZlYzIgdHJhbnNtaXNzaW9uU2FtcGxlclNpemU7XFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgdHJhbnNtaXNzaW9uU2FtcGxlck1hcDtcXG5cXHR1bmlmb3JtIG1hdDQgbW9kZWxNYXRyaXg7XFxuXFx0dW5pZm9ybSBtYXQ0IHByb2plY3Rpb25NYXRyaXg7XFxuXFx0dmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcblxcdHZlYzMgZ2V0Vm9sdW1lVHJhbnNtaXNzaW9uUmF5KCBjb25zdCBpbiB2ZWMzIG4sIGNvbnN0IGluIHZlYzMgdiwgY29uc3QgaW4gZmxvYXQgdGhpY2tuZXNzLCBjb25zdCBpbiBmbG9hdCBpb3IsIGNvbnN0IGluIG1hdDQgbW9kZWxNYXRyaXggKSB7XFxuXFx0XFx0dmVjMyByZWZyYWN0aW9uVmVjdG9yID0gcmVmcmFjdCggLSB2LCBub3JtYWxpemUoIG4gKSwgMS4wIC8gaW9yICk7XFxuXFx0XFx0dmVjMyBtb2RlbFNjYWxlO1xcblxcdFxcdG1vZGVsU2NhbGUueCA9IGxlbmd0aCggdmVjMyggbW9kZWxNYXRyaXhbIDAgXS54eXogKSApO1xcblxcdFxcdG1vZGVsU2NhbGUueSA9IGxlbmd0aCggdmVjMyggbW9kZWxNYXRyaXhbIDEgXS54eXogKSApO1xcblxcdFxcdG1vZGVsU2NhbGUueiA9IGxlbmd0aCggdmVjMyggbW9kZWxNYXRyaXhbIDIgXS54eXogKSApO1xcblxcdFxcdHJldHVybiBub3JtYWxpemUoIHJlZnJhY3Rpb25WZWN0b3IgKSAqIHRoaWNrbmVzcyAqIG1vZGVsU2NhbGU7XFxuXFx0fVxcblxcdGZsb2F0IGFwcGx5SW9yVG9Sb3VnaG5lc3MoIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcywgY29uc3QgaW4gZmxvYXQgaW9yICkge1xcblxcdFxcdHJldHVybiByb3VnaG5lc3MgKiBjbGFtcCggaW9yICogMi4wIC0gMi4wLCAwLjAsIDEuMCApO1xcblxcdH1cXG5cXHR2ZWM0IGdldFRyYW5zbWlzc2lvblNhbXBsZSggY29uc3QgaW4gdmVjMiBmcmFnQ29vcmQsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcywgY29uc3QgaW4gZmxvYXQgaW9yICkge1xcblxcdFxcdGZsb2F0IGZyYW1lYnVmZmVyTG9kID0gbG9nMiggdHJhbnNtaXNzaW9uU2FtcGxlclNpemUueCApICogYXBwbHlJb3JUb1JvdWdobmVzcyggcm91Z2huZXNzLCBpb3IgKTtcXG5cXHRcXHQjaWZkZWYgdGV4dHVyZTJETG9kRVhUXFxuXFx0XFx0XFx0cmV0dXJuIHRleHR1cmUyRExvZEVYVCggdHJhbnNtaXNzaW9uU2FtcGxlck1hcCwgZnJhZ0Nvb3JkLnh5LCBmcmFtZWJ1ZmZlckxvZCApO1xcblxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0cmV0dXJuIHRleHR1cmUyRCggdHJhbnNtaXNzaW9uU2FtcGxlck1hcCwgZnJhZ0Nvb3JkLnh5LCBmcmFtZWJ1ZmZlckxvZCApO1xcblxcdFxcdCNlbmRpZlxcblxcdH1cXG5cXHR2ZWMzIGFwcGx5Vm9sdW1lQXR0ZW51YXRpb24oIGNvbnN0IGluIHZlYzMgcmFkaWFuY2UsIGNvbnN0IGluIGZsb2F0IHRyYW5zbWlzc2lvbkRpc3RhbmNlLCBjb25zdCBpbiB2ZWMzIGF0dGVudWF0aW9uQ29sb3IsIGNvbnN0IGluIGZsb2F0IGF0dGVudWF0aW9uRGlzdGFuY2UgKSB7XFxuXFx0XFx0aWYgKCBpc2luZiggYXR0ZW51YXRpb25EaXN0YW5jZSApICkge1xcblxcdFxcdFxcdHJldHVybiByYWRpYW5jZTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdHZlYzMgYXR0ZW51YXRpb25Db2VmZmljaWVudCA9IC1sb2coIGF0dGVudWF0aW9uQ29sb3IgKSAvIGF0dGVudWF0aW9uRGlzdGFuY2U7XFxuXFx0XFx0XFx0dmVjMyB0cmFuc21pdHRhbmNlID0gZXhwKCAtIGF0dGVudWF0aW9uQ29lZmZpY2llbnQgKiB0cmFuc21pc3Npb25EaXN0YW5jZSApO1xcdFxcdFxcdHJldHVybiB0cmFuc21pdHRhbmNlICogcmFkaWFuY2U7XFxuXFx0XFx0fVxcblxcdH1cXG5cXHR2ZWM0IGdldElCTFZvbHVtZVJlZnJhY3Rpb24oIGNvbnN0IGluIHZlYzMgbiwgY29uc3QgaW4gdmVjMyB2LCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MsIGNvbnN0IGluIHZlYzMgZGlmZnVzZUNvbG9yLFxcblxcdFxcdGNvbnN0IGluIHZlYzMgc3BlY3VsYXJDb2xvciwgY29uc3QgaW4gZmxvYXQgc3BlY3VsYXJGOTAsIGNvbnN0IGluIHZlYzMgcG9zaXRpb24sIGNvbnN0IGluIG1hdDQgbW9kZWxNYXRyaXgsXFxuXFx0XFx0Y29uc3QgaW4gbWF0NCB2aWV3TWF0cml4LCBjb25zdCBpbiBtYXQ0IHByb2pNYXRyaXgsIGNvbnN0IGluIGZsb2F0IGlvciwgY29uc3QgaW4gZmxvYXQgdGhpY2tuZXNzLFxcblxcdFxcdGNvbnN0IGluIHZlYzMgYXR0ZW51YXRpb25Db2xvciwgY29uc3QgaW4gZmxvYXQgYXR0ZW51YXRpb25EaXN0YW5jZSApIHtcXG5cXHRcXHR2ZWMzIHRyYW5zbWlzc2lvblJheSA9IGdldFZvbHVtZVRyYW5zbWlzc2lvblJheSggbiwgdiwgdGhpY2tuZXNzLCBpb3IsIG1vZGVsTWF0cml4ICk7XFxuXFx0XFx0dmVjMyByZWZyYWN0ZWRSYXlFeGl0ID0gcG9zaXRpb24gKyB0cmFuc21pc3Npb25SYXk7XFxuXFx0XFx0dmVjNCBuZGNQb3MgPSBwcm9qTWF0cml4ICogdmlld01hdHJpeCAqIHZlYzQoIHJlZnJhY3RlZFJheUV4aXQsIDEuMCApO1xcblxcdFxcdHZlYzIgcmVmcmFjdGlvbkNvb3JkcyA9IG5kY1Bvcy54eSAvIG5kY1Bvcy53O1xcblxcdFxcdHJlZnJhY3Rpb25Db29yZHMgKz0gMS4wO1xcblxcdFxcdHJlZnJhY3Rpb25Db29yZHMgLz0gMi4wO1xcblxcdFxcdHZlYzQgdHJhbnNtaXR0ZWRMaWdodCA9IGdldFRyYW5zbWlzc2lvblNhbXBsZSggcmVmcmFjdGlvbkNvb3Jkcywgcm91Z2huZXNzLCBpb3IgKTtcXG5cXHRcXHR2ZWMzIGF0dGVudWF0ZWRDb2xvciA9IGFwcGx5Vm9sdW1lQXR0ZW51YXRpb24oIHRyYW5zbWl0dGVkTGlnaHQucmdiLCBsZW5ndGgoIHRyYW5zbWlzc2lvblJheSApLCBhdHRlbnVhdGlvbkNvbG9yLCBhdHRlbnVhdGlvbkRpc3RhbmNlICk7XFxuXFx0XFx0dmVjMyBGID0gRW52aXJvbm1lbnRCUkRGKCBuLCB2LCBzcGVjdWxhckNvbG9yLCBzcGVjdWxhckY5MCwgcm91Z2huZXNzICk7XFxuXFx0XFx0cmV0dXJuIHZlYzQoICggMS4wIC0gRiApICogYXR0ZW51YXRlZENvbG9yICogZGlmZnVzZUNvbG9yLCB0cmFuc21pdHRlZExpZ2h0LmEgKTtcXG5cXHR9XFxuI2VuZGlmXCI7XG5cbnZhciB1dl9wYXJzX2ZyYWdtZW50ID0gXCIjaWYgKCBkZWZpbmVkKCBVU0VfVVYgKSAmJiAhIGRlZmluZWQoIFVWU19WRVJURVhfT05MWSApIClcXG5cXHR2YXJ5aW5nIHZlYzIgdlV2O1xcbiNlbmRpZlwiO1xuXG52YXIgdXZfcGFyc192ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfVVZcXG5cXHQjaWZkZWYgVVZTX1ZFUlRFWF9PTkxZXFxuXFx0XFx0dmVjMiB2VXY7XFxuXFx0I2Vsc2VcXG5cXHRcXHR2YXJ5aW5nIHZlYzIgdlV2O1xcblxcdCNlbmRpZlxcblxcdHVuaWZvcm0gbWF0MyB1dlRyYW5zZm9ybTtcXG4jZW5kaWZcIjtcblxudmFyIHV2X3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9VVlxcblxcdHZVdiA9ICggdXZUcmFuc2Zvcm0gKiB2ZWMzKCB1diwgMSApICkueHk7XFxuI2VuZGlmXCI7XG5cbnZhciB1djJfcGFyc19mcmFnbWVudCA9IFwiI2lmIGRlZmluZWQoIFVTRV9MSUdIVE1BUCApIHx8IGRlZmluZWQoIFVTRV9BT01BUCApXFxuXFx0dmFyeWluZyB2ZWMyIHZVdjI7XFxuI2VuZGlmXCI7XG5cbnZhciB1djJfcGFyc192ZXJ0ZXggPSBcIiNpZiBkZWZpbmVkKCBVU0VfTElHSFRNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQU9NQVAgKVxcblxcdGF0dHJpYnV0ZSB2ZWMyIHV2MjtcXG5cXHR2YXJ5aW5nIHZlYzIgdlV2MjtcXG5cXHR1bmlmb3JtIG1hdDMgdXYyVHJhbnNmb3JtO1xcbiNlbmRpZlwiO1xuXG52YXIgdXYyX3ZlcnRleCA9IFwiI2lmIGRlZmluZWQoIFVTRV9MSUdIVE1BUCApIHx8IGRlZmluZWQoIFVTRV9BT01BUCApXFxuXFx0dlV2MiA9ICggdXYyVHJhbnNmb3JtICogdmVjMyggdXYyLCAxICkgKS54eTtcXG4jZW5kaWZcIjtcblxudmFyIHdvcmxkcG9zX3ZlcnRleCA9IFwiI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSB8fCBkZWZpbmVkKCBESVNUQU5DRSApIHx8IGRlZmluZWQgKCBVU0VfU0hBRE9XTUFQICkgfHwgZGVmaW5lZCAoIFVTRV9UUkFOU01JU1NJT04gKSB8fCBOVU1fU1BPVF9MSUdIVF9DT09SRFMgPiAwXFxuXFx0dmVjNCB3b3JsZFBvc2l0aW9uID0gdmVjNCggdHJhbnNmb3JtZWQsIDEuMCApO1xcblxcdCNpZmRlZiBVU0VfSU5TVEFOQ0lOR1xcblxcdFxcdHdvcmxkUG9zaXRpb24gPSBpbnN0YW5jZU1hdHJpeCAqIHdvcmxkUG9zaXRpb247XFxuXFx0I2VuZGlmXFxuXFx0d29ybGRQb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogd29ybGRQb3NpdGlvbjtcXG4jZW5kaWZcIjtcblxuY29uc3QgdmVydGV4JGggPSBcInZhcnlpbmcgdmVjMiB2VXY7XFxudW5pZm9ybSBtYXQzIHV2VHJhbnNmb3JtO1xcbnZvaWQgbWFpbigpIHtcXG5cXHR2VXYgPSAoIHV2VHJhbnNmb3JtICogdmVjMyggdXYsIDEgKSApLnh5O1xcblxcdGdsX1Bvc2l0aW9uID0gdmVjNCggcG9zaXRpb24ueHksIDEuMCwgMS4wICk7XFxufVwiO1xuY29uc3QgZnJhZ21lbnQkaCA9IFwidW5pZm9ybSBzYW1wbGVyMkQgdDJEO1xcbnZhcnlpbmcgdmVjMiB2VXY7XFxudm9pZCBtYWluKCkge1xcblxcdGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCggdDJELCB2VXYgKTtcXG5cXHQjaWZkZWYgREVDT0RFX1ZJREVPX1RFWFRVUkVcXG5cXHRcXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBtaXgoIHBvdyggZ2xfRnJhZ0NvbG9yLnJnYiAqIDAuOTQ3ODY3Mjk4NiArIHZlYzMoIDAuMDUyMTMyNzAxNCApLCB2ZWMzKCAyLjQgKSApLCBnbF9GcmFnQ29sb3IucmdiICogMC4wNzczOTkzODA4LCB2ZWMzKCBsZXNzVGhhbkVxdWFsKCBnbF9GcmFnQ29sb3IucmdiLCB2ZWMzKCAwLjA0MDQ1ICkgKSApICksIGdsX0ZyYWdDb2xvci53ICk7XFxuXFx0I2VuZGlmXFxuXFx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxlbmNvZGluZ3NfZnJhZ21lbnQ+XFxufVwiO1xuXG5jb25zdCB2ZXJ0ZXgkZyA9IFwidmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbnZvaWQgbWFpbigpIHtcXG5cXHR2V29ybGREaXJlY3Rpb24gPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIHBvc2l0aW9uLCBtb2RlbE1hdHJpeCApO1xcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcdGdsX1Bvc2l0aW9uLnogPSBnbF9Qb3NpdGlvbi53O1xcbn1cIjtcbmNvbnN0IGZyYWdtZW50JGcgPSBcIiNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFXFxuXFx0dW5pZm9ybSBzYW1wbGVyQ3ViZSBlbnZNYXA7XFxuI2VsaWYgZGVmaW5lZCggRU5WTUFQX1RZUEVfQ1VCRV9VViApXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgZW52TWFwO1xcbiNlbmRpZlxcbnVuaWZvcm0gZmxvYXQgZmxpcEVudk1hcDtcXG51bmlmb3JtIGZsb2F0IGJhY2tncm91bmRCbHVycmluZXNzO1xcbnZhcnlpbmcgdmVjMyB2V29ybGREaXJlY3Rpb247XFxuI2luY2x1ZGUgPGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVcXG5cXHRcXHR2ZWM0IHRleENvbG9yID0gdGV4dHVyZUN1YmUoIGVudk1hcCwgdmVjMyggZmxpcEVudk1hcCAqIHZXb3JsZERpcmVjdGlvbi54LCB2V29ybGREaXJlY3Rpb24ueXogKSApO1xcblxcdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9UWVBFX0NVQkVfVVYgKVxcblxcdFxcdHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlQ3ViZVVWKCBlbnZNYXAsIHZXb3JsZERpcmVjdGlvbiwgYmFja2dyb3VuZEJsdXJyaW5lc3MgKTtcXG5cXHQjZWxzZVxcblxcdFxcdHZlYzQgdGV4Q29sb3IgPSB2ZWM0KCAwLjAsIDAuMCwgMC4wLCAxLjAgKTtcXG5cXHQjZW5kaWZcXG5cXHRnbF9GcmFnQ29sb3IgPSB0ZXhDb2xvcjtcXG5cXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGVuY29kaW5nc19mcmFnbWVudD5cXG59XCI7XG5cbmNvbnN0IHZlcnRleCRmID0gXCJ2YXJ5aW5nIHZlYzMgdldvcmxkRGlyZWN0aW9uO1xcbiNpbmNsdWRlIDxjb21tb24+XFxudm9pZCBtYWluKCkge1xcblxcdHZXb3JsZERpcmVjdGlvbiA9IHRyYW5zZm9ybURpcmVjdGlvbiggcG9zaXRpb24sIG1vZGVsTWF0cml4ICk7XFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0Z2xfUG9zaXRpb24ueiA9IGdsX1Bvc2l0aW9uLnc7XFxufVwiO1xuY29uc3QgZnJhZ21lbnQkZiA9IFwidW5pZm9ybSBzYW1wbGVyQ3ViZSB0Q3ViZTtcXG51bmlmb3JtIGZsb2F0IHRGbGlwO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG52YXJ5aW5nIHZlYzMgdldvcmxkRGlyZWN0aW9uO1xcbnZvaWQgbWFpbigpIHtcXG5cXHR2ZWM0IHRleENvbG9yID0gdGV4dHVyZUN1YmUoIHRDdWJlLCB2ZWMzKCB0RmxpcCAqIHZXb3JsZERpcmVjdGlvbi54LCB2V29ybGREaXJlY3Rpb24ueXogKSApO1xcblxcdGdsX0ZyYWdDb2xvciA9IHRleENvbG9yO1xcblxcdGdsX0ZyYWdDb2xvci5hICo9IG9wYWNpdHk7XFxuXFx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxlbmNvZGluZ3NfZnJhZ21lbnQ+XFxufVwiO1xuXG5jb25zdCB2ZXJ0ZXgkZSA9IFwiI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbnZhcnlpbmcgdmVjMiB2SGlnaFByZWNpc2lvblpXO1xcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxuXFx0I2lmZGVmIFVTRV9ESVNQTEFDRU1FTlRNQVBcXG5cXHRcXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcblxcdFxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxuXFx0XFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxcblxcdCNlbmRpZlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcblxcdHZIaWdoUHJlY2lzaW9uWlcgPSBnbF9Qb3NpdGlvbi56dztcXG59XCI7XG5jb25zdCBmcmFnbWVudCRlID0gXCIjaWYgREVQVEhfUEFDS0lORyA9PSAzMjAwXFxuXFx0dW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbiNlbmRpZlxcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYXRlc3RfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudmFyeWluZyB2ZWMyIHZIaWdoUHJlY2lzaW9uWlc7XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCAxLjAgKTtcXG5cXHQjaWYgREVQVEhfUEFDS0lORyA9PSAzMjAwXFxuXFx0XFx0ZGlmZnVzZUNvbG9yLmEgPSBvcGFjaXR5O1xcblxcdCNlbmRpZlxcblxcdCNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcblxcdGZsb2F0IGZyYWdDb29yZFogPSAwLjUgKiB2SGlnaFByZWNpc2lvblpXWzBdIC8gdkhpZ2hQcmVjaXNpb25aV1sxXSArIDAuNTtcXG5cXHQjaWYgREVQVEhfUEFDS0lORyA9PSAzMjAwXFxuXFx0XFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggdmVjMyggMS4wIC0gZnJhZ0Nvb3JkWiApLCBvcGFjaXR5ICk7XFxuXFx0I2VsaWYgREVQVEhfUEFDS0lORyA9PSAzMjAxXFxuXFx0XFx0Z2xfRnJhZ0NvbG9yID0gcGFja0RlcHRoVG9SR0JBKCBmcmFnQ29vcmRaICk7XFxuXFx0I2VuZGlmXFxufVwiO1xuXG5jb25zdCB2ZXJ0ZXgkZCA9IFwiI2RlZmluZSBESVNUQU5DRVxcbnZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxcblxcdCNpZmRlZiBVU0VfRElTUExBQ0VNRU5UTUFQXFxuXFx0XFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cXG5cXHRcXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxcblxcdFxcdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjZW5kaWZcXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG5cXHR2V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24ueHl6O1xcbn1cIjtcbmNvbnN0IGZyYWdtZW50JGQgPSBcIiNkZWZpbmUgRElTVEFOQ0VcXG51bmlmb3JtIHZlYzMgcmVmZXJlbmNlUG9zaXRpb247XFxudW5pZm9ybSBmbG9hdCBuZWFyRGlzdGFuY2U7XFxudW5pZm9ybSBmbG9hdCBmYXJEaXN0YW5jZTtcXG52YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8cGFja2luZz5cXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cXG52b2lkIG1haW4gKCkge1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCAxLjAgKTtcXG5cXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PlxcblxcdGZsb2F0IGRpc3QgPSBsZW5ndGgoIHZXb3JsZFBvc2l0aW9uIC0gcmVmZXJlbmNlUG9zaXRpb24gKTtcXG5cXHRkaXN0ID0gKCBkaXN0IC0gbmVhckRpc3RhbmNlICkgLyAoIGZhckRpc3RhbmNlIC0gbmVhckRpc3RhbmNlICk7XFxuXFx0ZGlzdCA9IHNhdHVyYXRlKCBkaXN0ICk7XFxuXFx0Z2xfRnJhZ0NvbG9yID0gcGFja0RlcHRoVG9SR0JBKCBkaXN0ICk7XFxufVwiO1xuXG5jb25zdCB2ZXJ0ZXgkYyA9IFwidmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbnZvaWQgbWFpbigpIHtcXG5cXHR2V29ybGREaXJlY3Rpb24gPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIHBvc2l0aW9uLCBtb2RlbE1hdHJpeCApO1xcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4Plxcbn1cIjtcbmNvbnN0IGZyYWdtZW50JGMgPSBcInVuaWZvcm0gc2FtcGxlcjJEIHRFcXVpcmVjdDtcXG52YXJ5aW5nIHZlYzMgdldvcmxkRGlyZWN0aW9uO1xcbiNpbmNsdWRlIDxjb21tb24+XFxudm9pZCBtYWluKCkge1xcblxcdHZlYzMgZGlyZWN0aW9uID0gbm9ybWFsaXplKCB2V29ybGREaXJlY3Rpb24gKTtcXG5cXHR2ZWMyIHNhbXBsZVVWID0gZXF1aXJlY3RVdiggZGlyZWN0aW9uICk7XFxuXFx0Z2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCB0RXF1aXJlY3QsIHNhbXBsZVVWICk7XFxuXFx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxlbmNvZGluZ3NfZnJhZ21lbnQ+XFxufVwiO1xuXG5jb25zdCB2ZXJ0ZXgkYiA9IFwidW5pZm9ybSBmbG9hdCBzY2FsZTtcXG5hdHRyaWJ1dGUgZmxvYXQgbGluZURpc3RhbmNlO1xcbnZhcnlpbmcgZmxvYXQgdkxpbmVEaXN0YW5jZTtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0dkxpbmVEaXN0YW5jZSA9IHNjYWxlICogbGluZURpc3RhbmNlO1xcblxcdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBoY29sb3JfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cXG59XCI7XG5jb25zdCBmcmFnbWVudCRiID0gXCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxudW5pZm9ybSBmbG9hdCBkYXNoU2l6ZTtcXG51bmlmb3JtIGZsb2F0IHRvdGFsU2l6ZTtcXG52YXJ5aW5nIGZsb2F0IHZMaW5lRGlzdGFuY2U7XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdGlmICggbW9kKCB2TGluZURpc3RhbmNlLCB0b3RhbFNpemUgKSA+IGRhc2hTaXplICkge1xcblxcdFxcdGRpc2NhcmQ7XFxuXFx0fVxcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHZlYzMoIDAuMCApO1xcblxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1xcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+XFxuXFx0b3V0Z29pbmdMaWdodCA9IGRpZmZ1c2VDb2xvci5yZ2I7XFxuXFx0I2luY2x1ZGUgPG91dHB1dF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGVuY29kaW5nc19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50Plxcbn1cIjtcblxuY29uc3QgdmVydGV4JGEgPSBcIiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDx1djJfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGVudm1hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDx1djJfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBoY29sb3JfdmVydGV4PlxcblxcdCNpZiBkZWZpbmVkICggVVNFX0VOVk1BUCApIHx8IGRlZmluZWQgKCBVU0VfU0tJTk5JTkcgKVxcblxcdFxcdCNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0XFx0I2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD5cXG5cXHRcXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxcblxcdFxcdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cXG5cXHRcXHQjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2VuZGlmXFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZW52bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cXG59XCI7XG5jb25zdCBmcmFnbWVudCRhID0gXCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxuI2lmbmRlZiBGTEFUX1NIQURFRFxcblxcdHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcbiNlbmRpZlxcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDx1djJfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhb21hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsaWdodG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxlbnZtYXBfY29tbW9uX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGVudm1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8c3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxzcGVjdWxhcm1hcF9mcmFnbWVudD5cXG5cXHRSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCA9IFJlZmxlY3RlZExpZ2h0KCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSApO1xcblxcdCNpZmRlZiBVU0VfTElHSFRNQVBcXG5cXHRcXHR2ZWM0IGxpZ2h0TWFwVGV4ZWwgPSB0ZXh0dXJlMkQoIGxpZ2h0TWFwLCB2VXYyICk7XFxuXFx0XFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IGxpZ2h0TWFwVGV4ZWwucmdiICogbGlnaHRNYXBJbnRlbnNpdHkgKiBSRUNJUFJPQ0FMX1BJO1xcblxcdCNlbHNlXFxuXFx0XFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IHZlYzMoIDEuMCApO1xcblxcdCNlbmRpZlxcblxcdCNpbmNsdWRlIDxhb21hcF9mcmFnbWVudD5cXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKj0gZGlmZnVzZUNvbG9yLnJnYjtcXG5cXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2U7XFxuXFx0I2luY2x1ZGUgPGVudm1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8b3V0cHV0X2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGRpdGhlcmluZ19mcmFnbWVudD5cXG59XCI7XG5cbmNvbnN0IHZlcnRleCQ5ID0gXCIjZGVmaW5lIExBTUJFUlRcXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8dXYyX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGVudm1hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bm9ybWFsX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8dXYyX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaGNvbG9yX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcblxcdHZWaWV3UG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6O1xcblxcdCNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGVudm1hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNoYWRvd21hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGZvZ192ZXJ0ZXg+XFxufVwiO1xuY29uc3QgZnJhZ21lbnQkOSA9IFwiI2RlZmluZSBMQU1CRVJUXFxudW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxudW5pZm9ybSB2ZWMzIGVtaXNzaXZlO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxwYWNraW5nPlxcbiNpbmNsdWRlIDxkaXRoZXJpbmdfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXYyX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYXRlc3RfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YW9tYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bGlnaHRtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW52bWFwX2NvbW1vbl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxlbnZtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGJzZGZzPlxcbiNpbmNsdWRlIDxsaWdodHNfcGFyc19iZWdpbj5cXG4jaW5jbHVkZSA8bm9ybWFsX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxpZ2h0c19sYW1iZXJ0X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxidW1wbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXG5cXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcXG5cXHRSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCA9IFJlZmxlY3RlZExpZ2h0KCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSApO1xcblxcdHZlYzMgdG90YWxFbWlzc2l2ZVJhZGlhbmNlID0gZW1pc3NpdmU7XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxzcGVjdWxhcm1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50X2JlZ2luPlxcblxcdCNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfbWFwcz5cXG5cXHQjaW5jbHVkZSA8ZW1pc3NpdmVtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGxpZ2h0c19sYW1iZXJ0X2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxsaWdodHNfZnJhZ21lbnRfYmVnaW4+XFxuXFx0I2luY2x1ZGUgPGxpZ2h0c19mcmFnbWVudF9tYXBzPlxcblxcdCNpbmNsdWRlIDxsaWdodHNfZnJhZ21lbnRfZW5kPlxcblxcdCNpbmNsdWRlIDxhb21hcF9mcmFnbWVudD5cXG5cXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSByZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICsgcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICsgdG90YWxFbWlzc2l2ZVJhZGlhbmNlO1xcblxcdCNpbmNsdWRlIDxlbnZtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG91dHB1dF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGVuY29kaW5nc19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxkaXRoZXJpbmdfZnJhZ21lbnQ+XFxufVwiO1xuXG5jb25zdCB2ZXJ0ZXgkOCA9IFwiI2RlZmluZSBNQVRDQVBcXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxub3JtYWxfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaGNvbG9yX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxmb2dfdmVydGV4PlxcblxcdHZWaWV3UG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6O1xcbn1cIjtcbmNvbnN0IGZyYWdtZW50JDggPSBcIiNkZWZpbmUgTUFUQ0FQXFxudW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbnVuaWZvcm0gc2FtcGxlcjJEIG1hdGNhcDtcXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxkaXRoZXJpbmdfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bm9ybWFsX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGJ1bXBtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1xcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50X2JlZ2luPlxcblxcdCNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfbWFwcz5cXG5cXHR2ZWMzIHZpZXdEaXIgPSBub3JtYWxpemUoIHZWaWV3UG9zaXRpb24gKTtcXG5cXHR2ZWMzIHggPSBub3JtYWxpemUoIHZlYzMoIHZpZXdEaXIueiwgMC4wLCAtIHZpZXdEaXIueCApICk7XFxuXFx0dmVjMyB5ID0gY3Jvc3MoIHZpZXdEaXIsIHggKTtcXG5cXHR2ZWMyIHV2ID0gdmVjMiggZG90KCB4LCBub3JtYWwgKSwgZG90KCB5LCBub3JtYWwgKSApICogMC40OTUgKyAwLjU7XFxuXFx0I2lmZGVmIFVTRV9NQVRDQVBcXG5cXHRcXHR2ZWM0IG1hdGNhcENvbG9yID0gdGV4dHVyZTJEKCBtYXRjYXAsIHV2ICk7XFxuXFx0I2Vsc2VcXG5cXHRcXHR2ZWM0IG1hdGNhcENvbG9yID0gdmVjNCggdmVjMyggbWl4KCAwLjIsIDAuOCwgdXYueSApICksIDEuMCApO1xcblxcdCNlbmRpZlxcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IGRpZmZ1c2VDb2xvci5yZ2IgKiBtYXRjYXBDb2xvci5yZ2I7XFxuXFx0I2luY2x1ZGUgPG91dHB1dF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGVuY29kaW5nc19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxkaXRoZXJpbmdfZnJhZ21lbnQ+XFxufVwiO1xuXG5jb25zdCB2ZXJ0ZXgkNyA9IFwiI2RlZmluZSBOT1JNQUxcXG4jaWYgZGVmaW5lZCggRkxBVF9TSEFERUQgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFRBTkdFTlRTUEFDRV9OT1JNQUxNQVAgKVxcblxcdHZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcbiNlbmRpZlxcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG5vcm1hbF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxuI2lmIGRlZmluZWQoIEZMQVRfU0hBREVEICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBUQU5HRU5UU1BBQ0VfTk9STUFMTUFQIClcXG5cXHR2Vmlld1Bvc2l0aW9uID0gLSBtdlBvc2l0aW9uLnh5ejtcXG4jZW5kaWZcXG59XCI7XG5jb25zdCBmcmFnbWVudCQ3ID0gXCIjZGVmaW5lIE5PUk1BTFxcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG4jaWYgZGVmaW5lZCggRkxBVF9TSEFERUQgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFRBTkdFTlRTUEFDRV9OT1JNQUxNQVAgKVxcblxcdHZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcbiNlbmRpZlxcbiNpbmNsdWRlIDxwYWNraW5nPlxcbiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxub3JtYWxfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YnVtcG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxub3JtYWxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfYmVnaW4+XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9tYXBzPlxcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIHBhY2tOb3JtYWxUb1JHQiggbm9ybWFsICksIG9wYWNpdHkgKTtcXG5cXHQjaWZkZWYgT1BBUVVFXFxuXFx0XFx0Z2xfRnJhZ0NvbG9yLmEgPSAxLjA7XFxuXFx0I2VuZGlmXFxufVwiO1xuXG5jb25zdCB2ZXJ0ZXgkNiA9IFwiI2RlZmluZSBQSE9OR1xcbnZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDx1djJfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8ZW52bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxub3JtYWxfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDx1djJfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBoY29sb3JfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxuXFx0dlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7XFxuXFx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZW52bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2hhZG93bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cXG59XCI7XG5jb25zdCBmcmFnbWVudCQ2ID0gXCIjZGVmaW5lIFBIT05HXFxudW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxudW5pZm9ybSB2ZWMzIGVtaXNzaXZlO1xcbnVuaWZvcm0gdmVjMyBzcGVjdWxhcjtcXG51bmlmb3JtIGZsb2F0IHNoaW5pbmVzcztcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8cGFja2luZz5cXG4jaW5jbHVkZSA8ZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHV2Ml9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGF0ZXN0X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFvbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGVtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGVudm1hcF9jb21tb25fcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW52bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxic2Rmcz5cXG4jaW5jbHVkZSA8bGlnaHRzX3BhcnNfYmVnaW4+XFxuI2luY2x1ZGUgPG5vcm1hbF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsaWdodHNfcGhvbmdfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGJ1bXBtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1xcblxcdFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ID0gUmVmbGVjdGVkTGlnaHQoIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApICk7XFxuXFx0dmVjMyB0b3RhbEVtaXNzaXZlUmFkaWFuY2UgPSBlbWlzc2l2ZTtcXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHNwZWN1bGFybWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfYmVnaW4+XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9tYXBzPlxcblxcdCNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX3Bob25nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxsaWdodHNfZnJhZ21lbnRfYmVnaW4+XFxuXFx0I2luY2x1ZGUgPGxpZ2h0c19mcmFnbWVudF9tYXBzPlxcblxcdCNpbmNsdWRlIDxsaWdodHNfZnJhZ21lbnRfZW5kPlxcblxcdCNpbmNsdWRlIDxhb21hcF9mcmFnbWVudD5cXG5cXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSByZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICsgcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICsgcmVmbGVjdGVkTGlnaHQuZGlyZWN0U3BlY3VsYXIgKyByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdFNwZWN1bGFyICsgdG90YWxFbWlzc2l2ZVJhZGlhbmNlO1xcblxcdCNpbmNsdWRlIDxlbnZtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG91dHB1dF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGVuY29kaW5nc19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxkaXRoZXJpbmdfZnJhZ21lbnQ+XFxufVwiO1xuXG5jb25zdCB2ZXJ0ZXgkNSA9IFwiI2RlZmluZSBTVEFOREFSRFxcbnZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcbiNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OXFxuXFx0dmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcbiNlbmRpZlxcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDx1djJfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bm9ybWFsX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8dXYyX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaGNvbG9yX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcblxcdHZWaWV3UG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6O1xcblxcdCNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNoYWRvd21hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGZvZ192ZXJ0ZXg+XFxuI2lmZGVmIFVTRV9UUkFOU01JU1NJT05cXG5cXHR2V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24ueHl6O1xcbiNlbmRpZlxcbn1cIjtcbmNvbnN0IGZyYWdtZW50JDUgPSBcIiNkZWZpbmUgU1RBTkRBUkRcXG4jaWZkZWYgUEhZU0lDQUxcXG5cXHQjZGVmaW5lIElPUlxcblxcdCNkZWZpbmUgU1BFQ1VMQVJcXG4jZW5kaWZcXG51bmlmb3JtIHZlYzMgZGlmZnVzZTtcXG51bmlmb3JtIHZlYzMgZW1pc3NpdmU7XFxudW5pZm9ybSBmbG9hdCByb3VnaG5lc3M7XFxudW5pZm9ybSBmbG9hdCBtZXRhbG5lc3M7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbiNpZmRlZiBJT1JcXG5cXHR1bmlmb3JtIGZsb2F0IGlvcjtcXG4jZW5kaWZcXG4jaWZkZWYgU1BFQ1VMQVJcXG5cXHR1bmlmb3JtIGZsb2F0IHNwZWN1bGFySW50ZW5zaXR5O1xcblxcdHVuaWZvcm0gdmVjMyBzcGVjdWxhckNvbG9yO1xcblxcdCNpZmRlZiBVU0VfU1BFQ1VMQVJJTlRFTlNJVFlNQVBcXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXIyRCBzcGVjdWxhckludGVuc2l0eU1hcDtcXG5cXHQjZW5kaWZcXG5cXHQjaWZkZWYgVVNFX1NQRUNVTEFSQ09MT1JNQVBcXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXIyRCBzcGVjdWxhckNvbG9yTWFwO1xcblxcdCNlbmRpZlxcbiNlbmRpZlxcbiNpZmRlZiBVU0VfQ0xFQVJDT0FUXFxuXFx0dW5pZm9ybSBmbG9hdCBjbGVhcmNvYXQ7XFxuXFx0dW5pZm9ybSBmbG9hdCBjbGVhcmNvYXRSb3VnaG5lc3M7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9JUklERVNDRU5DRVxcblxcdHVuaWZvcm0gZmxvYXQgaXJpZGVzY2VuY2U7XFxuXFx0dW5pZm9ybSBmbG9hdCBpcmlkZXNjZW5jZUlPUjtcXG5cXHR1bmlmb3JtIGZsb2F0IGlyaWRlc2NlbmNlVGhpY2tuZXNzTWluaW11bTtcXG5cXHR1bmlmb3JtIGZsb2F0IGlyaWRlc2NlbmNlVGhpY2tuZXNzTWF4aW11bTtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX1NIRUVOXFxuXFx0dW5pZm9ybSB2ZWMzIHNoZWVuQ29sb3I7XFxuXFx0dW5pZm9ybSBmbG9hdCBzaGVlblJvdWdobmVzcztcXG5cXHQjaWZkZWYgVVNFX1NIRUVOQ09MT1JNQVBcXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXIyRCBzaGVlbkNvbG9yTWFwO1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBVU0VfU0hFRU5ST1VHSE5FU1NNQVBcXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXIyRCBzaGVlblJvdWdobmVzc01hcDtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxwYWNraW5nPlxcbiNpbmNsdWRlIDxkaXRoZXJpbmdfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXYyX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYXRlc3RfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YW9tYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bGlnaHRtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YnNkZnM+XFxuI2luY2x1ZGUgPGlyaWRlc2NlbmNlX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGVudm1hcF9jb21tb25fcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW52bWFwX3BoeXNpY2FsX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsaWdodHNfcGFyc19iZWdpbj5cXG4jaW5jbHVkZSA8bm9ybWFsX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxpZ2h0c19waHlzaWNhbF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDx0cmFuc21pc3Npb25fcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGJ1bXBtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsZWFyY29hdF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxpcmlkZXNjZW5jZV9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxyb3VnaG5lc3NtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bWV0YWxuZXNzbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1xcblxcdFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ID0gUmVmbGVjdGVkTGlnaHQoIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApICk7XFxuXFx0dmVjMyB0b3RhbEVtaXNzaXZlUmFkaWFuY2UgPSBlbWlzc2l2ZTtcXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHJvdWdobmVzc21hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bWV0YWxuZXNzbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfYmVnaW4+XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9tYXBzPlxcblxcdCNpbmNsdWRlIDxjbGVhcmNvYXRfbm9ybWFsX2ZyYWdtZW50X2JlZ2luPlxcblxcdCNpbmNsdWRlIDxjbGVhcmNvYXRfbm9ybWFsX2ZyYWdtZW50X21hcHM+XFxuXFx0I2luY2x1ZGUgPGVtaXNzaXZlbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxsaWdodHNfcGh5c2ljYWxfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGxpZ2h0c19mcmFnbWVudF9iZWdpbj5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X21hcHM+XFxuXFx0I2luY2x1ZGUgPGxpZ2h0c19mcmFnbWVudF9lbmQ+XFxuXFx0I2luY2x1ZGUgPGFvbWFwX2ZyYWdtZW50PlxcblxcdHZlYzMgdG90YWxEaWZmdXNlID0gcmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZTtcXG5cXHR2ZWMzIHRvdGFsU3BlY3VsYXIgPSByZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXI7XFxuXFx0I2luY2x1ZGUgPHRyYW5zbWlzc2lvbl9mcmFnbWVudD5cXG5cXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSB0b3RhbERpZmZ1c2UgKyB0b3RhbFNwZWN1bGFyICsgdG90YWxFbWlzc2l2ZVJhZGlhbmNlO1xcblxcdCNpZmRlZiBVU0VfU0hFRU5cXG5cXHRcXHRmbG9hdCBzaGVlbkVuZXJneUNvbXAgPSAxLjAgLSAwLjE1NyAqIG1heDMoIG1hdGVyaWFsLnNoZWVuQ29sb3IgKTtcXG5cXHRcXHRvdXRnb2luZ0xpZ2h0ID0gb3V0Z29pbmdMaWdodCAqIHNoZWVuRW5lcmd5Q29tcCArIHNoZWVuU3BlY3VsYXI7XFxuXFx0I2VuZGlmXFxuXFx0I2lmZGVmIFVTRV9DTEVBUkNPQVRcXG5cXHRcXHRmbG9hdCBkb3ROVmNjID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkuY2xlYXJjb2F0Tm9ybWFsLCBnZW9tZXRyeS52aWV3RGlyICkgKTtcXG5cXHRcXHR2ZWMzIEZjYyA9IEZfU2NobGljayggbWF0ZXJpYWwuY2xlYXJjb2F0RjAsIG1hdGVyaWFsLmNsZWFyY29hdEY5MCwgZG90TlZjYyApO1xcblxcdFxcdG91dGdvaW5nTGlnaHQgPSBvdXRnb2luZ0xpZ2h0ICogKCAxLjAgLSBtYXRlcmlhbC5jbGVhcmNvYXQgKiBGY2MgKSArIGNsZWFyY29hdFNwZWN1bGFyICogbWF0ZXJpYWwuY2xlYXJjb2F0O1xcblxcdCNlbmRpZlxcblxcdCNpbmNsdWRlIDxvdXRwdXRfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxlbmNvZGluZ3NfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZGl0aGVyaW5nX2ZyYWdtZW50Plxcbn1cIjtcblxuY29uc3QgdmVydGV4JDQgPSBcIiNkZWZpbmUgVE9PTlxcbnZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDx1djJfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bm9ybWFsX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8dXYyX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaGNvbG9yX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcblxcdHZWaWV3UG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6O1xcblxcdCNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNoYWRvd21hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGZvZ192ZXJ0ZXg+XFxufVwiO1xuY29uc3QgZnJhZ21lbnQkNCA9IFwiI2RlZmluZSBUT09OXFxudW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxudW5pZm9ybSB2ZWMzIGVtaXNzaXZlO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxwYWNraW5nPlxcbiNpbmNsdWRlIDxkaXRoZXJpbmdfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXYyX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYXRlc3RfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YW9tYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bGlnaHRtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Z3JhZGllbnRtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGJzZGZzPlxcbiNpbmNsdWRlIDxsaWdodHNfcGFyc19iZWdpbj5cXG4jaW5jbHVkZSA8bm9ybWFsX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxpZ2h0c190b29uX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxidW1wbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXG5cXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcXG5cXHRSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCA9IFJlZmxlY3RlZExpZ2h0KCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSApO1xcblxcdHZlYzMgdG90YWxFbWlzc2l2ZVJhZGlhbmNlID0gZW1pc3NpdmU7XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfYmVnaW4+XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9tYXBzPlxcblxcdCNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX3Rvb25fZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGxpZ2h0c19mcmFnbWVudF9iZWdpbj5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X21hcHM+XFxuXFx0I2luY2x1ZGUgPGxpZ2h0c19mcmFnbWVudF9lbmQ+XFxuXFx0I2luY2x1ZGUgPGFvbWFwX2ZyYWdtZW50PlxcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKyB0b3RhbEVtaXNzaXZlUmFkaWFuY2U7XFxuXFx0I2luY2x1ZGUgPG91dHB1dF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGVuY29kaW5nc19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxkaXRoZXJpbmdfZnJhZ21lbnQ+XFxufVwiO1xuXG5jb25zdCB2ZXJ0ZXgkMyA9IFwidW5pZm9ybSBmbG9hdCBzaXplO1xcbnVuaWZvcm0gZmxvYXQgc2NhbGU7XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBoY29sb3JfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0Z2xfUG9pbnRTaXplID0gc2l6ZTtcXG5cXHQjaWZkZWYgVVNFX1NJWkVBVFRFTlVBVElPTlxcblxcdFxcdGJvb2wgaXNQZXJzcGVjdGl2ZSA9IGlzUGVyc3BlY3RpdmVNYXRyaXgoIHByb2plY3Rpb25NYXRyaXggKTtcXG5cXHRcXHRpZiAoIGlzUGVyc3BlY3RpdmUgKSBnbF9Qb2ludFNpemUgKj0gKCBzY2FsZSAvIC0gbXZQb3NpdGlvbi56ICk7XFxuXFx0I2VuZGlmXFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxmb2dfdmVydGV4Plxcbn1cIjtcbmNvbnN0IGZyYWdtZW50JDMgPSBcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxtYXBfcGFydGljbGVfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGF0ZXN0X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXG5cXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSB2ZWMzKCAwLjAgKTtcXG5cXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG1hcF9wYXJ0aWNsZV9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXG5cXHRvdXRnb2luZ0xpZ2h0ID0gZGlmZnVzZUNvbG9yLnJnYjtcXG5cXHQjaW5jbHVkZSA8b3V0cHV0X2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XFxufVwiO1xuXG5jb25zdCB2ZXJ0ZXgkMiA9IFwiI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2hhZG93bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cXG59XCI7XG5jb25zdCBmcmFnbWVudCQyID0gXCJ1bmlmb3JtIHZlYzMgY29sb3I7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxic2Rmcz5cXG4jaW5jbHVkZSA8bGlnaHRzX3BhcnNfYmVnaW4+XFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXNrX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIGNvbG9yLCBvcGFjaXR5ICogKCAxLjAgLSBnZXRTaGFkb3dNYXNrKCkgKSApO1xcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxufVwiO1xuXG5jb25zdCB2ZXJ0ZXgkMSA9IFwidW5pZm9ybSBmbG9hdCByb3RhdGlvbjtcXG51bmlmb3JtIHZlYzIgY2VudGVyO1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XFxuXFx0dmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggMC4wLCAwLjAsIDAuMCwgMS4wICk7XFxuXFx0dmVjMiBzY2FsZTtcXG5cXHRzY2FsZS54ID0gbGVuZ3RoKCB2ZWMzKCBtb2RlbE1hdHJpeFsgMCBdLngsIG1vZGVsTWF0cml4WyAwIF0ueSwgbW9kZWxNYXRyaXhbIDAgXS56ICkgKTtcXG5cXHRzY2FsZS55ID0gbGVuZ3RoKCB2ZWMzKCBtb2RlbE1hdHJpeFsgMSBdLngsIG1vZGVsTWF0cml4WyAxIF0ueSwgbW9kZWxNYXRyaXhbIDEgXS56ICkgKTtcXG5cXHQjaWZuZGVmIFVTRV9TSVpFQVRURU5VQVRJT05cXG5cXHRcXHRib29sIGlzUGVyc3BlY3RpdmUgPSBpc1BlcnNwZWN0aXZlTWF0cml4KCBwcm9qZWN0aW9uTWF0cml4ICk7XFxuXFx0XFx0aWYgKCBpc1BlcnNwZWN0aXZlICkgc2NhbGUgKj0gLSBtdlBvc2l0aW9uLno7XFxuXFx0I2VuZGlmXFxuXFx0dmVjMiBhbGlnbmVkUG9zaXRpb24gPSAoIHBvc2l0aW9uLnh5IC0gKCBjZW50ZXIgLSB2ZWMyKCAwLjUgKSApICkgKiBzY2FsZTtcXG5cXHR2ZWMyIHJvdGF0ZWRQb3NpdGlvbjtcXG5cXHRyb3RhdGVkUG9zaXRpb24ueCA9IGNvcyggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi54IC0gc2luKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnk7XFxuXFx0cm90YXRlZFBvc2l0aW9uLnkgPSBzaW4oIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueCArIGNvcyggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi55O1xcblxcdG12UG9zaXRpb24ueHkgKz0gcm90YXRlZFBvc2l0aW9uO1xcblxcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cXG59XCI7XG5jb25zdCBmcmFnbWVudCQxID0gXCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gdmVjMyggMC4wICk7XFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxuXFx0b3V0Z29pbmdMaWdodCA9IGRpZmZ1c2VDb2xvci5yZ2I7XFxuXFx0I2luY2x1ZGUgPG91dHB1dF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGVuY29kaW5nc19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50Plxcbn1cIjtcblxuY29uc3QgU2hhZGVyQ2h1bmsgPSB7XG5cdGFscGhhbWFwX2ZyYWdtZW50OiBhbHBoYW1hcF9mcmFnbWVudCxcblx0YWxwaGFtYXBfcGFyc19mcmFnbWVudDogYWxwaGFtYXBfcGFyc19mcmFnbWVudCxcblx0YWxwaGF0ZXN0X2ZyYWdtZW50OiBhbHBoYXRlc3RfZnJhZ21lbnQsXG5cdGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50OiBhbHBoYXRlc3RfcGFyc19mcmFnbWVudCxcblx0YW9tYXBfZnJhZ21lbnQ6IGFvbWFwX2ZyYWdtZW50LFxuXHRhb21hcF9wYXJzX2ZyYWdtZW50OiBhb21hcF9wYXJzX2ZyYWdtZW50LFxuXHRiZWdpbl92ZXJ0ZXg6IGJlZ2luX3ZlcnRleCxcblx0YmVnaW5ub3JtYWxfdmVydGV4OiBiZWdpbm5vcm1hbF92ZXJ0ZXgsXG5cdGJzZGZzOiBic2Rmcyxcblx0aXJpZGVzY2VuY2VfZnJhZ21lbnQ6IGlyaWRlc2NlbmNlX2ZyYWdtZW50LFxuXHRidW1wbWFwX3BhcnNfZnJhZ21lbnQ6IGJ1bXBtYXBfcGFyc19mcmFnbWVudCxcblx0Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50OiBjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQsXG5cdGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50OiBjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudCxcblx0Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4OiBjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXgsXG5cdGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg6IGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXgsXG5cdGNvbG9yX2ZyYWdtZW50OiBjb2xvcl9mcmFnbWVudCxcblx0Y29sb3JfcGFyc19mcmFnbWVudDogY29sb3JfcGFyc19mcmFnbWVudCxcblx0Y29sb3JfcGFyc192ZXJ0ZXg6IGNvbG9yX3BhcnNfdmVydGV4LFxuXHRjb2xvcl92ZXJ0ZXg6IGNvbG9yX3ZlcnRleCxcblx0Y29tbW9uOiBjb21tb24sXG5cdGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudDogY3ViZV91dl9yZWZsZWN0aW9uX2ZyYWdtZW50LFxuXHRkZWZhdWx0bm9ybWFsX3ZlcnRleDogZGVmYXVsdG5vcm1hbF92ZXJ0ZXgsXG5cdGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleDogZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4LFxuXHRkaXNwbGFjZW1lbnRtYXBfdmVydGV4OiBkaXNwbGFjZW1lbnRtYXBfdmVydGV4LFxuXHRlbWlzc2l2ZW1hcF9mcmFnbWVudDogZW1pc3NpdmVtYXBfZnJhZ21lbnQsXG5cdGVtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnQ6IGVtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnQsXG5cdGVuY29kaW5nc19mcmFnbWVudDogZW5jb2RpbmdzX2ZyYWdtZW50LFxuXHRlbmNvZGluZ3NfcGFyc19mcmFnbWVudDogZW5jb2RpbmdzX3BhcnNfZnJhZ21lbnQsXG5cdGVudm1hcF9mcmFnbWVudDogZW52bWFwX2ZyYWdtZW50LFxuXHRlbnZtYXBfY29tbW9uX3BhcnNfZnJhZ21lbnQ6IGVudm1hcF9jb21tb25fcGFyc19mcmFnbWVudCxcblx0ZW52bWFwX3BhcnNfZnJhZ21lbnQ6IGVudm1hcF9wYXJzX2ZyYWdtZW50LFxuXHRlbnZtYXBfcGFyc192ZXJ0ZXg6IGVudm1hcF9wYXJzX3ZlcnRleCxcblx0ZW52bWFwX3BoeXNpY2FsX3BhcnNfZnJhZ21lbnQ6IGVudm1hcF9waHlzaWNhbF9wYXJzX2ZyYWdtZW50LFxuXHRlbnZtYXBfdmVydGV4OiBlbnZtYXBfdmVydGV4LFxuXHRmb2dfdmVydGV4OiBmb2dfdmVydGV4LFxuXHRmb2dfcGFyc192ZXJ0ZXg6IGZvZ19wYXJzX3ZlcnRleCxcblx0Zm9nX2ZyYWdtZW50OiBmb2dfZnJhZ21lbnQsXG5cdGZvZ19wYXJzX2ZyYWdtZW50OiBmb2dfcGFyc19mcmFnbWVudCxcblx0Z3JhZGllbnRtYXBfcGFyc19mcmFnbWVudDogZ3JhZGllbnRtYXBfcGFyc19mcmFnbWVudCxcblx0bGlnaHRtYXBfZnJhZ21lbnQ6IGxpZ2h0bWFwX2ZyYWdtZW50LFxuXHRsaWdodG1hcF9wYXJzX2ZyYWdtZW50OiBsaWdodG1hcF9wYXJzX2ZyYWdtZW50LFxuXHRsaWdodHNfbGFtYmVydF9mcmFnbWVudDogbGlnaHRzX2xhbWJlcnRfZnJhZ21lbnQsXG5cdGxpZ2h0c19sYW1iZXJ0X3BhcnNfZnJhZ21lbnQ6IGxpZ2h0c19sYW1iZXJ0X3BhcnNfZnJhZ21lbnQsXG5cdGxpZ2h0c19wYXJzX2JlZ2luOiBsaWdodHNfcGFyc19iZWdpbixcblx0bGlnaHRzX3Rvb25fZnJhZ21lbnQ6IGxpZ2h0c190b29uX2ZyYWdtZW50LFxuXHRsaWdodHNfdG9vbl9wYXJzX2ZyYWdtZW50OiBsaWdodHNfdG9vbl9wYXJzX2ZyYWdtZW50LFxuXHRsaWdodHNfcGhvbmdfZnJhZ21lbnQ6IGxpZ2h0c19waG9uZ19mcmFnbWVudCxcblx0bGlnaHRzX3Bob25nX3BhcnNfZnJhZ21lbnQ6IGxpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50LFxuXHRsaWdodHNfcGh5c2ljYWxfZnJhZ21lbnQ6IGxpZ2h0c19waHlzaWNhbF9mcmFnbWVudCxcblx0bGlnaHRzX3BoeXNpY2FsX3BhcnNfZnJhZ21lbnQ6IGxpZ2h0c19waHlzaWNhbF9wYXJzX2ZyYWdtZW50LFxuXHRsaWdodHNfZnJhZ21lbnRfYmVnaW46IGxpZ2h0c19mcmFnbWVudF9iZWdpbixcblx0bGlnaHRzX2ZyYWdtZW50X21hcHM6IGxpZ2h0c19mcmFnbWVudF9tYXBzLFxuXHRsaWdodHNfZnJhZ21lbnRfZW5kOiBsaWdodHNfZnJhZ21lbnRfZW5kLFxuXHRsb2dkZXB0aGJ1Zl9mcmFnbWVudDogbG9nZGVwdGhidWZfZnJhZ21lbnQsXG5cdGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ6IGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQsXG5cdGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4OiBsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleCxcblx0bG9nZGVwdGhidWZfdmVydGV4OiBsb2dkZXB0aGJ1Zl92ZXJ0ZXgsXG5cdG1hcF9mcmFnbWVudDogbWFwX2ZyYWdtZW50LFxuXHRtYXBfcGFyc19mcmFnbWVudDogbWFwX3BhcnNfZnJhZ21lbnQsXG5cdG1hcF9wYXJ0aWNsZV9mcmFnbWVudDogbWFwX3BhcnRpY2xlX2ZyYWdtZW50LFxuXHRtYXBfcGFydGljbGVfcGFyc19mcmFnbWVudDogbWFwX3BhcnRpY2xlX3BhcnNfZnJhZ21lbnQsXG5cdG1ldGFsbmVzc21hcF9mcmFnbWVudDogbWV0YWxuZXNzbWFwX2ZyYWdtZW50LFxuXHRtZXRhbG5lc3NtYXBfcGFyc19mcmFnbWVudDogbWV0YWxuZXNzbWFwX3BhcnNfZnJhZ21lbnQsXG5cdG1vcnBoY29sb3JfdmVydGV4OiBtb3JwaGNvbG9yX3ZlcnRleCxcblx0bW9ycGhub3JtYWxfdmVydGV4OiBtb3JwaG5vcm1hbF92ZXJ0ZXgsXG5cdG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4OiBtb3JwaHRhcmdldF9wYXJzX3ZlcnRleCxcblx0bW9ycGh0YXJnZXRfdmVydGV4OiBtb3JwaHRhcmdldF92ZXJ0ZXgsXG5cdG5vcm1hbF9mcmFnbWVudF9iZWdpbjogbm9ybWFsX2ZyYWdtZW50X2JlZ2luLFxuXHRub3JtYWxfZnJhZ21lbnRfbWFwczogbm9ybWFsX2ZyYWdtZW50X21hcHMsXG5cdG5vcm1hbF9wYXJzX2ZyYWdtZW50OiBub3JtYWxfcGFyc19mcmFnbWVudCxcblx0bm9ybWFsX3BhcnNfdmVydGV4OiBub3JtYWxfcGFyc192ZXJ0ZXgsXG5cdG5vcm1hbF92ZXJ0ZXg6IG5vcm1hbF92ZXJ0ZXgsXG5cdG5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50OiBub3JtYWxtYXBfcGFyc19mcmFnbWVudCxcblx0Y2xlYXJjb2F0X25vcm1hbF9mcmFnbWVudF9iZWdpbjogY2xlYXJjb2F0X25vcm1hbF9mcmFnbWVudF9iZWdpbixcblx0Y2xlYXJjb2F0X25vcm1hbF9mcmFnbWVudF9tYXBzOiBjbGVhcmNvYXRfbm9ybWFsX2ZyYWdtZW50X21hcHMsXG5cdGNsZWFyY29hdF9wYXJzX2ZyYWdtZW50OiBjbGVhcmNvYXRfcGFyc19mcmFnbWVudCxcblx0aXJpZGVzY2VuY2VfcGFyc19mcmFnbWVudDogaXJpZGVzY2VuY2VfcGFyc19mcmFnbWVudCxcblx0b3V0cHV0X2ZyYWdtZW50OiBvdXRwdXRfZnJhZ21lbnQsXG5cdHBhY2tpbmc6IHBhY2tpbmcsXG5cdHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ6IHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQsXG5cdHByb2plY3RfdmVydGV4OiBwcm9qZWN0X3ZlcnRleCxcblx0ZGl0aGVyaW5nX2ZyYWdtZW50OiBkaXRoZXJpbmdfZnJhZ21lbnQsXG5cdGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50OiBkaXRoZXJpbmdfcGFyc19mcmFnbWVudCxcblx0cm91Z2huZXNzbWFwX2ZyYWdtZW50OiByb3VnaG5lc3NtYXBfZnJhZ21lbnQsXG5cdHJvdWdobmVzc21hcF9wYXJzX2ZyYWdtZW50OiByb3VnaG5lc3NtYXBfcGFyc19mcmFnbWVudCxcblx0c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ6IHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50LFxuXHRzaGFkb3dtYXBfcGFyc192ZXJ0ZXg6IHNoYWRvd21hcF9wYXJzX3ZlcnRleCxcblx0c2hhZG93bWFwX3ZlcnRleDogc2hhZG93bWFwX3ZlcnRleCxcblx0c2hhZG93bWFza19wYXJzX2ZyYWdtZW50OiBzaGFkb3dtYXNrX3BhcnNfZnJhZ21lbnQsXG5cdHNraW5iYXNlX3ZlcnRleDogc2tpbmJhc2VfdmVydGV4LFxuXHRza2lubmluZ19wYXJzX3ZlcnRleDogc2tpbm5pbmdfcGFyc192ZXJ0ZXgsXG5cdHNraW5uaW5nX3ZlcnRleDogc2tpbm5pbmdfdmVydGV4LFxuXHRza2lubm9ybWFsX3ZlcnRleDogc2tpbm5vcm1hbF92ZXJ0ZXgsXG5cdHNwZWN1bGFybWFwX2ZyYWdtZW50OiBzcGVjdWxhcm1hcF9mcmFnbWVudCxcblx0c3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudDogc3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudCxcblx0dG9uZW1hcHBpbmdfZnJhZ21lbnQ6IHRvbmVtYXBwaW5nX2ZyYWdtZW50LFxuXHR0b25lbWFwcGluZ19wYXJzX2ZyYWdtZW50OiB0b25lbWFwcGluZ19wYXJzX2ZyYWdtZW50LFxuXHR0cmFuc21pc3Npb25fZnJhZ21lbnQ6IHRyYW5zbWlzc2lvbl9mcmFnbWVudCxcblx0dHJhbnNtaXNzaW9uX3BhcnNfZnJhZ21lbnQ6IHRyYW5zbWlzc2lvbl9wYXJzX2ZyYWdtZW50LFxuXHR1dl9wYXJzX2ZyYWdtZW50OiB1dl9wYXJzX2ZyYWdtZW50LFxuXHR1dl9wYXJzX3ZlcnRleDogdXZfcGFyc192ZXJ0ZXgsXG5cdHV2X3ZlcnRleDogdXZfdmVydGV4LFxuXHR1djJfcGFyc19mcmFnbWVudDogdXYyX3BhcnNfZnJhZ21lbnQsXG5cdHV2Ml9wYXJzX3ZlcnRleDogdXYyX3BhcnNfdmVydGV4LFxuXHR1djJfdmVydGV4OiB1djJfdmVydGV4LFxuXHR3b3JsZHBvc192ZXJ0ZXg6IHdvcmxkcG9zX3ZlcnRleCxcblx0YmFja2dyb3VuZF92ZXJ0OiB2ZXJ0ZXgkaCxcblx0YmFja2dyb3VuZF9mcmFnOiBmcmFnbWVudCRoLFxuXHRiYWNrZ3JvdW5kQ3ViZV92ZXJ0OiB2ZXJ0ZXgkZyxcblx0YmFja2dyb3VuZEN1YmVfZnJhZzogZnJhZ21lbnQkZyxcblx0Y3ViZV92ZXJ0OiB2ZXJ0ZXgkZixcblx0Y3ViZV9mcmFnOiBmcmFnbWVudCRmLFxuXHRkZXB0aF92ZXJ0OiB2ZXJ0ZXgkZSxcblx0ZGVwdGhfZnJhZzogZnJhZ21lbnQkZSxcblx0ZGlzdGFuY2VSR0JBX3ZlcnQ6IHZlcnRleCRkLFxuXHRkaXN0YW5jZVJHQkFfZnJhZzogZnJhZ21lbnQkZCxcblx0ZXF1aXJlY3RfdmVydDogdmVydGV4JGMsXG5cdGVxdWlyZWN0X2ZyYWc6IGZyYWdtZW50JGMsXG5cdGxpbmVkYXNoZWRfdmVydDogdmVydGV4JGIsXG5cdGxpbmVkYXNoZWRfZnJhZzogZnJhZ21lbnQkYixcblx0bWVzaGJhc2ljX3ZlcnQ6IHZlcnRleCRhLFxuXHRtZXNoYmFzaWNfZnJhZzogZnJhZ21lbnQkYSxcblx0bWVzaGxhbWJlcnRfdmVydDogdmVydGV4JDksXG5cdG1lc2hsYW1iZXJ0X2ZyYWc6IGZyYWdtZW50JDksXG5cdG1lc2htYXRjYXBfdmVydDogdmVydGV4JDgsXG5cdG1lc2htYXRjYXBfZnJhZzogZnJhZ21lbnQkOCxcblx0bWVzaG5vcm1hbF92ZXJ0OiB2ZXJ0ZXgkNyxcblx0bWVzaG5vcm1hbF9mcmFnOiBmcmFnbWVudCQ3LFxuXHRtZXNocGhvbmdfdmVydDogdmVydGV4JDYsXG5cdG1lc2hwaG9uZ19mcmFnOiBmcmFnbWVudCQ2LFxuXHRtZXNocGh5c2ljYWxfdmVydDogdmVydGV4JDUsXG5cdG1lc2hwaHlzaWNhbF9mcmFnOiBmcmFnbWVudCQ1LFxuXHRtZXNodG9vbl92ZXJ0OiB2ZXJ0ZXgkNCxcblx0bWVzaHRvb25fZnJhZzogZnJhZ21lbnQkNCxcblx0cG9pbnRzX3ZlcnQ6IHZlcnRleCQzLFxuXHRwb2ludHNfZnJhZzogZnJhZ21lbnQkMyxcblx0c2hhZG93X3ZlcnQ6IHZlcnRleCQyLFxuXHRzaGFkb3dfZnJhZzogZnJhZ21lbnQkMixcblx0c3ByaXRlX3ZlcnQ6IHZlcnRleCQxLFxuXHRzcHJpdGVfZnJhZzogZnJhZ21lbnQkMVxufTtcblxuLyoqXG4gKiBVbmlmb3JtcyBsaWJyYXJ5IGZvciBzaGFyZWQgd2ViZ2wgc2hhZGVyc1xuICovXG5cbmNvbnN0IFVuaWZvcm1zTGliID0ge1xuXHRjb21tb246IHtcblx0XHRkaWZmdXNlOiB7XG5cdFx0XHR2YWx1ZTogLypAX19QVVJFX18qL25ldyBDb2xvcigweGZmZmZmZilcblx0XHR9LFxuXHRcdG9wYWNpdHk6IHtcblx0XHRcdHZhbHVlOiAxLjBcblx0XHR9LFxuXHRcdG1hcDoge1xuXHRcdFx0dmFsdWU6IG51bGxcblx0XHR9LFxuXHRcdHV2VHJhbnNmb3JtOiB7XG5cdFx0XHR2YWx1ZTogLypAX19QVVJFX18qL25ldyBNYXRyaXgzKClcblx0XHR9LFxuXHRcdHV2MlRyYW5zZm9ybToge1xuXHRcdFx0dmFsdWU6IC8qQF9fUFVSRV9fKi9uZXcgTWF0cml4MygpXG5cdFx0fSxcblx0XHRhbHBoYU1hcDoge1xuXHRcdFx0dmFsdWU6IG51bGxcblx0XHR9LFxuXHRcdGFscGhhVGVzdDoge1xuXHRcdFx0dmFsdWU6IDBcblx0XHR9XG5cdH0sXG5cdHNwZWN1bGFybWFwOiB7XG5cdFx0c3BlY3VsYXJNYXA6IHtcblx0XHRcdHZhbHVlOiBudWxsXG5cdFx0fVxuXHR9LFxuXHRlbnZtYXA6IHtcblx0XHRlbnZNYXA6IHtcblx0XHRcdHZhbHVlOiBudWxsXG5cdFx0fSxcblx0XHRmbGlwRW52TWFwOiB7XG5cdFx0XHR2YWx1ZTogLTFcblx0XHR9LFxuXHRcdHJlZmxlY3Rpdml0eToge1xuXHRcdFx0dmFsdWU6IDEuMFxuXHRcdH0sXG5cdFx0Ly8gYmFzaWMsIGxhbWJlcnQsIHBob25nXG5cdFx0aW9yOiB7XG5cdFx0XHR2YWx1ZTogMS41XG5cdFx0fSxcblx0XHQvLyBwaHlzaWNhbFxuXHRcdHJlZnJhY3Rpb25SYXRpbzoge1xuXHRcdFx0dmFsdWU6IDAuOThcblx0XHR9IC8vIGJhc2ljLCBsYW1iZXJ0LCBwaG9uZ1xuXHR9LFxuXG5cdGFvbWFwOiB7XG5cdFx0YW9NYXA6IHtcblx0XHRcdHZhbHVlOiBudWxsXG5cdFx0fSxcblx0XHRhb01hcEludGVuc2l0eToge1xuXHRcdFx0dmFsdWU6IDFcblx0XHR9XG5cdH0sXG5cdGxpZ2h0bWFwOiB7XG5cdFx0bGlnaHRNYXA6IHtcblx0XHRcdHZhbHVlOiBudWxsXG5cdFx0fSxcblx0XHRsaWdodE1hcEludGVuc2l0eToge1xuXHRcdFx0dmFsdWU6IDFcblx0XHR9XG5cdH0sXG5cdGVtaXNzaXZlbWFwOiB7XG5cdFx0ZW1pc3NpdmVNYXA6IHtcblx0XHRcdHZhbHVlOiBudWxsXG5cdFx0fVxuXHR9LFxuXHRidW1wbWFwOiB7XG5cdFx0YnVtcE1hcDoge1xuXHRcdFx0dmFsdWU6IG51bGxcblx0XHR9LFxuXHRcdGJ1bXBTY2FsZToge1xuXHRcdFx0dmFsdWU6IDFcblx0XHR9XG5cdH0sXG5cdG5vcm1hbG1hcDoge1xuXHRcdG5vcm1hbE1hcDoge1xuXHRcdFx0dmFsdWU6IG51bGxcblx0XHR9LFxuXHRcdG5vcm1hbFNjYWxlOiB7XG5cdFx0XHR2YWx1ZTogLypAX19QVVJFX18qL25ldyBWZWN0b3IyKDEsIDEpXG5cdFx0fVxuXHR9LFxuXHRkaXNwbGFjZW1lbnRtYXA6IHtcblx0XHRkaXNwbGFjZW1lbnRNYXA6IHtcblx0XHRcdHZhbHVlOiBudWxsXG5cdFx0fSxcblx0XHRkaXNwbGFjZW1lbnRTY2FsZToge1xuXHRcdFx0dmFsdWU6IDFcblx0XHR9LFxuXHRcdGRpc3BsYWNlbWVudEJpYXM6IHtcblx0XHRcdHZhbHVlOiAwXG5cdFx0fVxuXHR9LFxuXHRyb3VnaG5lc3NtYXA6IHtcblx0XHRyb3VnaG5lc3NNYXA6IHtcblx0XHRcdHZhbHVlOiBudWxsXG5cdFx0fVxuXHR9LFxuXHRtZXRhbG5lc3NtYXA6IHtcblx0XHRtZXRhbG5lc3NNYXA6IHtcblx0XHRcdHZhbHVlOiBudWxsXG5cdFx0fVxuXHR9LFxuXHRncmFkaWVudG1hcDoge1xuXHRcdGdyYWRpZW50TWFwOiB7XG5cdFx0XHR2YWx1ZTogbnVsbFxuXHRcdH1cblx0fSxcblx0Zm9nOiB7XG5cdFx0Zm9nRGVuc2l0eToge1xuXHRcdFx0dmFsdWU6IDAuMDAwMjVcblx0XHR9LFxuXHRcdGZvZ05lYXI6IHtcblx0XHRcdHZhbHVlOiAxXG5cdFx0fSxcblx0XHRmb2dGYXI6IHtcblx0XHRcdHZhbHVlOiAyMDAwXG5cdFx0fSxcblx0XHRmb2dDb2xvcjoge1xuXHRcdFx0dmFsdWU6IC8qQF9fUFVSRV9fKi9uZXcgQ29sb3IoMHhmZmZmZmYpXG5cdFx0fVxuXHR9LFxuXHRsaWdodHM6IHtcblx0XHRhbWJpZW50TGlnaHRDb2xvcjoge1xuXHRcdFx0dmFsdWU6IFtdXG5cdFx0fSxcblx0XHRsaWdodFByb2JlOiB7XG5cdFx0XHR2YWx1ZTogW11cblx0XHR9LFxuXHRcdGRpcmVjdGlvbmFsTGlnaHRzOiB7XG5cdFx0XHR2YWx1ZTogW10sXG5cdFx0XHRwcm9wZXJ0aWVzOiB7XG5cdFx0XHRcdGRpcmVjdGlvbjoge30sXG5cdFx0XHRcdGNvbG9yOiB7fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZGlyZWN0aW9uYWxMaWdodFNoYWRvd3M6IHtcblx0XHRcdHZhbHVlOiBbXSxcblx0XHRcdHByb3BlcnRpZXM6IHtcblx0XHRcdFx0c2hhZG93Qmlhczoge30sXG5cdFx0XHRcdHNoYWRvd05vcm1hbEJpYXM6IHt9LFxuXHRcdFx0XHRzaGFkb3dSYWRpdXM6IHt9LFxuXHRcdFx0XHRzaGFkb3dNYXBTaXplOiB7fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZGlyZWN0aW9uYWxTaGFkb3dNYXA6IHtcblx0XHRcdHZhbHVlOiBbXVxuXHRcdH0sXG5cdFx0ZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXg6IHtcblx0XHRcdHZhbHVlOiBbXVxuXHRcdH0sXG5cdFx0c3BvdExpZ2h0czoge1xuXHRcdFx0dmFsdWU6IFtdLFxuXHRcdFx0cHJvcGVydGllczoge1xuXHRcdFx0XHRjb2xvcjoge30sXG5cdFx0XHRcdHBvc2l0aW9uOiB7fSxcblx0XHRcdFx0ZGlyZWN0aW9uOiB7fSxcblx0XHRcdFx0ZGlzdGFuY2U6IHt9LFxuXHRcdFx0XHRjb25lQ29zOiB7fSxcblx0XHRcdFx0cGVudW1icmFDb3M6IHt9LFxuXHRcdFx0XHRkZWNheToge31cblx0XHRcdH1cblx0XHR9LFxuXHRcdHNwb3RMaWdodFNoYWRvd3M6IHtcblx0XHRcdHZhbHVlOiBbXSxcblx0XHRcdHByb3BlcnRpZXM6IHtcblx0XHRcdFx0c2hhZG93Qmlhczoge30sXG5cdFx0XHRcdHNoYWRvd05vcm1hbEJpYXM6IHt9LFxuXHRcdFx0XHRzaGFkb3dSYWRpdXM6IHt9LFxuXHRcdFx0XHRzaGFkb3dNYXBTaXplOiB7fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c3BvdExpZ2h0TWFwOiB7XG5cdFx0XHR2YWx1ZTogW11cblx0XHR9LFxuXHRcdHNwb3RTaGFkb3dNYXA6IHtcblx0XHRcdHZhbHVlOiBbXVxuXHRcdH0sXG5cdFx0c3BvdExpZ2h0TWF0cml4OiB7XG5cdFx0XHR2YWx1ZTogW11cblx0XHR9LFxuXHRcdHBvaW50TGlnaHRzOiB7XG5cdFx0XHR2YWx1ZTogW10sXG5cdFx0XHRwcm9wZXJ0aWVzOiB7XG5cdFx0XHRcdGNvbG9yOiB7fSxcblx0XHRcdFx0cG9zaXRpb246IHt9LFxuXHRcdFx0XHRkZWNheToge30sXG5cdFx0XHRcdGRpc3RhbmNlOiB7fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0cG9pbnRMaWdodFNoYWRvd3M6IHtcblx0XHRcdHZhbHVlOiBbXSxcblx0XHRcdHByb3BlcnRpZXM6IHtcblx0XHRcdFx0c2hhZG93Qmlhczoge30sXG5cdFx0XHRcdHNoYWRvd05vcm1hbEJpYXM6IHt9LFxuXHRcdFx0XHRzaGFkb3dSYWRpdXM6IHt9LFxuXHRcdFx0XHRzaGFkb3dNYXBTaXplOiB7fSxcblx0XHRcdFx0c2hhZG93Q2FtZXJhTmVhcjoge30sXG5cdFx0XHRcdHNoYWRvd0NhbWVyYUZhcjoge31cblx0XHRcdH1cblx0XHR9LFxuXHRcdHBvaW50U2hhZG93TWFwOiB7XG5cdFx0XHR2YWx1ZTogW11cblx0XHR9LFxuXHRcdHBvaW50U2hhZG93TWF0cml4OiB7XG5cdFx0XHR2YWx1ZTogW11cblx0XHR9LFxuXHRcdGhlbWlzcGhlcmVMaWdodHM6IHtcblx0XHRcdHZhbHVlOiBbXSxcblx0XHRcdHByb3BlcnRpZXM6IHtcblx0XHRcdFx0ZGlyZWN0aW9uOiB7fSxcblx0XHRcdFx0c2t5Q29sb3I6IHt9LFxuXHRcdFx0XHRncm91bmRDb2xvcjoge31cblx0XHRcdH1cblx0XHR9LFxuXHRcdC8vIFRPRE8gKGFiZWxuYXRpb24pOiBSZWN0QXJlYUxpZ2h0IEJSREYgZGF0YSBuZWVkcyB0byBiZSBtb3ZlZCBmcm9tIGV4YW1wbGUgdG8gbWFpbiBzcmNcblx0XHRyZWN0QXJlYUxpZ2h0czoge1xuXHRcdFx0dmFsdWU6IFtdLFxuXHRcdFx0cHJvcGVydGllczoge1xuXHRcdFx0XHRjb2xvcjoge30sXG5cdFx0XHRcdHBvc2l0aW9uOiB7fSxcblx0XHRcdFx0d2lkdGg6IHt9LFxuXHRcdFx0XHRoZWlnaHQ6IHt9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRsdGNfMToge1xuXHRcdFx0dmFsdWU6IG51bGxcblx0XHR9LFxuXHRcdGx0Y18yOiB7XG5cdFx0XHR2YWx1ZTogbnVsbFxuXHRcdH1cblx0fSxcblx0cG9pbnRzOiB7XG5cdFx0ZGlmZnVzZToge1xuXHRcdFx0dmFsdWU6IC8qQF9fUFVSRV9fKi9uZXcgQ29sb3IoMHhmZmZmZmYpXG5cdFx0fSxcblx0XHRvcGFjaXR5OiB7XG5cdFx0XHR2YWx1ZTogMS4wXG5cdFx0fSxcblx0XHRzaXplOiB7XG5cdFx0XHR2YWx1ZTogMS4wXG5cdFx0fSxcblx0XHRzY2FsZToge1xuXHRcdFx0dmFsdWU6IDEuMFxuXHRcdH0sXG5cdFx0bWFwOiB7XG5cdFx0XHR2YWx1ZTogbnVsbFxuXHRcdH0sXG5cdFx0YWxwaGFNYXA6IHtcblx0XHRcdHZhbHVlOiBudWxsXG5cdFx0fSxcblx0XHRhbHBoYVRlc3Q6IHtcblx0XHRcdHZhbHVlOiAwXG5cdFx0fSxcblx0XHR1dlRyYW5zZm9ybToge1xuXHRcdFx0dmFsdWU6IC8qQF9fUFVSRV9fKi9uZXcgTWF0cml4MygpXG5cdFx0fVxuXHR9LFxuXHRzcHJpdGU6IHtcblx0XHRkaWZmdXNlOiB7XG5cdFx0XHR2YWx1ZTogLypAX19QVVJFX18qL25ldyBDb2xvcigweGZmZmZmZilcblx0XHR9LFxuXHRcdG9wYWNpdHk6IHtcblx0XHRcdHZhbHVlOiAxLjBcblx0XHR9LFxuXHRcdGNlbnRlcjoge1xuXHRcdFx0dmFsdWU6IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMigwLjUsIDAuNSlcblx0XHR9LFxuXHRcdHJvdGF0aW9uOiB7XG5cdFx0XHR2YWx1ZTogMC4wXG5cdFx0fSxcblx0XHRtYXA6IHtcblx0XHRcdHZhbHVlOiBudWxsXG5cdFx0fSxcblx0XHRhbHBoYU1hcDoge1xuXHRcdFx0dmFsdWU6IG51bGxcblx0XHR9LFxuXHRcdGFscGhhVGVzdDoge1xuXHRcdFx0dmFsdWU6IDBcblx0XHR9LFxuXHRcdHV2VHJhbnNmb3JtOiB7XG5cdFx0XHR2YWx1ZTogLypAX19QVVJFX18qL25ldyBNYXRyaXgzKClcblx0XHR9XG5cdH1cbn07XG5cbmNvbnN0IFNoYWRlckxpYiA9IHtcblx0YmFzaWM6IHtcblx0XHR1bmlmb3JtczogLypAX19QVVJFX18qL21lcmdlVW5pZm9ybXMoW1VuaWZvcm1zTGliLmNvbW1vbiwgVW5pZm9ybXNMaWIuc3BlY3VsYXJtYXAsIFVuaWZvcm1zTGliLmVudm1hcCwgVW5pZm9ybXNMaWIuYW9tYXAsIFVuaWZvcm1zTGliLmxpZ2h0bWFwLCBVbmlmb3Jtc0xpYi5mb2ddKSxcblx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hiYXNpY192ZXJ0LFxuXHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNoYmFzaWNfZnJhZ1xuXHR9LFxuXHRsYW1iZXJ0OiB7XG5cdFx0dW5pZm9ybXM6IC8qQF9fUFVSRV9fKi9tZXJnZVVuaWZvcm1zKFtVbmlmb3Jtc0xpYi5jb21tb24sIFVuaWZvcm1zTGliLnNwZWN1bGFybWFwLCBVbmlmb3Jtc0xpYi5lbnZtYXAsIFVuaWZvcm1zTGliLmFvbWFwLCBVbmlmb3Jtc0xpYi5saWdodG1hcCwgVW5pZm9ybXNMaWIuZW1pc3NpdmVtYXAsIFVuaWZvcm1zTGliLmJ1bXBtYXAsIFVuaWZvcm1zTGliLm5vcm1hbG1hcCwgVW5pZm9ybXNMaWIuZGlzcGxhY2VtZW50bWFwLCBVbmlmb3Jtc0xpYi5mb2csIFVuaWZvcm1zTGliLmxpZ2h0cywge1xuXHRcdFx0ZW1pc3NpdmU6IHtcblx0XHRcdFx0dmFsdWU6IC8qQF9fUFVSRV9fKi9uZXcgQ29sb3IoMHgwMDAwMDApXG5cdFx0XHR9XG5cdFx0fV0pLFxuXHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaGxhbWJlcnRfdmVydCxcblx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaGxhbWJlcnRfZnJhZ1xuXHR9LFxuXHRwaG9uZzoge1xuXHRcdHVuaWZvcm1zOiAvKkBfX1BVUkVfXyovbWVyZ2VVbmlmb3JtcyhbVW5pZm9ybXNMaWIuY29tbW9uLCBVbmlmb3Jtc0xpYi5zcGVjdWxhcm1hcCwgVW5pZm9ybXNMaWIuZW52bWFwLCBVbmlmb3Jtc0xpYi5hb21hcCwgVW5pZm9ybXNMaWIubGlnaHRtYXAsIFVuaWZvcm1zTGliLmVtaXNzaXZlbWFwLCBVbmlmb3Jtc0xpYi5idW1wbWFwLCBVbmlmb3Jtc0xpYi5ub3JtYWxtYXAsIFVuaWZvcm1zTGliLmRpc3BsYWNlbWVudG1hcCwgVW5pZm9ybXNMaWIuZm9nLCBVbmlmb3Jtc0xpYi5saWdodHMsIHtcblx0XHRcdGVtaXNzaXZlOiB7XG5cdFx0XHRcdHZhbHVlOiAvKkBfX1BVUkVfXyovbmV3IENvbG9yKDB4MDAwMDAwKVxuXHRcdFx0fSxcblx0XHRcdHNwZWN1bGFyOiB7XG5cdFx0XHRcdHZhbHVlOiAvKkBfX1BVUkVfXyovbmV3IENvbG9yKDB4MTExMTExKVxuXHRcdFx0fSxcblx0XHRcdHNoaW5pbmVzczoge1xuXHRcdFx0XHR2YWx1ZTogMzBcblx0XHRcdH1cblx0XHR9XSksXG5cdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNocGhvbmdfdmVydCxcblx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaHBob25nX2ZyYWdcblx0fSxcblx0c3RhbmRhcmQ6IHtcblx0XHR1bmlmb3JtczogLypAX19QVVJFX18qL21lcmdlVW5pZm9ybXMoW1VuaWZvcm1zTGliLmNvbW1vbiwgVW5pZm9ybXNMaWIuZW52bWFwLCBVbmlmb3Jtc0xpYi5hb21hcCwgVW5pZm9ybXNMaWIubGlnaHRtYXAsIFVuaWZvcm1zTGliLmVtaXNzaXZlbWFwLCBVbmlmb3Jtc0xpYi5idW1wbWFwLCBVbmlmb3Jtc0xpYi5ub3JtYWxtYXAsIFVuaWZvcm1zTGliLmRpc3BsYWNlbWVudG1hcCwgVW5pZm9ybXNMaWIucm91Z2huZXNzbWFwLCBVbmlmb3Jtc0xpYi5tZXRhbG5lc3NtYXAsIFVuaWZvcm1zTGliLmZvZywgVW5pZm9ybXNMaWIubGlnaHRzLCB7XG5cdFx0XHRlbWlzc2l2ZToge1xuXHRcdFx0XHR2YWx1ZTogLypAX19QVVJFX18qL25ldyBDb2xvcigweDAwMDAwMClcblx0XHRcdH0sXG5cdFx0XHRyb3VnaG5lc3M6IHtcblx0XHRcdFx0dmFsdWU6IDEuMFxuXHRcdFx0fSxcblx0XHRcdG1ldGFsbmVzczoge1xuXHRcdFx0XHR2YWx1ZTogMC4wXG5cdFx0XHR9LFxuXHRcdFx0ZW52TWFwSW50ZW5zaXR5OiB7XG5cdFx0XHRcdHZhbHVlOiAxXG5cdFx0XHR9IC8vIHRlbXBvcmFyeVxuXHRcdH1dKSxcblxuXHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaHBoeXNpY2FsX3ZlcnQsXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hwaHlzaWNhbF9mcmFnXG5cdH0sXG5cdHRvb246IHtcblx0XHR1bmlmb3JtczogLypAX19QVVJFX18qL21lcmdlVW5pZm9ybXMoW1VuaWZvcm1zTGliLmNvbW1vbiwgVW5pZm9ybXNMaWIuYW9tYXAsIFVuaWZvcm1zTGliLmxpZ2h0bWFwLCBVbmlmb3Jtc0xpYi5lbWlzc2l2ZW1hcCwgVW5pZm9ybXNMaWIuYnVtcG1hcCwgVW5pZm9ybXNMaWIubm9ybWFsbWFwLCBVbmlmb3Jtc0xpYi5kaXNwbGFjZW1lbnRtYXAsIFVuaWZvcm1zTGliLmdyYWRpZW50bWFwLCBVbmlmb3Jtc0xpYi5mb2csIFVuaWZvcm1zTGliLmxpZ2h0cywge1xuXHRcdFx0ZW1pc3NpdmU6IHtcblx0XHRcdFx0dmFsdWU6IC8qQF9fUFVSRV9fKi9uZXcgQ29sb3IoMHgwMDAwMDApXG5cdFx0XHR9XG5cdFx0fV0pLFxuXHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaHRvb25fdmVydCxcblx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaHRvb25fZnJhZ1xuXHR9LFxuXHRtYXRjYXA6IHtcblx0XHR1bmlmb3JtczogLypAX19QVVJFX18qL21lcmdlVW5pZm9ybXMoW1VuaWZvcm1zTGliLmNvbW1vbiwgVW5pZm9ybXNMaWIuYnVtcG1hcCwgVW5pZm9ybXNMaWIubm9ybWFsbWFwLCBVbmlmb3Jtc0xpYi5kaXNwbGFjZW1lbnRtYXAsIFVuaWZvcm1zTGliLmZvZywge1xuXHRcdFx0bWF0Y2FwOiB7XG5cdFx0XHRcdHZhbHVlOiBudWxsXG5cdFx0XHR9XG5cdFx0fV0pLFxuXHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaG1hdGNhcF92ZXJ0LFxuXHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNobWF0Y2FwX2ZyYWdcblx0fSxcblx0cG9pbnRzOiB7XG5cdFx0dW5pZm9ybXM6IC8qQF9fUFVSRV9fKi9tZXJnZVVuaWZvcm1zKFtVbmlmb3Jtc0xpYi5wb2ludHMsIFVuaWZvcm1zTGliLmZvZ10pLFxuXHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsucG9pbnRzX3ZlcnQsXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLnBvaW50c19mcmFnXG5cdH0sXG5cdGRhc2hlZDoge1xuXHRcdHVuaWZvcm1zOiAvKkBfX1BVUkVfXyovbWVyZ2VVbmlmb3JtcyhbVW5pZm9ybXNMaWIuY29tbW9uLCBVbmlmb3Jtc0xpYi5mb2csIHtcblx0XHRcdHNjYWxlOiB7XG5cdFx0XHRcdHZhbHVlOiAxXG5cdFx0XHR9LFxuXHRcdFx0ZGFzaFNpemU6IHtcblx0XHRcdFx0dmFsdWU6IDFcblx0XHRcdH0sXG5cdFx0XHR0b3RhbFNpemU6IHtcblx0XHRcdFx0dmFsdWU6IDJcblx0XHRcdH1cblx0XHR9XSksXG5cdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5saW5lZGFzaGVkX3ZlcnQsXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLmxpbmVkYXNoZWRfZnJhZ1xuXHR9LFxuXHRkZXB0aDoge1xuXHRcdHVuaWZvcm1zOiAvKkBfX1BVUkVfXyovbWVyZ2VVbmlmb3JtcyhbVW5pZm9ybXNMaWIuY29tbW9uLCBVbmlmb3Jtc0xpYi5kaXNwbGFjZW1lbnRtYXBdKSxcblx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLmRlcHRoX3ZlcnQsXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLmRlcHRoX2ZyYWdcblx0fSxcblx0bm9ybWFsOiB7XG5cdFx0dW5pZm9ybXM6IC8qQF9fUFVSRV9fKi9tZXJnZVVuaWZvcm1zKFtVbmlmb3Jtc0xpYi5jb21tb24sIFVuaWZvcm1zTGliLmJ1bXBtYXAsIFVuaWZvcm1zTGliLm5vcm1hbG1hcCwgVW5pZm9ybXNMaWIuZGlzcGxhY2VtZW50bWFwLCB7XG5cdFx0XHRvcGFjaXR5OiB7XG5cdFx0XHRcdHZhbHVlOiAxLjBcblx0XHRcdH1cblx0XHR9XSksXG5cdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNobm9ybWFsX3ZlcnQsXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hub3JtYWxfZnJhZ1xuXHR9LFxuXHRzcHJpdGU6IHtcblx0XHR1bmlmb3JtczogLypAX19QVVJFX18qL21lcmdlVW5pZm9ybXMoW1VuaWZvcm1zTGliLnNwcml0ZSwgVW5pZm9ybXNMaWIuZm9nXSksXG5cdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5zcHJpdGVfdmVydCxcblx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsuc3ByaXRlX2ZyYWdcblx0fSxcblx0YmFja2dyb3VuZDoge1xuXHRcdHVuaWZvcm1zOiB7XG5cdFx0XHR1dlRyYW5zZm9ybToge1xuXHRcdFx0XHR2YWx1ZTogLypAX19QVVJFX18qL25ldyBNYXRyaXgzKClcblx0XHRcdH0sXG5cdFx0XHR0MkQ6IHtcblx0XHRcdFx0dmFsdWU6IG51bGxcblx0XHRcdH1cblx0XHR9LFxuXHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsuYmFja2dyb3VuZF92ZXJ0LFxuXHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5iYWNrZ3JvdW5kX2ZyYWdcblx0fSxcblx0YmFja2dyb3VuZEN1YmU6IHtcblx0XHR1bmlmb3Jtczoge1xuXHRcdFx0ZW52TWFwOiB7XG5cdFx0XHRcdHZhbHVlOiBudWxsXG5cdFx0XHR9LFxuXHRcdFx0ZmxpcEVudk1hcDoge1xuXHRcdFx0XHR2YWx1ZTogLTFcblx0XHRcdH0sXG5cdFx0XHRiYWNrZ3JvdW5kQmx1cnJpbmVzczoge1xuXHRcdFx0XHR2YWx1ZTogMFxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5iYWNrZ3JvdW5kQ3ViZV92ZXJ0LFxuXHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5iYWNrZ3JvdW5kQ3ViZV9mcmFnXG5cdH0sXG5cdGN1YmU6IHtcblx0XHR1bmlmb3Jtczoge1xuXHRcdFx0dEN1YmU6IHtcblx0XHRcdFx0dmFsdWU6IG51bGxcblx0XHRcdH0sXG5cdFx0XHR0RmxpcDoge1xuXHRcdFx0XHR2YWx1ZTogLTFcblx0XHRcdH0sXG5cdFx0XHRvcGFjaXR5OiB7XG5cdFx0XHRcdHZhbHVlOiAxLjBcblx0XHRcdH1cblx0XHR9LFxuXHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsuY3ViZV92ZXJ0LFxuXHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5jdWJlX2ZyYWdcblx0fSxcblx0ZXF1aXJlY3Q6IHtcblx0XHR1bmlmb3Jtczoge1xuXHRcdFx0dEVxdWlyZWN0OiB7XG5cdFx0XHRcdHZhbHVlOiBudWxsXG5cdFx0XHR9XG5cdFx0fSxcblx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLmVxdWlyZWN0X3ZlcnQsXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLmVxdWlyZWN0X2ZyYWdcblx0fSxcblx0ZGlzdGFuY2VSR0JBOiB7XG5cdFx0dW5pZm9ybXM6IC8qQF9fUFVSRV9fKi9tZXJnZVVuaWZvcm1zKFtVbmlmb3Jtc0xpYi5jb21tb24sIFVuaWZvcm1zTGliLmRpc3BsYWNlbWVudG1hcCwge1xuXHRcdFx0cmVmZXJlbmNlUG9zaXRpb246IHtcblx0XHRcdFx0dmFsdWU6IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpXG5cdFx0XHR9LFxuXHRcdFx0bmVhckRpc3RhbmNlOiB7XG5cdFx0XHRcdHZhbHVlOiAxXG5cdFx0XHR9LFxuXHRcdFx0ZmFyRGlzdGFuY2U6IHtcblx0XHRcdFx0dmFsdWU6IDEwMDBcblx0XHRcdH1cblx0XHR9XSksXG5cdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5kaXN0YW5jZVJHQkFfdmVydCxcblx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsuZGlzdGFuY2VSR0JBX2ZyYWdcblx0fSxcblx0c2hhZG93OiB7XG5cdFx0dW5pZm9ybXM6IC8qQF9fUFVSRV9fKi9tZXJnZVVuaWZvcm1zKFtVbmlmb3Jtc0xpYi5saWdodHMsIFVuaWZvcm1zTGliLmZvZywge1xuXHRcdFx0Y29sb3I6IHtcblx0XHRcdFx0dmFsdWU6IC8qQF9fUFVSRV9fKi9uZXcgQ29sb3IoMHgwMDAwMClcblx0XHRcdH0sXG5cdFx0XHRvcGFjaXR5OiB7XG5cdFx0XHRcdHZhbHVlOiAxLjBcblx0XHRcdH1cblx0XHR9XSksXG5cdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5zaGFkb3dfdmVydCxcblx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsuc2hhZG93X2ZyYWdcblx0fVxufTtcblNoYWRlckxpYi5waHlzaWNhbCA9IHtcblx0dW5pZm9ybXM6IC8qQF9fUFVSRV9fKi9tZXJnZVVuaWZvcm1zKFtTaGFkZXJMaWIuc3RhbmRhcmQudW5pZm9ybXMsIHtcblx0XHRjbGVhcmNvYXQ6IHtcblx0XHRcdHZhbHVlOiAwXG5cdFx0fSxcblx0XHRjbGVhcmNvYXRNYXA6IHtcblx0XHRcdHZhbHVlOiBudWxsXG5cdFx0fSxcblx0XHRjbGVhcmNvYXRSb3VnaG5lc3M6IHtcblx0XHRcdHZhbHVlOiAwXG5cdFx0fSxcblx0XHRjbGVhcmNvYXRSb3VnaG5lc3NNYXA6IHtcblx0XHRcdHZhbHVlOiBudWxsXG5cdFx0fSxcblx0XHRjbGVhcmNvYXROb3JtYWxTY2FsZToge1xuXHRcdFx0dmFsdWU6IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMigxLCAxKVxuXHRcdH0sXG5cdFx0Y2xlYXJjb2F0Tm9ybWFsTWFwOiB7XG5cdFx0XHR2YWx1ZTogbnVsbFxuXHRcdH0sXG5cdFx0aXJpZGVzY2VuY2U6IHtcblx0XHRcdHZhbHVlOiAwXG5cdFx0fSxcblx0XHRpcmlkZXNjZW5jZU1hcDoge1xuXHRcdFx0dmFsdWU6IG51bGxcblx0XHR9LFxuXHRcdGlyaWRlc2NlbmNlSU9SOiB7XG5cdFx0XHR2YWx1ZTogMS4zXG5cdFx0fSxcblx0XHRpcmlkZXNjZW5jZVRoaWNrbmVzc01pbmltdW06IHtcblx0XHRcdHZhbHVlOiAxMDBcblx0XHR9LFxuXHRcdGlyaWRlc2NlbmNlVGhpY2tuZXNzTWF4aW11bToge1xuXHRcdFx0dmFsdWU6IDQwMFxuXHRcdH0sXG5cdFx0aXJpZGVzY2VuY2VUaGlja25lc3NNYXA6IHtcblx0XHRcdHZhbHVlOiBudWxsXG5cdFx0fSxcblx0XHRzaGVlbjoge1xuXHRcdFx0dmFsdWU6IDBcblx0XHR9LFxuXHRcdHNoZWVuQ29sb3I6IHtcblx0XHRcdHZhbHVlOiAvKkBfX1BVUkVfXyovbmV3IENvbG9yKDB4MDAwMDAwKVxuXHRcdH0sXG5cdFx0c2hlZW5Db2xvck1hcDoge1xuXHRcdFx0dmFsdWU6IG51bGxcblx0XHR9LFxuXHRcdHNoZWVuUm91Z2huZXNzOiB7XG5cdFx0XHR2YWx1ZTogMVxuXHRcdH0sXG5cdFx0c2hlZW5Sb3VnaG5lc3NNYXA6IHtcblx0XHRcdHZhbHVlOiBudWxsXG5cdFx0fSxcblx0XHR0cmFuc21pc3Npb246IHtcblx0XHRcdHZhbHVlOiAwXG5cdFx0fSxcblx0XHR0cmFuc21pc3Npb25NYXA6IHtcblx0XHRcdHZhbHVlOiBudWxsXG5cdFx0fSxcblx0XHR0cmFuc21pc3Npb25TYW1wbGVyU2l6ZToge1xuXHRcdFx0dmFsdWU6IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMigpXG5cdFx0fSxcblx0XHR0cmFuc21pc3Npb25TYW1wbGVyTWFwOiB7XG5cdFx0XHR2YWx1ZTogbnVsbFxuXHRcdH0sXG5cdFx0dGhpY2tuZXNzOiB7XG5cdFx0XHR2YWx1ZTogMFxuXHRcdH0sXG5cdFx0dGhpY2tuZXNzTWFwOiB7XG5cdFx0XHR2YWx1ZTogbnVsbFxuXHRcdH0sXG5cdFx0YXR0ZW51YXRpb25EaXN0YW5jZToge1xuXHRcdFx0dmFsdWU6IDBcblx0XHR9LFxuXHRcdGF0dGVudWF0aW9uQ29sb3I6IHtcblx0XHRcdHZhbHVlOiAvKkBfX1BVUkVfXyovbmV3IENvbG9yKDB4MDAwMDAwKVxuXHRcdH0sXG5cdFx0c3BlY3VsYXJJbnRlbnNpdHk6IHtcblx0XHRcdHZhbHVlOiAxXG5cdFx0fSxcblx0XHRzcGVjdWxhckludGVuc2l0eU1hcDoge1xuXHRcdFx0dmFsdWU6IG51bGxcblx0XHR9LFxuXHRcdHNwZWN1bGFyQ29sb3I6IHtcblx0XHRcdHZhbHVlOiAvKkBfX1BVUkVfXyovbmV3IENvbG9yKDEsIDEsIDEpXG5cdFx0fSxcblx0XHRzcGVjdWxhckNvbG9yTWFwOiB7XG5cdFx0XHR2YWx1ZTogbnVsbFxuXHRcdH1cblx0fV0pLFxuXHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hwaHlzaWNhbF92ZXJ0LFxuXHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaHBoeXNpY2FsX2ZyYWdcbn07XG5cbmZ1bmN0aW9uIFdlYkdMQmFja2dyb3VuZChyZW5kZXJlciwgY3ViZW1hcHMsIGN1YmV1dm1hcHMsIHN0YXRlLCBvYmplY3RzLCBhbHBoYSwgcHJlbXVsdGlwbGllZEFscGhhKSB7XG5cdGNvbnN0IGNsZWFyQ29sb3IgPSBuZXcgQ29sb3IoMHgwMDAwMDApO1xuXHRsZXQgY2xlYXJBbHBoYSA9IGFscGhhID09PSB0cnVlID8gMCA6IDE7XG5cdGxldCBwbGFuZU1lc2g7XG5cdGxldCBib3hNZXNoO1xuXHRsZXQgY3VycmVudEJhY2tncm91bmQgPSBudWxsO1xuXHRsZXQgY3VycmVudEJhY2tncm91bmRWZXJzaW9uID0gMDtcblx0bGV0IGN1cnJlbnRUb25lbWFwcGluZyA9IG51bGw7XG5cdGZ1bmN0aW9uIHJlbmRlcihyZW5kZXJMaXN0LCBzY2VuZSkge1xuXHRcdGxldCBmb3JjZUNsZWFyID0gZmFsc2U7XG5cdFx0bGV0IGJhY2tncm91bmQgPSBzY2VuZS5pc1NjZW5lID09PSB0cnVlID8gc2NlbmUuYmFja2dyb3VuZCA6IG51bGw7XG5cdFx0aWYgKGJhY2tncm91bmQgJiYgYmFja2dyb3VuZC5pc1RleHR1cmUpIHtcblx0XHRcdGNvbnN0IHVzZVBNUkVNID0gc2NlbmUuYmFja2dyb3VuZEJsdXJyaW5lc3MgPiAwOyAvLyB1c2UgUE1SRU0gaWYgdGhlIHVzZXIgd2FudHMgdG8gYmx1ciB0aGUgYmFja2dyb3VuZFxuXHRcdFx0YmFja2dyb3VuZCA9ICh1c2VQTVJFTSA/IGN1YmV1dm1hcHMgOiBjdWJlbWFwcykuZ2V0KGJhY2tncm91bmQpO1xuXHRcdH1cblxuXHRcdC8vIElnbm9yZSBiYWNrZ3JvdW5kIGluIEFSXG5cdFx0Ly8gVE9ETzogUmVjb25zaWRlciB0aGlzLlxuXG5cdFx0Y29uc3QgeHIgPSByZW5kZXJlci54cjtcblx0XHRjb25zdCBzZXNzaW9uID0geHIuZ2V0U2Vzc2lvbiAmJiB4ci5nZXRTZXNzaW9uKCk7XG5cdFx0aWYgKHNlc3Npb24gJiYgc2Vzc2lvbi5lbnZpcm9ubWVudEJsZW5kTW9kZSA9PT0gJ2FkZGl0aXZlJykge1xuXHRcdFx0YmFja2dyb3VuZCA9IG51bGw7XG5cdFx0fVxuXHRcdGlmIChiYWNrZ3JvdW5kID09PSBudWxsKSB7XG5cdFx0XHRzZXRDbGVhcihjbGVhckNvbG9yLCBjbGVhckFscGhhKTtcblx0XHR9IGVsc2UgaWYgKGJhY2tncm91bmQgJiYgYmFja2dyb3VuZC5pc0NvbG9yKSB7XG5cdFx0XHRzZXRDbGVhcihiYWNrZ3JvdW5kLCAxKTtcblx0XHRcdGZvcmNlQ2xlYXIgPSB0cnVlO1xuXHRcdH1cblx0XHRpZiAocmVuZGVyZXIuYXV0b0NsZWFyIHx8IGZvcmNlQ2xlYXIpIHtcblx0XHRcdHJlbmRlcmVyLmNsZWFyKHJlbmRlcmVyLmF1dG9DbGVhckNvbG9yLCByZW5kZXJlci5hdXRvQ2xlYXJEZXB0aCwgcmVuZGVyZXIuYXV0b0NsZWFyU3RlbmNpbCk7XG5cdFx0fVxuXHRcdGlmIChiYWNrZ3JvdW5kICYmIChiYWNrZ3JvdW5kLmlzQ3ViZVRleHR1cmUgfHwgYmFja2dyb3VuZC5tYXBwaW5nID09PSBDdWJlVVZSZWZsZWN0aW9uTWFwcGluZykpIHtcblx0XHRcdGlmIChib3hNZXNoID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Ym94TWVzaCA9IG5ldyBNZXNoKG5ldyBCb3hHZW9tZXRyeSgxLCAxLCAxKSwgbmV3IFNoYWRlck1hdGVyaWFsKHtcblx0XHRcdFx0XHRuYW1lOiAnQmFja2dyb3VuZEN1YmVNYXRlcmlhbCcsXG5cdFx0XHRcdFx0dW5pZm9ybXM6IGNsb25lVW5pZm9ybXMoU2hhZGVyTGliLmJhY2tncm91bmRDdWJlLnVuaWZvcm1zKSxcblx0XHRcdFx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckxpYi5iYWNrZ3JvdW5kQ3ViZS52ZXJ0ZXhTaGFkZXIsXG5cdFx0XHRcdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckxpYi5iYWNrZ3JvdW5kQ3ViZS5mcmFnbWVudFNoYWRlcixcblx0XHRcdFx0XHRzaWRlOiBCYWNrU2lkZSxcblx0XHRcdFx0XHRkZXB0aFRlc3Q6IGZhbHNlLFxuXHRcdFx0XHRcdGRlcHRoV3JpdGU6IGZhbHNlLFxuXHRcdFx0XHRcdGZvZzogZmFsc2Vcblx0XHRcdFx0fSkpO1xuXHRcdFx0XHRib3hNZXNoLmdlb21ldHJ5LmRlbGV0ZUF0dHJpYnV0ZSgnbm9ybWFsJyk7XG5cdFx0XHRcdGJveE1lc2guZ2VvbWV0cnkuZGVsZXRlQXR0cmlidXRlKCd1dicpO1xuXHRcdFx0XHRib3hNZXNoLm9uQmVmb3JlUmVuZGVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBzY2VuZSwgY2FtZXJhKSB7XG5cdFx0XHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5jb3B5UG9zaXRpb24oY2FtZXJhLm1hdHJpeFdvcmxkKTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvLyBhZGQgXCJlbnZNYXBcIiBtYXRlcmlhbCBwcm9wZXJ0eSBzbyB0aGUgcmVuZGVyZXIgY2FuIGV2YWx1YXRlIGl0IGxpa2UgZm9yIGJ1aWx0LWluIG1hdGVyaWFsc1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoYm94TWVzaC5tYXRlcmlhbCwgJ2Vudk1hcCcsIHtcblx0XHRcdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLnVuaWZvcm1zLmVudk1hcC52YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRvYmplY3RzLnVwZGF0ZShib3hNZXNoKTtcblx0XHRcdH1cblx0XHRcdGJveE1lc2gubWF0ZXJpYWwudW5pZm9ybXMuZW52TWFwLnZhbHVlID0gYmFja2dyb3VuZDtcblx0XHRcdGJveE1lc2gubWF0ZXJpYWwudW5pZm9ybXMuZmxpcEVudk1hcC52YWx1ZSA9IGJhY2tncm91bmQuaXNDdWJlVGV4dHVyZSAmJiBiYWNrZ3JvdW5kLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSA9PT0gZmFsc2UgPyAtMSA6IDE7XG5cdFx0XHRib3hNZXNoLm1hdGVyaWFsLnVuaWZvcm1zLmJhY2tncm91bmRCbHVycmluZXNzLnZhbHVlID0gc2NlbmUuYmFja2dyb3VuZEJsdXJyaW5lc3M7XG5cdFx0XHRpZiAoY3VycmVudEJhY2tncm91bmQgIT09IGJhY2tncm91bmQgfHwgY3VycmVudEJhY2tncm91bmRWZXJzaW9uICE9PSBiYWNrZ3JvdW5kLnZlcnNpb24gfHwgY3VycmVudFRvbmVtYXBwaW5nICE9PSByZW5kZXJlci50b25lTWFwcGluZykge1xuXHRcdFx0XHRib3hNZXNoLm1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0Y3VycmVudEJhY2tncm91bmQgPSBiYWNrZ3JvdW5kO1xuXHRcdFx0XHRjdXJyZW50QmFja2dyb3VuZFZlcnNpb24gPSBiYWNrZ3JvdW5kLnZlcnNpb247XG5cdFx0XHRcdGN1cnJlbnRUb25lbWFwcGluZyA9IHJlbmRlcmVyLnRvbmVNYXBwaW5nO1xuXHRcdFx0fVxuXHRcdFx0Ym94TWVzaC5sYXllcnMuZW5hYmxlQWxsKCk7XG5cblx0XHRcdC8vIHB1c2ggdG8gdGhlIHByZS1zb3J0ZWQgb3BhcXVlIHJlbmRlciBsaXN0XG5cdFx0XHRyZW5kZXJMaXN0LnVuc2hpZnQoYm94TWVzaCwgYm94TWVzaC5nZW9tZXRyeSwgYm94TWVzaC5tYXRlcmlhbCwgMCwgMCwgbnVsbCk7XG5cdFx0fSBlbHNlIGlmIChiYWNrZ3JvdW5kICYmIGJhY2tncm91bmQuaXNUZXh0dXJlKSB7XG5cdFx0XHRpZiAocGxhbmVNZXNoID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cGxhbmVNZXNoID0gbmV3IE1lc2gobmV3IFBsYW5lR2VvbWV0cnkoMiwgMiksIG5ldyBTaGFkZXJNYXRlcmlhbCh7XG5cdFx0XHRcdFx0bmFtZTogJ0JhY2tncm91bmRNYXRlcmlhbCcsXG5cdFx0XHRcdFx0dW5pZm9ybXM6IGNsb25lVW5pZm9ybXMoU2hhZGVyTGliLmJhY2tncm91bmQudW5pZm9ybXMpLFxuXHRcdFx0XHRcdHZlcnRleFNoYWRlcjogU2hhZGVyTGliLmJhY2tncm91bmQudmVydGV4U2hhZGVyLFxuXHRcdFx0XHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJMaWIuYmFja2dyb3VuZC5mcmFnbWVudFNoYWRlcixcblx0XHRcdFx0XHRzaWRlOiBGcm9udFNpZGUsXG5cdFx0XHRcdFx0ZGVwdGhUZXN0OiBmYWxzZSxcblx0XHRcdFx0XHRkZXB0aFdyaXRlOiBmYWxzZSxcblx0XHRcdFx0XHRmb2c6IGZhbHNlXG5cdFx0XHRcdH0pKTtcblx0XHRcdFx0cGxhbmVNZXNoLmdlb21ldHJ5LmRlbGV0ZUF0dHJpYnV0ZSgnbm9ybWFsJyk7XG5cblx0XHRcdFx0Ly8gYWRkIFwibWFwXCIgbWF0ZXJpYWwgcHJvcGVydHkgc28gdGhlIHJlbmRlcmVyIGNhbiBldmFsdWF0ZSBpdCBsaWtlIGZvciBidWlsdC1pbiBtYXRlcmlhbHNcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHBsYW5lTWVzaC5tYXRlcmlhbCwgJ21hcCcsIHtcblx0XHRcdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLnVuaWZvcm1zLnQyRC52YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRvYmplY3RzLnVwZGF0ZShwbGFuZU1lc2gpO1xuXHRcdFx0fVxuXHRcdFx0cGxhbmVNZXNoLm1hdGVyaWFsLnVuaWZvcm1zLnQyRC52YWx1ZSA9IGJhY2tncm91bmQ7XG5cdFx0XHRpZiAoYmFja2dyb3VuZC5tYXRyaXhBdXRvVXBkYXRlID09PSB0cnVlKSB7XG5cdFx0XHRcdGJhY2tncm91bmQudXBkYXRlTWF0cml4KCk7XG5cdFx0XHR9XG5cdFx0XHRwbGFuZU1lc2gubWF0ZXJpYWwudW5pZm9ybXMudXZUcmFuc2Zvcm0udmFsdWUuY29weShiYWNrZ3JvdW5kLm1hdHJpeCk7XG5cdFx0XHRpZiAoY3VycmVudEJhY2tncm91bmQgIT09IGJhY2tncm91bmQgfHwgY3VycmVudEJhY2tncm91bmRWZXJzaW9uICE9PSBiYWNrZ3JvdW5kLnZlcnNpb24gfHwgY3VycmVudFRvbmVtYXBwaW5nICE9PSByZW5kZXJlci50b25lTWFwcGluZykge1xuXHRcdFx0XHRwbGFuZU1lc2gubWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRjdXJyZW50QmFja2dyb3VuZCA9IGJhY2tncm91bmQ7XG5cdFx0XHRcdGN1cnJlbnRCYWNrZ3JvdW5kVmVyc2lvbiA9IGJhY2tncm91bmQudmVyc2lvbjtcblx0XHRcdFx0Y3VycmVudFRvbmVtYXBwaW5nID0gcmVuZGVyZXIudG9uZU1hcHBpbmc7XG5cdFx0XHR9XG5cdFx0XHRwbGFuZU1lc2gubGF5ZXJzLmVuYWJsZUFsbCgpO1xuXG5cdFx0XHQvLyBwdXNoIHRvIHRoZSBwcmUtc29ydGVkIG9wYXF1ZSByZW5kZXIgbGlzdFxuXHRcdFx0cmVuZGVyTGlzdC51bnNoaWZ0KHBsYW5lTWVzaCwgcGxhbmVNZXNoLmdlb21ldHJ5LCBwbGFuZU1lc2gubWF0ZXJpYWwsIDAsIDAsIG51bGwpO1xuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBzZXRDbGVhcihjb2xvciwgYWxwaGEpIHtcblx0XHRzdGF0ZS5idWZmZXJzLmNvbG9yLnNldENsZWFyKGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIsIGFscGhhLCBwcmVtdWx0aXBsaWVkQWxwaGEpO1xuXHR9XG5cdHJldHVybiB7XG5cdFx0Z2V0Q2xlYXJDb2xvcjogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGNsZWFyQ29sb3I7XG5cdFx0fSxcblx0XHRzZXRDbGVhckNvbG9yOiBmdW5jdGlvbiAoY29sb3IsIGFscGhhID0gMSkge1xuXHRcdFx0Y2xlYXJDb2xvci5zZXQoY29sb3IpO1xuXHRcdFx0Y2xlYXJBbHBoYSA9IGFscGhhO1xuXHRcdFx0c2V0Q2xlYXIoY2xlYXJDb2xvciwgY2xlYXJBbHBoYSk7XG5cdFx0fSxcblx0XHRnZXRDbGVhckFscGhhOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gY2xlYXJBbHBoYTtcblx0XHR9LFxuXHRcdHNldENsZWFyQWxwaGE6IGZ1bmN0aW9uIChhbHBoYSkge1xuXHRcdFx0Y2xlYXJBbHBoYSA9IGFscGhhO1xuXHRcdFx0c2V0Q2xlYXIoY2xlYXJDb2xvciwgY2xlYXJBbHBoYSk7XG5cdFx0fSxcblx0XHRyZW5kZXI6IHJlbmRlclxuXHR9O1xufVxuXG5mdW5jdGlvbiBXZWJHTEJpbmRpbmdTdGF0ZXMoZ2wsIGV4dGVuc2lvbnMsIGF0dHJpYnV0ZXMsIGNhcGFiaWxpdGllcykge1xuXHRjb25zdCBtYXhWZXJ0ZXhBdHRyaWJ1dGVzID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9WRVJURVhfQVRUUklCUyk7XG5cdGNvbnN0IGV4dGVuc2lvbiA9IGNhcGFiaWxpdGllcy5pc1dlYkdMMiA/IG51bGwgOiBleHRlbnNpb25zLmdldCgnT0VTX3ZlcnRleF9hcnJheV9vYmplY3QnKTtcblx0Y29uc3QgdmFvQXZhaWxhYmxlID0gY2FwYWJpbGl0aWVzLmlzV2ViR0wyIHx8IGV4dGVuc2lvbiAhPT0gbnVsbDtcblx0Y29uc3QgYmluZGluZ1N0YXRlcyA9IHt9O1xuXHRjb25zdCBkZWZhdWx0U3RhdGUgPSBjcmVhdGVCaW5kaW5nU3RhdGUobnVsbCk7XG5cdGxldCBjdXJyZW50U3RhdGUgPSBkZWZhdWx0U3RhdGU7XG5cdGxldCBmb3JjZVVwZGF0ZSA9IGZhbHNlO1xuXHRmdW5jdGlvbiBzZXR1cChvYmplY3QsIG1hdGVyaWFsLCBwcm9ncmFtLCBnZW9tZXRyeSwgaW5kZXgpIHtcblx0XHRsZXQgdXBkYXRlQnVmZmVycyA9IGZhbHNlO1xuXHRcdGlmICh2YW9BdmFpbGFibGUpIHtcblx0XHRcdGNvbnN0IHN0YXRlID0gZ2V0QmluZGluZ1N0YXRlKGdlb21ldHJ5LCBwcm9ncmFtLCBtYXRlcmlhbCk7XG5cdFx0XHRpZiAoY3VycmVudFN0YXRlICE9PSBzdGF0ZSkge1xuXHRcdFx0XHRjdXJyZW50U3RhdGUgPSBzdGF0ZTtcblx0XHRcdFx0YmluZFZlcnRleEFycmF5T2JqZWN0KGN1cnJlbnRTdGF0ZS5vYmplY3QpO1xuXHRcdFx0fVxuXHRcdFx0dXBkYXRlQnVmZmVycyA9IG5lZWRzVXBkYXRlKG9iamVjdCwgZ2VvbWV0cnksIHByb2dyYW0sIGluZGV4KTtcblx0XHRcdGlmICh1cGRhdGVCdWZmZXJzKSBzYXZlQ2FjaGUob2JqZWN0LCBnZW9tZXRyeSwgcHJvZ3JhbSwgaW5kZXgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCB3aXJlZnJhbWUgPSBtYXRlcmlhbC53aXJlZnJhbWUgPT09IHRydWU7XG5cdFx0XHRpZiAoY3VycmVudFN0YXRlLmdlb21ldHJ5ICE9PSBnZW9tZXRyeS5pZCB8fCBjdXJyZW50U3RhdGUucHJvZ3JhbSAhPT0gcHJvZ3JhbS5pZCB8fCBjdXJyZW50U3RhdGUud2lyZWZyYW1lICE9PSB3aXJlZnJhbWUpIHtcblx0XHRcdFx0Y3VycmVudFN0YXRlLmdlb21ldHJ5ID0gZ2VvbWV0cnkuaWQ7XG5cdFx0XHRcdGN1cnJlbnRTdGF0ZS5wcm9ncmFtID0gcHJvZ3JhbS5pZDtcblx0XHRcdFx0Y3VycmVudFN0YXRlLndpcmVmcmFtZSA9IHdpcmVmcmFtZTtcblx0XHRcdFx0dXBkYXRlQnVmZmVycyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChpbmRleCAhPT0gbnVsbCkge1xuXHRcdFx0YXR0cmlidXRlcy51cGRhdGUoaW5kZXgsIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSKTtcblx0XHR9XG5cdFx0aWYgKHVwZGF0ZUJ1ZmZlcnMgfHwgZm9yY2VVcGRhdGUpIHtcblx0XHRcdGZvcmNlVXBkYXRlID0gZmFsc2U7XG5cdFx0XHRzZXR1cFZlcnRleEF0dHJpYnV0ZXMob2JqZWN0LCBtYXRlcmlhbCwgcHJvZ3JhbSwgZ2VvbWV0cnkpO1xuXHRcdFx0aWYgKGluZGV4ICE9PSBudWxsKSB7XG5cdFx0XHRcdGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGF0dHJpYnV0ZXMuZ2V0KGluZGV4KS5idWZmZXIpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVWZXJ0ZXhBcnJheU9iamVjdCgpIHtcblx0XHRpZiAoY2FwYWJpbGl0aWVzLmlzV2ViR0wyKSByZXR1cm4gZ2wuY3JlYXRlVmVydGV4QXJyYXkoKTtcblx0XHRyZXR1cm4gZXh0ZW5zaW9uLmNyZWF0ZVZlcnRleEFycmF5T0VTKCk7XG5cdH1cblx0ZnVuY3Rpb24gYmluZFZlcnRleEFycmF5T2JqZWN0KHZhbykge1xuXHRcdGlmIChjYXBhYmlsaXRpZXMuaXNXZWJHTDIpIHJldHVybiBnbC5iaW5kVmVydGV4QXJyYXkodmFvKTtcblx0XHRyZXR1cm4gZXh0ZW5zaW9uLmJpbmRWZXJ0ZXhBcnJheU9FUyh2YW8pO1xuXHR9XG5cdGZ1bmN0aW9uIGRlbGV0ZVZlcnRleEFycmF5T2JqZWN0KHZhbykge1xuXHRcdGlmIChjYXBhYmlsaXRpZXMuaXNXZWJHTDIpIHJldHVybiBnbC5kZWxldGVWZXJ0ZXhBcnJheSh2YW8pO1xuXHRcdHJldHVybiBleHRlbnNpb24uZGVsZXRlVmVydGV4QXJyYXlPRVModmFvKTtcblx0fVxuXHRmdW5jdGlvbiBnZXRCaW5kaW5nU3RhdGUoZ2VvbWV0cnksIHByb2dyYW0sIG1hdGVyaWFsKSB7XG5cdFx0Y29uc3Qgd2lyZWZyYW1lID0gbWF0ZXJpYWwud2lyZWZyYW1lID09PSB0cnVlO1xuXHRcdGxldCBwcm9ncmFtTWFwID0gYmluZGluZ1N0YXRlc1tnZW9tZXRyeS5pZF07XG5cdFx0aWYgKHByb2dyYW1NYXAgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cHJvZ3JhbU1hcCA9IHt9O1xuXHRcdFx0YmluZGluZ1N0YXRlc1tnZW9tZXRyeS5pZF0gPSBwcm9ncmFtTWFwO1xuXHRcdH1cblx0XHRsZXQgc3RhdGVNYXAgPSBwcm9ncmFtTWFwW3Byb2dyYW0uaWRdO1xuXHRcdGlmIChzdGF0ZU1hcCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRzdGF0ZU1hcCA9IHt9O1xuXHRcdFx0cHJvZ3JhbU1hcFtwcm9ncmFtLmlkXSA9IHN0YXRlTWFwO1xuXHRcdH1cblx0XHRsZXQgc3RhdGUgPSBzdGF0ZU1hcFt3aXJlZnJhbWVdO1xuXHRcdGlmIChzdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRzdGF0ZSA9IGNyZWF0ZUJpbmRpbmdTdGF0ZShjcmVhdGVWZXJ0ZXhBcnJheU9iamVjdCgpKTtcblx0XHRcdHN0YXRlTWFwW3dpcmVmcmFtZV0gPSBzdGF0ZTtcblx0XHR9XG5cdFx0cmV0dXJuIHN0YXRlO1xuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZUJpbmRpbmdTdGF0ZSh2YW8pIHtcblx0XHRjb25zdCBuZXdBdHRyaWJ1dGVzID0gW107XG5cdFx0Y29uc3QgZW5hYmxlZEF0dHJpYnV0ZXMgPSBbXTtcblx0XHRjb25zdCBhdHRyaWJ1dGVEaXZpc29ycyA9IFtdO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbWF4VmVydGV4QXR0cmlidXRlczsgaSsrKSB7XG5cdFx0XHRuZXdBdHRyaWJ1dGVzW2ldID0gMDtcblx0XHRcdGVuYWJsZWRBdHRyaWJ1dGVzW2ldID0gMDtcblx0XHRcdGF0dHJpYnV0ZURpdmlzb3JzW2ldID0gMDtcblx0XHR9XG5cdFx0cmV0dXJuIHtcblx0XHRcdC8vIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IG9uIG5vbi1WQU8gc3VwcG9ydCBicm93c2VyXG5cdFx0XHRnZW9tZXRyeTogbnVsbCxcblx0XHRcdHByb2dyYW06IG51bGwsXG5cdFx0XHR3aXJlZnJhbWU6IGZhbHNlLFxuXHRcdFx0bmV3QXR0cmlidXRlczogbmV3QXR0cmlidXRlcyxcblx0XHRcdGVuYWJsZWRBdHRyaWJ1dGVzOiBlbmFibGVkQXR0cmlidXRlcyxcblx0XHRcdGF0dHJpYnV0ZURpdmlzb3JzOiBhdHRyaWJ1dGVEaXZpc29ycyxcblx0XHRcdG9iamVjdDogdmFvLFxuXHRcdFx0YXR0cmlidXRlczoge30sXG5cdFx0XHRpbmRleDogbnVsbFxuXHRcdH07XG5cdH1cblx0ZnVuY3Rpb24gbmVlZHNVcGRhdGUob2JqZWN0LCBnZW9tZXRyeSwgcHJvZ3JhbSwgaW5kZXgpIHtcblx0XHRjb25zdCBjYWNoZWRBdHRyaWJ1dGVzID0gY3VycmVudFN0YXRlLmF0dHJpYnV0ZXM7XG5cdFx0Y29uc3QgZ2VvbWV0cnlBdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcblx0XHRsZXQgYXR0cmlidXRlc051bSA9IDA7XG5cdFx0Y29uc3QgcHJvZ3JhbUF0dHJpYnV0ZXMgPSBwcm9ncmFtLmdldEF0dHJpYnV0ZXMoKTtcblx0XHRmb3IgKGNvbnN0IG5hbWUgaW4gcHJvZ3JhbUF0dHJpYnV0ZXMpIHtcblx0XHRcdGNvbnN0IHByb2dyYW1BdHRyaWJ1dGUgPSBwcm9ncmFtQXR0cmlidXRlc1tuYW1lXTtcblx0XHRcdGlmIChwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uID49IDApIHtcblx0XHRcdFx0Y29uc3QgY2FjaGVkQXR0cmlidXRlID0gY2FjaGVkQXR0cmlidXRlc1tuYW1lXTtcblx0XHRcdFx0bGV0IGdlb21ldHJ5QXR0cmlidXRlID0gZ2VvbWV0cnlBdHRyaWJ1dGVzW25hbWVdO1xuXHRcdFx0XHRpZiAoZ2VvbWV0cnlBdHRyaWJ1dGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGlmIChuYW1lID09PSAnaW5zdGFuY2VNYXRyaXgnICYmIG9iamVjdC5pbnN0YW5jZU1hdHJpeCkgZ2VvbWV0cnlBdHRyaWJ1dGUgPSBvYmplY3QuaW5zdGFuY2VNYXRyaXg7XG5cdFx0XHRcdFx0aWYgKG5hbWUgPT09ICdpbnN0YW5jZUNvbG9yJyAmJiBvYmplY3QuaW5zdGFuY2VDb2xvcikgZ2VvbWV0cnlBdHRyaWJ1dGUgPSBvYmplY3QuaW5zdGFuY2VDb2xvcjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoY2FjaGVkQXR0cmlidXRlID09PSB1bmRlZmluZWQpIHJldHVybiB0cnVlO1xuXHRcdFx0XHRpZiAoY2FjaGVkQXR0cmlidXRlLmF0dHJpYnV0ZSAhPT0gZ2VvbWV0cnlBdHRyaWJ1dGUpIHJldHVybiB0cnVlO1xuXHRcdFx0XHRpZiAoZ2VvbWV0cnlBdHRyaWJ1dGUgJiYgY2FjaGVkQXR0cmlidXRlLmRhdGEgIT09IGdlb21ldHJ5QXR0cmlidXRlLmRhdGEpIHJldHVybiB0cnVlO1xuXHRcdFx0XHRhdHRyaWJ1dGVzTnVtKys7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChjdXJyZW50U3RhdGUuYXR0cmlidXRlc051bSAhPT0gYXR0cmlidXRlc051bSkgcmV0dXJuIHRydWU7XG5cdFx0aWYgKGN1cnJlbnRTdGF0ZS5pbmRleCAhPT0gaW5kZXgpIHJldHVybiB0cnVlO1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRmdW5jdGlvbiBzYXZlQ2FjaGUob2JqZWN0LCBnZW9tZXRyeSwgcHJvZ3JhbSwgaW5kZXgpIHtcblx0XHRjb25zdCBjYWNoZSA9IHt9O1xuXHRcdGNvbnN0IGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuXHRcdGxldCBhdHRyaWJ1dGVzTnVtID0gMDtcblx0XHRjb25zdCBwcm9ncmFtQXR0cmlidXRlcyA9IHByb2dyYW0uZ2V0QXR0cmlidXRlcygpO1xuXHRcdGZvciAoY29uc3QgbmFtZSBpbiBwcm9ncmFtQXR0cmlidXRlcykge1xuXHRcdFx0Y29uc3QgcHJvZ3JhbUF0dHJpYnV0ZSA9IHByb2dyYW1BdHRyaWJ1dGVzW25hbWVdO1xuXHRcdFx0aWYgKHByb2dyYW1BdHRyaWJ1dGUubG9jYXRpb24gPj0gMCkge1xuXHRcdFx0XHRsZXQgYXR0cmlidXRlID0gYXR0cmlidXRlc1tuYW1lXTtcblx0XHRcdFx0aWYgKGF0dHJpYnV0ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0aWYgKG5hbWUgPT09ICdpbnN0YW5jZU1hdHJpeCcgJiYgb2JqZWN0Lmluc3RhbmNlTWF0cml4KSBhdHRyaWJ1dGUgPSBvYmplY3QuaW5zdGFuY2VNYXRyaXg7XG5cdFx0XHRcdFx0aWYgKG5hbWUgPT09ICdpbnN0YW5jZUNvbG9yJyAmJiBvYmplY3QuaW5zdGFuY2VDb2xvcikgYXR0cmlidXRlID0gb2JqZWN0Lmluc3RhbmNlQ29sb3I7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29uc3QgZGF0YSA9IHt9O1xuXHRcdFx0XHRkYXRhLmF0dHJpYnV0ZSA9IGF0dHJpYnV0ZTtcblx0XHRcdFx0aWYgKGF0dHJpYnV0ZSAmJiBhdHRyaWJ1dGUuZGF0YSkge1xuXHRcdFx0XHRcdGRhdGEuZGF0YSA9IGF0dHJpYnV0ZS5kYXRhO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhY2hlW25hbWVdID0gZGF0YTtcblx0XHRcdFx0YXR0cmlidXRlc051bSsrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRjdXJyZW50U3RhdGUuYXR0cmlidXRlcyA9IGNhY2hlO1xuXHRcdGN1cnJlbnRTdGF0ZS5hdHRyaWJ1dGVzTnVtID0gYXR0cmlidXRlc051bTtcblx0XHRjdXJyZW50U3RhdGUuaW5kZXggPSBpbmRleDtcblx0fVxuXHRmdW5jdGlvbiBpbml0QXR0cmlidXRlcygpIHtcblx0XHRjb25zdCBuZXdBdHRyaWJ1dGVzID0gY3VycmVudFN0YXRlLm5ld0F0dHJpYnV0ZXM7XG5cdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gbmV3QXR0cmlidXRlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRuZXdBdHRyaWJ1dGVzW2ldID0gMDtcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gZW5hYmxlQXR0cmlidXRlKGF0dHJpYnV0ZSkge1xuXHRcdGVuYWJsZUF0dHJpYnV0ZUFuZERpdmlzb3IoYXR0cmlidXRlLCAwKTtcblx0fVxuXHRmdW5jdGlvbiBlbmFibGVBdHRyaWJ1dGVBbmREaXZpc29yKGF0dHJpYnV0ZSwgbWVzaFBlckF0dHJpYnV0ZSkge1xuXHRcdGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSBjdXJyZW50U3RhdGUubmV3QXR0cmlidXRlcztcblx0XHRjb25zdCBlbmFibGVkQXR0cmlidXRlcyA9IGN1cnJlbnRTdGF0ZS5lbmFibGVkQXR0cmlidXRlcztcblx0XHRjb25zdCBhdHRyaWJ1dGVEaXZpc29ycyA9IGN1cnJlbnRTdGF0ZS5hdHRyaWJ1dGVEaXZpc29ycztcblx0XHRuZXdBdHRyaWJ1dGVzW2F0dHJpYnV0ZV0gPSAxO1xuXHRcdGlmIChlbmFibGVkQXR0cmlidXRlc1thdHRyaWJ1dGVdID09PSAwKSB7XG5cdFx0XHRnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhdHRyaWJ1dGUpO1xuXHRcdFx0ZW5hYmxlZEF0dHJpYnV0ZXNbYXR0cmlidXRlXSA9IDE7XG5cdFx0fVxuXHRcdGlmIChhdHRyaWJ1dGVEaXZpc29yc1thdHRyaWJ1dGVdICE9PSBtZXNoUGVyQXR0cmlidXRlKSB7XG5cdFx0XHRjb25zdCBleHRlbnNpb24gPSBjYXBhYmlsaXRpZXMuaXNXZWJHTDIgPyBnbCA6IGV4dGVuc2lvbnMuZ2V0KCdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyk7XG5cdFx0XHRleHRlbnNpb25bY2FwYWJpbGl0aWVzLmlzV2ViR0wyID8gJ3ZlcnRleEF0dHJpYkRpdmlzb3InIDogJ3ZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRSddKGF0dHJpYnV0ZSwgbWVzaFBlckF0dHJpYnV0ZSk7XG5cdFx0XHRhdHRyaWJ1dGVEaXZpc29yc1thdHRyaWJ1dGVdID0gbWVzaFBlckF0dHJpYnV0ZTtcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKSB7XG5cdFx0Y29uc3QgbmV3QXR0cmlidXRlcyA9IGN1cnJlbnRTdGF0ZS5uZXdBdHRyaWJ1dGVzO1xuXHRcdGNvbnN0IGVuYWJsZWRBdHRyaWJ1dGVzID0gY3VycmVudFN0YXRlLmVuYWJsZWRBdHRyaWJ1dGVzO1xuXHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IGVuYWJsZWRBdHRyaWJ1dGVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdGlmIChlbmFibGVkQXR0cmlidXRlc1tpXSAhPT0gbmV3QXR0cmlidXRlc1tpXSkge1xuXHRcdFx0XHRnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoaSk7XG5cdFx0XHRcdGVuYWJsZWRBdHRyaWJ1dGVzW2ldID0gMDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gdmVydGV4QXR0cmliUG9pbnRlcihpbmRleCwgc2l6ZSwgdHlwZSwgbm9ybWFsaXplZCwgc3RyaWRlLCBvZmZzZXQpIHtcblx0XHRpZiAoY2FwYWJpbGl0aWVzLmlzV2ViR0wyID09PSB0cnVlICYmICh0eXBlID09PSBnbC5JTlQgfHwgdHlwZSA9PT0gZ2wuVU5TSUdORURfSU5UKSkge1xuXHRcdFx0Z2wudmVydGV4QXR0cmliSVBvaW50ZXIoaW5kZXgsIHNpemUsIHR5cGUsIHN0cmlkZSwgb2Zmc2V0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Z2wudmVydGV4QXR0cmliUG9pbnRlcihpbmRleCwgc2l6ZSwgdHlwZSwgbm9ybWFsaXplZCwgc3RyaWRlLCBvZmZzZXQpO1xuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBzZXR1cFZlcnRleEF0dHJpYnV0ZXMob2JqZWN0LCBtYXRlcmlhbCwgcHJvZ3JhbSwgZ2VvbWV0cnkpIHtcblx0XHRpZiAoY2FwYWJpbGl0aWVzLmlzV2ViR0wyID09PSBmYWxzZSAmJiAob2JqZWN0LmlzSW5zdGFuY2VkTWVzaCB8fCBnZW9tZXRyeS5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5KSkge1xuXHRcdFx0aWYgKGV4dGVuc2lvbnMuZ2V0KCdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJykgPT09IG51bGwpIHJldHVybjtcblx0XHR9XG5cdFx0aW5pdEF0dHJpYnV0ZXMoKTtcblx0XHRjb25zdCBnZW9tZXRyeUF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuXHRcdGNvbnN0IHByb2dyYW1BdHRyaWJ1dGVzID0gcHJvZ3JhbS5nZXRBdHRyaWJ1dGVzKCk7XG5cdFx0Y29uc3QgbWF0ZXJpYWxEZWZhdWx0QXR0cmlidXRlVmFsdWVzID0gbWF0ZXJpYWwuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlcztcblx0XHRmb3IgKGNvbnN0IG5hbWUgaW4gcHJvZ3JhbUF0dHJpYnV0ZXMpIHtcblx0XHRcdGNvbnN0IHByb2dyYW1BdHRyaWJ1dGUgPSBwcm9ncmFtQXR0cmlidXRlc1tuYW1lXTtcblx0XHRcdGlmIChwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uID49IDApIHtcblx0XHRcdFx0bGV0IGdlb21ldHJ5QXR0cmlidXRlID0gZ2VvbWV0cnlBdHRyaWJ1dGVzW25hbWVdO1xuXHRcdFx0XHRpZiAoZ2VvbWV0cnlBdHRyaWJ1dGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGlmIChuYW1lID09PSAnaW5zdGFuY2VNYXRyaXgnICYmIG9iamVjdC5pbnN0YW5jZU1hdHJpeCkgZ2VvbWV0cnlBdHRyaWJ1dGUgPSBvYmplY3QuaW5zdGFuY2VNYXRyaXg7XG5cdFx0XHRcdFx0aWYgKG5hbWUgPT09ICdpbnN0YW5jZUNvbG9yJyAmJiBvYmplY3QuaW5zdGFuY2VDb2xvcikgZ2VvbWV0cnlBdHRyaWJ1dGUgPSBvYmplY3QuaW5zdGFuY2VDb2xvcjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZ2VvbWV0cnlBdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGNvbnN0IG5vcm1hbGl6ZWQgPSBnZW9tZXRyeUF0dHJpYnV0ZS5ub3JtYWxpemVkO1xuXHRcdFx0XHRcdGNvbnN0IHNpemUgPSBnZW9tZXRyeUF0dHJpYnV0ZS5pdGVtU2l6ZTtcblx0XHRcdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzLmdldChnZW9tZXRyeUF0dHJpYnV0ZSk7XG5cblx0XHRcdFx0XHQvLyBUT0RPIEF0dHJpYnV0ZSBtYXkgbm90IGJlIGF2YWlsYWJsZSBvbiBjb250ZXh0IHJlc3RvcmVcblxuXHRcdFx0XHRcdGlmIChhdHRyaWJ1dGUgPT09IHVuZGVmaW5lZCkgY29udGludWU7XG5cdFx0XHRcdFx0Y29uc3QgYnVmZmVyID0gYXR0cmlidXRlLmJ1ZmZlcjtcblx0XHRcdFx0XHRjb25zdCB0eXBlID0gYXR0cmlidXRlLnR5cGU7XG5cdFx0XHRcdFx0Y29uc3QgYnl0ZXNQZXJFbGVtZW50ID0gYXR0cmlidXRlLmJ5dGVzUGVyRWxlbWVudDtcblx0XHRcdFx0XHRpZiAoZ2VvbWV0cnlBdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSkge1xuXHRcdFx0XHRcdFx0Y29uc3QgZGF0YSA9IGdlb21ldHJ5QXR0cmlidXRlLmRhdGE7XG5cdFx0XHRcdFx0XHRjb25zdCBzdHJpZGUgPSBkYXRhLnN0cmlkZTtcblx0XHRcdFx0XHRcdGNvbnN0IG9mZnNldCA9IGdlb21ldHJ5QXR0cmlidXRlLm9mZnNldDtcblx0XHRcdFx0XHRcdGlmIChkYXRhLmlzSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIpIHtcblx0XHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uU2l6ZTsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlQW5kRGl2aXNvcihwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uICsgaSwgZGF0YS5tZXNoUGVyQXR0cmlidXRlKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAob2JqZWN0LmlzSW5zdGFuY2VkTWVzaCAhPT0gdHJ1ZSAmJiBnZW9tZXRyeS5fbWF4SW5zdGFuY2VDb3VudCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkuX21heEluc3RhbmNlQ291bnQgPSBkYXRhLm1lc2hQZXJBdHRyaWJ1dGUgKiBkYXRhLmNvdW50O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHByb2dyYW1BdHRyaWJ1dGUubG9jYXRpb25TaXplOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRlbmFibGVBdHRyaWJ1dGUocHJvZ3JhbUF0dHJpYnV0ZS5sb2NhdGlvbiArIGkpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcblx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcHJvZ3JhbUF0dHJpYnV0ZS5sb2NhdGlvblNpemU7IGkrKykge1xuXHRcdFx0XHRcdFx0XHR2ZXJ0ZXhBdHRyaWJQb2ludGVyKHByb2dyYW1BdHRyaWJ1dGUubG9jYXRpb24gKyBpLCBzaXplIC8gcHJvZ3JhbUF0dHJpYnV0ZS5sb2NhdGlvblNpemUsIHR5cGUsIG5vcm1hbGl6ZWQsIHN0cmlkZSAqIGJ5dGVzUGVyRWxlbWVudCwgKG9mZnNldCArIHNpemUgLyBwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uU2l6ZSAqIGkpICogYnl0ZXNQZXJFbGVtZW50KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYgKGdlb21ldHJ5QXR0cmlidXRlLmlzSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlKSB7XG5cdFx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcHJvZ3JhbUF0dHJpYnV0ZS5sb2NhdGlvblNpemU7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZUFuZERpdmlzb3IocHJvZ3JhbUF0dHJpYnV0ZS5sb2NhdGlvbiArIGksIGdlb21ldHJ5QXR0cmlidXRlLm1lc2hQZXJBdHRyaWJ1dGUpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmIChvYmplY3QuaXNJbnN0YW5jZWRNZXNoICE9PSB0cnVlICYmIGdlb21ldHJ5Ll9tYXhJbnN0YW5jZUNvdW50ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRnZW9tZXRyeS5fbWF4SW5zdGFuY2VDb3VudCA9IGdlb21ldHJ5QXR0cmlidXRlLm1lc2hQZXJBdHRyaWJ1dGUgKiBnZW9tZXRyeUF0dHJpYnV0ZS5jb3VudDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uU2l6ZTsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKHByb2dyYW1BdHRyaWJ1dGUubG9jYXRpb24gKyBpKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Z2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG5cdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHByb2dyYW1BdHRyaWJ1dGUubG9jYXRpb25TaXplOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0dmVydGV4QXR0cmliUG9pbnRlcihwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uICsgaSwgc2l6ZSAvIHByb2dyYW1BdHRyaWJ1dGUubG9jYXRpb25TaXplLCB0eXBlLCBub3JtYWxpemVkLCBzaXplICogYnl0ZXNQZXJFbGVtZW50LCBzaXplIC8gcHJvZ3JhbUF0dHJpYnV0ZS5sb2NhdGlvblNpemUgKiBpICogYnl0ZXNQZXJFbGVtZW50KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAobWF0ZXJpYWxEZWZhdWx0QXR0cmlidXRlVmFsdWVzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRjb25zdCB2YWx1ZSA9IG1hdGVyaWFsRGVmYXVsdEF0dHJpYnV0ZVZhbHVlc1tuYW1lXTtcblx0XHRcdFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0c3dpdGNoICh2YWx1ZS5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHRcdFx0XHRcdGdsLnZlcnRleEF0dHJpYjJmdihwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uLCB2YWx1ZSk7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdGNhc2UgMzpcblx0XHRcdFx0XHRcdFx0XHRnbC52ZXJ0ZXhBdHRyaWIzZnYocHJvZ3JhbUF0dHJpYnV0ZS5sb2NhdGlvbiwgdmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRjYXNlIDQ6XG5cdFx0XHRcdFx0XHRcdFx0Z2wudmVydGV4QXR0cmliNGZ2KHByb2dyYW1BdHRyaWJ1dGUubG9jYXRpb24sIHZhbHVlKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0XHRnbC52ZXJ0ZXhBdHRyaWIxZnYocHJvZ3JhbUF0dHJpYnV0ZS5sb2NhdGlvbiwgdmFsdWUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRkaXNhYmxlVW51c2VkQXR0cmlidXRlcygpO1xuXHR9XG5cdGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG5cdFx0cmVzZXQoKTtcblx0XHRmb3IgKGNvbnN0IGdlb21ldHJ5SWQgaW4gYmluZGluZ1N0YXRlcykge1xuXHRcdFx0Y29uc3QgcHJvZ3JhbU1hcCA9IGJpbmRpbmdTdGF0ZXNbZ2VvbWV0cnlJZF07XG5cdFx0XHRmb3IgKGNvbnN0IHByb2dyYW1JZCBpbiBwcm9ncmFtTWFwKSB7XG5cdFx0XHRcdGNvbnN0IHN0YXRlTWFwID0gcHJvZ3JhbU1hcFtwcm9ncmFtSWRdO1xuXHRcdFx0XHRmb3IgKGNvbnN0IHdpcmVmcmFtZSBpbiBzdGF0ZU1hcCkge1xuXHRcdFx0XHRcdGRlbGV0ZVZlcnRleEFycmF5T2JqZWN0KHN0YXRlTWFwW3dpcmVmcmFtZV0ub2JqZWN0KTtcblx0XHRcdFx0XHRkZWxldGUgc3RhdGVNYXBbd2lyZWZyYW1lXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkZWxldGUgcHJvZ3JhbU1hcFtwcm9ncmFtSWRdO1xuXHRcdFx0fVxuXHRcdFx0ZGVsZXRlIGJpbmRpbmdTdGF0ZXNbZ2VvbWV0cnlJZF07XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHJlbGVhc2VTdGF0ZXNPZkdlb21ldHJ5KGdlb21ldHJ5KSB7XG5cdFx0aWYgKGJpbmRpbmdTdGF0ZXNbZ2VvbWV0cnkuaWRdID09PSB1bmRlZmluZWQpIHJldHVybjtcblx0XHRjb25zdCBwcm9ncmFtTWFwID0gYmluZGluZ1N0YXRlc1tnZW9tZXRyeS5pZF07XG5cdFx0Zm9yIChjb25zdCBwcm9ncmFtSWQgaW4gcHJvZ3JhbU1hcCkge1xuXHRcdFx0Y29uc3Qgc3RhdGVNYXAgPSBwcm9ncmFtTWFwW3Byb2dyYW1JZF07XG5cdFx0XHRmb3IgKGNvbnN0IHdpcmVmcmFtZSBpbiBzdGF0ZU1hcCkge1xuXHRcdFx0XHRkZWxldGVWZXJ0ZXhBcnJheU9iamVjdChzdGF0ZU1hcFt3aXJlZnJhbWVdLm9iamVjdCk7XG5cdFx0XHRcdGRlbGV0ZSBzdGF0ZU1hcFt3aXJlZnJhbWVdO1xuXHRcdFx0fVxuXHRcdFx0ZGVsZXRlIHByb2dyYW1NYXBbcHJvZ3JhbUlkXTtcblx0XHR9XG5cdFx0ZGVsZXRlIGJpbmRpbmdTdGF0ZXNbZ2VvbWV0cnkuaWRdO1xuXHR9XG5cdGZ1bmN0aW9uIHJlbGVhc2VTdGF0ZXNPZlByb2dyYW0ocHJvZ3JhbSkge1xuXHRcdGZvciAoY29uc3QgZ2VvbWV0cnlJZCBpbiBiaW5kaW5nU3RhdGVzKSB7XG5cdFx0XHRjb25zdCBwcm9ncmFtTWFwID0gYmluZGluZ1N0YXRlc1tnZW9tZXRyeUlkXTtcblx0XHRcdGlmIChwcm9ncmFtTWFwW3Byb2dyYW0uaWRdID09PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xuXHRcdFx0Y29uc3Qgc3RhdGVNYXAgPSBwcm9ncmFtTWFwW3Byb2dyYW0uaWRdO1xuXHRcdFx0Zm9yIChjb25zdCB3aXJlZnJhbWUgaW4gc3RhdGVNYXApIHtcblx0XHRcdFx0ZGVsZXRlVmVydGV4QXJyYXlPYmplY3Qoc3RhdGVNYXBbd2lyZWZyYW1lXS5vYmplY3QpO1xuXHRcdFx0XHRkZWxldGUgc3RhdGVNYXBbd2lyZWZyYW1lXTtcblx0XHRcdH1cblx0XHRcdGRlbGV0ZSBwcm9ncmFtTWFwW3Byb2dyYW0uaWRdO1xuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiByZXNldCgpIHtcblx0XHRyZXNldERlZmF1bHRTdGF0ZSgpO1xuXHRcdGZvcmNlVXBkYXRlID0gdHJ1ZTtcblx0XHRpZiAoY3VycmVudFN0YXRlID09PSBkZWZhdWx0U3RhdGUpIHJldHVybjtcblx0XHRjdXJyZW50U3RhdGUgPSBkZWZhdWx0U3RhdGU7XG5cdFx0YmluZFZlcnRleEFycmF5T2JqZWN0KGN1cnJlbnRTdGF0ZS5vYmplY3QpO1xuXHR9XG5cblx0Ly8gZm9yIGJhY2t3YXJkLWNvbXBhdGliaWxpdHlcblxuXHRmdW5jdGlvbiByZXNldERlZmF1bHRTdGF0ZSgpIHtcblx0XHRkZWZhdWx0U3RhdGUuZ2VvbWV0cnkgPSBudWxsO1xuXHRcdGRlZmF1bHRTdGF0ZS5wcm9ncmFtID0gbnVsbDtcblx0XHRkZWZhdWx0U3RhdGUud2lyZWZyYW1lID0gZmFsc2U7XG5cdH1cblx0cmV0dXJuIHtcblx0XHRzZXR1cDogc2V0dXAsXG5cdFx0cmVzZXQ6IHJlc2V0LFxuXHRcdHJlc2V0RGVmYXVsdFN0YXRlOiByZXNldERlZmF1bHRTdGF0ZSxcblx0XHRkaXNwb3NlOiBkaXNwb3NlLFxuXHRcdHJlbGVhc2VTdGF0ZXNPZkdlb21ldHJ5OiByZWxlYXNlU3RhdGVzT2ZHZW9tZXRyeSxcblx0XHRyZWxlYXNlU3RhdGVzT2ZQcm9ncmFtOiByZWxlYXNlU3RhdGVzT2ZQcm9ncmFtLFxuXHRcdGluaXRBdHRyaWJ1dGVzOiBpbml0QXR0cmlidXRlcyxcblx0XHRlbmFibGVBdHRyaWJ1dGU6IGVuYWJsZUF0dHJpYnV0ZSxcblx0XHRkaXNhYmxlVW51c2VkQXR0cmlidXRlczogZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXNcblx0fTtcbn1cblxuZnVuY3Rpb24gV2ViR0xCdWZmZXJSZW5kZXJlcihnbCwgZXh0ZW5zaW9ucywgaW5mbywgY2FwYWJpbGl0aWVzKSB7XG5cdGNvbnN0IGlzV2ViR0wyID0gY2FwYWJpbGl0aWVzLmlzV2ViR0wyO1xuXHRsZXQgbW9kZTtcblx0ZnVuY3Rpb24gc2V0TW9kZSh2YWx1ZSkge1xuXHRcdG1vZGUgPSB2YWx1ZTtcblx0fVxuXHRmdW5jdGlvbiByZW5kZXIoc3RhcnQsIGNvdW50KSB7XG5cdFx0Z2wuZHJhd0FycmF5cyhtb2RlLCBzdGFydCwgY291bnQpO1xuXHRcdGluZm8udXBkYXRlKGNvdW50LCBtb2RlLCAxKTtcblx0fVxuXHRmdW5jdGlvbiByZW5kZXJJbnN0YW5jZXMoc3RhcnQsIGNvdW50LCBwcmltY291bnQpIHtcblx0XHRpZiAocHJpbWNvdW50ID09PSAwKSByZXR1cm47XG5cdFx0bGV0IGV4dGVuc2lvbiwgbWV0aG9kTmFtZTtcblx0XHRpZiAoaXNXZWJHTDIpIHtcblx0XHRcdGV4dGVuc2lvbiA9IGdsO1xuXHRcdFx0bWV0aG9kTmFtZSA9ICdkcmF3QXJyYXlzSW5zdGFuY2VkJztcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnKTtcblx0XHRcdG1ldGhvZE5hbWUgPSAnZHJhd0FycmF5c0luc3RhbmNlZEFOR0xFJztcblx0XHRcdGlmIChleHRlbnNpb24gPT09IG51bGwpIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuV2ViR0xCdWZmZXJSZW5kZXJlcjogdXNpbmcgVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgYnV0IGhhcmR3YXJlIGRvZXMgbm90IHN1cHBvcnQgZXh0ZW5zaW9uIEFOR0xFX2luc3RhbmNlZF9hcnJheXMuJyk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZXh0ZW5zaW9uW21ldGhvZE5hbWVdKG1vZGUsIHN0YXJ0LCBjb3VudCwgcHJpbWNvdW50KTtcblx0XHRpbmZvLnVwZGF0ZShjb3VudCwgbW9kZSwgcHJpbWNvdW50KTtcblx0fVxuXG5cdC8vXG5cblx0dGhpcy5zZXRNb2RlID0gc2V0TW9kZTtcblx0dGhpcy5yZW5kZXIgPSByZW5kZXI7XG5cdHRoaXMucmVuZGVySW5zdGFuY2VzID0gcmVuZGVySW5zdGFuY2VzO1xufVxuXG5mdW5jdGlvbiBXZWJHTENhcGFiaWxpdGllcyhnbCwgZXh0ZW5zaW9ucywgcGFyYW1ldGVycykge1xuXHRsZXQgbWF4QW5pc290cm9weTtcblx0ZnVuY3Rpb24gZ2V0TWF4QW5pc290cm9weSgpIHtcblx0XHRpZiAobWF4QW5pc290cm9weSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gbWF4QW5pc290cm9weTtcblx0XHRpZiAoZXh0ZW5zaW9ucy5oYXMoJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycpID09PSB0cnVlKSB7XG5cdFx0XHRjb25zdCBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCgnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyk7XG5cdFx0XHRtYXhBbmlzb3Ryb3B5ID0gZ2wuZ2V0UGFyYW1ldGVyKGV4dGVuc2lvbi5NQVhfVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXhBbmlzb3Ryb3B5ID0gMDtcblx0XHR9XG5cdFx0cmV0dXJuIG1heEFuaXNvdHJvcHk7XG5cdH1cblx0ZnVuY3Rpb24gZ2V0TWF4UHJlY2lzaW9uKHByZWNpc2lvbikge1xuXHRcdGlmIChwcmVjaXNpb24gPT09ICdoaWdocCcpIHtcblx0XHRcdGlmIChnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoZ2wuVkVSVEVYX1NIQURFUiwgZ2wuSElHSF9GTE9BVCkucHJlY2lzaW9uID4gMCAmJiBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoZ2wuRlJBR01FTlRfU0hBREVSLCBnbC5ISUdIX0ZMT0FUKS5wcmVjaXNpb24gPiAwKSB7XG5cdFx0XHRcdHJldHVybiAnaGlnaHAnO1xuXHRcdFx0fVxuXHRcdFx0cHJlY2lzaW9uID0gJ21lZGl1bXAnO1xuXHRcdH1cblx0XHRpZiAocHJlY2lzaW9uID09PSAnbWVkaXVtcCcpIHtcblx0XHRcdGlmIChnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoZ2wuVkVSVEVYX1NIQURFUiwgZ2wuTUVESVVNX0ZMT0FUKS5wcmVjaXNpb24gPiAwICYmIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5GUkFHTUVOVF9TSEFERVIsIGdsLk1FRElVTV9GTE9BVCkucHJlY2lzaW9uID4gMCkge1xuXHRcdFx0XHRyZXR1cm4gJ21lZGl1bXAnO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gJ2xvd3AnO1xuXHR9XG5cdGNvbnN0IGlzV2ViR0wyID0gdHlwZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgIT09ICd1bmRlZmluZWQnICYmIGdsIGluc3RhbmNlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCB8fCB0eXBlb2YgV2ViR0wyQ29tcHV0ZVJlbmRlcmluZ0NvbnRleHQgIT09ICd1bmRlZmluZWQnICYmIGdsIGluc3RhbmNlb2YgV2ViR0wyQ29tcHV0ZVJlbmRlcmluZ0NvbnRleHQ7XG5cdGxldCBwcmVjaXNpb24gPSBwYXJhbWV0ZXJzLnByZWNpc2lvbiAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wcmVjaXNpb24gOiAnaGlnaHAnO1xuXHRjb25zdCBtYXhQcmVjaXNpb24gPSBnZXRNYXhQcmVjaXNpb24ocHJlY2lzaW9uKTtcblx0aWYgKG1heFByZWNpc2lvbiAhPT0gcHJlY2lzaW9uKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOicsIHByZWNpc2lvbiwgJ25vdCBzdXBwb3J0ZWQsIHVzaW5nJywgbWF4UHJlY2lzaW9uLCAnaW5zdGVhZC4nKTtcblx0XHRwcmVjaXNpb24gPSBtYXhQcmVjaXNpb247XG5cdH1cblx0Y29uc3QgZHJhd0J1ZmZlcnMgPSBpc1dlYkdMMiB8fCBleHRlbnNpb25zLmhhcygnV0VCR0xfZHJhd19idWZmZXJzJyk7XG5cdGNvbnN0IGxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPSBwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPT09IHRydWU7XG5cdGNvbnN0IG1heFRleHR1cmVzID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTKTtcblx0Y29uc3QgbWF4VmVydGV4VGV4dHVyZXMgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1ZFUlRFWF9URVhUVVJFX0lNQUdFX1VOSVRTKTtcblx0Y29uc3QgbWF4VGV4dHVyZVNpemUgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1RFWFRVUkVfU0laRSk7XG5cdGNvbnN0IG1heEN1YmVtYXBTaXplID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9DVUJFX01BUF9URVhUVVJFX1NJWkUpO1xuXHRjb25zdCBtYXhBdHRyaWJ1dGVzID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9WRVJURVhfQVRUUklCUyk7XG5cdGNvbnN0IG1heFZlcnRleFVuaWZvcm1zID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9WRVJURVhfVU5JRk9STV9WRUNUT1JTKTtcblx0Y29uc3QgbWF4VmFyeWluZ3MgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1ZBUllJTkdfVkVDVE9SUyk7XG5cdGNvbnN0IG1heEZyYWdtZW50VW5pZm9ybXMgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX0ZSQUdNRU5UX1VOSUZPUk1fVkVDVE9SUyk7XG5cdGNvbnN0IHZlcnRleFRleHR1cmVzID0gbWF4VmVydGV4VGV4dHVyZXMgPiAwO1xuXHRjb25zdCBmbG9hdEZyYWdtZW50VGV4dHVyZXMgPSBpc1dlYkdMMiB8fCBleHRlbnNpb25zLmhhcygnT0VTX3RleHR1cmVfZmxvYXQnKTtcblx0Y29uc3QgZmxvYXRWZXJ0ZXhUZXh0dXJlcyA9IHZlcnRleFRleHR1cmVzICYmIGZsb2F0RnJhZ21lbnRUZXh0dXJlcztcblx0Y29uc3QgbWF4U2FtcGxlcyA9IGlzV2ViR0wyID8gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9TQU1QTEVTKSA6IDA7XG5cdHJldHVybiB7XG5cdFx0aXNXZWJHTDI6IGlzV2ViR0wyLFxuXHRcdGRyYXdCdWZmZXJzOiBkcmF3QnVmZmVycyxcblx0XHRnZXRNYXhBbmlzb3Ryb3B5OiBnZXRNYXhBbmlzb3Ryb3B5LFxuXHRcdGdldE1heFByZWNpc2lvbjogZ2V0TWF4UHJlY2lzaW9uLFxuXHRcdHByZWNpc2lvbjogcHJlY2lzaW9uLFxuXHRcdGxvZ2FyaXRobWljRGVwdGhCdWZmZXI6IGxvZ2FyaXRobWljRGVwdGhCdWZmZXIsXG5cdFx0bWF4VGV4dHVyZXM6IG1heFRleHR1cmVzLFxuXHRcdG1heFZlcnRleFRleHR1cmVzOiBtYXhWZXJ0ZXhUZXh0dXJlcyxcblx0XHRtYXhUZXh0dXJlU2l6ZTogbWF4VGV4dHVyZVNpemUsXG5cdFx0bWF4Q3ViZW1hcFNpemU6IG1heEN1YmVtYXBTaXplLFxuXHRcdG1heEF0dHJpYnV0ZXM6IG1heEF0dHJpYnV0ZXMsXG5cdFx0bWF4VmVydGV4VW5pZm9ybXM6IG1heFZlcnRleFVuaWZvcm1zLFxuXHRcdG1heFZhcnlpbmdzOiBtYXhWYXJ5aW5ncyxcblx0XHRtYXhGcmFnbWVudFVuaWZvcm1zOiBtYXhGcmFnbWVudFVuaWZvcm1zLFxuXHRcdHZlcnRleFRleHR1cmVzOiB2ZXJ0ZXhUZXh0dXJlcyxcblx0XHRmbG9hdEZyYWdtZW50VGV4dHVyZXM6IGZsb2F0RnJhZ21lbnRUZXh0dXJlcyxcblx0XHRmbG9hdFZlcnRleFRleHR1cmVzOiBmbG9hdFZlcnRleFRleHR1cmVzLFxuXHRcdG1heFNhbXBsZXM6IG1heFNhbXBsZXNcblx0fTtcbn1cblxuZnVuY3Rpb24gV2ViR0xDbGlwcGluZyhwcm9wZXJ0aWVzKSB7XG5cdGNvbnN0IHNjb3BlID0gdGhpcztcblx0bGV0IGdsb2JhbFN0YXRlID0gbnVsbCxcblx0XHRudW1HbG9iYWxQbGFuZXMgPSAwLFxuXHRcdGxvY2FsQ2xpcHBpbmdFbmFibGVkID0gZmFsc2UsXG5cdFx0cmVuZGVyaW5nU2hhZG93cyA9IGZhbHNlO1xuXHRjb25zdCBwbGFuZSA9IG5ldyBQbGFuZSgpLFxuXHRcdHZpZXdOb3JtYWxNYXRyaXggPSBuZXcgTWF0cml4MygpLFxuXHRcdHVuaWZvcm0gPSB7XG5cdFx0XHR2YWx1ZTogbnVsbCxcblx0XHRcdG5lZWRzVXBkYXRlOiBmYWxzZVxuXHRcdH07XG5cdHRoaXMudW5pZm9ybSA9IHVuaWZvcm07XG5cdHRoaXMubnVtUGxhbmVzID0gMDtcblx0dGhpcy5udW1JbnRlcnNlY3Rpb24gPSAwO1xuXHR0aGlzLmluaXQgPSBmdW5jdGlvbiAocGxhbmVzLCBlbmFibGVMb2NhbENsaXBwaW5nLCBjYW1lcmEpIHtcblx0XHRjb25zdCBlbmFibGVkID0gcGxhbmVzLmxlbmd0aCAhPT0gMCB8fCBlbmFibGVMb2NhbENsaXBwaW5nIHx8XG5cdFx0Ly8gZW5hYmxlIHN0YXRlIG9mIHByZXZpb3VzIGZyYW1lIC0gdGhlIGNsaXBwaW5nIGNvZGUgaGFzIHRvXG5cdFx0Ly8gcnVuIGFub3RoZXIgZnJhbWUgaW4gb3JkZXIgdG8gcmVzZXQgdGhlIHN0YXRlOlxuXHRcdG51bUdsb2JhbFBsYW5lcyAhPT0gMCB8fCBsb2NhbENsaXBwaW5nRW5hYmxlZDtcblx0XHRsb2NhbENsaXBwaW5nRW5hYmxlZCA9IGVuYWJsZUxvY2FsQ2xpcHBpbmc7XG5cdFx0Z2xvYmFsU3RhdGUgPSBwcm9qZWN0UGxhbmVzKHBsYW5lcywgY2FtZXJhLCAwKTtcblx0XHRudW1HbG9iYWxQbGFuZXMgPSBwbGFuZXMubGVuZ3RoO1xuXHRcdHJldHVybiBlbmFibGVkO1xuXHR9O1xuXHR0aGlzLmJlZ2luU2hhZG93cyA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZW5kZXJpbmdTaGFkb3dzID0gdHJ1ZTtcblx0XHRwcm9qZWN0UGxhbmVzKG51bGwpO1xuXHR9O1xuXHR0aGlzLmVuZFNoYWRvd3MgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmVuZGVyaW5nU2hhZG93cyA9IGZhbHNlO1xuXHRcdHJlc2V0R2xvYmFsU3RhdGUoKTtcblx0fTtcblx0dGhpcy5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChtYXRlcmlhbCwgY2FtZXJhLCB1c2VDYWNoZSkge1xuXHRcdGNvbnN0IHBsYW5lcyA9IG1hdGVyaWFsLmNsaXBwaW5nUGxhbmVzLFxuXHRcdFx0Y2xpcEludGVyc2VjdGlvbiA9IG1hdGVyaWFsLmNsaXBJbnRlcnNlY3Rpb24sXG5cdFx0XHRjbGlwU2hhZG93cyA9IG1hdGVyaWFsLmNsaXBTaGFkb3dzO1xuXHRcdGNvbnN0IG1hdGVyaWFsUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KG1hdGVyaWFsKTtcblx0XHRpZiAoIWxvY2FsQ2xpcHBpbmdFbmFibGVkIHx8IHBsYW5lcyA9PT0gbnVsbCB8fCBwbGFuZXMubGVuZ3RoID09PSAwIHx8IHJlbmRlcmluZ1NoYWRvd3MgJiYgIWNsaXBTaGFkb3dzKSB7XG5cdFx0XHQvLyB0aGVyZSdzIG5vIGxvY2FsIGNsaXBwaW5nXG5cblx0XHRcdGlmIChyZW5kZXJpbmdTaGFkb3dzKSB7XG5cdFx0XHRcdC8vIHRoZXJlJ3Mgbm8gZ2xvYmFsIGNsaXBwaW5nXG5cblx0XHRcdFx0cHJvamVjdFBsYW5lcyhudWxsKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlc2V0R2xvYmFsU3RhdGUoKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3Qgbkdsb2JhbCA9IHJlbmRlcmluZ1NoYWRvd3MgPyAwIDogbnVtR2xvYmFsUGxhbmVzLFxuXHRcdFx0XHRsR2xvYmFsID0gbkdsb2JhbCAqIDQ7XG5cdFx0XHRsZXQgZHN0QXJyYXkgPSBtYXRlcmlhbFByb3BlcnRpZXMuY2xpcHBpbmdTdGF0ZSB8fCBudWxsO1xuXHRcdFx0dW5pZm9ybS52YWx1ZSA9IGRzdEFycmF5OyAvLyBlbnN1cmUgdW5pcXVlIHN0YXRlXG5cblx0XHRcdGRzdEFycmF5ID0gcHJvamVjdFBsYW5lcyhwbGFuZXMsIGNhbWVyYSwgbEdsb2JhbCwgdXNlQ2FjaGUpO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgIT09IGxHbG9iYWw7ICsraSkge1xuXHRcdFx0XHRkc3RBcnJheVtpXSA9IGdsb2JhbFN0YXRlW2ldO1xuXHRcdFx0fVxuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLmNsaXBwaW5nU3RhdGUgPSBkc3RBcnJheTtcblx0XHRcdHRoaXMubnVtSW50ZXJzZWN0aW9uID0gY2xpcEludGVyc2VjdGlvbiA/IHRoaXMubnVtUGxhbmVzIDogMDtcblx0XHRcdHRoaXMubnVtUGxhbmVzICs9IG5HbG9iYWw7XG5cdFx0fVxuXHR9O1xuXHRmdW5jdGlvbiByZXNldEdsb2JhbFN0YXRlKCkge1xuXHRcdGlmICh1bmlmb3JtLnZhbHVlICE9PSBnbG9iYWxTdGF0ZSkge1xuXHRcdFx0dW5pZm9ybS52YWx1ZSA9IGdsb2JhbFN0YXRlO1xuXHRcdFx0dW5pZm9ybS5uZWVkc1VwZGF0ZSA9IG51bUdsb2JhbFBsYW5lcyA+IDA7XG5cdFx0fVxuXHRcdHNjb3BlLm51bVBsYW5lcyA9IG51bUdsb2JhbFBsYW5lcztcblx0XHRzY29wZS5udW1JbnRlcnNlY3Rpb24gPSAwO1xuXHR9XG5cdGZ1bmN0aW9uIHByb2plY3RQbGFuZXMocGxhbmVzLCBjYW1lcmEsIGRzdE9mZnNldCwgc2tpcFRyYW5zZm9ybSkge1xuXHRcdGNvbnN0IG5QbGFuZXMgPSBwbGFuZXMgIT09IG51bGwgPyBwbGFuZXMubGVuZ3RoIDogMDtcblx0XHRsZXQgZHN0QXJyYXkgPSBudWxsO1xuXHRcdGlmIChuUGxhbmVzICE9PSAwKSB7XG5cdFx0XHRkc3RBcnJheSA9IHVuaWZvcm0udmFsdWU7XG5cdFx0XHRpZiAoc2tpcFRyYW5zZm9ybSAhPT0gdHJ1ZSB8fCBkc3RBcnJheSA9PT0gbnVsbCkge1xuXHRcdFx0XHRjb25zdCBmbGF0U2l6ZSA9IGRzdE9mZnNldCArIG5QbGFuZXMgKiA0LFxuXHRcdFx0XHRcdHZpZXdNYXRyaXggPSBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlO1xuXHRcdFx0XHR2aWV3Tm9ybWFsTWF0cml4LmdldE5vcm1hbE1hdHJpeCh2aWV3TWF0cml4KTtcblx0XHRcdFx0aWYgKGRzdEFycmF5ID09PSBudWxsIHx8IGRzdEFycmF5Lmxlbmd0aCA8IGZsYXRTaXplKSB7XG5cdFx0XHRcdFx0ZHN0QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KGZsYXRTaXplKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgaTQgPSBkc3RPZmZzZXQ7IGkgIT09IG5QbGFuZXM7ICsraSwgaTQgKz0gNCkge1xuXHRcdFx0XHRcdHBsYW5lLmNvcHkocGxhbmVzW2ldKS5hcHBseU1hdHJpeDQodmlld01hdHJpeCwgdmlld05vcm1hbE1hdHJpeCk7XG5cdFx0XHRcdFx0cGxhbmUubm9ybWFsLnRvQXJyYXkoZHN0QXJyYXksIGk0KTtcblx0XHRcdFx0XHRkc3RBcnJheVtpNCArIDNdID0gcGxhbmUuY29uc3RhbnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHVuaWZvcm0udmFsdWUgPSBkc3RBcnJheTtcblx0XHRcdHVuaWZvcm0ubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdH1cblx0XHRzY29wZS5udW1QbGFuZXMgPSBuUGxhbmVzO1xuXHRcdHNjb3BlLm51bUludGVyc2VjdGlvbiA9IDA7XG5cdFx0cmV0dXJuIGRzdEFycmF5O1xuXHR9XG59XG5cbmZ1bmN0aW9uIFdlYkdMQ3ViZU1hcHMocmVuZGVyZXIpIHtcblx0bGV0IGN1YmVtYXBzID0gbmV3IFdlYWtNYXAoKTtcblx0ZnVuY3Rpb24gbWFwVGV4dHVyZU1hcHBpbmcodGV4dHVyZSwgbWFwcGluZykge1xuXHRcdGlmIChtYXBwaW5nID09PSBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZykge1xuXHRcdFx0dGV4dHVyZS5tYXBwaW5nID0gQ3ViZVJlZmxlY3Rpb25NYXBwaW5nO1xuXHRcdH0gZWxzZSBpZiAobWFwcGluZyA9PT0gRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmcpIHtcblx0XHRcdHRleHR1cmUubWFwcGluZyA9IEN1YmVSZWZyYWN0aW9uTWFwcGluZztcblx0XHR9XG5cdFx0cmV0dXJuIHRleHR1cmU7XG5cdH1cblx0ZnVuY3Rpb24gZ2V0KHRleHR1cmUpIHtcblx0XHRpZiAodGV4dHVyZSAmJiB0ZXh0dXJlLmlzVGV4dHVyZSAmJiB0ZXh0dXJlLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSA9PT0gZmFsc2UpIHtcblx0XHRcdGNvbnN0IG1hcHBpbmcgPSB0ZXh0dXJlLm1hcHBpbmc7XG5cdFx0XHRpZiAobWFwcGluZyA9PT0gRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcgfHwgbWFwcGluZyA9PT0gRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmcpIHtcblx0XHRcdFx0aWYgKGN1YmVtYXBzLmhhcyh0ZXh0dXJlKSkge1xuXHRcdFx0XHRcdGNvbnN0IGN1YmVtYXAgPSBjdWJlbWFwcy5nZXQodGV4dHVyZSkudGV4dHVyZTtcblx0XHRcdFx0XHRyZXR1cm4gbWFwVGV4dHVyZU1hcHBpbmcoY3ViZW1hcCwgdGV4dHVyZS5tYXBwaW5nKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb25zdCBpbWFnZSA9IHRleHR1cmUuaW1hZ2U7XG5cdFx0XHRcdFx0aWYgKGltYWdlICYmIGltYWdlLmhlaWdodCA+IDApIHtcblx0XHRcdFx0XHRcdGNvbnN0IHJlbmRlclRhcmdldCA9IG5ldyBXZWJHTEN1YmVSZW5kZXJUYXJnZXQoaW1hZ2UuaGVpZ2h0IC8gMik7XG5cdFx0XHRcdFx0XHRyZW5kZXJUYXJnZXQuZnJvbUVxdWlyZWN0YW5ndWxhclRleHR1cmUocmVuZGVyZXIsIHRleHR1cmUpO1xuXHRcdFx0XHRcdFx0Y3ViZW1hcHMuc2V0KHRleHR1cmUsIHJlbmRlclRhcmdldCk7XG5cdFx0XHRcdFx0XHR0ZXh0dXJlLmFkZEV2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBvblRleHR1cmVEaXNwb3NlKTtcblx0XHRcdFx0XHRcdHJldHVybiBtYXBUZXh0dXJlTWFwcGluZyhyZW5kZXJUYXJnZXQudGV4dHVyZSwgdGV4dHVyZS5tYXBwaW5nKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gaW1hZ2Ugbm90IHlldCByZWFkeS4gdHJ5IHRoZSBjb252ZXJzaW9uIG5leHQgZnJhbWVcblxuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0ZXh0dXJlO1xuXHR9XG5cdGZ1bmN0aW9uIG9uVGV4dHVyZURpc3Bvc2UoZXZlbnQpIHtcblx0XHRjb25zdCB0ZXh0dXJlID0gZXZlbnQudGFyZ2V0O1xuXHRcdHRleHR1cmUucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIG9uVGV4dHVyZURpc3Bvc2UpO1xuXHRcdGNvbnN0IGN1YmVtYXAgPSBjdWJlbWFwcy5nZXQodGV4dHVyZSk7XG5cdFx0aWYgKGN1YmVtYXAgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Y3ViZW1hcHMuZGVsZXRlKHRleHR1cmUpO1xuXHRcdFx0Y3ViZW1hcC5kaXNwb3NlKCk7XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG5cdFx0Y3ViZW1hcHMgPSBuZXcgV2Vha01hcCgpO1xuXHR9XG5cdHJldHVybiB7XG5cdFx0Z2V0OiBnZXQsXG5cdFx0ZGlzcG9zZTogZGlzcG9zZVxuXHR9O1xufVxuXG5jbGFzcyBPcnRob2dyYXBoaWNDYW1lcmEgZXh0ZW5kcyBDYW1lcmEge1xuXHRjb25zdHJ1Y3RvcihsZWZ0ID0gLTEsIHJpZ2h0ID0gMSwgdG9wID0gMSwgYm90dG9tID0gLTEsIG5lYXIgPSAwLjEsIGZhciA9IDIwMDApIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuaXNPcnRob2dyYXBoaWNDYW1lcmEgPSB0cnVlO1xuXHRcdHRoaXMudHlwZSA9ICdPcnRob2dyYXBoaWNDYW1lcmEnO1xuXHRcdHRoaXMuem9vbSA9IDE7XG5cdFx0dGhpcy52aWV3ID0gbnVsbDtcblx0XHR0aGlzLmxlZnQgPSBsZWZ0O1xuXHRcdHRoaXMucmlnaHQgPSByaWdodDtcblx0XHR0aGlzLnRvcCA9IHRvcDtcblx0XHR0aGlzLmJvdHRvbSA9IGJvdHRvbTtcblx0XHR0aGlzLm5lYXIgPSBuZWFyO1xuXHRcdHRoaXMuZmFyID0gZmFyO1xuXHRcdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXHR9XG5cdGNvcHkoc291cmNlLCByZWN1cnNpdmUpIHtcblx0XHRzdXBlci5jb3B5KHNvdXJjZSwgcmVjdXJzaXZlKTtcblx0XHR0aGlzLmxlZnQgPSBzb3VyY2UubGVmdDtcblx0XHR0aGlzLnJpZ2h0ID0gc291cmNlLnJpZ2h0O1xuXHRcdHRoaXMudG9wID0gc291cmNlLnRvcDtcblx0XHR0aGlzLmJvdHRvbSA9IHNvdXJjZS5ib3R0b207XG5cdFx0dGhpcy5uZWFyID0gc291cmNlLm5lYXI7XG5cdFx0dGhpcy5mYXIgPSBzb3VyY2UuZmFyO1xuXHRcdHRoaXMuem9vbSA9IHNvdXJjZS56b29tO1xuXHRcdHRoaXMudmlldyA9IHNvdXJjZS52aWV3ID09PSBudWxsID8gbnVsbCA6IE9iamVjdC5hc3NpZ24oe30sIHNvdXJjZS52aWV3KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRzZXRWaWV3T2Zmc2V0KGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXHRcdGlmICh0aGlzLnZpZXcgPT09IG51bGwpIHtcblx0XHRcdHRoaXMudmlldyA9IHtcblx0XHRcdFx0ZW5hYmxlZDogdHJ1ZSxcblx0XHRcdFx0ZnVsbFdpZHRoOiAxLFxuXHRcdFx0XHRmdWxsSGVpZ2h0OiAxLFxuXHRcdFx0XHRvZmZzZXRYOiAwLFxuXHRcdFx0XHRvZmZzZXRZOiAwLFxuXHRcdFx0XHR3aWR0aDogMSxcblx0XHRcdFx0aGVpZ2h0OiAxXG5cdFx0XHR9O1xuXHRcdH1cblx0XHR0aGlzLnZpZXcuZW5hYmxlZCA9IHRydWU7XG5cdFx0dGhpcy52aWV3LmZ1bGxXaWR0aCA9IGZ1bGxXaWR0aDtcblx0XHR0aGlzLnZpZXcuZnVsbEhlaWdodCA9IGZ1bGxIZWlnaHQ7XG5cdFx0dGhpcy52aWV3Lm9mZnNldFggPSB4O1xuXHRcdHRoaXMudmlldy5vZmZzZXRZID0geTtcblx0XHR0aGlzLnZpZXcud2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLnZpZXcuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXHR9XG5cdGNsZWFyVmlld09mZnNldCgpIHtcblx0XHRpZiAodGhpcy52aWV3ICE9PSBudWxsKSB7XG5cdFx0XHR0aGlzLnZpZXcuZW5hYmxlZCA9IGZhbHNlO1xuXHRcdH1cblx0XHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblx0fVxuXHR1cGRhdGVQcm9qZWN0aW9uTWF0cml4KCkge1xuXHRcdGNvbnN0IGR4ID0gKHRoaXMucmlnaHQgLSB0aGlzLmxlZnQpIC8gKDIgKiB0aGlzLnpvb20pO1xuXHRcdGNvbnN0IGR5ID0gKHRoaXMudG9wIC0gdGhpcy5ib3R0b20pIC8gKDIgKiB0aGlzLnpvb20pO1xuXHRcdGNvbnN0IGN4ID0gKHRoaXMucmlnaHQgKyB0aGlzLmxlZnQpIC8gMjtcblx0XHRjb25zdCBjeSA9ICh0aGlzLnRvcCArIHRoaXMuYm90dG9tKSAvIDI7XG5cdFx0bGV0IGxlZnQgPSBjeCAtIGR4O1xuXHRcdGxldCByaWdodCA9IGN4ICsgZHg7XG5cdFx0bGV0IHRvcCA9IGN5ICsgZHk7XG5cdFx0bGV0IGJvdHRvbSA9IGN5IC0gZHk7XG5cdFx0aWYgKHRoaXMudmlldyAhPT0gbnVsbCAmJiB0aGlzLnZpZXcuZW5hYmxlZCkge1xuXHRcdFx0Y29uc3Qgc2NhbGVXID0gKHRoaXMucmlnaHQgLSB0aGlzLmxlZnQpIC8gdGhpcy52aWV3LmZ1bGxXaWR0aCAvIHRoaXMuem9vbTtcblx0XHRcdGNvbnN0IHNjYWxlSCA9ICh0aGlzLnRvcCAtIHRoaXMuYm90dG9tKSAvIHRoaXMudmlldy5mdWxsSGVpZ2h0IC8gdGhpcy56b29tO1xuXHRcdFx0bGVmdCArPSBzY2FsZVcgKiB0aGlzLnZpZXcub2Zmc2V0WDtcblx0XHRcdHJpZ2h0ID0gbGVmdCArIHNjYWxlVyAqIHRoaXMudmlldy53aWR0aDtcblx0XHRcdHRvcCAtPSBzY2FsZUggKiB0aGlzLnZpZXcub2Zmc2V0WTtcblx0XHRcdGJvdHRvbSA9IHRvcCAtIHNjYWxlSCAqIHRoaXMudmlldy5oZWlnaHQ7XG5cdFx0fVxuXHRcdHRoaXMucHJvamVjdGlvbk1hdHJpeC5tYWtlT3J0aG9ncmFwaGljKGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgdGhpcy5uZWFyLCB0aGlzLmZhcik7XG5cdFx0dGhpcy5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZS5jb3B5KHRoaXMucHJvamVjdGlvbk1hdHJpeCkuaW52ZXJ0KCk7XG5cdH1cblx0dG9KU09OKG1ldGEpIHtcblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKG1ldGEpO1xuXHRcdGRhdGEub2JqZWN0Lnpvb20gPSB0aGlzLnpvb207XG5cdFx0ZGF0YS5vYmplY3QubGVmdCA9IHRoaXMubGVmdDtcblx0XHRkYXRhLm9iamVjdC5yaWdodCA9IHRoaXMucmlnaHQ7XG5cdFx0ZGF0YS5vYmplY3QudG9wID0gdGhpcy50b3A7XG5cdFx0ZGF0YS5vYmplY3QuYm90dG9tID0gdGhpcy5ib3R0b207XG5cdFx0ZGF0YS5vYmplY3QubmVhciA9IHRoaXMubmVhcjtcblx0XHRkYXRhLm9iamVjdC5mYXIgPSB0aGlzLmZhcjtcblx0XHRpZiAodGhpcy52aWV3ICE9PSBudWxsKSBkYXRhLm9iamVjdC52aWV3ID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy52aWV3KTtcblx0XHRyZXR1cm4gZGF0YTtcblx0fVxufVxuXG5jb25zdCBMT0RfTUlOID0gNDtcblxuLy8gVGhlIHN0YW5kYXJkIGRldmlhdGlvbnMgKHJhZGlhbnMpIGFzc29jaWF0ZWQgd2l0aCB0aGUgZXh0cmEgbWlwcy4gVGhlc2UgYXJlXG4vLyBjaG9zZW4gdG8gYXBwcm94aW1hdGUgYSBUcm93YnJpZGdlLVJlaXR6IGRpc3RyaWJ1dGlvbiBmdW5jdGlvbiB0aW1lcyB0aGVcbi8vIGdlb21ldHJpYyBzaGFkb3dpbmcgZnVuY3Rpb24uIFRoZXNlIHNpZ21hIHZhbHVlcyBzcXVhcmVkIG11c3QgbWF0Y2ggdGhlXG4vLyB2YXJpYW5jZSAjZGVmaW5lcyBpbiBjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQuZ2xzbC5qcy5cbmNvbnN0IEVYVFJBX0xPRF9TSUdNQSA9IFswLjEyNSwgMC4yMTUsIDAuMzUsIDAuNDQ2LCAwLjUyNiwgMC41ODJdO1xuXG4vLyBUaGUgbWF4aW11bSBsZW5ndGggb2YgdGhlIGJsdXIgZm9yIGxvb3AuIFNtYWxsZXIgc2lnbWFzIHdpbGwgdXNlIGZld2VyXG4vLyBzYW1wbGVzIGFuZCBleGl0IGVhcmx5LCBidXQgbm90IHJlY29tcGlsZSB0aGUgc2hhZGVyLlxuY29uc3QgTUFYX1NBTVBMRVMgPSAyMDtcbmNvbnN0IF9mbGF0Q2FtZXJhID0gLypAX19QVVJFX18qL25ldyBPcnRob2dyYXBoaWNDYW1lcmEoKTtcbmNvbnN0IF9jbGVhckNvbG9yID0gLypAX19QVVJFX18qL25ldyBDb2xvcigpO1xubGV0IF9vbGRUYXJnZXQgPSBudWxsO1xuXG4vLyBHb2xkZW4gUmF0aW9cbmNvbnN0IFBISSA9ICgxICsgTWF0aC5zcXJ0KDUpKSAvIDI7XG5jb25zdCBJTlZfUEhJID0gMSAvIFBISTtcblxuLy8gVmVydGljZXMgb2YgYSBkb2RlY2FoZWRyb24gKGV4Y2VwdCB0aGUgb3Bwb3NpdGVzLCB3aGljaCByZXByZXNlbnQgdGhlXG4vLyBzYW1lIGF4aXMpLCB1c2VkIGFzIGF4aXMgZGlyZWN0aW9ucyBldmVubHkgc3ByZWFkIG9uIGEgc3BoZXJlLlxuY29uc3QgX2F4aXNEaXJlY3Rpb25zID0gWy8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygxLCAxLCAxKSwgLypAX19QVVJFX18qL25ldyBWZWN0b3IzKC0xLCAxLCAxKSwgLypAX19QVVJFX18qL25ldyBWZWN0b3IzKDEsIDEsIC0xKSwgLypAX19QVVJFX18qL25ldyBWZWN0b3IzKC0xLCAxLCAtMSksIC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygwLCBQSEksIElOVl9QSEkpLCAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoMCwgUEhJLCAtSU5WX1BISSksIC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMyhJTlZfUEhJLCAwLCBQSEkpLCAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoLUlOVl9QSEksIDAsIFBISSksIC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMyhQSEksIElOVl9QSEksIDApLCAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoLVBISSwgSU5WX1BISSwgMCldO1xuXG4vKipcbiAqIFRoaXMgY2xhc3MgZ2VuZXJhdGVzIGEgUHJlZmlsdGVyZWQsIE1pcG1hcHBlZCBSYWRpYW5jZSBFbnZpcm9ubWVudCBNYXBcbiAqIChQTVJFTSkgZnJvbSBhIGN1YmVNYXAgZW52aXJvbm1lbnQgdGV4dHVyZS4gVGhpcyBhbGxvd3MgZGlmZmVyZW50IGxldmVscyBvZlxuICogYmx1ciB0byBiZSBxdWlja2x5IGFjY2Vzc2VkIGJhc2VkIG9uIG1hdGVyaWFsIHJvdWdobmVzcy4gSXQgaXMgcGFja2VkIGludG8gYVxuICogc3BlY2lhbCBDdWJlVVYgZm9ybWF0IHRoYXQgYWxsb3dzIHVzIHRvIHBlcmZvcm0gY3VzdG9tIGludGVycG9sYXRpb24gc28gdGhhdFxuICogd2UgY2FuIHN1cHBvcnQgbm9ubGluZWFyIGZvcm1hdHMgc3VjaCBhcyBSR0JFLiBVbmxpa2UgYSB0cmFkaXRpb25hbCBtaXBtYXBcbiAqIGNoYWluLCBpdCBvbmx5IGdvZXMgZG93biB0byB0aGUgTE9EX01JTiBsZXZlbCAoYWJvdmUpLCBhbmQgdGhlbiBjcmVhdGVzIGV4dHJhXG4gKiBldmVuIG1vcmUgZmlsdGVyZWQgJ21pcHMnIGF0IHRoZSBzYW1lIExPRF9NSU4gcmVzb2x1dGlvbiwgYXNzb2NpYXRlZCB3aXRoXG4gKiBoaWdoZXIgcm91Z2huZXNzIGxldmVscy4gSW4gdGhpcyB3YXkgd2UgbWFpbnRhaW4gcmVzb2x1dGlvbiB0byBzbW9vdGhseVxuICogaW50ZXJwb2xhdGUgZGlmZnVzZSBsaWdodGluZyB3aGlsZSBsaW1pdGluZyBzYW1wbGluZyBjb21wdXRhdGlvbi5cbiAqXG4gKiBQYXBlcjogRmFzdCwgQWNjdXJhdGUgSW1hZ2UtQmFzZWQgTGlnaHRpbmdcbiAqIGh0dHBzOi8vZHJpdmUuZ29vZ2xlLmNvbS9maWxlL2QvMTV5OHJfVXBLbFU5U3ZWNElMYjBDM3FDUGVjUzhwdkx6L3ZpZXdcbiovXG5cbmNsYXNzIFBNUkVNR2VuZXJhdG9yIHtcblx0Y29uc3RydWN0b3IocmVuZGVyZXIpIHtcblx0XHR0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuXHRcdHRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0ID0gbnVsbDtcblx0XHR0aGlzLl9sb2RNYXggPSAwO1xuXHRcdHRoaXMuX2N1YmVTaXplID0gMDtcblx0XHR0aGlzLl9sb2RQbGFuZXMgPSBbXTtcblx0XHR0aGlzLl9zaXplTG9kcyA9IFtdO1xuXHRcdHRoaXMuX3NpZ21hcyA9IFtdO1xuXHRcdHRoaXMuX2JsdXJNYXRlcmlhbCA9IG51bGw7XG5cdFx0dGhpcy5fY3ViZW1hcE1hdGVyaWFsID0gbnVsbDtcblx0XHR0aGlzLl9lcXVpcmVjdE1hdGVyaWFsID0gbnVsbDtcblx0XHR0aGlzLl9jb21waWxlTWF0ZXJpYWwodGhpcy5fYmx1ck1hdGVyaWFsKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZXMgYSBQTVJFTSBmcm9tIGEgc3VwcGxpZWQgU2NlbmUsIHdoaWNoIGNhbiBiZSBmYXN0ZXIgdGhhbiB1c2luZyBhblxuXHQgKiBpbWFnZSBpZiBuZXR3b3JraW5nIGJhbmR3aWR0aCBpcyBsb3cuIE9wdGlvbmFsIHNpZ21hIHNwZWNpZmllcyBhIGJsdXIgcmFkaXVzXG5cdCAqIGluIHJhZGlhbnMgdG8gYmUgYXBwbGllZCB0byB0aGUgc2NlbmUgYmVmb3JlIFBNUkVNIGdlbmVyYXRpb24uIE9wdGlvbmFsIG5lYXJcblx0ICogYW5kIGZhciBwbGFuZXMgZW5zdXJlIHRoZSBzY2VuZSBpcyByZW5kZXJlZCBpbiBpdHMgZW50aXJldHkgKHRoZSBjdWJlQ2FtZXJhXG5cdCAqIGlzIHBsYWNlZCBhdCB0aGUgb3JpZ2luKS5cblx0ICovXG5cdGZyb21TY2VuZShzY2VuZSwgc2lnbWEgPSAwLCBuZWFyID0gMC4xLCBmYXIgPSAxMDApIHtcblx0XHRfb2xkVGFyZ2V0ID0gdGhpcy5fcmVuZGVyZXIuZ2V0UmVuZGVyVGFyZ2V0KCk7XG5cdFx0dGhpcy5fc2V0U2l6ZSgyNTYpO1xuXHRcdGNvbnN0IGN1YmVVVlJlbmRlclRhcmdldCA9IHRoaXMuX2FsbG9jYXRlVGFyZ2V0cygpO1xuXHRcdGN1YmVVVlJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciA9IHRydWU7XG5cdFx0dGhpcy5fc2NlbmVUb0N1YmVVVihzY2VuZSwgbmVhciwgZmFyLCBjdWJlVVZSZW5kZXJUYXJnZXQpO1xuXHRcdGlmIChzaWdtYSA+IDApIHtcblx0XHRcdHRoaXMuX2JsdXIoY3ViZVVWUmVuZGVyVGFyZ2V0LCAwLCAwLCBzaWdtYSk7XG5cdFx0fVxuXHRcdHRoaXMuX2FwcGx5UE1SRU0oY3ViZVVWUmVuZGVyVGFyZ2V0KTtcblx0XHR0aGlzLl9jbGVhbnVwKGN1YmVVVlJlbmRlclRhcmdldCk7XG5cdFx0cmV0dXJuIGN1YmVVVlJlbmRlclRhcmdldDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZXMgYSBQTVJFTSBmcm9tIGFuIGVxdWlyZWN0YW5ndWxhciB0ZXh0dXJlLCB3aGljaCBjYW4gYmUgZWl0aGVyIExEUlxuXHQgKiBvciBIRFIuIFRoZSBpZGVhbCBpbnB1dCBpbWFnZSBzaXplIGlzIDFrICgxMDI0IHggNTEyKSxcblx0ICogYXMgdGhpcyBtYXRjaGVzIGJlc3Qgd2l0aCB0aGUgMjU2IHggMjU2IGN1YmVtYXAgb3V0cHV0LlxuXHQgKi9cblx0ZnJvbUVxdWlyZWN0YW5ndWxhcihlcXVpcmVjdGFuZ3VsYXIsIHJlbmRlclRhcmdldCA9IG51bGwpIHtcblx0XHRyZXR1cm4gdGhpcy5fZnJvbVRleHR1cmUoZXF1aXJlY3Rhbmd1bGFyLCByZW5kZXJUYXJnZXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlcyBhIFBNUkVNIGZyb20gYW4gY3ViZW1hcCB0ZXh0dXJlLCB3aGljaCBjYW4gYmUgZWl0aGVyIExEUlxuXHQgKiBvciBIRFIuIFRoZSBpZGVhbCBpbnB1dCBjdWJlIHNpemUgaXMgMjU2IHggMjU2LFxuXHQgKiBhcyB0aGlzIG1hdGNoZXMgYmVzdCB3aXRoIHRoZSAyNTYgeCAyNTYgY3ViZW1hcCBvdXRwdXQuXG5cdCAqL1xuXHRmcm9tQ3ViZW1hcChjdWJlbWFwLCByZW5kZXJUYXJnZXQgPSBudWxsKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Zyb21UZXh0dXJlKGN1YmVtYXAsIHJlbmRlclRhcmdldCk7XG5cdH1cblxuXHQvKipcblx0ICogUHJlLWNvbXBpbGVzIHRoZSBjdWJlbWFwIHNoYWRlci4gWW91IGNhbiBnZXQgZmFzdGVyIHN0YXJ0LXVwIGJ5IGludm9raW5nIHRoaXMgbWV0aG9kIGR1cmluZ1xuXHQgKiB5b3VyIHRleHR1cmUncyBuZXR3b3JrIGZldGNoIGZvciBpbmNyZWFzZWQgY29uY3VycmVuY3kuXG5cdCAqL1xuXHRjb21waWxlQ3ViZW1hcFNoYWRlcigpIHtcblx0XHRpZiAodGhpcy5fY3ViZW1hcE1hdGVyaWFsID09PSBudWxsKSB7XG5cdFx0XHR0aGlzLl9jdWJlbWFwTWF0ZXJpYWwgPSBfZ2V0Q3ViZW1hcE1hdGVyaWFsKCk7XG5cdFx0XHR0aGlzLl9jb21waWxlTWF0ZXJpYWwodGhpcy5fY3ViZW1hcE1hdGVyaWFsKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUHJlLWNvbXBpbGVzIHRoZSBlcXVpcmVjdGFuZ3VsYXIgc2hhZGVyLiBZb3UgY2FuIGdldCBmYXN0ZXIgc3RhcnQtdXAgYnkgaW52b2tpbmcgdGhpcyBtZXRob2QgZHVyaW5nXG5cdCAqIHlvdXIgdGV4dHVyZSdzIG5ldHdvcmsgZmV0Y2ggZm9yIGluY3JlYXNlZCBjb25jdXJyZW5jeS5cblx0ICovXG5cdGNvbXBpbGVFcXVpcmVjdGFuZ3VsYXJTaGFkZXIoKSB7XG5cdFx0aWYgKHRoaXMuX2VxdWlyZWN0TWF0ZXJpYWwgPT09IG51bGwpIHtcblx0XHRcdHRoaXMuX2VxdWlyZWN0TWF0ZXJpYWwgPSBfZ2V0RXF1aXJlY3RNYXRlcmlhbCgpO1xuXHRcdFx0dGhpcy5fY29tcGlsZU1hdGVyaWFsKHRoaXMuX2VxdWlyZWN0TWF0ZXJpYWwpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBEaXNwb3NlcyBvZiB0aGUgUE1SRU1HZW5lcmF0b3IncyBpbnRlcm5hbCBtZW1vcnkuIE5vdGUgdGhhdCBQTVJFTUdlbmVyYXRvciBpcyBhIHN0YXRpYyBjbGFzcyxcblx0ICogc28geW91IHNob3VsZCBub3QgbmVlZCBtb3JlIHRoYW4gb25lIFBNUkVNR2VuZXJhdG9yIG9iamVjdC4gSWYgeW91IGRvLCBjYWxsaW5nIGRpc3Bvc2UoKSBvblxuXHQgKiBvbmUgb2YgdGhlbSB3aWxsIGNhdXNlIGFueSBvdGhlcnMgdG8gYWxzbyBiZWNvbWUgdW51c2FibGUuXG5cdCAqL1xuXHRkaXNwb3NlKCkge1xuXHRcdHRoaXMuX2Rpc3Bvc2UoKTtcblx0XHRpZiAodGhpcy5fY3ViZW1hcE1hdGVyaWFsICE9PSBudWxsKSB0aGlzLl9jdWJlbWFwTWF0ZXJpYWwuZGlzcG9zZSgpO1xuXHRcdGlmICh0aGlzLl9lcXVpcmVjdE1hdGVyaWFsICE9PSBudWxsKSB0aGlzLl9lcXVpcmVjdE1hdGVyaWFsLmRpc3Bvc2UoKTtcblx0fVxuXG5cdC8vIHByaXZhdGUgaW50ZXJmYWNlXG5cblx0X3NldFNpemUoY3ViZVNpemUpIHtcblx0XHR0aGlzLl9sb2RNYXggPSBNYXRoLmZsb29yKE1hdGgubG9nMihjdWJlU2l6ZSkpO1xuXHRcdHRoaXMuX2N1YmVTaXplID0gTWF0aC5wb3coMiwgdGhpcy5fbG9kTWF4KTtcblx0fVxuXHRfZGlzcG9zZSgpIHtcblx0XHRpZiAodGhpcy5fYmx1ck1hdGVyaWFsICE9PSBudWxsKSB0aGlzLl9ibHVyTWF0ZXJpYWwuZGlzcG9zZSgpO1xuXHRcdGlmICh0aGlzLl9waW5nUG9uZ1JlbmRlclRhcmdldCAhPT0gbnVsbCkgdGhpcy5fcGluZ1BvbmdSZW5kZXJUYXJnZXQuZGlzcG9zZSgpO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbG9kUGxhbmVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0aGlzLl9sb2RQbGFuZXNbaV0uZGlzcG9zZSgpO1xuXHRcdH1cblx0fVxuXHRfY2xlYW51cChvdXRwdXRUYXJnZXQpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoX29sZFRhcmdldCk7XG5cdFx0b3V0cHV0VGFyZ2V0LnNjaXNzb3JUZXN0ID0gZmFsc2U7XG5cdFx0X3NldFZpZXdwb3J0KG91dHB1dFRhcmdldCwgMCwgMCwgb3V0cHV0VGFyZ2V0LndpZHRoLCBvdXRwdXRUYXJnZXQuaGVpZ2h0KTtcblx0fVxuXHRfZnJvbVRleHR1cmUodGV4dHVyZSwgcmVuZGVyVGFyZ2V0KSB7XG5cdFx0aWYgKHRleHR1cmUubWFwcGluZyA9PT0gQ3ViZVJlZmxlY3Rpb25NYXBwaW5nIHx8IHRleHR1cmUubWFwcGluZyA9PT0gQ3ViZVJlZnJhY3Rpb25NYXBwaW5nKSB7XG5cdFx0XHR0aGlzLl9zZXRTaXplKHRleHR1cmUuaW1hZ2UubGVuZ3RoID09PSAwID8gMTYgOiB0ZXh0dXJlLmltYWdlWzBdLndpZHRoIHx8IHRleHR1cmUuaW1hZ2VbMF0uaW1hZ2Uud2lkdGgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBFcXVpcmVjdGFuZ3VsYXJcblxuXHRcdFx0dGhpcy5fc2V0U2l6ZSh0ZXh0dXJlLmltYWdlLndpZHRoIC8gNCk7XG5cdFx0fVxuXHRcdF9vbGRUYXJnZXQgPSB0aGlzLl9yZW5kZXJlci5nZXRSZW5kZXJUYXJnZXQoKTtcblx0XHRjb25zdCBjdWJlVVZSZW5kZXJUYXJnZXQgPSByZW5kZXJUYXJnZXQgfHwgdGhpcy5fYWxsb2NhdGVUYXJnZXRzKCk7XG5cdFx0dGhpcy5fdGV4dHVyZVRvQ3ViZVVWKHRleHR1cmUsIGN1YmVVVlJlbmRlclRhcmdldCk7XG5cdFx0dGhpcy5fYXBwbHlQTVJFTShjdWJlVVZSZW5kZXJUYXJnZXQpO1xuXHRcdHRoaXMuX2NsZWFudXAoY3ViZVVWUmVuZGVyVGFyZ2V0KTtcblx0XHRyZXR1cm4gY3ViZVVWUmVuZGVyVGFyZ2V0O1xuXHR9XG5cdF9hbGxvY2F0ZVRhcmdldHMoKSB7XG5cdFx0Y29uc3Qgd2lkdGggPSAzICogTWF0aC5tYXgodGhpcy5fY3ViZVNpemUsIDE2ICogNyk7XG5cdFx0Y29uc3QgaGVpZ2h0ID0gNCAqIHRoaXMuX2N1YmVTaXplO1xuXHRcdGNvbnN0IHBhcmFtcyA9IHtcblx0XHRcdG1hZ0ZpbHRlcjogTGluZWFyRmlsdGVyLFxuXHRcdFx0bWluRmlsdGVyOiBMaW5lYXJGaWx0ZXIsXG5cdFx0XHRnZW5lcmF0ZU1pcG1hcHM6IGZhbHNlLFxuXHRcdFx0dHlwZTogSGFsZkZsb2F0VHlwZSxcblx0XHRcdGZvcm1hdDogUkdCQUZvcm1hdCxcblx0XHRcdGVuY29kaW5nOiBMaW5lYXJFbmNvZGluZyxcblx0XHRcdGRlcHRoQnVmZmVyOiBmYWxzZVxuXHRcdH07XG5cdFx0Y29uc3QgY3ViZVVWUmVuZGVyVGFyZ2V0ID0gX2NyZWF0ZVJlbmRlclRhcmdldCh3aWR0aCwgaGVpZ2h0LCBwYXJhbXMpO1xuXHRcdGlmICh0aGlzLl9waW5nUG9uZ1JlbmRlclRhcmdldCA9PT0gbnVsbCB8fCB0aGlzLl9waW5nUG9uZ1JlbmRlclRhcmdldC53aWR0aCAhPT0gd2lkdGgpIHtcblx0XHRcdGlmICh0aGlzLl9waW5nUG9uZ1JlbmRlclRhcmdldCAhPT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLl9kaXNwb3NlKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9waW5nUG9uZ1JlbmRlclRhcmdldCA9IF9jcmVhdGVSZW5kZXJUYXJnZXQod2lkdGgsIGhlaWdodCwgcGFyYW1zKTtcblx0XHRcdGNvbnN0IHtcblx0XHRcdFx0X2xvZE1heFxuXHRcdFx0fSA9IHRoaXM7XG5cdFx0XHQoe1xuXHRcdFx0XHRzaXplTG9kczogdGhpcy5fc2l6ZUxvZHMsXG5cdFx0XHRcdGxvZFBsYW5lczogdGhpcy5fbG9kUGxhbmVzLFxuXHRcdFx0XHRzaWdtYXM6IHRoaXMuX3NpZ21hc1xuXHRcdFx0fSA9IF9jcmVhdGVQbGFuZXMoX2xvZE1heCkpO1xuXHRcdFx0dGhpcy5fYmx1ck1hdGVyaWFsID0gX2dldEJsdXJTaGFkZXIoX2xvZE1heCwgd2lkdGgsIGhlaWdodCk7XG5cdFx0fVxuXHRcdHJldHVybiBjdWJlVVZSZW5kZXJUYXJnZXQ7XG5cdH1cblx0X2NvbXBpbGVNYXRlcmlhbChtYXRlcmlhbCkge1xuXHRcdGNvbnN0IHRtcE1lc2ggPSBuZXcgTWVzaCh0aGlzLl9sb2RQbGFuZXNbMF0sIG1hdGVyaWFsKTtcblx0XHR0aGlzLl9yZW5kZXJlci5jb21waWxlKHRtcE1lc2gsIF9mbGF0Q2FtZXJhKTtcblx0fVxuXHRfc2NlbmVUb0N1YmVVVihzY2VuZSwgbmVhciwgZmFyLCBjdWJlVVZSZW5kZXJUYXJnZXQpIHtcblx0XHRjb25zdCBmb3YgPSA5MDtcblx0XHRjb25zdCBhc3BlY3QgPSAxO1xuXHRcdGNvbnN0IGN1YmVDYW1lcmEgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoZm92LCBhc3BlY3QsIG5lYXIsIGZhcik7XG5cdFx0Y29uc3QgdXBTaWduID0gWzEsIC0xLCAxLCAxLCAxLCAxXTtcblx0XHRjb25zdCBmb3J3YXJkU2lnbiA9IFsxLCAxLCAxLCAtMSwgLTEsIC0xXTtcblx0XHRjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuXHRcdGNvbnN0IG9yaWdpbmFsQXV0b0NsZWFyID0gcmVuZGVyZXIuYXV0b0NsZWFyO1xuXHRcdGNvbnN0IHRvbmVNYXBwaW5nID0gcmVuZGVyZXIudG9uZU1hcHBpbmc7XG5cdFx0cmVuZGVyZXIuZ2V0Q2xlYXJDb2xvcihfY2xlYXJDb2xvcik7XG5cdFx0cmVuZGVyZXIudG9uZU1hcHBpbmcgPSBOb1RvbmVNYXBwaW5nO1xuXHRcdHJlbmRlcmVyLmF1dG9DbGVhciA9IGZhbHNlO1xuXHRcdGNvbnN0IGJhY2tncm91bmRNYXRlcmlhbCA9IG5ldyBNZXNoQmFzaWNNYXRlcmlhbCh7XG5cdFx0XHRuYW1lOiAnUE1SRU0uQmFja2dyb3VuZCcsXG5cdFx0XHRzaWRlOiBCYWNrU2lkZSxcblx0XHRcdGRlcHRoV3JpdGU6IGZhbHNlLFxuXHRcdFx0ZGVwdGhUZXN0OiBmYWxzZVxuXHRcdH0pO1xuXHRcdGNvbnN0IGJhY2tncm91bmRCb3ggPSBuZXcgTWVzaChuZXcgQm94R2VvbWV0cnkoKSwgYmFja2dyb3VuZE1hdGVyaWFsKTtcblx0XHRsZXQgdXNlU29saWRDb2xvciA9IGZhbHNlO1xuXHRcdGNvbnN0IGJhY2tncm91bmQgPSBzY2VuZS5iYWNrZ3JvdW5kO1xuXHRcdGlmIChiYWNrZ3JvdW5kKSB7XG5cdFx0XHRpZiAoYmFja2dyb3VuZC5pc0NvbG9yKSB7XG5cdFx0XHRcdGJhY2tncm91bmRNYXRlcmlhbC5jb2xvci5jb3B5KGJhY2tncm91bmQpO1xuXHRcdFx0XHRzY2VuZS5iYWNrZ3JvdW5kID0gbnVsbDtcblx0XHRcdFx0dXNlU29saWRDb2xvciA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGJhY2tncm91bmRNYXRlcmlhbC5jb2xvci5jb3B5KF9jbGVhckNvbG9yKTtcblx0XHRcdHVzZVNvbGlkQ29sb3IgPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xuXHRcdFx0Y29uc3QgY29sID0gaSAlIDM7XG5cdFx0XHRpZiAoY29sID09PSAwKSB7XG5cdFx0XHRcdGN1YmVDYW1lcmEudXAuc2V0KDAsIHVwU2lnbltpXSwgMCk7XG5cdFx0XHRcdGN1YmVDYW1lcmEubG9va0F0KGZvcndhcmRTaWduW2ldLCAwLCAwKTtcblx0XHRcdH0gZWxzZSBpZiAoY29sID09PSAxKSB7XG5cdFx0XHRcdGN1YmVDYW1lcmEudXAuc2V0KDAsIDAsIHVwU2lnbltpXSk7XG5cdFx0XHRcdGN1YmVDYW1lcmEubG9va0F0KDAsIGZvcndhcmRTaWduW2ldLCAwKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGN1YmVDYW1lcmEudXAuc2V0KDAsIHVwU2lnbltpXSwgMCk7XG5cdFx0XHRcdGN1YmVDYW1lcmEubG9va0F0KDAsIDAsIGZvcndhcmRTaWduW2ldKTtcblx0XHRcdH1cblx0XHRcdGNvbnN0IHNpemUgPSB0aGlzLl9jdWJlU2l6ZTtcblx0XHRcdF9zZXRWaWV3cG9ydChjdWJlVVZSZW5kZXJUYXJnZXQsIGNvbCAqIHNpemUsIGkgPiAyID8gc2l6ZSA6IDAsIHNpemUsIHNpemUpO1xuXHRcdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KGN1YmVVVlJlbmRlclRhcmdldCk7XG5cdFx0XHRpZiAodXNlU29saWRDb2xvcikge1xuXHRcdFx0XHRyZW5kZXJlci5yZW5kZXIoYmFja2dyb3VuZEJveCwgY3ViZUNhbWVyYSk7XG5cdFx0XHR9XG5cdFx0XHRyZW5kZXJlci5yZW5kZXIoc2NlbmUsIGN1YmVDYW1lcmEpO1xuXHRcdH1cblx0XHRiYWNrZ3JvdW5kQm94Lmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0XHRiYWNrZ3JvdW5kQm94Lm1hdGVyaWFsLmRpc3Bvc2UoKTtcblx0XHRyZW5kZXJlci50b25lTWFwcGluZyA9IHRvbmVNYXBwaW5nO1xuXHRcdHJlbmRlcmVyLmF1dG9DbGVhciA9IG9yaWdpbmFsQXV0b0NsZWFyO1xuXHRcdHNjZW5lLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kO1xuXHR9XG5cdF90ZXh0dXJlVG9DdWJlVVYodGV4dHVyZSwgY3ViZVVWUmVuZGVyVGFyZ2V0KSB7XG5cdFx0Y29uc3QgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcjtcblx0XHRjb25zdCBpc0N1YmVUZXh0dXJlID0gdGV4dHVyZS5tYXBwaW5nID09PSBDdWJlUmVmbGVjdGlvbk1hcHBpbmcgfHwgdGV4dHVyZS5tYXBwaW5nID09PSBDdWJlUmVmcmFjdGlvbk1hcHBpbmc7XG5cdFx0aWYgKGlzQ3ViZVRleHR1cmUpIHtcblx0XHRcdGlmICh0aGlzLl9jdWJlbWFwTWF0ZXJpYWwgPT09IG51bGwpIHtcblx0XHRcdFx0dGhpcy5fY3ViZW1hcE1hdGVyaWFsID0gX2dldEN1YmVtYXBNYXRlcmlhbCgpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fY3ViZW1hcE1hdGVyaWFsLnVuaWZvcm1zLmZsaXBFbnZNYXAudmFsdWUgPSB0ZXh0dXJlLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSA9PT0gZmFsc2UgPyAtMSA6IDE7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICh0aGlzLl9lcXVpcmVjdE1hdGVyaWFsID09PSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuX2VxdWlyZWN0TWF0ZXJpYWwgPSBfZ2V0RXF1aXJlY3RNYXRlcmlhbCgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRjb25zdCBtYXRlcmlhbCA9IGlzQ3ViZVRleHR1cmUgPyB0aGlzLl9jdWJlbWFwTWF0ZXJpYWwgOiB0aGlzLl9lcXVpcmVjdE1hdGVyaWFsO1xuXHRcdGNvbnN0IG1lc2ggPSBuZXcgTWVzaCh0aGlzLl9sb2RQbGFuZXNbMF0sIG1hdGVyaWFsKTtcblx0XHRjb25zdCB1bmlmb3JtcyA9IG1hdGVyaWFsLnVuaWZvcm1zO1xuXHRcdHVuaWZvcm1zWydlbnZNYXAnXS52YWx1ZSA9IHRleHR1cmU7XG5cdFx0Y29uc3Qgc2l6ZSA9IHRoaXMuX2N1YmVTaXplO1xuXHRcdF9zZXRWaWV3cG9ydChjdWJlVVZSZW5kZXJUYXJnZXQsIDAsIDAsIDMgKiBzaXplLCAyICogc2l6ZSk7XG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KGN1YmVVVlJlbmRlclRhcmdldCk7XG5cdFx0cmVuZGVyZXIucmVuZGVyKG1lc2gsIF9mbGF0Q2FtZXJhKTtcblx0fVxuXHRfYXBwbHlQTVJFTShjdWJlVVZSZW5kZXJUYXJnZXQpIHtcblx0XHRjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuXHRcdGNvbnN0IGF1dG9DbGVhciA9IHJlbmRlcmVyLmF1dG9DbGVhcjtcblx0XHRyZW5kZXJlci5hdXRvQ2xlYXIgPSBmYWxzZTtcblx0XHRmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMuX2xvZFBsYW5lcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3Qgc2lnbWEgPSBNYXRoLnNxcnQodGhpcy5fc2lnbWFzW2ldICogdGhpcy5fc2lnbWFzW2ldIC0gdGhpcy5fc2lnbWFzW2kgLSAxXSAqIHRoaXMuX3NpZ21hc1tpIC0gMV0pO1xuXHRcdFx0Y29uc3QgcG9sZUF4aXMgPSBfYXhpc0RpcmVjdGlvbnNbKGkgLSAxKSAlIF9heGlzRGlyZWN0aW9ucy5sZW5ndGhdO1xuXHRcdFx0dGhpcy5fYmx1cihjdWJlVVZSZW5kZXJUYXJnZXQsIGkgLSAxLCBpLCBzaWdtYSwgcG9sZUF4aXMpO1xuXHRcdH1cblx0XHRyZW5kZXJlci5hdXRvQ2xlYXIgPSBhdXRvQ2xlYXI7XG5cdH1cblxuXHQvKipcblx0ICogVGhpcyBpcyBhIHR3by1wYXNzIEdhdXNzaWFuIGJsdXIgZm9yIGEgY3ViZW1hcC4gTm9ybWFsbHkgdGhpcyBpcyBkb25lXG5cdCAqIHZlcnRpY2FsbHkgYW5kIGhvcml6b250YWxseSwgYnV0IHRoaXMgYnJlYWtzIGRvd24gb24gYSBjdWJlLiBIZXJlIHdlIGFwcGx5XG5cdCAqIHRoZSBibHVyIGxhdGl0dWRpbmFsbHkgKGFyb3VuZCB0aGUgcG9sZXMpLCBhbmQgdGhlbiBsb25naXR1ZGluYWxseSAodG93YXJkc1xuXHQgKiB0aGUgcG9sZXMpIHRvIGFwcHJveGltYXRlIHRoZSBvcnRob2dvbmFsbHktc2VwYXJhYmxlIGJsdXIuIEl0IGlzIGxlYXN0XG5cdCAqIGFjY3VyYXRlIGF0IHRoZSBwb2xlcywgYnV0IHN0aWxsIGRvZXMgYSBkZWNlbnQgam9iLlxuXHQgKi9cblx0X2JsdXIoY3ViZVVWUmVuZGVyVGFyZ2V0LCBsb2RJbiwgbG9kT3V0LCBzaWdtYSwgcG9sZUF4aXMpIHtcblx0XHRjb25zdCBwaW5nUG9uZ1JlbmRlclRhcmdldCA9IHRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0O1xuXHRcdHRoaXMuX2hhbGZCbHVyKGN1YmVVVlJlbmRlclRhcmdldCwgcGluZ1BvbmdSZW5kZXJUYXJnZXQsIGxvZEluLCBsb2RPdXQsIHNpZ21hLCAnbGF0aXR1ZGluYWwnLCBwb2xlQXhpcyk7XG5cdFx0dGhpcy5faGFsZkJsdXIocGluZ1BvbmdSZW5kZXJUYXJnZXQsIGN1YmVVVlJlbmRlclRhcmdldCwgbG9kT3V0LCBsb2RPdXQsIHNpZ21hLCAnbG9uZ2l0dWRpbmFsJywgcG9sZUF4aXMpO1xuXHR9XG5cdF9oYWxmQmx1cih0YXJnZXRJbiwgdGFyZ2V0T3V0LCBsb2RJbiwgbG9kT3V0LCBzaWdtYVJhZGlhbnMsIGRpcmVjdGlvbiwgcG9sZUF4aXMpIHtcblx0XHRjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuXHRcdGNvbnN0IGJsdXJNYXRlcmlhbCA9IHRoaXMuX2JsdXJNYXRlcmlhbDtcblx0XHRpZiAoZGlyZWN0aW9uICE9PSAnbGF0aXR1ZGluYWwnICYmIGRpcmVjdGlvbiAhPT0gJ2xvbmdpdHVkaW5hbCcpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ2JsdXIgZGlyZWN0aW9uIG11c3QgYmUgZWl0aGVyIGxhdGl0dWRpbmFsIG9yIGxvbmdpdHVkaW5hbCEnKTtcblx0XHR9XG5cblx0XHQvLyBOdW1iZXIgb2Ygc3RhbmRhcmQgZGV2aWF0aW9ucyBhdCB3aGljaCB0byBjdXQgb2ZmIHRoZSBkaXNjcmV0ZSBhcHByb3hpbWF0aW9uLlxuXHRcdGNvbnN0IFNUQU5EQVJEX0RFVklBVElPTlMgPSAzO1xuXHRcdGNvbnN0IGJsdXJNZXNoID0gbmV3IE1lc2godGhpcy5fbG9kUGxhbmVzW2xvZE91dF0sIGJsdXJNYXRlcmlhbCk7XG5cdFx0Y29uc3QgYmx1clVuaWZvcm1zID0gYmx1ck1hdGVyaWFsLnVuaWZvcm1zO1xuXHRcdGNvbnN0IHBpeGVscyA9IHRoaXMuX3NpemVMb2RzW2xvZEluXSAtIDE7XG5cdFx0Y29uc3QgcmFkaWFuc1BlclBpeGVsID0gaXNGaW5pdGUoc2lnbWFSYWRpYW5zKSA/IE1hdGguUEkgLyAoMiAqIHBpeGVscykgOiAyICogTWF0aC5QSSAvICgyICogTUFYX1NBTVBMRVMgLSAxKTtcblx0XHRjb25zdCBzaWdtYVBpeGVscyA9IHNpZ21hUmFkaWFucyAvIHJhZGlhbnNQZXJQaXhlbDtcblx0XHRjb25zdCBzYW1wbGVzID0gaXNGaW5pdGUoc2lnbWFSYWRpYW5zKSA/IDEgKyBNYXRoLmZsb29yKFNUQU5EQVJEX0RFVklBVElPTlMgKiBzaWdtYVBpeGVscykgOiBNQVhfU0FNUExFUztcblx0XHRpZiAoc2FtcGxlcyA+IE1BWF9TQU1QTEVTKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oYHNpZ21hUmFkaWFucywgJHtzaWdtYVJhZGlhbnN9LCBpcyB0b28gbGFyZ2UgYW5kIHdpbGwgY2xpcCwgYXMgaXQgcmVxdWVzdGVkICR7c2FtcGxlc30gc2FtcGxlcyB3aGVuIHRoZSBtYXhpbXVtIGlzIHNldCB0byAke01BWF9TQU1QTEVTfWApO1xuXHRcdH1cblx0XHRjb25zdCB3ZWlnaHRzID0gW107XG5cdFx0bGV0IHN1bSA9IDA7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBNQVhfU0FNUExFUzsgKytpKSB7XG5cdFx0XHRjb25zdCB4ID0gaSAvIHNpZ21hUGl4ZWxzO1xuXHRcdFx0Y29uc3Qgd2VpZ2h0ID0gTWF0aC5leHAoLXggKiB4IC8gMik7XG5cdFx0XHR3ZWlnaHRzLnB1c2god2VpZ2h0KTtcblx0XHRcdGlmIChpID09PSAwKSB7XG5cdFx0XHRcdHN1bSArPSB3ZWlnaHQ7XG5cdFx0XHR9IGVsc2UgaWYgKGkgPCBzYW1wbGVzKSB7XG5cdFx0XHRcdHN1bSArPSAyICogd2VpZ2h0O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHdlaWdodHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHdlaWdodHNbaV0gPSB3ZWlnaHRzW2ldIC8gc3VtO1xuXHRcdH1cblx0XHRibHVyVW5pZm9ybXNbJ2Vudk1hcCddLnZhbHVlID0gdGFyZ2V0SW4udGV4dHVyZTtcblx0XHRibHVyVW5pZm9ybXNbJ3NhbXBsZXMnXS52YWx1ZSA9IHNhbXBsZXM7XG5cdFx0Ymx1clVuaWZvcm1zWyd3ZWlnaHRzJ10udmFsdWUgPSB3ZWlnaHRzO1xuXHRcdGJsdXJVbmlmb3Jtc1snbGF0aXR1ZGluYWwnXS52YWx1ZSA9IGRpcmVjdGlvbiA9PT0gJ2xhdGl0dWRpbmFsJztcblx0XHRpZiAocG9sZUF4aXMpIHtcblx0XHRcdGJsdXJVbmlmb3Jtc1sncG9sZUF4aXMnXS52YWx1ZSA9IHBvbGVBeGlzO1xuXHRcdH1cblx0XHRjb25zdCB7XG5cdFx0XHRfbG9kTWF4XG5cdFx0fSA9IHRoaXM7XG5cdFx0Ymx1clVuaWZvcm1zWydkVGhldGEnXS52YWx1ZSA9IHJhZGlhbnNQZXJQaXhlbDtcblx0XHRibHVyVW5pZm9ybXNbJ21pcEludCddLnZhbHVlID0gX2xvZE1heCAtIGxvZEluO1xuXHRcdGNvbnN0IG91dHB1dFNpemUgPSB0aGlzLl9zaXplTG9kc1tsb2RPdXRdO1xuXHRcdGNvbnN0IHggPSAzICogb3V0cHV0U2l6ZSAqIChsb2RPdXQgPiBfbG9kTWF4IC0gTE9EX01JTiA/IGxvZE91dCAtIF9sb2RNYXggKyBMT0RfTUlOIDogMCk7XG5cdFx0Y29uc3QgeSA9IDQgKiAodGhpcy5fY3ViZVNpemUgLSBvdXRwdXRTaXplKTtcblx0XHRfc2V0Vmlld3BvcnQodGFyZ2V0T3V0LCB4LCB5LCAzICogb3V0cHV0U2l6ZSwgMiAqIG91dHB1dFNpemUpO1xuXHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCh0YXJnZXRPdXQpO1xuXHRcdHJlbmRlcmVyLnJlbmRlcihibHVyTWVzaCwgX2ZsYXRDYW1lcmEpO1xuXHR9XG59XG5mdW5jdGlvbiBfY3JlYXRlUGxhbmVzKGxvZE1heCkge1xuXHRjb25zdCBsb2RQbGFuZXMgPSBbXTtcblx0Y29uc3Qgc2l6ZUxvZHMgPSBbXTtcblx0Y29uc3Qgc2lnbWFzID0gW107XG5cdGxldCBsb2QgPSBsb2RNYXg7XG5cdGNvbnN0IHRvdGFsTG9kcyA9IGxvZE1heCAtIExPRF9NSU4gKyAxICsgRVhUUkFfTE9EX1NJR01BLmxlbmd0aDtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbExvZHM7IGkrKykge1xuXHRcdGNvbnN0IHNpemVMb2QgPSBNYXRoLnBvdygyLCBsb2QpO1xuXHRcdHNpemVMb2RzLnB1c2goc2l6ZUxvZCk7XG5cdFx0bGV0IHNpZ21hID0gMS4wIC8gc2l6ZUxvZDtcblx0XHRpZiAoaSA+IGxvZE1heCAtIExPRF9NSU4pIHtcblx0XHRcdHNpZ21hID0gRVhUUkFfTE9EX1NJR01BW2kgLSBsb2RNYXggKyBMT0RfTUlOIC0gMV07XG5cdFx0fSBlbHNlIGlmIChpID09PSAwKSB7XG5cdFx0XHRzaWdtYSA9IDA7XG5cdFx0fVxuXHRcdHNpZ21hcy5wdXNoKHNpZ21hKTtcblx0XHRjb25zdCB0ZXhlbFNpemUgPSAxLjAgLyAoc2l6ZUxvZCAtIDIpO1xuXHRcdGNvbnN0IG1pbiA9IC10ZXhlbFNpemU7XG5cdFx0Y29uc3QgbWF4ID0gMSArIHRleGVsU2l6ZTtcblx0XHRjb25zdCB1djEgPSBbbWluLCBtaW4sIG1heCwgbWluLCBtYXgsIG1heCwgbWluLCBtaW4sIG1heCwgbWF4LCBtaW4sIG1heF07XG5cdFx0Y29uc3QgY3ViZUZhY2VzID0gNjtcblx0XHRjb25zdCB2ZXJ0aWNlcyA9IDY7XG5cdFx0Y29uc3QgcG9zaXRpb25TaXplID0gMztcblx0XHRjb25zdCB1dlNpemUgPSAyO1xuXHRcdGNvbnN0IGZhY2VJbmRleFNpemUgPSAxO1xuXHRcdGNvbnN0IHBvc2l0aW9uID0gbmV3IEZsb2F0MzJBcnJheShwb3NpdGlvblNpemUgKiB2ZXJ0aWNlcyAqIGN1YmVGYWNlcyk7XG5cdFx0Y29uc3QgdXYgPSBuZXcgRmxvYXQzMkFycmF5KHV2U2l6ZSAqIHZlcnRpY2VzICogY3ViZUZhY2VzKTtcblx0XHRjb25zdCBmYWNlSW5kZXggPSBuZXcgRmxvYXQzMkFycmF5KGZhY2VJbmRleFNpemUgKiB2ZXJ0aWNlcyAqIGN1YmVGYWNlcyk7XG5cdFx0Zm9yIChsZXQgZmFjZSA9IDA7IGZhY2UgPCBjdWJlRmFjZXM7IGZhY2UrKykge1xuXHRcdFx0Y29uc3QgeCA9IGZhY2UgJSAzICogMiAvIDMgLSAxO1xuXHRcdFx0Y29uc3QgeSA9IGZhY2UgPiAyID8gMCA6IC0xO1xuXHRcdFx0Y29uc3QgY29vcmRpbmF0ZXMgPSBbeCwgeSwgMCwgeCArIDIgLyAzLCB5LCAwLCB4ICsgMiAvIDMsIHkgKyAxLCAwLCB4LCB5LCAwLCB4ICsgMiAvIDMsIHkgKyAxLCAwLCB4LCB5ICsgMSwgMF07XG5cdFx0XHRwb3NpdGlvbi5zZXQoY29vcmRpbmF0ZXMsIHBvc2l0aW9uU2l6ZSAqIHZlcnRpY2VzICogZmFjZSk7XG5cdFx0XHR1di5zZXQodXYxLCB1dlNpemUgKiB2ZXJ0aWNlcyAqIGZhY2UpO1xuXHRcdFx0Y29uc3QgZmlsbCA9IFtmYWNlLCBmYWNlLCBmYWNlLCBmYWNlLCBmYWNlLCBmYWNlXTtcblx0XHRcdGZhY2VJbmRleC5zZXQoZmlsbCwgZmFjZUluZGV4U2l6ZSAqIHZlcnRpY2VzICogZmFjZSk7XG5cdFx0fVxuXHRcdGNvbnN0IHBsYW5lcyA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdHBsYW5lcy5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbiwgcG9zaXRpb25TaXplKSk7XG5cdFx0cGxhbmVzLnNldEF0dHJpYnV0ZSgndXYnLCBuZXcgQnVmZmVyQXR0cmlidXRlKHV2LCB1dlNpemUpKTtcblx0XHRwbGFuZXMuc2V0QXR0cmlidXRlKCdmYWNlSW5kZXgnLCBuZXcgQnVmZmVyQXR0cmlidXRlKGZhY2VJbmRleCwgZmFjZUluZGV4U2l6ZSkpO1xuXHRcdGxvZFBsYW5lcy5wdXNoKHBsYW5lcyk7XG5cdFx0aWYgKGxvZCA+IExPRF9NSU4pIHtcblx0XHRcdGxvZC0tO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4ge1xuXHRcdGxvZFBsYW5lcyxcblx0XHRzaXplTG9kcyxcblx0XHRzaWdtYXNcblx0fTtcbn1cbmZ1bmN0aW9uIF9jcmVhdGVSZW5kZXJUYXJnZXQod2lkdGgsIGhlaWdodCwgcGFyYW1zKSB7XG5cdGNvbnN0IGN1YmVVVlJlbmRlclRhcmdldCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldCh3aWR0aCwgaGVpZ2h0LCBwYXJhbXMpO1xuXHRjdWJlVVZSZW5kZXJUYXJnZXQudGV4dHVyZS5tYXBwaW5nID0gQ3ViZVVWUmVmbGVjdGlvbk1hcHBpbmc7XG5cdGN1YmVVVlJlbmRlclRhcmdldC50ZXh0dXJlLm5hbWUgPSAnUE1SRU0uY3ViZVV2Jztcblx0Y3ViZVVWUmVuZGVyVGFyZ2V0LnNjaXNzb3JUZXN0ID0gdHJ1ZTtcblx0cmV0dXJuIGN1YmVVVlJlbmRlclRhcmdldDtcbn1cbmZ1bmN0aW9uIF9zZXRWaWV3cG9ydCh0YXJnZXQsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblx0dGFyZ2V0LnZpZXdwb3J0LnNldCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcblx0dGFyZ2V0LnNjaXNzb3Iuc2V0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xufVxuZnVuY3Rpb24gX2dldEJsdXJTaGFkZXIobG9kTWF4LCB3aWR0aCwgaGVpZ2h0KSB7XG5cdGNvbnN0IHdlaWdodHMgPSBuZXcgRmxvYXQzMkFycmF5KE1BWF9TQU1QTEVTKTtcblx0Y29uc3QgcG9sZUF4aXMgPSBuZXcgVmVjdG9yMygwLCAxLCAwKTtcblx0Y29uc3Qgc2hhZGVyTWF0ZXJpYWwgPSBuZXcgU2hhZGVyTWF0ZXJpYWwoe1xuXHRcdG5hbWU6ICdTcGhlcmljYWxHYXVzc2lhbkJsdXInLFxuXHRcdGRlZmluZXM6IHtcblx0XHRcdCduJzogTUFYX1NBTVBMRVMsXG5cdFx0XHQnQ1VCRVVWX1RFWEVMX1dJRFRIJzogMS4wIC8gd2lkdGgsXG5cdFx0XHQnQ1VCRVVWX1RFWEVMX0hFSUdIVCc6IDEuMCAvIGhlaWdodCxcblx0XHRcdCdDVUJFVVZfTUFYX01JUCc6IGAke2xvZE1heH0uMGBcblx0XHR9LFxuXHRcdHVuaWZvcm1zOiB7XG5cdFx0XHQnZW52TWFwJzoge1xuXHRcdFx0XHR2YWx1ZTogbnVsbFxuXHRcdFx0fSxcblx0XHRcdCdzYW1wbGVzJzoge1xuXHRcdFx0XHR2YWx1ZTogMVxuXHRcdFx0fSxcblx0XHRcdCd3ZWlnaHRzJzoge1xuXHRcdFx0XHR2YWx1ZTogd2VpZ2h0c1xuXHRcdFx0fSxcblx0XHRcdCdsYXRpdHVkaW5hbCc6IHtcblx0XHRcdFx0dmFsdWU6IGZhbHNlXG5cdFx0XHR9LFxuXHRcdFx0J2RUaGV0YSc6IHtcblx0XHRcdFx0dmFsdWU6IDBcblx0XHRcdH0sXG5cdFx0XHQnbWlwSW50Jzoge1xuXHRcdFx0XHR2YWx1ZTogMFxuXHRcdFx0fSxcblx0XHRcdCdwb2xlQXhpcyc6IHtcblx0XHRcdFx0dmFsdWU6IHBvbGVBeGlzXG5cdFx0XHR9XG5cdFx0fSxcblx0XHR2ZXJ0ZXhTaGFkZXI6IF9nZXRDb21tb25WZXJ0ZXhTaGFkZXIoKSxcblx0XHRmcmFnbWVudFNoYWRlcjogLyogZ2xzbCAqL2BcblxuXHRcdFx0cHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG5cdFx0XHRwcmVjaXNpb24gbWVkaXVtcCBpbnQ7XG5cblx0XHRcdHZhcnlpbmcgdmVjMyB2T3V0cHV0RGlyZWN0aW9uO1xuXG5cdFx0XHR1bmlmb3JtIHNhbXBsZXIyRCBlbnZNYXA7XG5cdFx0XHR1bmlmb3JtIGludCBzYW1wbGVzO1xuXHRcdFx0dW5pZm9ybSBmbG9hdCB3ZWlnaHRzWyBuIF07XG5cdFx0XHR1bmlmb3JtIGJvb2wgbGF0aXR1ZGluYWw7XG5cdFx0XHR1bmlmb3JtIGZsb2F0IGRUaGV0YTtcblx0XHRcdHVuaWZvcm0gZmxvYXQgbWlwSW50O1xuXHRcdFx0dW5pZm9ybSB2ZWMzIHBvbGVBeGlzO1xuXG5cdFx0XHQjZGVmaW5lIEVOVk1BUF9UWVBFX0NVQkVfVVZcblx0XHRcdCNpbmNsdWRlIDxjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQ+XG5cblx0XHRcdHZlYzMgZ2V0U2FtcGxlKCBmbG9hdCB0aGV0YSwgdmVjMyBheGlzICkge1xuXG5cdFx0XHRcdGZsb2F0IGNvc1RoZXRhID0gY29zKCB0aGV0YSApO1xuXHRcdFx0XHQvLyBSb2RyaWd1ZXMnIGF4aXMtYW5nbGUgcm90YXRpb25cblx0XHRcdFx0dmVjMyBzYW1wbGVEaXJlY3Rpb24gPSB2T3V0cHV0RGlyZWN0aW9uICogY29zVGhldGFcblx0XHRcdFx0XHQrIGNyb3NzKCBheGlzLCB2T3V0cHV0RGlyZWN0aW9uICkgKiBzaW4oIHRoZXRhIClcblx0XHRcdFx0XHQrIGF4aXMgKiBkb3QoIGF4aXMsIHZPdXRwdXREaXJlY3Rpb24gKSAqICggMS4wIC0gY29zVGhldGEgKTtcblxuXHRcdFx0XHRyZXR1cm4gYmlsaW5lYXJDdWJlVVYoIGVudk1hcCwgc2FtcGxlRGlyZWN0aW9uLCBtaXBJbnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2b2lkIG1haW4oKSB7XG5cblx0XHRcdFx0dmVjMyBheGlzID0gbGF0aXR1ZGluYWwgPyBwb2xlQXhpcyA6IGNyb3NzKCBwb2xlQXhpcywgdk91dHB1dERpcmVjdGlvbiApO1xuXG5cdFx0XHRcdGlmICggYWxsKCBlcXVhbCggYXhpcywgdmVjMyggMC4wICkgKSApICkge1xuXG5cdFx0XHRcdFx0YXhpcyA9IHZlYzMoIHZPdXRwdXREaXJlY3Rpb24ueiwgMC4wLCAtIHZPdXRwdXREaXJlY3Rpb24ueCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRheGlzID0gbm9ybWFsaXplKCBheGlzICk7XG5cblx0XHRcdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggMC4wLCAwLjAsIDAuMCwgMS4wICk7XG5cdFx0XHRcdGdsX0ZyYWdDb2xvci5yZ2IgKz0gd2VpZ2h0c1sgMCBdICogZ2V0U2FtcGxlKCAwLjAsIGF4aXMgKTtcblxuXHRcdFx0XHRmb3IgKCBpbnQgaSA9IDE7IGkgPCBuOyBpKysgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGkgPj0gc2FtcGxlcyApIHtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRmbG9hdCB0aGV0YSA9IGRUaGV0YSAqIGZsb2F0KCBpICk7XG5cdFx0XHRcdFx0Z2xfRnJhZ0NvbG9yLnJnYiArPSB3ZWlnaHRzWyBpIF0gKiBnZXRTYW1wbGUoIC0xLjAgKiB0aGV0YSwgYXhpcyApO1xuXHRcdFx0XHRcdGdsX0ZyYWdDb2xvci5yZ2IgKz0gd2VpZ2h0c1sgaSBdICogZ2V0U2FtcGxlKCB0aGV0YSwgYXhpcyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXHRcdGAsXG5cdFx0YmxlbmRpbmc6IE5vQmxlbmRpbmcsXG5cdFx0ZGVwdGhUZXN0OiBmYWxzZSxcblx0XHRkZXB0aFdyaXRlOiBmYWxzZVxuXHR9KTtcblx0cmV0dXJuIHNoYWRlck1hdGVyaWFsO1xufVxuZnVuY3Rpb24gX2dldEVxdWlyZWN0TWF0ZXJpYWwoKSB7XG5cdHJldHVybiBuZXcgU2hhZGVyTWF0ZXJpYWwoe1xuXHRcdG5hbWU6ICdFcXVpcmVjdGFuZ3VsYXJUb0N1YmVVVicsXG5cdFx0dW5pZm9ybXM6IHtcblx0XHRcdCdlbnZNYXAnOiB7XG5cdFx0XHRcdHZhbHVlOiBudWxsXG5cdFx0XHR9XG5cdFx0fSxcblx0XHR2ZXJ0ZXhTaGFkZXI6IF9nZXRDb21tb25WZXJ0ZXhTaGFkZXIoKSxcblx0XHRmcmFnbWVudFNoYWRlcjogLyogZ2xzbCAqL2BcblxuXHRcdFx0cHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG5cdFx0XHRwcmVjaXNpb24gbWVkaXVtcCBpbnQ7XG5cblx0XHRcdHZhcnlpbmcgdmVjMyB2T3V0cHV0RGlyZWN0aW9uO1xuXG5cdFx0XHR1bmlmb3JtIHNhbXBsZXIyRCBlbnZNYXA7XG5cblx0XHRcdCNpbmNsdWRlIDxjb21tb24+XG5cblx0XHRcdHZvaWQgbWFpbigpIHtcblxuXHRcdFx0XHR2ZWMzIG91dHB1dERpcmVjdGlvbiA9IG5vcm1hbGl6ZSggdk91dHB1dERpcmVjdGlvbiApO1xuXHRcdFx0XHR2ZWMyIHV2ID0gZXF1aXJlY3RVdiggb3V0cHV0RGlyZWN0aW9uICk7XG5cblx0XHRcdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggdGV4dHVyZTJEICggZW52TWFwLCB1diApLnJnYiwgMS4wICk7XG5cblx0XHRcdH1cblx0XHRgLFxuXHRcdGJsZW5kaW5nOiBOb0JsZW5kaW5nLFxuXHRcdGRlcHRoVGVzdDogZmFsc2UsXG5cdFx0ZGVwdGhXcml0ZTogZmFsc2Vcblx0fSk7XG59XG5mdW5jdGlvbiBfZ2V0Q3ViZW1hcE1hdGVyaWFsKCkge1xuXHRyZXR1cm4gbmV3IFNoYWRlck1hdGVyaWFsKHtcblx0XHRuYW1lOiAnQ3ViZW1hcFRvQ3ViZVVWJyxcblx0XHR1bmlmb3Jtczoge1xuXHRcdFx0J2Vudk1hcCc6IHtcblx0XHRcdFx0dmFsdWU6IG51bGxcblx0XHRcdH0sXG5cdFx0XHQnZmxpcEVudk1hcCc6IHtcblx0XHRcdFx0dmFsdWU6IC0xXG5cdFx0XHR9XG5cdFx0fSxcblx0XHR2ZXJ0ZXhTaGFkZXI6IF9nZXRDb21tb25WZXJ0ZXhTaGFkZXIoKSxcblx0XHRmcmFnbWVudFNoYWRlcjogLyogZ2xzbCAqL2BcblxuXHRcdFx0cHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG5cdFx0XHRwcmVjaXNpb24gbWVkaXVtcCBpbnQ7XG5cblx0XHRcdHVuaWZvcm0gZmxvYXQgZmxpcEVudk1hcDtcblxuXHRcdFx0dmFyeWluZyB2ZWMzIHZPdXRwdXREaXJlY3Rpb247XG5cblx0XHRcdHVuaWZvcm0gc2FtcGxlckN1YmUgZW52TWFwO1xuXG5cdFx0XHR2b2lkIG1haW4oKSB7XG5cblx0XHRcdFx0Z2xfRnJhZ0NvbG9yID0gdGV4dHVyZUN1YmUoIGVudk1hcCwgdmVjMyggZmxpcEVudk1hcCAqIHZPdXRwdXREaXJlY3Rpb24ueCwgdk91dHB1dERpcmVjdGlvbi55eiApICk7XG5cblx0XHRcdH1cblx0XHRgLFxuXHRcdGJsZW5kaW5nOiBOb0JsZW5kaW5nLFxuXHRcdGRlcHRoVGVzdDogZmFsc2UsXG5cdFx0ZGVwdGhXcml0ZTogZmFsc2Vcblx0fSk7XG59XG5mdW5jdGlvbiBfZ2V0Q29tbW9uVmVydGV4U2hhZGVyKCkge1xuXHRyZXR1cm4gKC8qIGdsc2wgKi9gXG5cblx0XHRwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcblx0XHRwcmVjaXNpb24gbWVkaXVtcCBpbnQ7XG5cblx0XHRhdHRyaWJ1dGUgZmxvYXQgZmFjZUluZGV4O1xuXG5cdFx0dmFyeWluZyB2ZWMzIHZPdXRwdXREaXJlY3Rpb247XG5cblx0XHQvLyBSSCBjb29yZGluYXRlIHN5c3RlbTsgUE1SRU0gZmFjZS1pbmRleGluZyBjb252ZW50aW9uXG5cdFx0dmVjMyBnZXREaXJlY3Rpb24oIHZlYzIgdXYsIGZsb2F0IGZhY2UgKSB7XG5cblx0XHRcdHV2ID0gMi4wICogdXYgLSAxLjA7XG5cblx0XHRcdHZlYzMgZGlyZWN0aW9uID0gdmVjMyggdXYsIDEuMCApO1xuXG5cdFx0XHRpZiAoIGZhY2UgPT0gMC4wICkge1xuXG5cdFx0XHRcdGRpcmVjdGlvbiA9IGRpcmVjdGlvbi56eXg7IC8vICggMSwgdiwgdSApIHBvcyB4XG5cblx0XHRcdH0gZWxzZSBpZiAoIGZhY2UgPT0gMS4wICkge1xuXG5cdFx0XHRcdGRpcmVjdGlvbiA9IGRpcmVjdGlvbi54enk7XG5cdFx0XHRcdGRpcmVjdGlvbi54eiAqPSAtMS4wOyAvLyAoIC11LCAxLCAtdiApIHBvcyB5XG5cblx0XHRcdH0gZWxzZSBpZiAoIGZhY2UgPT0gMi4wICkge1xuXG5cdFx0XHRcdGRpcmVjdGlvbi54ICo9IC0xLjA7IC8vICggLXUsIHYsIDEgKSBwb3MgelxuXG5cdFx0XHR9IGVsc2UgaWYgKCBmYWNlID09IDMuMCApIHtcblxuXHRcdFx0XHRkaXJlY3Rpb24gPSBkaXJlY3Rpb24uenl4O1xuXHRcdFx0XHRkaXJlY3Rpb24ueHogKj0gLTEuMDsgLy8gKCAtMSwgdiwgLXUgKSBuZWcgeFxuXG5cdFx0XHR9IGVsc2UgaWYgKCBmYWNlID09IDQuMCApIHtcblxuXHRcdFx0XHRkaXJlY3Rpb24gPSBkaXJlY3Rpb24ueHp5O1xuXHRcdFx0XHRkaXJlY3Rpb24ueHkgKj0gLTEuMDsgLy8gKCAtdSwgLTEsIHYgKSBuZWcgeVxuXG5cdFx0XHR9IGVsc2UgaWYgKCBmYWNlID09IDUuMCApIHtcblxuXHRcdFx0XHRkaXJlY3Rpb24ueiAqPSAtMS4wOyAvLyAoIHUsIHYsIC0xICkgbmVnIHpcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGlyZWN0aW9uO1xuXG5cdFx0fVxuXG5cdFx0dm9pZCBtYWluKCkge1xuXG5cdFx0XHR2T3V0cHV0RGlyZWN0aW9uID0gZ2V0RGlyZWN0aW9uKCB1diwgZmFjZUluZGV4ICk7XG5cdFx0XHRnbF9Qb3NpdGlvbiA9IHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcblxuXHRcdH1cblx0YFxuXHQpO1xufVxuXG5mdW5jdGlvbiBXZWJHTEN1YmVVVk1hcHMocmVuZGVyZXIpIHtcblx0bGV0IGN1YmVVVm1hcHMgPSBuZXcgV2Vha01hcCgpO1xuXHRsZXQgcG1yZW1HZW5lcmF0b3IgPSBudWxsO1xuXHRmdW5jdGlvbiBnZXQodGV4dHVyZSkge1xuXHRcdGlmICh0ZXh0dXJlICYmIHRleHR1cmUuaXNUZXh0dXJlKSB7XG5cdFx0XHRjb25zdCBtYXBwaW5nID0gdGV4dHVyZS5tYXBwaW5nO1xuXHRcdFx0Y29uc3QgaXNFcXVpcmVjdE1hcCA9IG1hcHBpbmcgPT09IEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nIHx8IG1hcHBpbmcgPT09IEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nO1xuXHRcdFx0Y29uc3QgaXNDdWJlTWFwID0gbWFwcGluZyA9PT0gQ3ViZVJlZmxlY3Rpb25NYXBwaW5nIHx8IG1hcHBpbmcgPT09IEN1YmVSZWZyYWN0aW9uTWFwcGluZztcblxuXHRcdFx0Ly8gZXF1aXJlY3QvY3ViZSBtYXAgdG8gY3ViZVVWIGNvbnZlcnNpb25cblxuXHRcdFx0aWYgKGlzRXF1aXJlY3RNYXAgfHwgaXNDdWJlTWFwKSB7XG5cdFx0XHRcdGlmICh0ZXh0dXJlLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSAmJiB0ZXh0dXJlLm5lZWRzUE1SRU1VcGRhdGUgPT09IHRydWUpIHtcblx0XHRcdFx0XHR0ZXh0dXJlLm5lZWRzUE1SRU1VcGRhdGUgPSBmYWxzZTtcblx0XHRcdFx0XHRsZXQgcmVuZGVyVGFyZ2V0ID0gY3ViZVVWbWFwcy5nZXQodGV4dHVyZSk7XG5cdFx0XHRcdFx0aWYgKHBtcmVtR2VuZXJhdG9yID09PSBudWxsKSBwbXJlbUdlbmVyYXRvciA9IG5ldyBQTVJFTUdlbmVyYXRvcihyZW5kZXJlcik7XG5cdFx0XHRcdFx0cmVuZGVyVGFyZ2V0ID0gaXNFcXVpcmVjdE1hcCA/IHBtcmVtR2VuZXJhdG9yLmZyb21FcXVpcmVjdGFuZ3VsYXIodGV4dHVyZSwgcmVuZGVyVGFyZ2V0KSA6IHBtcmVtR2VuZXJhdG9yLmZyb21DdWJlbWFwKHRleHR1cmUsIHJlbmRlclRhcmdldCk7XG5cdFx0XHRcdFx0Y3ViZVVWbWFwcy5zZXQodGV4dHVyZSwgcmVuZGVyVGFyZ2V0KTtcblx0XHRcdFx0XHRyZXR1cm4gcmVuZGVyVGFyZ2V0LnRleHR1cmU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKGN1YmVVVm1hcHMuaGFzKHRleHR1cmUpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gY3ViZVVWbWFwcy5nZXQodGV4dHVyZSkudGV4dHVyZTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29uc3QgaW1hZ2UgPSB0ZXh0dXJlLmltYWdlO1xuXHRcdFx0XHRcdFx0aWYgKGlzRXF1aXJlY3RNYXAgJiYgaW1hZ2UgJiYgaW1hZ2UuaGVpZ2h0ID4gMCB8fCBpc0N1YmVNYXAgJiYgaW1hZ2UgJiYgaXNDdWJlVGV4dHVyZUNvbXBsZXRlKGltYWdlKSkge1xuXHRcdFx0XHRcdFx0XHRpZiAocG1yZW1HZW5lcmF0b3IgPT09IG51bGwpIHBtcmVtR2VuZXJhdG9yID0gbmV3IFBNUkVNR2VuZXJhdG9yKHJlbmRlcmVyKTtcblx0XHRcdFx0XHRcdFx0Y29uc3QgcmVuZGVyVGFyZ2V0ID0gaXNFcXVpcmVjdE1hcCA/IHBtcmVtR2VuZXJhdG9yLmZyb21FcXVpcmVjdGFuZ3VsYXIodGV4dHVyZSkgOiBwbXJlbUdlbmVyYXRvci5mcm9tQ3ViZW1hcCh0ZXh0dXJlKTtcblx0XHRcdFx0XHRcdFx0Y3ViZVVWbWFwcy5zZXQodGV4dHVyZSwgcmVuZGVyVGFyZ2V0KTtcblx0XHRcdFx0XHRcdFx0dGV4dHVyZS5hZGRFdmVudExpc3RlbmVyKCdkaXNwb3NlJywgb25UZXh0dXJlRGlzcG9zZSk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZW5kZXJUYXJnZXQudGV4dHVyZTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIGltYWdlIG5vdCB5ZXQgcmVhZHkuIHRyeSB0aGUgY29udmVyc2lvbiBuZXh0IGZyYW1lXG5cblx0XHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0ZXh0dXJlO1xuXHR9XG5cdGZ1bmN0aW9uIGlzQ3ViZVRleHR1cmVDb21wbGV0ZShpbWFnZSkge1xuXHRcdGxldCBjb3VudCA9IDA7XG5cdFx0Y29uc3QgbGVuZ3RoID0gNjtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoaW1hZ2VbaV0gIT09IHVuZGVmaW5lZCkgY291bnQrKztcblx0XHR9XG5cdFx0cmV0dXJuIGNvdW50ID09PSBsZW5ndGg7XG5cdH1cblx0ZnVuY3Rpb24gb25UZXh0dXJlRGlzcG9zZShldmVudCkge1xuXHRcdGNvbnN0IHRleHR1cmUgPSBldmVudC50YXJnZXQ7XG5cdFx0dGV4dHVyZS5yZW1vdmVFdmVudExpc3RlbmVyKCdkaXNwb3NlJywgb25UZXh0dXJlRGlzcG9zZSk7XG5cdFx0Y29uc3QgY3ViZW1hcFVWID0gY3ViZVVWbWFwcy5nZXQodGV4dHVyZSk7XG5cdFx0aWYgKGN1YmVtYXBVViAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjdWJlVVZtYXBzLmRlbGV0ZSh0ZXh0dXJlKTtcblx0XHRcdGN1YmVtYXBVVi5kaXNwb3NlKCk7XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG5cdFx0Y3ViZVVWbWFwcyA9IG5ldyBXZWFrTWFwKCk7XG5cdFx0aWYgKHBtcmVtR2VuZXJhdG9yICE9PSBudWxsKSB7XG5cdFx0XHRwbXJlbUdlbmVyYXRvci5kaXNwb3NlKCk7XG5cdFx0XHRwbXJlbUdlbmVyYXRvciA9IG51bGw7XG5cdFx0fVxuXHR9XG5cdHJldHVybiB7XG5cdFx0Z2V0OiBnZXQsXG5cdFx0ZGlzcG9zZTogZGlzcG9zZVxuXHR9O1xufVxuXG5mdW5jdGlvbiBXZWJHTEV4dGVuc2lvbnMoZ2wpIHtcblx0Y29uc3QgZXh0ZW5zaW9ucyA9IHt9O1xuXHRmdW5jdGlvbiBnZXRFeHRlbnNpb24obmFtZSkge1xuXHRcdGlmIChleHRlbnNpb25zW25hbWVdICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiBleHRlbnNpb25zW25hbWVdO1xuXHRcdH1cblx0XHRsZXQgZXh0ZW5zaW9uO1xuXHRcdHN3aXRjaCAobmFtZSkge1xuXHRcdFx0Y2FzZSAnV0VCR0xfZGVwdGhfdGV4dHVyZSc6XG5cdFx0XHRcdGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbignV0VCR0xfZGVwdGhfdGV4dHVyZScpIHx8IGdsLmdldEV4dGVuc2lvbignTU9aX1dFQkdMX2RlcHRoX3RleHR1cmUnKSB8fCBnbC5nZXRFeHRlbnNpb24oJ1dFQktJVF9XRUJHTF9kZXB0aF90ZXh0dXJlJyk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJzpcblx0XHRcdFx0ZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnKSB8fCBnbC5nZXRFeHRlbnNpb24oJ01PWl9FWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnKSB8fCBnbC5nZXRFeHRlbnNpb24oJ1dFQktJVF9FWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Yyc6XG5cdFx0XHRcdGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbignV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnKSB8fCBnbC5nZXRFeHRlbnNpb24oJ01PWl9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycpIHx8IGdsLmdldEV4dGVuc2lvbignV0VCS0lUX1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJzpcblx0XHRcdFx0ZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnKSB8fCBnbC5nZXRFeHRlbnNpb24oJ1dFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24obmFtZSk7XG5cdFx0fVxuXHRcdGV4dGVuc2lvbnNbbmFtZV0gPSBleHRlbnNpb247XG5cdFx0cmV0dXJuIGV4dGVuc2lvbjtcblx0fVxuXHRyZXR1cm4ge1xuXHRcdGhhczogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRcdHJldHVybiBnZXRFeHRlbnNpb24obmFtZSkgIT09IG51bGw7XG5cdFx0fSxcblx0XHRpbml0OiBmdW5jdGlvbiAoY2FwYWJpbGl0aWVzKSB7XG5cdFx0XHRpZiAoY2FwYWJpbGl0aWVzLmlzV2ViR0wyKSB7XG5cdFx0XHRcdGdldEV4dGVuc2lvbignRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdCcpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Z2V0RXh0ZW5zaW9uKCdXRUJHTF9kZXB0aF90ZXh0dXJlJyk7XG5cdFx0XHRcdGdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXQnKTtcblx0XHRcdFx0Z2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0Jyk7XG5cdFx0XHRcdGdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfaGFsZl9mbG9hdF9saW5lYXInKTtcblx0XHRcdFx0Z2V0RXh0ZW5zaW9uKCdPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMnKTtcblx0XHRcdFx0Z2V0RXh0ZW5zaW9uKCdPRVNfZWxlbWVudF9pbmRleF91aW50Jyk7XG5cdFx0XHRcdGdldEV4dGVuc2lvbignT0VTX3ZlcnRleF9hcnJheV9vYmplY3QnKTtcblx0XHRcdFx0Z2V0RXh0ZW5zaW9uKCdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyk7XG5cdFx0XHR9XG5cdFx0XHRnZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicpO1xuXHRcdFx0Z2V0RXh0ZW5zaW9uKCdFWFRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXQnKTtcblx0XHRcdGdldEV4dGVuc2lvbignV0VCR0xfbXVsdGlzYW1wbGVkX3JlbmRlcl90b190ZXh0dXJlJyk7XG5cdFx0fSxcblx0XHRnZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0XHRjb25zdCBleHRlbnNpb24gPSBnZXRFeHRlbnNpb24obmFtZSk7XG5cdFx0XHRpZiAoZXh0ZW5zaW9uID09PSBudWxsKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogJyArIG5hbWUgKyAnIGV4dGVuc2lvbiBub3Qgc3VwcG9ydGVkLicpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGV4dGVuc2lvbjtcblx0XHR9XG5cdH07XG59XG5cbmZ1bmN0aW9uIFdlYkdMR2VvbWV0cmllcyhnbCwgYXR0cmlidXRlcywgaW5mbywgYmluZGluZ1N0YXRlcykge1xuXHRjb25zdCBnZW9tZXRyaWVzID0ge307XG5cdGNvbnN0IHdpcmVmcmFtZUF0dHJpYnV0ZXMgPSBuZXcgV2Vha01hcCgpO1xuXHRmdW5jdGlvbiBvbkdlb21ldHJ5RGlzcG9zZShldmVudCkge1xuXHRcdGNvbnN0IGdlb21ldHJ5ID0gZXZlbnQudGFyZ2V0O1xuXHRcdGlmIChnZW9tZXRyeS5pbmRleCAhPT0gbnVsbCkge1xuXHRcdFx0YXR0cmlidXRlcy5yZW1vdmUoZ2VvbWV0cnkuaW5kZXgpO1xuXHRcdH1cblx0XHRmb3IgKGNvbnN0IG5hbWUgaW4gZ2VvbWV0cnkuYXR0cmlidXRlcykge1xuXHRcdFx0YXR0cmlidXRlcy5yZW1vdmUoZ2VvbWV0cnkuYXR0cmlidXRlc1tuYW1lXSk7XG5cdFx0fVxuXHRcdGdlb21ldHJ5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBvbkdlb21ldHJ5RGlzcG9zZSk7XG5cdFx0ZGVsZXRlIGdlb21ldHJpZXNbZ2VvbWV0cnkuaWRdO1xuXHRcdGNvbnN0IGF0dHJpYnV0ZSA9IHdpcmVmcmFtZUF0dHJpYnV0ZXMuZ2V0KGdlb21ldHJ5KTtcblx0XHRpZiAoYXR0cmlidXRlKSB7XG5cdFx0XHRhdHRyaWJ1dGVzLnJlbW92ZShhdHRyaWJ1dGUpO1xuXHRcdFx0d2lyZWZyYW1lQXR0cmlidXRlcy5kZWxldGUoZ2VvbWV0cnkpO1xuXHRcdH1cblx0XHRiaW5kaW5nU3RhdGVzLnJlbGVhc2VTdGF0ZXNPZkdlb21ldHJ5KGdlb21ldHJ5KTtcblx0XHRpZiAoZ2VvbWV0cnkuaXNJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSA9PT0gdHJ1ZSkge1xuXHRcdFx0ZGVsZXRlIGdlb21ldHJ5Ll9tYXhJbnN0YW5jZUNvdW50O1xuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRpbmZvLm1lbW9yeS5nZW9tZXRyaWVzLS07XG5cdH1cblx0ZnVuY3Rpb24gZ2V0KG9iamVjdCwgZ2VvbWV0cnkpIHtcblx0XHRpZiAoZ2VvbWV0cmllc1tnZW9tZXRyeS5pZF0gPT09IHRydWUpIHJldHVybiBnZW9tZXRyeTtcblx0XHRnZW9tZXRyeS5hZGRFdmVudExpc3RlbmVyKCdkaXNwb3NlJywgb25HZW9tZXRyeURpc3Bvc2UpO1xuXHRcdGdlb21ldHJpZXNbZ2VvbWV0cnkuaWRdID0gdHJ1ZTtcblx0XHRpbmZvLm1lbW9yeS5nZW9tZXRyaWVzKys7XG5cdFx0cmV0dXJuIGdlb21ldHJ5O1xuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZShnZW9tZXRyeSkge1xuXHRcdGNvbnN0IGdlb21ldHJ5QXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG5cblx0XHQvLyBVcGRhdGluZyBpbmRleCBidWZmZXIgaW4gVkFPIG5vdy4gU2VlIFdlYkdMQmluZGluZ1N0YXRlcy5cblxuXHRcdGZvciAoY29uc3QgbmFtZSBpbiBnZW9tZXRyeUF0dHJpYnV0ZXMpIHtcblx0XHRcdGF0dHJpYnV0ZXMudXBkYXRlKGdlb21ldHJ5QXR0cmlidXRlc1tuYW1lXSwgZ2wuQVJSQVlfQlVGRkVSKTtcblx0XHR9XG5cblx0XHQvLyBtb3JwaCB0YXJnZXRzXG5cblx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXM7XG5cdFx0Zm9yIChjb25zdCBuYW1lIGluIG1vcnBoQXR0cmlidXRlcykge1xuXHRcdFx0Y29uc3QgYXJyYXkgPSBtb3JwaEF0dHJpYnV0ZXNbbmFtZV07XG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRhdHRyaWJ1dGVzLnVwZGF0ZShhcnJheVtpXSwgZ2wuQVJSQVlfQlVGRkVSKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlV2lyZWZyYW1lQXR0cmlidXRlKGdlb21ldHJ5KSB7XG5cdFx0Y29uc3QgaW5kaWNlcyA9IFtdO1xuXHRcdGNvbnN0IGdlb21ldHJ5SW5kZXggPSBnZW9tZXRyeS5pbmRleDtcblx0XHRjb25zdCBnZW9tZXRyeVBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRsZXQgdmVyc2lvbiA9IDA7XG5cdFx0aWYgKGdlb21ldHJ5SW5kZXggIT09IG51bGwpIHtcblx0XHRcdGNvbnN0IGFycmF5ID0gZ2VvbWV0cnlJbmRleC5hcnJheTtcblx0XHRcdHZlcnNpb24gPSBnZW9tZXRyeUluZGV4LnZlcnNpb247XG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkgKz0gMykge1xuXHRcdFx0XHRjb25zdCBhID0gYXJyYXlbaSArIDBdO1xuXHRcdFx0XHRjb25zdCBiID0gYXJyYXlbaSArIDFdO1xuXHRcdFx0XHRjb25zdCBjID0gYXJyYXlbaSArIDJdO1xuXHRcdFx0XHRpbmRpY2VzLnB1c2goYSwgYiwgYiwgYywgYywgYSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnN0IGFycmF5ID0gZ2VvbWV0cnlQb3NpdGlvbi5hcnJheTtcblx0XHRcdHZlcnNpb24gPSBnZW9tZXRyeVBvc2l0aW9uLnZlcnNpb247XG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aCAvIDMgLSAxOyBpIDwgbDsgaSArPSAzKSB7XG5cdFx0XHRcdGNvbnN0IGEgPSBpICsgMDtcblx0XHRcdFx0Y29uc3QgYiA9IGkgKyAxO1xuXHRcdFx0XHRjb25zdCBjID0gaSArIDI7XG5cdFx0XHRcdGluZGljZXMucHVzaChhLCBiLCBiLCBjLCBjLCBhKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Y29uc3QgYXR0cmlidXRlID0gbmV3IChhcnJheU5lZWRzVWludDMyKGluZGljZXMpID8gVWludDMyQnVmZmVyQXR0cmlidXRlIDogVWludDE2QnVmZmVyQXR0cmlidXRlKShpbmRpY2VzLCAxKTtcblx0XHRhdHRyaWJ1dGUudmVyc2lvbiA9IHZlcnNpb247XG5cblx0XHQvLyBVcGRhdGluZyBpbmRleCBidWZmZXIgaW4gVkFPIG5vdy4gU2VlIFdlYkdMQmluZGluZ1N0YXRlc1xuXG5cdFx0Ly9cblxuXHRcdGNvbnN0IHByZXZpb3VzQXR0cmlidXRlID0gd2lyZWZyYW1lQXR0cmlidXRlcy5nZXQoZ2VvbWV0cnkpO1xuXHRcdGlmIChwcmV2aW91c0F0dHJpYnV0ZSkgYXR0cmlidXRlcy5yZW1vdmUocHJldmlvdXNBdHRyaWJ1dGUpO1xuXG5cdFx0Ly9cblxuXHRcdHdpcmVmcmFtZUF0dHJpYnV0ZXMuc2V0KGdlb21ldHJ5LCBhdHRyaWJ1dGUpO1xuXHR9XG5cdGZ1bmN0aW9uIGdldFdpcmVmcmFtZUF0dHJpYnV0ZShnZW9tZXRyeSkge1xuXHRcdGNvbnN0IGN1cnJlbnRBdHRyaWJ1dGUgPSB3aXJlZnJhbWVBdHRyaWJ1dGVzLmdldChnZW9tZXRyeSk7XG5cdFx0aWYgKGN1cnJlbnRBdHRyaWJ1dGUpIHtcblx0XHRcdGNvbnN0IGdlb21ldHJ5SW5kZXggPSBnZW9tZXRyeS5pbmRleDtcblx0XHRcdGlmIChnZW9tZXRyeUluZGV4ICE9PSBudWxsKSB7XG5cdFx0XHRcdC8vIGlmIHRoZSBhdHRyaWJ1dGUgaXMgb2Jzb2xldGUsIGNyZWF0ZSBhIG5ldyBvbmVcblxuXHRcdFx0XHRpZiAoY3VycmVudEF0dHJpYnV0ZS52ZXJzaW9uIDwgZ2VvbWV0cnlJbmRleC52ZXJzaW9uKSB7XG5cdFx0XHRcdFx0dXBkYXRlV2lyZWZyYW1lQXR0cmlidXRlKGdlb21ldHJ5KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR1cGRhdGVXaXJlZnJhbWVBdHRyaWJ1dGUoZ2VvbWV0cnkpO1xuXHRcdH1cblx0XHRyZXR1cm4gd2lyZWZyYW1lQXR0cmlidXRlcy5nZXQoZ2VvbWV0cnkpO1xuXHR9XG5cdHJldHVybiB7XG5cdFx0Z2V0OiBnZXQsXG5cdFx0dXBkYXRlOiB1cGRhdGUsXG5cdFx0Z2V0V2lyZWZyYW1lQXR0cmlidXRlOiBnZXRXaXJlZnJhbWVBdHRyaWJ1dGVcblx0fTtcbn1cblxuZnVuY3Rpb24gV2ViR0xJbmRleGVkQnVmZmVyUmVuZGVyZXIoZ2wsIGV4dGVuc2lvbnMsIGluZm8sIGNhcGFiaWxpdGllcykge1xuXHRjb25zdCBpc1dlYkdMMiA9IGNhcGFiaWxpdGllcy5pc1dlYkdMMjtcblx0bGV0IG1vZGU7XG5cdGZ1bmN0aW9uIHNldE1vZGUodmFsdWUpIHtcblx0XHRtb2RlID0gdmFsdWU7XG5cdH1cblx0bGV0IHR5cGUsIGJ5dGVzUGVyRWxlbWVudDtcblx0ZnVuY3Rpb24gc2V0SW5kZXgodmFsdWUpIHtcblx0XHR0eXBlID0gdmFsdWUudHlwZTtcblx0XHRieXRlc1BlckVsZW1lbnQgPSB2YWx1ZS5ieXRlc1BlckVsZW1lbnQ7XG5cdH1cblx0ZnVuY3Rpb24gcmVuZGVyKHN0YXJ0LCBjb3VudCkge1xuXHRcdGdsLmRyYXdFbGVtZW50cyhtb2RlLCBjb3VudCwgdHlwZSwgc3RhcnQgKiBieXRlc1BlckVsZW1lbnQpO1xuXHRcdGluZm8udXBkYXRlKGNvdW50LCBtb2RlLCAxKTtcblx0fVxuXHRmdW5jdGlvbiByZW5kZXJJbnN0YW5jZXMoc3RhcnQsIGNvdW50LCBwcmltY291bnQpIHtcblx0XHRpZiAocHJpbWNvdW50ID09PSAwKSByZXR1cm47XG5cdFx0bGV0IGV4dGVuc2lvbiwgbWV0aG9kTmFtZTtcblx0XHRpZiAoaXNXZWJHTDIpIHtcblx0XHRcdGV4dGVuc2lvbiA9IGdsO1xuXHRcdFx0bWV0aG9kTmFtZSA9ICdkcmF3RWxlbWVudHNJbnN0YW5jZWQnO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCgnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycpO1xuXHRcdFx0bWV0aG9kTmFtZSA9ICdkcmF3RWxlbWVudHNJbnN0YW5jZWRBTkdMRSc7XG5cdFx0XHRpZiAoZXh0ZW5zaW9uID09PSBudWxsKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLldlYkdMSW5kZXhlZEJ1ZmZlclJlbmRlcmVyOiB1c2luZyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSBidXQgaGFyZHdhcmUgZG9lcyBub3Qgc3VwcG9ydCBleHRlbnNpb24gQU5HTEVfaW5zdGFuY2VkX2FycmF5cy4nKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRleHRlbnNpb25bbWV0aG9kTmFtZV0obW9kZSwgY291bnQsIHR5cGUsIHN0YXJ0ICogYnl0ZXNQZXJFbGVtZW50LCBwcmltY291bnQpO1xuXHRcdGluZm8udXBkYXRlKGNvdW50LCBtb2RlLCBwcmltY291bnQpO1xuXHR9XG5cblx0Ly9cblxuXHR0aGlzLnNldE1vZGUgPSBzZXRNb2RlO1xuXHR0aGlzLnNldEluZGV4ID0gc2V0SW5kZXg7XG5cdHRoaXMucmVuZGVyID0gcmVuZGVyO1xuXHR0aGlzLnJlbmRlckluc3RhbmNlcyA9IHJlbmRlckluc3RhbmNlcztcbn1cblxuZnVuY3Rpb24gV2ViR0xJbmZvKGdsKSB7XG5cdGNvbnN0IG1lbW9yeSA9IHtcblx0XHRnZW9tZXRyaWVzOiAwLFxuXHRcdHRleHR1cmVzOiAwXG5cdH07XG5cdGNvbnN0IHJlbmRlciA9IHtcblx0XHRmcmFtZTogMCxcblx0XHRjYWxsczogMCxcblx0XHR0cmlhbmdsZXM6IDAsXG5cdFx0cG9pbnRzOiAwLFxuXHRcdGxpbmVzOiAwXG5cdH07XG5cdGZ1bmN0aW9uIHVwZGF0ZShjb3VudCwgbW9kZSwgaW5zdGFuY2VDb3VudCkge1xuXHRcdHJlbmRlci5jYWxscysrO1xuXHRcdHN3aXRjaCAobW9kZSkge1xuXHRcdFx0Y2FzZSBnbC5UUklBTkdMRVM6XG5cdFx0XHRcdHJlbmRlci50cmlhbmdsZXMgKz0gaW5zdGFuY2VDb3VudCAqIChjb3VudCAvIDMpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgZ2wuTElORVM6XG5cdFx0XHRcdHJlbmRlci5saW5lcyArPSBpbnN0YW5jZUNvdW50ICogKGNvdW50IC8gMik7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBnbC5MSU5FX1NUUklQOlxuXHRcdFx0XHRyZW5kZXIubGluZXMgKz0gaW5zdGFuY2VDb3VudCAqIChjb3VudCAtIDEpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgZ2wuTElORV9MT09QOlxuXHRcdFx0XHRyZW5kZXIubGluZXMgKz0gaW5zdGFuY2VDb3VudCAqIGNvdW50O1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgZ2wuUE9JTlRTOlxuXHRcdFx0XHRyZW5kZXIucG9pbnRzICs9IGluc3RhbmNlQ291bnQgKiBjb3VudDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5XZWJHTEluZm86IFVua25vd24gZHJhdyBtb2RlOicsIG1vZGUpO1xuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gcmVzZXQoKSB7XG5cdFx0cmVuZGVyLmZyYW1lKys7XG5cdFx0cmVuZGVyLmNhbGxzID0gMDtcblx0XHRyZW5kZXIudHJpYW5nbGVzID0gMDtcblx0XHRyZW5kZXIucG9pbnRzID0gMDtcblx0XHRyZW5kZXIubGluZXMgPSAwO1xuXHR9XG5cdHJldHVybiB7XG5cdFx0bWVtb3J5OiBtZW1vcnksXG5cdFx0cmVuZGVyOiByZW5kZXIsXG5cdFx0cHJvZ3JhbXM6IG51bGwsXG5cdFx0YXV0b1Jlc2V0OiB0cnVlLFxuXHRcdHJlc2V0OiByZXNldCxcblx0XHR1cGRhdGU6IHVwZGF0ZVxuXHR9O1xufVxuXG5mdW5jdGlvbiBudW1lcmljYWxTb3J0KGEsIGIpIHtcblx0cmV0dXJuIGFbMF0gLSBiWzBdO1xufVxuZnVuY3Rpb24gYWJzTnVtZXJpY2FsU29ydChhLCBiKSB7XG5cdHJldHVybiBNYXRoLmFicyhiWzFdKSAtIE1hdGguYWJzKGFbMV0pO1xufVxuZnVuY3Rpb24gV2ViR0xNb3JwaHRhcmdldHMoZ2wsIGNhcGFiaWxpdGllcywgdGV4dHVyZXMpIHtcblx0Y29uc3QgaW5mbHVlbmNlc0xpc3QgPSB7fTtcblx0Y29uc3QgbW9ycGhJbmZsdWVuY2VzID0gbmV3IEZsb2F0MzJBcnJheSg4KTtcblx0Y29uc3QgbW9ycGhUZXh0dXJlcyA9IG5ldyBXZWFrTWFwKCk7XG5cdGNvbnN0IG1vcnBoID0gbmV3IFZlY3RvcjQoKTtcblx0Y29uc3Qgd29ya0luZmx1ZW5jZXMgPSBbXTtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpKyspIHtcblx0XHR3b3JrSW5mbHVlbmNlc1tpXSA9IFtpLCAwXTtcblx0fVxuXHRmdW5jdGlvbiB1cGRhdGUob2JqZWN0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHByb2dyYW0pIHtcblx0XHRjb25zdCBvYmplY3RJbmZsdWVuY2VzID0gb2JqZWN0Lm1vcnBoVGFyZ2V0SW5mbHVlbmNlcztcblx0XHRpZiAoY2FwYWJpbGl0aWVzLmlzV2ViR0wyID09PSB0cnVlKSB7XG5cdFx0XHQvLyBpbnN0ZWFkIG9mIHVzaW5nIGF0dHJpYnV0ZXMsIHRoZSBXZWJHTCAyIGNvZGUgcGF0aCBlbmNvZGVzIG1vcnBoIHRhcmdldHNcblx0XHRcdC8vIGludG8gYW4gYXJyYXkgb2YgZGF0YSB0ZXh0dXJlcy4gRWFjaCBsYXllciByZXByZXNlbnRzIGEgc2luZ2xlIG1vcnBoIHRhcmdldC5cblxuXHRcdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGUgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24gfHwgZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbCB8fCBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMuY29sb3I7XG5cdFx0XHRjb25zdCBtb3JwaFRhcmdldHNDb3VudCA9IG1vcnBoQXR0cmlidXRlICE9PSB1bmRlZmluZWQgPyBtb3JwaEF0dHJpYnV0ZS5sZW5ndGggOiAwO1xuXHRcdFx0bGV0IGVudHJ5ID0gbW9ycGhUZXh0dXJlcy5nZXQoZ2VvbWV0cnkpO1xuXHRcdFx0aWYgKGVudHJ5ID09PSB1bmRlZmluZWQgfHwgZW50cnkuY291bnQgIT09IG1vcnBoVGFyZ2V0c0NvdW50KSB7XG5cdFx0XHRcdGlmIChlbnRyeSAhPT0gdW5kZWZpbmVkKSBlbnRyeS50ZXh0dXJlLmRpc3Bvc2UoKTtcblx0XHRcdFx0Y29uc3QgaGFzTW9ycGhQb3NpdGlvbiA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbiAhPT0gdW5kZWZpbmVkO1xuXHRcdFx0XHRjb25zdCBoYXNNb3JwaE5vcm1hbHMgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsICE9PSB1bmRlZmluZWQ7XG5cdFx0XHRcdGNvbnN0IGhhc01vcnBoQ29sb3JzID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLmNvbG9yICE9PSB1bmRlZmluZWQ7XG5cdFx0XHRcdGNvbnN0IG1vcnBoVGFyZ2V0cyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbiB8fCBbXTtcblx0XHRcdFx0Y29uc3QgbW9ycGhOb3JtYWxzID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbCB8fCBbXTtcblx0XHRcdFx0Y29uc3QgbW9ycGhDb2xvcnMgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMuY29sb3IgfHwgW107XG5cdFx0XHRcdGxldCB2ZXJ0ZXhEYXRhQ291bnQgPSAwO1xuXHRcdFx0XHRpZiAoaGFzTW9ycGhQb3NpdGlvbiA9PT0gdHJ1ZSkgdmVydGV4RGF0YUNvdW50ID0gMTtcblx0XHRcdFx0aWYgKGhhc01vcnBoTm9ybWFscyA9PT0gdHJ1ZSkgdmVydGV4RGF0YUNvdW50ID0gMjtcblx0XHRcdFx0aWYgKGhhc01vcnBoQ29sb3JzID09PSB0cnVlKSB2ZXJ0ZXhEYXRhQ291bnQgPSAzO1xuXHRcdFx0XHRsZXQgd2lkdGggPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmNvdW50ICogdmVydGV4RGF0YUNvdW50O1xuXHRcdFx0XHRsZXQgaGVpZ2h0ID0gMTtcblx0XHRcdFx0aWYgKHdpZHRoID4gY2FwYWJpbGl0aWVzLm1heFRleHR1cmVTaXplKSB7XG5cdFx0XHRcdFx0aGVpZ2h0ID0gTWF0aC5jZWlsKHdpZHRoIC8gY2FwYWJpbGl0aWVzLm1heFRleHR1cmVTaXplKTtcblx0XHRcdFx0XHR3aWR0aCA9IGNhcGFiaWxpdGllcy5tYXhUZXh0dXJlU2l6ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb25zdCBidWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KHdpZHRoICogaGVpZ2h0ICogNCAqIG1vcnBoVGFyZ2V0c0NvdW50KTtcblx0XHRcdFx0Y29uc3QgdGV4dHVyZSA9IG5ldyBEYXRhQXJyYXlUZXh0dXJlKGJ1ZmZlciwgd2lkdGgsIGhlaWdodCwgbW9ycGhUYXJnZXRzQ291bnQpO1xuXHRcdFx0XHR0ZXh0dXJlLnR5cGUgPSBGbG9hdFR5cGU7XG5cdFx0XHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdC8vIGZpbGwgYnVmZmVyXG5cblx0XHRcdFx0Y29uc3QgdmVydGV4RGF0YVN0cmlkZSA9IHZlcnRleERhdGFDb3VudCAqIDQ7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbW9ycGhUYXJnZXRzQ291bnQ7IGkrKykge1xuXHRcdFx0XHRcdGNvbnN0IG1vcnBoVGFyZ2V0ID0gbW9ycGhUYXJnZXRzW2ldO1xuXHRcdFx0XHRcdGNvbnN0IG1vcnBoTm9ybWFsID0gbW9ycGhOb3JtYWxzW2ldO1xuXHRcdFx0XHRcdGNvbnN0IG1vcnBoQ29sb3IgPSBtb3JwaENvbG9yc1tpXTtcblx0XHRcdFx0XHRjb25zdCBvZmZzZXQgPSB3aWR0aCAqIGhlaWdodCAqIDQgKiBpO1xuXHRcdFx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgbW9ycGhUYXJnZXQuY291bnQ7IGorKykge1xuXHRcdFx0XHRcdFx0Y29uc3Qgc3RyaWRlID0gaiAqIHZlcnRleERhdGFTdHJpZGU7XG5cdFx0XHRcdFx0XHRpZiAoaGFzTW9ycGhQb3NpdGlvbiA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0XHRtb3JwaC5mcm9tQnVmZmVyQXR0cmlidXRlKG1vcnBoVGFyZ2V0LCBqKTtcblx0XHRcdFx0XHRcdFx0YnVmZmVyW29mZnNldCArIHN0cmlkZSArIDBdID0gbW9ycGgueDtcblx0XHRcdFx0XHRcdFx0YnVmZmVyW29mZnNldCArIHN0cmlkZSArIDFdID0gbW9ycGgueTtcblx0XHRcdFx0XHRcdFx0YnVmZmVyW29mZnNldCArIHN0cmlkZSArIDJdID0gbW9ycGguejtcblx0XHRcdFx0XHRcdFx0YnVmZmVyW29mZnNldCArIHN0cmlkZSArIDNdID0gMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChoYXNNb3JwaE5vcm1hbHMgPT09IHRydWUpIHtcblx0XHRcdFx0XHRcdFx0bW9ycGguZnJvbUJ1ZmZlckF0dHJpYnV0ZShtb3JwaE5vcm1hbCwgaik7XG5cdFx0XHRcdFx0XHRcdGJ1ZmZlcltvZmZzZXQgKyBzdHJpZGUgKyA0XSA9IG1vcnBoLng7XG5cdFx0XHRcdFx0XHRcdGJ1ZmZlcltvZmZzZXQgKyBzdHJpZGUgKyA1XSA9IG1vcnBoLnk7XG5cdFx0XHRcdFx0XHRcdGJ1ZmZlcltvZmZzZXQgKyBzdHJpZGUgKyA2XSA9IG1vcnBoLno7XG5cdFx0XHRcdFx0XHRcdGJ1ZmZlcltvZmZzZXQgKyBzdHJpZGUgKyA3XSA9IDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoaGFzTW9ycGhDb2xvcnMgPT09IHRydWUpIHtcblx0XHRcdFx0XHRcdFx0bW9ycGguZnJvbUJ1ZmZlckF0dHJpYnV0ZShtb3JwaENvbG9yLCBqKTtcblx0XHRcdFx0XHRcdFx0YnVmZmVyW29mZnNldCArIHN0cmlkZSArIDhdID0gbW9ycGgueDtcblx0XHRcdFx0XHRcdFx0YnVmZmVyW29mZnNldCArIHN0cmlkZSArIDldID0gbW9ycGgueTtcblx0XHRcdFx0XHRcdFx0YnVmZmVyW29mZnNldCArIHN0cmlkZSArIDEwXSA9IG1vcnBoLno7XG5cdFx0XHRcdFx0XHRcdGJ1ZmZlcltvZmZzZXQgKyBzdHJpZGUgKyAxMV0gPSBtb3JwaENvbG9yLml0ZW1TaXplID09PSA0ID8gbW9ycGgudyA6IDE7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVudHJ5ID0ge1xuXHRcdFx0XHRcdGNvdW50OiBtb3JwaFRhcmdldHNDb3VudCxcblx0XHRcdFx0XHR0ZXh0dXJlOiB0ZXh0dXJlLFxuXHRcdFx0XHRcdHNpemU6IG5ldyBWZWN0b3IyKHdpZHRoLCBoZWlnaHQpXG5cdFx0XHRcdH07XG5cdFx0XHRcdG1vcnBoVGV4dHVyZXMuc2V0KGdlb21ldHJ5LCBlbnRyeSk7XG5cdFx0XHRcdGZ1bmN0aW9uIGRpc3Bvc2VUZXh0dXJlKCkge1xuXHRcdFx0XHRcdHRleHR1cmUuZGlzcG9zZSgpO1xuXHRcdFx0XHRcdG1vcnBoVGV4dHVyZXMuZGVsZXRlKGdlb21ldHJ5KTtcblx0XHRcdFx0XHRnZW9tZXRyeS5yZW1vdmVFdmVudExpc3RlbmVyKCdkaXNwb3NlJywgZGlzcG9zZVRleHR1cmUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGdlb21ldHJ5LmFkZEV2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBkaXNwb3NlVGV4dHVyZSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vXG5cblx0XHRcdGxldCBtb3JwaEluZmx1ZW5jZXNTdW0gPSAwO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBvYmplY3RJbmZsdWVuY2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdG1vcnBoSW5mbHVlbmNlc1N1bSArPSBvYmplY3RJbmZsdWVuY2VzW2ldO1xuXHRcdFx0fVxuXHRcdFx0Y29uc3QgbW9ycGhCYXNlSW5mbHVlbmNlID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzUmVsYXRpdmUgPyAxIDogMSAtIG1vcnBoSW5mbHVlbmNlc1N1bTtcblx0XHRcdHByb2dyYW0uZ2V0VW5pZm9ybXMoKS5zZXRWYWx1ZShnbCwgJ21vcnBoVGFyZ2V0QmFzZUluZmx1ZW5jZScsIG1vcnBoQmFzZUluZmx1ZW5jZSk7XG5cdFx0XHRwcm9ncmFtLmdldFVuaWZvcm1zKCkuc2V0VmFsdWUoZ2wsICdtb3JwaFRhcmdldEluZmx1ZW5jZXMnLCBvYmplY3RJbmZsdWVuY2VzKTtcblx0XHRcdHByb2dyYW0uZ2V0VW5pZm9ybXMoKS5zZXRWYWx1ZShnbCwgJ21vcnBoVGFyZ2V0c1RleHR1cmUnLCBlbnRyeS50ZXh0dXJlLCB0ZXh0dXJlcyk7XG5cdFx0XHRwcm9ncmFtLmdldFVuaWZvcm1zKCkuc2V0VmFsdWUoZ2wsICdtb3JwaFRhcmdldHNUZXh0dXJlU2l6ZScsIGVudHJ5LnNpemUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBXaGVuIG9iamVjdCBkb2Vzbid0IGhhdmUgbW9ycGggdGFyZ2V0IGluZmx1ZW5jZXMgZGVmaW5lZCwgd2UgdHJlYXQgaXQgYXMgYSAwLWxlbmd0aCBhcnJheVxuXHRcdFx0Ly8gVGhpcyBpcyBpbXBvcnRhbnQgdG8gbWFrZSBzdXJlIHdlIHNldCB1cCBtb3JwaFRhcmdldEJhc2VJbmZsdWVuY2UgLyBtb3JwaFRhcmdldEluZmx1ZW5jZXNcblxuXHRcdFx0Y29uc3QgbGVuZ3RoID0gb2JqZWN0SW5mbHVlbmNlcyA9PT0gdW5kZWZpbmVkID8gMCA6IG9iamVjdEluZmx1ZW5jZXMubGVuZ3RoO1xuXHRcdFx0bGV0IGluZmx1ZW5jZXMgPSBpbmZsdWVuY2VzTGlzdFtnZW9tZXRyeS5pZF07XG5cdFx0XHRpZiAoaW5mbHVlbmNlcyA9PT0gdW5kZWZpbmVkIHx8IGluZmx1ZW5jZXMubGVuZ3RoICE9PSBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaW5pdGlhbGlzZSBsaXN0XG5cblx0XHRcdFx0aW5mbHVlbmNlcyA9IFtdO1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0aW5mbHVlbmNlc1tpXSA9IFtpLCAwXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpbmZsdWVuY2VzTGlzdFtnZW9tZXRyeS5pZF0gPSBpbmZsdWVuY2VzO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb2xsZWN0IGluZmx1ZW5jZXNcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0XHRjb25zdCBpbmZsdWVuY2UgPSBpbmZsdWVuY2VzW2ldO1xuXHRcdFx0XHRpbmZsdWVuY2VbMF0gPSBpO1xuXHRcdFx0XHRpbmZsdWVuY2VbMV0gPSBvYmplY3RJbmZsdWVuY2VzW2ldO1xuXHRcdFx0fVxuXHRcdFx0aW5mbHVlbmNlcy5zb3J0KGFic051bWVyaWNhbFNvcnQpO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpKyspIHtcblx0XHRcdFx0aWYgKGkgPCBsZW5ndGggJiYgaW5mbHVlbmNlc1tpXVsxXSkge1xuXHRcdFx0XHRcdHdvcmtJbmZsdWVuY2VzW2ldWzBdID0gaW5mbHVlbmNlc1tpXVswXTtcblx0XHRcdFx0XHR3b3JrSW5mbHVlbmNlc1tpXVsxXSA9IGluZmx1ZW5jZXNbaV1bMV07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0d29ya0luZmx1ZW5jZXNbaV1bMF0gPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcblx0XHRcdFx0XHR3b3JrSW5mbHVlbmNlc1tpXVsxXSA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHdvcmtJbmZsdWVuY2VzLnNvcnQobnVtZXJpY2FsU29ydCk7XG5cdFx0XHRjb25zdCBtb3JwaFRhcmdldHMgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0XHRjb25zdCBtb3JwaE5vcm1hbHMgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsO1xuXHRcdFx0bGV0IG1vcnBoSW5mbHVlbmNlc1N1bSA9IDA7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkrKykge1xuXHRcdFx0XHRjb25zdCBpbmZsdWVuY2UgPSB3b3JrSW5mbHVlbmNlc1tpXTtcblx0XHRcdFx0Y29uc3QgaW5kZXggPSBpbmZsdWVuY2VbMF07XG5cdFx0XHRcdGNvbnN0IHZhbHVlID0gaW5mbHVlbmNlWzFdO1xuXHRcdFx0XHRpZiAoaW5kZXggIT09IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSICYmIHZhbHVlKSB7XG5cdFx0XHRcdFx0aWYgKG1vcnBoVGFyZ2V0cyAmJiBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoJ21vcnBoVGFyZ2V0JyArIGkpICE9PSBtb3JwaFRhcmdldHNbaW5kZXhdKSB7XG5cdFx0XHRcdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ21vcnBoVGFyZ2V0JyArIGksIG1vcnBoVGFyZ2V0c1tpbmRleF0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAobW9ycGhOb3JtYWxzICYmIGdlb21ldHJ5LmdldEF0dHJpYnV0ZSgnbW9ycGhOb3JtYWwnICsgaSkgIT09IG1vcnBoTm9ybWFsc1tpbmRleF0pIHtcblx0XHRcdFx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnbW9ycGhOb3JtYWwnICsgaSwgbW9ycGhOb3JtYWxzW2luZGV4XSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG1vcnBoSW5mbHVlbmNlc1tpXSA9IHZhbHVlO1xuXHRcdFx0XHRcdG1vcnBoSW5mbHVlbmNlc1N1bSArPSB2YWx1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAobW9ycGhUYXJnZXRzICYmIGdlb21ldHJ5Lmhhc0F0dHJpYnV0ZSgnbW9ycGhUYXJnZXQnICsgaSkgPT09IHRydWUpIHtcblx0XHRcdFx0XHRcdGdlb21ldHJ5LmRlbGV0ZUF0dHJpYnV0ZSgnbW9ycGhUYXJnZXQnICsgaSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChtb3JwaE5vcm1hbHMgJiYgZ2VvbWV0cnkuaGFzQXR0cmlidXRlKCdtb3JwaE5vcm1hbCcgKyBpKSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0Z2VvbWV0cnkuZGVsZXRlQXR0cmlidXRlKCdtb3JwaE5vcm1hbCcgKyBpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bW9ycGhJbmZsdWVuY2VzW2ldID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBHTFNMIHNoYWRlciB1c2VzIGZvcm11bGEgYmFzZWluZmx1ZW5jZSAqIGJhc2UgKyBzdW0odGFyZ2V0ICogaW5mbHVlbmNlKVxuXHRcdFx0Ly8gVGhpcyBhbGxvd3MgdXMgdG8gc3dpdGNoIGJldHdlZW4gYWJzb2x1dGUgbW9ycGhzIGFuZCByZWxhdGl2ZSBtb3JwaHMgd2l0aG91dCBjaGFuZ2luZyBzaGFkZXIgY29kZVxuXHRcdFx0Ly8gV2hlbiBiYXNlaW5mbHVlbmNlID0gMSAtIHN1bShpbmZsdWVuY2UpLCB0aGUgYWJvdmUgaXMgZXF1aXZhbGVudCB0byBzdW0oKHRhcmdldCAtIGJhc2UpICogaW5mbHVlbmNlKVxuXHRcdFx0Y29uc3QgbW9ycGhCYXNlSW5mbHVlbmNlID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzUmVsYXRpdmUgPyAxIDogMSAtIG1vcnBoSW5mbHVlbmNlc1N1bTtcblx0XHRcdHByb2dyYW0uZ2V0VW5pZm9ybXMoKS5zZXRWYWx1ZShnbCwgJ21vcnBoVGFyZ2V0QmFzZUluZmx1ZW5jZScsIG1vcnBoQmFzZUluZmx1ZW5jZSk7XG5cdFx0XHRwcm9ncmFtLmdldFVuaWZvcm1zKCkuc2V0VmFsdWUoZ2wsICdtb3JwaFRhcmdldEluZmx1ZW5jZXMnLCBtb3JwaEluZmx1ZW5jZXMpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4ge1xuXHRcdHVwZGF0ZTogdXBkYXRlXG5cdH07XG59XG5cbmZ1bmN0aW9uIFdlYkdMT2JqZWN0cyhnbCwgZ2VvbWV0cmllcywgYXR0cmlidXRlcywgaW5mbykge1xuXHRsZXQgdXBkYXRlTWFwID0gbmV3IFdlYWtNYXAoKTtcblx0ZnVuY3Rpb24gdXBkYXRlKG9iamVjdCkge1xuXHRcdGNvbnN0IGZyYW1lID0gaW5mby5yZW5kZXIuZnJhbWU7XG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG5cdFx0Y29uc3QgYnVmZmVyZ2VvbWV0cnkgPSBnZW9tZXRyaWVzLmdldChvYmplY3QsIGdlb21ldHJ5KTtcblxuXHRcdC8vIFVwZGF0ZSBvbmNlIHBlciBmcmFtZVxuXG5cdFx0aWYgKHVwZGF0ZU1hcC5nZXQoYnVmZmVyZ2VvbWV0cnkpICE9PSBmcmFtZSkge1xuXHRcdFx0Z2VvbWV0cmllcy51cGRhdGUoYnVmZmVyZ2VvbWV0cnkpO1xuXHRcdFx0dXBkYXRlTWFwLnNldChidWZmZXJnZW9tZXRyeSwgZnJhbWUpO1xuXHRcdH1cblx0XHRpZiAob2JqZWN0LmlzSW5zdGFuY2VkTWVzaCkge1xuXHRcdFx0aWYgKG9iamVjdC5oYXNFdmVudExpc3RlbmVyKCdkaXNwb3NlJywgb25JbnN0YW5jZWRNZXNoRGlzcG9zZSkgPT09IGZhbHNlKSB7XG5cdFx0XHRcdG9iamVjdC5hZGRFdmVudExpc3RlbmVyKCdkaXNwb3NlJywgb25JbnN0YW5jZWRNZXNoRGlzcG9zZSk7XG5cdFx0XHR9XG5cdFx0XHRhdHRyaWJ1dGVzLnVwZGF0ZShvYmplY3QuaW5zdGFuY2VNYXRyaXgsIGdsLkFSUkFZX0JVRkZFUik7XG5cdFx0XHRpZiAob2JqZWN0Lmluc3RhbmNlQ29sb3IgIT09IG51bGwpIHtcblx0XHRcdFx0YXR0cmlidXRlcy51cGRhdGUob2JqZWN0Lmluc3RhbmNlQ29sb3IsIGdsLkFSUkFZX0JVRkZFUik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBidWZmZXJnZW9tZXRyeTtcblx0fVxuXHRmdW5jdGlvbiBkaXNwb3NlKCkge1xuXHRcdHVwZGF0ZU1hcCA9IG5ldyBXZWFrTWFwKCk7XG5cdH1cblx0ZnVuY3Rpb24gb25JbnN0YW5jZWRNZXNoRGlzcG9zZShldmVudCkge1xuXHRcdGNvbnN0IGluc3RhbmNlZE1lc2ggPSBldmVudC50YXJnZXQ7XG5cdFx0aW5zdGFuY2VkTWVzaC5yZW1vdmVFdmVudExpc3RlbmVyKCdkaXNwb3NlJywgb25JbnN0YW5jZWRNZXNoRGlzcG9zZSk7XG5cdFx0YXR0cmlidXRlcy5yZW1vdmUoaW5zdGFuY2VkTWVzaC5pbnN0YW5jZU1hdHJpeCk7XG5cdFx0aWYgKGluc3RhbmNlZE1lc2guaW5zdGFuY2VDb2xvciAhPT0gbnVsbCkgYXR0cmlidXRlcy5yZW1vdmUoaW5zdGFuY2VkTWVzaC5pbnN0YW5jZUNvbG9yKTtcblx0fVxuXHRyZXR1cm4ge1xuXHRcdHVwZGF0ZTogdXBkYXRlLFxuXHRcdGRpc3Bvc2U6IGRpc3Bvc2Vcblx0fTtcbn1cblxuLyoqXG4gKiBVbmlmb3JtcyBvZiBhIHByb2dyYW0uXG4gKiBUaG9zZSBmb3JtIGEgdHJlZSBzdHJ1Y3R1cmUgd2l0aCBhIHNwZWNpYWwgdG9wLWxldmVsIGNvbnRhaW5lciBmb3IgdGhlIHJvb3QsXG4gKiB3aGljaCB5b3UgZ2V0IGJ5IGNhbGxpbmcgJ25ldyBXZWJHTFVuaWZvcm1zKCBnbCwgcHJvZ3JhbSApJy5cbiAqXG4gKlxuICogUHJvcGVydGllcyBvZiBpbm5lciBub2RlcyBpbmNsdWRpbmcgdGhlIHRvcC1sZXZlbCBjb250YWluZXI6XG4gKlxuICogLnNlcSAtIGFycmF5IG9mIG5lc3RlZCB1bmlmb3Jtc1xuICogLm1hcCAtIG5lc3RlZCB1bmlmb3JtcyBieSBuYW1lXG4gKlxuICpcbiAqIE1ldGhvZHMgb2YgYWxsIG5vZGVzIGV4Y2VwdCB0aGUgdG9wLWxldmVsIGNvbnRhaW5lcjpcbiAqXG4gKiAuc2V0VmFsdWUoIGdsLCB2YWx1ZSwgW3RleHR1cmVzXSApXG4gKlxuICogXHRcdHVwbG9hZHMgYSB1bmlmb3JtIHZhbHVlKHMpXG4gKlx0XHR0aGUgJ3RleHR1cmVzJyBwYXJhbWV0ZXIgaXMgbmVlZGVkIGZvciBzYW1wbGVyIHVuaWZvcm1zXG4gKlxuICpcbiAqIFN0YXRpYyBtZXRob2RzIG9mIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyICh0ZXh0dXJlcyBmYWN0b3JpemF0aW9ucyk6XG4gKlxuICogLnVwbG9hZCggZ2wsIHNlcSwgdmFsdWVzLCB0ZXh0dXJlcyApXG4gKlxuICogXHRcdHNldHMgdW5pZm9ybXMgaW4gJ3NlcScgdG8gJ3ZhbHVlc1tpZF0udmFsdWUnXG4gKlxuICogLnNlcVdpdGhWYWx1ZSggc2VxLCB2YWx1ZXMgKSA6IGZpbHRlcmVkU2VxXG4gKlxuICogXHRcdGZpbHRlcnMgJ3NlcScgZW50cmllcyB3aXRoIGNvcnJlc3BvbmRpbmcgZW50cnkgaW4gdmFsdWVzXG4gKlxuICpcbiAqIE1ldGhvZHMgb2YgdGhlIHRvcC1sZXZlbCBjb250YWluZXIgKHRleHR1cmVzIGZhY3Rvcml6YXRpb25zKTpcbiAqXG4gKiAuc2V0VmFsdWUoIGdsLCBuYW1lLCB2YWx1ZSwgdGV4dHVyZXMgKVxuICpcbiAqIFx0XHRzZXRzIHVuaWZvcm0gd2l0aFx0bmFtZSAnbmFtZScgdG8gJ3ZhbHVlJ1xuICpcbiAqIC5zZXRPcHRpb25hbCggZ2wsIG9iaiwgcHJvcCApXG4gKlxuICogXHRcdGxpa2UgLnNldCBmb3IgYW4gb3B0aW9uYWwgcHJvcGVydHkgb2YgdGhlIG9iamVjdFxuICpcbiAqL1xuY29uc3QgZW1wdHlUZXh0dXJlID0gLypAX19QVVJFX18qL25ldyBUZXh0dXJlKCk7XG5jb25zdCBlbXB0eUFycmF5VGV4dHVyZSA9IC8qQF9fUFVSRV9fKi9uZXcgRGF0YUFycmF5VGV4dHVyZSgpO1xuY29uc3QgZW1wdHkzZFRleHR1cmUgPSAvKkBfX1BVUkVfXyovbmV3IERhdGEzRFRleHR1cmUoKTtcbmNvbnN0IGVtcHR5Q3ViZVRleHR1cmUgPSAvKkBfX1BVUkVfXyovbmV3IEN1YmVUZXh0dXJlKCk7XG5cbi8vIC0tLSBVdGlsaXRpZXMgLS0tXG5cbi8vIEFycmF5IENhY2hlcyAocHJvdmlkZSB0eXBlZCBhcnJheXMgZm9yIHRlbXBvcmFyeSBieSBzaXplKVxuXG5jb25zdCBhcnJheUNhY2hlRjMyID0gW107XG5jb25zdCBhcnJheUNhY2hlSTMyID0gW107XG5cbi8vIEZsb2F0MzJBcnJheSBjYWNoZXMgdXNlZCBmb3IgdXBsb2FkaW5nIE1hdHJpeCB1bmlmb3Jtc1xuXG5jb25zdCBtYXQ0YXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcbmNvbnN0IG1hdDNhcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoOSk7XG5jb25zdCBtYXQyYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuXG4vLyBGbGF0dGVuaW5nIGZvciBhcnJheXMgb2YgdmVjdG9ycyBhbmQgbWF0cmljZXNcblxuZnVuY3Rpb24gZmxhdHRlbihhcnJheSwgbkJsb2NrcywgYmxvY2tTaXplKSB7XG5cdGNvbnN0IGZpcnN0RWxlbSA9IGFycmF5WzBdO1xuXHRpZiAoZmlyc3RFbGVtIDw9IDAgfHwgZmlyc3RFbGVtID4gMCkgcmV0dXJuIGFycmF5O1xuXHQvLyB1bm9wdGltaXplZDogISBpc05hTiggZmlyc3RFbGVtIClcblx0Ly8gc2VlIGh0dHA6Ly9qYWNrc29uZHVuc3Rhbi5jb20vYXJ0aWNsZXMvOTgzXG5cblx0Y29uc3QgbiA9IG5CbG9ja3MgKiBibG9ja1NpemU7XG5cdGxldCByID0gYXJyYXlDYWNoZUYzMltuXTtcblx0aWYgKHIgPT09IHVuZGVmaW5lZCkge1xuXHRcdHIgPSBuZXcgRmxvYXQzMkFycmF5KG4pO1xuXHRcdGFycmF5Q2FjaGVGMzJbbl0gPSByO1xuXHR9XG5cdGlmIChuQmxvY2tzICE9PSAwKSB7XG5cdFx0Zmlyc3RFbGVtLnRvQXJyYXkociwgMCk7XG5cdFx0Zm9yIChsZXQgaSA9IDEsIG9mZnNldCA9IDA7IGkgIT09IG5CbG9ja3M7ICsraSkge1xuXHRcdFx0b2Zmc2V0ICs9IGJsb2NrU2l6ZTtcblx0XHRcdGFycmF5W2ldLnRvQXJyYXkociwgb2Zmc2V0KTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHI7XG59XG5mdW5jdGlvbiBhcnJheXNFcXVhbChhLCBiKSB7XG5cdGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcblx0Zm9yIChsZXQgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2U7XG5cdH1cblx0cmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjb3B5QXJyYXkoYSwgYikge1xuXHRmb3IgKGxldCBpID0gMCwgbCA9IGIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0YVtpXSA9IGJbaV07XG5cdH1cbn1cblxuLy8gVGV4dHVyZSB1bml0IGFsbG9jYXRpb25cblxuZnVuY3Rpb24gYWxsb2NUZXhVbml0cyh0ZXh0dXJlcywgbikge1xuXHRsZXQgciA9IGFycmF5Q2FjaGVJMzJbbl07XG5cdGlmIChyID09PSB1bmRlZmluZWQpIHtcblx0XHRyID0gbmV3IEludDMyQXJyYXkobik7XG5cdFx0YXJyYXlDYWNoZUkzMltuXSA9IHI7XG5cdH1cblx0Zm9yIChsZXQgaSA9IDA7IGkgIT09IG47ICsraSkge1xuXHRcdHJbaV0gPSB0ZXh0dXJlcy5hbGxvY2F0ZVRleHR1cmVVbml0KCk7XG5cdH1cblx0cmV0dXJuIHI7XG59XG5cbi8vIC0tLSBTZXR0ZXJzIC0tLVxuXG4vLyBOb3RlOiBEZWZpbmluZyB0aGVzZSBtZXRob2RzIGV4dGVybmFsbHksIGJlY2F1c2UgdGhleSBjb21lIGluIGEgYnVuY2hcbi8vIGFuZCB0aGlzIHdheSB0aGVpciBuYW1lcyBtaW5pZnkuXG5cbi8vIFNpbmdsZSBzY2FsYXJcblxuZnVuY3Rpb24gc2V0VmFsdWVWMWYoZ2wsIHYpIHtcblx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xuXHRpZiAoY2FjaGVbMF0gPT09IHYpIHJldHVybjtcblx0Z2wudW5pZm9ybTFmKHRoaXMuYWRkciwgdik7XG5cdGNhY2hlWzBdID0gdjtcbn1cblxuLy8gU2luZ2xlIGZsb2F0IHZlY3RvciAoZnJvbSBmbGF0IGFycmF5IG9yIFRIUkVFLlZlY3Rvck4pXG5cbmZ1bmN0aW9uIHNldFZhbHVlVjJmKGdsLCB2KSB7XG5cdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcblx0aWYgKHYueCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKGNhY2hlWzBdICE9PSB2LnggfHwgY2FjaGVbMV0gIT09IHYueSkge1xuXHRcdFx0Z2wudW5pZm9ybTJmKHRoaXMuYWRkciwgdi54LCB2LnkpO1xuXHRcdFx0Y2FjaGVbMF0gPSB2Lng7XG5cdFx0XHRjYWNoZVsxXSA9IHYueTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0aWYgKGFycmF5c0VxdWFsKGNhY2hlLCB2KSkgcmV0dXJuO1xuXHRcdGdsLnVuaWZvcm0yZnYodGhpcy5hZGRyLCB2KTtcblx0XHRjb3B5QXJyYXkoY2FjaGUsIHYpO1xuXHR9XG59XG5mdW5jdGlvbiBzZXRWYWx1ZVYzZihnbCwgdikge1xuXHRjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGU7XG5cdGlmICh2LnggIT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChjYWNoZVswXSAhPT0gdi54IHx8IGNhY2hlWzFdICE9PSB2LnkgfHwgY2FjaGVbMl0gIT09IHYueikge1xuXHRcdFx0Z2wudW5pZm9ybTNmKHRoaXMuYWRkciwgdi54LCB2LnksIHYueik7XG5cdFx0XHRjYWNoZVswXSA9IHYueDtcblx0XHRcdGNhY2hlWzFdID0gdi55O1xuXHRcdFx0Y2FjaGVbMl0gPSB2Lno7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKHYuciAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKGNhY2hlWzBdICE9PSB2LnIgfHwgY2FjaGVbMV0gIT09IHYuZyB8fCBjYWNoZVsyXSAhPT0gdi5iKSB7XG5cdFx0XHRnbC51bmlmb3JtM2YodGhpcy5hZGRyLCB2LnIsIHYuZywgdi5iKTtcblx0XHRcdGNhY2hlWzBdID0gdi5yO1xuXHRcdFx0Y2FjaGVbMV0gPSB2Lmc7XG5cdFx0XHRjYWNoZVsyXSA9IHYuYjtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0aWYgKGFycmF5c0VxdWFsKGNhY2hlLCB2KSkgcmV0dXJuO1xuXHRcdGdsLnVuaWZvcm0zZnYodGhpcy5hZGRyLCB2KTtcblx0XHRjb3B5QXJyYXkoY2FjaGUsIHYpO1xuXHR9XG59XG5mdW5jdGlvbiBzZXRWYWx1ZVY0ZihnbCwgdikge1xuXHRjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGU7XG5cdGlmICh2LnggIT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChjYWNoZVswXSAhPT0gdi54IHx8IGNhY2hlWzFdICE9PSB2LnkgfHwgY2FjaGVbMl0gIT09IHYueiB8fCBjYWNoZVszXSAhPT0gdi53KSB7XG5cdFx0XHRnbC51bmlmb3JtNGYodGhpcy5hZGRyLCB2LngsIHYueSwgdi56LCB2LncpO1xuXHRcdFx0Y2FjaGVbMF0gPSB2Lng7XG5cdFx0XHRjYWNoZVsxXSA9IHYueTtcblx0XHRcdGNhY2hlWzJdID0gdi56O1xuXHRcdFx0Y2FjaGVbM10gPSB2Lnc7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGlmIChhcnJheXNFcXVhbChjYWNoZSwgdikpIHJldHVybjtcblx0XHRnbC51bmlmb3JtNGZ2KHRoaXMuYWRkciwgdik7XG5cdFx0Y29weUFycmF5KGNhY2hlLCB2KTtcblx0fVxufVxuXG4vLyBTaW5nbGUgbWF0cml4IChmcm9tIGZsYXQgYXJyYXkgb3IgVEhSRUUuTWF0cml4TilcblxuZnVuY3Rpb24gc2V0VmFsdWVNMihnbCwgdikge1xuXHRjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGU7XG5cdGNvbnN0IGVsZW1lbnRzID0gdi5lbGVtZW50cztcblx0aWYgKGVsZW1lbnRzID09PSB1bmRlZmluZWQpIHtcblx0XHRpZiAoYXJyYXlzRXF1YWwoY2FjaGUsIHYpKSByZXR1cm47XG5cdFx0Z2wudW5pZm9ybU1hdHJpeDJmdih0aGlzLmFkZHIsIGZhbHNlLCB2KTtcblx0XHRjb3B5QXJyYXkoY2FjaGUsIHYpO1xuXHR9IGVsc2Uge1xuXHRcdGlmIChhcnJheXNFcXVhbChjYWNoZSwgZWxlbWVudHMpKSByZXR1cm47XG5cdFx0bWF0MmFycmF5LnNldChlbGVtZW50cyk7XG5cdFx0Z2wudW5pZm9ybU1hdHJpeDJmdih0aGlzLmFkZHIsIGZhbHNlLCBtYXQyYXJyYXkpO1xuXHRcdGNvcHlBcnJheShjYWNoZSwgZWxlbWVudHMpO1xuXHR9XG59XG5mdW5jdGlvbiBzZXRWYWx1ZU0zKGdsLCB2KSB7XG5cdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcblx0Y29uc3QgZWxlbWVudHMgPSB2LmVsZW1lbnRzO1xuXHRpZiAoZWxlbWVudHMgPT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChhcnJheXNFcXVhbChjYWNoZSwgdikpIHJldHVybjtcblx0XHRnbC51bmlmb3JtTWF0cml4M2Z2KHRoaXMuYWRkciwgZmFsc2UsIHYpO1xuXHRcdGNvcHlBcnJheShjYWNoZSwgdik7XG5cdH0gZWxzZSB7XG5cdFx0aWYgKGFycmF5c0VxdWFsKGNhY2hlLCBlbGVtZW50cykpIHJldHVybjtcblx0XHRtYXQzYXJyYXkuc2V0KGVsZW1lbnRzKTtcblx0XHRnbC51bmlmb3JtTWF0cml4M2Z2KHRoaXMuYWRkciwgZmFsc2UsIG1hdDNhcnJheSk7XG5cdFx0Y29weUFycmF5KGNhY2hlLCBlbGVtZW50cyk7XG5cdH1cbn1cbmZ1bmN0aW9uIHNldFZhbHVlTTQoZ2wsIHYpIHtcblx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xuXHRjb25zdCBlbGVtZW50cyA9IHYuZWxlbWVudHM7XG5cdGlmIChlbGVtZW50cyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKGFycmF5c0VxdWFsKGNhY2hlLCB2KSkgcmV0dXJuO1xuXHRcdGdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5hZGRyLCBmYWxzZSwgdik7XG5cdFx0Y29weUFycmF5KGNhY2hlLCB2KTtcblx0fSBlbHNlIHtcblx0XHRpZiAoYXJyYXlzRXF1YWwoY2FjaGUsIGVsZW1lbnRzKSkgcmV0dXJuO1xuXHRcdG1hdDRhcnJheS5zZXQoZWxlbWVudHMpO1xuXHRcdGdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5hZGRyLCBmYWxzZSwgbWF0NGFycmF5KTtcblx0XHRjb3B5QXJyYXkoY2FjaGUsIGVsZW1lbnRzKTtcblx0fVxufVxuXG4vLyBTaW5nbGUgaW50ZWdlciAvIGJvb2xlYW5cblxuZnVuY3Rpb24gc2V0VmFsdWVWMWkoZ2wsIHYpIHtcblx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xuXHRpZiAoY2FjaGVbMF0gPT09IHYpIHJldHVybjtcblx0Z2wudW5pZm9ybTFpKHRoaXMuYWRkciwgdik7XG5cdGNhY2hlWzBdID0gdjtcbn1cblxuLy8gU2luZ2xlIGludGVnZXIgLyBib29sZWFuIHZlY3RvciAoZnJvbSBmbGF0IGFycmF5IG9yIFRIUkVFLlZlY3Rvck4pXG5cbmZ1bmN0aW9uIHNldFZhbHVlVjJpKGdsLCB2KSB7XG5cdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcblx0aWYgKHYueCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKGNhY2hlWzBdICE9PSB2LnggfHwgY2FjaGVbMV0gIT09IHYueSkge1xuXHRcdFx0Z2wudW5pZm9ybTJpKHRoaXMuYWRkciwgdi54LCB2LnkpO1xuXHRcdFx0Y2FjaGVbMF0gPSB2Lng7XG5cdFx0XHRjYWNoZVsxXSA9IHYueTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0aWYgKGFycmF5c0VxdWFsKGNhY2hlLCB2KSkgcmV0dXJuO1xuXHRcdGdsLnVuaWZvcm0yaXYodGhpcy5hZGRyLCB2KTtcblx0XHRjb3B5QXJyYXkoY2FjaGUsIHYpO1xuXHR9XG59XG5mdW5jdGlvbiBzZXRWYWx1ZVYzaShnbCwgdikge1xuXHRjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGU7XG5cdGlmICh2LnggIT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChjYWNoZVswXSAhPT0gdi54IHx8IGNhY2hlWzFdICE9PSB2LnkgfHwgY2FjaGVbMl0gIT09IHYueikge1xuXHRcdFx0Z2wudW5pZm9ybTNpKHRoaXMuYWRkciwgdi54LCB2LnksIHYueik7XG5cdFx0XHRjYWNoZVswXSA9IHYueDtcblx0XHRcdGNhY2hlWzFdID0gdi55O1xuXHRcdFx0Y2FjaGVbMl0gPSB2Lno7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGlmIChhcnJheXNFcXVhbChjYWNoZSwgdikpIHJldHVybjtcblx0XHRnbC51bmlmb3JtM2l2KHRoaXMuYWRkciwgdik7XG5cdFx0Y29weUFycmF5KGNhY2hlLCB2KTtcblx0fVxufVxuZnVuY3Rpb24gc2V0VmFsdWVWNGkoZ2wsIHYpIHtcblx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xuXHRpZiAodi54ICE9PSB1bmRlZmluZWQpIHtcblx0XHRpZiAoY2FjaGVbMF0gIT09IHYueCB8fCBjYWNoZVsxXSAhPT0gdi55IHx8IGNhY2hlWzJdICE9PSB2LnogfHwgY2FjaGVbM10gIT09IHYudykge1xuXHRcdFx0Z2wudW5pZm9ybTRpKHRoaXMuYWRkciwgdi54LCB2LnksIHYueiwgdi53KTtcblx0XHRcdGNhY2hlWzBdID0gdi54O1xuXHRcdFx0Y2FjaGVbMV0gPSB2Lnk7XG5cdFx0XHRjYWNoZVsyXSA9IHYuejtcblx0XHRcdGNhY2hlWzNdID0gdi53O1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRpZiAoYXJyYXlzRXF1YWwoY2FjaGUsIHYpKSByZXR1cm47XG5cdFx0Z2wudW5pZm9ybTRpdih0aGlzLmFkZHIsIHYpO1xuXHRcdGNvcHlBcnJheShjYWNoZSwgdik7XG5cdH1cbn1cblxuLy8gU2luZ2xlIHVuc2lnbmVkIGludGVnZXJcblxuZnVuY3Rpb24gc2V0VmFsdWVWMXVpKGdsLCB2KSB7XG5cdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcblx0aWYgKGNhY2hlWzBdID09PSB2KSByZXR1cm47XG5cdGdsLnVuaWZvcm0xdWkodGhpcy5hZGRyLCB2KTtcblx0Y2FjaGVbMF0gPSB2O1xufVxuXG4vLyBTaW5nbGUgdW5zaWduZWQgaW50ZWdlciB2ZWN0b3IgKGZyb20gZmxhdCBhcnJheSBvciBUSFJFRS5WZWN0b3JOKVxuXG5mdW5jdGlvbiBzZXRWYWx1ZVYydWkoZ2wsIHYpIHtcblx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xuXHRpZiAodi54ICE9PSB1bmRlZmluZWQpIHtcblx0XHRpZiAoY2FjaGVbMF0gIT09IHYueCB8fCBjYWNoZVsxXSAhPT0gdi55KSB7XG5cdFx0XHRnbC51bmlmb3JtMnVpKHRoaXMuYWRkciwgdi54LCB2LnkpO1xuXHRcdFx0Y2FjaGVbMF0gPSB2Lng7XG5cdFx0XHRjYWNoZVsxXSA9IHYueTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0aWYgKGFycmF5c0VxdWFsKGNhY2hlLCB2KSkgcmV0dXJuO1xuXHRcdGdsLnVuaWZvcm0ydWl2KHRoaXMuYWRkciwgdik7XG5cdFx0Y29weUFycmF5KGNhY2hlLCB2KTtcblx0fVxufVxuZnVuY3Rpb24gc2V0VmFsdWVWM3VpKGdsLCB2KSB7XG5cdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcblx0aWYgKHYueCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKGNhY2hlWzBdICE9PSB2LnggfHwgY2FjaGVbMV0gIT09IHYueSB8fCBjYWNoZVsyXSAhPT0gdi56KSB7XG5cdFx0XHRnbC51bmlmb3JtM3VpKHRoaXMuYWRkciwgdi54LCB2LnksIHYueik7XG5cdFx0XHRjYWNoZVswXSA9IHYueDtcblx0XHRcdGNhY2hlWzFdID0gdi55O1xuXHRcdFx0Y2FjaGVbMl0gPSB2Lno7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGlmIChhcnJheXNFcXVhbChjYWNoZSwgdikpIHJldHVybjtcblx0XHRnbC51bmlmb3JtM3Vpdih0aGlzLmFkZHIsIHYpO1xuXHRcdGNvcHlBcnJheShjYWNoZSwgdik7XG5cdH1cbn1cbmZ1bmN0aW9uIHNldFZhbHVlVjR1aShnbCwgdikge1xuXHRjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGU7XG5cdGlmICh2LnggIT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChjYWNoZVswXSAhPT0gdi54IHx8IGNhY2hlWzFdICE9PSB2LnkgfHwgY2FjaGVbMl0gIT09IHYueiB8fCBjYWNoZVszXSAhPT0gdi53KSB7XG5cdFx0XHRnbC51bmlmb3JtNHVpKHRoaXMuYWRkciwgdi54LCB2LnksIHYueiwgdi53KTtcblx0XHRcdGNhY2hlWzBdID0gdi54O1xuXHRcdFx0Y2FjaGVbMV0gPSB2Lnk7XG5cdFx0XHRjYWNoZVsyXSA9IHYuejtcblx0XHRcdGNhY2hlWzNdID0gdi53O1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRpZiAoYXJyYXlzRXF1YWwoY2FjaGUsIHYpKSByZXR1cm47XG5cdFx0Z2wudW5pZm9ybTR1aXYodGhpcy5hZGRyLCB2KTtcblx0XHRjb3B5QXJyYXkoY2FjaGUsIHYpO1xuXHR9XG59XG5cbi8vIFNpbmdsZSB0ZXh0dXJlICgyRCAvIEN1YmUpXG5cbmZ1bmN0aW9uIHNldFZhbHVlVDEoZ2wsIHYsIHRleHR1cmVzKSB7XG5cdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcblx0Y29uc3QgdW5pdCA9IHRleHR1cmVzLmFsbG9jYXRlVGV4dHVyZVVuaXQoKTtcblx0aWYgKGNhY2hlWzBdICE9PSB1bml0KSB7XG5cdFx0Z2wudW5pZm9ybTFpKHRoaXMuYWRkciwgdW5pdCk7XG5cdFx0Y2FjaGVbMF0gPSB1bml0O1xuXHR9XG5cdHRleHR1cmVzLnNldFRleHR1cmUyRCh2IHx8IGVtcHR5VGV4dHVyZSwgdW5pdCk7XG59XG5mdW5jdGlvbiBzZXRWYWx1ZVQzRDEoZ2wsIHYsIHRleHR1cmVzKSB7XG5cdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcblx0Y29uc3QgdW5pdCA9IHRleHR1cmVzLmFsbG9jYXRlVGV4dHVyZVVuaXQoKTtcblx0aWYgKGNhY2hlWzBdICE9PSB1bml0KSB7XG5cdFx0Z2wudW5pZm9ybTFpKHRoaXMuYWRkciwgdW5pdCk7XG5cdFx0Y2FjaGVbMF0gPSB1bml0O1xuXHR9XG5cdHRleHR1cmVzLnNldFRleHR1cmUzRCh2IHx8IGVtcHR5M2RUZXh0dXJlLCB1bml0KTtcbn1cbmZ1bmN0aW9uIHNldFZhbHVlVDYoZ2wsIHYsIHRleHR1cmVzKSB7XG5cdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcblx0Y29uc3QgdW5pdCA9IHRleHR1cmVzLmFsbG9jYXRlVGV4dHVyZVVuaXQoKTtcblx0aWYgKGNhY2hlWzBdICE9PSB1bml0KSB7XG5cdFx0Z2wudW5pZm9ybTFpKHRoaXMuYWRkciwgdW5pdCk7XG5cdFx0Y2FjaGVbMF0gPSB1bml0O1xuXHR9XG5cdHRleHR1cmVzLnNldFRleHR1cmVDdWJlKHYgfHwgZW1wdHlDdWJlVGV4dHVyZSwgdW5pdCk7XG59XG5mdW5jdGlvbiBzZXRWYWx1ZVQyREFycmF5MShnbCwgdiwgdGV4dHVyZXMpIHtcblx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xuXHRjb25zdCB1bml0ID0gdGV4dHVyZXMuYWxsb2NhdGVUZXh0dXJlVW5pdCgpO1xuXHRpZiAoY2FjaGVbMF0gIT09IHVuaXQpIHtcblx0XHRnbC51bmlmb3JtMWkodGhpcy5hZGRyLCB1bml0KTtcblx0XHRjYWNoZVswXSA9IHVuaXQ7XG5cdH1cblx0dGV4dHVyZXMuc2V0VGV4dHVyZTJEQXJyYXkodiB8fCBlbXB0eUFycmF5VGV4dHVyZSwgdW5pdCk7XG59XG5cbi8vIEhlbHBlciB0byBwaWNrIHRoZSByaWdodCBzZXR0ZXIgZm9yIHRoZSBzaW5ndWxhciBjYXNlXG5cbmZ1bmN0aW9uIGdldFNpbmd1bGFyU2V0dGVyKHR5cGUpIHtcblx0c3dpdGNoICh0eXBlKSB7XG5cdFx0Y2FzZSAweDE0MDY6XG5cdFx0XHRyZXR1cm4gc2V0VmFsdWVWMWY7XG5cdFx0Ly8gRkxPQVRcblx0XHRjYXNlIDB4OGI1MDpcblx0XHRcdHJldHVybiBzZXRWYWx1ZVYyZjtcblx0XHQvLyBfVkVDMlxuXHRcdGNhc2UgMHg4YjUxOlxuXHRcdFx0cmV0dXJuIHNldFZhbHVlVjNmO1xuXHRcdC8vIF9WRUMzXG5cdFx0Y2FzZSAweDhiNTI6XG5cdFx0XHRyZXR1cm4gc2V0VmFsdWVWNGY7XG5cdFx0Ly8gX1ZFQzRcblxuXHRcdGNhc2UgMHg4YjVhOlxuXHRcdFx0cmV0dXJuIHNldFZhbHVlTTI7XG5cdFx0Ly8gX01BVDJcblx0XHRjYXNlIDB4OGI1Yjpcblx0XHRcdHJldHVybiBzZXRWYWx1ZU0zO1xuXHRcdC8vIF9NQVQzXG5cdFx0Y2FzZSAweDhiNWM6XG5cdFx0XHRyZXR1cm4gc2V0VmFsdWVNNDtcblx0XHQvLyBfTUFUNFxuXG5cdFx0Y2FzZSAweDE0MDQ6XG5cdFx0Y2FzZSAweDhiNTY6XG5cdFx0XHRyZXR1cm4gc2V0VmFsdWVWMWk7XG5cdFx0Ly8gSU5ULCBCT09MXG5cdFx0Y2FzZSAweDhiNTM6XG5cdFx0Y2FzZSAweDhiNTc6XG5cdFx0XHRyZXR1cm4gc2V0VmFsdWVWMmk7XG5cdFx0Ly8gX1ZFQzJcblx0XHRjYXNlIDB4OGI1NDpcblx0XHRjYXNlIDB4OGI1ODpcblx0XHRcdHJldHVybiBzZXRWYWx1ZVYzaTtcblx0XHQvLyBfVkVDM1xuXHRcdGNhc2UgMHg4YjU1OlxuXHRcdGNhc2UgMHg4YjU5OlxuXHRcdFx0cmV0dXJuIHNldFZhbHVlVjRpO1xuXHRcdC8vIF9WRUM0XG5cblx0XHRjYXNlIDB4MTQwNTpcblx0XHRcdHJldHVybiBzZXRWYWx1ZVYxdWk7XG5cdFx0Ly8gVUlOVFxuXHRcdGNhc2UgMHg4ZGM2OlxuXHRcdFx0cmV0dXJuIHNldFZhbHVlVjJ1aTtcblx0XHQvLyBfVkVDMlxuXHRcdGNhc2UgMHg4ZGM3OlxuXHRcdFx0cmV0dXJuIHNldFZhbHVlVjN1aTtcblx0XHQvLyBfVkVDM1xuXHRcdGNhc2UgMHg4ZGM4OlxuXHRcdFx0cmV0dXJuIHNldFZhbHVlVjR1aTtcblx0XHQvLyBfVkVDNFxuXG5cdFx0Y2FzZSAweDhiNWU6IC8vIFNBTVBMRVJfMkRcblx0XHRjYXNlIDB4OGQ2NjogLy8gU0FNUExFUl9FWFRFUk5BTF9PRVNcblx0XHRjYXNlIDB4OGRjYTogLy8gSU5UX1NBTVBMRVJfMkRcblx0XHRjYXNlIDB4OGRkMjogLy8gVU5TSUdORURfSU5UX1NBTVBMRVJfMkRcblx0XHRjYXNlIDB4OGI2Mjpcblx0XHRcdC8vIFNBTVBMRVJfMkRfU0hBRE9XXG5cdFx0XHRyZXR1cm4gc2V0VmFsdWVUMTtcblx0XHRjYXNlIDB4OGI1ZjogLy8gU0FNUExFUl8zRFxuXHRcdGNhc2UgMHg4ZGNiOiAvLyBJTlRfU0FNUExFUl8zRFxuXHRcdGNhc2UgMHg4ZGQzOlxuXHRcdFx0Ly8gVU5TSUdORURfSU5UX1NBTVBMRVJfM0Rcblx0XHRcdHJldHVybiBzZXRWYWx1ZVQzRDE7XG5cdFx0Y2FzZSAweDhiNjA6IC8vIFNBTVBMRVJfQ1VCRVxuXHRcdGNhc2UgMHg4ZGNjOiAvLyBJTlRfU0FNUExFUl9DVUJFXG5cdFx0Y2FzZSAweDhkZDQ6IC8vIFVOU0lHTkVEX0lOVF9TQU1QTEVSX0NVQkVcblx0XHRjYXNlIDB4OGRjNTpcblx0XHRcdC8vIFNBTVBMRVJfQ1VCRV9TSEFET1dcblx0XHRcdHJldHVybiBzZXRWYWx1ZVQ2O1xuXHRcdGNhc2UgMHg4ZGMxOiAvLyBTQU1QTEVSXzJEX0FSUkFZXG5cdFx0Y2FzZSAweDhkY2Y6IC8vIElOVF9TQU1QTEVSXzJEX0FSUkFZXG5cdFx0Y2FzZSAweDhkZDc6IC8vIFVOU0lHTkVEX0lOVF9TQU1QTEVSXzJEX0FSUkFZXG5cdFx0Y2FzZSAweDhkYzQ6XG5cdFx0XHQvLyBTQU1QTEVSXzJEX0FSUkFZX1NIQURPV1xuXHRcdFx0cmV0dXJuIHNldFZhbHVlVDJEQXJyYXkxO1xuXHR9XG59XG5cbi8vIEFycmF5IG9mIHNjYWxhcnNcblxuZnVuY3Rpb24gc2V0VmFsdWVWMWZBcnJheShnbCwgdikge1xuXHRnbC51bmlmb3JtMWZ2KHRoaXMuYWRkciwgdik7XG59XG5cbi8vIEFycmF5IG9mIHZlY3RvcnMgKGZyb20gZmxhdCBhcnJheSBvciBhcnJheSBvZiBUSFJFRS5WZWN0b3JOKVxuXG5mdW5jdGlvbiBzZXRWYWx1ZVYyZkFycmF5KGdsLCB2KSB7XG5cdGNvbnN0IGRhdGEgPSBmbGF0dGVuKHYsIHRoaXMuc2l6ZSwgMik7XG5cdGdsLnVuaWZvcm0yZnYodGhpcy5hZGRyLCBkYXRhKTtcbn1cbmZ1bmN0aW9uIHNldFZhbHVlVjNmQXJyYXkoZ2wsIHYpIHtcblx0Y29uc3QgZGF0YSA9IGZsYXR0ZW4odiwgdGhpcy5zaXplLCAzKTtcblx0Z2wudW5pZm9ybTNmdih0aGlzLmFkZHIsIGRhdGEpO1xufVxuZnVuY3Rpb24gc2V0VmFsdWVWNGZBcnJheShnbCwgdikge1xuXHRjb25zdCBkYXRhID0gZmxhdHRlbih2LCB0aGlzLnNpemUsIDQpO1xuXHRnbC51bmlmb3JtNGZ2KHRoaXMuYWRkciwgZGF0YSk7XG59XG5cbi8vIEFycmF5IG9mIG1hdHJpY2VzIChmcm9tIGZsYXQgYXJyYXkgb3IgYXJyYXkgb2YgVEhSRUUuTWF0cml4TilcblxuZnVuY3Rpb24gc2V0VmFsdWVNMkFycmF5KGdsLCB2KSB7XG5cdGNvbnN0IGRhdGEgPSBmbGF0dGVuKHYsIHRoaXMuc2l6ZSwgNCk7XG5cdGdsLnVuaWZvcm1NYXRyaXgyZnYodGhpcy5hZGRyLCBmYWxzZSwgZGF0YSk7XG59XG5mdW5jdGlvbiBzZXRWYWx1ZU0zQXJyYXkoZ2wsIHYpIHtcblx0Y29uc3QgZGF0YSA9IGZsYXR0ZW4odiwgdGhpcy5zaXplLCA5KTtcblx0Z2wudW5pZm9ybU1hdHJpeDNmdih0aGlzLmFkZHIsIGZhbHNlLCBkYXRhKTtcbn1cbmZ1bmN0aW9uIHNldFZhbHVlTTRBcnJheShnbCwgdikge1xuXHRjb25zdCBkYXRhID0gZmxhdHRlbih2LCB0aGlzLnNpemUsIDE2KTtcblx0Z2wudW5pZm9ybU1hdHJpeDRmdih0aGlzLmFkZHIsIGZhbHNlLCBkYXRhKTtcbn1cblxuLy8gQXJyYXkgb2YgaW50ZWdlciAvIGJvb2xlYW5cblxuZnVuY3Rpb24gc2V0VmFsdWVWMWlBcnJheShnbCwgdikge1xuXHRnbC51bmlmb3JtMWl2KHRoaXMuYWRkciwgdik7XG59XG5cbi8vIEFycmF5IG9mIGludGVnZXIgLyBib29sZWFuIHZlY3RvcnMgKGZyb20gZmxhdCBhcnJheSlcblxuZnVuY3Rpb24gc2V0VmFsdWVWMmlBcnJheShnbCwgdikge1xuXHRnbC51bmlmb3JtMml2KHRoaXMuYWRkciwgdik7XG59XG5mdW5jdGlvbiBzZXRWYWx1ZVYzaUFycmF5KGdsLCB2KSB7XG5cdGdsLnVuaWZvcm0zaXYodGhpcy5hZGRyLCB2KTtcbn1cbmZ1bmN0aW9uIHNldFZhbHVlVjRpQXJyYXkoZ2wsIHYpIHtcblx0Z2wudW5pZm9ybTRpdih0aGlzLmFkZHIsIHYpO1xufVxuXG4vLyBBcnJheSBvZiB1bnNpZ25lZCBpbnRlZ2VyXG5cbmZ1bmN0aW9uIHNldFZhbHVlVjF1aUFycmF5KGdsLCB2KSB7XG5cdGdsLnVuaWZvcm0xdWl2KHRoaXMuYWRkciwgdik7XG59XG5cbi8vIEFycmF5IG9mIHVuc2lnbmVkIGludGVnZXIgdmVjdG9ycyAoZnJvbSBmbGF0IGFycmF5KVxuXG5mdW5jdGlvbiBzZXRWYWx1ZVYydWlBcnJheShnbCwgdikge1xuXHRnbC51bmlmb3JtMnVpdih0aGlzLmFkZHIsIHYpO1xufVxuZnVuY3Rpb24gc2V0VmFsdWVWM3VpQXJyYXkoZ2wsIHYpIHtcblx0Z2wudW5pZm9ybTN1aXYodGhpcy5hZGRyLCB2KTtcbn1cbmZ1bmN0aW9uIHNldFZhbHVlVjR1aUFycmF5KGdsLCB2KSB7XG5cdGdsLnVuaWZvcm00dWl2KHRoaXMuYWRkciwgdik7XG59XG5cbi8vIEFycmF5IG9mIHRleHR1cmVzICgyRCAvIDNEIC8gQ3ViZSAvIDJEQXJyYXkpXG5cbmZ1bmN0aW9uIHNldFZhbHVlVDFBcnJheShnbCwgdiwgdGV4dHVyZXMpIHtcblx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xuXHRjb25zdCBuID0gdi5sZW5ndGg7XG5cdGNvbnN0IHVuaXRzID0gYWxsb2NUZXhVbml0cyh0ZXh0dXJlcywgbik7XG5cdGlmICghYXJyYXlzRXF1YWwoY2FjaGUsIHVuaXRzKSkge1xuXHRcdGdsLnVuaWZvcm0xaXYodGhpcy5hZGRyLCB1bml0cyk7XG5cdFx0Y29weUFycmF5KGNhY2hlLCB1bml0cyk7XG5cdH1cblx0Zm9yIChsZXQgaSA9IDA7IGkgIT09IG47ICsraSkge1xuXHRcdHRleHR1cmVzLnNldFRleHR1cmUyRCh2W2ldIHx8IGVtcHR5VGV4dHVyZSwgdW5pdHNbaV0pO1xuXHR9XG59XG5mdW5jdGlvbiBzZXRWYWx1ZVQzREFycmF5KGdsLCB2LCB0ZXh0dXJlcykge1xuXHRjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGU7XG5cdGNvbnN0IG4gPSB2Lmxlbmd0aDtcblx0Y29uc3QgdW5pdHMgPSBhbGxvY1RleFVuaXRzKHRleHR1cmVzLCBuKTtcblx0aWYgKCFhcnJheXNFcXVhbChjYWNoZSwgdW5pdHMpKSB7XG5cdFx0Z2wudW5pZm9ybTFpdih0aGlzLmFkZHIsIHVuaXRzKTtcblx0XHRjb3B5QXJyYXkoY2FjaGUsIHVuaXRzKTtcblx0fVxuXHRmb3IgKGxldCBpID0gMDsgaSAhPT0gbjsgKytpKSB7XG5cdFx0dGV4dHVyZXMuc2V0VGV4dHVyZTNEKHZbaV0gfHwgZW1wdHkzZFRleHR1cmUsIHVuaXRzW2ldKTtcblx0fVxufVxuZnVuY3Rpb24gc2V0VmFsdWVUNkFycmF5KGdsLCB2LCB0ZXh0dXJlcykge1xuXHRjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGU7XG5cdGNvbnN0IG4gPSB2Lmxlbmd0aDtcblx0Y29uc3QgdW5pdHMgPSBhbGxvY1RleFVuaXRzKHRleHR1cmVzLCBuKTtcblx0aWYgKCFhcnJheXNFcXVhbChjYWNoZSwgdW5pdHMpKSB7XG5cdFx0Z2wudW5pZm9ybTFpdih0aGlzLmFkZHIsIHVuaXRzKTtcblx0XHRjb3B5QXJyYXkoY2FjaGUsIHVuaXRzKTtcblx0fVxuXHRmb3IgKGxldCBpID0gMDsgaSAhPT0gbjsgKytpKSB7XG5cdFx0dGV4dHVyZXMuc2V0VGV4dHVyZUN1YmUodltpXSB8fCBlbXB0eUN1YmVUZXh0dXJlLCB1bml0c1tpXSk7XG5cdH1cbn1cbmZ1bmN0aW9uIHNldFZhbHVlVDJEQXJyYXlBcnJheShnbCwgdiwgdGV4dHVyZXMpIHtcblx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xuXHRjb25zdCBuID0gdi5sZW5ndGg7XG5cdGNvbnN0IHVuaXRzID0gYWxsb2NUZXhVbml0cyh0ZXh0dXJlcywgbik7XG5cdGlmICghYXJyYXlzRXF1YWwoY2FjaGUsIHVuaXRzKSkge1xuXHRcdGdsLnVuaWZvcm0xaXYodGhpcy5hZGRyLCB1bml0cyk7XG5cdFx0Y29weUFycmF5KGNhY2hlLCB1bml0cyk7XG5cdH1cblx0Zm9yIChsZXQgaSA9IDA7IGkgIT09IG47ICsraSkge1xuXHRcdHRleHR1cmVzLnNldFRleHR1cmUyREFycmF5KHZbaV0gfHwgZW1wdHlBcnJheVRleHR1cmUsIHVuaXRzW2ldKTtcblx0fVxufVxuXG4vLyBIZWxwZXIgdG8gcGljayB0aGUgcmlnaHQgc2V0dGVyIGZvciBhIHB1cmUgKGJvdHRvbS1sZXZlbCkgYXJyYXlcblxuZnVuY3Rpb24gZ2V0UHVyZUFycmF5U2V0dGVyKHR5cGUpIHtcblx0c3dpdGNoICh0eXBlKSB7XG5cdFx0Y2FzZSAweDE0MDY6XG5cdFx0XHRyZXR1cm4gc2V0VmFsdWVWMWZBcnJheTtcblx0XHQvLyBGTE9BVFxuXHRcdGNhc2UgMHg4YjUwOlxuXHRcdFx0cmV0dXJuIHNldFZhbHVlVjJmQXJyYXk7XG5cdFx0Ly8gX1ZFQzJcblx0XHRjYXNlIDB4OGI1MTpcblx0XHRcdHJldHVybiBzZXRWYWx1ZVYzZkFycmF5O1xuXHRcdC8vIF9WRUMzXG5cdFx0Y2FzZSAweDhiNTI6XG5cdFx0XHRyZXR1cm4gc2V0VmFsdWVWNGZBcnJheTtcblx0XHQvLyBfVkVDNFxuXG5cdFx0Y2FzZSAweDhiNWE6XG5cdFx0XHRyZXR1cm4gc2V0VmFsdWVNMkFycmF5O1xuXHRcdC8vIF9NQVQyXG5cdFx0Y2FzZSAweDhiNWI6XG5cdFx0XHRyZXR1cm4gc2V0VmFsdWVNM0FycmF5O1xuXHRcdC8vIF9NQVQzXG5cdFx0Y2FzZSAweDhiNWM6XG5cdFx0XHRyZXR1cm4gc2V0VmFsdWVNNEFycmF5O1xuXHRcdC8vIF9NQVQ0XG5cblx0XHRjYXNlIDB4MTQwNDpcblx0XHRjYXNlIDB4OGI1Njpcblx0XHRcdHJldHVybiBzZXRWYWx1ZVYxaUFycmF5O1xuXHRcdC8vIElOVCwgQk9PTFxuXHRcdGNhc2UgMHg4YjUzOlxuXHRcdGNhc2UgMHg4YjU3OlxuXHRcdFx0cmV0dXJuIHNldFZhbHVlVjJpQXJyYXk7XG5cdFx0Ly8gX1ZFQzJcblx0XHRjYXNlIDB4OGI1NDpcblx0XHRjYXNlIDB4OGI1ODpcblx0XHRcdHJldHVybiBzZXRWYWx1ZVYzaUFycmF5O1xuXHRcdC8vIF9WRUMzXG5cdFx0Y2FzZSAweDhiNTU6XG5cdFx0Y2FzZSAweDhiNTk6XG5cdFx0XHRyZXR1cm4gc2V0VmFsdWVWNGlBcnJheTtcblx0XHQvLyBfVkVDNFxuXG5cdFx0Y2FzZSAweDE0MDU6XG5cdFx0XHRyZXR1cm4gc2V0VmFsdWVWMXVpQXJyYXk7XG5cdFx0Ly8gVUlOVFxuXHRcdGNhc2UgMHg4ZGM2OlxuXHRcdFx0cmV0dXJuIHNldFZhbHVlVjJ1aUFycmF5O1xuXHRcdC8vIF9WRUMyXG5cdFx0Y2FzZSAweDhkYzc6XG5cdFx0XHRyZXR1cm4gc2V0VmFsdWVWM3VpQXJyYXk7XG5cdFx0Ly8gX1ZFQzNcblx0XHRjYXNlIDB4OGRjODpcblx0XHRcdHJldHVybiBzZXRWYWx1ZVY0dWlBcnJheTtcblx0XHQvLyBfVkVDNFxuXG5cdFx0Y2FzZSAweDhiNWU6IC8vIFNBTVBMRVJfMkRcblx0XHRjYXNlIDB4OGQ2NjogLy8gU0FNUExFUl9FWFRFUk5BTF9PRVNcblx0XHRjYXNlIDB4OGRjYTogLy8gSU5UX1NBTVBMRVJfMkRcblx0XHRjYXNlIDB4OGRkMjogLy8gVU5TSUdORURfSU5UX1NBTVBMRVJfMkRcblx0XHRjYXNlIDB4OGI2Mjpcblx0XHRcdC8vIFNBTVBMRVJfMkRfU0hBRE9XXG5cdFx0XHRyZXR1cm4gc2V0VmFsdWVUMUFycmF5O1xuXHRcdGNhc2UgMHg4YjVmOiAvLyBTQU1QTEVSXzNEXG5cdFx0Y2FzZSAweDhkY2I6IC8vIElOVF9TQU1QTEVSXzNEXG5cdFx0Y2FzZSAweDhkZDM6XG5cdFx0XHQvLyBVTlNJR05FRF9JTlRfU0FNUExFUl8zRFxuXHRcdFx0cmV0dXJuIHNldFZhbHVlVDNEQXJyYXk7XG5cdFx0Y2FzZSAweDhiNjA6IC8vIFNBTVBMRVJfQ1VCRVxuXHRcdGNhc2UgMHg4ZGNjOiAvLyBJTlRfU0FNUExFUl9DVUJFXG5cdFx0Y2FzZSAweDhkZDQ6IC8vIFVOU0lHTkVEX0lOVF9TQU1QTEVSX0NVQkVcblx0XHRjYXNlIDB4OGRjNTpcblx0XHRcdC8vIFNBTVBMRVJfQ1VCRV9TSEFET1dcblx0XHRcdHJldHVybiBzZXRWYWx1ZVQ2QXJyYXk7XG5cdFx0Y2FzZSAweDhkYzE6IC8vIFNBTVBMRVJfMkRfQVJSQVlcblx0XHRjYXNlIDB4OGRjZjogLy8gSU5UX1NBTVBMRVJfMkRfQVJSQVlcblx0XHRjYXNlIDB4OGRkNzogLy8gVU5TSUdORURfSU5UX1NBTVBMRVJfMkRfQVJSQVlcblx0XHRjYXNlIDB4OGRjNDpcblx0XHRcdC8vIFNBTVBMRVJfMkRfQVJSQVlfU0hBRE9XXG5cdFx0XHRyZXR1cm4gc2V0VmFsdWVUMkRBcnJheUFycmF5O1xuXHR9XG59XG5cbi8vIC0tLSBVbmlmb3JtIENsYXNzZXMgLS0tXG5cbmNsYXNzIFNpbmdsZVVuaWZvcm0ge1xuXHRjb25zdHJ1Y3RvcihpZCwgYWN0aXZlSW5mbywgYWRkcikge1xuXHRcdHRoaXMuaWQgPSBpZDtcblx0XHR0aGlzLmFkZHIgPSBhZGRyO1xuXHRcdHRoaXMuY2FjaGUgPSBbXTtcblx0XHR0aGlzLnNldFZhbHVlID0gZ2V0U2luZ3VsYXJTZXR0ZXIoYWN0aXZlSW5mby50eXBlKTtcblxuXHRcdC8vIHRoaXMucGF0aCA9IGFjdGl2ZUluZm8ubmFtZTsgLy8gREVCVUdcblx0fVxufVxuXG5jbGFzcyBQdXJlQXJyYXlVbmlmb3JtIHtcblx0Y29uc3RydWN0b3IoaWQsIGFjdGl2ZUluZm8sIGFkZHIpIHtcblx0XHR0aGlzLmlkID0gaWQ7XG5cdFx0dGhpcy5hZGRyID0gYWRkcjtcblx0XHR0aGlzLmNhY2hlID0gW107XG5cdFx0dGhpcy5zaXplID0gYWN0aXZlSW5mby5zaXplO1xuXHRcdHRoaXMuc2V0VmFsdWUgPSBnZXRQdXJlQXJyYXlTZXR0ZXIoYWN0aXZlSW5mby50eXBlKTtcblxuXHRcdC8vIHRoaXMucGF0aCA9IGFjdGl2ZUluZm8ubmFtZTsgLy8gREVCVUdcblx0fVxufVxuXG5jbGFzcyBTdHJ1Y3R1cmVkVW5pZm9ybSB7XG5cdGNvbnN0cnVjdG9yKGlkKSB7XG5cdFx0dGhpcy5pZCA9IGlkO1xuXHRcdHRoaXMuc2VxID0gW107XG5cdFx0dGhpcy5tYXAgPSB7fTtcblx0fVxuXHRzZXRWYWx1ZShnbCwgdmFsdWUsIHRleHR1cmVzKSB7XG5cdFx0Y29uc3Qgc2VxID0gdGhpcy5zZXE7XG5cdFx0Zm9yIChsZXQgaSA9IDAsIG4gPSBzZXEubGVuZ3RoOyBpICE9PSBuOyArK2kpIHtcblx0XHRcdGNvbnN0IHUgPSBzZXFbaV07XG5cdFx0XHR1LnNldFZhbHVlKGdsLCB2YWx1ZVt1LmlkXSwgdGV4dHVyZXMpO1xuXHRcdH1cblx0fVxufVxuXG4vLyAtLS0gVG9wLWxldmVsIC0tLVxuXG4vLyBQYXJzZXIgLSBidWlsZHMgdXAgdGhlIHByb3BlcnR5IHRyZWUgZnJvbSB0aGUgcGF0aCBzdHJpbmdzXG5cbmNvbnN0IFJlUGF0aFBhcnQgPSAvKFxcdyspKFxcXSk/KFxcW3xcXC4pPy9nO1xuXG4vLyBleHRyYWN0c1xuLy8gXHQtIHRoZSBpZGVudGlmaWVyIChtZW1iZXIgbmFtZSBvciBhcnJheSBpbmRleClcbi8vXHQtIGZvbGxvd2VkIGJ5IGFuIG9wdGlvbmFsIHJpZ2h0IGJyYWNrZXQgKGZvdW5kIHdoZW4gYXJyYXkgaW5kZXgpXG4vL1x0LSBmb2xsb3dlZCBieSBhbiBvcHRpb25hbCBsZWZ0IGJyYWNrZXQgb3IgZG90ICh0eXBlIG9mIHN1YnNjcmlwdClcbi8vXG4vLyBOb3RlOiBUaGVzZSBwb3J0aW9ucyBjYW4gYmUgcmVhZCBpbiBhIG5vbi1vdmVybGFwcGluZyBmYXNoaW9uIGFuZFxuLy8gYWxsb3cgc3RyYWlnaHRmb3J3YXJkIHBhcnNpbmcgb2YgdGhlIGhpZXJhcmNoeSB0aGF0IFdlYkdMIGVuY29kZXNcbi8vIGluIHRoZSB1bmlmb3JtIG5hbWVzLlxuXG5mdW5jdGlvbiBhZGRVbmlmb3JtKGNvbnRhaW5lciwgdW5pZm9ybU9iamVjdCkge1xuXHRjb250YWluZXIuc2VxLnB1c2godW5pZm9ybU9iamVjdCk7XG5cdGNvbnRhaW5lci5tYXBbdW5pZm9ybU9iamVjdC5pZF0gPSB1bmlmb3JtT2JqZWN0O1xufVxuZnVuY3Rpb24gcGFyc2VVbmlmb3JtKGFjdGl2ZUluZm8sIGFkZHIsIGNvbnRhaW5lcikge1xuXHRjb25zdCBwYXRoID0gYWN0aXZlSW5mby5uYW1lLFxuXHRcdHBhdGhMZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuXHQvLyByZXNldCBSZWdFeHAgb2JqZWN0LCBiZWNhdXNlIG9mIHRoZSBlYXJseSBleGl0IG9mIGEgcHJldmlvdXMgcnVuXG5cdFJlUGF0aFBhcnQubGFzdEluZGV4ID0gMDtcblx0d2hpbGUgKHRydWUpIHtcblx0XHRjb25zdCBtYXRjaCA9IFJlUGF0aFBhcnQuZXhlYyhwYXRoKSxcblx0XHRcdG1hdGNoRW5kID0gUmVQYXRoUGFydC5sYXN0SW5kZXg7XG5cdFx0bGV0IGlkID0gbWF0Y2hbMV07XG5cdFx0Y29uc3QgaWRJc0luZGV4ID0gbWF0Y2hbMl0gPT09ICddJyxcblx0XHRcdHN1YnNjcmlwdCA9IG1hdGNoWzNdO1xuXHRcdGlmIChpZElzSW5kZXgpIGlkID0gaWQgfCAwOyAvLyBjb252ZXJ0IHRvIGludGVnZXJcblxuXHRcdGlmIChzdWJzY3JpcHQgPT09IHVuZGVmaW5lZCB8fCBzdWJzY3JpcHQgPT09ICdbJyAmJiBtYXRjaEVuZCArIDIgPT09IHBhdGhMZW5ndGgpIHtcblx0XHRcdC8vIGJhcmUgbmFtZSBvciBcInB1cmVcIiBib3R0b20tbGV2ZWwgYXJyYXkgXCJbMF1cIiBzdWZmaXhcblxuXHRcdFx0YWRkVW5pZm9ybShjb250YWluZXIsIHN1YnNjcmlwdCA9PT0gdW5kZWZpbmVkID8gbmV3IFNpbmdsZVVuaWZvcm0oaWQsIGFjdGl2ZUluZm8sIGFkZHIpIDogbmV3IFB1cmVBcnJheVVuaWZvcm0oaWQsIGFjdGl2ZUluZm8sIGFkZHIpKTtcblx0XHRcdGJyZWFrO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBzdGVwIGludG8gaW5uZXIgbm9kZSAvIGNyZWF0ZSBpdCBpbiBjYXNlIGl0IGRvZXNuJ3QgZXhpc3RcblxuXHRcdFx0Y29uc3QgbWFwID0gY29udGFpbmVyLm1hcDtcblx0XHRcdGxldCBuZXh0ID0gbWFwW2lkXTtcblx0XHRcdGlmIChuZXh0ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0bmV4dCA9IG5ldyBTdHJ1Y3R1cmVkVW5pZm9ybShpZCk7XG5cdFx0XHRcdGFkZFVuaWZvcm0oY29udGFpbmVyLCBuZXh0KTtcblx0XHRcdH1cblx0XHRcdGNvbnRhaW5lciA9IG5leHQ7XG5cdFx0fVxuXHR9XG59XG5cbi8vIFJvb3QgQ29udGFpbmVyXG5cbmNsYXNzIFdlYkdMVW5pZm9ybXMge1xuXHRjb25zdHJ1Y3RvcihnbCwgcHJvZ3JhbSkge1xuXHRcdHRoaXMuc2VxID0gW107XG5cdFx0dGhpcy5tYXAgPSB7fTtcblx0XHRjb25zdCBuID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5BQ1RJVkVfVU5JRk9STVMpO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG5cdFx0XHRjb25zdCBpbmZvID0gZ2wuZ2V0QWN0aXZlVW5pZm9ybShwcm9ncmFtLCBpKSxcblx0XHRcdFx0YWRkciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBpbmZvLm5hbWUpO1xuXHRcdFx0cGFyc2VVbmlmb3JtKGluZm8sIGFkZHIsIHRoaXMpO1xuXHRcdH1cblx0fVxuXHRzZXRWYWx1ZShnbCwgbmFtZSwgdmFsdWUsIHRleHR1cmVzKSB7XG5cdFx0Y29uc3QgdSA9IHRoaXMubWFwW25hbWVdO1xuXHRcdGlmICh1ICE9PSB1bmRlZmluZWQpIHUuc2V0VmFsdWUoZ2wsIHZhbHVlLCB0ZXh0dXJlcyk7XG5cdH1cblx0c2V0T3B0aW9uYWwoZ2wsIG9iamVjdCwgbmFtZSkge1xuXHRcdGNvbnN0IHYgPSBvYmplY3RbbmFtZV07XG5cdFx0aWYgKHYgIT09IHVuZGVmaW5lZCkgdGhpcy5zZXRWYWx1ZShnbCwgbmFtZSwgdik7XG5cdH1cblx0c3RhdGljIHVwbG9hZChnbCwgc2VxLCB2YWx1ZXMsIHRleHR1cmVzKSB7XG5cdFx0Zm9yIChsZXQgaSA9IDAsIG4gPSBzZXEubGVuZ3RoOyBpICE9PSBuOyArK2kpIHtcblx0XHRcdGNvbnN0IHUgPSBzZXFbaV0sXG5cdFx0XHRcdHYgPSB2YWx1ZXNbdS5pZF07XG5cdFx0XHRpZiAodi5uZWVkc1VwZGF0ZSAhPT0gZmFsc2UpIHtcblx0XHRcdFx0Ly8gbm90ZTogYWx3YXlzIHVwZGF0aW5nIHdoZW4gLm5lZWRzVXBkYXRlIGlzIHVuZGVmaW5lZFxuXHRcdFx0XHR1LnNldFZhbHVlKGdsLCB2LnZhbHVlLCB0ZXh0dXJlcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHN0YXRpYyBzZXFXaXRoVmFsdWUoc2VxLCB2YWx1ZXMpIHtcblx0XHRjb25zdCByID0gW107XG5cdFx0Zm9yIChsZXQgaSA9IDAsIG4gPSBzZXEubGVuZ3RoOyBpICE9PSBuOyArK2kpIHtcblx0XHRcdGNvbnN0IHUgPSBzZXFbaV07XG5cdFx0XHRpZiAodS5pZCBpbiB2YWx1ZXMpIHIucHVzaCh1KTtcblx0XHR9XG5cdFx0cmV0dXJuIHI7XG5cdH1cbn1cblxuZnVuY3Rpb24gV2ViR0xTaGFkZXIoZ2wsIHR5cGUsIHN0cmluZykge1xuXHRjb25zdCBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIodHlwZSk7XG5cdGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHN0cmluZyk7XG5cdGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcblx0cmV0dXJuIHNoYWRlcjtcbn1cblxubGV0IHByb2dyYW1JZENvdW50ID0gMDtcbmZ1bmN0aW9uIGhhbmRsZVNvdXJjZShzdHJpbmcsIGVycm9yTGluZSkge1xuXHRjb25zdCBsaW5lcyA9IHN0cmluZy5zcGxpdCgnXFxuJyk7XG5cdGNvbnN0IGxpbmVzMiA9IFtdO1xuXHRjb25zdCBmcm9tID0gTWF0aC5tYXgoZXJyb3JMaW5lIC0gNiwgMCk7XG5cdGNvbnN0IHRvID0gTWF0aC5taW4oZXJyb3JMaW5lICsgNiwgbGluZXMubGVuZ3RoKTtcblx0Zm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKSB7XG5cdFx0Y29uc3QgbGluZSA9IGkgKyAxO1xuXHRcdGxpbmVzMi5wdXNoKGAke2xpbmUgPT09IGVycm9yTGluZSA/ICc+JyA6ICcgJ30gJHtsaW5lfTogJHtsaW5lc1tpXX1gKTtcblx0fVxuXHRyZXR1cm4gbGluZXMyLmpvaW4oJ1xcbicpO1xufVxuZnVuY3Rpb24gZ2V0RW5jb2RpbmdDb21wb25lbnRzKGVuY29kaW5nKSB7XG5cdHN3aXRjaCAoZW5jb2RpbmcpIHtcblx0XHRjYXNlIExpbmVhckVuY29kaW5nOlxuXHRcdFx0cmV0dXJuIFsnTGluZWFyJywgJyggdmFsdWUgKSddO1xuXHRcdGNhc2Ugc1JHQkVuY29kaW5nOlxuXHRcdFx0cmV0dXJuIFsnc1JHQicsICcoIHZhbHVlICknXTtcblx0XHRkZWZhdWx0OlxuXHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFByb2dyYW06IFVuc3VwcG9ydGVkIGVuY29kaW5nOicsIGVuY29kaW5nKTtcblx0XHRcdHJldHVybiBbJ0xpbmVhcicsICcoIHZhbHVlICknXTtcblx0fVxufVxuZnVuY3Rpb24gZ2V0U2hhZGVyRXJyb3JzKGdsLCBzaGFkZXIsIHR5cGUpIHtcblx0Y29uc3Qgc3RhdHVzID0gZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpO1xuXHRjb25zdCBlcnJvcnMgPSBnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcikudHJpbSgpO1xuXHRpZiAoc3RhdHVzICYmIGVycm9ycyA9PT0gJycpIHJldHVybiAnJztcblx0Y29uc3QgZXJyb3JNYXRjaGVzID0gL0VSUk9SOiAwOihcXGQrKS8uZXhlYyhlcnJvcnMpO1xuXHRpZiAoZXJyb3JNYXRjaGVzKSB7XG5cdFx0Ly8gLS1lbmFibGUtcHJpdmlsZWdlZC13ZWJnbC1leHRlbnNpb25cblx0XHQvLyBjb25zb2xlLmxvZyggJyoqJyArIHR5cGUgKyAnKionLCBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9kZWJ1Z19zaGFkZXJzJyApLmdldFRyYW5zbGF0ZWRTaGFkZXJTb3VyY2UoIHNoYWRlciApICk7XG5cblx0XHRjb25zdCBlcnJvckxpbmUgPSBwYXJzZUludChlcnJvck1hdGNoZXNbMV0pO1xuXHRcdHJldHVybiB0eXBlLnRvVXBwZXJDYXNlKCkgKyAnXFxuXFxuJyArIGVycm9ycyArICdcXG5cXG4nICsgaGFuZGxlU291cmNlKGdsLmdldFNoYWRlclNvdXJjZShzaGFkZXIpLCBlcnJvckxpbmUpO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBlcnJvcnM7XG5cdH1cbn1cbmZ1bmN0aW9uIGdldFRleGVsRW5jb2RpbmdGdW5jdGlvbihmdW5jdGlvbk5hbWUsIGVuY29kaW5nKSB7XG5cdGNvbnN0IGNvbXBvbmVudHMgPSBnZXRFbmNvZGluZ0NvbXBvbmVudHMoZW5jb2RpbmcpO1xuXHRyZXR1cm4gJ3ZlYzQgJyArIGZ1bmN0aW9uTmFtZSArICcoIHZlYzQgdmFsdWUgKSB7IHJldHVybiBMaW5lYXJUbycgKyBjb21wb25lbnRzWzBdICsgY29tcG9uZW50c1sxXSArICc7IH0nO1xufVxuZnVuY3Rpb24gZ2V0VG9uZU1hcHBpbmdGdW5jdGlvbihmdW5jdGlvbk5hbWUsIHRvbmVNYXBwaW5nKSB7XG5cdGxldCB0b25lTWFwcGluZ05hbWU7XG5cdHN3aXRjaCAodG9uZU1hcHBpbmcpIHtcblx0XHRjYXNlIExpbmVhclRvbmVNYXBwaW5nOlxuXHRcdFx0dG9uZU1hcHBpbmdOYW1lID0gJ0xpbmVhcic7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIFJlaW5oYXJkVG9uZU1hcHBpbmc6XG5cdFx0XHR0b25lTWFwcGluZ05hbWUgPSAnUmVpbmhhcmQnO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBDaW5lb25Ub25lTWFwcGluZzpcblx0XHRcdHRvbmVNYXBwaW5nTmFtZSA9ICdPcHRpbWl6ZWRDaW5lb24nO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBBQ0VTRmlsbWljVG9uZU1hcHBpbmc6XG5cdFx0XHR0b25lTWFwcGluZ05hbWUgPSAnQUNFU0ZpbG1pYyc7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIEN1c3RvbVRvbmVNYXBwaW5nOlxuXHRcdFx0dG9uZU1hcHBpbmdOYW1lID0gJ0N1c3RvbSc7XG5cdFx0XHRicmVhaztcblx0XHRkZWZhdWx0OlxuXHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFByb2dyYW06IFVuc3VwcG9ydGVkIHRvbmVNYXBwaW5nOicsIHRvbmVNYXBwaW5nKTtcblx0XHRcdHRvbmVNYXBwaW5nTmFtZSA9ICdMaW5lYXInO1xuXHR9XG5cdHJldHVybiAndmVjMyAnICsgZnVuY3Rpb25OYW1lICsgJyggdmVjMyBjb2xvciApIHsgcmV0dXJuICcgKyB0b25lTWFwcGluZ05hbWUgKyAnVG9uZU1hcHBpbmcoIGNvbG9yICk7IH0nO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVFeHRlbnNpb25zKHBhcmFtZXRlcnMpIHtcblx0Y29uc3QgY2h1bmtzID0gW3BhcmFtZXRlcnMuZXh0ZW5zaW9uRGVyaXZhdGl2ZXMgfHwgISFwYXJhbWV0ZXJzLmVudk1hcEN1YmVVVkhlaWdodCB8fCBwYXJhbWV0ZXJzLmJ1bXBNYXAgfHwgcGFyYW1ldGVycy50YW5nZW50U3BhY2VOb3JtYWxNYXAgfHwgcGFyYW1ldGVycy5jbGVhcmNvYXROb3JtYWxNYXAgfHwgcGFyYW1ldGVycy5mbGF0U2hhZGluZyB8fCBwYXJhbWV0ZXJzLnNoYWRlcklEID09PSAncGh5c2ljYWwnID8gJyNleHRlbnNpb24gR0xfT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzIDogZW5hYmxlJyA6ICcnLCAocGFyYW1ldGVycy5leHRlbnNpb25GcmFnRGVwdGggfHwgcGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyKSAmJiBwYXJhbWV0ZXJzLnJlbmRlcmVyRXh0ZW5zaW9uRnJhZ0RlcHRoID8gJyNleHRlbnNpb24gR0xfRVhUX2ZyYWdfZGVwdGggOiBlbmFibGUnIDogJycsIHBhcmFtZXRlcnMuZXh0ZW5zaW9uRHJhd0J1ZmZlcnMgJiYgcGFyYW1ldGVycy5yZW5kZXJlckV4dGVuc2lvbkRyYXdCdWZmZXJzID8gJyNleHRlbnNpb24gR0xfRVhUX2RyYXdfYnVmZmVycyA6IHJlcXVpcmUnIDogJycsIChwYXJhbWV0ZXJzLmV4dGVuc2lvblNoYWRlclRleHR1cmVMT0QgfHwgcGFyYW1ldGVycy5lbnZNYXAgfHwgcGFyYW1ldGVycy50cmFuc21pc3Npb24pICYmIHBhcmFtZXRlcnMucmVuZGVyZXJFeHRlbnNpb25TaGFkZXJUZXh0dXJlTG9kID8gJyNleHRlbnNpb24gR0xfRVhUX3NoYWRlcl90ZXh0dXJlX2xvZCA6IGVuYWJsZScgOiAnJ107XG5cdHJldHVybiBjaHVua3MuZmlsdGVyKGZpbHRlckVtcHR5TGluZSkuam9pbignXFxuJyk7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZURlZmluZXMoZGVmaW5lcykge1xuXHRjb25zdCBjaHVua3MgPSBbXTtcblx0Zm9yIChjb25zdCBuYW1lIGluIGRlZmluZXMpIHtcblx0XHRjb25zdCB2YWx1ZSA9IGRlZmluZXNbbmFtZV07XG5cdFx0aWYgKHZhbHVlID09PSBmYWxzZSkgY29udGludWU7XG5cdFx0Y2h1bmtzLnB1c2goJyNkZWZpbmUgJyArIG5hbWUgKyAnICcgKyB2YWx1ZSk7XG5cdH1cblx0cmV0dXJuIGNodW5rcy5qb2luKCdcXG4nKTtcbn1cbmZ1bmN0aW9uIGZldGNoQXR0cmlidXRlTG9jYXRpb25zKGdsLCBwcm9ncmFtKSB7XG5cdGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcblx0Y29uc3QgbiA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuQUNUSVZFX0FUVFJJQlVURVMpO1xuXHRmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuXHRcdGNvbnN0IGluZm8gPSBnbC5nZXRBY3RpdmVBdHRyaWIocHJvZ3JhbSwgaSk7XG5cdFx0Y29uc3QgbmFtZSA9IGluZm8ubmFtZTtcblx0XHRsZXQgbG9jYXRpb25TaXplID0gMTtcblx0XHRpZiAoaW5mby50eXBlID09PSBnbC5GTE9BVF9NQVQyKSBsb2NhdGlvblNpemUgPSAyO1xuXHRcdGlmIChpbmZvLnR5cGUgPT09IGdsLkZMT0FUX01BVDMpIGxvY2F0aW9uU2l6ZSA9IDM7XG5cdFx0aWYgKGluZm8udHlwZSA9PT0gZ2wuRkxPQVRfTUFUNCkgbG9jYXRpb25TaXplID0gNDtcblxuXHRcdC8vIGNvbnNvbGUubG9nKCAnVEhSRUUuV2ViR0xQcm9ncmFtOiBBQ1RJVkUgVkVSVEVYIEFUVFJJQlVURTonLCBuYW1lLCBpICk7XG5cblx0XHRhdHRyaWJ1dGVzW25hbWVdID0ge1xuXHRcdFx0dHlwZTogaW5mby50eXBlLFxuXHRcdFx0bG9jYXRpb246IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIG5hbWUpLFxuXHRcdFx0bG9jYXRpb25TaXplOiBsb2NhdGlvblNpemVcblx0XHR9O1xuXHR9XG5cdHJldHVybiBhdHRyaWJ1dGVzO1xufVxuZnVuY3Rpb24gZmlsdGVyRW1wdHlMaW5lKHN0cmluZykge1xuXHRyZXR1cm4gc3RyaW5nICE9PSAnJztcbn1cbmZ1bmN0aW9uIHJlcGxhY2VMaWdodE51bXMoc3RyaW5nLCBwYXJhbWV0ZXJzKSB7XG5cdGNvbnN0IG51bVNwb3RMaWdodENvb3JkcyA9IHBhcmFtZXRlcnMubnVtU3BvdExpZ2h0U2hhZG93cyArIHBhcmFtZXRlcnMubnVtU3BvdExpZ2h0TWFwcyAtIHBhcmFtZXRlcnMubnVtU3BvdExpZ2h0U2hhZG93c1dpdGhNYXBzO1xuXHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UoL05VTV9ESVJfTElHSFRTL2csIHBhcmFtZXRlcnMubnVtRGlyTGlnaHRzKS5yZXBsYWNlKC9OVU1fU1BPVF9MSUdIVFMvZywgcGFyYW1ldGVycy5udW1TcG90TGlnaHRzKS5yZXBsYWNlKC9OVU1fU1BPVF9MSUdIVF9NQVBTL2csIHBhcmFtZXRlcnMubnVtU3BvdExpZ2h0TWFwcykucmVwbGFjZSgvTlVNX1NQT1RfTElHSFRfQ09PUkRTL2csIG51bVNwb3RMaWdodENvb3JkcykucmVwbGFjZSgvTlVNX1JFQ1RfQVJFQV9MSUdIVFMvZywgcGFyYW1ldGVycy5udW1SZWN0QXJlYUxpZ2h0cykucmVwbGFjZSgvTlVNX1BPSU5UX0xJR0hUUy9nLCBwYXJhbWV0ZXJzLm51bVBvaW50TGlnaHRzKS5yZXBsYWNlKC9OVU1fSEVNSV9MSUdIVFMvZywgcGFyYW1ldGVycy5udW1IZW1pTGlnaHRzKS5yZXBsYWNlKC9OVU1fRElSX0xJR0hUX1NIQURPV1MvZywgcGFyYW1ldGVycy5udW1EaXJMaWdodFNoYWRvd3MpLnJlcGxhY2UoL05VTV9TUE9UX0xJR0hUX1NIQURPV1NfV0lUSF9NQVBTL2csIHBhcmFtZXRlcnMubnVtU3BvdExpZ2h0U2hhZG93c1dpdGhNYXBzKS5yZXBsYWNlKC9OVU1fU1BPVF9MSUdIVF9TSEFET1dTL2csIHBhcmFtZXRlcnMubnVtU3BvdExpZ2h0U2hhZG93cykucmVwbGFjZSgvTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MvZywgcGFyYW1ldGVycy5udW1Qb2ludExpZ2h0U2hhZG93cyk7XG59XG5mdW5jdGlvbiByZXBsYWNlQ2xpcHBpbmdQbGFuZU51bXMoc3RyaW5nLCBwYXJhbWV0ZXJzKSB7XG5cdHJldHVybiBzdHJpbmcucmVwbGFjZSgvTlVNX0NMSVBQSU5HX1BMQU5FUy9nLCBwYXJhbWV0ZXJzLm51bUNsaXBwaW5nUGxhbmVzKS5yZXBsYWNlKC9VTklPTl9DTElQUElOR19QTEFORVMvZywgcGFyYW1ldGVycy5udW1DbGlwcGluZ1BsYW5lcyAtIHBhcmFtZXRlcnMubnVtQ2xpcEludGVyc2VjdGlvbik7XG59XG5cbi8vIFJlc29sdmUgSW5jbHVkZXNcblxuY29uc3QgaW5jbHVkZVBhdHRlcm4gPSAvXlsgXFx0XSojaW5jbHVkZSArPChbXFx3XFxkLi9dKyk+L2dtO1xuZnVuY3Rpb24gcmVzb2x2ZUluY2x1ZGVzKHN0cmluZykge1xuXHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UoaW5jbHVkZVBhdHRlcm4sIGluY2x1ZGVSZXBsYWNlcik7XG59XG5mdW5jdGlvbiBpbmNsdWRlUmVwbGFjZXIobWF0Y2gsIGluY2x1ZGUpIHtcblx0Y29uc3Qgc3RyaW5nID0gU2hhZGVyQ2h1bmtbaW5jbHVkZV07XG5cdGlmIChzdHJpbmcgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCByZXNvbHZlICNpbmNsdWRlIDwnICsgaW5jbHVkZSArICc+Jyk7XG5cdH1cblx0cmV0dXJuIHJlc29sdmVJbmNsdWRlcyhzdHJpbmcpO1xufVxuXG4vLyBVbnJvbGwgTG9vcHNcblxuY29uc3QgdW5yb2xsTG9vcFBhdHRlcm4gPSAvI3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxccytmb3JcXHMqXFwoXFxzKmludFxccytpXFxzKj1cXHMqKFxcZCspXFxzKjtcXHMqaVxccyo8XFxzKihcXGQrKVxccyo7XFxzKmlcXHMqXFwrXFwrXFxzKlxcKVxccyp7KFtcXHNcXFNdKz8pfVxccysjcHJhZ21hIHVucm9sbF9sb29wX2VuZC9nO1xuZnVuY3Rpb24gdW5yb2xsTG9vcHMoc3RyaW5nKSB7XG5cdHJldHVybiBzdHJpbmcucmVwbGFjZSh1bnJvbGxMb29wUGF0dGVybiwgbG9vcFJlcGxhY2VyKTtcbn1cbmZ1bmN0aW9uIGxvb3BSZXBsYWNlcihtYXRjaCwgc3RhcnQsIGVuZCwgc25pcHBldCkge1xuXHRsZXQgc3RyaW5nID0gJyc7XG5cdGZvciAobGV0IGkgPSBwYXJzZUludChzdGFydCk7IGkgPCBwYXJzZUludChlbmQpOyBpKyspIHtcblx0XHRzdHJpbmcgKz0gc25pcHBldC5yZXBsYWNlKC9cXFtcXHMqaVxccypcXF0vZywgJ1sgJyArIGkgKyAnIF0nKS5yZXBsYWNlKC9VTlJPTExFRF9MT09QX0lOREVYL2csIGkpO1xuXHR9XG5cdHJldHVybiBzdHJpbmc7XG59XG5cbi8vXG5cbmZ1bmN0aW9uIGdlbmVyYXRlUHJlY2lzaW9uKHBhcmFtZXRlcnMpIHtcblx0bGV0IHByZWNpc2lvbnN0cmluZyA9ICdwcmVjaXNpb24gJyArIHBhcmFtZXRlcnMucHJlY2lzaW9uICsgJyBmbG9hdDtcXG5wcmVjaXNpb24gJyArIHBhcmFtZXRlcnMucHJlY2lzaW9uICsgJyBpbnQ7Jztcblx0aWYgKHBhcmFtZXRlcnMucHJlY2lzaW9uID09PSAnaGlnaHAnKSB7XG5cdFx0cHJlY2lzaW9uc3RyaW5nICs9ICdcXG4jZGVmaW5lIEhJR0hfUFJFQ0lTSU9OJztcblx0fSBlbHNlIGlmIChwYXJhbWV0ZXJzLnByZWNpc2lvbiA9PT0gJ21lZGl1bXAnKSB7XG5cdFx0cHJlY2lzaW9uc3RyaW5nICs9ICdcXG4jZGVmaW5lIE1FRElVTV9QUkVDSVNJT04nO1xuXHR9IGVsc2UgaWYgKHBhcmFtZXRlcnMucHJlY2lzaW9uID09PSAnbG93cCcpIHtcblx0XHRwcmVjaXNpb25zdHJpbmcgKz0gJ1xcbiNkZWZpbmUgTE9XX1BSRUNJU0lPTic7XG5cdH1cblx0cmV0dXJuIHByZWNpc2lvbnN0cmluZztcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlU2hhZG93TWFwVHlwZURlZmluZShwYXJhbWV0ZXJzKSB7XG5cdGxldCBzaGFkb3dNYXBUeXBlRGVmaW5lID0gJ1NIQURPV01BUF9UWVBFX0JBU0lDJztcblx0aWYgKHBhcmFtZXRlcnMuc2hhZG93TWFwVHlwZSA9PT0gUENGU2hhZG93TWFwKSB7XG5cdFx0c2hhZG93TWFwVHlwZURlZmluZSA9ICdTSEFET1dNQVBfVFlQRV9QQ0YnO1xuXHR9IGVsc2UgaWYgKHBhcmFtZXRlcnMuc2hhZG93TWFwVHlwZSA9PT0gUENGU29mdFNoYWRvd01hcCkge1xuXHRcdHNoYWRvd01hcFR5cGVEZWZpbmUgPSAnU0hBRE9XTUFQX1RZUEVfUENGX1NPRlQnO1xuXHR9IGVsc2UgaWYgKHBhcmFtZXRlcnMuc2hhZG93TWFwVHlwZSA9PT0gVlNNU2hhZG93TWFwKSB7XG5cdFx0c2hhZG93TWFwVHlwZURlZmluZSA9ICdTSEFET1dNQVBfVFlQRV9WU00nO1xuXHR9XG5cdHJldHVybiBzaGFkb3dNYXBUeXBlRGVmaW5lO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVFbnZNYXBUeXBlRGVmaW5lKHBhcmFtZXRlcnMpIHtcblx0bGV0IGVudk1hcFR5cGVEZWZpbmUgPSAnRU5WTUFQX1RZUEVfQ1VCRSc7XG5cdGlmIChwYXJhbWV0ZXJzLmVudk1hcCkge1xuXHRcdHN3aXRjaCAocGFyYW1ldGVycy5lbnZNYXBNb2RlKSB7XG5cdFx0XHRjYXNlIEN1YmVSZWZsZWN0aW9uTWFwcGluZzpcblx0XHRcdGNhc2UgQ3ViZVJlZnJhY3Rpb25NYXBwaW5nOlxuXHRcdFx0XHRlbnZNYXBUeXBlRGVmaW5lID0gJ0VOVk1BUF9UWVBFX0NVQkUnO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgQ3ViZVVWUmVmbGVjdGlvbk1hcHBpbmc6XG5cdFx0XHRcdGVudk1hcFR5cGVEZWZpbmUgPSAnRU5WTUFQX1RZUEVfQ1VCRV9VVic7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZW52TWFwVHlwZURlZmluZTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlRW52TWFwTW9kZURlZmluZShwYXJhbWV0ZXJzKSB7XG5cdGxldCBlbnZNYXBNb2RlRGVmaW5lID0gJ0VOVk1BUF9NT0RFX1JFRkxFQ1RJT04nO1xuXHRpZiAocGFyYW1ldGVycy5lbnZNYXApIHtcblx0XHRzd2l0Y2ggKHBhcmFtZXRlcnMuZW52TWFwTW9kZSkge1xuXHRcdFx0Y2FzZSBDdWJlUmVmcmFjdGlvbk1hcHBpbmc6XG5cdFx0XHRcdGVudk1hcE1vZGVEZWZpbmUgPSAnRU5WTUFQX01PREVfUkVGUkFDVElPTic7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZW52TWFwTW9kZURlZmluZTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlRW52TWFwQmxlbmRpbmdEZWZpbmUocGFyYW1ldGVycykge1xuXHRsZXQgZW52TWFwQmxlbmRpbmdEZWZpbmUgPSAnRU5WTUFQX0JMRU5ESU5HX05PTkUnO1xuXHRpZiAocGFyYW1ldGVycy5lbnZNYXApIHtcblx0XHRzd2l0Y2ggKHBhcmFtZXRlcnMuY29tYmluZSkge1xuXHRcdFx0Y2FzZSBNdWx0aXBseU9wZXJhdGlvbjpcblx0XHRcdFx0ZW52TWFwQmxlbmRpbmdEZWZpbmUgPSAnRU5WTUFQX0JMRU5ESU5HX01VTFRJUExZJztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIE1peE9wZXJhdGlvbjpcblx0XHRcdFx0ZW52TWFwQmxlbmRpbmdEZWZpbmUgPSAnRU5WTUFQX0JMRU5ESU5HX01JWCc7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBBZGRPcGVyYXRpb246XG5cdFx0XHRcdGVudk1hcEJsZW5kaW5nRGVmaW5lID0gJ0VOVk1BUF9CTEVORElOR19BREQnO1xuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblx0cmV0dXJuIGVudk1hcEJsZW5kaW5nRGVmaW5lO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVDdWJlVVZTaXplKHBhcmFtZXRlcnMpIHtcblx0Y29uc3QgaW1hZ2VIZWlnaHQgPSBwYXJhbWV0ZXJzLmVudk1hcEN1YmVVVkhlaWdodDtcblx0aWYgKGltYWdlSGVpZ2h0ID09PSBudWxsKSByZXR1cm4gbnVsbDtcblx0Y29uc3QgbWF4TWlwID0gTWF0aC5sb2cyKGltYWdlSGVpZ2h0KSAtIDI7XG5cdGNvbnN0IHRleGVsSGVpZ2h0ID0gMS4wIC8gaW1hZ2VIZWlnaHQ7XG5cdGNvbnN0IHRleGVsV2lkdGggPSAxLjAgLyAoMyAqIE1hdGgubWF4KE1hdGgucG93KDIsIG1heE1pcCksIDcgKiAxNikpO1xuXHRyZXR1cm4ge1xuXHRcdHRleGVsV2lkdGgsXG5cdFx0dGV4ZWxIZWlnaHQsXG5cdFx0bWF4TWlwXG5cdH07XG59XG5mdW5jdGlvbiBXZWJHTFByb2dyYW0ocmVuZGVyZXIsIGNhY2hlS2V5LCBwYXJhbWV0ZXJzLCBiaW5kaW5nU3RhdGVzKSB7XG5cdC8vIFRPRE8gU2VuZCB0aGlzIGV2ZW50IHRvIFRocmVlLmpzIERldlRvb2xzXG5cdC8vIGNvbnNvbGUubG9nKCAnV2ViR0xQcm9ncmFtJywgY2FjaGVLZXkgKTtcblxuXHRjb25zdCBnbCA9IHJlbmRlcmVyLmdldENvbnRleHQoKTtcblx0Y29uc3QgZGVmaW5lcyA9IHBhcmFtZXRlcnMuZGVmaW5lcztcblx0bGV0IHZlcnRleFNoYWRlciA9IHBhcmFtZXRlcnMudmVydGV4U2hhZGVyO1xuXHRsZXQgZnJhZ21lbnRTaGFkZXIgPSBwYXJhbWV0ZXJzLmZyYWdtZW50U2hhZGVyO1xuXHRjb25zdCBzaGFkb3dNYXBUeXBlRGVmaW5lID0gZ2VuZXJhdGVTaGFkb3dNYXBUeXBlRGVmaW5lKHBhcmFtZXRlcnMpO1xuXHRjb25zdCBlbnZNYXBUeXBlRGVmaW5lID0gZ2VuZXJhdGVFbnZNYXBUeXBlRGVmaW5lKHBhcmFtZXRlcnMpO1xuXHRjb25zdCBlbnZNYXBNb2RlRGVmaW5lID0gZ2VuZXJhdGVFbnZNYXBNb2RlRGVmaW5lKHBhcmFtZXRlcnMpO1xuXHRjb25zdCBlbnZNYXBCbGVuZGluZ0RlZmluZSA9IGdlbmVyYXRlRW52TWFwQmxlbmRpbmdEZWZpbmUocGFyYW1ldGVycyk7XG5cdGNvbnN0IGVudk1hcEN1YmVVVlNpemUgPSBnZW5lcmF0ZUN1YmVVVlNpemUocGFyYW1ldGVycyk7XG5cdGNvbnN0IGN1c3RvbUV4dGVuc2lvbnMgPSBwYXJhbWV0ZXJzLmlzV2ViR0wyID8gJycgOiBnZW5lcmF0ZUV4dGVuc2lvbnMocGFyYW1ldGVycyk7XG5cdGNvbnN0IGN1c3RvbURlZmluZXMgPSBnZW5lcmF0ZURlZmluZXMoZGVmaW5lcyk7XG5cdGNvbnN0IHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG5cdGxldCBwcmVmaXhWZXJ0ZXgsIHByZWZpeEZyYWdtZW50O1xuXHRsZXQgdmVyc2lvblN0cmluZyA9IHBhcmFtZXRlcnMuZ2xzbFZlcnNpb24gPyAnI3ZlcnNpb24gJyArIHBhcmFtZXRlcnMuZ2xzbFZlcnNpb24gKyAnXFxuJyA6ICcnO1xuXHRpZiAocGFyYW1ldGVycy5pc1Jhd1NoYWRlck1hdGVyaWFsKSB7XG5cdFx0cHJlZml4VmVydGV4ID0gW2N1c3RvbURlZmluZXNdLmZpbHRlcihmaWx0ZXJFbXB0eUxpbmUpLmpvaW4oJ1xcbicpO1xuXHRcdGlmIChwcmVmaXhWZXJ0ZXgubGVuZ3RoID4gMCkge1xuXHRcdFx0cHJlZml4VmVydGV4ICs9ICdcXG4nO1xuXHRcdH1cblx0XHRwcmVmaXhGcmFnbWVudCA9IFtjdXN0b21FeHRlbnNpb25zLCBjdXN0b21EZWZpbmVzXS5maWx0ZXIoZmlsdGVyRW1wdHlMaW5lKS5qb2luKCdcXG4nKTtcblx0XHRpZiAocHJlZml4RnJhZ21lbnQubGVuZ3RoID4gMCkge1xuXHRcdFx0cHJlZml4RnJhZ21lbnQgKz0gJ1xcbic7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHByZWZpeFZlcnRleCA9IFtnZW5lcmF0ZVByZWNpc2lvbihwYXJhbWV0ZXJzKSwgJyNkZWZpbmUgU0hBREVSX05BTUUgJyArIHBhcmFtZXRlcnMuc2hhZGVyTmFtZSwgY3VzdG9tRGVmaW5lcywgcGFyYW1ldGVycy5pbnN0YW5jaW5nID8gJyNkZWZpbmUgVVNFX0lOU1RBTkNJTkcnIDogJycsIHBhcmFtZXRlcnMuaW5zdGFuY2luZ0NvbG9yID8gJyNkZWZpbmUgVVNFX0lOU1RBTkNJTkdfQ09MT1InIDogJycsIHBhcmFtZXRlcnMuc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcyA/ICcjZGVmaW5lIFZFUlRFWF9URVhUVVJFUycgOiAnJywgcGFyYW1ldGVycy51c2VGb2cgJiYgcGFyYW1ldGVycy5mb2cgPyAnI2RlZmluZSBVU0VfRk9HJyA6ICcnLCBwYXJhbWV0ZXJzLnVzZUZvZyAmJiBwYXJhbWV0ZXJzLmZvZ0V4cDIgPyAnI2RlZmluZSBGT0dfRVhQMicgOiAnJywgcGFyYW1ldGVycy5tYXAgPyAnI2RlZmluZSBVU0VfTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lIFVTRV9FTlZNQVAnIDogJycsIHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgJyArIGVudk1hcE1vZGVEZWZpbmUgOiAnJywgcGFyYW1ldGVycy5saWdodE1hcCA/ICcjZGVmaW5lIFVTRV9MSUdIVE1BUCcgOiAnJywgcGFyYW1ldGVycy5hb01hcCA/ICcjZGVmaW5lIFVTRV9BT01BUCcgOiAnJywgcGFyYW1ldGVycy5lbWlzc2l2ZU1hcCA/ICcjZGVmaW5lIFVTRV9FTUlTU0lWRU1BUCcgOiAnJywgcGFyYW1ldGVycy5idW1wTWFwID8gJyNkZWZpbmUgVVNFX0JVTVBNQVAnIDogJycsIHBhcmFtZXRlcnMubm9ybWFsTWFwID8gJyNkZWZpbmUgVVNFX05PUk1BTE1BUCcgOiAnJywgcGFyYW1ldGVycy5ub3JtYWxNYXAgJiYgcGFyYW1ldGVycy5vYmplY3RTcGFjZU5vcm1hbE1hcCA/ICcjZGVmaW5lIE9CSkVDVFNQQUNFX05PUk1BTE1BUCcgOiAnJywgcGFyYW1ldGVycy5ub3JtYWxNYXAgJiYgcGFyYW1ldGVycy50YW5nZW50U3BhY2VOb3JtYWxNYXAgPyAnI2RlZmluZSBUQU5HRU5UU1BBQ0VfTk9STUFMTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLmNsZWFyY29hdE1hcCA/ICcjZGVmaW5lIFVTRV9DTEVBUkNPQVRNQVAnIDogJycsIHBhcmFtZXRlcnMuY2xlYXJjb2F0Um91Z2huZXNzTWFwID8gJyNkZWZpbmUgVVNFX0NMRUFSQ09BVF9ST1VHSE5FU1NNQVAnIDogJycsIHBhcmFtZXRlcnMuY2xlYXJjb2F0Tm9ybWFsTWFwID8gJyNkZWZpbmUgVVNFX0NMRUFSQ09BVF9OT1JNQUxNQVAnIDogJycsIHBhcmFtZXRlcnMuaXJpZGVzY2VuY2VNYXAgPyAnI2RlZmluZSBVU0VfSVJJREVTQ0VOQ0VNQVAnIDogJycsIHBhcmFtZXRlcnMuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAgPyAnI2RlZmluZSBVU0VfSVJJREVTQ0VOQ0VfVEhJQ0tORVNTTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLmRpc3BsYWNlbWVudE1hcCAmJiBwYXJhbWV0ZXJzLnN1cHBvcnRzVmVydGV4VGV4dHVyZXMgPyAnI2RlZmluZSBVU0VfRElTUExBQ0VNRU5UTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLnNwZWN1bGFyTWFwID8gJyNkZWZpbmUgVVNFX1NQRUNVTEFSTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLnNwZWN1bGFySW50ZW5zaXR5TWFwID8gJyNkZWZpbmUgVVNFX1NQRUNVTEFSSU5URU5TSVRZTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLnNwZWN1bGFyQ29sb3JNYXAgPyAnI2RlZmluZSBVU0VfU1BFQ1VMQVJDT0xPUk1BUCcgOiAnJywgcGFyYW1ldGVycy5yb3VnaG5lc3NNYXAgPyAnI2RlZmluZSBVU0VfUk9VR0hORVNTTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLm1ldGFsbmVzc01hcCA/ICcjZGVmaW5lIFVTRV9NRVRBTE5FU1NNQVAnIDogJycsIHBhcmFtZXRlcnMuYWxwaGFNYXAgPyAnI2RlZmluZSBVU0VfQUxQSEFNQVAnIDogJycsIHBhcmFtZXRlcnMudHJhbnNtaXNzaW9uID8gJyNkZWZpbmUgVVNFX1RSQU5TTUlTU0lPTicgOiAnJywgcGFyYW1ldGVycy50cmFuc21pc3Npb25NYXAgPyAnI2RlZmluZSBVU0VfVFJBTlNNSVNTSU9OTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLnRoaWNrbmVzc01hcCA/ICcjZGVmaW5lIFVTRV9USElDS05FU1NNQVAnIDogJycsIHBhcmFtZXRlcnMuc2hlZW5Db2xvck1hcCA/ICcjZGVmaW5lIFVTRV9TSEVFTkNPTE9STUFQJyA6ICcnLCBwYXJhbWV0ZXJzLnNoZWVuUm91Z2huZXNzTWFwID8gJyNkZWZpbmUgVVNFX1NIRUVOUk9VR0hORVNTTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLnZlcnRleFRhbmdlbnRzID8gJyNkZWZpbmUgVVNFX1RBTkdFTlQnIDogJycsIHBhcmFtZXRlcnMudmVydGV4Q29sb3JzID8gJyNkZWZpbmUgVVNFX0NPTE9SJyA6ICcnLCBwYXJhbWV0ZXJzLnZlcnRleEFscGhhcyA/ICcjZGVmaW5lIFVTRV9DT0xPUl9BTFBIQScgOiAnJywgcGFyYW1ldGVycy52ZXJ0ZXhVdnMgPyAnI2RlZmluZSBVU0VfVVYnIDogJycsIHBhcmFtZXRlcnMudXZzVmVydGV4T25seSA/ICcjZGVmaW5lIFVWU19WRVJURVhfT05MWScgOiAnJywgcGFyYW1ldGVycy5mbGF0U2hhZGluZyA/ICcjZGVmaW5lIEZMQVRfU0hBREVEJyA6ICcnLCBwYXJhbWV0ZXJzLnNraW5uaW5nID8gJyNkZWZpbmUgVVNFX1NLSU5OSU5HJyA6ICcnLCBwYXJhbWV0ZXJzLm1vcnBoVGFyZ2V0cyA/ICcjZGVmaW5lIFVTRV9NT1JQSFRBUkdFVFMnIDogJycsIHBhcmFtZXRlcnMubW9ycGhOb3JtYWxzICYmIHBhcmFtZXRlcnMuZmxhdFNoYWRpbmcgPT09IGZhbHNlID8gJyNkZWZpbmUgVVNFX01PUlBITk9STUFMUycgOiAnJywgcGFyYW1ldGVycy5tb3JwaENvbG9ycyAmJiBwYXJhbWV0ZXJzLmlzV2ViR0wyID8gJyNkZWZpbmUgVVNFX01PUlBIQ09MT1JTJyA6ICcnLCBwYXJhbWV0ZXJzLm1vcnBoVGFyZ2V0c0NvdW50ID4gMCAmJiBwYXJhbWV0ZXJzLmlzV2ViR0wyID8gJyNkZWZpbmUgTU9SUEhUQVJHRVRTX1RFWFRVUkUnIDogJycsIHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzQ291bnQgPiAwICYmIHBhcmFtZXRlcnMuaXNXZWJHTDIgPyAnI2RlZmluZSBNT1JQSFRBUkdFVFNfVEVYVFVSRV9TVFJJREUgJyArIHBhcmFtZXRlcnMubW9ycGhUZXh0dXJlU3RyaWRlIDogJycsIHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzQ291bnQgPiAwICYmIHBhcmFtZXRlcnMuaXNXZWJHTDIgPyAnI2RlZmluZSBNT1JQSFRBUkdFVFNfQ09VTlQgJyArIHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzQ291bnQgOiAnJywgcGFyYW1ldGVycy5kb3VibGVTaWRlZCA/ICcjZGVmaW5lIERPVUJMRV9TSURFRCcgOiAnJywgcGFyYW1ldGVycy5mbGlwU2lkZWQgPyAnI2RlZmluZSBGTElQX1NJREVEJyA6ICcnLCBwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyAnI2RlZmluZSBVU0VfU0hBRE9XTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyAnI2RlZmluZSAnICsgc2hhZG93TWFwVHlwZURlZmluZSA6ICcnLCBwYXJhbWV0ZXJzLnNpemVBdHRlbnVhdGlvbiA/ICcjZGVmaW5lIFVTRV9TSVpFQVRURU5VQVRJT04nIDogJycsIHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciA/ICcjZGVmaW5lIFVTRV9MT0dERVBUSEJVRicgOiAnJywgcGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyICYmIHBhcmFtZXRlcnMucmVuZGVyZXJFeHRlbnNpb25GcmFnRGVwdGggPyAnI2RlZmluZSBVU0VfTE9HREVQVEhCVUZfRVhUJyA6ICcnLCAndW5pZm9ybSBtYXQ0IG1vZGVsTWF0cml4OycsICd1bmlmb3JtIG1hdDQgbW9kZWxWaWV3TWF0cml4OycsICd1bmlmb3JtIG1hdDQgcHJvamVjdGlvbk1hdHJpeDsnLCAndW5pZm9ybSBtYXQ0IHZpZXdNYXRyaXg7JywgJ3VuaWZvcm0gbWF0MyBub3JtYWxNYXRyaXg7JywgJ3VuaWZvcm0gdmVjMyBjYW1lcmFQb3NpdGlvbjsnLCAndW5pZm9ybSBib29sIGlzT3J0aG9ncmFwaGljOycsICcjaWZkZWYgVVNFX0lOU1RBTkNJTkcnLCAnXHRhdHRyaWJ1dGUgbWF0NCBpbnN0YW5jZU1hdHJpeDsnLCAnI2VuZGlmJywgJyNpZmRlZiBVU0VfSU5TVEFOQ0lOR19DT0xPUicsICdcdGF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlQ29sb3I7JywgJyNlbmRpZicsICdhdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjsnLCAnYXR0cmlidXRlIHZlYzMgbm9ybWFsOycsICdhdHRyaWJ1dGUgdmVjMiB1djsnLCAnI2lmZGVmIFVTRV9UQU5HRU5UJywgJ1x0YXR0cmlidXRlIHZlYzQgdGFuZ2VudDsnLCAnI2VuZGlmJywgJyNpZiBkZWZpbmVkKCBVU0VfQ09MT1JfQUxQSEEgKScsICdcdGF0dHJpYnV0ZSB2ZWM0IGNvbG9yOycsICcjZWxpZiBkZWZpbmVkKCBVU0VfQ09MT1IgKScsICdcdGF0dHJpYnV0ZSB2ZWMzIGNvbG9yOycsICcjZW5kaWYnLCAnI2lmICggZGVmaW5lZCggVVNFX01PUlBIVEFSR0VUUyApICYmICEgZGVmaW5lZCggTU9SUEhUQVJHRVRTX1RFWFRVUkUgKSApJywgJ1x0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQwOycsICdcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MTsnLCAnXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDI7JywgJ1x0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQzOycsICdcdCNpZmRlZiBVU0VfTU9SUEhOT1JNQUxTJywgJ1x0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDA7JywgJ1x0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDE7JywgJ1x0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDI7JywgJ1x0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDM7JywgJ1x0I2Vsc2UnLCAnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0NDsnLCAnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0NTsnLCAnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0NjsnLCAnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0NzsnLCAnXHQjZW5kaWYnLCAnI2VuZGlmJywgJyNpZmRlZiBVU0VfU0tJTk5JTkcnLCAnXHRhdHRyaWJ1dGUgdmVjNCBza2luSW5kZXg7JywgJ1x0YXR0cmlidXRlIHZlYzQgc2tpbldlaWdodDsnLCAnI2VuZGlmJywgJ1xcbiddLmZpbHRlcihmaWx0ZXJFbXB0eUxpbmUpLmpvaW4oJ1xcbicpO1xuXHRcdHByZWZpeEZyYWdtZW50ID0gW2N1c3RvbUV4dGVuc2lvbnMsIGdlbmVyYXRlUHJlY2lzaW9uKHBhcmFtZXRlcnMpLCAnI2RlZmluZSBTSEFERVJfTkFNRSAnICsgcGFyYW1ldGVycy5zaGFkZXJOYW1lLCBjdXN0b21EZWZpbmVzLCBwYXJhbWV0ZXJzLnVzZUZvZyAmJiBwYXJhbWV0ZXJzLmZvZyA/ICcjZGVmaW5lIFVTRV9GT0cnIDogJycsIHBhcmFtZXRlcnMudXNlRm9nICYmIHBhcmFtZXRlcnMuZm9nRXhwMiA/ICcjZGVmaW5lIEZPR19FWFAyJyA6ICcnLCBwYXJhbWV0ZXJzLm1hcCA/ICcjZGVmaW5lIFVTRV9NQVAnIDogJycsIHBhcmFtZXRlcnMubWF0Y2FwID8gJyNkZWZpbmUgVVNFX01BVENBUCcgOiAnJywgcGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSBVU0VfRU5WTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lICcgKyBlbnZNYXBUeXBlRGVmaW5lIDogJycsIHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgJyArIGVudk1hcE1vZGVEZWZpbmUgOiAnJywgcGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSAnICsgZW52TWFwQmxlbmRpbmdEZWZpbmUgOiAnJywgZW52TWFwQ3ViZVVWU2l6ZSA/ICcjZGVmaW5lIENVQkVVVl9URVhFTF9XSURUSCAnICsgZW52TWFwQ3ViZVVWU2l6ZS50ZXhlbFdpZHRoIDogJycsIGVudk1hcEN1YmVVVlNpemUgPyAnI2RlZmluZSBDVUJFVVZfVEVYRUxfSEVJR0hUICcgKyBlbnZNYXBDdWJlVVZTaXplLnRleGVsSGVpZ2h0IDogJycsIGVudk1hcEN1YmVVVlNpemUgPyAnI2RlZmluZSBDVUJFVVZfTUFYX01JUCAnICsgZW52TWFwQ3ViZVVWU2l6ZS5tYXhNaXAgKyAnLjAnIDogJycsIHBhcmFtZXRlcnMubGlnaHRNYXAgPyAnI2RlZmluZSBVU0VfTElHSFRNQVAnIDogJycsIHBhcmFtZXRlcnMuYW9NYXAgPyAnI2RlZmluZSBVU0VfQU9NQVAnIDogJycsIHBhcmFtZXRlcnMuZW1pc3NpdmVNYXAgPyAnI2RlZmluZSBVU0VfRU1JU1NJVkVNQVAnIDogJycsIHBhcmFtZXRlcnMuYnVtcE1hcCA/ICcjZGVmaW5lIFVTRV9CVU1QTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLm5vcm1hbE1hcCA/ICcjZGVmaW5lIFVTRV9OT1JNQUxNQVAnIDogJycsIHBhcmFtZXRlcnMubm9ybWFsTWFwICYmIHBhcmFtZXRlcnMub2JqZWN0U3BhY2VOb3JtYWxNYXAgPyAnI2RlZmluZSBPQkpFQ1RTUEFDRV9OT1JNQUxNQVAnIDogJycsIHBhcmFtZXRlcnMubm9ybWFsTWFwICYmIHBhcmFtZXRlcnMudGFuZ2VudFNwYWNlTm9ybWFsTWFwID8gJyNkZWZpbmUgVEFOR0VOVFNQQUNFX05PUk1BTE1BUCcgOiAnJywgcGFyYW1ldGVycy5jbGVhcmNvYXQgPyAnI2RlZmluZSBVU0VfQ0xFQVJDT0FUJyA6ICcnLCBwYXJhbWV0ZXJzLmNsZWFyY29hdE1hcCA/ICcjZGVmaW5lIFVTRV9DTEVBUkNPQVRNQVAnIDogJycsIHBhcmFtZXRlcnMuY2xlYXJjb2F0Um91Z2huZXNzTWFwID8gJyNkZWZpbmUgVVNFX0NMRUFSQ09BVF9ST1VHSE5FU1NNQVAnIDogJycsIHBhcmFtZXRlcnMuY2xlYXJjb2F0Tm9ybWFsTWFwID8gJyNkZWZpbmUgVVNFX0NMRUFSQ09BVF9OT1JNQUxNQVAnIDogJycsIHBhcmFtZXRlcnMuaXJpZGVzY2VuY2UgPyAnI2RlZmluZSBVU0VfSVJJREVTQ0VOQ0UnIDogJycsIHBhcmFtZXRlcnMuaXJpZGVzY2VuY2VNYXAgPyAnI2RlZmluZSBVU0VfSVJJREVTQ0VOQ0VNQVAnIDogJycsIHBhcmFtZXRlcnMuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAgPyAnI2RlZmluZSBVU0VfSVJJREVTQ0VOQ0VfVEhJQ0tORVNTTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLnNwZWN1bGFyTWFwID8gJyNkZWZpbmUgVVNFX1NQRUNVTEFSTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLnNwZWN1bGFySW50ZW5zaXR5TWFwID8gJyNkZWZpbmUgVVNFX1NQRUNVTEFSSU5URU5TSVRZTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLnNwZWN1bGFyQ29sb3JNYXAgPyAnI2RlZmluZSBVU0VfU1BFQ1VMQVJDT0xPUk1BUCcgOiAnJywgcGFyYW1ldGVycy5yb3VnaG5lc3NNYXAgPyAnI2RlZmluZSBVU0VfUk9VR0hORVNTTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLm1ldGFsbmVzc01hcCA/ICcjZGVmaW5lIFVTRV9NRVRBTE5FU1NNQVAnIDogJycsIHBhcmFtZXRlcnMuYWxwaGFNYXAgPyAnI2RlZmluZSBVU0VfQUxQSEFNQVAnIDogJycsIHBhcmFtZXRlcnMuYWxwaGFUZXN0ID8gJyNkZWZpbmUgVVNFX0FMUEhBVEVTVCcgOiAnJywgcGFyYW1ldGVycy5zaGVlbiA/ICcjZGVmaW5lIFVTRV9TSEVFTicgOiAnJywgcGFyYW1ldGVycy5zaGVlbkNvbG9yTWFwID8gJyNkZWZpbmUgVVNFX1NIRUVOQ09MT1JNQVAnIDogJycsIHBhcmFtZXRlcnMuc2hlZW5Sb3VnaG5lc3NNYXAgPyAnI2RlZmluZSBVU0VfU0hFRU5ST1VHSE5FU1NNQVAnIDogJycsIHBhcmFtZXRlcnMudHJhbnNtaXNzaW9uID8gJyNkZWZpbmUgVVNFX1RSQU5TTUlTU0lPTicgOiAnJywgcGFyYW1ldGVycy50cmFuc21pc3Npb25NYXAgPyAnI2RlZmluZSBVU0VfVFJBTlNNSVNTSU9OTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLnRoaWNrbmVzc01hcCA/ICcjZGVmaW5lIFVTRV9USElDS05FU1NNQVAnIDogJycsIHBhcmFtZXRlcnMuZGVjb2RlVmlkZW9UZXh0dXJlID8gJyNkZWZpbmUgREVDT0RFX1ZJREVPX1RFWFRVUkUnIDogJycsIHBhcmFtZXRlcnMudmVydGV4VGFuZ2VudHMgPyAnI2RlZmluZSBVU0VfVEFOR0VOVCcgOiAnJywgcGFyYW1ldGVycy52ZXJ0ZXhDb2xvcnMgfHwgcGFyYW1ldGVycy5pbnN0YW5jaW5nQ29sb3IgPyAnI2RlZmluZSBVU0VfQ09MT1InIDogJycsIHBhcmFtZXRlcnMudmVydGV4QWxwaGFzID8gJyNkZWZpbmUgVVNFX0NPTE9SX0FMUEhBJyA6ICcnLCBwYXJhbWV0ZXJzLnZlcnRleFV2cyA/ICcjZGVmaW5lIFVTRV9VVicgOiAnJywgcGFyYW1ldGVycy51dnNWZXJ0ZXhPbmx5ID8gJyNkZWZpbmUgVVZTX1ZFUlRFWF9PTkxZJyA6ICcnLCBwYXJhbWV0ZXJzLmdyYWRpZW50TWFwID8gJyNkZWZpbmUgVVNFX0dSQURJRU5UTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLmZsYXRTaGFkaW5nID8gJyNkZWZpbmUgRkxBVF9TSEFERUQnIDogJycsIHBhcmFtZXRlcnMuZG91YmxlU2lkZWQgPyAnI2RlZmluZSBET1VCTEVfU0lERUQnIDogJycsIHBhcmFtZXRlcnMuZmxpcFNpZGVkID8gJyNkZWZpbmUgRkxJUF9TSURFRCcgOiAnJywgcGFyYW1ldGVycy5zaGFkb3dNYXBFbmFibGVkID8gJyNkZWZpbmUgVVNFX1NIQURPV01BUCcgOiAnJywgcGFyYW1ldGVycy5zaGFkb3dNYXBFbmFibGVkID8gJyNkZWZpbmUgJyArIHNoYWRvd01hcFR5cGVEZWZpbmUgOiAnJywgcGFyYW1ldGVycy5wcmVtdWx0aXBsaWVkQWxwaGEgPyAnI2RlZmluZSBQUkVNVUxUSVBMSUVEX0FMUEhBJyA6ICcnLCBwYXJhbWV0ZXJzLnBoeXNpY2FsbHlDb3JyZWN0TGlnaHRzID8gJyNkZWZpbmUgUEhZU0lDQUxMWV9DT1JSRUNUX0xJR0hUUycgOiAnJywgcGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyID8gJyNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGJyA6ICcnLCBwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgJiYgcGFyYW1ldGVycy5yZW5kZXJlckV4dGVuc2lvbkZyYWdEZXB0aCA/ICcjZGVmaW5lIFVTRV9MT0dERVBUSEJVRl9FWFQnIDogJycsICd1bmlmb3JtIG1hdDQgdmlld01hdHJpeDsnLCAndW5pZm9ybSB2ZWMzIGNhbWVyYVBvc2l0aW9uOycsICd1bmlmb3JtIGJvb2wgaXNPcnRob2dyYXBoaWM7JywgcGFyYW1ldGVycy50b25lTWFwcGluZyAhPT0gTm9Ub25lTWFwcGluZyA/ICcjZGVmaW5lIFRPTkVfTUFQUElORycgOiAnJywgcGFyYW1ldGVycy50b25lTWFwcGluZyAhPT0gTm9Ub25lTWFwcGluZyA/IFNoYWRlckNodW5rWyd0b25lbWFwcGluZ19wYXJzX2ZyYWdtZW50J10gOiAnJyxcblx0XHQvLyB0aGlzIGNvZGUgaXMgcmVxdWlyZWQgaGVyZSBiZWNhdXNlIGl0IGlzIHVzZWQgYnkgdGhlIHRvbmVNYXBwaW5nKCkgZnVuY3Rpb24gZGVmaW5lZCBiZWxvd1xuXHRcdHBhcmFtZXRlcnMudG9uZU1hcHBpbmcgIT09IE5vVG9uZU1hcHBpbmcgPyBnZXRUb25lTWFwcGluZ0Z1bmN0aW9uKCd0b25lTWFwcGluZycsIHBhcmFtZXRlcnMudG9uZU1hcHBpbmcpIDogJycsIHBhcmFtZXRlcnMuZGl0aGVyaW5nID8gJyNkZWZpbmUgRElUSEVSSU5HJyA6ICcnLCBwYXJhbWV0ZXJzLm9wYXF1ZSA/ICcjZGVmaW5lIE9QQVFVRScgOiAnJywgU2hhZGVyQ2h1bmtbJ2VuY29kaW5nc19wYXJzX2ZyYWdtZW50J10sXG5cdFx0Ly8gdGhpcyBjb2RlIGlzIHJlcXVpcmVkIGhlcmUgYmVjYXVzZSBpdCBpcyB1c2VkIGJ5IHRoZSB2YXJpb3VzIGVuY29kaW5nL2RlY29kaW5nIGZ1bmN0aW9uIGRlZmluZWQgYmVsb3dcblx0XHRnZXRUZXhlbEVuY29kaW5nRnVuY3Rpb24oJ2xpbmVhclRvT3V0cHV0VGV4ZWwnLCBwYXJhbWV0ZXJzLm91dHB1dEVuY29kaW5nKSwgcGFyYW1ldGVycy51c2VEZXB0aFBhY2tpbmcgPyAnI2RlZmluZSBERVBUSF9QQUNLSU5HICcgKyBwYXJhbWV0ZXJzLmRlcHRoUGFja2luZyA6ICcnLCAnXFxuJ10uZmlsdGVyKGZpbHRlckVtcHR5TGluZSkuam9pbignXFxuJyk7XG5cdH1cblx0dmVydGV4U2hhZGVyID0gcmVzb2x2ZUluY2x1ZGVzKHZlcnRleFNoYWRlcik7XG5cdHZlcnRleFNoYWRlciA9IHJlcGxhY2VMaWdodE51bXModmVydGV4U2hhZGVyLCBwYXJhbWV0ZXJzKTtcblx0dmVydGV4U2hhZGVyID0gcmVwbGFjZUNsaXBwaW5nUGxhbmVOdW1zKHZlcnRleFNoYWRlciwgcGFyYW1ldGVycyk7XG5cdGZyYWdtZW50U2hhZGVyID0gcmVzb2x2ZUluY2x1ZGVzKGZyYWdtZW50U2hhZGVyKTtcblx0ZnJhZ21lbnRTaGFkZXIgPSByZXBsYWNlTGlnaHROdW1zKGZyYWdtZW50U2hhZGVyLCBwYXJhbWV0ZXJzKTtcblx0ZnJhZ21lbnRTaGFkZXIgPSByZXBsYWNlQ2xpcHBpbmdQbGFuZU51bXMoZnJhZ21lbnRTaGFkZXIsIHBhcmFtZXRlcnMpO1xuXHR2ZXJ0ZXhTaGFkZXIgPSB1bnJvbGxMb29wcyh2ZXJ0ZXhTaGFkZXIpO1xuXHRmcmFnbWVudFNoYWRlciA9IHVucm9sbExvb3BzKGZyYWdtZW50U2hhZGVyKTtcblx0aWYgKHBhcmFtZXRlcnMuaXNXZWJHTDIgJiYgcGFyYW1ldGVycy5pc1Jhd1NoYWRlck1hdGVyaWFsICE9PSB0cnVlKSB7XG5cdFx0Ly8gR0xTTCAzLjAgY29udmVyc2lvbiBmb3IgYnVpbHQtaW4gbWF0ZXJpYWxzIGFuZCBTaGFkZXJNYXRlcmlhbFxuXG5cdFx0dmVyc2lvblN0cmluZyA9ICcjdmVyc2lvbiAzMDAgZXNcXG4nO1xuXHRcdHByZWZpeFZlcnRleCA9IFsncHJlY2lzaW9uIG1lZGl1bXAgc2FtcGxlcjJEQXJyYXk7JywgJyNkZWZpbmUgYXR0cmlidXRlIGluJywgJyNkZWZpbmUgdmFyeWluZyBvdXQnLCAnI2RlZmluZSB0ZXh0dXJlMkQgdGV4dHVyZSddLmpvaW4oJ1xcbicpICsgJ1xcbicgKyBwcmVmaXhWZXJ0ZXg7XG5cdFx0cHJlZml4RnJhZ21lbnQgPSBbJyNkZWZpbmUgdmFyeWluZyBpbicsIHBhcmFtZXRlcnMuZ2xzbFZlcnNpb24gPT09IEdMU0wzID8gJycgOiAnbGF5b3V0KGxvY2F0aW9uID0gMCkgb3V0IGhpZ2hwIHZlYzQgcGNfZnJhZ0NvbG9yOycsIHBhcmFtZXRlcnMuZ2xzbFZlcnNpb24gPT09IEdMU0wzID8gJycgOiAnI2RlZmluZSBnbF9GcmFnQ29sb3IgcGNfZnJhZ0NvbG9yJywgJyNkZWZpbmUgZ2xfRnJhZ0RlcHRoRVhUIGdsX0ZyYWdEZXB0aCcsICcjZGVmaW5lIHRleHR1cmUyRCB0ZXh0dXJlJywgJyNkZWZpbmUgdGV4dHVyZUN1YmUgdGV4dHVyZScsICcjZGVmaW5lIHRleHR1cmUyRFByb2ogdGV4dHVyZVByb2onLCAnI2RlZmluZSB0ZXh0dXJlMkRMb2RFWFQgdGV4dHVyZUxvZCcsICcjZGVmaW5lIHRleHR1cmUyRFByb2pMb2RFWFQgdGV4dHVyZVByb2pMb2QnLCAnI2RlZmluZSB0ZXh0dXJlQ3ViZUxvZEVYVCB0ZXh0dXJlTG9kJywgJyNkZWZpbmUgdGV4dHVyZTJER3JhZEVYVCB0ZXh0dXJlR3JhZCcsICcjZGVmaW5lIHRleHR1cmUyRFByb2pHcmFkRVhUIHRleHR1cmVQcm9qR3JhZCcsICcjZGVmaW5lIHRleHR1cmVDdWJlR3JhZEVYVCB0ZXh0dXJlR3JhZCddLmpvaW4oJ1xcbicpICsgJ1xcbicgKyBwcmVmaXhGcmFnbWVudDtcblx0fVxuXHRjb25zdCB2ZXJ0ZXhHbHNsID0gdmVyc2lvblN0cmluZyArIHByZWZpeFZlcnRleCArIHZlcnRleFNoYWRlcjtcblx0Y29uc3QgZnJhZ21lbnRHbHNsID0gdmVyc2lvblN0cmluZyArIHByZWZpeEZyYWdtZW50ICsgZnJhZ21lbnRTaGFkZXI7XG5cblx0Ly8gY29uc29sZS5sb2coICcqVkVSVEVYKicsIHZlcnRleEdsc2wgKTtcblx0Ly8gY29uc29sZS5sb2coICcqRlJBR01FTlQqJywgZnJhZ21lbnRHbHNsICk7XG5cblx0Y29uc3QgZ2xWZXJ0ZXhTaGFkZXIgPSBXZWJHTFNoYWRlcihnbCwgZ2wuVkVSVEVYX1NIQURFUiwgdmVydGV4R2xzbCk7XG5cdGNvbnN0IGdsRnJhZ21lbnRTaGFkZXIgPSBXZWJHTFNoYWRlcihnbCwgZ2wuRlJBR01FTlRfU0hBREVSLCBmcmFnbWVudEdsc2wpO1xuXHRnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZ2xWZXJ0ZXhTaGFkZXIpO1xuXHRnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZ2xGcmFnbWVudFNoYWRlcik7XG5cblx0Ly8gRm9yY2UgYSBwYXJ0aWN1bGFyIGF0dHJpYnV0ZSB0byBpbmRleCAwLlxuXG5cdGlmIChwYXJhbWV0ZXJzLmluZGV4MEF0dHJpYnV0ZU5hbWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdGdsLmJpbmRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAwLCBwYXJhbWV0ZXJzLmluZGV4MEF0dHJpYnV0ZU5hbWUpO1xuXHR9IGVsc2UgaWYgKHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzID09PSB0cnVlKSB7XG5cdFx0Ly8gcHJvZ3JhbXMgd2l0aCBtb3JwaFRhcmdldHMgZGlzcGxhY2UgcG9zaXRpb24gb3V0IG9mIGF0dHJpYnV0ZSAwXG5cdFx0Z2wuYmluZEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIDAsICdwb3NpdGlvbicpO1xuXHR9XG5cdGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuXG5cdC8vIGNoZWNrIGZvciBsaW5rIGVycm9yc1xuXHRpZiAocmVuZGVyZXIuZGVidWcuY2hlY2tTaGFkZXJFcnJvcnMpIHtcblx0XHRjb25zdCBwcm9ncmFtTG9nID0gZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSkudHJpbSgpO1xuXHRcdGNvbnN0IHZlcnRleExvZyA9IGdsLmdldFNoYWRlckluZm9Mb2coZ2xWZXJ0ZXhTaGFkZXIpLnRyaW0oKTtcblx0XHRjb25zdCBmcmFnbWVudExvZyA9IGdsLmdldFNoYWRlckluZm9Mb2coZ2xGcmFnbWVudFNoYWRlcikudHJpbSgpO1xuXHRcdGxldCBydW5uYWJsZSA9IHRydWU7XG5cdFx0bGV0IGhhdmVEaWFnbm9zdGljcyA9IHRydWU7XG5cdFx0aWYgKGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpID09PSBmYWxzZSkge1xuXHRcdFx0cnVubmFibGUgPSBmYWxzZTtcblx0XHRcdGNvbnN0IHZlcnRleEVycm9ycyA9IGdldFNoYWRlckVycm9ycyhnbCwgZ2xWZXJ0ZXhTaGFkZXIsICd2ZXJ0ZXgnKTtcblx0XHRcdGNvbnN0IGZyYWdtZW50RXJyb3JzID0gZ2V0U2hhZGVyRXJyb3JzKGdsLCBnbEZyYWdtZW50U2hhZGVyLCAnZnJhZ21lbnQnKTtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLldlYkdMUHJvZ3JhbTogU2hhZGVyIEVycm9yICcgKyBnbC5nZXRFcnJvcigpICsgJyAtICcgKyAnVkFMSURBVEVfU1RBVFVTICcgKyBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLlZBTElEQVRFX1NUQVRVUykgKyAnXFxuXFxuJyArICdQcm9ncmFtIEluZm8gTG9nOiAnICsgcHJvZ3JhbUxvZyArICdcXG4nICsgdmVydGV4RXJyb3JzICsgJ1xcbicgKyBmcmFnbWVudEVycm9ycyk7XG5cdFx0fSBlbHNlIGlmIChwcm9ncmFtTG9nICE9PSAnJykge1xuXHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFByb2dyYW06IFByb2dyYW0gSW5mbyBMb2c6JywgcHJvZ3JhbUxvZyk7XG5cdFx0fSBlbHNlIGlmICh2ZXJ0ZXhMb2cgPT09ICcnIHx8IGZyYWdtZW50TG9nID09PSAnJykge1xuXHRcdFx0aGF2ZURpYWdub3N0aWNzID0gZmFsc2U7XG5cdFx0fVxuXHRcdGlmIChoYXZlRGlhZ25vc3RpY3MpIHtcblx0XHRcdHRoaXMuZGlhZ25vc3RpY3MgPSB7XG5cdFx0XHRcdHJ1bm5hYmxlOiBydW5uYWJsZSxcblx0XHRcdFx0cHJvZ3JhbUxvZzogcHJvZ3JhbUxvZyxcblx0XHRcdFx0dmVydGV4U2hhZGVyOiB7XG5cdFx0XHRcdFx0bG9nOiB2ZXJ0ZXhMb2csXG5cdFx0XHRcdFx0cHJlZml4OiBwcmVmaXhWZXJ0ZXhcblx0XHRcdFx0fSxcblx0XHRcdFx0ZnJhZ21lbnRTaGFkZXI6IHtcblx0XHRcdFx0XHRsb2c6IGZyYWdtZW50TG9nLFxuXHRcdFx0XHRcdHByZWZpeDogcHJlZml4RnJhZ21lbnRcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdH1cblxuXHQvLyBDbGVhbiB1cFxuXG5cdC8vIENyYXNoZXMgaW4gaU9TOSBhbmQgaU9TMTAuICMxODQwMlxuXHQvLyBnbC5kZXRhY2hTaGFkZXIoIHByb2dyYW0sIGdsVmVydGV4U2hhZGVyICk7XG5cdC8vIGdsLmRldGFjaFNoYWRlciggcHJvZ3JhbSwgZ2xGcmFnbWVudFNoYWRlciApO1xuXG5cdGdsLmRlbGV0ZVNoYWRlcihnbFZlcnRleFNoYWRlcik7XG5cdGdsLmRlbGV0ZVNoYWRlcihnbEZyYWdtZW50U2hhZGVyKTtcblxuXHQvLyBzZXQgdXAgY2FjaGluZyBmb3IgdW5pZm9ybSBsb2NhdGlvbnNcblxuXHRsZXQgY2FjaGVkVW5pZm9ybXM7XG5cdHRoaXMuZ2V0VW5pZm9ybXMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKGNhY2hlZFVuaWZvcm1zID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGNhY2hlZFVuaWZvcm1zID0gbmV3IFdlYkdMVW5pZm9ybXMoZ2wsIHByb2dyYW0pO1xuXHRcdH1cblx0XHRyZXR1cm4gY2FjaGVkVW5pZm9ybXM7XG5cdH07XG5cblx0Ly8gc2V0IHVwIGNhY2hpbmcgZm9yIGF0dHJpYnV0ZSBsb2NhdGlvbnNcblxuXHRsZXQgY2FjaGVkQXR0cmlidXRlcztcblx0dGhpcy5nZXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmIChjYWNoZWRBdHRyaWJ1dGVzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGNhY2hlZEF0dHJpYnV0ZXMgPSBmZXRjaEF0dHJpYnV0ZUxvY2F0aW9ucyhnbCwgcHJvZ3JhbSk7XG5cdFx0fVxuXHRcdHJldHVybiBjYWNoZWRBdHRyaWJ1dGVzO1xuXHR9O1xuXG5cdC8vIGZyZWUgcmVzb3VyY2VcblxuXHR0aGlzLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG5cdFx0YmluZGluZ1N0YXRlcy5yZWxlYXNlU3RhdGVzT2ZQcm9ncmFtKHRoaXMpO1xuXHRcdGdsLmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSk7XG5cdFx0dGhpcy5wcm9ncmFtID0gdW5kZWZpbmVkO1xuXHR9O1xuXG5cdC8vXG5cblx0dGhpcy5uYW1lID0gcGFyYW1ldGVycy5zaGFkZXJOYW1lO1xuXHR0aGlzLmlkID0gcHJvZ3JhbUlkQ291bnQrKztcblx0dGhpcy5jYWNoZUtleSA9IGNhY2hlS2V5O1xuXHR0aGlzLnVzZWRUaW1lcyA9IDE7XG5cdHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XG5cdHRoaXMudmVydGV4U2hhZGVyID0gZ2xWZXJ0ZXhTaGFkZXI7XG5cdHRoaXMuZnJhZ21lbnRTaGFkZXIgPSBnbEZyYWdtZW50U2hhZGVyO1xuXHRyZXR1cm4gdGhpcztcbn1cblxubGV0IF9pZCA9IDA7XG5jbGFzcyBXZWJHTFNoYWRlckNhY2hlIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0dGhpcy5zaGFkZXJDYWNoZSA9IG5ldyBNYXAoKTtcblx0XHR0aGlzLm1hdGVyaWFsQ2FjaGUgPSBuZXcgTWFwKCk7XG5cdH1cblx0dXBkYXRlKG1hdGVyaWFsKSB7XG5cdFx0Y29uc3QgdmVydGV4U2hhZGVyID0gbWF0ZXJpYWwudmVydGV4U2hhZGVyO1xuXHRcdGNvbnN0IGZyYWdtZW50U2hhZGVyID0gbWF0ZXJpYWwuZnJhZ21lbnRTaGFkZXI7XG5cdFx0Y29uc3QgdmVydGV4U2hhZGVyU3RhZ2UgPSB0aGlzLl9nZXRTaGFkZXJTdGFnZSh2ZXJ0ZXhTaGFkZXIpO1xuXHRcdGNvbnN0IGZyYWdtZW50U2hhZGVyU3RhZ2UgPSB0aGlzLl9nZXRTaGFkZXJTdGFnZShmcmFnbWVudFNoYWRlcik7XG5cdFx0Y29uc3QgbWF0ZXJpYWxTaGFkZXJzID0gdGhpcy5fZ2V0U2hhZGVyQ2FjaGVGb3JNYXRlcmlhbChtYXRlcmlhbCk7XG5cdFx0aWYgKG1hdGVyaWFsU2hhZGVycy5oYXModmVydGV4U2hhZGVyU3RhZ2UpID09PSBmYWxzZSkge1xuXHRcdFx0bWF0ZXJpYWxTaGFkZXJzLmFkZCh2ZXJ0ZXhTaGFkZXJTdGFnZSk7XG5cdFx0XHR2ZXJ0ZXhTaGFkZXJTdGFnZS51c2VkVGltZXMrKztcblx0XHR9XG5cdFx0aWYgKG1hdGVyaWFsU2hhZGVycy5oYXMoZnJhZ21lbnRTaGFkZXJTdGFnZSkgPT09IGZhbHNlKSB7XG5cdFx0XHRtYXRlcmlhbFNoYWRlcnMuYWRkKGZyYWdtZW50U2hhZGVyU3RhZ2UpO1xuXHRcdFx0ZnJhZ21lbnRTaGFkZXJTdGFnZS51c2VkVGltZXMrKztcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0cmVtb3ZlKG1hdGVyaWFsKSB7XG5cdFx0Y29uc3QgbWF0ZXJpYWxTaGFkZXJzID0gdGhpcy5tYXRlcmlhbENhY2hlLmdldChtYXRlcmlhbCk7XG5cdFx0Zm9yIChjb25zdCBzaGFkZXJTdGFnZSBvZiBtYXRlcmlhbFNoYWRlcnMpIHtcblx0XHRcdHNoYWRlclN0YWdlLnVzZWRUaW1lcy0tO1xuXHRcdFx0aWYgKHNoYWRlclN0YWdlLnVzZWRUaW1lcyA9PT0gMCkgdGhpcy5zaGFkZXJDYWNoZS5kZWxldGUoc2hhZGVyU3RhZ2UuY29kZSk7XG5cdFx0fVxuXHRcdHRoaXMubWF0ZXJpYWxDYWNoZS5kZWxldGUobWF0ZXJpYWwpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGdldFZlcnRleFNoYWRlcklEKG1hdGVyaWFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2dldFNoYWRlclN0YWdlKG1hdGVyaWFsLnZlcnRleFNoYWRlcikuaWQ7XG5cdH1cblx0Z2V0RnJhZ21lbnRTaGFkZXJJRChtYXRlcmlhbCkge1xuXHRcdHJldHVybiB0aGlzLl9nZXRTaGFkZXJTdGFnZShtYXRlcmlhbC5mcmFnbWVudFNoYWRlcikuaWQ7XG5cdH1cblx0ZGlzcG9zZSgpIHtcblx0XHR0aGlzLnNoYWRlckNhY2hlLmNsZWFyKCk7XG5cdFx0dGhpcy5tYXRlcmlhbENhY2hlLmNsZWFyKCk7XG5cdH1cblx0X2dldFNoYWRlckNhY2hlRm9yTWF0ZXJpYWwobWF0ZXJpYWwpIHtcblx0XHRjb25zdCBjYWNoZSA9IHRoaXMubWF0ZXJpYWxDYWNoZTtcblx0XHRsZXQgc2V0ID0gY2FjaGUuZ2V0KG1hdGVyaWFsKTtcblx0XHRpZiAoc2V0ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHNldCA9IG5ldyBTZXQoKTtcblx0XHRcdGNhY2hlLnNldChtYXRlcmlhbCwgc2V0KTtcblx0XHR9XG5cdFx0cmV0dXJuIHNldDtcblx0fVxuXHRfZ2V0U2hhZGVyU3RhZ2UoY29kZSkge1xuXHRcdGNvbnN0IGNhY2hlID0gdGhpcy5zaGFkZXJDYWNoZTtcblx0XHRsZXQgc3RhZ2UgPSBjYWNoZS5nZXQoY29kZSk7XG5cdFx0aWYgKHN0YWdlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHN0YWdlID0gbmV3IFdlYkdMU2hhZGVyU3RhZ2UoY29kZSk7XG5cdFx0XHRjYWNoZS5zZXQoY29kZSwgc3RhZ2UpO1xuXHRcdH1cblx0XHRyZXR1cm4gc3RhZ2U7XG5cdH1cbn1cbmNsYXNzIFdlYkdMU2hhZGVyU3RhZ2Uge1xuXHRjb25zdHJ1Y3Rvcihjb2RlKSB7XG5cdFx0dGhpcy5pZCA9IF9pZCsrO1xuXHRcdHRoaXMuY29kZSA9IGNvZGU7XG5cdFx0dGhpcy51c2VkVGltZXMgPSAwO1xuXHR9XG59XG5cbmZ1bmN0aW9uIFdlYkdMUHJvZ3JhbXMocmVuZGVyZXIsIGN1YmVtYXBzLCBjdWJldXZtYXBzLCBleHRlbnNpb25zLCBjYXBhYmlsaXRpZXMsIGJpbmRpbmdTdGF0ZXMsIGNsaXBwaW5nKSB7XG5cdGNvbnN0IF9wcm9ncmFtTGF5ZXJzID0gbmV3IExheWVycygpO1xuXHRjb25zdCBfY3VzdG9tU2hhZGVycyA9IG5ldyBXZWJHTFNoYWRlckNhY2hlKCk7XG5cdGNvbnN0IHByb2dyYW1zID0gW107XG5cdGNvbnN0IGlzV2ViR0wyID0gY2FwYWJpbGl0aWVzLmlzV2ViR0wyO1xuXHRjb25zdCBsb2dhcml0aG1pY0RlcHRoQnVmZmVyID0gY2FwYWJpbGl0aWVzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXI7XG5cdGNvbnN0IHZlcnRleFRleHR1cmVzID0gY2FwYWJpbGl0aWVzLnZlcnRleFRleHR1cmVzO1xuXHRsZXQgcHJlY2lzaW9uID0gY2FwYWJpbGl0aWVzLnByZWNpc2lvbjtcblx0Y29uc3Qgc2hhZGVySURzID0ge1xuXHRcdE1lc2hEZXB0aE1hdGVyaWFsOiAnZGVwdGgnLFxuXHRcdE1lc2hEaXN0YW5jZU1hdGVyaWFsOiAnZGlzdGFuY2VSR0JBJyxcblx0XHRNZXNoTm9ybWFsTWF0ZXJpYWw6ICdub3JtYWwnLFxuXHRcdE1lc2hCYXNpY01hdGVyaWFsOiAnYmFzaWMnLFxuXHRcdE1lc2hMYW1iZXJ0TWF0ZXJpYWw6ICdsYW1iZXJ0Jyxcblx0XHRNZXNoUGhvbmdNYXRlcmlhbDogJ3Bob25nJyxcblx0XHRNZXNoVG9vbk1hdGVyaWFsOiAndG9vbicsXG5cdFx0TWVzaFN0YW5kYXJkTWF0ZXJpYWw6ICdwaHlzaWNhbCcsXG5cdFx0TWVzaFBoeXNpY2FsTWF0ZXJpYWw6ICdwaHlzaWNhbCcsXG5cdFx0TWVzaE1hdGNhcE1hdGVyaWFsOiAnbWF0Y2FwJyxcblx0XHRMaW5lQmFzaWNNYXRlcmlhbDogJ2Jhc2ljJyxcblx0XHRMaW5lRGFzaGVkTWF0ZXJpYWw6ICdkYXNoZWQnLFxuXHRcdFBvaW50c01hdGVyaWFsOiAncG9pbnRzJyxcblx0XHRTaGFkb3dNYXRlcmlhbDogJ3NoYWRvdycsXG5cdFx0U3ByaXRlTWF0ZXJpYWw6ICdzcHJpdGUnXG5cdH07XG5cdGZ1bmN0aW9uIGdldFBhcmFtZXRlcnMobWF0ZXJpYWwsIGxpZ2h0cywgc2hhZG93cywgc2NlbmUsIG9iamVjdCkge1xuXHRcdGNvbnN0IGZvZyA9IHNjZW5lLmZvZztcblx0XHRjb25zdCBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcblx0XHRjb25zdCBlbnZpcm9ubWVudCA9IG1hdGVyaWFsLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgPyBzY2VuZS5lbnZpcm9ubWVudCA6IG51bGw7XG5cdFx0Y29uc3QgZW52TWFwID0gKG1hdGVyaWFsLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgPyBjdWJldXZtYXBzIDogY3ViZW1hcHMpLmdldChtYXRlcmlhbC5lbnZNYXAgfHwgZW52aXJvbm1lbnQpO1xuXHRcdGNvbnN0IGVudk1hcEN1YmVVVkhlaWdodCA9ICEhZW52TWFwICYmIGVudk1hcC5tYXBwaW5nID09PSBDdWJlVVZSZWZsZWN0aW9uTWFwcGluZyA/IGVudk1hcC5pbWFnZS5oZWlnaHQgOiBudWxsO1xuXHRcdGNvbnN0IHNoYWRlcklEID0gc2hhZGVySURzW21hdGVyaWFsLnR5cGVdO1xuXG5cdFx0Ly8gaGV1cmlzdGljcyB0byBjcmVhdGUgc2hhZGVyIHBhcmFtZXRlcnMgYWNjb3JkaW5nIHRvIGxpZ2h0cyBpbiB0aGUgc2NlbmVcblx0XHQvLyAobm90IHRvIGJsb3cgb3ZlciBtYXhMaWdodHMgYnVkZ2V0KVxuXG5cdFx0aWYgKG1hdGVyaWFsLnByZWNpc2lvbiAhPT0gbnVsbCkge1xuXHRcdFx0cHJlY2lzaW9uID0gY2FwYWJpbGl0aWVzLmdldE1heFByZWNpc2lvbihtYXRlcmlhbC5wcmVjaXNpb24pO1xuXHRcdFx0aWYgKHByZWNpc2lvbiAhPT0gbWF0ZXJpYWwucHJlY2lzaW9uKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xQcm9ncmFtLmdldFBhcmFtZXRlcnM6JywgbWF0ZXJpYWwucHJlY2lzaW9uLCAnbm90IHN1cHBvcnRlZCwgdXNpbmcnLCBwcmVjaXNpb24sICdpbnN0ZWFkLicpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZSA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbiB8fCBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsIHx8IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5jb2xvcjtcblx0XHRjb25zdCBtb3JwaFRhcmdldHNDb3VudCA9IG1vcnBoQXR0cmlidXRlICE9PSB1bmRlZmluZWQgPyBtb3JwaEF0dHJpYnV0ZS5sZW5ndGggOiAwO1xuXHRcdGxldCBtb3JwaFRleHR1cmVTdHJpZGUgPSAwO1xuXHRcdGlmIChnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24gIT09IHVuZGVmaW5lZCkgbW9ycGhUZXh0dXJlU3RyaWRlID0gMTtcblx0XHRpZiAoZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbCAhPT0gdW5kZWZpbmVkKSBtb3JwaFRleHR1cmVTdHJpZGUgPSAyO1xuXHRcdGlmIChnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMuY29sb3IgIT09IHVuZGVmaW5lZCkgbW9ycGhUZXh0dXJlU3RyaWRlID0gMztcblxuXHRcdC8vXG5cblx0XHRsZXQgdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcjtcblx0XHRsZXQgY3VzdG9tVmVydGV4U2hhZGVySUQsIGN1c3RvbUZyYWdtZW50U2hhZGVySUQ7XG5cdFx0aWYgKHNoYWRlcklEKSB7XG5cdFx0XHRjb25zdCBzaGFkZXIgPSBTaGFkZXJMaWJbc2hhZGVySURdO1xuXHRcdFx0dmVydGV4U2hhZGVyID0gc2hhZGVyLnZlcnRleFNoYWRlcjtcblx0XHRcdGZyYWdtZW50U2hhZGVyID0gc2hhZGVyLmZyYWdtZW50U2hhZGVyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2ZXJ0ZXhTaGFkZXIgPSBtYXRlcmlhbC52ZXJ0ZXhTaGFkZXI7XG5cdFx0XHRmcmFnbWVudFNoYWRlciA9IG1hdGVyaWFsLmZyYWdtZW50U2hhZGVyO1xuXHRcdFx0X2N1c3RvbVNoYWRlcnMudXBkYXRlKG1hdGVyaWFsKTtcblx0XHRcdGN1c3RvbVZlcnRleFNoYWRlcklEID0gX2N1c3RvbVNoYWRlcnMuZ2V0VmVydGV4U2hhZGVySUQobWF0ZXJpYWwpO1xuXHRcdFx0Y3VzdG9tRnJhZ21lbnRTaGFkZXJJRCA9IF9jdXN0b21TaGFkZXJzLmdldEZyYWdtZW50U2hhZGVySUQobWF0ZXJpYWwpO1xuXHRcdH1cblx0XHRjb25zdCBjdXJyZW50UmVuZGVyVGFyZ2V0ID0gcmVuZGVyZXIuZ2V0UmVuZGVyVGFyZ2V0KCk7XG5cdFx0Y29uc3QgdXNlQWxwaGFUZXN0ID0gbWF0ZXJpYWwuYWxwaGFUZXN0ID4gMDtcblx0XHRjb25zdCB1c2VDbGVhcmNvYXQgPSBtYXRlcmlhbC5jbGVhcmNvYXQgPiAwO1xuXHRcdGNvbnN0IHVzZUlyaWRlc2NlbmNlID0gbWF0ZXJpYWwuaXJpZGVzY2VuY2UgPiAwO1xuXHRcdGNvbnN0IHBhcmFtZXRlcnMgPSB7XG5cdFx0XHRpc1dlYkdMMjogaXNXZWJHTDIsXG5cdFx0XHRzaGFkZXJJRDogc2hhZGVySUQsXG5cdFx0XHRzaGFkZXJOYW1lOiBtYXRlcmlhbC50eXBlLFxuXHRcdFx0dmVydGV4U2hhZGVyOiB2ZXJ0ZXhTaGFkZXIsXG5cdFx0XHRmcmFnbWVudFNoYWRlcjogZnJhZ21lbnRTaGFkZXIsXG5cdFx0XHRkZWZpbmVzOiBtYXRlcmlhbC5kZWZpbmVzLFxuXHRcdFx0Y3VzdG9tVmVydGV4U2hhZGVySUQ6IGN1c3RvbVZlcnRleFNoYWRlcklELFxuXHRcdFx0Y3VzdG9tRnJhZ21lbnRTaGFkZXJJRDogY3VzdG9tRnJhZ21lbnRTaGFkZXJJRCxcblx0XHRcdGlzUmF3U2hhZGVyTWF0ZXJpYWw6IG1hdGVyaWFsLmlzUmF3U2hhZGVyTWF0ZXJpYWwgPT09IHRydWUsXG5cdFx0XHRnbHNsVmVyc2lvbjogbWF0ZXJpYWwuZ2xzbFZlcnNpb24sXG5cdFx0XHRwcmVjaXNpb246IHByZWNpc2lvbixcblx0XHRcdGluc3RhbmNpbmc6IG9iamVjdC5pc0luc3RhbmNlZE1lc2ggPT09IHRydWUsXG5cdFx0XHRpbnN0YW5jaW5nQ29sb3I6IG9iamVjdC5pc0luc3RhbmNlZE1lc2ggPT09IHRydWUgJiYgb2JqZWN0Lmluc3RhbmNlQ29sb3IgIT09IG51bGwsXG5cdFx0XHRzdXBwb3J0c1ZlcnRleFRleHR1cmVzOiB2ZXJ0ZXhUZXh0dXJlcyxcblx0XHRcdG91dHB1dEVuY29kaW5nOiBjdXJyZW50UmVuZGVyVGFyZ2V0ID09PSBudWxsID8gcmVuZGVyZXIub3V0cHV0RW5jb2RpbmcgOiBjdXJyZW50UmVuZGVyVGFyZ2V0LmlzWFJSZW5kZXJUYXJnZXQgPT09IHRydWUgPyBjdXJyZW50UmVuZGVyVGFyZ2V0LnRleHR1cmUuZW5jb2RpbmcgOiBMaW5lYXJFbmNvZGluZyxcblx0XHRcdG1hcDogISFtYXRlcmlhbC5tYXAsXG5cdFx0XHRtYXRjYXA6ICEhbWF0ZXJpYWwubWF0Y2FwLFxuXHRcdFx0ZW52TWFwOiAhIWVudk1hcCxcblx0XHRcdGVudk1hcE1vZGU6IGVudk1hcCAmJiBlbnZNYXAubWFwcGluZyxcblx0XHRcdGVudk1hcEN1YmVVVkhlaWdodDogZW52TWFwQ3ViZVVWSGVpZ2h0LFxuXHRcdFx0bGlnaHRNYXA6ICEhbWF0ZXJpYWwubGlnaHRNYXAsXG5cdFx0XHRhb01hcDogISFtYXRlcmlhbC5hb01hcCxcblx0XHRcdGVtaXNzaXZlTWFwOiAhIW1hdGVyaWFsLmVtaXNzaXZlTWFwLFxuXHRcdFx0YnVtcE1hcDogISFtYXRlcmlhbC5idW1wTWFwLFxuXHRcdFx0bm9ybWFsTWFwOiAhIW1hdGVyaWFsLm5vcm1hbE1hcCxcblx0XHRcdG9iamVjdFNwYWNlTm9ybWFsTWFwOiBtYXRlcmlhbC5ub3JtYWxNYXBUeXBlID09PSBPYmplY3RTcGFjZU5vcm1hbE1hcCxcblx0XHRcdHRhbmdlbnRTcGFjZU5vcm1hbE1hcDogbWF0ZXJpYWwubm9ybWFsTWFwVHlwZSA9PT0gVGFuZ2VudFNwYWNlTm9ybWFsTWFwLFxuXHRcdFx0ZGVjb2RlVmlkZW9UZXh0dXJlOiAhIW1hdGVyaWFsLm1hcCAmJiBtYXRlcmlhbC5tYXAuaXNWaWRlb1RleHR1cmUgPT09IHRydWUgJiYgbWF0ZXJpYWwubWFwLmVuY29kaW5nID09PSBzUkdCRW5jb2RpbmcsXG5cdFx0XHRjbGVhcmNvYXQ6IHVzZUNsZWFyY29hdCxcblx0XHRcdGNsZWFyY29hdE1hcDogdXNlQ2xlYXJjb2F0ICYmICEhbWF0ZXJpYWwuY2xlYXJjb2F0TWFwLFxuXHRcdFx0Y2xlYXJjb2F0Um91Z2huZXNzTWFwOiB1c2VDbGVhcmNvYXQgJiYgISFtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3NNYXAsXG5cdFx0XHRjbGVhcmNvYXROb3JtYWxNYXA6IHVzZUNsZWFyY29hdCAmJiAhIW1hdGVyaWFsLmNsZWFyY29hdE5vcm1hbE1hcCxcblx0XHRcdGlyaWRlc2NlbmNlOiB1c2VJcmlkZXNjZW5jZSxcblx0XHRcdGlyaWRlc2NlbmNlTWFwOiB1c2VJcmlkZXNjZW5jZSAmJiAhIW1hdGVyaWFsLmlyaWRlc2NlbmNlTWFwLFxuXHRcdFx0aXJpZGVzY2VuY2VUaGlja25lc3NNYXA6IHVzZUlyaWRlc2NlbmNlICYmICEhbWF0ZXJpYWwuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAsXG5cdFx0XHRkaXNwbGFjZW1lbnRNYXA6ICEhbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwLFxuXHRcdFx0cm91Z2huZXNzTWFwOiAhIW1hdGVyaWFsLnJvdWdobmVzc01hcCxcblx0XHRcdG1ldGFsbmVzc01hcDogISFtYXRlcmlhbC5tZXRhbG5lc3NNYXAsXG5cdFx0XHRzcGVjdWxhck1hcDogISFtYXRlcmlhbC5zcGVjdWxhck1hcCxcblx0XHRcdHNwZWN1bGFySW50ZW5zaXR5TWFwOiAhIW1hdGVyaWFsLnNwZWN1bGFySW50ZW5zaXR5TWFwLFxuXHRcdFx0c3BlY3VsYXJDb2xvck1hcDogISFtYXRlcmlhbC5zcGVjdWxhckNvbG9yTWFwLFxuXHRcdFx0b3BhcXVlOiBtYXRlcmlhbC50cmFuc3BhcmVudCA9PT0gZmFsc2UgJiYgbWF0ZXJpYWwuYmxlbmRpbmcgPT09IE5vcm1hbEJsZW5kaW5nLFxuXHRcdFx0YWxwaGFNYXA6ICEhbWF0ZXJpYWwuYWxwaGFNYXAsXG5cdFx0XHRhbHBoYVRlc3Q6IHVzZUFscGhhVGVzdCxcblx0XHRcdGdyYWRpZW50TWFwOiAhIW1hdGVyaWFsLmdyYWRpZW50TWFwLFxuXHRcdFx0c2hlZW46IG1hdGVyaWFsLnNoZWVuID4gMCxcblx0XHRcdHNoZWVuQ29sb3JNYXA6ICEhbWF0ZXJpYWwuc2hlZW5Db2xvck1hcCxcblx0XHRcdHNoZWVuUm91Z2huZXNzTWFwOiAhIW1hdGVyaWFsLnNoZWVuUm91Z2huZXNzTWFwLFxuXHRcdFx0dHJhbnNtaXNzaW9uOiBtYXRlcmlhbC50cmFuc21pc3Npb24gPiAwLFxuXHRcdFx0dHJhbnNtaXNzaW9uTWFwOiAhIW1hdGVyaWFsLnRyYW5zbWlzc2lvbk1hcCxcblx0XHRcdHRoaWNrbmVzc01hcDogISFtYXRlcmlhbC50aGlja25lc3NNYXAsXG5cdFx0XHRjb21iaW5lOiBtYXRlcmlhbC5jb21iaW5lLFxuXHRcdFx0dmVydGV4VGFuZ2VudHM6ICEhbWF0ZXJpYWwubm9ybWFsTWFwICYmICEhZ2VvbWV0cnkuYXR0cmlidXRlcy50YW5nZW50LFxuXHRcdFx0dmVydGV4Q29sb3JzOiBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMsXG5cdFx0XHR2ZXJ0ZXhBbHBoYXM6IG1hdGVyaWFsLnZlcnRleENvbG9ycyA9PT0gdHJ1ZSAmJiAhIWdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3IgJiYgZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvci5pdGVtU2l6ZSA9PT0gNCxcblx0XHRcdHZlcnRleFV2czogISFtYXRlcmlhbC5tYXAgfHwgISFtYXRlcmlhbC5idW1wTWFwIHx8ICEhbWF0ZXJpYWwubm9ybWFsTWFwIHx8ICEhbWF0ZXJpYWwuc3BlY3VsYXJNYXAgfHwgISFtYXRlcmlhbC5hbHBoYU1hcCB8fCAhIW1hdGVyaWFsLmVtaXNzaXZlTWFwIHx8ICEhbWF0ZXJpYWwucm91Z2huZXNzTWFwIHx8ICEhbWF0ZXJpYWwubWV0YWxuZXNzTWFwIHx8ICEhbWF0ZXJpYWwuY2xlYXJjb2F0TWFwIHx8ICEhbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzTWFwIHx8ICEhbWF0ZXJpYWwuY2xlYXJjb2F0Tm9ybWFsTWFwIHx8ICEhbWF0ZXJpYWwuaXJpZGVzY2VuY2VNYXAgfHwgISFtYXRlcmlhbC5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcCB8fCAhIW1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCB8fCAhIW1hdGVyaWFsLnRyYW5zbWlzc2lvbk1hcCB8fCAhIW1hdGVyaWFsLnRoaWNrbmVzc01hcCB8fCAhIW1hdGVyaWFsLnNwZWN1bGFySW50ZW5zaXR5TWFwIHx8ICEhbWF0ZXJpYWwuc3BlY3VsYXJDb2xvck1hcCB8fCAhIW1hdGVyaWFsLnNoZWVuQ29sb3JNYXAgfHwgISFtYXRlcmlhbC5zaGVlblJvdWdobmVzc01hcCxcblx0XHRcdHV2c1ZlcnRleE9ubHk6ICEoISFtYXRlcmlhbC5tYXAgfHwgISFtYXRlcmlhbC5idW1wTWFwIHx8ICEhbWF0ZXJpYWwubm9ybWFsTWFwIHx8ICEhbWF0ZXJpYWwuc3BlY3VsYXJNYXAgfHwgISFtYXRlcmlhbC5hbHBoYU1hcCB8fCAhIW1hdGVyaWFsLmVtaXNzaXZlTWFwIHx8ICEhbWF0ZXJpYWwucm91Z2huZXNzTWFwIHx8ICEhbWF0ZXJpYWwubWV0YWxuZXNzTWFwIHx8ICEhbWF0ZXJpYWwuY2xlYXJjb2F0Tm9ybWFsTWFwIHx8ICEhbWF0ZXJpYWwuaXJpZGVzY2VuY2VNYXAgfHwgISFtYXRlcmlhbC5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcCB8fCBtYXRlcmlhbC50cmFuc21pc3Npb24gPiAwIHx8ICEhbWF0ZXJpYWwudHJhbnNtaXNzaW9uTWFwIHx8ICEhbWF0ZXJpYWwudGhpY2tuZXNzTWFwIHx8ICEhbWF0ZXJpYWwuc3BlY3VsYXJJbnRlbnNpdHlNYXAgfHwgISFtYXRlcmlhbC5zcGVjdWxhckNvbG9yTWFwIHx8IG1hdGVyaWFsLnNoZWVuID4gMCB8fCAhIW1hdGVyaWFsLnNoZWVuQ29sb3JNYXAgfHwgISFtYXRlcmlhbC5zaGVlblJvdWdobmVzc01hcCkgJiYgISFtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAsXG5cdFx0XHRmb2c6ICEhZm9nLFxuXHRcdFx0dXNlRm9nOiBtYXRlcmlhbC5mb2cgPT09IHRydWUsXG5cdFx0XHRmb2dFeHAyOiBmb2cgJiYgZm9nLmlzRm9nRXhwMixcblx0XHRcdGZsYXRTaGFkaW5nOiAhIW1hdGVyaWFsLmZsYXRTaGFkaW5nLFxuXHRcdFx0c2l6ZUF0dGVudWF0aW9uOiBtYXRlcmlhbC5zaXplQXR0ZW51YXRpb24sXG5cdFx0XHRsb2dhcml0aG1pY0RlcHRoQnVmZmVyOiBsb2dhcml0aG1pY0RlcHRoQnVmZmVyLFxuXHRcdFx0c2tpbm5pbmc6IG9iamVjdC5pc1NraW5uZWRNZXNoID09PSB0cnVlLFxuXHRcdFx0bW9ycGhUYXJnZXRzOiBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24gIT09IHVuZGVmaW5lZCxcblx0XHRcdG1vcnBoTm9ybWFsczogZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbCAhPT0gdW5kZWZpbmVkLFxuXHRcdFx0bW9ycGhDb2xvcnM6IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5jb2xvciAhPT0gdW5kZWZpbmVkLFxuXHRcdFx0bW9ycGhUYXJnZXRzQ291bnQ6IG1vcnBoVGFyZ2V0c0NvdW50LFxuXHRcdFx0bW9ycGhUZXh0dXJlU3RyaWRlOiBtb3JwaFRleHR1cmVTdHJpZGUsXG5cdFx0XHRudW1EaXJMaWdodHM6IGxpZ2h0cy5kaXJlY3Rpb25hbC5sZW5ndGgsXG5cdFx0XHRudW1Qb2ludExpZ2h0czogbGlnaHRzLnBvaW50Lmxlbmd0aCxcblx0XHRcdG51bVNwb3RMaWdodHM6IGxpZ2h0cy5zcG90Lmxlbmd0aCxcblx0XHRcdG51bVNwb3RMaWdodE1hcHM6IGxpZ2h0cy5zcG90TGlnaHRNYXAubGVuZ3RoLFxuXHRcdFx0bnVtUmVjdEFyZWFMaWdodHM6IGxpZ2h0cy5yZWN0QXJlYS5sZW5ndGgsXG5cdFx0XHRudW1IZW1pTGlnaHRzOiBsaWdodHMuaGVtaS5sZW5ndGgsXG5cdFx0XHRudW1EaXJMaWdodFNoYWRvd3M6IGxpZ2h0cy5kaXJlY3Rpb25hbFNoYWRvd01hcC5sZW5ndGgsXG5cdFx0XHRudW1Qb2ludExpZ2h0U2hhZG93czogbGlnaHRzLnBvaW50U2hhZG93TWFwLmxlbmd0aCxcblx0XHRcdG51bVNwb3RMaWdodFNoYWRvd3M6IGxpZ2h0cy5zcG90U2hhZG93TWFwLmxlbmd0aCxcblx0XHRcdG51bVNwb3RMaWdodFNoYWRvd3NXaXRoTWFwczogbGlnaHRzLm51bVNwb3RMaWdodFNoYWRvd3NXaXRoTWFwcyxcblx0XHRcdG51bUNsaXBwaW5nUGxhbmVzOiBjbGlwcGluZy5udW1QbGFuZXMsXG5cdFx0XHRudW1DbGlwSW50ZXJzZWN0aW9uOiBjbGlwcGluZy5udW1JbnRlcnNlY3Rpb24sXG5cdFx0XHRkaXRoZXJpbmc6IG1hdGVyaWFsLmRpdGhlcmluZyxcblx0XHRcdHNoYWRvd01hcEVuYWJsZWQ6IHJlbmRlcmVyLnNoYWRvd01hcC5lbmFibGVkICYmIHNoYWRvd3MubGVuZ3RoID4gMCxcblx0XHRcdHNoYWRvd01hcFR5cGU6IHJlbmRlcmVyLnNoYWRvd01hcC50eXBlLFxuXHRcdFx0dG9uZU1hcHBpbmc6IG1hdGVyaWFsLnRvbmVNYXBwZWQgPyByZW5kZXJlci50b25lTWFwcGluZyA6IE5vVG9uZU1hcHBpbmcsXG5cdFx0XHRwaHlzaWNhbGx5Q29ycmVjdExpZ2h0czogcmVuZGVyZXIucGh5c2ljYWxseUNvcnJlY3RMaWdodHMsXG5cdFx0XHRwcmVtdWx0aXBsaWVkQWxwaGE6IG1hdGVyaWFsLnByZW11bHRpcGxpZWRBbHBoYSxcblx0XHRcdGRvdWJsZVNpZGVkOiBtYXRlcmlhbC5zaWRlID09PSBEb3VibGVTaWRlLFxuXHRcdFx0ZmxpcFNpZGVkOiBtYXRlcmlhbC5zaWRlID09PSBCYWNrU2lkZSxcblx0XHRcdHVzZURlcHRoUGFja2luZzogISFtYXRlcmlhbC5kZXB0aFBhY2tpbmcsXG5cdFx0XHRkZXB0aFBhY2tpbmc6IG1hdGVyaWFsLmRlcHRoUGFja2luZyB8fCAwLFxuXHRcdFx0aW5kZXgwQXR0cmlidXRlTmFtZTogbWF0ZXJpYWwuaW5kZXgwQXR0cmlidXRlTmFtZSxcblx0XHRcdGV4dGVuc2lvbkRlcml2YXRpdmVzOiBtYXRlcmlhbC5leHRlbnNpb25zICYmIG1hdGVyaWFsLmV4dGVuc2lvbnMuZGVyaXZhdGl2ZXMsXG5cdFx0XHRleHRlbnNpb25GcmFnRGVwdGg6IG1hdGVyaWFsLmV4dGVuc2lvbnMgJiYgbWF0ZXJpYWwuZXh0ZW5zaW9ucy5mcmFnRGVwdGgsXG5cdFx0XHRleHRlbnNpb25EcmF3QnVmZmVyczogbWF0ZXJpYWwuZXh0ZW5zaW9ucyAmJiBtYXRlcmlhbC5leHRlbnNpb25zLmRyYXdCdWZmZXJzLFxuXHRcdFx0ZXh0ZW5zaW9uU2hhZGVyVGV4dHVyZUxPRDogbWF0ZXJpYWwuZXh0ZW5zaW9ucyAmJiBtYXRlcmlhbC5leHRlbnNpb25zLnNoYWRlclRleHR1cmVMT0QsXG5cdFx0XHRyZW5kZXJlckV4dGVuc2lvbkZyYWdEZXB0aDogaXNXZWJHTDIgfHwgZXh0ZW5zaW9ucy5oYXMoJ0VYVF9mcmFnX2RlcHRoJyksXG5cdFx0XHRyZW5kZXJlckV4dGVuc2lvbkRyYXdCdWZmZXJzOiBpc1dlYkdMMiB8fCBleHRlbnNpb25zLmhhcygnV0VCR0xfZHJhd19idWZmZXJzJyksXG5cdFx0XHRyZW5kZXJlckV4dGVuc2lvblNoYWRlclRleHR1cmVMb2Q6IGlzV2ViR0wyIHx8IGV4dGVuc2lvbnMuaGFzKCdFWFRfc2hhZGVyX3RleHR1cmVfbG9kJyksXG5cdFx0XHRjdXN0b21Qcm9ncmFtQ2FjaGVLZXk6IG1hdGVyaWFsLmN1c3RvbVByb2dyYW1DYWNoZUtleSgpXG5cdFx0fTtcblx0XHRyZXR1cm4gcGFyYW1ldGVycztcblx0fVxuXHRmdW5jdGlvbiBnZXRQcm9ncmFtQ2FjaGVLZXkocGFyYW1ldGVycykge1xuXHRcdGNvbnN0IGFycmF5ID0gW107XG5cdFx0aWYgKHBhcmFtZXRlcnMuc2hhZGVySUQpIHtcblx0XHRcdGFycmF5LnB1c2gocGFyYW1ldGVycy5zaGFkZXJJRCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFycmF5LnB1c2gocGFyYW1ldGVycy5jdXN0b21WZXJ0ZXhTaGFkZXJJRCk7XG5cdFx0XHRhcnJheS5wdXNoKHBhcmFtZXRlcnMuY3VzdG9tRnJhZ21lbnRTaGFkZXJJRCk7XG5cdFx0fVxuXHRcdGlmIChwYXJhbWV0ZXJzLmRlZmluZXMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Zm9yIChjb25zdCBuYW1lIGluIHBhcmFtZXRlcnMuZGVmaW5lcykge1xuXHRcdFx0XHRhcnJheS5wdXNoKG5hbWUpO1xuXHRcdFx0XHRhcnJheS5wdXNoKHBhcmFtZXRlcnMuZGVmaW5lc1tuYW1lXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChwYXJhbWV0ZXJzLmlzUmF3U2hhZGVyTWF0ZXJpYWwgPT09IGZhbHNlKSB7XG5cdFx0XHRnZXRQcm9ncmFtQ2FjaGVLZXlQYXJhbWV0ZXJzKGFycmF5LCBwYXJhbWV0ZXJzKTtcblx0XHRcdGdldFByb2dyYW1DYWNoZUtleUJvb2xlYW5zKGFycmF5LCBwYXJhbWV0ZXJzKTtcblx0XHRcdGFycmF5LnB1c2gocmVuZGVyZXIub3V0cHV0RW5jb2RpbmcpO1xuXHRcdH1cblx0XHRhcnJheS5wdXNoKHBhcmFtZXRlcnMuY3VzdG9tUHJvZ3JhbUNhY2hlS2V5KTtcblx0XHRyZXR1cm4gYXJyYXkuam9pbigpO1xuXHR9XG5cdGZ1bmN0aW9uIGdldFByb2dyYW1DYWNoZUtleVBhcmFtZXRlcnMoYXJyYXksIHBhcmFtZXRlcnMpIHtcblx0XHRhcnJheS5wdXNoKHBhcmFtZXRlcnMucHJlY2lzaW9uKTtcblx0XHRhcnJheS5wdXNoKHBhcmFtZXRlcnMub3V0cHV0RW5jb2RpbmcpO1xuXHRcdGFycmF5LnB1c2gocGFyYW1ldGVycy5lbnZNYXBNb2RlKTtcblx0XHRhcnJheS5wdXNoKHBhcmFtZXRlcnMuZW52TWFwQ3ViZVVWSGVpZ2h0KTtcblx0XHRhcnJheS5wdXNoKHBhcmFtZXRlcnMuY29tYmluZSk7XG5cdFx0YXJyYXkucHVzaChwYXJhbWV0ZXJzLnZlcnRleFV2cyk7XG5cdFx0YXJyYXkucHVzaChwYXJhbWV0ZXJzLmZvZ0V4cDIpO1xuXHRcdGFycmF5LnB1c2gocGFyYW1ldGVycy5zaXplQXR0ZW51YXRpb24pO1xuXHRcdGFycmF5LnB1c2gocGFyYW1ldGVycy5tb3JwaFRhcmdldHNDb3VudCk7XG5cdFx0YXJyYXkucHVzaChwYXJhbWV0ZXJzLm1vcnBoQXR0cmlidXRlQ291bnQpO1xuXHRcdGFycmF5LnB1c2gocGFyYW1ldGVycy5udW1EaXJMaWdodHMpO1xuXHRcdGFycmF5LnB1c2gocGFyYW1ldGVycy5udW1Qb2ludExpZ2h0cyk7XG5cdFx0YXJyYXkucHVzaChwYXJhbWV0ZXJzLm51bVNwb3RMaWdodHMpO1xuXHRcdGFycmF5LnB1c2gocGFyYW1ldGVycy5udW1TcG90TGlnaHRNYXBzKTtcblx0XHRhcnJheS5wdXNoKHBhcmFtZXRlcnMubnVtSGVtaUxpZ2h0cyk7XG5cdFx0YXJyYXkucHVzaChwYXJhbWV0ZXJzLm51bVJlY3RBcmVhTGlnaHRzKTtcblx0XHRhcnJheS5wdXNoKHBhcmFtZXRlcnMubnVtRGlyTGlnaHRTaGFkb3dzKTtcblx0XHRhcnJheS5wdXNoKHBhcmFtZXRlcnMubnVtUG9pbnRMaWdodFNoYWRvd3MpO1xuXHRcdGFycmF5LnB1c2gocGFyYW1ldGVycy5udW1TcG90TGlnaHRTaGFkb3dzKTtcblx0XHRhcnJheS5wdXNoKHBhcmFtZXRlcnMubnVtU3BvdExpZ2h0U2hhZG93c1dpdGhNYXBzKTtcblx0XHRhcnJheS5wdXNoKHBhcmFtZXRlcnMuc2hhZG93TWFwVHlwZSk7XG5cdFx0YXJyYXkucHVzaChwYXJhbWV0ZXJzLnRvbmVNYXBwaW5nKTtcblx0XHRhcnJheS5wdXNoKHBhcmFtZXRlcnMubnVtQ2xpcHBpbmdQbGFuZXMpO1xuXHRcdGFycmF5LnB1c2gocGFyYW1ldGVycy5udW1DbGlwSW50ZXJzZWN0aW9uKTtcblx0XHRhcnJheS5wdXNoKHBhcmFtZXRlcnMuZGVwdGhQYWNraW5nKTtcblx0fVxuXHRmdW5jdGlvbiBnZXRQcm9ncmFtQ2FjaGVLZXlCb29sZWFucyhhcnJheSwgcGFyYW1ldGVycykge1xuXHRcdF9wcm9ncmFtTGF5ZXJzLmRpc2FibGVBbGwoKTtcblx0XHRpZiAocGFyYW1ldGVycy5pc1dlYkdMMikgX3Byb2dyYW1MYXllcnMuZW5hYmxlKDApO1xuXHRcdGlmIChwYXJhbWV0ZXJzLnN1cHBvcnRzVmVydGV4VGV4dHVyZXMpIF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSgxKTtcblx0XHRpZiAocGFyYW1ldGVycy5pbnN0YW5jaW5nKSBfcHJvZ3JhbUxheWVycy5lbmFibGUoMik7XG5cdFx0aWYgKHBhcmFtZXRlcnMuaW5zdGFuY2luZ0NvbG9yKSBfcHJvZ3JhbUxheWVycy5lbmFibGUoMyk7XG5cdFx0aWYgKHBhcmFtZXRlcnMubWFwKSBfcHJvZ3JhbUxheWVycy5lbmFibGUoNCk7XG5cdFx0aWYgKHBhcmFtZXRlcnMubWF0Y2FwKSBfcHJvZ3JhbUxheWVycy5lbmFibGUoNSk7XG5cdFx0aWYgKHBhcmFtZXRlcnMuZW52TWFwKSBfcHJvZ3JhbUxheWVycy5lbmFibGUoNik7XG5cdFx0aWYgKHBhcmFtZXRlcnMubGlnaHRNYXApIF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSg3KTtcblx0XHRpZiAocGFyYW1ldGVycy5hb01hcCkgX3Byb2dyYW1MYXllcnMuZW5hYmxlKDgpO1xuXHRcdGlmIChwYXJhbWV0ZXJzLmVtaXNzaXZlTWFwKSBfcHJvZ3JhbUxheWVycy5lbmFibGUoOSk7XG5cdFx0aWYgKHBhcmFtZXRlcnMuYnVtcE1hcCkgX3Byb2dyYW1MYXllcnMuZW5hYmxlKDEwKTtcblx0XHRpZiAocGFyYW1ldGVycy5ub3JtYWxNYXApIF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSgxMSk7XG5cdFx0aWYgKHBhcmFtZXRlcnMub2JqZWN0U3BhY2VOb3JtYWxNYXApIF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSgxMik7XG5cdFx0aWYgKHBhcmFtZXRlcnMudGFuZ2VudFNwYWNlTm9ybWFsTWFwKSBfcHJvZ3JhbUxheWVycy5lbmFibGUoMTMpO1xuXHRcdGlmIChwYXJhbWV0ZXJzLmNsZWFyY29hdCkgX3Byb2dyYW1MYXllcnMuZW5hYmxlKDE0KTtcblx0XHRpZiAocGFyYW1ldGVycy5jbGVhcmNvYXRNYXApIF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSgxNSk7XG5cdFx0aWYgKHBhcmFtZXRlcnMuY2xlYXJjb2F0Um91Z2huZXNzTWFwKSBfcHJvZ3JhbUxheWVycy5lbmFibGUoMTYpO1xuXHRcdGlmIChwYXJhbWV0ZXJzLmNsZWFyY29hdE5vcm1hbE1hcCkgX3Byb2dyYW1MYXllcnMuZW5hYmxlKDE3KTtcblx0XHRpZiAocGFyYW1ldGVycy5pcmlkZXNjZW5jZSkgX3Byb2dyYW1MYXllcnMuZW5hYmxlKDE4KTtcblx0XHRpZiAocGFyYW1ldGVycy5pcmlkZXNjZW5jZU1hcCkgX3Byb2dyYW1MYXllcnMuZW5hYmxlKDE5KTtcblx0XHRpZiAocGFyYW1ldGVycy5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcCkgX3Byb2dyYW1MYXllcnMuZW5hYmxlKDIwKTtcblx0XHRpZiAocGFyYW1ldGVycy5kaXNwbGFjZW1lbnRNYXApIF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSgyMSk7XG5cdFx0aWYgKHBhcmFtZXRlcnMuc3BlY3VsYXJNYXApIF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSgyMik7XG5cdFx0aWYgKHBhcmFtZXRlcnMucm91Z2huZXNzTWFwKSBfcHJvZ3JhbUxheWVycy5lbmFibGUoMjMpO1xuXHRcdGlmIChwYXJhbWV0ZXJzLm1ldGFsbmVzc01hcCkgX3Byb2dyYW1MYXllcnMuZW5hYmxlKDI0KTtcblx0XHRpZiAocGFyYW1ldGVycy5ncmFkaWVudE1hcCkgX3Byb2dyYW1MYXllcnMuZW5hYmxlKDI1KTtcblx0XHRpZiAocGFyYW1ldGVycy5hbHBoYU1hcCkgX3Byb2dyYW1MYXllcnMuZW5hYmxlKDI2KTtcblx0XHRpZiAocGFyYW1ldGVycy5hbHBoYVRlc3QpIF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSgyNyk7XG5cdFx0aWYgKHBhcmFtZXRlcnMudmVydGV4Q29sb3JzKSBfcHJvZ3JhbUxheWVycy5lbmFibGUoMjgpO1xuXHRcdGlmIChwYXJhbWV0ZXJzLnZlcnRleEFscGhhcykgX3Byb2dyYW1MYXllcnMuZW5hYmxlKDI5KTtcblx0XHRpZiAocGFyYW1ldGVycy52ZXJ0ZXhVdnMpIF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSgzMCk7XG5cdFx0aWYgKHBhcmFtZXRlcnMudmVydGV4VGFuZ2VudHMpIF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSgzMSk7XG5cdFx0aWYgKHBhcmFtZXRlcnMudXZzVmVydGV4T25seSkgX3Byb2dyYW1MYXllcnMuZW5hYmxlKDMyKTtcblx0XHRhcnJheS5wdXNoKF9wcm9ncmFtTGF5ZXJzLm1hc2spO1xuXHRcdF9wcm9ncmFtTGF5ZXJzLmRpc2FibGVBbGwoKTtcblx0XHRpZiAocGFyYW1ldGVycy5mb2cpIF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSgwKTtcblx0XHRpZiAocGFyYW1ldGVycy51c2VGb2cpIF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSgxKTtcblx0XHRpZiAocGFyYW1ldGVycy5mbGF0U2hhZGluZykgX3Byb2dyYW1MYXllcnMuZW5hYmxlKDIpO1xuXHRcdGlmIChwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIpIF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSgzKTtcblx0XHRpZiAocGFyYW1ldGVycy5za2lubmluZykgX3Byb2dyYW1MYXllcnMuZW5hYmxlKDQpO1xuXHRcdGlmIChwYXJhbWV0ZXJzLm1vcnBoVGFyZ2V0cykgX3Byb2dyYW1MYXllcnMuZW5hYmxlKDUpO1xuXHRcdGlmIChwYXJhbWV0ZXJzLm1vcnBoTm9ybWFscykgX3Byb2dyYW1MYXllcnMuZW5hYmxlKDYpO1xuXHRcdGlmIChwYXJhbWV0ZXJzLm1vcnBoQ29sb3JzKSBfcHJvZ3JhbUxheWVycy5lbmFibGUoNyk7XG5cdFx0aWYgKHBhcmFtZXRlcnMucHJlbXVsdGlwbGllZEFscGhhKSBfcHJvZ3JhbUxheWVycy5lbmFibGUoOCk7XG5cdFx0aWYgKHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCkgX3Byb2dyYW1MYXllcnMuZW5hYmxlKDkpO1xuXHRcdGlmIChwYXJhbWV0ZXJzLnBoeXNpY2FsbHlDb3JyZWN0TGlnaHRzKSBfcHJvZ3JhbUxheWVycy5lbmFibGUoMTApO1xuXHRcdGlmIChwYXJhbWV0ZXJzLmRvdWJsZVNpZGVkKSBfcHJvZ3JhbUxheWVycy5lbmFibGUoMTEpO1xuXHRcdGlmIChwYXJhbWV0ZXJzLmZsaXBTaWRlZCkgX3Byb2dyYW1MYXllcnMuZW5hYmxlKDEyKTtcblx0XHRpZiAocGFyYW1ldGVycy51c2VEZXB0aFBhY2tpbmcpIF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSgxMyk7XG5cdFx0aWYgKHBhcmFtZXRlcnMuZGl0aGVyaW5nKSBfcHJvZ3JhbUxheWVycy5lbmFibGUoMTQpO1xuXHRcdGlmIChwYXJhbWV0ZXJzLnNwZWN1bGFySW50ZW5zaXR5TWFwKSBfcHJvZ3JhbUxheWVycy5lbmFibGUoMTUpO1xuXHRcdGlmIChwYXJhbWV0ZXJzLnNwZWN1bGFyQ29sb3JNYXApIF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSgxNik7XG5cdFx0aWYgKHBhcmFtZXRlcnMudHJhbnNtaXNzaW9uKSBfcHJvZ3JhbUxheWVycy5lbmFibGUoMTcpO1xuXHRcdGlmIChwYXJhbWV0ZXJzLnRyYW5zbWlzc2lvbk1hcCkgX3Byb2dyYW1MYXllcnMuZW5hYmxlKDE4KTtcblx0XHRpZiAocGFyYW1ldGVycy50aGlja25lc3NNYXApIF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSgxOSk7XG5cdFx0aWYgKHBhcmFtZXRlcnMuc2hlZW4pIF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSgyMCk7XG5cdFx0aWYgKHBhcmFtZXRlcnMuc2hlZW5Db2xvck1hcCkgX3Byb2dyYW1MYXllcnMuZW5hYmxlKDIxKTtcblx0XHRpZiAocGFyYW1ldGVycy5zaGVlblJvdWdobmVzc01hcCkgX3Byb2dyYW1MYXllcnMuZW5hYmxlKDIyKTtcblx0XHRpZiAocGFyYW1ldGVycy5kZWNvZGVWaWRlb1RleHR1cmUpIF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSgyMyk7XG5cdFx0aWYgKHBhcmFtZXRlcnMub3BhcXVlKSBfcHJvZ3JhbUxheWVycy5lbmFibGUoMjQpO1xuXHRcdGFycmF5LnB1c2goX3Byb2dyYW1MYXllcnMubWFzayk7XG5cdH1cblx0ZnVuY3Rpb24gZ2V0VW5pZm9ybXMobWF0ZXJpYWwpIHtcblx0XHRjb25zdCBzaGFkZXJJRCA9IHNoYWRlcklEc1ttYXRlcmlhbC50eXBlXTtcblx0XHRsZXQgdW5pZm9ybXM7XG5cdFx0aWYgKHNoYWRlcklEKSB7XG5cdFx0XHRjb25zdCBzaGFkZXIgPSBTaGFkZXJMaWJbc2hhZGVySURdO1xuXHRcdFx0dW5pZm9ybXMgPSBVbmlmb3Jtc1V0aWxzLmNsb25lKHNoYWRlci51bmlmb3Jtcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHVuaWZvcm1zID0gbWF0ZXJpYWwudW5pZm9ybXM7XG5cdFx0fVxuXHRcdHJldHVybiB1bmlmb3Jtcztcblx0fVxuXHRmdW5jdGlvbiBhY3F1aXJlUHJvZ3JhbShwYXJhbWV0ZXJzLCBjYWNoZUtleSkge1xuXHRcdGxldCBwcm9ncmFtO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgY29kZSBoYXMgYmVlbiBhbHJlYWR5IGNvbXBpbGVkXG5cdFx0Zm9yIChsZXQgcCA9IDAsIHBsID0gcHJvZ3JhbXMubGVuZ3RoOyBwIDwgcGw7IHArKykge1xuXHRcdFx0Y29uc3QgcHJlZXhpc3RpbmdQcm9ncmFtID0gcHJvZ3JhbXNbcF07XG5cdFx0XHRpZiAocHJlZXhpc3RpbmdQcm9ncmFtLmNhY2hlS2V5ID09PSBjYWNoZUtleSkge1xuXHRcdFx0XHRwcm9ncmFtID0gcHJlZXhpc3RpbmdQcm9ncmFtO1xuXHRcdFx0XHQrK3Byb2dyYW0udXNlZFRpbWVzO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHByb2dyYW0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cHJvZ3JhbSA9IG5ldyBXZWJHTFByb2dyYW0ocmVuZGVyZXIsIGNhY2hlS2V5LCBwYXJhbWV0ZXJzLCBiaW5kaW5nU3RhdGVzKTtcblx0XHRcdHByb2dyYW1zLnB1c2gocHJvZ3JhbSk7XG5cdFx0fVxuXHRcdHJldHVybiBwcm9ncmFtO1xuXHR9XG5cdGZ1bmN0aW9uIHJlbGVhc2VQcm9ncmFtKHByb2dyYW0pIHtcblx0XHRpZiAoLS1wcm9ncmFtLnVzZWRUaW1lcyA9PT0gMCkge1xuXHRcdFx0Ly8gUmVtb3ZlIGZyb20gdW5vcmRlcmVkIHNldFxuXHRcdFx0Y29uc3QgaSA9IHByb2dyYW1zLmluZGV4T2YocHJvZ3JhbSk7XG5cdFx0XHRwcm9ncmFtc1tpXSA9IHByb2dyYW1zW3Byb2dyYW1zLmxlbmd0aCAtIDFdO1xuXHRcdFx0cHJvZ3JhbXMucG9wKCk7XG5cblx0XHRcdC8vIEZyZWUgV2ViR0wgcmVzb3VyY2VzXG5cdFx0XHRwcm9ncmFtLmRlc3Ryb3koKTtcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gcmVsZWFzZVNoYWRlckNhY2hlKG1hdGVyaWFsKSB7XG5cdFx0X2N1c3RvbVNoYWRlcnMucmVtb3ZlKG1hdGVyaWFsKTtcblx0fVxuXHRmdW5jdGlvbiBkaXNwb3NlKCkge1xuXHRcdF9jdXN0b21TaGFkZXJzLmRpc3Bvc2UoKTtcblx0fVxuXHRyZXR1cm4ge1xuXHRcdGdldFBhcmFtZXRlcnM6IGdldFBhcmFtZXRlcnMsXG5cdFx0Z2V0UHJvZ3JhbUNhY2hlS2V5OiBnZXRQcm9ncmFtQ2FjaGVLZXksXG5cdFx0Z2V0VW5pZm9ybXM6IGdldFVuaWZvcm1zLFxuXHRcdGFjcXVpcmVQcm9ncmFtOiBhY3F1aXJlUHJvZ3JhbSxcblx0XHRyZWxlYXNlUHJvZ3JhbTogcmVsZWFzZVByb2dyYW0sXG5cdFx0cmVsZWFzZVNoYWRlckNhY2hlOiByZWxlYXNlU2hhZGVyQ2FjaGUsXG5cdFx0Ly8gRXhwb3NlZCBmb3IgcmVzb3VyY2UgbW9uaXRvcmluZyAmIGVycm9yIGZlZWRiYWNrIHZpYSByZW5kZXJlci5pbmZvOlxuXHRcdHByb2dyYW1zOiBwcm9ncmFtcyxcblx0XHRkaXNwb3NlOiBkaXNwb3NlXG5cdH07XG59XG5cbmZ1bmN0aW9uIFdlYkdMUHJvcGVydGllcygpIHtcblx0bGV0IHByb3BlcnRpZXMgPSBuZXcgV2Vha01hcCgpO1xuXHRmdW5jdGlvbiBnZXQob2JqZWN0KSB7XG5cdFx0bGV0IG1hcCA9IHByb3BlcnRpZXMuZ2V0KG9iamVjdCk7XG5cdFx0aWYgKG1hcCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRtYXAgPSB7fTtcblx0XHRcdHByb3BlcnRpZXMuc2V0KG9iamVjdCwgbWFwKTtcblx0XHR9XG5cdFx0cmV0dXJuIG1hcDtcblx0fVxuXHRmdW5jdGlvbiByZW1vdmUob2JqZWN0KSB7XG5cdFx0cHJvcGVydGllcy5kZWxldGUob2JqZWN0KTtcblx0fVxuXHRmdW5jdGlvbiB1cGRhdGUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG5cdFx0cHJvcGVydGllcy5nZXQob2JqZWN0KVtrZXldID0gdmFsdWU7XG5cdH1cblx0ZnVuY3Rpb24gZGlzcG9zZSgpIHtcblx0XHRwcm9wZXJ0aWVzID0gbmV3IFdlYWtNYXAoKTtcblx0fVxuXHRyZXR1cm4ge1xuXHRcdGdldDogZ2V0LFxuXHRcdHJlbW92ZTogcmVtb3ZlLFxuXHRcdHVwZGF0ZTogdXBkYXRlLFxuXHRcdGRpc3Bvc2U6IGRpc3Bvc2Vcblx0fTtcbn1cblxuZnVuY3Rpb24gcGFpbnRlclNvcnRTdGFibGUoYSwgYikge1xuXHRpZiAoYS5ncm91cE9yZGVyICE9PSBiLmdyb3VwT3JkZXIpIHtcblx0XHRyZXR1cm4gYS5ncm91cE9yZGVyIC0gYi5ncm91cE9yZGVyO1xuXHR9IGVsc2UgaWYgKGEucmVuZGVyT3JkZXIgIT09IGIucmVuZGVyT3JkZXIpIHtcblx0XHRyZXR1cm4gYS5yZW5kZXJPcmRlciAtIGIucmVuZGVyT3JkZXI7XG5cdH0gZWxzZSBpZiAoYS5tYXRlcmlhbC5pZCAhPT0gYi5tYXRlcmlhbC5pZCkge1xuXHRcdHJldHVybiBhLm1hdGVyaWFsLmlkIC0gYi5tYXRlcmlhbC5pZDtcblx0fSBlbHNlIGlmIChhLnogIT09IGIueikge1xuXHRcdHJldHVybiBhLnogLSBiLno7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIGEuaWQgLSBiLmlkO1xuXHR9XG59XG5mdW5jdGlvbiByZXZlcnNlUGFpbnRlclNvcnRTdGFibGUoYSwgYikge1xuXHRpZiAoYS5ncm91cE9yZGVyICE9PSBiLmdyb3VwT3JkZXIpIHtcblx0XHRyZXR1cm4gYS5ncm91cE9yZGVyIC0gYi5ncm91cE9yZGVyO1xuXHR9IGVsc2UgaWYgKGEucmVuZGVyT3JkZXIgIT09IGIucmVuZGVyT3JkZXIpIHtcblx0XHRyZXR1cm4gYS5yZW5kZXJPcmRlciAtIGIucmVuZGVyT3JkZXI7XG5cdH0gZWxzZSBpZiAoYS56ICE9PSBiLnopIHtcblx0XHRyZXR1cm4gYi56IC0gYS56O1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBhLmlkIC0gYi5pZDtcblx0fVxufVxuZnVuY3Rpb24gV2ViR0xSZW5kZXJMaXN0KCkge1xuXHRjb25zdCByZW5kZXJJdGVtcyA9IFtdO1xuXHRsZXQgcmVuZGVySXRlbXNJbmRleCA9IDA7XG5cdGNvbnN0IG9wYXF1ZSA9IFtdO1xuXHRjb25zdCB0cmFuc21pc3NpdmUgPSBbXTtcblx0Y29uc3QgdHJhbnNwYXJlbnQgPSBbXTtcblx0ZnVuY3Rpb24gaW5pdCgpIHtcblx0XHRyZW5kZXJJdGVtc0luZGV4ID0gMDtcblx0XHRvcGFxdWUubGVuZ3RoID0gMDtcblx0XHR0cmFuc21pc3NpdmUubGVuZ3RoID0gMDtcblx0XHR0cmFuc3BhcmVudC5sZW5ndGggPSAwO1xuXHR9XG5cdGZ1bmN0aW9uIGdldE5leHRSZW5kZXJJdGVtKG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cE9yZGVyLCB6LCBncm91cCkge1xuXHRcdGxldCByZW5kZXJJdGVtID0gcmVuZGVySXRlbXNbcmVuZGVySXRlbXNJbmRleF07XG5cdFx0aWYgKHJlbmRlckl0ZW0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmVuZGVySXRlbSA9IHtcblx0XHRcdFx0aWQ6IG9iamVjdC5pZCxcblx0XHRcdFx0b2JqZWN0OiBvYmplY3QsXG5cdFx0XHRcdGdlb21ldHJ5OiBnZW9tZXRyeSxcblx0XHRcdFx0bWF0ZXJpYWw6IG1hdGVyaWFsLFxuXHRcdFx0XHRncm91cE9yZGVyOiBncm91cE9yZGVyLFxuXHRcdFx0XHRyZW5kZXJPcmRlcjogb2JqZWN0LnJlbmRlck9yZGVyLFxuXHRcdFx0XHR6OiB6LFxuXHRcdFx0XHRncm91cDogZ3JvdXBcblx0XHRcdH07XG5cdFx0XHRyZW5kZXJJdGVtc1tyZW5kZXJJdGVtc0luZGV4XSA9IHJlbmRlckl0ZW07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlbmRlckl0ZW0uaWQgPSBvYmplY3QuaWQ7XG5cdFx0XHRyZW5kZXJJdGVtLm9iamVjdCA9IG9iamVjdDtcblx0XHRcdHJlbmRlckl0ZW0uZ2VvbWV0cnkgPSBnZW9tZXRyeTtcblx0XHRcdHJlbmRlckl0ZW0ubWF0ZXJpYWwgPSBtYXRlcmlhbDtcblx0XHRcdHJlbmRlckl0ZW0uZ3JvdXBPcmRlciA9IGdyb3VwT3JkZXI7XG5cdFx0XHRyZW5kZXJJdGVtLnJlbmRlck9yZGVyID0gb2JqZWN0LnJlbmRlck9yZGVyO1xuXHRcdFx0cmVuZGVySXRlbS56ID0gejtcblx0XHRcdHJlbmRlckl0ZW0uZ3JvdXAgPSBncm91cDtcblx0XHR9XG5cdFx0cmVuZGVySXRlbXNJbmRleCsrO1xuXHRcdHJldHVybiByZW5kZXJJdGVtO1xuXHR9XG5cdGZ1bmN0aW9uIHB1c2gob2JqZWN0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwT3JkZXIsIHosIGdyb3VwKSB7XG5cdFx0Y29uc3QgcmVuZGVySXRlbSA9IGdldE5leHRSZW5kZXJJdGVtKG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cE9yZGVyLCB6LCBncm91cCk7XG5cdFx0aWYgKG1hdGVyaWFsLnRyYW5zbWlzc2lvbiA+IDAuMCkge1xuXHRcdFx0dHJhbnNtaXNzaXZlLnB1c2gocmVuZGVySXRlbSk7XG5cdFx0fSBlbHNlIGlmIChtYXRlcmlhbC50cmFuc3BhcmVudCA9PT0gdHJ1ZSkge1xuXHRcdFx0dHJhbnNwYXJlbnQucHVzaChyZW5kZXJJdGVtKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0b3BhcXVlLnB1c2gocmVuZGVySXRlbSk7XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVuc2hpZnQob2JqZWN0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwT3JkZXIsIHosIGdyb3VwKSB7XG5cdFx0Y29uc3QgcmVuZGVySXRlbSA9IGdldE5leHRSZW5kZXJJdGVtKG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cE9yZGVyLCB6LCBncm91cCk7XG5cdFx0aWYgKG1hdGVyaWFsLnRyYW5zbWlzc2lvbiA+IDAuMCkge1xuXHRcdFx0dHJhbnNtaXNzaXZlLnVuc2hpZnQocmVuZGVySXRlbSk7XG5cdFx0fSBlbHNlIGlmIChtYXRlcmlhbC50cmFuc3BhcmVudCA9PT0gdHJ1ZSkge1xuXHRcdFx0dHJhbnNwYXJlbnQudW5zaGlmdChyZW5kZXJJdGVtKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0b3BhcXVlLnVuc2hpZnQocmVuZGVySXRlbSk7XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHNvcnQoY3VzdG9tT3BhcXVlU29ydCwgY3VzdG9tVHJhbnNwYXJlbnRTb3J0KSB7XG5cdFx0aWYgKG9wYXF1ZS5sZW5ndGggPiAxKSBvcGFxdWUuc29ydChjdXN0b21PcGFxdWVTb3J0IHx8IHBhaW50ZXJTb3J0U3RhYmxlKTtcblx0XHRpZiAodHJhbnNtaXNzaXZlLmxlbmd0aCA+IDEpIHRyYW5zbWlzc2l2ZS5zb3J0KGN1c3RvbVRyYW5zcGFyZW50U29ydCB8fCByZXZlcnNlUGFpbnRlclNvcnRTdGFibGUpO1xuXHRcdGlmICh0cmFuc3BhcmVudC5sZW5ndGggPiAxKSB0cmFuc3BhcmVudC5zb3J0KGN1c3RvbVRyYW5zcGFyZW50U29ydCB8fCByZXZlcnNlUGFpbnRlclNvcnRTdGFibGUpO1xuXHR9XG5cdGZ1bmN0aW9uIGZpbmlzaCgpIHtcblx0XHQvLyBDbGVhciByZWZlcmVuY2VzIGZyb20gaW5hY3RpdmUgcmVuZGVySXRlbXMgaW4gdGhlIGxpc3RcblxuXHRcdGZvciAobGV0IGkgPSByZW5kZXJJdGVtc0luZGV4LCBpbCA9IHJlbmRlckl0ZW1zLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdGNvbnN0IHJlbmRlckl0ZW0gPSByZW5kZXJJdGVtc1tpXTtcblx0XHRcdGlmIChyZW5kZXJJdGVtLmlkID09PSBudWxsKSBicmVhaztcblx0XHRcdHJlbmRlckl0ZW0uaWQgPSBudWxsO1xuXHRcdFx0cmVuZGVySXRlbS5vYmplY3QgPSBudWxsO1xuXHRcdFx0cmVuZGVySXRlbS5nZW9tZXRyeSA9IG51bGw7XG5cdFx0XHRyZW5kZXJJdGVtLm1hdGVyaWFsID0gbnVsbDtcblx0XHRcdHJlbmRlckl0ZW0uZ3JvdXAgPSBudWxsO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4ge1xuXHRcdG9wYXF1ZTogb3BhcXVlLFxuXHRcdHRyYW5zbWlzc2l2ZTogdHJhbnNtaXNzaXZlLFxuXHRcdHRyYW5zcGFyZW50OiB0cmFuc3BhcmVudCxcblx0XHRpbml0OiBpbml0LFxuXHRcdHB1c2g6IHB1c2gsXG5cdFx0dW5zaGlmdDogdW5zaGlmdCxcblx0XHRmaW5pc2g6IGZpbmlzaCxcblx0XHRzb3J0OiBzb3J0XG5cdH07XG59XG5mdW5jdGlvbiBXZWJHTFJlbmRlckxpc3RzKCkge1xuXHRsZXQgbGlzdHMgPSBuZXcgV2Vha01hcCgpO1xuXHRmdW5jdGlvbiBnZXQoc2NlbmUsIHJlbmRlckNhbGxEZXB0aCkge1xuXHRcdGNvbnN0IGxpc3RBcnJheSA9IGxpc3RzLmdldChzY2VuZSk7XG5cdFx0bGV0IGxpc3Q7XG5cdFx0aWYgKGxpc3RBcnJheSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRsaXN0ID0gbmV3IFdlYkdMUmVuZGVyTGlzdCgpO1xuXHRcdFx0bGlzdHMuc2V0KHNjZW5lLCBbbGlzdF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAocmVuZGVyQ2FsbERlcHRoID49IGxpc3RBcnJheS5sZW5ndGgpIHtcblx0XHRcdFx0bGlzdCA9IG5ldyBXZWJHTFJlbmRlckxpc3QoKTtcblx0XHRcdFx0bGlzdEFycmF5LnB1c2gobGlzdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsaXN0ID0gbGlzdEFycmF5W3JlbmRlckNhbGxEZXB0aF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBsaXN0O1xuXHR9XG5cdGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG5cdFx0bGlzdHMgPSBuZXcgV2Vha01hcCgpO1xuXHR9XG5cdHJldHVybiB7XG5cdFx0Z2V0OiBnZXQsXG5cdFx0ZGlzcG9zZTogZGlzcG9zZVxuXHR9O1xufVxuXG5mdW5jdGlvbiBVbmlmb3Jtc0NhY2hlKCkge1xuXHRjb25zdCBsaWdodHMgPSB7fTtcblx0cmV0dXJuIHtcblx0XHRnZXQ6IGZ1bmN0aW9uIChsaWdodCkge1xuXHRcdFx0aWYgKGxpZ2h0c1tsaWdodC5pZF0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRyZXR1cm4gbGlnaHRzW2xpZ2h0LmlkXTtcblx0XHRcdH1cblx0XHRcdGxldCB1bmlmb3Jtcztcblx0XHRcdHN3aXRjaCAobGlnaHQudHlwZSkge1xuXHRcdFx0XHRjYXNlICdEaXJlY3Rpb25hbExpZ2h0Jzpcblx0XHRcdFx0XHR1bmlmb3JtcyA9IHtcblx0XHRcdFx0XHRcdGRpcmVjdGlvbjogbmV3IFZlY3RvcjMoKSxcblx0XHRcdFx0XHRcdGNvbG9yOiBuZXcgQ29sb3IoKVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ1Nwb3RMaWdodCc6XG5cdFx0XHRcdFx0dW5pZm9ybXMgPSB7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbjogbmV3IFZlY3RvcjMoKSxcblx0XHRcdFx0XHRcdGRpcmVjdGlvbjogbmV3IFZlY3RvcjMoKSxcblx0XHRcdFx0XHRcdGNvbG9yOiBuZXcgQ29sb3IoKSxcblx0XHRcdFx0XHRcdGRpc3RhbmNlOiAwLFxuXHRcdFx0XHRcdFx0Y29uZUNvczogMCxcblx0XHRcdFx0XHRcdHBlbnVtYnJhQ29zOiAwLFxuXHRcdFx0XHRcdFx0ZGVjYXk6IDBcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdQb2ludExpZ2h0Jzpcblx0XHRcdFx0XHR1bmlmb3JtcyA9IHtcblx0XHRcdFx0XHRcdHBvc2l0aW9uOiBuZXcgVmVjdG9yMygpLFxuXHRcdFx0XHRcdFx0Y29sb3I6IG5ldyBDb2xvcigpLFxuXHRcdFx0XHRcdFx0ZGlzdGFuY2U6IDAsXG5cdFx0XHRcdFx0XHRkZWNheTogMFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ0hlbWlzcGhlcmVMaWdodCc6XG5cdFx0XHRcdFx0dW5pZm9ybXMgPSB7XG5cdFx0XHRcdFx0XHRkaXJlY3Rpb246IG5ldyBWZWN0b3IzKCksXG5cdFx0XHRcdFx0XHRza3lDb2xvcjogbmV3IENvbG9yKCksXG5cdFx0XHRcdFx0XHRncm91bmRDb2xvcjogbmV3IENvbG9yKClcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdSZWN0QXJlYUxpZ2h0Jzpcblx0XHRcdFx0XHR1bmlmb3JtcyA9IHtcblx0XHRcdFx0XHRcdGNvbG9yOiBuZXcgQ29sb3IoKSxcblx0XHRcdFx0XHRcdHBvc2l0aW9uOiBuZXcgVmVjdG9yMygpLFxuXHRcdFx0XHRcdFx0aGFsZldpZHRoOiBuZXcgVmVjdG9yMygpLFxuXHRcdFx0XHRcdFx0aGFsZkhlaWdodDogbmV3IFZlY3RvcjMoKVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRsaWdodHNbbGlnaHQuaWRdID0gdW5pZm9ybXM7XG5cdFx0XHRyZXR1cm4gdW5pZm9ybXM7XG5cdFx0fVxuXHR9O1xufVxuZnVuY3Rpb24gU2hhZG93VW5pZm9ybXNDYWNoZSgpIHtcblx0Y29uc3QgbGlnaHRzID0ge307XG5cdHJldHVybiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiAobGlnaHQpIHtcblx0XHRcdGlmIChsaWdodHNbbGlnaHQuaWRdICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cmV0dXJuIGxpZ2h0c1tsaWdodC5pZF07XG5cdFx0XHR9XG5cdFx0XHRsZXQgdW5pZm9ybXM7XG5cdFx0XHRzd2l0Y2ggKGxpZ2h0LnR5cGUpIHtcblx0XHRcdFx0Y2FzZSAnRGlyZWN0aW9uYWxMaWdodCc6XG5cdFx0XHRcdFx0dW5pZm9ybXMgPSB7XG5cdFx0XHRcdFx0XHRzaGFkb3dCaWFzOiAwLFxuXHRcdFx0XHRcdFx0c2hhZG93Tm9ybWFsQmlhczogMCxcblx0XHRcdFx0XHRcdHNoYWRvd1JhZGl1czogMSxcblx0XHRcdFx0XHRcdHNoYWRvd01hcFNpemU6IG5ldyBWZWN0b3IyKClcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdTcG90TGlnaHQnOlxuXHRcdFx0XHRcdHVuaWZvcm1zID0ge1xuXHRcdFx0XHRcdFx0c2hhZG93QmlhczogMCxcblx0XHRcdFx0XHRcdHNoYWRvd05vcm1hbEJpYXM6IDAsXG5cdFx0XHRcdFx0XHRzaGFkb3dSYWRpdXM6IDEsXG5cdFx0XHRcdFx0XHRzaGFkb3dNYXBTaXplOiBuZXcgVmVjdG9yMigpXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnUG9pbnRMaWdodCc6XG5cdFx0XHRcdFx0dW5pZm9ybXMgPSB7XG5cdFx0XHRcdFx0XHRzaGFkb3dCaWFzOiAwLFxuXHRcdFx0XHRcdFx0c2hhZG93Tm9ybWFsQmlhczogMCxcblx0XHRcdFx0XHRcdHNoYWRvd1JhZGl1czogMSxcblx0XHRcdFx0XHRcdHNoYWRvd01hcFNpemU6IG5ldyBWZWN0b3IyKCksXG5cdFx0XHRcdFx0XHRzaGFkb3dDYW1lcmFOZWFyOiAxLFxuXHRcdFx0XHRcdFx0c2hhZG93Q2FtZXJhRmFyOiAxMDAwXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHQvLyBUT0RPIChhYmVsbmF0aW9uKTogc2V0IFJlY3RBcmVhTGlnaHQgc2hhZG93IHVuaWZvcm1zXG5cdFx0XHR9XG5cblx0XHRcdGxpZ2h0c1tsaWdodC5pZF0gPSB1bmlmb3Jtcztcblx0XHRcdHJldHVybiB1bmlmb3Jtcztcblx0XHR9XG5cdH07XG59XG5sZXQgbmV4dFZlcnNpb24gPSAwO1xuZnVuY3Rpb24gc2hhZG93Q2FzdGluZ0FuZFRleHR1cmluZ0xpZ2h0c0ZpcnN0KGxpZ2h0QSwgbGlnaHRCKSB7XG5cdHJldHVybiAobGlnaHRCLmNhc3RTaGFkb3cgPyAyIDogMCkgLSAobGlnaHRBLmNhc3RTaGFkb3cgPyAyIDogMCkgKyAobGlnaHRCLm1hcCA/IDEgOiAwKSAtIChsaWdodEEubWFwID8gMSA6IDApO1xufVxuZnVuY3Rpb24gV2ViR0xMaWdodHMoZXh0ZW5zaW9ucywgY2FwYWJpbGl0aWVzKSB7XG5cdGNvbnN0IGNhY2hlID0gbmV3IFVuaWZvcm1zQ2FjaGUoKTtcblx0Y29uc3Qgc2hhZG93Q2FjaGUgPSBTaGFkb3dVbmlmb3Jtc0NhY2hlKCk7XG5cdGNvbnN0IHN0YXRlID0ge1xuXHRcdHZlcnNpb246IDAsXG5cdFx0aGFzaDoge1xuXHRcdFx0ZGlyZWN0aW9uYWxMZW5ndGg6IC0xLFxuXHRcdFx0cG9pbnRMZW5ndGg6IC0xLFxuXHRcdFx0c3BvdExlbmd0aDogLTEsXG5cdFx0XHRyZWN0QXJlYUxlbmd0aDogLTEsXG5cdFx0XHRoZW1pTGVuZ3RoOiAtMSxcblx0XHRcdG51bURpcmVjdGlvbmFsU2hhZG93czogLTEsXG5cdFx0XHRudW1Qb2ludFNoYWRvd3M6IC0xLFxuXHRcdFx0bnVtU3BvdFNoYWRvd3M6IC0xLFxuXHRcdFx0bnVtU3BvdE1hcHM6IC0xXG5cdFx0fSxcblx0XHRhbWJpZW50OiBbMCwgMCwgMF0sXG5cdFx0cHJvYmU6IFtdLFxuXHRcdGRpcmVjdGlvbmFsOiBbXSxcblx0XHRkaXJlY3Rpb25hbFNoYWRvdzogW10sXG5cdFx0ZGlyZWN0aW9uYWxTaGFkb3dNYXA6IFtdLFxuXHRcdGRpcmVjdGlvbmFsU2hhZG93TWF0cml4OiBbXSxcblx0XHRzcG90OiBbXSxcblx0XHRzcG90TGlnaHRNYXA6IFtdLFxuXHRcdHNwb3RTaGFkb3c6IFtdLFxuXHRcdHNwb3RTaGFkb3dNYXA6IFtdLFxuXHRcdHNwb3RMaWdodE1hdHJpeDogW10sXG5cdFx0cmVjdEFyZWE6IFtdLFxuXHRcdHJlY3RBcmVhTFRDMTogbnVsbCxcblx0XHRyZWN0QXJlYUxUQzI6IG51bGwsXG5cdFx0cG9pbnQ6IFtdLFxuXHRcdHBvaW50U2hhZG93OiBbXSxcblx0XHRwb2ludFNoYWRvd01hcDogW10sXG5cdFx0cG9pbnRTaGFkb3dNYXRyaXg6IFtdLFxuXHRcdGhlbWk6IFtdLFxuXHRcdG51bVNwb3RMaWdodFNoYWRvd3NXaXRoTWFwczogMFxuXHR9O1xuXHRmb3IgKGxldCBpID0gMDsgaSA8IDk7IGkrKykgc3RhdGUucHJvYmUucHVzaChuZXcgVmVjdG9yMygpKTtcblx0Y29uc3QgdmVjdG9yMyA9IG5ldyBWZWN0b3IzKCk7XG5cdGNvbnN0IG1hdHJpeDQgPSBuZXcgTWF0cml4NCgpO1xuXHRjb25zdCBtYXRyaXg0MiA9IG5ldyBNYXRyaXg0KCk7XG5cdGZ1bmN0aW9uIHNldHVwKGxpZ2h0cywgcGh5c2ljYWxseUNvcnJlY3RMaWdodHMpIHtcblx0XHRsZXQgciA9IDAsXG5cdFx0XHRnID0gMCxcblx0XHRcdGIgPSAwO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgOTsgaSsrKSBzdGF0ZS5wcm9iZVtpXS5zZXQoMCwgMCwgMCk7XG5cdFx0bGV0IGRpcmVjdGlvbmFsTGVuZ3RoID0gMDtcblx0XHRsZXQgcG9pbnRMZW5ndGggPSAwO1xuXHRcdGxldCBzcG90TGVuZ3RoID0gMDtcblx0XHRsZXQgcmVjdEFyZWFMZW5ndGggPSAwO1xuXHRcdGxldCBoZW1pTGVuZ3RoID0gMDtcblx0XHRsZXQgbnVtRGlyZWN0aW9uYWxTaGFkb3dzID0gMDtcblx0XHRsZXQgbnVtUG9pbnRTaGFkb3dzID0gMDtcblx0XHRsZXQgbnVtU3BvdFNoYWRvd3MgPSAwO1xuXHRcdGxldCBudW1TcG90TWFwcyA9IDA7XG5cdFx0bGV0IG51bVNwb3RTaGFkb3dzV2l0aE1hcHMgPSAwO1xuXG5cdFx0Ly8gb3JkZXJpbmcgOiBbc2hhZG93IGNhc3RpbmcgKyBtYXAgdGV4dHVyaW5nLCBtYXAgdGV4dHVyaW5nLCBzaGFkb3cgY2FzdGluZywgbm9uZSBdXG5cdFx0bGlnaHRzLnNvcnQoc2hhZG93Q2FzdGluZ0FuZFRleHR1cmluZ0xpZ2h0c0ZpcnN0KTtcblxuXHRcdC8vIGFydGlzdC1mcmllbmRseSBsaWdodCBpbnRlbnNpdHkgc2NhbGluZyBmYWN0b3Jcblx0XHRjb25zdCBzY2FsZUZhY3RvciA9IHBoeXNpY2FsbHlDb3JyZWN0TGlnaHRzICE9PSB0cnVlID8gTWF0aC5QSSA6IDE7XG5cdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBsaWdodHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRjb25zdCBsaWdodCA9IGxpZ2h0c1tpXTtcblx0XHRcdGNvbnN0IGNvbG9yID0gbGlnaHQuY29sb3I7XG5cdFx0XHRjb25zdCBpbnRlbnNpdHkgPSBsaWdodC5pbnRlbnNpdHk7XG5cdFx0XHRjb25zdCBkaXN0YW5jZSA9IGxpZ2h0LmRpc3RhbmNlO1xuXHRcdFx0Y29uc3Qgc2hhZG93TWFwID0gbGlnaHQuc2hhZG93ICYmIGxpZ2h0LnNoYWRvdy5tYXAgPyBsaWdodC5zaGFkb3cubWFwLnRleHR1cmUgOiBudWxsO1xuXHRcdFx0aWYgKGxpZ2h0LmlzQW1iaWVudExpZ2h0KSB7XG5cdFx0XHRcdHIgKz0gY29sb3IuciAqIGludGVuc2l0eSAqIHNjYWxlRmFjdG9yO1xuXHRcdFx0XHRnICs9IGNvbG9yLmcgKiBpbnRlbnNpdHkgKiBzY2FsZUZhY3Rvcjtcblx0XHRcdFx0YiArPSBjb2xvci5iICogaW50ZW5zaXR5ICogc2NhbGVGYWN0b3I7XG5cdFx0XHR9IGVsc2UgaWYgKGxpZ2h0LmlzTGlnaHRQcm9iZSkge1xuXHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IDk7IGorKykge1xuXHRcdFx0XHRcdHN0YXRlLnByb2JlW2pdLmFkZFNjYWxlZFZlY3RvcihsaWdodC5zaC5jb2VmZmljaWVudHNbal0sIGludGVuc2l0eSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAobGlnaHQuaXNEaXJlY3Rpb25hbExpZ2h0KSB7XG5cdFx0XHRcdGNvbnN0IHVuaWZvcm1zID0gY2FjaGUuZ2V0KGxpZ2h0KTtcblx0XHRcdFx0dW5pZm9ybXMuY29sb3IuY29weShsaWdodC5jb2xvcikubXVsdGlwbHlTY2FsYXIobGlnaHQuaW50ZW5zaXR5ICogc2NhbGVGYWN0b3IpO1xuXHRcdFx0XHRpZiAobGlnaHQuY2FzdFNoYWRvdykge1xuXHRcdFx0XHRcdGNvbnN0IHNoYWRvdyA9IGxpZ2h0LnNoYWRvdztcblx0XHRcdFx0XHRjb25zdCBzaGFkb3dVbmlmb3JtcyA9IHNoYWRvd0NhY2hlLmdldChsaWdodCk7XG5cdFx0XHRcdFx0c2hhZG93VW5pZm9ybXMuc2hhZG93QmlhcyA9IHNoYWRvdy5iaWFzO1xuXHRcdFx0XHRcdHNoYWRvd1VuaWZvcm1zLnNoYWRvd05vcm1hbEJpYXMgPSBzaGFkb3cubm9ybWFsQmlhcztcblx0XHRcdFx0XHRzaGFkb3dVbmlmb3Jtcy5zaGFkb3dSYWRpdXMgPSBzaGFkb3cucmFkaXVzO1xuXHRcdFx0XHRcdHNoYWRvd1VuaWZvcm1zLnNoYWRvd01hcFNpemUgPSBzaGFkb3cubWFwU2l6ZTtcblx0XHRcdFx0XHRzdGF0ZS5kaXJlY3Rpb25hbFNoYWRvd1tkaXJlY3Rpb25hbExlbmd0aF0gPSBzaGFkb3dVbmlmb3Jtcztcblx0XHRcdFx0XHRzdGF0ZS5kaXJlY3Rpb25hbFNoYWRvd01hcFtkaXJlY3Rpb25hbExlbmd0aF0gPSBzaGFkb3dNYXA7XG5cdFx0XHRcdFx0c3RhdGUuZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXhbZGlyZWN0aW9uYWxMZW5ndGhdID0gbGlnaHQuc2hhZG93Lm1hdHJpeDtcblx0XHRcdFx0XHRudW1EaXJlY3Rpb25hbFNoYWRvd3MrKztcblx0XHRcdFx0fVxuXHRcdFx0XHRzdGF0ZS5kaXJlY3Rpb25hbFtkaXJlY3Rpb25hbExlbmd0aF0gPSB1bmlmb3Jtcztcblx0XHRcdFx0ZGlyZWN0aW9uYWxMZW5ndGgrKztcblx0XHRcdH0gZWxzZSBpZiAobGlnaHQuaXNTcG90TGlnaHQpIHtcblx0XHRcdFx0Y29uc3QgdW5pZm9ybXMgPSBjYWNoZS5nZXQobGlnaHQpO1xuXHRcdFx0XHR1bmlmb3Jtcy5wb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24obGlnaHQubWF0cml4V29ybGQpO1xuXHRcdFx0XHR1bmlmb3Jtcy5jb2xvci5jb3B5KGNvbG9yKS5tdWx0aXBseVNjYWxhcihpbnRlbnNpdHkgKiBzY2FsZUZhY3Rvcik7XG5cdFx0XHRcdHVuaWZvcm1zLmRpc3RhbmNlID0gZGlzdGFuY2U7XG5cdFx0XHRcdHVuaWZvcm1zLmNvbmVDb3MgPSBNYXRoLmNvcyhsaWdodC5hbmdsZSk7XG5cdFx0XHRcdHVuaWZvcm1zLnBlbnVtYnJhQ29zID0gTWF0aC5jb3MobGlnaHQuYW5nbGUgKiAoMSAtIGxpZ2h0LnBlbnVtYnJhKSk7XG5cdFx0XHRcdHVuaWZvcm1zLmRlY2F5ID0gbGlnaHQuZGVjYXk7XG5cdFx0XHRcdHN0YXRlLnNwb3Rbc3BvdExlbmd0aF0gPSB1bmlmb3Jtcztcblx0XHRcdFx0Y29uc3Qgc2hhZG93ID0gbGlnaHQuc2hhZG93O1xuXHRcdFx0XHRpZiAobGlnaHQubWFwKSB7XG5cdFx0XHRcdFx0c3RhdGUuc3BvdExpZ2h0TWFwW251bVNwb3RNYXBzXSA9IGxpZ2h0Lm1hcDtcblx0XHRcdFx0XHRudW1TcG90TWFwcysrO1xuXG5cdFx0XHRcdFx0Ly8gbWFrZSBzdXJlIHRoZSBsaWdodE1hdHJpeCBpcyB1cCB0byBkYXRlXG5cdFx0XHRcdFx0Ly8gVE9ETyA6IGRvIGl0IGlmIHJlcXVpcmVkIG9ubHlcblx0XHRcdFx0XHRzaGFkb3cudXBkYXRlTWF0cmljZXMobGlnaHQpO1xuXHRcdFx0XHRcdGlmIChsaWdodC5jYXN0U2hhZG93KSBudW1TcG90U2hhZG93c1dpdGhNYXBzKys7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RhdGUuc3BvdExpZ2h0TWF0cml4W3Nwb3RMZW5ndGhdID0gc2hhZG93Lm1hdHJpeDtcblx0XHRcdFx0aWYgKGxpZ2h0LmNhc3RTaGFkb3cpIHtcblx0XHRcdFx0XHRjb25zdCBzaGFkb3dVbmlmb3JtcyA9IHNoYWRvd0NhY2hlLmdldChsaWdodCk7XG5cdFx0XHRcdFx0c2hhZG93VW5pZm9ybXMuc2hhZG93QmlhcyA9IHNoYWRvdy5iaWFzO1xuXHRcdFx0XHRcdHNoYWRvd1VuaWZvcm1zLnNoYWRvd05vcm1hbEJpYXMgPSBzaGFkb3cubm9ybWFsQmlhcztcblx0XHRcdFx0XHRzaGFkb3dVbmlmb3Jtcy5zaGFkb3dSYWRpdXMgPSBzaGFkb3cucmFkaXVzO1xuXHRcdFx0XHRcdHNoYWRvd1VuaWZvcm1zLnNoYWRvd01hcFNpemUgPSBzaGFkb3cubWFwU2l6ZTtcblx0XHRcdFx0XHRzdGF0ZS5zcG90U2hhZG93W3Nwb3RMZW5ndGhdID0gc2hhZG93VW5pZm9ybXM7XG5cdFx0XHRcdFx0c3RhdGUuc3BvdFNoYWRvd01hcFtzcG90TGVuZ3RoXSA9IHNoYWRvd01hcDtcblx0XHRcdFx0XHRudW1TcG90U2hhZG93cysrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNwb3RMZW5ndGgrKztcblx0XHRcdH0gZWxzZSBpZiAobGlnaHQuaXNSZWN0QXJlYUxpZ2h0KSB7XG5cdFx0XHRcdGNvbnN0IHVuaWZvcm1zID0gY2FjaGUuZ2V0KGxpZ2h0KTtcblxuXHRcdFx0XHQvLyAoYSkgaW50ZW5zaXR5IGlzIHRoZSB0b3RhbCB2aXNpYmxlIGxpZ2h0IGVtaXR0ZWRcblx0XHRcdFx0Ly91bmlmb3Jtcy5jb2xvci5jb3B5KCBjb2xvciApLm11bHRpcGx5U2NhbGFyKCBpbnRlbnNpdHkgLyAoIGxpZ2h0LndpZHRoICogbGlnaHQuaGVpZ2h0ICogTWF0aC5QSSApICk7XG5cblx0XHRcdFx0Ly8gKGIpIGludGVuc2l0eSBpcyB0aGUgYnJpZ2h0bmVzcyBvZiB0aGUgbGlnaHRcblx0XHRcdFx0dW5pZm9ybXMuY29sb3IuY29weShjb2xvcikubXVsdGlwbHlTY2FsYXIoaW50ZW5zaXR5KTtcblx0XHRcdFx0dW5pZm9ybXMuaGFsZldpZHRoLnNldChsaWdodC53aWR0aCAqIDAuNSwgMC4wLCAwLjApO1xuXHRcdFx0XHR1bmlmb3Jtcy5oYWxmSGVpZ2h0LnNldCgwLjAsIGxpZ2h0LmhlaWdodCAqIDAuNSwgMC4wKTtcblx0XHRcdFx0c3RhdGUucmVjdEFyZWFbcmVjdEFyZWFMZW5ndGhdID0gdW5pZm9ybXM7XG5cdFx0XHRcdHJlY3RBcmVhTGVuZ3RoKys7XG5cdFx0XHR9IGVsc2UgaWYgKGxpZ2h0LmlzUG9pbnRMaWdodCkge1xuXHRcdFx0XHRjb25zdCB1bmlmb3JtcyA9IGNhY2hlLmdldChsaWdodCk7XG5cdFx0XHRcdHVuaWZvcm1zLmNvbG9yLmNvcHkobGlnaHQuY29sb3IpLm11bHRpcGx5U2NhbGFyKGxpZ2h0LmludGVuc2l0eSAqIHNjYWxlRmFjdG9yKTtcblx0XHRcdFx0dW5pZm9ybXMuZGlzdGFuY2UgPSBsaWdodC5kaXN0YW5jZTtcblx0XHRcdFx0dW5pZm9ybXMuZGVjYXkgPSBsaWdodC5kZWNheTtcblx0XHRcdFx0aWYgKGxpZ2h0LmNhc3RTaGFkb3cpIHtcblx0XHRcdFx0XHRjb25zdCBzaGFkb3cgPSBsaWdodC5zaGFkb3c7XG5cdFx0XHRcdFx0Y29uc3Qgc2hhZG93VW5pZm9ybXMgPSBzaGFkb3dDYWNoZS5nZXQobGlnaHQpO1xuXHRcdFx0XHRcdHNoYWRvd1VuaWZvcm1zLnNoYWRvd0JpYXMgPSBzaGFkb3cuYmlhcztcblx0XHRcdFx0XHRzaGFkb3dVbmlmb3Jtcy5zaGFkb3dOb3JtYWxCaWFzID0gc2hhZG93Lm5vcm1hbEJpYXM7XG5cdFx0XHRcdFx0c2hhZG93VW5pZm9ybXMuc2hhZG93UmFkaXVzID0gc2hhZG93LnJhZGl1cztcblx0XHRcdFx0XHRzaGFkb3dVbmlmb3Jtcy5zaGFkb3dNYXBTaXplID0gc2hhZG93Lm1hcFNpemU7XG5cdFx0XHRcdFx0c2hhZG93VW5pZm9ybXMuc2hhZG93Q2FtZXJhTmVhciA9IHNoYWRvdy5jYW1lcmEubmVhcjtcblx0XHRcdFx0XHRzaGFkb3dVbmlmb3Jtcy5zaGFkb3dDYW1lcmFGYXIgPSBzaGFkb3cuY2FtZXJhLmZhcjtcblx0XHRcdFx0XHRzdGF0ZS5wb2ludFNoYWRvd1twb2ludExlbmd0aF0gPSBzaGFkb3dVbmlmb3Jtcztcblx0XHRcdFx0XHRzdGF0ZS5wb2ludFNoYWRvd01hcFtwb2ludExlbmd0aF0gPSBzaGFkb3dNYXA7XG5cdFx0XHRcdFx0c3RhdGUucG9pbnRTaGFkb3dNYXRyaXhbcG9pbnRMZW5ndGhdID0gbGlnaHQuc2hhZG93Lm1hdHJpeDtcblx0XHRcdFx0XHRudW1Qb2ludFNoYWRvd3MrKztcblx0XHRcdFx0fVxuXHRcdFx0XHRzdGF0ZS5wb2ludFtwb2ludExlbmd0aF0gPSB1bmlmb3Jtcztcblx0XHRcdFx0cG9pbnRMZW5ndGgrKztcblx0XHRcdH0gZWxzZSBpZiAobGlnaHQuaXNIZW1pc3BoZXJlTGlnaHQpIHtcblx0XHRcdFx0Y29uc3QgdW5pZm9ybXMgPSBjYWNoZS5nZXQobGlnaHQpO1xuXHRcdFx0XHR1bmlmb3Jtcy5za3lDb2xvci5jb3B5KGxpZ2h0LmNvbG9yKS5tdWx0aXBseVNjYWxhcihpbnRlbnNpdHkgKiBzY2FsZUZhY3Rvcik7XG5cdFx0XHRcdHVuaWZvcm1zLmdyb3VuZENvbG9yLmNvcHkobGlnaHQuZ3JvdW5kQ29sb3IpLm11bHRpcGx5U2NhbGFyKGludGVuc2l0eSAqIHNjYWxlRmFjdG9yKTtcblx0XHRcdFx0c3RhdGUuaGVtaVtoZW1pTGVuZ3RoXSA9IHVuaWZvcm1zO1xuXHRcdFx0XHRoZW1pTGVuZ3RoKys7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChyZWN0QXJlYUxlbmd0aCA+IDApIHtcblx0XHRcdGlmIChjYXBhYmlsaXRpZXMuaXNXZWJHTDIpIHtcblx0XHRcdFx0Ly8gV2ViR0wgMlxuXG5cdFx0XHRcdHN0YXRlLnJlY3RBcmVhTFRDMSA9IFVuaWZvcm1zTGliLkxUQ19GTE9BVF8xO1xuXHRcdFx0XHRzdGF0ZS5yZWN0QXJlYUxUQzIgPSBVbmlmb3Jtc0xpYi5MVENfRkxPQVRfMjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIFdlYkdMIDFcblxuXHRcdFx0XHRpZiAoZXh0ZW5zaW9ucy5oYXMoJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicpID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0c3RhdGUucmVjdEFyZWFMVEMxID0gVW5pZm9ybXNMaWIuTFRDX0ZMT0FUXzE7XG5cdFx0XHRcdFx0c3RhdGUucmVjdEFyZWFMVEMyID0gVW5pZm9ybXNMaWIuTFRDX0ZMT0FUXzI7XG5cdFx0XHRcdH0gZWxzZSBpZiAoZXh0ZW5zaW9ucy5oYXMoJ09FU190ZXh0dXJlX2hhbGZfZmxvYXRfbGluZWFyJykgPT09IHRydWUpIHtcblx0XHRcdFx0XHRzdGF0ZS5yZWN0QXJlYUxUQzEgPSBVbmlmb3Jtc0xpYi5MVENfSEFMRl8xO1xuXHRcdFx0XHRcdHN0YXRlLnJlY3RBcmVhTFRDMiA9IFVuaWZvcm1zTGliLkxUQ19IQUxGXzI7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuV2ViR0xSZW5kZXJlcjogVW5hYmxlIHRvIHVzZSBSZWN0QXJlYUxpZ2h0LiBNaXNzaW5nIFdlYkdMIGV4dGVuc2lvbnMuJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0c3RhdGUuYW1iaWVudFswXSA9IHI7XG5cdFx0c3RhdGUuYW1iaWVudFsxXSA9IGc7XG5cdFx0c3RhdGUuYW1iaWVudFsyXSA9IGI7XG5cdFx0Y29uc3QgaGFzaCA9IHN0YXRlLmhhc2g7XG5cdFx0aWYgKGhhc2guZGlyZWN0aW9uYWxMZW5ndGggIT09IGRpcmVjdGlvbmFsTGVuZ3RoIHx8IGhhc2gucG9pbnRMZW5ndGggIT09IHBvaW50TGVuZ3RoIHx8IGhhc2guc3BvdExlbmd0aCAhPT0gc3BvdExlbmd0aCB8fCBoYXNoLnJlY3RBcmVhTGVuZ3RoICE9PSByZWN0QXJlYUxlbmd0aCB8fCBoYXNoLmhlbWlMZW5ndGggIT09IGhlbWlMZW5ndGggfHwgaGFzaC5udW1EaXJlY3Rpb25hbFNoYWRvd3MgIT09IG51bURpcmVjdGlvbmFsU2hhZG93cyB8fCBoYXNoLm51bVBvaW50U2hhZG93cyAhPT0gbnVtUG9pbnRTaGFkb3dzIHx8IGhhc2gubnVtU3BvdFNoYWRvd3MgIT09IG51bVNwb3RTaGFkb3dzIHx8IGhhc2gubnVtU3BvdE1hcHMgIT09IG51bVNwb3RNYXBzKSB7XG5cdFx0XHRzdGF0ZS5kaXJlY3Rpb25hbC5sZW5ndGggPSBkaXJlY3Rpb25hbExlbmd0aDtcblx0XHRcdHN0YXRlLnNwb3QubGVuZ3RoID0gc3BvdExlbmd0aDtcblx0XHRcdHN0YXRlLnJlY3RBcmVhLmxlbmd0aCA9IHJlY3RBcmVhTGVuZ3RoO1xuXHRcdFx0c3RhdGUucG9pbnQubGVuZ3RoID0gcG9pbnRMZW5ndGg7XG5cdFx0XHRzdGF0ZS5oZW1pLmxlbmd0aCA9IGhlbWlMZW5ndGg7XG5cdFx0XHRzdGF0ZS5kaXJlY3Rpb25hbFNoYWRvdy5sZW5ndGggPSBudW1EaXJlY3Rpb25hbFNoYWRvd3M7XG5cdFx0XHRzdGF0ZS5kaXJlY3Rpb25hbFNoYWRvd01hcC5sZW5ndGggPSBudW1EaXJlY3Rpb25hbFNoYWRvd3M7XG5cdFx0XHRzdGF0ZS5wb2ludFNoYWRvdy5sZW5ndGggPSBudW1Qb2ludFNoYWRvd3M7XG5cdFx0XHRzdGF0ZS5wb2ludFNoYWRvd01hcC5sZW5ndGggPSBudW1Qb2ludFNoYWRvd3M7XG5cdFx0XHRzdGF0ZS5zcG90U2hhZG93Lmxlbmd0aCA9IG51bVNwb3RTaGFkb3dzO1xuXHRcdFx0c3RhdGUuc3BvdFNoYWRvd01hcC5sZW5ndGggPSBudW1TcG90U2hhZG93cztcblx0XHRcdHN0YXRlLmRpcmVjdGlvbmFsU2hhZG93TWF0cml4Lmxlbmd0aCA9IG51bURpcmVjdGlvbmFsU2hhZG93cztcblx0XHRcdHN0YXRlLnBvaW50U2hhZG93TWF0cml4Lmxlbmd0aCA9IG51bVBvaW50U2hhZG93cztcblx0XHRcdHN0YXRlLnNwb3RMaWdodE1hdHJpeC5sZW5ndGggPSBudW1TcG90U2hhZG93cyArIG51bVNwb3RNYXBzIC0gbnVtU3BvdFNoYWRvd3NXaXRoTWFwcztcblx0XHRcdHN0YXRlLnNwb3RMaWdodE1hcC5sZW5ndGggPSBudW1TcG90TWFwcztcblx0XHRcdHN0YXRlLm51bVNwb3RMaWdodFNoYWRvd3NXaXRoTWFwcyA9IG51bVNwb3RTaGFkb3dzV2l0aE1hcHM7XG5cdFx0XHRoYXNoLmRpcmVjdGlvbmFsTGVuZ3RoID0gZGlyZWN0aW9uYWxMZW5ndGg7XG5cdFx0XHRoYXNoLnBvaW50TGVuZ3RoID0gcG9pbnRMZW5ndGg7XG5cdFx0XHRoYXNoLnNwb3RMZW5ndGggPSBzcG90TGVuZ3RoO1xuXHRcdFx0aGFzaC5yZWN0QXJlYUxlbmd0aCA9IHJlY3RBcmVhTGVuZ3RoO1xuXHRcdFx0aGFzaC5oZW1pTGVuZ3RoID0gaGVtaUxlbmd0aDtcblx0XHRcdGhhc2gubnVtRGlyZWN0aW9uYWxTaGFkb3dzID0gbnVtRGlyZWN0aW9uYWxTaGFkb3dzO1xuXHRcdFx0aGFzaC5udW1Qb2ludFNoYWRvd3MgPSBudW1Qb2ludFNoYWRvd3M7XG5cdFx0XHRoYXNoLm51bVNwb3RTaGFkb3dzID0gbnVtU3BvdFNoYWRvd3M7XG5cdFx0XHRoYXNoLm51bVNwb3RNYXBzID0gbnVtU3BvdE1hcHM7XG5cdFx0XHRzdGF0ZS52ZXJzaW9uID0gbmV4dFZlcnNpb24rKztcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gc2V0dXBWaWV3KGxpZ2h0cywgY2FtZXJhKSB7XG5cdFx0bGV0IGRpcmVjdGlvbmFsTGVuZ3RoID0gMDtcblx0XHRsZXQgcG9pbnRMZW5ndGggPSAwO1xuXHRcdGxldCBzcG90TGVuZ3RoID0gMDtcblx0XHRsZXQgcmVjdEFyZWFMZW5ndGggPSAwO1xuXHRcdGxldCBoZW1pTGVuZ3RoID0gMDtcblx0XHRjb25zdCB2aWV3TWF0cml4ID0gY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZTtcblx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGxpZ2h0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGNvbnN0IGxpZ2h0ID0gbGlnaHRzW2ldO1xuXHRcdFx0aWYgKGxpZ2h0LmlzRGlyZWN0aW9uYWxMaWdodCkge1xuXHRcdFx0XHRjb25zdCB1bmlmb3JtcyA9IHN0YXRlLmRpcmVjdGlvbmFsW2RpcmVjdGlvbmFsTGVuZ3RoXTtcblx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbihsaWdodC5tYXRyaXhXb3JsZCk7XG5cdFx0XHRcdHZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCk7XG5cdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi5zdWIodmVjdG9yMyk7XG5cdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi50cmFuc2Zvcm1EaXJlY3Rpb24odmlld01hdHJpeCk7XG5cdFx0XHRcdGRpcmVjdGlvbmFsTGVuZ3RoKys7XG5cdFx0XHR9IGVsc2UgaWYgKGxpZ2h0LmlzU3BvdExpZ2h0KSB7XG5cdFx0XHRcdGNvbnN0IHVuaWZvcm1zID0gc3RhdGUuc3BvdFtzcG90TGVuZ3RoXTtcblx0XHRcdFx0dW5pZm9ybXMucG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGxpZ2h0Lm1hdHJpeFdvcmxkKTtcblx0XHRcdFx0dW5pZm9ybXMucG9zaXRpb24uYXBwbHlNYXRyaXg0KHZpZXdNYXRyaXgpO1xuXHRcdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGxpZ2h0Lm1hdHJpeFdvcmxkKTtcblx0XHRcdFx0dmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24obGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkKTtcblx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uLnN1Yih2ZWN0b3IzKTtcblx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbih2aWV3TWF0cml4KTtcblx0XHRcdFx0c3BvdExlbmd0aCsrO1xuXHRcdFx0fSBlbHNlIGlmIChsaWdodC5pc1JlY3RBcmVhTGlnaHQpIHtcblx0XHRcdFx0Y29uc3QgdW5pZm9ybXMgPSBzdGF0ZS5yZWN0QXJlYVtyZWN0QXJlYUxlbmd0aF07XG5cdFx0XHRcdHVuaWZvcm1zLnBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbihsaWdodC5tYXRyaXhXb3JsZCk7XG5cdFx0XHRcdHVuaWZvcm1zLnBvc2l0aW9uLmFwcGx5TWF0cml4NCh2aWV3TWF0cml4KTtcblxuXHRcdFx0XHQvLyBleHRyYWN0IGxvY2FsIHJvdGF0aW9uIG9mIGxpZ2h0IHRvIGRlcml2ZSB3aWR0aC9oZWlnaHQgaGFsZiB2ZWN0b3JzXG5cdFx0XHRcdG1hdHJpeDQyLmlkZW50aXR5KCk7XG5cdFx0XHRcdG1hdHJpeDQuY29weShsaWdodC5tYXRyaXhXb3JsZCk7XG5cdFx0XHRcdG1hdHJpeDQucHJlbXVsdGlwbHkodmlld01hdHJpeCk7XG5cdFx0XHRcdG1hdHJpeDQyLmV4dHJhY3RSb3RhdGlvbihtYXRyaXg0KTtcblx0XHRcdFx0dW5pZm9ybXMuaGFsZldpZHRoLnNldChsaWdodC53aWR0aCAqIDAuNSwgMC4wLCAwLjApO1xuXHRcdFx0XHR1bmlmb3Jtcy5oYWxmSGVpZ2h0LnNldCgwLjAsIGxpZ2h0LmhlaWdodCAqIDAuNSwgMC4wKTtcblx0XHRcdFx0dW5pZm9ybXMuaGFsZldpZHRoLmFwcGx5TWF0cml4NChtYXRyaXg0Mik7XG5cdFx0XHRcdHVuaWZvcm1zLmhhbGZIZWlnaHQuYXBwbHlNYXRyaXg0KG1hdHJpeDQyKTtcblx0XHRcdFx0cmVjdEFyZWFMZW5ndGgrKztcblx0XHRcdH0gZWxzZSBpZiAobGlnaHQuaXNQb2ludExpZ2h0KSB7XG5cdFx0XHRcdGNvbnN0IHVuaWZvcm1zID0gc3RhdGUucG9pbnRbcG9pbnRMZW5ndGhdO1xuXHRcdFx0XHR1bmlmb3Jtcy5wb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24obGlnaHQubWF0cml4V29ybGQpO1xuXHRcdFx0XHR1bmlmb3Jtcy5wb3NpdGlvbi5hcHBseU1hdHJpeDQodmlld01hdHJpeCk7XG5cdFx0XHRcdHBvaW50TGVuZ3RoKys7XG5cdFx0XHR9IGVsc2UgaWYgKGxpZ2h0LmlzSGVtaXNwaGVyZUxpZ2h0KSB7XG5cdFx0XHRcdGNvbnN0IHVuaWZvcm1zID0gc3RhdGUuaGVtaVtoZW1pTGVuZ3RoXTtcblx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbihsaWdodC5tYXRyaXhXb3JsZCk7XG5cdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi50cmFuc2Zvcm1EaXJlY3Rpb24odmlld01hdHJpeCk7XG5cdFx0XHRcdGhlbWlMZW5ndGgrKztcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHtcblx0XHRzZXR1cDogc2V0dXAsXG5cdFx0c2V0dXBWaWV3OiBzZXR1cFZpZXcsXG5cdFx0c3RhdGU6IHN0YXRlXG5cdH07XG59XG5cbmZ1bmN0aW9uIFdlYkdMUmVuZGVyU3RhdGUoZXh0ZW5zaW9ucywgY2FwYWJpbGl0aWVzKSB7XG5cdGNvbnN0IGxpZ2h0cyA9IG5ldyBXZWJHTExpZ2h0cyhleHRlbnNpb25zLCBjYXBhYmlsaXRpZXMpO1xuXHRjb25zdCBsaWdodHNBcnJheSA9IFtdO1xuXHRjb25zdCBzaGFkb3dzQXJyYXkgPSBbXTtcblx0ZnVuY3Rpb24gaW5pdCgpIHtcblx0XHRsaWdodHNBcnJheS5sZW5ndGggPSAwO1xuXHRcdHNoYWRvd3NBcnJheS5sZW5ndGggPSAwO1xuXHR9XG5cdGZ1bmN0aW9uIHB1c2hMaWdodChsaWdodCkge1xuXHRcdGxpZ2h0c0FycmF5LnB1c2gobGlnaHQpO1xuXHR9XG5cdGZ1bmN0aW9uIHB1c2hTaGFkb3coc2hhZG93TGlnaHQpIHtcblx0XHRzaGFkb3dzQXJyYXkucHVzaChzaGFkb3dMaWdodCk7XG5cdH1cblx0ZnVuY3Rpb24gc2V0dXBMaWdodHMocGh5c2ljYWxseUNvcnJlY3RMaWdodHMpIHtcblx0XHRsaWdodHMuc2V0dXAobGlnaHRzQXJyYXksIHBoeXNpY2FsbHlDb3JyZWN0TGlnaHRzKTtcblx0fVxuXHRmdW5jdGlvbiBzZXR1cExpZ2h0c1ZpZXcoY2FtZXJhKSB7XG5cdFx0bGlnaHRzLnNldHVwVmlldyhsaWdodHNBcnJheSwgY2FtZXJhKTtcblx0fVxuXHRjb25zdCBzdGF0ZSA9IHtcblx0XHRsaWdodHNBcnJheTogbGlnaHRzQXJyYXksXG5cdFx0c2hhZG93c0FycmF5OiBzaGFkb3dzQXJyYXksXG5cdFx0bGlnaHRzOiBsaWdodHNcblx0fTtcblx0cmV0dXJuIHtcblx0XHRpbml0OiBpbml0LFxuXHRcdHN0YXRlOiBzdGF0ZSxcblx0XHRzZXR1cExpZ2h0czogc2V0dXBMaWdodHMsXG5cdFx0c2V0dXBMaWdodHNWaWV3OiBzZXR1cExpZ2h0c1ZpZXcsXG5cdFx0cHVzaExpZ2h0OiBwdXNoTGlnaHQsXG5cdFx0cHVzaFNoYWRvdzogcHVzaFNoYWRvd1xuXHR9O1xufVxuZnVuY3Rpb24gV2ViR0xSZW5kZXJTdGF0ZXMoZXh0ZW5zaW9ucywgY2FwYWJpbGl0aWVzKSB7XG5cdGxldCByZW5kZXJTdGF0ZXMgPSBuZXcgV2Vha01hcCgpO1xuXHRmdW5jdGlvbiBnZXQoc2NlbmUsIHJlbmRlckNhbGxEZXB0aCA9IDApIHtcblx0XHRjb25zdCByZW5kZXJTdGF0ZUFycmF5ID0gcmVuZGVyU3RhdGVzLmdldChzY2VuZSk7XG5cdFx0bGV0IHJlbmRlclN0YXRlO1xuXHRcdGlmIChyZW5kZXJTdGF0ZUFycmF5ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJlbmRlclN0YXRlID0gbmV3IFdlYkdMUmVuZGVyU3RhdGUoZXh0ZW5zaW9ucywgY2FwYWJpbGl0aWVzKTtcblx0XHRcdHJlbmRlclN0YXRlcy5zZXQoc2NlbmUsIFtyZW5kZXJTdGF0ZV0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAocmVuZGVyQ2FsbERlcHRoID49IHJlbmRlclN0YXRlQXJyYXkubGVuZ3RoKSB7XG5cdFx0XHRcdHJlbmRlclN0YXRlID0gbmV3IFdlYkdMUmVuZGVyU3RhdGUoZXh0ZW5zaW9ucywgY2FwYWJpbGl0aWVzKTtcblx0XHRcdFx0cmVuZGVyU3RhdGVBcnJheS5wdXNoKHJlbmRlclN0YXRlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlbmRlclN0YXRlID0gcmVuZGVyU3RhdGVBcnJheVtyZW5kZXJDYWxsRGVwdGhdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcmVuZGVyU3RhdGU7XG5cdH1cblx0ZnVuY3Rpb24gZGlzcG9zZSgpIHtcblx0XHRyZW5kZXJTdGF0ZXMgPSBuZXcgV2Vha01hcCgpO1xuXHR9XG5cdHJldHVybiB7XG5cdFx0Z2V0OiBnZXQsXG5cdFx0ZGlzcG9zZTogZGlzcG9zZVxuXHR9O1xufVxuXG5jbGFzcyBNZXNoRGVwdGhNYXRlcmlhbCBleHRlbmRzIE1hdGVyaWFsIHtcblx0Y29uc3RydWN0b3IocGFyYW1ldGVycykge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5pc01lc2hEZXB0aE1hdGVyaWFsID0gdHJ1ZTtcblx0XHR0aGlzLnR5cGUgPSAnTWVzaERlcHRoTWF0ZXJpYWwnO1xuXHRcdHRoaXMuZGVwdGhQYWNraW5nID0gQmFzaWNEZXB0aFBhY2tpbmc7XG5cdFx0dGhpcy5tYXAgPSBudWxsO1xuXHRcdHRoaXMuYWxwaGFNYXAgPSBudWxsO1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gbnVsbDtcblx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcblx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSAwO1xuXHRcdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuXHRcdHRoaXMuc2V0VmFsdWVzKHBhcmFtZXRlcnMpO1xuXHR9XG5cdGNvcHkoc291cmNlKSB7XG5cdFx0c3VwZXIuY29weShzb3VyY2UpO1xuXHRcdHRoaXMuZGVwdGhQYWNraW5nID0gc291cmNlLmRlcHRoUGFja2luZztcblx0XHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XG5cdFx0dGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcblx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IHNvdXJjZS5kaXNwbGFjZW1lbnRNYXA7XG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IHNvdXJjZS5kaXNwbGFjZW1lbnRTY2FsZTtcblx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSBzb3VyY2UuZGlzcGxhY2VtZW50Qmlhcztcblx0XHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59XG5cbmNsYXNzIE1lc2hEaXN0YW5jZU1hdGVyaWFsIGV4dGVuZHMgTWF0ZXJpYWwge1xuXHRjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLmlzTWVzaERpc3RhbmNlTWF0ZXJpYWwgPSB0cnVlO1xuXHRcdHRoaXMudHlwZSA9ICdNZXNoRGlzdGFuY2VNYXRlcmlhbCc7XG5cdFx0dGhpcy5yZWZlcmVuY2VQb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0dGhpcy5uZWFyRGlzdGFuY2UgPSAxO1xuXHRcdHRoaXMuZmFyRGlzdGFuY2UgPSAxMDAwO1xuXHRcdHRoaXMubWFwID0gbnVsbDtcblx0XHR0aGlzLmFscGhhTWFwID0gbnVsbDtcblx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IG51bGw7XG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IDE7XG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gMDtcblx0XHR0aGlzLnNldFZhbHVlcyhwYXJhbWV0ZXJzKTtcblx0fVxuXHRjb3B5KHNvdXJjZSkge1xuXHRcdHN1cGVyLmNvcHkoc291cmNlKTtcblx0XHR0aGlzLnJlZmVyZW5jZVBvc2l0aW9uLmNvcHkoc291cmNlLnJlZmVyZW5jZVBvc2l0aW9uKTtcblx0XHR0aGlzLm5lYXJEaXN0YW5jZSA9IHNvdXJjZS5uZWFyRGlzdGFuY2U7XG5cdFx0dGhpcy5mYXJEaXN0YW5jZSA9IHNvdXJjZS5mYXJEaXN0YW5jZTtcblx0XHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XG5cdFx0dGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcblx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IHNvdXJjZS5kaXNwbGFjZW1lbnRNYXA7XG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IHNvdXJjZS5kaXNwbGFjZW1lbnRTY2FsZTtcblx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSBzb3VyY2UuZGlzcGxhY2VtZW50Qmlhcztcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufVxuXG5jb25zdCB2ZXJ0ZXggPSBcInZvaWQgbWFpbigpIHtcXG5cXHRnbF9Qb3NpdGlvbiA9IHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcXG59XCI7XG5jb25zdCBmcmFnbWVudCA9IFwidW5pZm9ybSBzYW1wbGVyMkQgc2hhZG93X3Bhc3M7XFxudW5pZm9ybSB2ZWMyIHJlc29sdXRpb247XFxudW5pZm9ybSBmbG9hdCByYWRpdXM7XFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxudm9pZCBtYWluKCkge1xcblxcdGNvbnN0IGZsb2F0IHNhbXBsZXMgPSBmbG9hdCggVlNNX1NBTVBMRVMgKTtcXG5cXHRmbG9hdCBtZWFuID0gMC4wO1xcblxcdGZsb2F0IHNxdWFyZWRfbWVhbiA9IDAuMDtcXG5cXHRmbG9hdCB1dlN0cmlkZSA9IHNhbXBsZXMgPD0gMS4wID8gMC4wIDogMi4wIC8gKCBzYW1wbGVzIC0gMS4wICk7XFxuXFx0ZmxvYXQgdXZTdGFydCA9IHNhbXBsZXMgPD0gMS4wID8gMC4wIDogLSAxLjA7XFxuXFx0Zm9yICggZmxvYXQgaSA9IDAuMDsgaSA8IHNhbXBsZXM7IGkgKysgKSB7XFxuXFx0XFx0ZmxvYXQgdXZPZmZzZXQgPSB1dlN0YXJ0ICsgaSAqIHV2U3RyaWRlO1xcblxcdFxcdCNpZmRlZiBIT1JJWk9OVEFMX1BBU1NcXG5cXHRcXHRcXHR2ZWMyIGRpc3RyaWJ1dGlvbiA9IHVucGFja1JHQkFUbzJIYWxmKCB0ZXh0dXJlMkQoIHNoYWRvd19wYXNzLCAoIGdsX0ZyYWdDb29yZC54eSArIHZlYzIoIHV2T2Zmc2V0LCAwLjAgKSAqIHJhZGl1cyApIC8gcmVzb2x1dGlvbiApICk7XFxuXFx0XFx0XFx0bWVhbiArPSBkaXN0cmlidXRpb24ueDtcXG5cXHRcXHRcXHRzcXVhcmVkX21lYW4gKz0gZGlzdHJpYnV0aW9uLnkgKiBkaXN0cmlidXRpb24ueSArIGRpc3RyaWJ1dGlvbi54ICogZGlzdHJpYnV0aW9uLng7XFxuXFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHRmbG9hdCBkZXB0aCA9IHVucGFja1JHQkFUb0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd19wYXNzLCAoIGdsX0ZyYWdDb29yZC54eSArIHZlYzIoIDAuMCwgdXZPZmZzZXQgKSAqIHJhZGl1cyApIC8gcmVzb2x1dGlvbiApICk7XFxuXFx0XFx0XFx0bWVhbiArPSBkZXB0aDtcXG5cXHRcXHRcXHRzcXVhcmVkX21lYW4gKz0gZGVwdGggKiBkZXB0aDtcXG5cXHRcXHQjZW5kaWZcXG5cXHR9XFxuXFx0bWVhbiA9IG1lYW4gLyBzYW1wbGVzO1xcblxcdHNxdWFyZWRfbWVhbiA9IHNxdWFyZWRfbWVhbiAvIHNhbXBsZXM7XFxuXFx0ZmxvYXQgc3RkX2RldiA9IHNxcnQoIHNxdWFyZWRfbWVhbiAtIG1lYW4gKiBtZWFuICk7XFxuXFx0Z2xfRnJhZ0NvbG9yID0gcGFjazJIYWxmVG9SR0JBKCB2ZWMyKCBtZWFuLCBzdGRfZGV2ICkgKTtcXG59XCI7XG5cbmZ1bmN0aW9uIFdlYkdMU2hhZG93TWFwKF9yZW5kZXJlciwgX29iamVjdHMsIF9jYXBhYmlsaXRpZXMpIHtcblx0bGV0IF9mcnVzdHVtID0gbmV3IEZydXN0dW0oKTtcblx0Y29uc3QgX3NoYWRvd01hcFNpemUgPSBuZXcgVmVjdG9yMigpLFxuXHRcdF92aWV3cG9ydFNpemUgPSBuZXcgVmVjdG9yMigpLFxuXHRcdF92aWV3cG9ydCA9IG5ldyBWZWN0b3I0KCksXG5cdFx0X2RlcHRoTWF0ZXJpYWwgPSBuZXcgTWVzaERlcHRoTWF0ZXJpYWwoe1xuXHRcdFx0ZGVwdGhQYWNraW5nOiBSR0JBRGVwdGhQYWNraW5nXG5cdFx0fSksXG5cdFx0X2Rpc3RhbmNlTWF0ZXJpYWwgPSBuZXcgTWVzaERpc3RhbmNlTWF0ZXJpYWwoKSxcblx0XHRfbWF0ZXJpYWxDYWNoZSA9IHt9LFxuXHRcdF9tYXhUZXh0dXJlU2l6ZSA9IF9jYXBhYmlsaXRpZXMubWF4VGV4dHVyZVNpemU7XG5cdGNvbnN0IHNoYWRvd1NpZGUgPSB7XG5cdFx0MDogQmFja1NpZGUsXG5cdFx0MTogRnJvbnRTaWRlLFxuXHRcdDI6IERvdWJsZVNpZGVcblx0fTtcblx0Y29uc3Qgc2hhZG93TWF0ZXJpYWxWZXJ0aWNhbCA9IG5ldyBTaGFkZXJNYXRlcmlhbCh7XG5cdFx0ZGVmaW5lczoge1xuXHRcdFx0VlNNX1NBTVBMRVM6IDhcblx0XHR9LFxuXHRcdHVuaWZvcm1zOiB7XG5cdFx0XHRzaGFkb3dfcGFzczoge1xuXHRcdFx0XHR2YWx1ZTogbnVsbFxuXHRcdFx0fSxcblx0XHRcdHJlc29sdXRpb246IHtcblx0XHRcdFx0dmFsdWU6IG5ldyBWZWN0b3IyKClcblx0XHRcdH0sXG5cdFx0XHRyYWRpdXM6IHtcblx0XHRcdFx0dmFsdWU6IDQuMFxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0dmVydGV4U2hhZGVyOiB2ZXJ0ZXgsXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IGZyYWdtZW50XG5cdH0pO1xuXHRjb25zdCBzaGFkb3dNYXRlcmlhbEhvcml6b250YWwgPSBzaGFkb3dNYXRlcmlhbFZlcnRpY2FsLmNsb25lKCk7XG5cdHNoYWRvd01hdGVyaWFsSG9yaXpvbnRhbC5kZWZpbmVzLkhPUklaT05UQUxfUEFTUyA9IDE7XG5cdGNvbnN0IGZ1bGxTY3JlZW5UcmkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0ZnVsbFNjcmVlblRyaS5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZShuZXcgRmxvYXQzMkFycmF5KFstMSwgLTEsIDAuNSwgMywgLTEsIDAuNSwgLTEsIDMsIDAuNV0pLCAzKSk7XG5cdGNvbnN0IGZ1bGxTY3JlZW5NZXNoID0gbmV3IE1lc2goZnVsbFNjcmVlblRyaSwgc2hhZG93TWF0ZXJpYWxWZXJ0aWNhbCk7XG5cdGNvbnN0IHNjb3BlID0gdGhpcztcblx0dGhpcy5lbmFibGVkID0gZmFsc2U7XG5cdHRoaXMuYXV0b1VwZGF0ZSA9IHRydWU7XG5cdHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcblx0dGhpcy50eXBlID0gUENGU2hhZG93TWFwO1xuXHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uIChsaWdodHMsIHNjZW5lLCBjYW1lcmEpIHtcblx0XHRpZiAoc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UpIHJldHVybjtcblx0XHRpZiAoc2NvcGUuYXV0b1VwZGF0ZSA9PT0gZmFsc2UgJiYgc2NvcGUubmVlZHNVcGRhdGUgPT09IGZhbHNlKSByZXR1cm47XG5cdFx0aWYgKGxpZ2h0cy5sZW5ndGggPT09IDApIHJldHVybjtcblx0XHRjb25zdCBjdXJyZW50UmVuZGVyVGFyZ2V0ID0gX3JlbmRlcmVyLmdldFJlbmRlclRhcmdldCgpO1xuXHRcdGNvbnN0IGFjdGl2ZUN1YmVGYWNlID0gX3JlbmRlcmVyLmdldEFjdGl2ZUN1YmVGYWNlKCk7XG5cdFx0Y29uc3QgYWN0aXZlTWlwbWFwTGV2ZWwgPSBfcmVuZGVyZXIuZ2V0QWN0aXZlTWlwbWFwTGV2ZWwoKTtcblx0XHRjb25zdCBfc3RhdGUgPSBfcmVuZGVyZXIuc3RhdGU7XG5cblx0XHQvLyBTZXQgR0wgc3RhdGUgZm9yIGRlcHRoIG1hcC5cblx0XHRfc3RhdGUuc2V0QmxlbmRpbmcoTm9CbGVuZGluZyk7XG5cdFx0X3N0YXRlLmJ1ZmZlcnMuY29sb3Iuc2V0Q2xlYXIoMSwgMSwgMSwgMSk7XG5cdFx0X3N0YXRlLmJ1ZmZlcnMuZGVwdGguc2V0VGVzdCh0cnVlKTtcblx0XHRfc3RhdGUuc2V0U2Npc3NvclRlc3QoZmFsc2UpO1xuXG5cdFx0Ly8gcmVuZGVyIGRlcHRoIG1hcFxuXG5cdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gbGlnaHRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdGNvbnN0IGxpZ2h0ID0gbGlnaHRzW2ldO1xuXHRcdFx0Y29uc3Qgc2hhZG93ID0gbGlnaHQuc2hhZG93O1xuXHRcdFx0aWYgKHNoYWRvdyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xTaGFkb3dNYXA6JywgbGlnaHQsICdoYXMgbm8gc2hhZG93LicpO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdGlmIChzaGFkb3cuYXV0b1VwZGF0ZSA9PT0gZmFsc2UgJiYgc2hhZG93Lm5lZWRzVXBkYXRlID09PSBmYWxzZSkgY29udGludWU7XG5cdFx0XHRfc2hhZG93TWFwU2l6ZS5jb3B5KHNoYWRvdy5tYXBTaXplKTtcblx0XHRcdGNvbnN0IHNoYWRvd0ZyYW1lRXh0ZW50cyA9IHNoYWRvdy5nZXRGcmFtZUV4dGVudHMoKTtcblx0XHRcdF9zaGFkb3dNYXBTaXplLm11bHRpcGx5KHNoYWRvd0ZyYW1lRXh0ZW50cyk7XG5cdFx0XHRfdmlld3BvcnRTaXplLmNvcHkoc2hhZG93Lm1hcFNpemUpO1xuXHRcdFx0aWYgKF9zaGFkb3dNYXBTaXplLnggPiBfbWF4VGV4dHVyZVNpemUgfHwgX3NoYWRvd01hcFNpemUueSA+IF9tYXhUZXh0dXJlU2l6ZSkge1xuXHRcdFx0XHRpZiAoX3NoYWRvd01hcFNpemUueCA+IF9tYXhUZXh0dXJlU2l6ZSkge1xuXHRcdFx0XHRcdF92aWV3cG9ydFNpemUueCA9IE1hdGguZmxvb3IoX21heFRleHR1cmVTaXplIC8gc2hhZG93RnJhbWVFeHRlbnRzLngpO1xuXHRcdFx0XHRcdF9zaGFkb3dNYXBTaXplLnggPSBfdmlld3BvcnRTaXplLnggKiBzaGFkb3dGcmFtZUV4dGVudHMueDtcblx0XHRcdFx0XHRzaGFkb3cubWFwU2l6ZS54ID0gX3ZpZXdwb3J0U2l6ZS54O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChfc2hhZG93TWFwU2l6ZS55ID4gX21heFRleHR1cmVTaXplKSB7XG5cdFx0XHRcdFx0X3ZpZXdwb3J0U2l6ZS55ID0gTWF0aC5mbG9vcihfbWF4VGV4dHVyZVNpemUgLyBzaGFkb3dGcmFtZUV4dGVudHMueSk7XG5cdFx0XHRcdFx0X3NoYWRvd01hcFNpemUueSA9IF92aWV3cG9ydFNpemUueSAqIHNoYWRvd0ZyYW1lRXh0ZW50cy55O1xuXHRcdFx0XHRcdHNoYWRvdy5tYXBTaXplLnkgPSBfdmlld3BvcnRTaXplLnk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChzaGFkb3cubWFwID09PSBudWxsKSB7XG5cdFx0XHRcdGNvbnN0IHBhcnMgPSB0aGlzLnR5cGUgIT09IFZTTVNoYWRvd01hcCA/IHtcblx0XHRcdFx0XHRtaW5GaWx0ZXI6IE5lYXJlc3RGaWx0ZXIsXG5cdFx0XHRcdFx0bWFnRmlsdGVyOiBOZWFyZXN0RmlsdGVyXG5cdFx0XHRcdH0gOiB7fTtcblx0XHRcdFx0c2hhZG93Lm1hcCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldChfc2hhZG93TWFwU2l6ZS54LCBfc2hhZG93TWFwU2l6ZS55LCBwYXJzKTtcblx0XHRcdFx0c2hhZG93Lm1hcC50ZXh0dXJlLm5hbWUgPSBsaWdodC5uYW1lICsgJy5zaGFkb3dNYXAnO1xuXHRcdFx0XHRzaGFkb3cuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblx0XHRcdH1cblx0XHRcdF9yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoc2hhZG93Lm1hcCk7XG5cdFx0XHRfcmVuZGVyZXIuY2xlYXIoKTtcblx0XHRcdGNvbnN0IHZpZXdwb3J0Q291bnQgPSBzaGFkb3cuZ2V0Vmlld3BvcnRDb3VudCgpO1xuXHRcdFx0Zm9yIChsZXQgdnAgPSAwOyB2cCA8IHZpZXdwb3J0Q291bnQ7IHZwKyspIHtcblx0XHRcdFx0Y29uc3Qgdmlld3BvcnQgPSBzaGFkb3cuZ2V0Vmlld3BvcnQodnApO1xuXHRcdFx0XHRfdmlld3BvcnQuc2V0KF92aWV3cG9ydFNpemUueCAqIHZpZXdwb3J0LngsIF92aWV3cG9ydFNpemUueSAqIHZpZXdwb3J0LnksIF92aWV3cG9ydFNpemUueCAqIHZpZXdwb3J0LnosIF92aWV3cG9ydFNpemUueSAqIHZpZXdwb3J0LncpO1xuXHRcdFx0XHRfc3RhdGUudmlld3BvcnQoX3ZpZXdwb3J0KTtcblx0XHRcdFx0c2hhZG93LnVwZGF0ZU1hdHJpY2VzKGxpZ2h0LCB2cCk7XG5cdFx0XHRcdF9mcnVzdHVtID0gc2hhZG93LmdldEZydXN0dW0oKTtcblx0XHRcdFx0cmVuZGVyT2JqZWN0KHNjZW5lLCBjYW1lcmEsIHNoYWRvdy5jYW1lcmEsIGxpZ2h0LCB0aGlzLnR5cGUpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBkbyBibHVyIHBhc3MgZm9yIFZTTVxuXG5cdFx0XHRpZiAoc2hhZG93LmlzUG9pbnRMaWdodFNoYWRvdyAhPT0gdHJ1ZSAmJiB0aGlzLnR5cGUgPT09IFZTTVNoYWRvd01hcCkge1xuXHRcdFx0XHRWU01QYXNzKHNoYWRvdywgY2FtZXJhKTtcblx0XHRcdH1cblx0XHRcdHNoYWRvdy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXHRcdH1cblx0XHRzY29wZS5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXHRcdF9yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoY3VycmVudFJlbmRlclRhcmdldCwgYWN0aXZlQ3ViZUZhY2UsIGFjdGl2ZU1pcG1hcExldmVsKTtcblx0fTtcblx0ZnVuY3Rpb24gVlNNUGFzcyhzaGFkb3csIGNhbWVyYSkge1xuXHRcdGNvbnN0IGdlb21ldHJ5ID0gX29iamVjdHMudXBkYXRlKGZ1bGxTY3JlZW5NZXNoKTtcblx0XHRpZiAoc2hhZG93TWF0ZXJpYWxWZXJ0aWNhbC5kZWZpbmVzLlZTTV9TQU1QTEVTICE9PSBzaGFkb3cuYmx1clNhbXBsZXMpIHtcblx0XHRcdHNoYWRvd01hdGVyaWFsVmVydGljYWwuZGVmaW5lcy5WU01fU0FNUExFUyA9IHNoYWRvdy5ibHVyU2FtcGxlcztcblx0XHRcdHNoYWRvd01hdGVyaWFsSG9yaXpvbnRhbC5kZWZpbmVzLlZTTV9TQU1QTEVTID0gc2hhZG93LmJsdXJTYW1wbGVzO1xuXHRcdFx0c2hhZG93TWF0ZXJpYWxWZXJ0aWNhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRzaGFkb3dNYXRlcmlhbEhvcml6b250YWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdH1cblx0XHRpZiAoc2hhZG93Lm1hcFBhc3MgPT09IG51bGwpIHtcblx0XHRcdHNoYWRvdy5tYXBQYXNzID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0KF9zaGFkb3dNYXBTaXplLngsIF9zaGFkb3dNYXBTaXplLnkpO1xuXHRcdH1cblxuXHRcdC8vIHZlcnRpY2FsIHBhc3NcblxuXHRcdHNoYWRvd01hdGVyaWFsVmVydGljYWwudW5pZm9ybXMuc2hhZG93X3Bhc3MudmFsdWUgPSBzaGFkb3cubWFwLnRleHR1cmU7XG5cdFx0c2hhZG93TWF0ZXJpYWxWZXJ0aWNhbC51bmlmb3Jtcy5yZXNvbHV0aW9uLnZhbHVlID0gc2hhZG93Lm1hcFNpemU7XG5cdFx0c2hhZG93TWF0ZXJpYWxWZXJ0aWNhbC51bmlmb3Jtcy5yYWRpdXMudmFsdWUgPSBzaGFkb3cucmFkaXVzO1xuXHRcdF9yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoc2hhZG93Lm1hcFBhc3MpO1xuXHRcdF9yZW5kZXJlci5jbGVhcigpO1xuXHRcdF9yZW5kZXJlci5yZW5kZXJCdWZmZXJEaXJlY3QoY2FtZXJhLCBudWxsLCBnZW9tZXRyeSwgc2hhZG93TWF0ZXJpYWxWZXJ0aWNhbCwgZnVsbFNjcmVlbk1lc2gsIG51bGwpO1xuXG5cdFx0Ly8gaG9yaXpvbnRhbCBwYXNzXG5cblx0XHRzaGFkb3dNYXRlcmlhbEhvcml6b250YWwudW5pZm9ybXMuc2hhZG93X3Bhc3MudmFsdWUgPSBzaGFkb3cubWFwUGFzcy50ZXh0dXJlO1xuXHRcdHNoYWRvd01hdGVyaWFsSG9yaXpvbnRhbC51bmlmb3Jtcy5yZXNvbHV0aW9uLnZhbHVlID0gc2hhZG93Lm1hcFNpemU7XG5cdFx0c2hhZG93TWF0ZXJpYWxIb3Jpem9udGFsLnVuaWZvcm1zLnJhZGl1cy52YWx1ZSA9IHNoYWRvdy5yYWRpdXM7XG5cdFx0X3JlbmRlcmVyLnNldFJlbmRlclRhcmdldChzaGFkb3cubWFwKTtcblx0XHRfcmVuZGVyZXIuY2xlYXIoKTtcblx0XHRfcmVuZGVyZXIucmVuZGVyQnVmZmVyRGlyZWN0KGNhbWVyYSwgbnVsbCwgZ2VvbWV0cnksIHNoYWRvd01hdGVyaWFsSG9yaXpvbnRhbCwgZnVsbFNjcmVlbk1lc2gsIG51bGwpO1xuXHR9XG5cdGZ1bmN0aW9uIGdldERlcHRoTWF0ZXJpYWwob2JqZWN0LCBtYXRlcmlhbCwgbGlnaHQsIHNoYWRvd0NhbWVyYU5lYXIsIHNoYWRvd0NhbWVyYUZhciwgdHlwZSkge1xuXHRcdGxldCByZXN1bHQgPSBudWxsO1xuXHRcdGNvbnN0IGN1c3RvbU1hdGVyaWFsID0gbGlnaHQuaXNQb2ludExpZ2h0ID09PSB0cnVlID8gb2JqZWN0LmN1c3RvbURpc3RhbmNlTWF0ZXJpYWwgOiBvYmplY3QuY3VzdG9tRGVwdGhNYXRlcmlhbDtcblx0XHRpZiAoY3VzdG9tTWF0ZXJpYWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmVzdWx0ID0gY3VzdG9tTWF0ZXJpYWw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlc3VsdCA9IGxpZ2h0LmlzUG9pbnRMaWdodCA9PT0gdHJ1ZSA/IF9kaXN0YW5jZU1hdGVyaWFsIDogX2RlcHRoTWF0ZXJpYWw7XG5cdFx0fVxuXHRcdGlmIChfcmVuZGVyZXIubG9jYWxDbGlwcGluZ0VuYWJsZWQgJiYgbWF0ZXJpYWwuY2xpcFNoYWRvd3MgPT09IHRydWUgJiYgQXJyYXkuaXNBcnJheShtYXRlcmlhbC5jbGlwcGluZ1BsYW5lcykgJiYgbWF0ZXJpYWwuY2xpcHBpbmdQbGFuZXMubGVuZ3RoICE9PSAwIHx8IG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCAmJiBtYXRlcmlhbC5kaXNwbGFjZW1lbnRTY2FsZSAhPT0gMCB8fCBtYXRlcmlhbC5hbHBoYU1hcCAmJiBtYXRlcmlhbC5hbHBoYVRlc3QgPiAwKSB7XG5cdFx0XHQvLyBpbiB0aGlzIGNhc2Ugd2UgbmVlZCBhIHVuaXF1ZSBtYXRlcmlhbCBpbnN0YW5jZSByZWZsZWN0aW5nIHRoZVxuXHRcdFx0Ly8gYXBwcm9wcmlhdGUgc3RhdGVcblxuXHRcdFx0Y29uc3Qga2V5QSA9IHJlc3VsdC51dWlkLFxuXHRcdFx0XHRrZXlCID0gbWF0ZXJpYWwudXVpZDtcblx0XHRcdGxldCBtYXRlcmlhbHNGb3JWYXJpYW50ID0gX21hdGVyaWFsQ2FjaGVba2V5QV07XG5cdFx0XHRpZiAobWF0ZXJpYWxzRm9yVmFyaWFudCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdG1hdGVyaWFsc0ZvclZhcmlhbnQgPSB7fTtcblx0XHRcdFx0X21hdGVyaWFsQ2FjaGVba2V5QV0gPSBtYXRlcmlhbHNGb3JWYXJpYW50O1xuXHRcdFx0fVxuXHRcdFx0bGV0IGNhY2hlZE1hdGVyaWFsID0gbWF0ZXJpYWxzRm9yVmFyaWFudFtrZXlCXTtcblx0XHRcdGlmIChjYWNoZWRNYXRlcmlhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGNhY2hlZE1hdGVyaWFsID0gcmVzdWx0LmNsb25lKCk7XG5cdFx0XHRcdG1hdGVyaWFsc0ZvclZhcmlhbnRba2V5Ql0gPSBjYWNoZWRNYXRlcmlhbDtcblx0XHRcdH1cblx0XHRcdHJlc3VsdCA9IGNhY2hlZE1hdGVyaWFsO1xuXHRcdH1cblx0XHRyZXN1bHQudmlzaWJsZSA9IG1hdGVyaWFsLnZpc2libGU7XG5cdFx0cmVzdWx0LndpcmVmcmFtZSA9IG1hdGVyaWFsLndpcmVmcmFtZTtcblx0XHRpZiAodHlwZSA9PT0gVlNNU2hhZG93TWFwKSB7XG5cdFx0XHRyZXN1bHQuc2lkZSA9IG1hdGVyaWFsLnNoYWRvd1NpZGUgIT09IG51bGwgPyBtYXRlcmlhbC5zaGFkb3dTaWRlIDogbWF0ZXJpYWwuc2lkZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVzdWx0LnNpZGUgPSBtYXRlcmlhbC5zaGFkb3dTaWRlICE9PSBudWxsID8gbWF0ZXJpYWwuc2hhZG93U2lkZSA6IHNoYWRvd1NpZGVbbWF0ZXJpYWwuc2lkZV07XG5cdFx0fVxuXHRcdHJlc3VsdC5hbHBoYU1hcCA9IG1hdGVyaWFsLmFscGhhTWFwO1xuXHRcdHJlc3VsdC5hbHBoYVRlc3QgPSBtYXRlcmlhbC5hbHBoYVRlc3Q7XG5cdFx0cmVzdWx0LmNsaXBTaGFkb3dzID0gbWF0ZXJpYWwuY2xpcFNoYWRvd3M7XG5cdFx0cmVzdWx0LmNsaXBwaW5nUGxhbmVzID0gbWF0ZXJpYWwuY2xpcHBpbmdQbGFuZXM7XG5cdFx0cmVzdWx0LmNsaXBJbnRlcnNlY3Rpb24gPSBtYXRlcmlhbC5jbGlwSW50ZXJzZWN0aW9uO1xuXHRcdHJlc3VsdC5kaXNwbGFjZW1lbnRNYXAgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXA7XG5cdFx0cmVzdWx0LmRpc3BsYWNlbWVudFNjYWxlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50U2NhbGU7XG5cdFx0cmVzdWx0LmRpc3BsYWNlbWVudEJpYXMgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRCaWFzO1xuXHRcdHJlc3VsdC53aXJlZnJhbWVMaW5ld2lkdGggPSBtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGg7XG5cdFx0cmVzdWx0LmxpbmV3aWR0aCA9IG1hdGVyaWFsLmxpbmV3aWR0aDtcblx0XHRpZiAobGlnaHQuaXNQb2ludExpZ2h0ID09PSB0cnVlICYmIHJlc3VsdC5pc01lc2hEaXN0YW5jZU1hdGVyaWFsID09PSB0cnVlKSB7XG5cdFx0XHRyZXN1bHQucmVmZXJlbmNlUG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGxpZ2h0Lm1hdHJpeFdvcmxkKTtcblx0XHRcdHJlc3VsdC5uZWFyRGlzdGFuY2UgPSBzaGFkb3dDYW1lcmFOZWFyO1xuXHRcdFx0cmVzdWx0LmZhckRpc3RhbmNlID0gc2hhZG93Q2FtZXJhRmFyO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cdGZ1bmN0aW9uIHJlbmRlck9iamVjdChvYmplY3QsIGNhbWVyYSwgc2hhZG93Q2FtZXJhLCBsaWdodCwgdHlwZSkge1xuXHRcdGlmIChvYmplY3QudmlzaWJsZSA9PT0gZmFsc2UpIHJldHVybjtcblx0XHRjb25zdCB2aXNpYmxlID0gb2JqZWN0LmxheWVycy50ZXN0KGNhbWVyYS5sYXllcnMpO1xuXHRcdGlmICh2aXNpYmxlICYmIChvYmplY3QuaXNNZXNoIHx8IG9iamVjdC5pc0xpbmUgfHwgb2JqZWN0LmlzUG9pbnRzKSkge1xuXHRcdFx0aWYgKChvYmplY3QuY2FzdFNoYWRvdyB8fCBvYmplY3QucmVjZWl2ZVNoYWRvdyAmJiB0eXBlID09PSBWU01TaGFkb3dNYXApICYmICghb2JqZWN0LmZydXN0dW1DdWxsZWQgfHwgX2ZydXN0dW0uaW50ZXJzZWN0c09iamVjdChvYmplY3QpKSkge1xuXHRcdFx0XHRvYmplY3QubW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoc2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgb2JqZWN0Lm1hdHJpeFdvcmxkKTtcblx0XHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBfb2JqZWN0cy51cGRhdGUob2JqZWN0KTtcblx0XHRcdFx0Y29uc3QgbWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XG5cdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KG1hdGVyaWFsKSkge1xuXHRcdFx0XHRcdGNvbnN0IGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3Vwcztcblx0XHRcdFx0XHRmb3IgKGxldCBrID0gMCwga2wgPSBncm91cHMubGVuZ3RoOyBrIDwga2w7IGsrKykge1xuXHRcdFx0XHRcdFx0Y29uc3QgZ3JvdXAgPSBncm91cHNba107XG5cdFx0XHRcdFx0XHRjb25zdCBncm91cE1hdGVyaWFsID0gbWF0ZXJpYWxbZ3JvdXAubWF0ZXJpYWxJbmRleF07XG5cdFx0XHRcdFx0XHRpZiAoZ3JvdXBNYXRlcmlhbCAmJiBncm91cE1hdGVyaWFsLnZpc2libGUpIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgZGVwdGhNYXRlcmlhbCA9IGdldERlcHRoTWF0ZXJpYWwob2JqZWN0LCBncm91cE1hdGVyaWFsLCBsaWdodCwgc2hhZG93Q2FtZXJhLm5lYXIsIHNoYWRvd0NhbWVyYS5mYXIsIHR5cGUpO1xuXHRcdFx0XHRcdFx0XHRfcmVuZGVyZXIucmVuZGVyQnVmZmVyRGlyZWN0KHNoYWRvd0NhbWVyYSwgbnVsbCwgZ2VvbWV0cnksIGRlcHRoTWF0ZXJpYWwsIG9iamVjdCwgZ3JvdXApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChtYXRlcmlhbC52aXNpYmxlKSB7XG5cdFx0XHRcdFx0Y29uc3QgZGVwdGhNYXRlcmlhbCA9IGdldERlcHRoTWF0ZXJpYWwob2JqZWN0LCBtYXRlcmlhbCwgbGlnaHQsIHNoYWRvd0NhbWVyYS5uZWFyLCBzaGFkb3dDYW1lcmEuZmFyLCB0eXBlKTtcblx0XHRcdFx0XHRfcmVuZGVyZXIucmVuZGVyQnVmZmVyRGlyZWN0KHNoYWRvd0NhbWVyYSwgbnVsbCwgZ2VvbWV0cnksIGRlcHRoTWF0ZXJpYWwsIG9iamVjdCwgbnVsbCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0Y29uc3QgY2hpbGRyZW4gPSBvYmplY3QuY2hpbGRyZW47XG5cdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHJlbmRlck9iamVjdChjaGlsZHJlbltpXSwgY2FtZXJhLCBzaGFkb3dDYW1lcmEsIGxpZ2h0LCB0eXBlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gV2ViR0xTdGF0ZShnbCwgZXh0ZW5zaW9ucywgY2FwYWJpbGl0aWVzKSB7XG5cdGNvbnN0IGlzV2ViR0wyID0gY2FwYWJpbGl0aWVzLmlzV2ViR0wyO1xuXHRmdW5jdGlvbiBDb2xvckJ1ZmZlcigpIHtcblx0XHRsZXQgbG9ja2VkID0gZmFsc2U7XG5cdFx0Y29uc3QgY29sb3IgPSBuZXcgVmVjdG9yNCgpO1xuXHRcdGxldCBjdXJyZW50Q29sb3JNYXNrID0gbnVsbDtcblx0XHRjb25zdCBjdXJyZW50Q29sb3JDbGVhciA9IG5ldyBWZWN0b3I0KDAsIDAsIDAsIDApO1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZXRNYXNrOiBmdW5jdGlvbiAoY29sb3JNYXNrKSB7XG5cdFx0XHRcdGlmIChjdXJyZW50Q29sb3JNYXNrICE9PSBjb2xvck1hc2sgJiYgIWxvY2tlZCkge1xuXHRcdFx0XHRcdGdsLmNvbG9yTWFzayhjb2xvck1hc2ssIGNvbG9yTWFzaywgY29sb3JNYXNrLCBjb2xvck1hc2spO1xuXHRcdFx0XHRcdGN1cnJlbnRDb2xvck1hc2sgPSBjb2xvck1hc2s7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRzZXRMb2NrZWQ6IGZ1bmN0aW9uIChsb2NrKSB7XG5cdFx0XHRcdGxvY2tlZCA9IGxvY2s7XG5cdFx0XHR9LFxuXHRcdFx0c2V0Q2xlYXI6IGZ1bmN0aW9uIChyLCBnLCBiLCBhLCBwcmVtdWx0aXBsaWVkQWxwaGEpIHtcblx0XHRcdFx0aWYgKHByZW11bHRpcGxpZWRBbHBoYSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdHIgKj0gYTtcblx0XHRcdFx0XHRnICo9IGE7XG5cdFx0XHRcdFx0YiAqPSBhO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbG9yLnNldChyLCBnLCBiLCBhKTtcblx0XHRcdFx0aWYgKGN1cnJlbnRDb2xvckNsZWFyLmVxdWFscyhjb2xvcikgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0Z2wuY2xlYXJDb2xvcihyLCBnLCBiLCBhKTtcblx0XHRcdFx0XHRjdXJyZW50Q29sb3JDbGVhci5jb3B5KGNvbG9yKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGxvY2tlZCA9IGZhbHNlO1xuXHRcdFx0XHRjdXJyZW50Q29sb3JNYXNrID0gbnVsbDtcblx0XHRcdFx0Y3VycmVudENvbG9yQ2xlYXIuc2V0KC0xLCAwLCAwLCAwKTsgLy8gc2V0IHRvIGludmFsaWQgc3RhdGVcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gRGVwdGhCdWZmZXIoKSB7XG5cdFx0bGV0IGxvY2tlZCA9IGZhbHNlO1xuXHRcdGxldCBjdXJyZW50RGVwdGhNYXNrID0gbnVsbDtcblx0XHRsZXQgY3VycmVudERlcHRoRnVuYyA9IG51bGw7XG5cdFx0bGV0IGN1cnJlbnREZXB0aENsZWFyID0gbnVsbDtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2V0VGVzdDogZnVuY3Rpb24gKGRlcHRoVGVzdCkge1xuXHRcdFx0XHRpZiAoZGVwdGhUZXN0KSB7XG5cdFx0XHRcdFx0ZW5hYmxlKGdsLkRFUFRIX1RFU1QpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRzZXRNYXNrOiBmdW5jdGlvbiAoZGVwdGhNYXNrKSB7XG5cdFx0XHRcdGlmIChjdXJyZW50RGVwdGhNYXNrICE9PSBkZXB0aE1hc2sgJiYgIWxvY2tlZCkge1xuXHRcdFx0XHRcdGdsLmRlcHRoTWFzayhkZXB0aE1hc2spO1xuXHRcdFx0XHRcdGN1cnJlbnREZXB0aE1hc2sgPSBkZXB0aE1hc2s7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRzZXRGdW5jOiBmdW5jdGlvbiAoZGVwdGhGdW5jKSB7XG5cdFx0XHRcdGlmIChjdXJyZW50RGVwdGhGdW5jICE9PSBkZXB0aEZ1bmMpIHtcblx0XHRcdFx0XHRzd2l0Y2ggKGRlcHRoRnVuYykge1xuXHRcdFx0XHRcdFx0Y2FzZSBOZXZlckRlcHRoOlxuXHRcdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoZ2wuTkVWRVIpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgQWx3YXlzRGVwdGg6XG5cdFx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyhnbC5BTFdBWVMpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgTGVzc0RlcHRoOlxuXHRcdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoZ2wuTEVTUyk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBMZXNzRXF1YWxEZXB0aDpcblx0XHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKGdsLkxFUVVBTCk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBFcXVhbERlcHRoOlxuXHRcdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoZ2wuRVFVQUwpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgR3JlYXRlckVxdWFsRGVwdGg6XG5cdFx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyhnbC5HRVFVQUwpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgR3JlYXRlckRlcHRoOlxuXHRcdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoZ2wuR1JFQVRFUik7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBOb3RFcXVhbERlcHRoOlxuXHRcdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoZ2wuTk9URVFVQUwpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyhnbC5MRVFVQUwpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjdXJyZW50RGVwdGhGdW5jID0gZGVwdGhGdW5jO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0c2V0TG9ja2VkOiBmdW5jdGlvbiAobG9jaykge1xuXHRcdFx0XHRsb2NrZWQgPSBsb2NrO1xuXHRcdFx0fSxcblx0XHRcdHNldENsZWFyOiBmdW5jdGlvbiAoZGVwdGgpIHtcblx0XHRcdFx0aWYgKGN1cnJlbnREZXB0aENsZWFyICE9PSBkZXB0aCkge1xuXHRcdFx0XHRcdGdsLmNsZWFyRGVwdGgoZGVwdGgpO1xuXHRcdFx0XHRcdGN1cnJlbnREZXB0aENsZWFyID0gZGVwdGg7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRyZXNldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBmYWxzZTtcblx0XHRcdFx0Y3VycmVudERlcHRoTWFzayA9IG51bGw7XG5cdFx0XHRcdGN1cnJlbnREZXB0aEZ1bmMgPSBudWxsO1xuXHRcdFx0XHRjdXJyZW50RGVwdGhDbGVhciA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXHRmdW5jdGlvbiBTdGVuY2lsQnVmZmVyKCkge1xuXHRcdGxldCBsb2NrZWQgPSBmYWxzZTtcblx0XHRsZXQgY3VycmVudFN0ZW5jaWxNYXNrID0gbnVsbDtcblx0XHRsZXQgY3VycmVudFN0ZW5jaWxGdW5jID0gbnVsbDtcblx0XHRsZXQgY3VycmVudFN0ZW5jaWxSZWYgPSBudWxsO1xuXHRcdGxldCBjdXJyZW50U3RlbmNpbEZ1bmNNYXNrID0gbnVsbDtcblx0XHRsZXQgY3VycmVudFN0ZW5jaWxGYWlsID0gbnVsbDtcblx0XHRsZXQgY3VycmVudFN0ZW5jaWxaRmFpbCA9IG51bGw7XG5cdFx0bGV0IGN1cnJlbnRTdGVuY2lsWlBhc3MgPSBudWxsO1xuXHRcdGxldCBjdXJyZW50U3RlbmNpbENsZWFyID0gbnVsbDtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2V0VGVzdDogZnVuY3Rpb24gKHN0ZW5jaWxUZXN0KSB7XG5cdFx0XHRcdGlmICghbG9ja2VkKSB7XG5cdFx0XHRcdFx0aWYgKHN0ZW5jaWxUZXN0KSB7XG5cdFx0XHRcdFx0XHRlbmFibGUoZ2wuU1RFTkNJTF9URVNUKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZGlzYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHNldE1hc2s6IGZ1bmN0aW9uIChzdGVuY2lsTWFzaykge1xuXHRcdFx0XHRpZiAoY3VycmVudFN0ZW5jaWxNYXNrICE9PSBzdGVuY2lsTWFzayAmJiAhbG9ja2VkKSB7XG5cdFx0XHRcdFx0Z2wuc3RlbmNpbE1hc2soc3RlbmNpbE1hc2spO1xuXHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsTWFzayA9IHN0ZW5jaWxNYXNrO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0c2V0RnVuYzogZnVuY3Rpb24gKHN0ZW5jaWxGdW5jLCBzdGVuY2lsUmVmLCBzdGVuY2lsTWFzaykge1xuXHRcdFx0XHRpZiAoY3VycmVudFN0ZW5jaWxGdW5jICE9PSBzdGVuY2lsRnVuYyB8fCBjdXJyZW50U3RlbmNpbFJlZiAhPT0gc3RlbmNpbFJlZiB8fCBjdXJyZW50U3RlbmNpbEZ1bmNNYXNrICE9PSBzdGVuY2lsTWFzaykge1xuXHRcdFx0XHRcdGdsLnN0ZW5jaWxGdW5jKHN0ZW5jaWxGdW5jLCBzdGVuY2lsUmVmLCBzdGVuY2lsTWFzayk7XG5cdFx0XHRcdFx0Y3VycmVudFN0ZW5jaWxGdW5jID0gc3RlbmNpbEZ1bmM7XG5cdFx0XHRcdFx0Y3VycmVudFN0ZW5jaWxSZWYgPSBzdGVuY2lsUmVmO1xuXHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsRnVuY01hc2sgPSBzdGVuY2lsTWFzaztcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHNldE9wOiBmdW5jdGlvbiAoc3RlbmNpbEZhaWwsIHN0ZW5jaWxaRmFpbCwgc3RlbmNpbFpQYXNzKSB7XG5cdFx0XHRcdGlmIChjdXJyZW50U3RlbmNpbEZhaWwgIT09IHN0ZW5jaWxGYWlsIHx8IGN1cnJlbnRTdGVuY2lsWkZhaWwgIT09IHN0ZW5jaWxaRmFpbCB8fCBjdXJyZW50U3RlbmNpbFpQYXNzICE9PSBzdGVuY2lsWlBhc3MpIHtcblx0XHRcdFx0XHRnbC5zdGVuY2lsT3Aoc3RlbmNpbEZhaWwsIHN0ZW5jaWxaRmFpbCwgc3RlbmNpbFpQYXNzKTtcblx0XHRcdFx0XHRjdXJyZW50U3RlbmNpbEZhaWwgPSBzdGVuY2lsRmFpbDtcblx0XHRcdFx0XHRjdXJyZW50U3RlbmNpbFpGYWlsID0gc3RlbmNpbFpGYWlsO1xuXHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsWlBhc3MgPSBzdGVuY2lsWlBhc3M7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRzZXRMb2NrZWQ6IGZ1bmN0aW9uIChsb2NrKSB7XG5cdFx0XHRcdGxvY2tlZCA9IGxvY2s7XG5cdFx0XHR9LFxuXHRcdFx0c2V0Q2xlYXI6IGZ1bmN0aW9uIChzdGVuY2lsKSB7XG5cdFx0XHRcdGlmIChjdXJyZW50U3RlbmNpbENsZWFyICE9PSBzdGVuY2lsKSB7XG5cdFx0XHRcdFx0Z2wuY2xlYXJTdGVuY2lsKHN0ZW5jaWwpO1xuXHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsQ2xlYXIgPSBzdGVuY2lsO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0cmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0bG9ja2VkID0gZmFsc2U7XG5cdFx0XHRcdGN1cnJlbnRTdGVuY2lsTWFzayA9IG51bGw7XG5cdFx0XHRcdGN1cnJlbnRTdGVuY2lsRnVuYyA9IG51bGw7XG5cdFx0XHRcdGN1cnJlbnRTdGVuY2lsUmVmID0gbnVsbDtcblx0XHRcdFx0Y3VycmVudFN0ZW5jaWxGdW5jTWFzayA9IG51bGw7XG5cdFx0XHRcdGN1cnJlbnRTdGVuY2lsRmFpbCA9IG51bGw7XG5cdFx0XHRcdGN1cnJlbnRTdGVuY2lsWkZhaWwgPSBudWxsO1xuXHRcdFx0XHRjdXJyZW50U3RlbmNpbFpQYXNzID0gbnVsbDtcblx0XHRcdFx0Y3VycmVudFN0ZW5jaWxDbGVhciA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG5cdC8vXG5cblx0Y29uc3QgY29sb3JCdWZmZXIgPSBuZXcgQ29sb3JCdWZmZXIoKTtcblx0Y29uc3QgZGVwdGhCdWZmZXIgPSBuZXcgRGVwdGhCdWZmZXIoKTtcblx0Y29uc3Qgc3RlbmNpbEJ1ZmZlciA9IG5ldyBTdGVuY2lsQnVmZmVyKCk7XG5cdGNvbnN0IHVib0JpbmRpbmdzID0gbmV3IFdlYWtNYXAoKTtcblx0Y29uc3QgdWJvUHJvZ2FtTWFwID0gbmV3IFdlYWtNYXAoKTtcblx0bGV0IGVuYWJsZWRDYXBhYmlsaXRpZXMgPSB7fTtcblx0bGV0IGN1cnJlbnRCb3VuZEZyYW1lYnVmZmVycyA9IHt9O1xuXHRsZXQgY3VycmVudERyYXdidWZmZXJzID0gbmV3IFdlYWtNYXAoKTtcblx0bGV0IGRlZmF1bHREcmF3YnVmZmVycyA9IFtdO1xuXHRsZXQgY3VycmVudFByb2dyYW0gPSBudWxsO1xuXHRsZXQgY3VycmVudEJsZW5kaW5nRW5hYmxlZCA9IGZhbHNlO1xuXHRsZXQgY3VycmVudEJsZW5kaW5nID0gbnVsbDtcblx0bGV0IGN1cnJlbnRCbGVuZEVxdWF0aW9uID0gbnVsbDtcblx0bGV0IGN1cnJlbnRCbGVuZFNyYyA9IG51bGw7XG5cdGxldCBjdXJyZW50QmxlbmREc3QgPSBudWxsO1xuXHRsZXQgY3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSA9IG51bGw7XG5cdGxldCBjdXJyZW50QmxlbmRTcmNBbHBoYSA9IG51bGw7XG5cdGxldCBjdXJyZW50QmxlbmREc3RBbHBoYSA9IG51bGw7XG5cdGxldCBjdXJyZW50UHJlbXVsdGlwbGVkQWxwaGEgPSBmYWxzZTtcblx0bGV0IGN1cnJlbnRGbGlwU2lkZWQgPSBudWxsO1xuXHRsZXQgY3VycmVudEN1bGxGYWNlID0gbnVsbDtcblx0bGV0IGN1cnJlbnRMaW5lV2lkdGggPSBudWxsO1xuXHRsZXQgY3VycmVudFBvbHlnb25PZmZzZXRGYWN0b3IgPSBudWxsO1xuXHRsZXQgY3VycmVudFBvbHlnb25PZmZzZXRVbml0cyA9IG51bGw7XG5cdGNvbnN0IG1heFRleHR1cmVzID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9DT01CSU5FRF9URVhUVVJFX0lNQUdFX1VOSVRTKTtcblx0bGV0IGxpbmVXaWR0aEF2YWlsYWJsZSA9IGZhbHNlO1xuXHRsZXQgdmVyc2lvbiA9IDA7XG5cdGNvbnN0IGdsVmVyc2lvbiA9IGdsLmdldFBhcmFtZXRlcihnbC5WRVJTSU9OKTtcblx0aWYgKGdsVmVyc2lvbi5pbmRleE9mKCdXZWJHTCcpICE9PSAtMSkge1xuXHRcdHZlcnNpb24gPSBwYXJzZUZsb2F0KC9eV2ViR0wgKFxcZCkvLmV4ZWMoZ2xWZXJzaW9uKVsxXSk7XG5cdFx0bGluZVdpZHRoQXZhaWxhYmxlID0gdmVyc2lvbiA+PSAxLjA7XG5cdH0gZWxzZSBpZiAoZ2xWZXJzaW9uLmluZGV4T2YoJ09wZW5HTCBFUycpICE9PSAtMSkge1xuXHRcdHZlcnNpb24gPSBwYXJzZUZsb2F0KC9eT3BlbkdMIEVTIChcXGQpLy5leGVjKGdsVmVyc2lvbilbMV0pO1xuXHRcdGxpbmVXaWR0aEF2YWlsYWJsZSA9IHZlcnNpb24gPj0gMi4wO1xuXHR9XG5cdGxldCBjdXJyZW50VGV4dHVyZVNsb3QgPSBudWxsO1xuXHRsZXQgY3VycmVudEJvdW5kVGV4dHVyZXMgPSB7fTtcblx0Y29uc3Qgc2Npc3NvclBhcmFtID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLlNDSVNTT1JfQk9YKTtcblx0Y29uc3Qgdmlld3BvcnRQYXJhbSA9IGdsLmdldFBhcmFtZXRlcihnbC5WSUVXUE9SVCk7XG5cdGNvbnN0IGN1cnJlbnRTY2lzc29yID0gbmV3IFZlY3RvcjQoKS5mcm9tQXJyYXkoc2Npc3NvclBhcmFtKTtcblx0Y29uc3QgY3VycmVudFZpZXdwb3J0ID0gbmV3IFZlY3RvcjQoKS5mcm9tQXJyYXkodmlld3BvcnRQYXJhbSk7XG5cdGZ1bmN0aW9uIGNyZWF0ZVRleHR1cmUodHlwZSwgdGFyZ2V0LCBjb3VudCkge1xuXHRcdGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheSg0KTsgLy8gNCBpcyByZXF1aXJlZCB0byBtYXRjaCBkZWZhdWx0IHVucGFjayBhbGlnbm1lbnQgb2YgNC5cblx0XHRjb25zdCB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXHRcdGdsLmJpbmRUZXh0dXJlKHR5cGUsIHRleHR1cmUpO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkodHlwZSwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKHR5cGUsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG5cdFx0XHRnbC50ZXhJbWFnZTJEKHRhcmdldCArIGksIDAsIGdsLlJHQkEsIDEsIDEsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGRhdGEpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGV4dHVyZTtcblx0fVxuXHRjb25zdCBlbXB0eVRleHR1cmVzID0ge307XG5cdGVtcHR5VGV4dHVyZXNbZ2wuVEVYVFVSRV8yRF0gPSBjcmVhdGVUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfMkQsIDEpO1xuXHRlbXB0eVRleHR1cmVzW2dsLlRFWFRVUkVfQ1VCRV9NQVBdID0gY3JlYXRlVGV4dHVyZShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1gsIDYpO1xuXG5cdC8vIGluaXRcblxuXHRjb2xvckJ1ZmZlci5zZXRDbGVhcigwLCAwLCAwLCAxKTtcblx0ZGVwdGhCdWZmZXIuc2V0Q2xlYXIoMSk7XG5cdHN0ZW5jaWxCdWZmZXIuc2V0Q2xlYXIoMCk7XG5cdGVuYWJsZShnbC5ERVBUSF9URVNUKTtcblx0ZGVwdGhCdWZmZXIuc2V0RnVuYyhMZXNzRXF1YWxEZXB0aCk7XG5cdHNldEZsaXBTaWRlZChmYWxzZSk7XG5cdHNldEN1bGxGYWNlKEN1bGxGYWNlQmFjayk7XG5cdGVuYWJsZShnbC5DVUxMX0ZBQ0UpO1xuXHRzZXRCbGVuZGluZyhOb0JsZW5kaW5nKTtcblxuXHQvL1xuXG5cdGZ1bmN0aW9uIGVuYWJsZShpZCkge1xuXHRcdGlmIChlbmFibGVkQ2FwYWJpbGl0aWVzW2lkXSAhPT0gdHJ1ZSkge1xuXHRcdFx0Z2wuZW5hYmxlKGlkKTtcblx0XHRcdGVuYWJsZWRDYXBhYmlsaXRpZXNbaWRdID0gdHJ1ZTtcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gZGlzYWJsZShpZCkge1xuXHRcdGlmIChlbmFibGVkQ2FwYWJpbGl0aWVzW2lkXSAhPT0gZmFsc2UpIHtcblx0XHRcdGdsLmRpc2FibGUoaWQpO1xuXHRcdFx0ZW5hYmxlZENhcGFiaWxpdGllc1tpZF0gPSBmYWxzZTtcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gYmluZEZyYW1lYnVmZmVyKHRhcmdldCwgZnJhbWVidWZmZXIpIHtcblx0XHRpZiAoY3VycmVudEJvdW5kRnJhbWVidWZmZXJzW3RhcmdldF0gIT09IGZyYW1lYnVmZmVyKSB7XG5cdFx0XHRnbC5iaW5kRnJhbWVidWZmZXIodGFyZ2V0LCBmcmFtZWJ1ZmZlcik7XG5cdFx0XHRjdXJyZW50Qm91bmRGcmFtZWJ1ZmZlcnNbdGFyZ2V0XSA9IGZyYW1lYnVmZmVyO1xuXHRcdFx0aWYgKGlzV2ViR0wyKSB7XG5cdFx0XHRcdC8vIGdsLkRSQVdfRlJBTUVCVUZGRVIgaXMgZXF1aXZhbGVudCB0byBnbC5GUkFNRUJVRkZFUlxuXG5cdFx0XHRcdGlmICh0YXJnZXQgPT09IGdsLkRSQVdfRlJBTUVCVUZGRVIpIHtcblx0XHRcdFx0XHRjdXJyZW50Qm91bmRGcmFtZWJ1ZmZlcnNbZ2wuRlJBTUVCVUZGRVJdID0gZnJhbWVidWZmZXI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRhcmdldCA9PT0gZ2wuRlJBTUVCVUZGRVIpIHtcblx0XHRcdFx0XHRjdXJyZW50Qm91bmRGcmFtZWJ1ZmZlcnNbZ2wuRFJBV19GUkFNRUJVRkZFUl0gPSBmcmFtZWJ1ZmZlcjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRmdW5jdGlvbiBkcmF3QnVmZmVycyhyZW5kZXJUYXJnZXQsIGZyYW1lYnVmZmVyKSB7XG5cdFx0bGV0IGRyYXdCdWZmZXJzID0gZGVmYXVsdERyYXdidWZmZXJzO1xuXHRcdGxldCBuZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXHRcdGlmIChyZW5kZXJUYXJnZXQpIHtcblx0XHRcdGRyYXdCdWZmZXJzID0gY3VycmVudERyYXdidWZmZXJzLmdldChmcmFtZWJ1ZmZlcik7XG5cdFx0XHRpZiAoZHJhd0J1ZmZlcnMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRkcmF3QnVmZmVycyA9IFtdO1xuXHRcdFx0XHRjdXJyZW50RHJhd2J1ZmZlcnMuc2V0KGZyYW1lYnVmZmVyLCBkcmF3QnVmZmVycyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAocmVuZGVyVGFyZ2V0LmlzV2ViR0xNdWx0aXBsZVJlbmRlclRhcmdldHMpIHtcblx0XHRcdFx0Y29uc3QgdGV4dHVyZXMgPSByZW5kZXJUYXJnZXQudGV4dHVyZTtcblx0XHRcdFx0aWYgKGRyYXdCdWZmZXJzLmxlbmd0aCAhPT0gdGV4dHVyZXMubGVuZ3RoIHx8IGRyYXdCdWZmZXJzWzBdICE9PSBnbC5DT0xPUl9BVFRBQ0hNRU5UMCkge1xuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IHRleHR1cmVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0XHRcdGRyYXdCdWZmZXJzW2ldID0gZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkcmF3QnVmZmVycy5sZW5ndGggPSB0ZXh0dXJlcy5sZW5ndGg7XG5cdFx0XHRcdFx0bmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoZHJhd0J1ZmZlcnNbMF0gIT09IGdsLkNPTE9SX0FUVEFDSE1FTlQwKSB7XG5cdFx0XHRcdFx0ZHJhd0J1ZmZlcnNbMF0gPSBnbC5DT0xPUl9BVFRBQ0hNRU5UMDtcblx0XHRcdFx0XHRuZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKGRyYXdCdWZmZXJzWzBdICE9PSBnbC5CQUNLKSB7XG5cdFx0XHRcdGRyYXdCdWZmZXJzWzBdID0gZ2wuQkFDSztcblx0XHRcdFx0bmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAobmVlZHNVcGRhdGUpIHtcblx0XHRcdGlmIChjYXBhYmlsaXRpZXMuaXNXZWJHTDIpIHtcblx0XHRcdFx0Z2wuZHJhd0J1ZmZlcnMoZHJhd0J1ZmZlcnMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZXh0ZW5zaW9ucy5nZXQoJ1dFQkdMX2RyYXdfYnVmZmVycycpLmRyYXdCdWZmZXJzV0VCR0woZHJhd0J1ZmZlcnMpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1c2VQcm9ncmFtKHByb2dyYW0pIHtcblx0XHRpZiAoY3VycmVudFByb2dyYW0gIT09IHByb2dyYW0pIHtcblx0XHRcdGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG5cdFx0XHRjdXJyZW50UHJvZ3JhbSA9IHByb2dyYW07XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdGNvbnN0IGVxdWF0aW9uVG9HTCA9IHtcblx0XHRbQWRkRXF1YXRpb25dOiBnbC5GVU5DX0FERCxcblx0XHRbU3VidHJhY3RFcXVhdGlvbl06IGdsLkZVTkNfU1VCVFJBQ1QsXG5cdFx0W1JldmVyc2VTdWJ0cmFjdEVxdWF0aW9uXTogZ2wuRlVOQ19SRVZFUlNFX1NVQlRSQUNUXG5cdH07XG5cdGlmIChpc1dlYkdMMikge1xuXHRcdGVxdWF0aW9uVG9HTFtNaW5FcXVhdGlvbl0gPSBnbC5NSU47XG5cdFx0ZXF1YXRpb25Ub0dMW01heEVxdWF0aW9uXSA9IGdsLk1BWDtcblx0fSBlbHNlIHtcblx0XHRjb25zdCBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCgnRVhUX2JsZW5kX21pbm1heCcpO1xuXHRcdGlmIChleHRlbnNpb24gIT09IG51bGwpIHtcblx0XHRcdGVxdWF0aW9uVG9HTFtNaW5FcXVhdGlvbl0gPSBleHRlbnNpb24uTUlOX0VYVDtcblx0XHRcdGVxdWF0aW9uVG9HTFtNYXhFcXVhdGlvbl0gPSBleHRlbnNpb24uTUFYX0VYVDtcblx0XHR9XG5cdH1cblx0Y29uc3QgZmFjdG9yVG9HTCA9IHtcblx0XHRbWmVyb0ZhY3Rvcl06IGdsLlpFUk8sXG5cdFx0W09uZUZhY3Rvcl06IGdsLk9ORSxcblx0XHRbU3JjQ29sb3JGYWN0b3JdOiBnbC5TUkNfQ09MT1IsXG5cdFx0W1NyY0FscGhhRmFjdG9yXTogZ2wuU1JDX0FMUEhBLFxuXHRcdFtTcmNBbHBoYVNhdHVyYXRlRmFjdG9yXTogZ2wuU1JDX0FMUEhBX1NBVFVSQVRFLFxuXHRcdFtEc3RDb2xvckZhY3Rvcl06IGdsLkRTVF9DT0xPUixcblx0XHRbRHN0QWxwaGFGYWN0b3JdOiBnbC5EU1RfQUxQSEEsXG5cdFx0W09uZU1pbnVzU3JjQ29sb3JGYWN0b3JdOiBnbC5PTkVfTUlOVVNfU1JDX0NPTE9SLFxuXHRcdFtPbmVNaW51c1NyY0FscGhhRmFjdG9yXTogZ2wuT05FX01JTlVTX1NSQ19BTFBIQSxcblx0XHRbT25lTWludXNEc3RDb2xvckZhY3Rvcl06IGdsLk9ORV9NSU5VU19EU1RfQ09MT1IsXG5cdFx0W09uZU1pbnVzRHN0QWxwaGFGYWN0b3JdOiBnbC5PTkVfTUlOVVNfRFNUX0FMUEhBXG5cdH07XG5cdGZ1bmN0aW9uIHNldEJsZW5kaW5nKGJsZW5kaW5nLCBibGVuZEVxdWF0aW9uLCBibGVuZFNyYywgYmxlbmREc3QsIGJsZW5kRXF1YXRpb25BbHBoYSwgYmxlbmRTcmNBbHBoYSwgYmxlbmREc3RBbHBoYSwgcHJlbXVsdGlwbGllZEFscGhhKSB7XG5cdFx0aWYgKGJsZW5kaW5nID09PSBOb0JsZW5kaW5nKSB7XG5cdFx0XHRpZiAoY3VycmVudEJsZW5kaW5nRW5hYmxlZCA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRkaXNhYmxlKGdsLkJMRU5EKTtcblx0XHRcdFx0Y3VycmVudEJsZW5kaW5nRW5hYmxlZCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAoY3VycmVudEJsZW5kaW5nRW5hYmxlZCA9PT0gZmFsc2UpIHtcblx0XHRcdGVuYWJsZShnbC5CTEVORCk7XG5cdFx0XHRjdXJyZW50QmxlbmRpbmdFbmFibGVkID0gdHJ1ZTtcblx0XHR9XG5cdFx0aWYgKGJsZW5kaW5nICE9PSBDdXN0b21CbGVuZGluZykge1xuXHRcdFx0aWYgKGJsZW5kaW5nICE9PSBjdXJyZW50QmxlbmRpbmcgfHwgcHJlbXVsdGlwbGllZEFscGhhICE9PSBjdXJyZW50UHJlbXVsdGlwbGVkQWxwaGEpIHtcblx0XHRcdFx0aWYgKGN1cnJlbnRCbGVuZEVxdWF0aW9uICE9PSBBZGRFcXVhdGlvbiB8fCBjdXJyZW50QmxlbmRFcXVhdGlvbkFscGhhICE9PSBBZGRFcXVhdGlvbikge1xuXHRcdFx0XHRcdGdsLmJsZW5kRXF1YXRpb24oZ2wuRlVOQ19BREQpO1xuXHRcdFx0XHRcdGN1cnJlbnRCbGVuZEVxdWF0aW9uID0gQWRkRXF1YXRpb247XG5cdFx0XHRcdFx0Y3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSA9IEFkZEVxdWF0aW9uO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwcmVtdWx0aXBsaWVkQWxwaGEpIHtcblx0XHRcdFx0XHRzd2l0Y2ggKGJsZW5kaW5nKSB7XG5cdFx0XHRcdFx0XHRjYXNlIE5vcm1hbEJsZW5kaW5nOlxuXHRcdFx0XHRcdFx0XHRnbC5ibGVuZEZ1bmNTZXBhcmF0ZShnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEsIGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBBZGRpdGl2ZUJsZW5kaW5nOlxuXHRcdFx0XHRcdFx0XHRnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkUpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgU3VidHJhY3RpdmVCbGVuZGluZzpcblx0XHRcdFx0XHRcdFx0Z2wuYmxlbmRGdW5jU2VwYXJhdGUoZ2wuWkVSTywgZ2wuT05FX01JTlVTX1NSQ19DT0xPUiwgZ2wuWkVSTywgZ2wuT05FKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIE11bHRpcGx5QmxlbmRpbmc6XG5cdFx0XHRcdFx0XHRcdGdsLmJsZW5kRnVuY1NlcGFyYXRlKGdsLlpFUk8sIGdsLlNSQ19DT0xPUiwgZ2wuWkVSTywgZ2wuU1JDX0FMUEhBKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5XZWJHTFN0YXRlOiBJbnZhbGlkIGJsZW5kaW5nOiAnLCBibGVuZGluZyk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzd2l0Y2ggKGJsZW5kaW5nKSB7XG5cdFx0XHRcdFx0XHRjYXNlIE5vcm1hbEJsZW5kaW5nOlxuXHRcdFx0XHRcdFx0XHRnbC5ibGVuZEZ1bmNTZXBhcmF0ZShnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEsIGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBBZGRpdGl2ZUJsZW5kaW5nOlxuXHRcdFx0XHRcdFx0XHRnbC5ibGVuZEZ1bmMoZ2wuU1JDX0FMUEhBLCBnbC5PTkUpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgU3VidHJhY3RpdmVCbGVuZGluZzpcblx0XHRcdFx0XHRcdFx0Z2wuYmxlbmRGdW5jU2VwYXJhdGUoZ2wuWkVSTywgZ2wuT05FX01JTlVTX1NSQ19DT0xPUiwgZ2wuWkVSTywgZ2wuT05FKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIE11bHRpcGx5QmxlbmRpbmc6XG5cdFx0XHRcdFx0XHRcdGdsLmJsZW5kRnVuYyhnbC5aRVJPLCBnbC5TUkNfQ09MT1IpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLldlYkdMU3RhdGU6IEludmFsaWQgYmxlbmRpbmc6ICcsIGJsZW5kaW5nKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGN1cnJlbnRCbGVuZFNyYyA9IG51bGw7XG5cdFx0XHRcdGN1cnJlbnRCbGVuZERzdCA9IG51bGw7XG5cdFx0XHRcdGN1cnJlbnRCbGVuZFNyY0FscGhhID0gbnVsbDtcblx0XHRcdFx0Y3VycmVudEJsZW5kRHN0QWxwaGEgPSBudWxsO1xuXHRcdFx0XHRjdXJyZW50QmxlbmRpbmcgPSBibGVuZGluZztcblx0XHRcdFx0Y3VycmVudFByZW11bHRpcGxlZEFscGhhID0gcHJlbXVsdGlwbGllZEFscGhhO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGN1c3RvbSBibGVuZGluZ1xuXG5cdFx0YmxlbmRFcXVhdGlvbkFscGhhID0gYmxlbmRFcXVhdGlvbkFscGhhIHx8IGJsZW5kRXF1YXRpb247XG5cdFx0YmxlbmRTcmNBbHBoYSA9IGJsZW5kU3JjQWxwaGEgfHwgYmxlbmRTcmM7XG5cdFx0YmxlbmREc3RBbHBoYSA9IGJsZW5kRHN0QWxwaGEgfHwgYmxlbmREc3Q7XG5cdFx0aWYgKGJsZW5kRXF1YXRpb24gIT09IGN1cnJlbnRCbGVuZEVxdWF0aW9uIHx8IGJsZW5kRXF1YXRpb25BbHBoYSAhPT0gY3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSkge1xuXHRcdFx0Z2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKGVxdWF0aW9uVG9HTFtibGVuZEVxdWF0aW9uXSwgZXF1YXRpb25Ub0dMW2JsZW5kRXF1YXRpb25BbHBoYV0pO1xuXHRcdFx0Y3VycmVudEJsZW5kRXF1YXRpb24gPSBibGVuZEVxdWF0aW9uO1xuXHRcdFx0Y3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSA9IGJsZW5kRXF1YXRpb25BbHBoYTtcblx0XHR9XG5cdFx0aWYgKGJsZW5kU3JjICE9PSBjdXJyZW50QmxlbmRTcmMgfHwgYmxlbmREc3QgIT09IGN1cnJlbnRCbGVuZERzdCB8fCBibGVuZFNyY0FscGhhICE9PSBjdXJyZW50QmxlbmRTcmNBbHBoYSB8fCBibGVuZERzdEFscGhhICE9PSBjdXJyZW50QmxlbmREc3RBbHBoYSkge1xuXHRcdFx0Z2wuYmxlbmRGdW5jU2VwYXJhdGUoZmFjdG9yVG9HTFtibGVuZFNyY10sIGZhY3RvclRvR0xbYmxlbmREc3RdLCBmYWN0b3JUb0dMW2JsZW5kU3JjQWxwaGFdLCBmYWN0b3JUb0dMW2JsZW5kRHN0QWxwaGFdKTtcblx0XHRcdGN1cnJlbnRCbGVuZFNyYyA9IGJsZW5kU3JjO1xuXHRcdFx0Y3VycmVudEJsZW5kRHN0ID0gYmxlbmREc3Q7XG5cdFx0XHRjdXJyZW50QmxlbmRTcmNBbHBoYSA9IGJsZW5kU3JjQWxwaGE7XG5cdFx0XHRjdXJyZW50QmxlbmREc3RBbHBoYSA9IGJsZW5kRHN0QWxwaGE7XG5cdFx0fVxuXHRcdGN1cnJlbnRCbGVuZGluZyA9IGJsZW5kaW5nO1xuXHRcdGN1cnJlbnRQcmVtdWx0aXBsZWRBbHBoYSA9IG51bGw7XG5cdH1cblx0ZnVuY3Rpb24gc2V0TWF0ZXJpYWwobWF0ZXJpYWwsIGZyb250RmFjZUNXKSB7XG5cdFx0bWF0ZXJpYWwuc2lkZSA9PT0gRG91YmxlU2lkZSA/IGRpc2FibGUoZ2wuQ1VMTF9GQUNFKSA6IGVuYWJsZShnbC5DVUxMX0ZBQ0UpO1xuXHRcdGxldCBmbGlwU2lkZWQgPSBtYXRlcmlhbC5zaWRlID09PSBCYWNrU2lkZTtcblx0XHRpZiAoZnJvbnRGYWNlQ1cpIGZsaXBTaWRlZCA9ICFmbGlwU2lkZWQ7XG5cdFx0c2V0RmxpcFNpZGVkKGZsaXBTaWRlZCk7XG5cdFx0bWF0ZXJpYWwuYmxlbmRpbmcgPT09IE5vcm1hbEJsZW5kaW5nICYmIG1hdGVyaWFsLnRyYW5zcGFyZW50ID09PSBmYWxzZSA/IHNldEJsZW5kaW5nKE5vQmxlbmRpbmcpIDogc2V0QmxlbmRpbmcobWF0ZXJpYWwuYmxlbmRpbmcsIG1hdGVyaWFsLmJsZW5kRXF1YXRpb24sIG1hdGVyaWFsLmJsZW5kU3JjLCBtYXRlcmlhbC5ibGVuZERzdCwgbWF0ZXJpYWwuYmxlbmRFcXVhdGlvbkFscGhhLCBtYXRlcmlhbC5ibGVuZFNyY0FscGhhLCBtYXRlcmlhbC5ibGVuZERzdEFscGhhLCBtYXRlcmlhbC5wcmVtdWx0aXBsaWVkQWxwaGEpO1xuXHRcdGRlcHRoQnVmZmVyLnNldEZ1bmMobWF0ZXJpYWwuZGVwdGhGdW5jKTtcblx0XHRkZXB0aEJ1ZmZlci5zZXRUZXN0KG1hdGVyaWFsLmRlcHRoVGVzdCk7XG5cdFx0ZGVwdGhCdWZmZXIuc2V0TWFzayhtYXRlcmlhbC5kZXB0aFdyaXRlKTtcblx0XHRjb2xvckJ1ZmZlci5zZXRNYXNrKG1hdGVyaWFsLmNvbG9yV3JpdGUpO1xuXHRcdGNvbnN0IHN0ZW5jaWxXcml0ZSA9IG1hdGVyaWFsLnN0ZW5jaWxXcml0ZTtcblx0XHRzdGVuY2lsQnVmZmVyLnNldFRlc3Qoc3RlbmNpbFdyaXRlKTtcblx0XHRpZiAoc3RlbmNpbFdyaXRlKSB7XG5cdFx0XHRzdGVuY2lsQnVmZmVyLnNldE1hc2sobWF0ZXJpYWwuc3RlbmNpbFdyaXRlTWFzayk7XG5cdFx0XHRzdGVuY2lsQnVmZmVyLnNldEZ1bmMobWF0ZXJpYWwuc3RlbmNpbEZ1bmMsIG1hdGVyaWFsLnN0ZW5jaWxSZWYsIG1hdGVyaWFsLnN0ZW5jaWxGdW5jTWFzayk7XG5cdFx0XHRzdGVuY2lsQnVmZmVyLnNldE9wKG1hdGVyaWFsLnN0ZW5jaWxGYWlsLCBtYXRlcmlhbC5zdGVuY2lsWkZhaWwsIG1hdGVyaWFsLnN0ZW5jaWxaUGFzcyk7XG5cdFx0fVxuXHRcdHNldFBvbHlnb25PZmZzZXQobWF0ZXJpYWwucG9seWdvbk9mZnNldCwgbWF0ZXJpYWwucG9seWdvbk9mZnNldEZhY3RvciwgbWF0ZXJpYWwucG9seWdvbk9mZnNldFVuaXRzKTtcblx0XHRtYXRlcmlhbC5hbHBoYVRvQ292ZXJhZ2UgPT09IHRydWUgPyBlbmFibGUoZ2wuU0FNUExFX0FMUEhBX1RPX0NPVkVSQUdFKSA6IGRpc2FibGUoZ2wuU0FNUExFX0FMUEhBX1RPX0NPVkVSQUdFKTtcblx0fVxuXG5cdC8vXG5cblx0ZnVuY3Rpb24gc2V0RmxpcFNpZGVkKGZsaXBTaWRlZCkge1xuXHRcdGlmIChjdXJyZW50RmxpcFNpZGVkICE9PSBmbGlwU2lkZWQpIHtcblx0XHRcdGlmIChmbGlwU2lkZWQpIHtcblx0XHRcdFx0Z2wuZnJvbnRGYWNlKGdsLkNXKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGdsLmZyb250RmFjZShnbC5DQ1cpO1xuXHRcdFx0fVxuXHRcdFx0Y3VycmVudEZsaXBTaWRlZCA9IGZsaXBTaWRlZDtcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gc2V0Q3VsbEZhY2UoY3VsbEZhY2UpIHtcblx0XHRpZiAoY3VsbEZhY2UgIT09IEN1bGxGYWNlTm9uZSkge1xuXHRcdFx0ZW5hYmxlKGdsLkNVTExfRkFDRSk7XG5cdFx0XHRpZiAoY3VsbEZhY2UgIT09IGN1cnJlbnRDdWxsRmFjZSkge1xuXHRcdFx0XHRpZiAoY3VsbEZhY2UgPT09IEN1bGxGYWNlQmFjaykge1xuXHRcdFx0XHRcdGdsLmN1bGxGYWNlKGdsLkJBQ0spO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGN1bGxGYWNlID09PSBDdWxsRmFjZUZyb250KSB7XG5cdFx0XHRcdFx0Z2wuY3VsbEZhY2UoZ2wuRlJPTlQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGdsLmN1bGxGYWNlKGdsLkZST05UX0FORF9CQUNLKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRkaXNhYmxlKGdsLkNVTExfRkFDRSk7XG5cdFx0fVxuXHRcdGN1cnJlbnRDdWxsRmFjZSA9IGN1bGxGYWNlO1xuXHR9XG5cdGZ1bmN0aW9uIHNldExpbmVXaWR0aCh3aWR0aCkge1xuXHRcdGlmICh3aWR0aCAhPT0gY3VycmVudExpbmVXaWR0aCkge1xuXHRcdFx0aWYgKGxpbmVXaWR0aEF2YWlsYWJsZSkgZ2wubGluZVdpZHRoKHdpZHRoKTtcblx0XHRcdGN1cnJlbnRMaW5lV2lkdGggPSB3aWR0aDtcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gc2V0UG9seWdvbk9mZnNldChwb2x5Z29uT2Zmc2V0LCBmYWN0b3IsIHVuaXRzKSB7XG5cdFx0aWYgKHBvbHlnb25PZmZzZXQpIHtcblx0XHRcdGVuYWJsZShnbC5QT0xZR09OX09GRlNFVF9GSUxMKTtcblx0XHRcdGlmIChjdXJyZW50UG9seWdvbk9mZnNldEZhY3RvciAhPT0gZmFjdG9yIHx8IGN1cnJlbnRQb2x5Z29uT2Zmc2V0VW5pdHMgIT09IHVuaXRzKSB7XG5cdFx0XHRcdGdsLnBvbHlnb25PZmZzZXQoZmFjdG9yLCB1bml0cyk7XG5cdFx0XHRcdGN1cnJlbnRQb2x5Z29uT2Zmc2V0RmFjdG9yID0gZmFjdG9yO1xuXHRcdFx0XHRjdXJyZW50UG9seWdvbk9mZnNldFVuaXRzID0gdW5pdHM7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRpc2FibGUoZ2wuUE9MWUdPTl9PRkZTRVRfRklMTCk7XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHNldFNjaXNzb3JUZXN0KHNjaXNzb3JUZXN0KSB7XG5cdFx0aWYgKHNjaXNzb3JUZXN0KSB7XG5cdFx0XHRlbmFibGUoZ2wuU0NJU1NPUl9URVNUKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGlzYWJsZShnbC5TQ0lTU09SX1RFU1QpO1xuXHRcdH1cblx0fVxuXG5cdC8vIHRleHR1cmVcblxuXHRmdW5jdGlvbiBhY3RpdmVUZXh0dXJlKHdlYmdsU2xvdCkge1xuXHRcdGlmICh3ZWJnbFNsb3QgPT09IHVuZGVmaW5lZCkgd2ViZ2xTbG90ID0gZ2wuVEVYVFVSRTAgKyBtYXhUZXh0dXJlcyAtIDE7XG5cdFx0aWYgKGN1cnJlbnRUZXh0dXJlU2xvdCAhPT0gd2ViZ2xTbG90KSB7XG5cdFx0XHRnbC5hY3RpdmVUZXh0dXJlKHdlYmdsU2xvdCk7XG5cdFx0XHRjdXJyZW50VGV4dHVyZVNsb3QgPSB3ZWJnbFNsb3Q7XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIGJpbmRUZXh0dXJlKHdlYmdsVHlwZSwgd2ViZ2xUZXh0dXJlLCB3ZWJnbFNsb3QpIHtcblx0XHRpZiAod2ViZ2xTbG90ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGlmIChjdXJyZW50VGV4dHVyZVNsb3QgPT09IG51bGwpIHtcblx0XHRcdFx0d2ViZ2xTbG90ID0gZ2wuVEVYVFVSRTAgKyBtYXhUZXh0dXJlcyAtIDE7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3ZWJnbFNsb3QgPSBjdXJyZW50VGV4dHVyZVNsb3Q7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGxldCBib3VuZFRleHR1cmUgPSBjdXJyZW50Qm91bmRUZXh0dXJlc1t3ZWJnbFNsb3RdO1xuXHRcdGlmIChib3VuZFRleHR1cmUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Ym91bmRUZXh0dXJlID0ge1xuXHRcdFx0XHR0eXBlOiB1bmRlZmluZWQsXG5cdFx0XHRcdHRleHR1cmU6IHVuZGVmaW5lZFxuXHRcdFx0fTtcblx0XHRcdGN1cnJlbnRCb3VuZFRleHR1cmVzW3dlYmdsU2xvdF0gPSBib3VuZFRleHR1cmU7XG5cdFx0fVxuXHRcdGlmIChib3VuZFRleHR1cmUudHlwZSAhPT0gd2ViZ2xUeXBlIHx8IGJvdW5kVGV4dHVyZS50ZXh0dXJlICE9PSB3ZWJnbFRleHR1cmUpIHtcblx0XHRcdGlmIChjdXJyZW50VGV4dHVyZVNsb3QgIT09IHdlYmdsU2xvdCkge1xuXHRcdFx0XHRnbC5hY3RpdmVUZXh0dXJlKHdlYmdsU2xvdCk7XG5cdFx0XHRcdGN1cnJlbnRUZXh0dXJlU2xvdCA9IHdlYmdsU2xvdDtcblx0XHRcdH1cblx0XHRcdGdsLmJpbmRUZXh0dXJlKHdlYmdsVHlwZSwgd2ViZ2xUZXh0dXJlIHx8IGVtcHR5VGV4dHVyZXNbd2ViZ2xUeXBlXSk7XG5cdFx0XHRib3VuZFRleHR1cmUudHlwZSA9IHdlYmdsVHlwZTtcblx0XHRcdGJvdW5kVGV4dHVyZS50ZXh0dXJlID0gd2ViZ2xUZXh0dXJlO1xuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1bmJpbmRUZXh0dXJlKCkge1xuXHRcdGNvbnN0IGJvdW5kVGV4dHVyZSA9IGN1cnJlbnRCb3VuZFRleHR1cmVzW2N1cnJlbnRUZXh0dXJlU2xvdF07XG5cdFx0aWYgKGJvdW5kVGV4dHVyZSAhPT0gdW5kZWZpbmVkICYmIGJvdW5kVGV4dHVyZS50eXBlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGdsLmJpbmRUZXh0dXJlKGJvdW5kVGV4dHVyZS50eXBlLCBudWxsKTtcblx0XHRcdGJvdW5kVGV4dHVyZS50eXBlID0gdW5kZWZpbmVkO1xuXHRcdFx0Ym91bmRUZXh0dXJlLnRleHR1cmUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIGNvbXByZXNzZWRUZXhJbWFnZTJEKCkge1xuXHRcdHRyeSB7XG5cdFx0XHRnbC5jb21wcmVzc2VkVGV4SW1hZ2UyRC5hcHBseShnbCwgYXJndW1lbnRzKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuV2ViR0xTdGF0ZTonLCBlcnJvcik7XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIGNvbXByZXNzZWRUZXhJbWFnZTNEKCkge1xuXHRcdHRyeSB7XG5cdFx0XHRnbC5jb21wcmVzc2VkVGV4SW1hZ2UzRC5hcHBseShnbCwgYXJndW1lbnRzKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuV2ViR0xTdGF0ZTonLCBlcnJvcik7XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHRleFN1YkltYWdlMkQoKSB7XG5cdFx0dHJ5IHtcblx0XHRcdGdsLnRleFN1YkltYWdlMkQuYXBwbHkoZ2wsIGFyZ3VtZW50cyk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLldlYkdMU3RhdGU6JywgZXJyb3IpO1xuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB0ZXhTdWJJbWFnZTNEKCkge1xuXHRcdHRyeSB7XG5cdFx0XHRnbC50ZXhTdWJJbWFnZTNELmFwcGx5KGdsLCBhcmd1bWVudHMpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5XZWJHTFN0YXRlOicsIGVycm9yKTtcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gY29tcHJlc3NlZFRleFN1YkltYWdlMkQoKSB7XG5cdFx0dHJ5IHtcblx0XHRcdGdsLmNvbXByZXNzZWRUZXhTdWJJbWFnZTJELmFwcGx5KGdsLCBhcmd1bWVudHMpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5XZWJHTFN0YXRlOicsIGVycm9yKTtcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gY29tcHJlc3NlZFRleFN1YkltYWdlM0QoKSB7XG5cdFx0dHJ5IHtcblx0XHRcdGdsLmNvbXByZXNzZWRUZXhTdWJJbWFnZTNELmFwcGx5KGdsLCBhcmd1bWVudHMpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5XZWJHTFN0YXRlOicsIGVycm9yKTtcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gdGV4U3RvcmFnZTJEKCkge1xuXHRcdHRyeSB7XG5cdFx0XHRnbC50ZXhTdG9yYWdlMkQuYXBwbHkoZ2wsIGFyZ3VtZW50cyk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLldlYkdMU3RhdGU6JywgZXJyb3IpO1xuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB0ZXhTdG9yYWdlM0QoKSB7XG5cdFx0dHJ5IHtcblx0XHRcdGdsLnRleFN0b3JhZ2UzRC5hcHBseShnbCwgYXJndW1lbnRzKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuV2ViR0xTdGF0ZTonLCBlcnJvcik7XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHRleEltYWdlMkQoKSB7XG5cdFx0dHJ5IHtcblx0XHRcdGdsLnRleEltYWdlMkQuYXBwbHkoZ2wsIGFyZ3VtZW50cyk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLldlYkdMU3RhdGU6JywgZXJyb3IpO1xuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB0ZXhJbWFnZTNEKCkge1xuXHRcdHRyeSB7XG5cdFx0XHRnbC50ZXhJbWFnZTNELmFwcGx5KGdsLCBhcmd1bWVudHMpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5XZWJHTFN0YXRlOicsIGVycm9yKTtcblx0XHR9XG5cdH1cblxuXHQvL1xuXG5cdGZ1bmN0aW9uIHNjaXNzb3Ioc2Npc3Nvcikge1xuXHRcdGlmIChjdXJyZW50U2Npc3Nvci5lcXVhbHMoc2Npc3NvcikgPT09IGZhbHNlKSB7XG5cdFx0XHRnbC5zY2lzc29yKHNjaXNzb3IueCwgc2Npc3Nvci55LCBzY2lzc29yLnosIHNjaXNzb3Iudyk7XG5cdFx0XHRjdXJyZW50U2Npc3Nvci5jb3B5KHNjaXNzb3IpO1xuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB2aWV3cG9ydCh2aWV3cG9ydCkge1xuXHRcdGlmIChjdXJyZW50Vmlld3BvcnQuZXF1YWxzKHZpZXdwb3J0KSA9PT0gZmFsc2UpIHtcblx0XHRcdGdsLnZpZXdwb3J0KHZpZXdwb3J0LngsIHZpZXdwb3J0LnksIHZpZXdwb3J0LnosIHZpZXdwb3J0LncpO1xuXHRcdFx0Y3VycmVudFZpZXdwb3J0LmNvcHkodmlld3BvcnQpO1xuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVVQk9NYXBwaW5nKHVuaWZvcm1zR3JvdXAsIHByb2dyYW0pIHtcblx0XHRsZXQgbWFwcGluZyA9IHVib1Byb2dhbU1hcC5nZXQocHJvZ3JhbSk7XG5cdFx0aWYgKG1hcHBpbmcgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0bWFwcGluZyA9IG5ldyBXZWFrTWFwKCk7XG5cdFx0XHR1Ym9Qcm9nYW1NYXAuc2V0KHByb2dyYW0sIG1hcHBpbmcpO1xuXHRcdH1cblx0XHRsZXQgYmxvY2tJbmRleCA9IG1hcHBpbmcuZ2V0KHVuaWZvcm1zR3JvdXApO1xuXHRcdGlmIChibG9ja0luZGV4ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGJsb2NrSW5kZXggPSBnbC5nZXRVbmlmb3JtQmxvY2tJbmRleChwcm9ncmFtLCB1bmlmb3Jtc0dyb3VwLm5hbWUpO1xuXHRcdFx0bWFwcGluZy5zZXQodW5pZm9ybXNHcm91cCwgYmxvY2tJbmRleCk7XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVuaWZvcm1CbG9ja0JpbmRpbmcodW5pZm9ybXNHcm91cCwgcHJvZ3JhbSkge1xuXHRcdGNvbnN0IG1hcHBpbmcgPSB1Ym9Qcm9nYW1NYXAuZ2V0KHByb2dyYW0pO1xuXHRcdGNvbnN0IGJsb2NrSW5kZXggPSBtYXBwaW5nLmdldCh1bmlmb3Jtc0dyb3VwKTtcblx0XHRpZiAodWJvQmluZGluZ3MuZ2V0KHVuaWZvcm1zR3JvdXApICE9PSBibG9ja0luZGV4KSB7XG5cdFx0XHQvLyBiaW5kIHNoYWRlciBzcGVjaWZpYyBibG9jayBpbmRleCB0byBnbG9iYWwgYmxvY2sgcG9pbnRcblxuXHRcdFx0Z2wudW5pZm9ybUJsb2NrQmluZGluZyhwcm9ncmFtLCBibG9ja0luZGV4LCB1bmlmb3Jtc0dyb3VwLl9fYmluZGluZ1BvaW50SW5kZXgpO1xuXHRcdFx0dWJvQmluZGluZ3Muc2V0KHVuaWZvcm1zR3JvdXAsIGJsb2NrSW5kZXgpO1xuXHRcdH1cblx0fVxuXG5cdC8vXG5cblx0ZnVuY3Rpb24gcmVzZXQoKSB7XG5cdFx0Ly8gcmVzZXQgc3RhdGVcblxuXHRcdGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuXHRcdGdsLmRpc2FibGUoZ2wuQ1VMTF9GQUNFKTtcblx0XHRnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xuXHRcdGdsLmRpc2FibGUoZ2wuUE9MWUdPTl9PRkZTRVRfRklMTCk7XG5cdFx0Z2wuZGlzYWJsZShnbC5TQ0lTU09SX1RFU1QpO1xuXHRcdGdsLmRpc2FibGUoZ2wuU1RFTkNJTF9URVNUKTtcblx0XHRnbC5kaXNhYmxlKGdsLlNBTVBMRV9BTFBIQV9UT19DT1ZFUkFHRSk7XG5cdFx0Z2wuYmxlbmRFcXVhdGlvbihnbC5GVU5DX0FERCk7XG5cdFx0Z2wuYmxlbmRGdW5jKGdsLk9ORSwgZ2wuWkVSTyk7XG5cdFx0Z2wuYmxlbmRGdW5jU2VwYXJhdGUoZ2wuT05FLCBnbC5aRVJPLCBnbC5PTkUsIGdsLlpFUk8pO1xuXHRcdGdsLmNvbG9yTWFzayh0cnVlLCB0cnVlLCB0cnVlLCB0cnVlKTtcblx0XHRnbC5jbGVhckNvbG9yKDAsIDAsIDAsIDApO1xuXHRcdGdsLmRlcHRoTWFzayh0cnVlKTtcblx0XHRnbC5kZXB0aEZ1bmMoZ2wuTEVTUyk7XG5cdFx0Z2wuY2xlYXJEZXB0aCgxKTtcblx0XHRnbC5zdGVuY2lsTWFzaygweGZmZmZmZmZmKTtcblx0XHRnbC5zdGVuY2lsRnVuYyhnbC5BTFdBWVMsIDAsIDB4ZmZmZmZmZmYpO1xuXHRcdGdsLnN0ZW5jaWxPcChnbC5LRUVQLCBnbC5LRUVQLCBnbC5LRUVQKTtcblx0XHRnbC5jbGVhclN0ZW5jaWwoMCk7XG5cdFx0Z2wuY3VsbEZhY2UoZ2wuQkFDSyk7XG5cdFx0Z2wuZnJvbnRGYWNlKGdsLkNDVyk7XG5cdFx0Z2wucG9seWdvbk9mZnNldCgwLCAwKTtcblx0XHRnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcblx0XHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuXHRcdGlmIChpc1dlYkdMMiA9PT0gdHJ1ZSkge1xuXHRcdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLkRSQVdfRlJBTUVCVUZGRVIsIG51bGwpO1xuXHRcdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLlJFQURfRlJBTUVCVUZGRVIsIG51bGwpO1xuXHRcdH1cblx0XHRnbC51c2VQcm9ncmFtKG51bGwpO1xuXHRcdGdsLmxpbmVXaWR0aCgxKTtcblx0XHRnbC5zY2lzc29yKDAsIDAsIGdsLmNhbnZhcy53aWR0aCwgZ2wuY2FudmFzLmhlaWdodCk7XG5cdFx0Z2wudmlld3BvcnQoMCwgMCwgZ2wuY2FudmFzLndpZHRoLCBnbC5jYW52YXMuaGVpZ2h0KTtcblxuXHRcdC8vIHJlc2V0IGludGVybmFsc1xuXG5cdFx0ZW5hYmxlZENhcGFiaWxpdGllcyA9IHt9O1xuXHRcdGN1cnJlbnRUZXh0dXJlU2xvdCA9IG51bGw7XG5cdFx0Y3VycmVudEJvdW5kVGV4dHVyZXMgPSB7fTtcblx0XHRjdXJyZW50Qm91bmRGcmFtZWJ1ZmZlcnMgPSB7fTtcblx0XHRjdXJyZW50RHJhd2J1ZmZlcnMgPSBuZXcgV2Vha01hcCgpO1xuXHRcdGRlZmF1bHREcmF3YnVmZmVycyA9IFtdO1xuXHRcdGN1cnJlbnRQcm9ncmFtID0gbnVsbDtcblx0XHRjdXJyZW50QmxlbmRpbmdFbmFibGVkID0gZmFsc2U7XG5cdFx0Y3VycmVudEJsZW5kaW5nID0gbnVsbDtcblx0XHRjdXJyZW50QmxlbmRFcXVhdGlvbiA9IG51bGw7XG5cdFx0Y3VycmVudEJsZW5kU3JjID0gbnVsbDtcblx0XHRjdXJyZW50QmxlbmREc3QgPSBudWxsO1xuXHRcdGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgPSBudWxsO1xuXHRcdGN1cnJlbnRCbGVuZFNyY0FscGhhID0gbnVsbDtcblx0XHRjdXJyZW50QmxlbmREc3RBbHBoYSA9IG51bGw7XG5cdFx0Y3VycmVudFByZW11bHRpcGxlZEFscGhhID0gZmFsc2U7XG5cdFx0Y3VycmVudEZsaXBTaWRlZCA9IG51bGw7XG5cdFx0Y3VycmVudEN1bGxGYWNlID0gbnVsbDtcblx0XHRjdXJyZW50TGluZVdpZHRoID0gbnVsbDtcblx0XHRjdXJyZW50UG9seWdvbk9mZnNldEZhY3RvciA9IG51bGw7XG5cdFx0Y3VycmVudFBvbHlnb25PZmZzZXRVbml0cyA9IG51bGw7XG5cdFx0Y3VycmVudFNjaXNzb3Iuc2V0KDAsIDAsIGdsLmNhbnZhcy53aWR0aCwgZ2wuY2FudmFzLmhlaWdodCk7XG5cdFx0Y3VycmVudFZpZXdwb3J0LnNldCgwLCAwLCBnbC5jYW52YXMud2lkdGgsIGdsLmNhbnZhcy5oZWlnaHQpO1xuXHRcdGNvbG9yQnVmZmVyLnJlc2V0KCk7XG5cdFx0ZGVwdGhCdWZmZXIucmVzZXQoKTtcblx0XHRzdGVuY2lsQnVmZmVyLnJlc2V0KCk7XG5cdH1cblx0cmV0dXJuIHtcblx0XHRidWZmZXJzOiB7XG5cdFx0XHRjb2xvcjogY29sb3JCdWZmZXIsXG5cdFx0XHRkZXB0aDogZGVwdGhCdWZmZXIsXG5cdFx0XHRzdGVuY2lsOiBzdGVuY2lsQnVmZmVyXG5cdFx0fSxcblx0XHRlbmFibGU6IGVuYWJsZSxcblx0XHRkaXNhYmxlOiBkaXNhYmxlLFxuXHRcdGJpbmRGcmFtZWJ1ZmZlcjogYmluZEZyYW1lYnVmZmVyLFxuXHRcdGRyYXdCdWZmZXJzOiBkcmF3QnVmZmVycyxcblx0XHR1c2VQcm9ncmFtOiB1c2VQcm9ncmFtLFxuXHRcdHNldEJsZW5kaW5nOiBzZXRCbGVuZGluZyxcblx0XHRzZXRNYXRlcmlhbDogc2V0TWF0ZXJpYWwsXG5cdFx0c2V0RmxpcFNpZGVkOiBzZXRGbGlwU2lkZWQsXG5cdFx0c2V0Q3VsbEZhY2U6IHNldEN1bGxGYWNlLFxuXHRcdHNldExpbmVXaWR0aDogc2V0TGluZVdpZHRoLFxuXHRcdHNldFBvbHlnb25PZmZzZXQ6IHNldFBvbHlnb25PZmZzZXQsXG5cdFx0c2V0U2Npc3NvclRlc3Q6IHNldFNjaXNzb3JUZXN0LFxuXHRcdGFjdGl2ZVRleHR1cmU6IGFjdGl2ZVRleHR1cmUsXG5cdFx0YmluZFRleHR1cmU6IGJpbmRUZXh0dXJlLFxuXHRcdHVuYmluZFRleHR1cmU6IHVuYmluZFRleHR1cmUsXG5cdFx0Y29tcHJlc3NlZFRleEltYWdlMkQ6IGNvbXByZXNzZWRUZXhJbWFnZTJELFxuXHRcdGNvbXByZXNzZWRUZXhJbWFnZTNEOiBjb21wcmVzc2VkVGV4SW1hZ2UzRCxcblx0XHR0ZXhJbWFnZTJEOiB0ZXhJbWFnZTJELFxuXHRcdHRleEltYWdlM0Q6IHRleEltYWdlM0QsXG5cdFx0dXBkYXRlVUJPTWFwcGluZzogdXBkYXRlVUJPTWFwcGluZyxcblx0XHR1bmlmb3JtQmxvY2tCaW5kaW5nOiB1bmlmb3JtQmxvY2tCaW5kaW5nLFxuXHRcdHRleFN0b3JhZ2UyRDogdGV4U3RvcmFnZTJELFxuXHRcdHRleFN0b3JhZ2UzRDogdGV4U3RvcmFnZTNELFxuXHRcdHRleFN1YkltYWdlMkQ6IHRleFN1YkltYWdlMkQsXG5cdFx0dGV4U3ViSW1hZ2UzRDogdGV4U3ViSW1hZ2UzRCxcblx0XHRjb21wcmVzc2VkVGV4U3ViSW1hZ2UyRDogY29tcHJlc3NlZFRleFN1YkltYWdlMkQsXG5cdFx0Y29tcHJlc3NlZFRleFN1YkltYWdlM0Q6IGNvbXByZXNzZWRUZXhTdWJJbWFnZTNELFxuXHRcdHNjaXNzb3I6IHNjaXNzb3IsXG5cdFx0dmlld3BvcnQ6IHZpZXdwb3J0LFxuXHRcdHJlc2V0OiByZXNldFxuXHR9O1xufVxuXG5mdW5jdGlvbiBXZWJHTFRleHR1cmVzKF9nbCwgZXh0ZW5zaW9ucywgc3RhdGUsIHByb3BlcnRpZXMsIGNhcGFiaWxpdGllcywgdXRpbHMsIGluZm8pIHtcblx0Y29uc3QgaXNXZWJHTDIgPSBjYXBhYmlsaXRpZXMuaXNXZWJHTDI7XG5cdGNvbnN0IG1heFRleHR1cmVzID0gY2FwYWJpbGl0aWVzLm1heFRleHR1cmVzO1xuXHRjb25zdCBtYXhDdWJlbWFwU2l6ZSA9IGNhcGFiaWxpdGllcy5tYXhDdWJlbWFwU2l6ZTtcblx0Y29uc3QgbWF4VGV4dHVyZVNpemUgPSBjYXBhYmlsaXRpZXMubWF4VGV4dHVyZVNpemU7XG5cdGNvbnN0IG1heFNhbXBsZXMgPSBjYXBhYmlsaXRpZXMubWF4U2FtcGxlcztcblx0Y29uc3QgbXVsdGlzYW1wbGVkUlRURXh0ID0gZXh0ZW5zaW9ucy5oYXMoJ1dFQkdMX211bHRpc2FtcGxlZF9yZW5kZXJfdG9fdGV4dHVyZScpID8gZXh0ZW5zaW9ucy5nZXQoJ1dFQkdMX211bHRpc2FtcGxlZF9yZW5kZXJfdG9fdGV4dHVyZScpIDogbnVsbDtcblx0Y29uc3Qgc3VwcG9ydHNJbnZhbGlkYXRlRnJhbWVidWZmZXIgPSAvT2N1bHVzQnJvd3Nlci9nLnRlc3QodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcgPyAnJyA6IG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXHRjb25zdCBfdmlkZW9UZXh0dXJlcyA9IG5ldyBXZWFrTWFwKCk7XG5cdGxldCBfY2FudmFzO1xuXHRjb25zdCBfc291cmNlcyA9IG5ldyBXZWFrTWFwKCk7IC8vIG1hcHMgV2ViZ2xUZXh0dXJlIG9iamVjdHMgdG8gaW5zdGFuY2VzIG9mIFNvdXJjZVxuXG5cdC8vIGNvcmRvdmEgaU9TIChhcyBvZiA1LjApIHN0aWxsIHVzZXMgVUlXZWJWaWV3LCB3aGljaCBwcm92aWRlcyBPZmZzY3JlZW5DYW52YXMsXG5cdC8vIGFsc28gT2Zmc2NyZWVuQ2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbFwiKSwgYnV0IG5vdCBPZmZzY3JlZW5DYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpIVxuXHQvLyBTb21lIGltcGxlbWVudGF0aW9ucyBtYXkgb25seSBpbXBsZW1lbnQgT2Zmc2NyZWVuQ2FudmFzIHBhcnRpYWxseSAoZS5nLiBsYWNraW5nIDJkKS5cblxuXHRsZXQgdXNlT2Zmc2NyZWVuQ2FudmFzID0gZmFsc2U7XG5cdHRyeSB7XG5cdFx0dXNlT2Zmc2NyZWVuQ2FudmFzID0gdHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCdcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGF0L2NvbXBhdFxuXHRcdCYmIG5ldyBPZmZzY3JlZW5DYW52YXMoMSwgMSkuZ2V0Q29udGV4dCgnMmQnKSAhPT0gbnVsbDtcblx0fSBjYXRjaCAoZXJyKSB7XG5cblx0XHQvLyBJZ25vcmUgYW55IGVycm9yc1xuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0Ly8gVXNlIE9mZnNjcmVlbkNhbnZhcyB3aGVuIGF2YWlsYWJsZS4gU3BlY2lhbGx5IG5lZWRlZCBpbiB3ZWIgd29ya2Vyc1xuXG5cdFx0cmV0dXJuIHVzZU9mZnNjcmVlbkNhbnZhcyA/XG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBhdC9jb21wYXRcblx0XHRuZXcgT2Zmc2NyZWVuQ2FudmFzKHdpZHRoLCBoZWlnaHQpIDogY3JlYXRlRWxlbWVudE5TKCdjYW52YXMnKTtcblx0fVxuXHRmdW5jdGlvbiByZXNpemVJbWFnZShpbWFnZSwgbmVlZHNQb3dlck9mVHdvLCBuZWVkc05ld0NhbnZhcywgbWF4U2l6ZSkge1xuXHRcdGxldCBzY2FsZSA9IDE7XG5cblx0XHQvLyBoYW5kbGUgY2FzZSBpZiB0ZXh0dXJlIGV4Y2VlZHMgbWF4IHNpemVcblxuXHRcdGlmIChpbWFnZS53aWR0aCA+IG1heFNpemUgfHwgaW1hZ2UuaGVpZ2h0ID4gbWF4U2l6ZSkge1xuXHRcdFx0c2NhbGUgPSBtYXhTaXplIC8gTWF0aC5tYXgoaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCk7XG5cdFx0fVxuXG5cdFx0Ly8gb25seSBwZXJmb3JtIHJlc2l6ZSBpZiBuZWNlc3NhcnlcblxuXHRcdGlmIChzY2FsZSA8IDEgfHwgbmVlZHNQb3dlck9mVHdvID09PSB0cnVlKSB7XG5cdFx0XHQvLyBvbmx5IHBlcmZvcm0gcmVzaXplIGZvciBjZXJ0YWluIGltYWdlIHR5cGVzXG5cblx0XHRcdGlmICh0eXBlb2YgSFRNTEltYWdlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50IHx8IHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCB8fCB0eXBlb2YgSW1hZ2VCaXRtYXAgIT09ICd1bmRlZmluZWQnICYmIGltYWdlIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXApIHtcblx0XHRcdFx0Y29uc3QgZmxvb3IgPSBuZWVkc1Bvd2VyT2ZUd28gPyBmbG9vclBvd2VyT2ZUd28gOiBNYXRoLmZsb29yO1xuXHRcdFx0XHRjb25zdCB3aWR0aCA9IGZsb29yKHNjYWxlICogaW1hZ2Uud2lkdGgpO1xuXHRcdFx0XHRjb25zdCBoZWlnaHQgPSBmbG9vcihzY2FsZSAqIGltYWdlLmhlaWdodCk7XG5cdFx0XHRcdGlmIChfY2FudmFzID09PSB1bmRlZmluZWQpIF9jYW52YXMgPSBjcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCk7XG5cblx0XHRcdFx0Ly8gY3ViZSB0ZXh0dXJlcyBjYW4ndCByZXVzZSB0aGUgc2FtZSBjYW52YXNcblxuXHRcdFx0XHRjb25zdCBjYW52YXMgPSBuZWVkc05ld0NhbnZhcyA/IGNyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KSA6IF9jYW52YXM7XG5cdFx0XHRcdGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuXHRcdFx0XHRjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdFx0XHRjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cdFx0XHRcdGNvbnRleHQuZHJhd0ltYWdlKGltYWdlLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIGhhcyBiZWVuIHJlc2l6ZWQgZnJvbSAoJyArIGltYWdlLndpZHRoICsgJ3gnICsgaW1hZ2UuaGVpZ2h0ICsgJykgdG8gKCcgKyB3aWR0aCArICd4JyArIGhlaWdodCArICcpLicpO1xuXHRcdFx0XHRyZXR1cm4gY2FudmFzO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCdkYXRhJyBpbiBpbWFnZSkge1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogSW1hZ2UgaW4gRGF0YVRleHR1cmUgaXMgdG9vIGJpZyAoJyArIGltYWdlLndpZHRoICsgJ3gnICsgaW1hZ2UuaGVpZ2h0ICsgJykuJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGltYWdlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gaW1hZ2U7XG5cdH1cblx0ZnVuY3Rpb24gaXNQb3dlck9mVHdvJDEoaW1hZ2UpIHtcblx0XHRyZXR1cm4gaXNQb3dlck9mVHdvKGltYWdlLndpZHRoKSAmJiBpc1Bvd2VyT2ZUd28oaW1hZ2UuaGVpZ2h0KTtcblx0fVxuXHRmdW5jdGlvbiB0ZXh0dXJlTmVlZHNQb3dlck9mVHdvKHRleHR1cmUpIHtcblx0XHRpZiAoaXNXZWJHTDIpIHJldHVybiBmYWxzZTtcblx0XHRyZXR1cm4gdGV4dHVyZS53cmFwUyAhPT0gQ2xhbXBUb0VkZ2VXcmFwcGluZyB8fCB0ZXh0dXJlLndyYXBUICE9PSBDbGFtcFRvRWRnZVdyYXBwaW5nIHx8IHRleHR1cmUubWluRmlsdGVyICE9PSBOZWFyZXN0RmlsdGVyICYmIHRleHR1cmUubWluRmlsdGVyICE9PSBMaW5lYXJGaWx0ZXI7XG5cdH1cblx0ZnVuY3Rpb24gdGV4dHVyZU5lZWRzR2VuZXJhdGVNaXBtYXBzKHRleHR1cmUsIHN1cHBvcnRzTWlwcykge1xuXHRcdHJldHVybiB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyAmJiBzdXBwb3J0c01pcHMgJiYgdGV4dHVyZS5taW5GaWx0ZXIgIT09IE5lYXJlc3RGaWx0ZXIgJiYgdGV4dHVyZS5taW5GaWx0ZXIgIT09IExpbmVhckZpbHRlcjtcblx0fVxuXHRmdW5jdGlvbiBnZW5lcmF0ZU1pcG1hcCh0YXJnZXQpIHtcblx0XHRfZ2wuZ2VuZXJhdGVNaXBtYXAodGFyZ2V0KTtcblx0fVxuXHRmdW5jdGlvbiBnZXRJbnRlcm5hbEZvcm1hdChpbnRlcm5hbEZvcm1hdE5hbWUsIGdsRm9ybWF0LCBnbFR5cGUsIGVuY29kaW5nLCBmb3JjZUxpbmVhckVuY29kaW5nID0gZmFsc2UpIHtcblx0XHRpZiAoaXNXZWJHTDIgPT09IGZhbHNlKSByZXR1cm4gZ2xGb3JtYXQ7XG5cdFx0aWYgKGludGVybmFsRm9ybWF0TmFtZSAhPT0gbnVsbCkge1xuXHRcdFx0aWYgKF9nbFtpbnRlcm5hbEZvcm1hdE5hbWVdICE9PSB1bmRlZmluZWQpIHJldHVybiBfZ2xbaW50ZXJuYWxGb3JtYXROYW1lXTtcblx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogQXR0ZW1wdCB0byB1c2Ugbm9uLWV4aXN0aW5nIFdlYkdMIGludGVybmFsIGZvcm1hdCBcXCcnICsgaW50ZXJuYWxGb3JtYXROYW1lICsgJ1xcJycpO1xuXHRcdH1cblx0XHRsZXQgaW50ZXJuYWxGb3JtYXQgPSBnbEZvcm1hdDtcblx0XHRpZiAoZ2xGb3JtYXQgPT09IF9nbC5SRUQpIHtcblx0XHRcdGlmIChnbFR5cGUgPT09IF9nbC5GTE9BVCkgaW50ZXJuYWxGb3JtYXQgPSBfZ2wuUjMyRjtcblx0XHRcdGlmIChnbFR5cGUgPT09IF9nbC5IQUxGX0ZMT0FUKSBpbnRlcm5hbEZvcm1hdCA9IF9nbC5SMTZGO1xuXHRcdFx0aWYgKGdsVHlwZSA9PT0gX2dsLlVOU0lHTkVEX0JZVEUpIGludGVybmFsRm9ybWF0ID0gX2dsLlI4O1xuXHRcdH1cblx0XHRpZiAoZ2xGb3JtYXQgPT09IF9nbC5SRykge1xuXHRcdFx0aWYgKGdsVHlwZSA9PT0gX2dsLkZMT0FUKSBpbnRlcm5hbEZvcm1hdCA9IF9nbC5SRzMyRjtcblx0XHRcdGlmIChnbFR5cGUgPT09IF9nbC5IQUxGX0ZMT0FUKSBpbnRlcm5hbEZvcm1hdCA9IF9nbC5SRzE2Rjtcblx0XHRcdGlmIChnbFR5cGUgPT09IF9nbC5VTlNJR05FRF9CWVRFKSBpbnRlcm5hbEZvcm1hdCA9IF9nbC5SRzg7XG5cdFx0fVxuXHRcdGlmIChnbEZvcm1hdCA9PT0gX2dsLlJHQkEpIHtcblx0XHRcdGlmIChnbFR5cGUgPT09IF9nbC5GTE9BVCkgaW50ZXJuYWxGb3JtYXQgPSBfZ2wuUkdCQTMyRjtcblx0XHRcdGlmIChnbFR5cGUgPT09IF9nbC5IQUxGX0ZMT0FUKSBpbnRlcm5hbEZvcm1hdCA9IF9nbC5SR0JBMTZGO1xuXHRcdFx0aWYgKGdsVHlwZSA9PT0gX2dsLlVOU0lHTkVEX0JZVEUpIGludGVybmFsRm9ybWF0ID0gZW5jb2RpbmcgPT09IHNSR0JFbmNvZGluZyAmJiBmb3JjZUxpbmVhckVuY29kaW5nID09PSBmYWxzZSA/IF9nbC5TUkdCOF9BTFBIQTggOiBfZ2wuUkdCQTg7XG5cdFx0XHRpZiAoZ2xUeXBlID09PSBfZ2wuVU5TSUdORURfU0hPUlRfNF80XzRfNCkgaW50ZXJuYWxGb3JtYXQgPSBfZ2wuUkdCQTQ7XG5cdFx0XHRpZiAoZ2xUeXBlID09PSBfZ2wuVU5TSUdORURfU0hPUlRfNV81XzVfMSkgaW50ZXJuYWxGb3JtYXQgPSBfZ2wuUkdCNV9BMTtcblx0XHR9XG5cdFx0aWYgKGludGVybmFsRm9ybWF0ID09PSBfZ2wuUjE2RiB8fCBpbnRlcm5hbEZvcm1hdCA9PT0gX2dsLlIzMkYgfHwgaW50ZXJuYWxGb3JtYXQgPT09IF9nbC5SRzE2RiB8fCBpbnRlcm5hbEZvcm1hdCA9PT0gX2dsLlJHMzJGIHx8IGludGVybmFsRm9ybWF0ID09PSBfZ2wuUkdCQTE2RiB8fCBpbnRlcm5hbEZvcm1hdCA9PT0gX2dsLlJHQkEzMkYpIHtcblx0XHRcdGV4dGVuc2lvbnMuZ2V0KCdFWFRfY29sb3JfYnVmZmVyX2Zsb2F0Jyk7XG5cdFx0fVxuXHRcdHJldHVybiBpbnRlcm5hbEZvcm1hdDtcblx0fVxuXHRmdW5jdGlvbiBnZXRNaXBMZXZlbHModGV4dHVyZSwgaW1hZ2UsIHN1cHBvcnRzTWlwcykge1xuXHRcdGlmICh0ZXh0dXJlTmVlZHNHZW5lcmF0ZU1pcG1hcHModGV4dHVyZSwgc3VwcG9ydHNNaXBzKSA9PT0gdHJ1ZSB8fCB0ZXh0dXJlLmlzRnJhbWVidWZmZXJUZXh0dXJlICYmIHRleHR1cmUubWluRmlsdGVyICE9PSBOZWFyZXN0RmlsdGVyICYmIHRleHR1cmUubWluRmlsdGVyICE9PSBMaW5lYXJGaWx0ZXIpIHtcblx0XHRcdHJldHVybiBNYXRoLmxvZzIoTWF0aC5tYXgoaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCkpICsgMTtcblx0XHR9IGVsc2UgaWYgKHRleHR1cmUubWlwbWFwcyAhPT0gdW5kZWZpbmVkICYmIHRleHR1cmUubWlwbWFwcy5sZW5ndGggPiAwKSB7XG5cdFx0XHQvLyB1c2VyLWRlZmluZWQgbWlwbWFwc1xuXG5cdFx0XHRyZXR1cm4gdGV4dHVyZS5taXBtYXBzLmxlbmd0aDtcblx0XHR9IGVsc2UgaWYgKHRleHR1cmUuaXNDb21wcmVzc2VkVGV4dHVyZSAmJiBBcnJheS5pc0FycmF5KHRleHR1cmUuaW1hZ2UpKSB7XG5cdFx0XHRyZXR1cm4gaW1hZ2UubWlwbWFwcy5sZW5ndGg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHRleHR1cmUgd2l0aG91dCBtaXBtYXBzIChvbmx5IGJhc2UgbGV2ZWwpXG5cblx0XHRcdHJldHVybiAxO1xuXHRcdH1cblx0fVxuXG5cdC8vIEZhbGxiYWNrIGZpbHRlcnMgZm9yIG5vbi1wb3dlci1vZi0yIHRleHR1cmVzXG5cblx0ZnVuY3Rpb24gZmlsdGVyRmFsbGJhY2soZikge1xuXHRcdGlmIChmID09PSBOZWFyZXN0RmlsdGVyIHx8IGYgPT09IE5lYXJlc3RNaXBtYXBOZWFyZXN0RmlsdGVyIHx8IGYgPT09IE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIpIHtcblx0XHRcdHJldHVybiBfZ2wuTkVBUkVTVDtcblx0XHR9XG5cdFx0cmV0dXJuIF9nbC5MSU5FQVI7XG5cdH1cblxuXHQvL1xuXG5cdGZ1bmN0aW9uIG9uVGV4dHVyZURpc3Bvc2UoZXZlbnQpIHtcblx0XHRjb25zdCB0ZXh0dXJlID0gZXZlbnQudGFyZ2V0O1xuXHRcdHRleHR1cmUucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIG9uVGV4dHVyZURpc3Bvc2UpO1xuXHRcdGRlYWxsb2NhdGVUZXh0dXJlKHRleHR1cmUpO1xuXHRcdGlmICh0ZXh0dXJlLmlzVmlkZW9UZXh0dXJlKSB7XG5cdFx0XHRfdmlkZW9UZXh0dXJlcy5kZWxldGUodGV4dHVyZSk7XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIG9uUmVuZGVyVGFyZ2V0RGlzcG9zZShldmVudCkge1xuXHRcdGNvbnN0IHJlbmRlclRhcmdldCA9IGV2ZW50LnRhcmdldDtcblx0XHRyZW5kZXJUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIG9uUmVuZGVyVGFyZ2V0RGlzcG9zZSk7XG5cdFx0ZGVhbGxvY2F0ZVJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQpO1xuXHR9XG5cblx0Ly9cblxuXHRmdW5jdGlvbiBkZWFsbG9jYXRlVGV4dHVyZSh0ZXh0dXJlKSB7XG5cdFx0Y29uc3QgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCh0ZXh0dXJlKTtcblx0XHRpZiAodGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbEluaXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG5cdFx0Ly8gY2hlY2sgaWYgaXQncyBuZWNlc3NhcnkgdG8gcmVtb3ZlIHRoZSBXZWJHTFRleHR1cmUgb2JqZWN0XG5cblx0XHRjb25zdCBzb3VyY2UgPSB0ZXh0dXJlLnNvdXJjZTtcblx0XHRjb25zdCB3ZWJnbFRleHR1cmVzID0gX3NvdXJjZXMuZ2V0KHNvdXJjZSk7XG5cdFx0aWYgKHdlYmdsVGV4dHVyZXMpIHtcblx0XHRcdGNvbnN0IHdlYmdsVGV4dHVyZSA9IHdlYmdsVGV4dHVyZXNbdGV4dHVyZVByb3BlcnRpZXMuX19jYWNoZUtleV07XG5cdFx0XHR3ZWJnbFRleHR1cmUudXNlZFRpbWVzLS07XG5cblx0XHRcdC8vIHRoZSBXZWJHTFRleHR1cmUgb2JqZWN0IGlzIG5vdCB1c2VkIGFueW1vcmUsIHJlbW92ZSBpdFxuXG5cdFx0XHRpZiAod2ViZ2xUZXh0dXJlLnVzZWRUaW1lcyA9PT0gMCkge1xuXHRcdFx0XHRkZWxldGVUZXh0dXJlKHRleHR1cmUpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyByZW1vdmUgdGhlIHdlYWsgbWFwIGVudHJ5IGlmIG5vIFdlYkdMVGV4dHVyZSB1c2VzIHRoZSBzb3VyY2UgYW55bW9yZVxuXG5cdFx0XHRpZiAoT2JqZWN0LmtleXMod2ViZ2xUZXh0dXJlcykubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdF9zb3VyY2VzLmRlbGV0ZShzb3VyY2UpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRwcm9wZXJ0aWVzLnJlbW92ZSh0ZXh0dXJlKTtcblx0fVxuXHRmdW5jdGlvbiBkZWxldGVUZXh0dXJlKHRleHR1cmUpIHtcblx0XHRjb25zdCB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KHRleHR1cmUpO1xuXHRcdF9nbC5kZWxldGVUZXh0dXJlKHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlKTtcblx0XHRjb25zdCBzb3VyY2UgPSB0ZXh0dXJlLnNvdXJjZTtcblx0XHRjb25zdCB3ZWJnbFRleHR1cmVzID0gX3NvdXJjZXMuZ2V0KHNvdXJjZSk7XG5cdFx0ZGVsZXRlIHdlYmdsVGV4dHVyZXNbdGV4dHVyZVByb3BlcnRpZXMuX19jYWNoZUtleV07XG5cdFx0aW5mby5tZW1vcnkudGV4dHVyZXMtLTtcblx0fVxuXHRmdW5jdGlvbiBkZWFsbG9jYXRlUmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCkge1xuXHRcdGNvbnN0IHRleHR1cmUgPSByZW5kZXJUYXJnZXQudGV4dHVyZTtcblx0XHRjb25zdCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQocmVuZGVyVGFyZ2V0KTtcblx0XHRjb25zdCB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KHRleHR1cmUpO1xuXHRcdGlmICh0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRfZ2wuZGVsZXRlVGV4dHVyZSh0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSk7XG5cdFx0XHRpbmZvLm1lbW9yeS50ZXh0dXJlcy0tO1xuXHRcdH1cblx0XHRpZiAocmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZSkge1xuXHRcdFx0cmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5kaXNwb3NlKCk7XG5cdFx0fVxuXHRcdGlmIChyZW5kZXJUYXJnZXQuaXNXZWJHTEN1YmVSZW5kZXJUYXJnZXQpIHtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG5cdFx0XHRcdF9nbC5kZWxldGVGcmFtZWJ1ZmZlcihyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlcltpXSk7XG5cdFx0XHRcdGlmIChyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlcikgX2dsLmRlbGV0ZVJlbmRlcmJ1ZmZlcihyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlcltpXSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdF9nbC5kZWxldGVGcmFtZWJ1ZmZlcihyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlcik7XG5cdFx0XHRpZiAocmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXIpIF9nbC5kZWxldGVSZW5kZXJidWZmZXIocmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXIpO1xuXHRcdFx0aWYgKHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbE11bHRpc2FtcGxlZEZyYW1lYnVmZmVyKSBfZ2wuZGVsZXRlRnJhbWVidWZmZXIocmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsTXVsdGlzYW1wbGVkRnJhbWVidWZmZXIpO1xuXHRcdFx0aWYgKHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbENvbG9yUmVuZGVyYnVmZmVyKSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsQ29sb3JSZW5kZXJidWZmZXIubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZiAocmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsQ29sb3JSZW5kZXJidWZmZXJbaV0pIF9nbC5kZWxldGVSZW5kZXJidWZmZXIocmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsQ29sb3JSZW5kZXJidWZmZXJbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAocmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhSZW5kZXJidWZmZXIpIF9nbC5kZWxldGVSZW5kZXJidWZmZXIocmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhSZW5kZXJidWZmZXIpO1xuXHRcdH1cblx0XHRpZiAocmVuZGVyVGFyZ2V0LmlzV2ViR0xNdWx0aXBsZVJlbmRlclRhcmdldHMpIHtcblx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IHRleHR1cmUubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHRjb25zdCBhdHRhY2htZW50UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KHRleHR1cmVbaV0pO1xuXHRcdFx0XHRpZiAoYXR0YWNobWVudFByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUpIHtcblx0XHRcdFx0XHRfZ2wuZGVsZXRlVGV4dHVyZShhdHRhY2htZW50UHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSk7XG5cdFx0XHRcdFx0aW5mby5tZW1vcnkudGV4dHVyZXMtLTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwcm9wZXJ0aWVzLnJlbW92ZSh0ZXh0dXJlW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cHJvcGVydGllcy5yZW1vdmUodGV4dHVyZSk7XG5cdFx0cHJvcGVydGllcy5yZW1vdmUocmVuZGVyVGFyZ2V0KTtcblx0fVxuXG5cdC8vXG5cblx0bGV0IHRleHR1cmVVbml0cyA9IDA7XG5cdGZ1bmN0aW9uIHJlc2V0VGV4dHVyZVVuaXRzKCkge1xuXHRcdHRleHR1cmVVbml0cyA9IDA7XG5cdH1cblx0ZnVuY3Rpb24gYWxsb2NhdGVUZXh0dXJlVW5pdCgpIHtcblx0XHRjb25zdCB0ZXh0dXJlVW5pdCA9IHRleHR1cmVVbml0cztcblx0XHRpZiAodGV4dHVyZVVuaXQgPj0gbWF4VGV4dHVyZXMpIHtcblx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xUZXh0dXJlczogVHJ5aW5nIHRvIHVzZSAnICsgdGV4dHVyZVVuaXQgKyAnIHRleHR1cmUgdW5pdHMgd2hpbGUgdGhpcyBHUFUgc3VwcG9ydHMgb25seSAnICsgbWF4VGV4dHVyZXMpO1xuXHRcdH1cblx0XHR0ZXh0dXJlVW5pdHMgKz0gMTtcblx0XHRyZXR1cm4gdGV4dHVyZVVuaXQ7XG5cdH1cblx0ZnVuY3Rpb24gZ2V0VGV4dHVyZUNhY2hlS2V5KHRleHR1cmUpIHtcblx0XHRjb25zdCBhcnJheSA9IFtdO1xuXHRcdGFycmF5LnB1c2godGV4dHVyZS53cmFwUyk7XG5cdFx0YXJyYXkucHVzaCh0ZXh0dXJlLndyYXBUKTtcblx0XHRhcnJheS5wdXNoKHRleHR1cmUud3JhcFIgfHwgMCk7XG5cdFx0YXJyYXkucHVzaCh0ZXh0dXJlLm1hZ0ZpbHRlcik7XG5cdFx0YXJyYXkucHVzaCh0ZXh0dXJlLm1pbkZpbHRlcik7XG5cdFx0YXJyYXkucHVzaCh0ZXh0dXJlLmFuaXNvdHJvcHkpO1xuXHRcdGFycmF5LnB1c2godGV4dHVyZS5pbnRlcm5hbEZvcm1hdCk7XG5cdFx0YXJyYXkucHVzaCh0ZXh0dXJlLmZvcm1hdCk7XG5cdFx0YXJyYXkucHVzaCh0ZXh0dXJlLnR5cGUpO1xuXHRcdGFycmF5LnB1c2godGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMpO1xuXHRcdGFycmF5LnB1c2godGV4dHVyZS5wcmVtdWx0aXBseUFscGhhKTtcblx0XHRhcnJheS5wdXNoKHRleHR1cmUuZmxpcFkpO1xuXHRcdGFycmF5LnB1c2godGV4dHVyZS51bnBhY2tBbGlnbm1lbnQpO1xuXHRcdGFycmF5LnB1c2godGV4dHVyZS5lbmNvZGluZyk7XG5cdFx0cmV0dXJuIGFycmF5LmpvaW4oKTtcblx0fVxuXG5cdC8vXG5cblx0ZnVuY3Rpb24gc2V0VGV4dHVyZTJEKHRleHR1cmUsIHNsb3QpIHtcblx0XHRjb25zdCB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KHRleHR1cmUpO1xuXHRcdGlmICh0ZXh0dXJlLmlzVmlkZW9UZXh0dXJlKSB1cGRhdGVWaWRlb1RleHR1cmUodGV4dHVyZSk7XG5cdFx0aWYgKHRleHR1cmUuaXNSZW5kZXJUYXJnZXRUZXh0dXJlID09PSBmYWxzZSAmJiB0ZXh0dXJlLnZlcnNpb24gPiAwICYmIHRleHR1cmVQcm9wZXJ0aWVzLl9fdmVyc2lvbiAhPT0gdGV4dHVyZS52ZXJzaW9uKSB7XG5cdFx0XHRjb25zdCBpbWFnZSA9IHRleHR1cmUuaW1hZ2U7XG5cdFx0XHRpZiAoaW1hZ2UgPT09IG51bGwpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIG1hcmtlZCBmb3IgdXBkYXRlIGJ1dCBubyBpbWFnZSBkYXRhIGZvdW5kLicpO1xuXHRcdFx0fSBlbHNlIGlmIChpbWFnZS5jb21wbGV0ZSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIG1hcmtlZCBmb3IgdXBkYXRlIGJ1dCBpbWFnZSBpcyBpbmNvbXBsZXRlJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR1cGxvYWRUZXh0dXJlKHRleHR1cmVQcm9wZXJ0aWVzLCB0ZXh0dXJlLCBzbG90KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRzdGF0ZS5iaW5kVGV4dHVyZShfZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUsIF9nbC5URVhUVVJFMCArIHNsb3QpO1xuXHR9XG5cdGZ1bmN0aW9uIHNldFRleHR1cmUyREFycmF5KHRleHR1cmUsIHNsb3QpIHtcblx0XHRjb25zdCB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KHRleHR1cmUpO1xuXHRcdGlmICh0ZXh0dXJlLnZlcnNpb24gPiAwICYmIHRleHR1cmVQcm9wZXJ0aWVzLl9fdmVyc2lvbiAhPT0gdGV4dHVyZS52ZXJzaW9uKSB7XG5cdFx0XHR1cGxvYWRUZXh0dXJlKHRleHR1cmVQcm9wZXJ0aWVzLCB0ZXh0dXJlLCBzbG90KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0c3RhdGUuYmluZFRleHR1cmUoX2dsLlRFWFRVUkVfMkRfQVJSQVksIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlLCBfZ2wuVEVYVFVSRTAgKyBzbG90KTtcblx0fVxuXHRmdW5jdGlvbiBzZXRUZXh0dXJlM0QodGV4dHVyZSwgc2xvdCkge1xuXHRcdGNvbnN0IHRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQodGV4dHVyZSk7XG5cdFx0aWYgKHRleHR1cmUudmVyc2lvbiA+IDAgJiYgdGV4dHVyZVByb3BlcnRpZXMuX192ZXJzaW9uICE9PSB0ZXh0dXJlLnZlcnNpb24pIHtcblx0XHRcdHVwbG9hZFRleHR1cmUodGV4dHVyZVByb3BlcnRpZXMsIHRleHR1cmUsIHNsb3QpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRzdGF0ZS5iaW5kVGV4dHVyZShfZ2wuVEVYVFVSRV8zRCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUsIF9nbC5URVhUVVJFMCArIHNsb3QpO1xuXHR9XG5cdGZ1bmN0aW9uIHNldFRleHR1cmVDdWJlKHRleHR1cmUsIHNsb3QpIHtcblx0XHRjb25zdCB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KHRleHR1cmUpO1xuXHRcdGlmICh0ZXh0dXJlLnZlcnNpb24gPiAwICYmIHRleHR1cmVQcm9wZXJ0aWVzLl9fdmVyc2lvbiAhPT0gdGV4dHVyZS52ZXJzaW9uKSB7XG5cdFx0XHR1cGxvYWRDdWJlVGV4dHVyZSh0ZXh0dXJlUHJvcGVydGllcywgdGV4dHVyZSwgc2xvdCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHN0YXRlLmJpbmRUZXh0dXJlKF9nbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSwgX2dsLlRFWFRVUkUwICsgc2xvdCk7XG5cdH1cblx0Y29uc3Qgd3JhcHBpbmdUb0dMID0ge1xuXHRcdFtSZXBlYXRXcmFwcGluZ106IF9nbC5SRVBFQVQsXG5cdFx0W0NsYW1wVG9FZGdlV3JhcHBpbmddOiBfZ2wuQ0xBTVBfVE9fRURHRSxcblx0XHRbTWlycm9yZWRSZXBlYXRXcmFwcGluZ106IF9nbC5NSVJST1JFRF9SRVBFQVRcblx0fTtcblx0Y29uc3QgZmlsdGVyVG9HTCA9IHtcblx0XHRbTmVhcmVzdEZpbHRlcl06IF9nbC5ORUFSRVNULFxuXHRcdFtOZWFyZXN0TWlwbWFwTmVhcmVzdEZpbHRlcl06IF9nbC5ORUFSRVNUX01JUE1BUF9ORUFSRVNULFxuXHRcdFtOZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyXTogX2dsLk5FQVJFU1RfTUlQTUFQX0xJTkVBUixcblx0XHRbTGluZWFyRmlsdGVyXTogX2dsLkxJTkVBUixcblx0XHRbTGluZWFyTWlwbWFwTmVhcmVzdEZpbHRlcl06IF9nbC5MSU5FQVJfTUlQTUFQX05FQVJFU1QsXG5cdFx0W0xpbmVhck1pcG1hcExpbmVhckZpbHRlcl06IF9nbC5MSU5FQVJfTUlQTUFQX0xJTkVBUlxuXHR9O1xuXHRmdW5jdGlvbiBzZXRUZXh0dXJlUGFyYW1ldGVycyh0ZXh0dXJlVHlwZSwgdGV4dHVyZSwgc3VwcG9ydHNNaXBzKSB7XG5cdFx0aWYgKHN1cHBvcnRzTWlwcykge1xuXHRcdFx0X2dsLnRleFBhcmFtZXRlcmkodGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfUywgd3JhcHBpbmdUb0dMW3RleHR1cmUud3JhcFNdKTtcblx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1QsIHdyYXBwaW5nVG9HTFt0ZXh0dXJlLndyYXBUXSk7XG5cdFx0XHRpZiAodGV4dHVyZVR5cGUgPT09IF9nbC5URVhUVVJFXzNEIHx8IHRleHR1cmVUeXBlID09PSBfZ2wuVEVYVFVSRV8yRF9BUlJBWSkge1xuXHRcdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSh0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfV1JBUF9SLCB3cmFwcGluZ1RvR0xbdGV4dHVyZS53cmFwUl0pO1xuXHRcdFx0fVxuXHRcdFx0X2dsLnRleFBhcmFtZXRlcmkodGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01BR19GSUxURVIsIGZpbHRlclRvR0xbdGV4dHVyZS5tYWdGaWx0ZXJdKTtcblx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBmaWx0ZXJUb0dMW3RleHR1cmUubWluRmlsdGVyXSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1MsIF9nbC5DTEFNUF9UT19FREdFKTtcblx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1QsIF9nbC5DTEFNUF9UT19FREdFKTtcblx0XHRcdGlmICh0ZXh0dXJlVHlwZSA9PT0gX2dsLlRFWFRVUkVfM0QgfHwgdGV4dHVyZVR5cGUgPT09IF9nbC5URVhUVVJFXzJEX0FSUkFZKSB7XG5cdFx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1IsIF9nbC5DTEFNUF9UT19FREdFKTtcblx0XHRcdH1cblx0XHRcdGlmICh0ZXh0dXJlLndyYXBTICE9PSBDbGFtcFRvRWRnZVdyYXBwaW5nIHx8IHRleHR1cmUud3JhcFQgIT09IENsYW1wVG9FZGdlV3JhcHBpbmcpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIGlzIG5vdCBwb3dlciBvZiB0d28uIFRleHR1cmUud3JhcFMgYW5kIFRleHR1cmUud3JhcFQgc2hvdWxkIGJlIHNldCB0byBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nLicpO1xuXHRcdFx0fVxuXHRcdFx0X2dsLnRleFBhcmFtZXRlcmkodGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01BR19GSUxURVIsIGZpbHRlckZhbGxiYWNrKHRleHR1cmUubWFnRmlsdGVyKSk7XG5cdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSh0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZmlsdGVyRmFsbGJhY2sodGV4dHVyZS5taW5GaWx0ZXIpKTtcblx0XHRcdGlmICh0ZXh0dXJlLm1pbkZpbHRlciAhPT0gTmVhcmVzdEZpbHRlciAmJiB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gTGluZWFyRmlsdGVyKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBpcyBub3QgcG93ZXIgb2YgdHdvLiBUZXh0dXJlLm1pbkZpbHRlciBzaG91bGQgYmUgc2V0IHRvIFRIUkVFLk5lYXJlc3RGaWx0ZXIgb3IgVEhSRUUuTGluZWFyRmlsdGVyLicpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoZXh0ZW5zaW9ucy5oYXMoJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycpID09PSB0cnVlKSB7XG5cdFx0XHRjb25zdCBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCgnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyk7XG5cdFx0XHRpZiAodGV4dHVyZS50eXBlID09PSBGbG9hdFR5cGUgJiYgZXh0ZW5zaW9ucy5oYXMoJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicpID09PSBmYWxzZSkgcmV0dXJuOyAvLyB2ZXJpZnkgZXh0ZW5zaW9uIGZvciBXZWJHTCAxIGFuZCBXZWJHTCAyXG5cdFx0XHRpZiAoaXNXZWJHTDIgPT09IGZhbHNlICYmIHRleHR1cmUudHlwZSA9PT0gSGFsZkZsb2F0VHlwZSAmJiBleHRlbnNpb25zLmhhcygnT0VTX3RleHR1cmVfaGFsZl9mbG9hdF9saW5lYXInKSA9PT0gZmFsc2UpIHJldHVybjsgLy8gdmVyaWZ5IGV4dGVuc2lvbiBmb3IgV2ViR0wgMSBvbmx5XG5cblx0XHRcdGlmICh0ZXh0dXJlLmFuaXNvdHJvcHkgPiAxIHx8IHByb3BlcnRpZXMuZ2V0KHRleHR1cmUpLl9fY3VycmVudEFuaXNvdHJvcHkpIHtcblx0XHRcdFx0X2dsLnRleFBhcmFtZXRlcmYodGV4dHVyZVR5cGUsIGV4dGVuc2lvbi5URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCwgTWF0aC5taW4odGV4dHVyZS5hbmlzb3Ryb3B5LCBjYXBhYmlsaXRpZXMuZ2V0TWF4QW5pc290cm9weSgpKSk7XG5cdFx0XHRcdHByb3BlcnRpZXMuZ2V0KHRleHR1cmUpLl9fY3VycmVudEFuaXNvdHJvcHkgPSB0ZXh0dXJlLmFuaXNvdHJvcHk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIGluaXRUZXh0dXJlKHRleHR1cmVQcm9wZXJ0aWVzLCB0ZXh0dXJlKSB7XG5cdFx0bGV0IGZvcmNlVXBsb2FkID0gZmFsc2U7XG5cdFx0aWYgKHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xJbml0ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xJbml0ID0gdHJ1ZTtcblx0XHRcdHRleHR1cmUuYWRkRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIG9uVGV4dHVyZURpc3Bvc2UpO1xuXHRcdH1cblxuXHRcdC8vIGNyZWF0ZSBTb3VyY2UgPC0+IFdlYkdMVGV4dHVyZXMgbWFwcGluZyBpZiBuZWNlc3NhcnlcblxuXHRcdGNvbnN0IHNvdXJjZSA9IHRleHR1cmUuc291cmNlO1xuXHRcdGxldCB3ZWJnbFRleHR1cmVzID0gX3NvdXJjZXMuZ2V0KHNvdXJjZSk7XG5cdFx0aWYgKHdlYmdsVGV4dHVyZXMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0d2ViZ2xUZXh0dXJlcyA9IHt9O1xuXHRcdFx0X3NvdXJjZXMuc2V0KHNvdXJjZSwgd2ViZ2xUZXh0dXJlcyk7XG5cdFx0fVxuXG5cdFx0Ly8gY2hlY2sgaWYgdGhlcmUgaXMgYWxyZWFkeSBhIFdlYkdMVGV4dHVyZSBvYmplY3QgZm9yIHRoZSBnaXZlbiB0ZXh0dXJlIHBhcmFtZXRlcnNcblxuXHRcdGNvbnN0IHRleHR1cmVDYWNoZUtleSA9IGdldFRleHR1cmVDYWNoZUtleSh0ZXh0dXJlKTtcblx0XHRpZiAodGV4dHVyZUNhY2hlS2V5ICE9PSB0ZXh0dXJlUHJvcGVydGllcy5fX2NhY2hlS2V5KSB7XG5cdFx0XHQvLyBpZiBub3QsIGNyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBXZWJHTFRleHR1cmVcblxuXHRcdFx0aWYgKHdlYmdsVGV4dHVyZXNbdGV4dHVyZUNhY2hlS2V5XSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdC8vIGNyZWF0ZSBuZXcgZW50cnlcblxuXHRcdFx0XHR3ZWJnbFRleHR1cmVzW3RleHR1cmVDYWNoZUtleV0gPSB7XG5cdFx0XHRcdFx0dGV4dHVyZTogX2dsLmNyZWF0ZVRleHR1cmUoKSxcblx0XHRcdFx0XHR1c2VkVGltZXM6IDBcblx0XHRcdFx0fTtcblx0XHRcdFx0aW5mby5tZW1vcnkudGV4dHVyZXMrKztcblxuXHRcdFx0XHQvLyB3aGVuIGEgbmV3IGluc3RhbmNlIG9mIFdlYkdMVGV4dHVyZSB3YXMgY3JlYXRlZCwgYSB0ZXh0dXJlIHVwbG9hZCBpcyByZXF1aXJlZFxuXHRcdFx0XHQvLyBldmVuIGlmIHRoZSBpbWFnZSBjb250ZW50cyBhcmUgaWRlbnRpY2FsXG5cblx0XHRcdFx0Zm9yY2VVcGxvYWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0d2ViZ2xUZXh0dXJlc1t0ZXh0dXJlQ2FjaGVLZXldLnVzZWRUaW1lcysrO1xuXG5cdFx0XHQvLyBldmVyeSB0aW1lIHRoZSB0ZXh0dXJlIGNhY2hlIGtleSBjaGFuZ2VzLCBpdCdzIG5lY2Vzc2FyeSB0byBjaGVjayBpZiBhbiBpbnN0YW5jZSBvZlxuXHRcdFx0Ly8gV2ViR0xUZXh0dXJlIGNhbiBiZSBkZWxldGVkIGluIG9yZGVyIHRvIGF2b2lkIGEgbWVtb3J5IGxlYWsuXG5cblx0XHRcdGNvbnN0IHdlYmdsVGV4dHVyZSA9IHdlYmdsVGV4dHVyZXNbdGV4dHVyZVByb3BlcnRpZXMuX19jYWNoZUtleV07XG5cdFx0XHRpZiAod2ViZ2xUZXh0dXJlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0d2ViZ2xUZXh0dXJlc1t0ZXh0dXJlUHJvcGVydGllcy5fX2NhY2hlS2V5XS51c2VkVGltZXMtLTtcblx0XHRcdFx0aWYgKHdlYmdsVGV4dHVyZS51c2VkVGltZXMgPT09IDApIHtcblx0XHRcdFx0XHRkZWxldGVUZXh0dXJlKHRleHR1cmUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIHN0b3JlIHJlZmVyZW5jZXMgdG8gY2FjaGUga2V5IGFuZCBXZWJHTFRleHR1cmUgb2JqZWN0XG5cblx0XHRcdHRleHR1cmVQcm9wZXJ0aWVzLl9fY2FjaGVLZXkgPSB0ZXh0dXJlQ2FjaGVLZXk7XG5cdFx0XHR0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSA9IHdlYmdsVGV4dHVyZXNbdGV4dHVyZUNhY2hlS2V5XS50ZXh0dXJlO1xuXHRcdH1cblx0XHRyZXR1cm4gZm9yY2VVcGxvYWQ7XG5cdH1cblx0ZnVuY3Rpb24gdXBsb2FkVGV4dHVyZSh0ZXh0dXJlUHJvcGVydGllcywgdGV4dHVyZSwgc2xvdCkge1xuXHRcdGxldCB0ZXh0dXJlVHlwZSA9IF9nbC5URVhUVVJFXzJEO1xuXHRcdGlmICh0ZXh0dXJlLmlzRGF0YUFycmF5VGV4dHVyZSB8fCB0ZXh0dXJlLmlzQ29tcHJlc3NlZEFycmF5VGV4dHVyZSkgdGV4dHVyZVR5cGUgPSBfZ2wuVEVYVFVSRV8yRF9BUlJBWTtcblx0XHRpZiAodGV4dHVyZS5pc0RhdGEzRFRleHR1cmUpIHRleHR1cmVUeXBlID0gX2dsLlRFWFRVUkVfM0Q7XG5cdFx0Y29uc3QgZm9yY2VVcGxvYWQgPSBpbml0VGV4dHVyZSh0ZXh0dXJlUHJvcGVydGllcywgdGV4dHVyZSk7XG5cdFx0Y29uc3Qgc291cmNlID0gdGV4dHVyZS5zb3VyY2U7XG5cdFx0c3RhdGUuYmluZFRleHR1cmUodGV4dHVyZVR5cGUsIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlLCBfZ2wuVEVYVFVSRTAgKyBzbG90KTtcblx0XHRjb25zdCBzb3VyY2VQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoc291cmNlKTtcblx0XHRpZiAoc291cmNlLnZlcnNpb24gIT09IHNvdXJjZVByb3BlcnRpZXMuX192ZXJzaW9uIHx8IGZvcmNlVXBsb2FkID09PSB0cnVlKSB7XG5cdFx0XHRzdGF0ZS5hY3RpdmVUZXh0dXJlKF9nbC5URVhUVVJFMCArIHNsb3QpO1xuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKF9nbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0ZXh0dXJlLmZsaXBZKTtcblx0XHRcdF9nbC5waXhlbFN0b3JlaShfZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0ZXh0dXJlLnByZW11bHRpcGx5QWxwaGEpO1xuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKF9nbC5VTlBBQ0tfQUxJR05NRU5ULCB0ZXh0dXJlLnVucGFja0FsaWdubWVudCk7XG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoX2dsLlVOUEFDS19DT0xPUlNQQUNFX0NPTlZFUlNJT05fV0VCR0wsIF9nbC5OT05FKTtcblx0XHRcdGNvbnN0IG5lZWRzUG93ZXJPZlR3byA9IHRleHR1cmVOZWVkc1Bvd2VyT2ZUd28odGV4dHVyZSkgJiYgaXNQb3dlck9mVHdvJDEodGV4dHVyZS5pbWFnZSkgPT09IGZhbHNlO1xuXHRcdFx0bGV0IGltYWdlID0gcmVzaXplSW1hZ2UodGV4dHVyZS5pbWFnZSwgbmVlZHNQb3dlck9mVHdvLCBmYWxzZSwgbWF4VGV4dHVyZVNpemUpO1xuXHRcdFx0aW1hZ2UgPSB2ZXJpZnlDb2xvclNwYWNlKHRleHR1cmUsIGltYWdlKTtcblx0XHRcdGNvbnN0IHN1cHBvcnRzTWlwcyA9IGlzUG93ZXJPZlR3byQxKGltYWdlKSB8fCBpc1dlYkdMMixcblx0XHRcdFx0Z2xGb3JtYXQgPSB1dGlscy5jb252ZXJ0KHRleHR1cmUuZm9ybWF0LCB0ZXh0dXJlLmVuY29kaW5nKTtcblx0XHRcdGxldCBnbFR5cGUgPSB1dGlscy5jb252ZXJ0KHRleHR1cmUudHlwZSksXG5cdFx0XHRcdGdsSW50ZXJuYWxGb3JtYXQgPSBnZXRJbnRlcm5hbEZvcm1hdCh0ZXh0dXJlLmludGVybmFsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCB0ZXh0dXJlLmVuY29kaW5nLCB0ZXh0dXJlLmlzVmlkZW9UZXh0dXJlKTtcblx0XHRcdHNldFRleHR1cmVQYXJhbWV0ZXJzKHRleHR1cmVUeXBlLCB0ZXh0dXJlLCBzdXBwb3J0c01pcHMpO1xuXHRcdFx0bGV0IG1pcG1hcDtcblx0XHRcdGNvbnN0IG1pcG1hcHMgPSB0ZXh0dXJlLm1pcG1hcHM7XG5cdFx0XHRjb25zdCB1c2VUZXhTdG9yYWdlID0gaXNXZWJHTDIgJiYgdGV4dHVyZS5pc1ZpZGVvVGV4dHVyZSAhPT0gdHJ1ZTtcblx0XHRcdGNvbnN0IGFsbG9jYXRlTWVtb3J5ID0gc291cmNlUHJvcGVydGllcy5fX3ZlcnNpb24gPT09IHVuZGVmaW5lZCB8fCBmb3JjZVVwbG9hZCA9PT0gdHJ1ZTtcblx0XHRcdGNvbnN0IGxldmVscyA9IGdldE1pcExldmVscyh0ZXh0dXJlLCBpbWFnZSwgc3VwcG9ydHNNaXBzKTtcblx0XHRcdGlmICh0ZXh0dXJlLmlzRGVwdGhUZXh0dXJlKSB7XG5cdFx0XHRcdC8vIHBvcHVsYXRlIGRlcHRoIHRleHR1cmUgd2l0aCBkdW1teSBkYXRhXG5cblx0XHRcdFx0Z2xJbnRlcm5hbEZvcm1hdCA9IF9nbC5ERVBUSF9DT01QT05FTlQ7XG5cdFx0XHRcdGlmIChpc1dlYkdMMikge1xuXHRcdFx0XHRcdGlmICh0ZXh0dXJlLnR5cGUgPT09IEZsb2F0VHlwZSkge1xuXHRcdFx0XHRcdFx0Z2xJbnRlcm5hbEZvcm1hdCA9IF9nbC5ERVBUSF9DT01QT05FTlQzMkY7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0ZXh0dXJlLnR5cGUgPT09IFVuc2lnbmVkSW50VHlwZSkge1xuXHRcdFx0XHRcdFx0Z2xJbnRlcm5hbEZvcm1hdCA9IF9nbC5ERVBUSF9DT01QT05FTlQyNDtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRleHR1cmUudHlwZSA9PT0gVW5zaWduZWRJbnQyNDhUeXBlKSB7XG5cdFx0XHRcdFx0XHRnbEludGVybmFsRm9ybWF0ID0gX2dsLkRFUFRIMjRfU1RFTkNJTDg7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGdsSW50ZXJuYWxGb3JtYXQgPSBfZ2wuREVQVEhfQ09NUE9ORU5UMTY7IC8vIFdlYkdMMiByZXF1aXJlcyBzaXplZCBpbnRlcm5hbGZvcm1hdCBmb3IgZ2xUZXhJbWFnZTJEXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICh0ZXh0dXJlLnR5cGUgPT09IEZsb2F0VHlwZSkge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvcignV2ViR0xSZW5kZXJlcjogRmxvYXRpbmcgcG9pbnQgZGVwdGggdGV4dHVyZSByZXF1aXJlcyBXZWJHTDIuJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gdmFsaWRhdGlvbiBjaGVja3MgZm9yIFdlYkdMIDFcblxuXHRcdFx0XHRpZiAodGV4dHVyZS5mb3JtYXQgPT09IERlcHRoRm9ybWF0ICYmIGdsSW50ZXJuYWxGb3JtYXQgPT09IF9nbC5ERVBUSF9DT01QT05FTlQpIHtcblx0XHRcdFx0XHQvLyBUaGUgZXJyb3IgSU5WQUxJRF9PUEVSQVRJT04gaXMgZ2VuZXJhdGVkIGJ5IHRleEltYWdlMkQgaWYgZm9ybWF0IGFuZCBpbnRlcm5hbGZvcm1hdCBhcmVcblx0XHRcdFx0XHQvLyBERVBUSF9DT01QT05FTlQgYW5kIHR5cGUgaXMgbm90IFVOU0lHTkVEX1NIT1JUIG9yIFVOU0lHTkVEX0lOVFxuXHRcdFx0XHRcdC8vIChodHRwczovL3d3dy5raHJvbm9zLm9yZy9yZWdpc3RyeS93ZWJnbC9leHRlbnNpb25zL1dFQkdMX2RlcHRoX3RleHR1cmUvKVxuXHRcdFx0XHRcdGlmICh0ZXh0dXJlLnR5cGUgIT09IFVuc2lnbmVkU2hvcnRUeXBlICYmIHRleHR1cmUudHlwZSAhPT0gVW5zaWduZWRJbnRUeXBlKSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFVzZSBVbnNpZ25lZFNob3J0VHlwZSBvciBVbnNpZ25lZEludFR5cGUgZm9yIERlcHRoRm9ybWF0IERlcHRoVGV4dHVyZS4nKTtcblx0XHRcdFx0XHRcdHRleHR1cmUudHlwZSA9IFVuc2lnbmVkSW50VHlwZTtcblx0XHRcdFx0XHRcdGdsVHlwZSA9IHV0aWxzLmNvbnZlcnQodGV4dHVyZS50eXBlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRleHR1cmUuZm9ybWF0ID09PSBEZXB0aFN0ZW5jaWxGb3JtYXQgJiYgZ2xJbnRlcm5hbEZvcm1hdCA9PT0gX2dsLkRFUFRIX0NPTVBPTkVOVCkge1xuXHRcdFx0XHRcdC8vIERlcHRoIHN0ZW5jaWwgdGV4dHVyZXMgbmVlZCB0aGUgREVQVEhfU1RFTkNJTCBpbnRlcm5hbCBmb3JtYXRcblx0XHRcdFx0XHQvLyAoaHR0cHM6Ly93d3cua2hyb25vcy5vcmcvcmVnaXN0cnkvd2ViZ2wvZXh0ZW5zaW9ucy9XRUJHTF9kZXB0aF90ZXh0dXJlLylcblx0XHRcdFx0XHRnbEludGVybmFsRm9ybWF0ID0gX2dsLkRFUFRIX1NURU5DSUw7XG5cblx0XHRcdFx0XHQvLyBUaGUgZXJyb3IgSU5WQUxJRF9PUEVSQVRJT04gaXMgZ2VuZXJhdGVkIGJ5IHRleEltYWdlMkQgaWYgZm9ybWF0IGFuZCBpbnRlcm5hbGZvcm1hdCBhcmVcblx0XHRcdFx0XHQvLyBERVBUSF9TVEVOQ0lMIGFuZCB0eXBlIGlzIG5vdCBVTlNJR05FRF9JTlRfMjRfOF9XRUJHTC5cblx0XHRcdFx0XHQvLyAoaHR0cHM6Ly93d3cua2hyb25vcy5vcmcvcmVnaXN0cnkvd2ViZ2wvZXh0ZW5zaW9ucy9XRUJHTF9kZXB0aF90ZXh0dXJlLylcblx0XHRcdFx0XHRpZiAodGV4dHVyZS50eXBlICE9PSBVbnNpZ25lZEludDI0OFR5cGUpIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogVXNlIFVuc2lnbmVkSW50MjQ4VHlwZSBmb3IgRGVwdGhTdGVuY2lsRm9ybWF0IERlcHRoVGV4dHVyZS4nKTtcblx0XHRcdFx0XHRcdHRleHR1cmUudHlwZSA9IFVuc2lnbmVkSW50MjQ4VHlwZTtcblx0XHRcdFx0XHRcdGdsVHlwZSA9IHV0aWxzLmNvbnZlcnQodGV4dHVyZS50eXBlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL1xuXG5cdFx0XHRcdGlmIChhbGxvY2F0ZU1lbW9yeSkge1xuXHRcdFx0XHRcdGlmICh1c2VUZXhTdG9yYWdlKSB7XG5cdFx0XHRcdFx0XHRzdGF0ZS50ZXhTdG9yYWdlMkQoX2dsLlRFWFRVUkVfMkQsIDEsIGdsSW50ZXJuYWxGb3JtYXQsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKF9nbC5URVhUVVJFXzJELCAwLCBnbEludGVybmFsRm9ybWF0LCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBudWxsKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAodGV4dHVyZS5pc0RhdGFUZXh0dXJlKSB7XG5cdFx0XHRcdC8vIHVzZSBtYW51YWxseSBjcmVhdGVkIG1pcG1hcHMgaWYgYXZhaWxhYmxlXG5cdFx0XHRcdC8vIGlmIHRoZXJlIGFyZSBubyBtYW51YWwgbWlwbWFwc1xuXHRcdFx0XHQvLyBzZXQgMCBsZXZlbCBtaXBtYXAgYW5kIHRoZW4gdXNlIEdMIHRvIGdlbmVyYXRlIG90aGVyIG1pcG1hcCBsZXZlbHNcblxuXHRcdFx0XHRpZiAobWlwbWFwcy5sZW5ndGggPiAwICYmIHN1cHBvcnRzTWlwcykge1xuXHRcdFx0XHRcdGlmICh1c2VUZXhTdG9yYWdlICYmIGFsbG9jYXRlTWVtb3J5KSB7XG5cdFx0XHRcdFx0XHRzdGF0ZS50ZXhTdG9yYWdlMkQoX2dsLlRFWFRVUkVfMkQsIGxldmVscywgZ2xJbnRlcm5hbEZvcm1hdCwgbWlwbWFwc1swXS53aWR0aCwgbWlwbWFwc1swXS5oZWlnaHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSBtaXBtYXBzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0XHRcdG1pcG1hcCA9IG1pcG1hcHNbaV07XG5cdFx0XHRcdFx0XHRpZiAodXNlVGV4U3RvcmFnZSkge1xuXHRcdFx0XHRcdFx0XHRzdGF0ZS50ZXhTdWJJbWFnZTJEKF9nbC5URVhUVVJFXzJELCBpLCAwLCAwLCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcC5kYXRhKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoX2dsLlRFWFRVUkVfMkQsIGksIGdsSW50ZXJuYWxGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmRhdGEpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICh1c2VUZXhTdG9yYWdlKSB7XG5cdFx0XHRcdFx0XHRpZiAoYWxsb2NhdGVNZW1vcnkpIHtcblx0XHRcdFx0XHRcdFx0c3RhdGUudGV4U3RvcmFnZTJEKF9nbC5URVhUVVJFXzJELCBsZXZlbHMsIGdsSW50ZXJuYWxGb3JtYXQsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0c3RhdGUudGV4U3ViSW1hZ2UyRChfZ2wuVEVYVFVSRV8yRCwgMCwgMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgZ2xGb3JtYXQsIGdsVHlwZSwgaW1hZ2UuZGF0YSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoX2dsLlRFWFRVUkVfMkQsIDAsIGdsSW50ZXJuYWxGb3JtYXQsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIGltYWdlLmRhdGEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh0ZXh0dXJlLmlzQ29tcHJlc3NlZFRleHR1cmUpIHtcblx0XHRcdFx0aWYgKHRleHR1cmUuaXNDb21wcmVzc2VkQXJyYXlUZXh0dXJlKSB7XG5cdFx0XHRcdFx0aWYgKHVzZVRleFN0b3JhZ2UgJiYgYWxsb2NhdGVNZW1vcnkpIHtcblx0XHRcdFx0XHRcdHN0YXRlLnRleFN0b3JhZ2UzRChfZ2wuVEVYVFVSRV8yRF9BUlJBWSwgbGV2ZWxzLCBnbEludGVybmFsRm9ybWF0LCBtaXBtYXBzWzBdLndpZHRoLCBtaXBtYXBzWzBdLmhlaWdodCwgaW1hZ2UuZGVwdGgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSBtaXBtYXBzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0XHRcdG1pcG1hcCA9IG1pcG1hcHNbaV07XG5cdFx0XHRcdFx0XHRpZiAodGV4dHVyZS5mb3JtYXQgIT09IFJHQkFGb3JtYXQpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGdsRm9ybWF0ICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHVzZVRleFN0b3JhZ2UpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHN0YXRlLmNvbXByZXNzZWRUZXhTdWJJbWFnZTNEKF9nbC5URVhUVVJFXzJEX0FSUkFZLCBpLCAwLCAwLCAwLCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIGltYWdlLmRlcHRoLCBnbEZvcm1hdCwgbWlwbWFwLmRhdGEsIDAsIDApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzdGF0ZS5jb21wcmVzc2VkVGV4SW1hZ2UzRChfZ2wuVEVYVFVSRV8yRF9BUlJBWSwgaSwgZ2xJbnRlcm5hbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCBpbWFnZS5kZXB0aCwgMCwgbWlwbWFwLmRhdGEsIDAsIDApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IEF0dGVtcHQgdG8gbG9hZCB1bnN1cHBvcnRlZCBjb21wcmVzc2VkIHRleHR1cmUgZm9ybWF0IGluIC51cGxvYWRUZXh0dXJlKCknKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0aWYgKHVzZVRleFN0b3JhZ2UpIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZS50ZXhTdWJJbWFnZTNEKF9nbC5URVhUVVJFXzJEX0FSUkFZLCBpLCAwLCAwLCAwLCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIGltYWdlLmRlcHRoLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UzRChfZ2wuVEVYVFVSRV8yRF9BUlJBWSwgaSwgZ2xJbnRlcm5hbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCBpbWFnZS5kZXB0aCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmRhdGEpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICh1c2VUZXhTdG9yYWdlICYmIGFsbG9jYXRlTWVtb3J5KSB7XG5cdFx0XHRcdFx0XHRzdGF0ZS50ZXhTdG9yYWdlMkQoX2dsLlRFWFRVUkVfMkQsIGxldmVscywgZ2xJbnRlcm5hbEZvcm1hdCwgbWlwbWFwc1swXS53aWR0aCwgbWlwbWFwc1swXS5oZWlnaHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSBtaXBtYXBzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0XHRcdG1pcG1hcCA9IG1pcG1hcHNbaV07XG5cdFx0XHRcdFx0XHRpZiAodGV4dHVyZS5mb3JtYXQgIT09IFJHQkFGb3JtYXQpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGdsRm9ybWF0ICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHVzZVRleFN0b3JhZ2UpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHN0YXRlLmNvbXByZXNzZWRUZXhTdWJJbWFnZTJEKF9nbC5URVhUVVJFXzJELCBpLCAwLCAwLCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIGdsRm9ybWF0LCBtaXBtYXAuZGF0YSk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdHN0YXRlLmNvbXByZXNzZWRUZXhJbWFnZTJEKF9nbC5URVhUVVJFXzJELCBpLCBnbEludGVybmFsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIG1pcG1hcC5kYXRhKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiBBdHRlbXB0IHRvIGxvYWQgdW5zdXBwb3J0ZWQgY29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdCBpbiAudXBsb2FkVGV4dHVyZSgpJyk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGlmICh1c2VUZXhTdG9yYWdlKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGUudGV4U3ViSW1hZ2UyRChfZ2wuVEVYVFVSRV8yRCwgaSwgMCwgMCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRChfZ2wuVEVYVFVSRV8yRCwgaSwgZ2xJbnRlcm5hbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAodGV4dHVyZS5pc0RhdGFBcnJheVRleHR1cmUpIHtcblx0XHRcdFx0aWYgKHVzZVRleFN0b3JhZ2UpIHtcblx0XHRcdFx0XHRpZiAoYWxsb2NhdGVNZW1vcnkpIHtcblx0XHRcdFx0XHRcdHN0YXRlLnRleFN0b3JhZ2UzRChfZ2wuVEVYVFVSRV8yRF9BUlJBWSwgbGV2ZWxzLCBnbEludGVybmFsRm9ybWF0LCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCBpbWFnZS5kZXB0aCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHN0YXRlLnRleFN1YkltYWdlM0QoX2dsLlRFWFRVUkVfMkRfQVJSQVksIDAsIDAsIDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIGltYWdlLmRlcHRoLCBnbEZvcm1hdCwgZ2xUeXBlLCBpbWFnZS5kYXRhKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTNEKF9nbC5URVhUVVJFXzJEX0FSUkFZLCAwLCBnbEludGVybmFsRm9ybWF0LCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCBpbWFnZS5kZXB0aCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgaW1hZ2UuZGF0YSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAodGV4dHVyZS5pc0RhdGEzRFRleHR1cmUpIHtcblx0XHRcdFx0aWYgKHVzZVRleFN0b3JhZ2UpIHtcblx0XHRcdFx0XHRpZiAoYWxsb2NhdGVNZW1vcnkpIHtcblx0XHRcdFx0XHRcdHN0YXRlLnRleFN0b3JhZ2UzRChfZ2wuVEVYVFVSRV8zRCwgbGV2ZWxzLCBnbEludGVybmFsRm9ybWF0LCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCBpbWFnZS5kZXB0aCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHN0YXRlLnRleFN1YkltYWdlM0QoX2dsLlRFWFRVUkVfM0QsIDAsIDAsIDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIGltYWdlLmRlcHRoLCBnbEZvcm1hdCwgZ2xUeXBlLCBpbWFnZS5kYXRhKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTNEKF9nbC5URVhUVVJFXzNELCAwLCBnbEludGVybmFsRm9ybWF0LCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCBpbWFnZS5kZXB0aCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgaW1hZ2UuZGF0YSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAodGV4dHVyZS5pc0ZyYW1lYnVmZmVyVGV4dHVyZSkge1xuXHRcdFx0XHRpZiAoYWxsb2NhdGVNZW1vcnkpIHtcblx0XHRcdFx0XHRpZiAodXNlVGV4U3RvcmFnZSkge1xuXHRcdFx0XHRcdFx0c3RhdGUudGV4U3RvcmFnZTJEKF9nbC5URVhUVVJFXzJELCBsZXZlbHMsIGdsSW50ZXJuYWxGb3JtYXQsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRsZXQgd2lkdGggPSBpbWFnZS53aWR0aCxcblx0XHRcdFx0XHRcdFx0aGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZXZlbHM7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKF9nbC5URVhUVVJFXzJELCBpLCBnbEludGVybmFsRm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBudWxsKTtcblx0XHRcdFx0XHRcdFx0d2lkdGggPj49IDE7XG5cdFx0XHRcdFx0XHRcdGhlaWdodCA+Pj0gMTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHJlZ3VsYXIgVGV4dHVyZSAoaW1hZ2UsIHZpZGVvLCBjYW52YXMpXG5cblx0XHRcdFx0Ly8gdXNlIG1hbnVhbGx5IGNyZWF0ZWQgbWlwbWFwcyBpZiBhdmFpbGFibGVcblx0XHRcdFx0Ly8gaWYgdGhlcmUgYXJlIG5vIG1hbnVhbCBtaXBtYXBzXG5cdFx0XHRcdC8vIHNldCAwIGxldmVsIG1pcG1hcCBhbmQgdGhlbiB1c2UgR0wgdG8gZ2VuZXJhdGUgb3RoZXIgbWlwbWFwIGxldmVsc1xuXG5cdFx0XHRcdGlmIChtaXBtYXBzLmxlbmd0aCA+IDAgJiYgc3VwcG9ydHNNaXBzKSB7XG5cdFx0XHRcdFx0aWYgKHVzZVRleFN0b3JhZ2UgJiYgYWxsb2NhdGVNZW1vcnkpIHtcblx0XHRcdFx0XHRcdHN0YXRlLnRleFN0b3JhZ2UyRChfZ2wuVEVYVFVSRV8yRCwgbGV2ZWxzLCBnbEludGVybmFsRm9ybWF0LCBtaXBtYXBzWzBdLndpZHRoLCBtaXBtYXBzWzBdLmhlaWdodCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IG1pcG1hcHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHRcdFx0bWlwbWFwID0gbWlwbWFwc1tpXTtcblx0XHRcdFx0XHRcdGlmICh1c2VUZXhTdG9yYWdlKSB7XG5cdFx0XHRcdFx0XHRcdHN0YXRlLnRleFN1YkltYWdlMkQoX2dsLlRFWFRVUkVfMkQsIGksIDAsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKF9nbC5URVhUVVJFXzJELCBpLCBnbEludGVybmFsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICh1c2VUZXhTdG9yYWdlKSB7XG5cdFx0XHRcdFx0XHRpZiAoYWxsb2NhdGVNZW1vcnkpIHtcblx0XHRcdFx0XHRcdFx0c3RhdGUudGV4U3RvcmFnZTJEKF9nbC5URVhUVVJFXzJELCBsZXZlbHMsIGdsSW50ZXJuYWxGb3JtYXQsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0c3RhdGUudGV4U3ViSW1hZ2UyRChfZ2wuVEVYVFVSRV8yRCwgMCwgMCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgaW1hZ2UpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKF9nbC5URVhUVVJFXzJELCAwLCBnbEludGVybmFsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCBpbWFnZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAodGV4dHVyZU5lZWRzR2VuZXJhdGVNaXBtYXBzKHRleHR1cmUsIHN1cHBvcnRzTWlwcykpIHtcblx0XHRcdFx0Z2VuZXJhdGVNaXBtYXAodGV4dHVyZVR5cGUpO1xuXHRcdFx0fVxuXHRcdFx0c291cmNlUHJvcGVydGllcy5fX3ZlcnNpb24gPSBzb3VyY2UudmVyc2lvbjtcblx0XHRcdGlmICh0ZXh0dXJlLm9uVXBkYXRlKSB0ZXh0dXJlLm9uVXBkYXRlKHRleHR1cmUpO1xuXHRcdH1cblx0XHR0ZXh0dXJlUHJvcGVydGllcy5fX3ZlcnNpb24gPSB0ZXh0dXJlLnZlcnNpb247XG5cdH1cblx0ZnVuY3Rpb24gdXBsb2FkQ3ViZVRleHR1cmUodGV4dHVyZVByb3BlcnRpZXMsIHRleHR1cmUsIHNsb3QpIHtcblx0XHRpZiAodGV4dHVyZS5pbWFnZS5sZW5ndGggIT09IDYpIHJldHVybjtcblx0XHRjb25zdCBmb3JjZVVwbG9hZCA9IGluaXRUZXh0dXJlKHRleHR1cmVQcm9wZXJ0aWVzLCB0ZXh0dXJlKTtcblx0XHRjb25zdCBzb3VyY2UgPSB0ZXh0dXJlLnNvdXJjZTtcblx0XHRzdGF0ZS5iaW5kVGV4dHVyZShfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUsIF9nbC5URVhUVVJFMCArIHNsb3QpO1xuXHRcdGNvbnN0IHNvdXJjZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldChzb3VyY2UpO1xuXHRcdGlmIChzb3VyY2UudmVyc2lvbiAhPT0gc291cmNlUHJvcGVydGllcy5fX3ZlcnNpb24gfHwgZm9yY2VVcGxvYWQgPT09IHRydWUpIHtcblx0XHRcdHN0YXRlLmFjdGl2ZVRleHR1cmUoX2dsLlRFWFRVUkUwICsgc2xvdCk7XG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoX2dsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRleHR1cmUuZmxpcFkpO1xuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKF9nbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIHRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSk7XG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoX2dsLlVOUEFDS19BTElHTk1FTlQsIHRleHR1cmUudW5wYWNrQWxpZ25tZW50KTtcblx0XHRcdF9nbC5waXhlbFN0b3JlaShfZ2wuVU5QQUNLX0NPTE9SU1BBQ0VfQ09OVkVSU0lPTl9XRUJHTCwgX2dsLk5PTkUpO1xuXHRcdFx0Y29uc3QgaXNDb21wcmVzc2VkID0gdGV4dHVyZS5pc0NvbXByZXNzZWRUZXh0dXJlIHx8IHRleHR1cmUuaW1hZ2VbMF0uaXNDb21wcmVzc2VkVGV4dHVyZTtcblx0XHRcdGNvbnN0IGlzRGF0YVRleHR1cmUgPSB0ZXh0dXJlLmltYWdlWzBdICYmIHRleHR1cmUuaW1hZ2VbMF0uaXNEYXRhVGV4dHVyZTtcblx0XHRcdGNvbnN0IGN1YmVJbWFnZSA9IFtdO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcblx0XHRcdFx0aWYgKCFpc0NvbXByZXNzZWQgJiYgIWlzRGF0YVRleHR1cmUpIHtcblx0XHRcdFx0XHRjdWJlSW1hZ2VbaV0gPSByZXNpemVJbWFnZSh0ZXh0dXJlLmltYWdlW2ldLCBmYWxzZSwgdHJ1ZSwgbWF4Q3ViZW1hcFNpemUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGN1YmVJbWFnZVtpXSA9IGlzRGF0YVRleHR1cmUgPyB0ZXh0dXJlLmltYWdlW2ldLmltYWdlIDogdGV4dHVyZS5pbWFnZVtpXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjdWJlSW1hZ2VbaV0gPSB2ZXJpZnlDb2xvclNwYWNlKHRleHR1cmUsIGN1YmVJbWFnZVtpXSk7XG5cdFx0XHR9XG5cdFx0XHRjb25zdCBpbWFnZSA9IGN1YmVJbWFnZVswXSxcblx0XHRcdFx0c3VwcG9ydHNNaXBzID0gaXNQb3dlck9mVHdvJDEoaW1hZ2UpIHx8IGlzV2ViR0wyLFxuXHRcdFx0XHRnbEZvcm1hdCA9IHV0aWxzLmNvbnZlcnQodGV4dHVyZS5mb3JtYXQsIHRleHR1cmUuZW5jb2RpbmcpLFxuXHRcdFx0XHRnbFR5cGUgPSB1dGlscy5jb252ZXJ0KHRleHR1cmUudHlwZSksXG5cdFx0XHRcdGdsSW50ZXJuYWxGb3JtYXQgPSBnZXRJbnRlcm5hbEZvcm1hdCh0ZXh0dXJlLmludGVybmFsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCB0ZXh0dXJlLmVuY29kaW5nKTtcblx0XHRcdGNvbnN0IHVzZVRleFN0b3JhZ2UgPSBpc1dlYkdMMiAmJiB0ZXh0dXJlLmlzVmlkZW9UZXh0dXJlICE9PSB0cnVlO1xuXHRcdFx0Y29uc3QgYWxsb2NhdGVNZW1vcnkgPSBzb3VyY2VQcm9wZXJ0aWVzLl9fdmVyc2lvbiA9PT0gdW5kZWZpbmVkIHx8IGZvcmNlVXBsb2FkID09PSB0cnVlO1xuXHRcdFx0bGV0IGxldmVscyA9IGdldE1pcExldmVscyh0ZXh0dXJlLCBpbWFnZSwgc3VwcG9ydHNNaXBzKTtcblx0XHRcdHNldFRleHR1cmVQYXJhbWV0ZXJzKF9nbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlLCBzdXBwb3J0c01pcHMpO1xuXHRcdFx0bGV0IG1pcG1hcHM7XG5cdFx0XHRpZiAoaXNDb21wcmVzc2VkKSB7XG5cdFx0XHRcdGlmICh1c2VUZXhTdG9yYWdlICYmIGFsbG9jYXRlTWVtb3J5KSB7XG5cdFx0XHRcdFx0c3RhdGUudGV4U3RvcmFnZTJEKF9nbC5URVhUVVJFX0NVQkVfTUFQLCBsZXZlbHMsIGdsSW50ZXJuYWxGb3JtYXQsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG5cdFx0XHRcdFx0bWlwbWFwcyA9IGN1YmVJbWFnZVtpXS5taXBtYXBzO1xuXHRcdFx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgbWlwbWFwcy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdFx0Y29uc3QgbWlwbWFwID0gbWlwbWFwc1tqXTtcblx0XHRcdFx0XHRcdGlmICh0ZXh0dXJlLmZvcm1hdCAhPT0gUkdCQUZvcm1hdCkge1xuXHRcdFx0XHRcdFx0XHRpZiAoZ2xGb3JtYXQgIT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAodXNlVGV4U3RvcmFnZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0c3RhdGUuY29tcHJlc3NlZFRleFN1YkltYWdlMkQoX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIGosIDAsIDAsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgZ2xGb3JtYXQsIG1pcG1hcC5kYXRhKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0c3RhdGUuY29tcHJlc3NlZFRleEltYWdlMkQoX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIGosIGdsSW50ZXJuYWxGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgbWlwbWFwLmRhdGEpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IEF0dGVtcHQgdG8gbG9hZCB1bnN1cHBvcnRlZCBjb21wcmVzc2VkIHRleHR1cmUgZm9ybWF0IGluIC5zZXRUZXh0dXJlQ3ViZSgpJyk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGlmICh1c2VUZXhTdG9yYWdlKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGUudGV4U3ViSW1hZ2UyRChfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgaiwgMCwgMCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRChfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgaiwgZ2xJbnRlcm5hbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1pcG1hcHMgPSB0ZXh0dXJlLm1pcG1hcHM7XG5cdFx0XHRcdGlmICh1c2VUZXhTdG9yYWdlICYmIGFsbG9jYXRlTWVtb3J5KSB7XG5cdFx0XHRcdFx0Ly8gVE9ETzogVW5pZm9ybWx5IGhhbmRsZSBtaXBtYXAgZGVmaW5pdGlvbnNcblx0XHRcdFx0XHQvLyBOb3JtYWwgdGV4dHVyZXMgYW5kIGNvbXByZXNzZWQgY3ViZSB0ZXh0dXJlcyBkZWZpbmUgYmFzZSBsZXZlbCArIG1pcHMgd2l0aCB0aGVpciBtaXBtYXAgYXJyYXlcblx0XHRcdFx0XHQvLyBVbmNvbXByZXNzZWQgY3ViZSB0ZXh0dXJlcyB1c2UgdGhlaXIgbWlwbWFwIGFycmF5IG9ubHkgZm9yIG1pcHMgKG5vIGJhc2UgbGV2ZWwpXG5cblx0XHRcdFx0XHRpZiAobWlwbWFwcy5sZW5ndGggPiAwKSBsZXZlbHMrKztcblx0XHRcdFx0XHRzdGF0ZS50ZXhTdG9yYWdlMkQoX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIGxldmVscywgZ2xJbnRlcm5hbEZvcm1hdCwgY3ViZUltYWdlWzBdLndpZHRoLCBjdWJlSW1hZ2VbMF0uaGVpZ2h0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xuXHRcdFx0XHRcdGlmIChpc0RhdGFUZXh0dXJlKSB7XG5cdFx0XHRcdFx0XHRpZiAodXNlVGV4U3RvcmFnZSkge1xuXHRcdFx0XHRcdFx0XHRzdGF0ZS50ZXhTdWJJbWFnZTJEKF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCAwLCAwLCAwLCBjdWJlSW1hZ2VbaV0ud2lkdGgsIGN1YmVJbWFnZVtpXS5oZWlnaHQsIGdsRm9ybWF0LCBnbFR5cGUsIGN1YmVJbWFnZVtpXS5kYXRhKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIDAsIGdsSW50ZXJuYWxGb3JtYXQsIGN1YmVJbWFnZVtpXS53aWR0aCwgY3ViZUltYWdlW2ldLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgY3ViZUltYWdlW2ldLmRhdGEpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBtaXBtYXBzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IG1pcG1hcCA9IG1pcG1hcHNbal07XG5cdFx0XHRcdFx0XHRcdGNvbnN0IG1pcG1hcEltYWdlID0gbWlwbWFwLmltYWdlW2ldLmltYWdlO1xuXHRcdFx0XHRcdFx0XHRpZiAodXNlVGV4U3RvcmFnZSkge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXRlLnRleFN1YkltYWdlMkQoX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIGogKyAxLCAwLCAwLCBtaXBtYXBJbWFnZS53aWR0aCwgbWlwbWFwSW1hZ2UuaGVpZ2h0LCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXBJbWFnZS5kYXRhKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCBqICsgMSwgZ2xJbnRlcm5hbEZvcm1hdCwgbWlwbWFwSW1hZ2Uud2lkdGgsIG1pcG1hcEltYWdlLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwSW1hZ2UuZGF0YSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYgKHVzZVRleFN0b3JhZ2UpIHtcblx0XHRcdFx0XHRcdFx0c3RhdGUudGV4U3ViSW1hZ2UyRChfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgMCwgMCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgY3ViZUltYWdlW2ldKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIDAsIGdsSW50ZXJuYWxGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUsIGN1YmVJbWFnZVtpXSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IG1pcG1hcHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgbWlwbWFwID0gbWlwbWFwc1tqXTtcblx0XHRcdFx0XHRcdFx0aWYgKHVzZVRleFN0b3JhZ2UpIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZS50ZXhTdWJJbWFnZTJEKF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCBqICsgMSwgMCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmltYWdlW2ldKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCBqICsgMSwgZ2xJbnRlcm5hbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmltYWdlW2ldKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHRleHR1cmVOZWVkc0dlbmVyYXRlTWlwbWFwcyh0ZXh0dXJlLCBzdXBwb3J0c01pcHMpKSB7XG5cdFx0XHRcdC8vIFdlIGFzc3VtZSBpbWFnZXMgZm9yIGN1YmUgbWFwIGhhdmUgdGhlIHNhbWUgc2l6ZS5cblx0XHRcdFx0Z2VuZXJhdGVNaXBtYXAoX2dsLlRFWFRVUkVfQ1VCRV9NQVApO1xuXHRcdFx0fVxuXHRcdFx0c291cmNlUHJvcGVydGllcy5fX3ZlcnNpb24gPSBzb3VyY2UudmVyc2lvbjtcblx0XHRcdGlmICh0ZXh0dXJlLm9uVXBkYXRlKSB0ZXh0dXJlLm9uVXBkYXRlKHRleHR1cmUpO1xuXHRcdH1cblx0XHR0ZXh0dXJlUHJvcGVydGllcy5fX3ZlcnNpb24gPSB0ZXh0dXJlLnZlcnNpb247XG5cdH1cblxuXHQvLyBSZW5kZXIgdGFyZ2V0c1xuXG5cdC8vIFNldHVwIHN0b3JhZ2UgZm9yIHRhcmdldCB0ZXh0dXJlIGFuZCBiaW5kIGl0IHRvIGNvcnJlY3QgZnJhbWVidWZmZXJcblx0ZnVuY3Rpb24gc2V0dXBGcmFtZUJ1ZmZlclRleHR1cmUoZnJhbWVidWZmZXIsIHJlbmRlclRhcmdldCwgdGV4dHVyZSwgYXR0YWNobWVudCwgdGV4dHVyZVRhcmdldCkge1xuXHRcdGNvbnN0IGdsRm9ybWF0ID0gdXRpbHMuY29udmVydCh0ZXh0dXJlLmZvcm1hdCwgdGV4dHVyZS5lbmNvZGluZyk7XG5cdFx0Y29uc3QgZ2xUeXBlID0gdXRpbHMuY29udmVydCh0ZXh0dXJlLnR5cGUpO1xuXHRcdGNvbnN0IGdsSW50ZXJuYWxGb3JtYXQgPSBnZXRJbnRlcm5hbEZvcm1hdCh0ZXh0dXJlLmludGVybmFsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCB0ZXh0dXJlLmVuY29kaW5nKTtcblx0XHRjb25zdCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQocmVuZGVyVGFyZ2V0KTtcblx0XHRpZiAoIXJlbmRlclRhcmdldFByb3BlcnRpZXMuX19oYXNFeHRlcm5hbFRleHR1cmVzKSB7XG5cdFx0XHRpZiAodGV4dHVyZVRhcmdldCA9PT0gX2dsLlRFWFRVUkVfM0QgfHwgdGV4dHVyZVRhcmdldCA9PT0gX2dsLlRFWFRVUkVfMkRfQVJSQVkpIHtcblx0XHRcdFx0c3RhdGUudGV4SW1hZ2UzRCh0ZXh0dXJlVGFyZ2V0LCAwLCBnbEludGVybmFsRm9ybWF0LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQsIHJlbmRlclRhcmdldC5kZXB0aCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbnVsbCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKHRleHR1cmVUYXJnZXQsIDAsIGdsSW50ZXJuYWxGb3JtYXQsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbnVsbCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlcihfZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyKTtcblx0XHRpZiAodXNlTXVsdGlzYW1wbGVkUlRUKHJlbmRlclRhcmdldCkpIHtcblx0XHRcdG11bHRpc2FtcGxlZFJUVEV4dC5mcmFtZWJ1ZmZlclRleHR1cmUyRE11bHRpc2FtcGxlRVhUKF9nbC5GUkFNRUJVRkZFUiwgYXR0YWNobWVudCwgdGV4dHVyZVRhcmdldCwgcHJvcGVydGllcy5nZXQodGV4dHVyZSkuX193ZWJnbFRleHR1cmUsIDAsIGdldFJlbmRlclRhcmdldFNhbXBsZXMocmVuZGVyVGFyZ2V0KSk7XG5cdFx0fSBlbHNlIGlmICh0ZXh0dXJlVGFyZ2V0ID09PSBfZ2wuVEVYVFVSRV8yRCB8fCB0ZXh0dXJlVGFyZ2V0ID49IF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggJiYgdGV4dHVyZVRhcmdldCA8PSBfZ2wuVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9aKSB7XG5cdFx0XHQvLyBzZWUgIzI0NzUzXG5cblx0XHRcdF9nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChfZ2wuRlJBTUVCVUZGRVIsIGF0dGFjaG1lbnQsIHRleHR1cmVUYXJnZXQsIHByb3BlcnRpZXMuZ2V0KHRleHR1cmUpLl9fd2ViZ2xUZXh0dXJlLCAwKTtcblx0XHR9XG5cdFx0c3RhdGUuYmluZEZyYW1lYnVmZmVyKF9nbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG5cdH1cblxuXHQvLyBTZXR1cCBzdG9yYWdlIGZvciBpbnRlcm5hbCBkZXB0aC9zdGVuY2lsIGJ1ZmZlcnMgYW5kIGJpbmQgdG8gY29ycmVjdCBmcmFtZWJ1ZmZlclxuXHRmdW5jdGlvbiBzZXR1cFJlbmRlckJ1ZmZlclN0b3JhZ2UocmVuZGVyYnVmZmVyLCByZW5kZXJUYXJnZXQsIGlzTXVsdGlzYW1wbGUpIHtcblx0XHRfZ2wuYmluZFJlbmRlcmJ1ZmZlcihfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIpO1xuXHRcdGlmIChyZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgJiYgIXJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyKSB7XG5cdFx0XHRsZXQgZ2xJbnRlcm5hbEZvcm1hdCA9IF9nbC5ERVBUSF9DT01QT05FTlQxNjtcblx0XHRcdGlmIChpc011bHRpc2FtcGxlIHx8IHVzZU11bHRpc2FtcGxlZFJUVChyZW5kZXJUYXJnZXQpKSB7XG5cdFx0XHRcdGNvbnN0IGRlcHRoVGV4dHVyZSA9IHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmU7XG5cdFx0XHRcdGlmIChkZXB0aFRleHR1cmUgJiYgZGVwdGhUZXh0dXJlLmlzRGVwdGhUZXh0dXJlKSB7XG5cdFx0XHRcdFx0aWYgKGRlcHRoVGV4dHVyZS50eXBlID09PSBGbG9hdFR5cGUpIHtcblx0XHRcdFx0XHRcdGdsSW50ZXJuYWxGb3JtYXQgPSBfZ2wuREVQVEhfQ09NUE9ORU5UMzJGO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoZGVwdGhUZXh0dXJlLnR5cGUgPT09IFVuc2lnbmVkSW50VHlwZSkge1xuXHRcdFx0XHRcdFx0Z2xJbnRlcm5hbEZvcm1hdCA9IF9nbC5ERVBUSF9DT01QT05FTlQyNDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29uc3Qgc2FtcGxlcyA9IGdldFJlbmRlclRhcmdldFNhbXBsZXMocmVuZGVyVGFyZ2V0KTtcblx0XHRcdFx0aWYgKHVzZU11bHRpc2FtcGxlZFJUVChyZW5kZXJUYXJnZXQpKSB7XG5cdFx0XHRcdFx0bXVsdGlzYW1wbGVkUlRURXh0LnJlbmRlcmJ1ZmZlclN0b3JhZ2VNdWx0aXNhbXBsZUVYVChfZ2wuUkVOREVSQlVGRkVSLCBzYW1wbGVzLCBnbEludGVybmFsRm9ybWF0LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUoX2dsLlJFTkRFUkJVRkZFUiwgc2FtcGxlcywgZ2xJbnRlcm5hbEZvcm1hdCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0X2dsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoX2dsLlJFTkRFUkJVRkZFUiwgZ2xJbnRlcm5hbEZvcm1hdCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0KTtcblx0XHRcdH1cblx0XHRcdF9nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihfZ2wuRlJBTUVCVUZGRVIsIF9nbC5ERVBUSF9BVFRBQ0hNRU5ULCBfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIpO1xuXHRcdH0gZWxzZSBpZiAocmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICYmIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyKSB7XG5cdFx0XHRjb25zdCBzYW1wbGVzID0gZ2V0UmVuZGVyVGFyZ2V0U2FtcGxlcyhyZW5kZXJUYXJnZXQpO1xuXHRcdFx0aWYgKGlzTXVsdGlzYW1wbGUgJiYgdXNlTXVsdGlzYW1wbGVkUlRUKHJlbmRlclRhcmdldCkgPT09IGZhbHNlKSB7XG5cdFx0XHRcdF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUoX2dsLlJFTkRFUkJVRkZFUiwgc2FtcGxlcywgX2dsLkRFUFRIMjRfU1RFTkNJTDgsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCk7XG5cdFx0XHR9IGVsc2UgaWYgKHVzZU11bHRpc2FtcGxlZFJUVChyZW5kZXJUYXJnZXQpKSB7XG5cdFx0XHRcdG11bHRpc2FtcGxlZFJUVEV4dC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGVFWFQoX2dsLlJFTkRFUkJVRkZFUiwgc2FtcGxlcywgX2dsLkRFUFRIMjRfU1RFTkNJTDgsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZShfZ2wuUkVOREVSQlVGRkVSLCBfZ2wuREVQVEhfU1RFTkNJTCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0KTtcblx0XHRcdH1cblx0XHRcdF9nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihfZ2wuRlJBTUVCVUZGRVIsIF9nbC5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlcik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnN0IHRleHR1cmVzID0gcmVuZGVyVGFyZ2V0LmlzV2ViR0xNdWx0aXBsZVJlbmRlclRhcmdldHMgPT09IHRydWUgPyByZW5kZXJUYXJnZXQudGV4dHVyZSA6IFtyZW5kZXJUYXJnZXQudGV4dHVyZV07XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRleHR1cmVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IHRleHR1cmUgPSB0ZXh0dXJlc1tpXTtcblx0XHRcdFx0Y29uc3QgZ2xGb3JtYXQgPSB1dGlscy5jb252ZXJ0KHRleHR1cmUuZm9ybWF0LCB0ZXh0dXJlLmVuY29kaW5nKTtcblx0XHRcdFx0Y29uc3QgZ2xUeXBlID0gdXRpbHMuY29udmVydCh0ZXh0dXJlLnR5cGUpO1xuXHRcdFx0XHRjb25zdCBnbEludGVybmFsRm9ybWF0ID0gZ2V0SW50ZXJuYWxGb3JtYXQodGV4dHVyZS5pbnRlcm5hbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgdGV4dHVyZS5lbmNvZGluZyk7XG5cdFx0XHRcdGNvbnN0IHNhbXBsZXMgPSBnZXRSZW5kZXJUYXJnZXRTYW1wbGVzKHJlbmRlclRhcmdldCk7XG5cdFx0XHRcdGlmIChpc011bHRpc2FtcGxlICYmIHVzZU11bHRpc2FtcGxlZFJUVChyZW5kZXJUYXJnZXQpID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUoX2dsLlJFTkRFUkJVRkZFUiwgc2FtcGxlcywgZ2xJbnRlcm5hbEZvcm1hdCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0KTtcblx0XHRcdFx0fSBlbHNlIGlmICh1c2VNdWx0aXNhbXBsZWRSVFQocmVuZGVyVGFyZ2V0KSkge1xuXHRcdFx0XHRcdG11bHRpc2FtcGxlZFJUVEV4dC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGVFWFQoX2dsLlJFTkRFUkJVRkZFUiwgc2FtcGxlcywgZ2xJbnRlcm5hbEZvcm1hdCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZShfZ2wuUkVOREVSQlVGRkVSLCBnbEludGVybmFsRm9ybWF0LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdF9nbC5iaW5kUmVuZGVyYnVmZmVyKF9nbC5SRU5ERVJCVUZGRVIsIG51bGwpO1xuXHR9XG5cblx0Ly8gU2V0dXAgcmVzb3VyY2VzIGZvciBhIERlcHRoIFRleHR1cmUgZm9yIGEgRkJPIChuZWVkcyBhbiBleHRlbnNpb24pXG5cdGZ1bmN0aW9uIHNldHVwRGVwdGhUZXh0dXJlKGZyYW1lYnVmZmVyLCByZW5kZXJUYXJnZXQpIHtcblx0XHRjb25zdCBpc0N1YmUgPSByZW5kZXJUYXJnZXQgJiYgcmVuZGVyVGFyZ2V0LmlzV2ViR0xDdWJlUmVuZGVyVGFyZ2V0O1xuXHRcdGlmIChpc0N1YmUpIHRocm93IG5ldyBFcnJvcignRGVwdGggVGV4dHVyZSB3aXRoIGN1YmUgcmVuZGVyIHRhcmdldHMgaXMgbm90IHN1cHBvcnRlZCcpO1xuXHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlcihfZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyKTtcblx0XHRpZiAoIShyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlICYmIHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUuaXNEZXB0aFRleHR1cmUpKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ3JlbmRlclRhcmdldC5kZXB0aFRleHR1cmUgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBUSFJFRS5EZXB0aFRleHR1cmUnKTtcblx0XHR9XG5cblx0XHQvLyB1cGxvYWQgYW4gZW1wdHkgZGVwdGggdGV4dHVyZSB3aXRoIGZyYW1lYnVmZmVyIHNpemVcblx0XHRpZiAoIXByb3BlcnRpZXMuZ2V0KHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUpLl9fd2ViZ2xUZXh0dXJlIHx8IHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUuaW1hZ2Uud2lkdGggIT09IHJlbmRlclRhcmdldC53aWR0aCB8fCByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmltYWdlLmhlaWdodCAhPT0gcmVuZGVyVGFyZ2V0LmhlaWdodCkge1xuXHRcdFx0cmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5pbWFnZS53aWR0aCA9IHJlbmRlclRhcmdldC53aWR0aDtcblx0XHRcdHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUuaW1hZ2UuaGVpZ2h0ID0gcmVuZGVyVGFyZ2V0LmhlaWdodDtcblx0XHRcdHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdH1cblx0XHRzZXRUZXh0dXJlMkQocmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZSwgMCk7XG5cdFx0Y29uc3Qgd2ViZ2xEZXB0aFRleHR1cmUgPSBwcm9wZXJ0aWVzLmdldChyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlKS5fX3dlYmdsVGV4dHVyZTtcblx0XHRjb25zdCBzYW1wbGVzID0gZ2V0UmVuZGVyVGFyZ2V0U2FtcGxlcyhyZW5kZXJUYXJnZXQpO1xuXHRcdGlmIChyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmZvcm1hdCA9PT0gRGVwdGhGb3JtYXQpIHtcblx0XHRcdGlmICh1c2VNdWx0aXNhbXBsZWRSVFQocmVuZGVyVGFyZ2V0KSkge1xuXHRcdFx0XHRtdWx0aXNhbXBsZWRSVFRFeHQuZnJhbWVidWZmZXJUZXh0dXJlMkRNdWx0aXNhbXBsZUVYVChfZ2wuRlJBTUVCVUZGRVIsIF9nbC5ERVBUSF9BVFRBQ0hNRU5ULCBfZ2wuVEVYVFVSRV8yRCwgd2ViZ2xEZXB0aFRleHR1cmUsIDAsIHNhbXBsZXMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0X2dsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX0FUVEFDSE1FTlQsIF9nbC5URVhUVVJFXzJELCB3ZWJnbERlcHRoVGV4dHVyZSwgMCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmZvcm1hdCA9PT0gRGVwdGhTdGVuY2lsRm9ybWF0KSB7XG5cdFx0XHRpZiAodXNlTXVsdGlzYW1wbGVkUlRUKHJlbmRlclRhcmdldCkpIHtcblx0XHRcdFx0bXVsdGlzYW1wbGVkUlRURXh0LmZyYW1lYnVmZmVyVGV4dHVyZTJETXVsdGlzYW1wbGVFWFQoX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULCBfZ2wuVEVYVFVSRV8yRCwgd2ViZ2xEZXB0aFRleHR1cmUsIDAsIHNhbXBsZXMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0X2dsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCwgX2dsLlRFWFRVUkVfMkQsIHdlYmdsRGVwdGhUZXh0dXJlLCAwKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGRlcHRoVGV4dHVyZSBmb3JtYXQnKTtcblx0XHR9XG5cdH1cblxuXHQvLyBTZXR1cCBHTCByZXNvdXJjZXMgZm9yIGEgbm9uLXRleHR1cmUgZGVwdGggYnVmZmVyXG5cdGZ1bmN0aW9uIHNldHVwRGVwdGhSZW5kZXJidWZmZXIocmVuZGVyVGFyZ2V0KSB7XG5cdFx0Y29uc3QgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KHJlbmRlclRhcmdldCk7XG5cdFx0Y29uc3QgaXNDdWJlID0gcmVuZGVyVGFyZ2V0LmlzV2ViR0xDdWJlUmVuZGVyVGFyZ2V0ID09PSB0cnVlO1xuXHRcdGlmIChyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlICYmICFyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fYXV0b0FsbG9jYXRlRGVwdGhCdWZmZXIpIHtcblx0XHRcdGlmIChpc0N1YmUpIHRocm93IG5ldyBFcnJvcigndGFyZ2V0LmRlcHRoVGV4dHVyZSBub3Qgc3VwcG9ydGVkIGluIEN1YmUgcmVuZGVyIHRhcmdldHMnKTtcblx0XHRcdHNldHVwRGVwdGhUZXh0dXJlKHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyLCByZW5kZXJUYXJnZXQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoaXNDdWJlKSB7XG5cdFx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoYnVmZmVyID0gW107XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG5cdFx0XHRcdFx0c3RhdGUuYmluZEZyYW1lYnVmZmVyKF9nbC5GUkFNRUJVRkZFUiwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXJbaV0pO1xuXHRcdFx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoYnVmZmVyW2ldID0gX2dsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xuXHRcdFx0XHRcdHNldHVwUmVuZGVyQnVmZmVyU3RvcmFnZShyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlcltpXSwgcmVuZGVyVGFyZ2V0LCBmYWxzZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlcihfZ2wuRlJBTUVCVUZGRVIsIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyKTtcblx0XHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXIgPSBfZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG5cdFx0XHRcdHNldHVwUmVuZGVyQnVmZmVyU3RvcmFnZShyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlciwgcmVuZGVyVGFyZ2V0LCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlcihfZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuXHR9XG5cblx0Ly8gcmViaW5kIGZyYW1lYnVmZmVyIHdpdGggZXh0ZXJuYWwgdGV4dHVyZXNcblx0ZnVuY3Rpb24gcmViaW5kVGV4dHVyZXMocmVuZGVyVGFyZ2V0LCBjb2xvclRleHR1cmUsIGRlcHRoVGV4dHVyZSkge1xuXHRcdGNvbnN0IHJlbmRlclRhcmdldFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldChyZW5kZXJUYXJnZXQpO1xuXHRcdGlmIChjb2xvclRleHR1cmUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0c2V0dXBGcmFtZUJ1ZmZlclRleHR1cmUocmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIsIHJlbmRlclRhcmdldCwgcmVuZGVyVGFyZ2V0LnRleHR1cmUsIF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgX2dsLlRFWFRVUkVfMkQpO1xuXHRcdH1cblx0XHRpZiAoZGVwdGhUZXh0dXJlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHNldHVwRGVwdGhSZW5kZXJidWZmZXIocmVuZGVyVGFyZ2V0KTtcblx0XHR9XG5cdH1cblxuXHQvLyBTZXQgdXAgR0wgcmVzb3VyY2VzIGZvciB0aGUgcmVuZGVyIHRhcmdldFxuXHRmdW5jdGlvbiBzZXR1cFJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQpIHtcblx0XHRjb25zdCB0ZXh0dXJlID0gcmVuZGVyVGFyZ2V0LnRleHR1cmU7XG5cdFx0Y29uc3QgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KHJlbmRlclRhcmdldCk7XG5cdFx0Y29uc3QgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCh0ZXh0dXJlKTtcblx0XHRyZW5kZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIG9uUmVuZGVyVGFyZ2V0RGlzcG9zZSk7XG5cdFx0aWYgKHJlbmRlclRhcmdldC5pc1dlYkdMTXVsdGlwbGVSZW5kZXJUYXJnZXRzICE9PSB0cnVlKSB7XG5cdFx0XHRpZiAodGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSA9IF9nbC5jcmVhdGVUZXh0dXJlKCk7XG5cdFx0XHR9XG5cdFx0XHR0ZXh0dXJlUHJvcGVydGllcy5fX3ZlcnNpb24gPSB0ZXh0dXJlLnZlcnNpb247XG5cdFx0XHRpbmZvLm1lbW9yeS50ZXh0dXJlcysrO1xuXHRcdH1cblx0XHRjb25zdCBpc0N1YmUgPSByZW5kZXJUYXJnZXQuaXNXZWJHTEN1YmVSZW5kZXJUYXJnZXQgPT09IHRydWU7XG5cdFx0Y29uc3QgaXNNdWx0aXBsZVJlbmRlclRhcmdldHMgPSByZW5kZXJUYXJnZXQuaXNXZWJHTE11bHRpcGxlUmVuZGVyVGFyZ2V0cyA9PT0gdHJ1ZTtcblx0XHRjb25zdCBzdXBwb3J0c01pcHMgPSBpc1Bvd2VyT2ZUd28kMShyZW5kZXJUYXJnZXQpIHx8IGlzV2ViR0wyO1xuXG5cdFx0Ly8gU2V0dXAgZnJhbWVidWZmZXJcblxuXHRcdGlmIChpc0N1YmUpIHtcblx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyID0gW107XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xuXHRcdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlcltpXSA9IF9nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciA9IF9nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuXHRcdFx0aWYgKGlzTXVsdGlwbGVSZW5kZXJUYXJnZXRzKSB7XG5cdFx0XHRcdGlmIChjYXBhYmlsaXRpZXMuZHJhd0J1ZmZlcnMpIHtcblx0XHRcdFx0XHRjb25zdCB0ZXh0dXJlcyA9IHJlbmRlclRhcmdldC50ZXh0dXJlO1xuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IHRleHR1cmVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0XHRcdGNvbnN0IGF0dGFjaG1lbnRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQodGV4dHVyZXNbaV0pO1xuXHRcdFx0XHRcdFx0aWYgKGF0dGFjaG1lbnRQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0YXR0YWNobWVudFByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgPSBfZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXHRcdFx0XHRcdFx0XHRpbmZvLm1lbW9yeS50ZXh0dXJlcysrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFdlYkdMTXVsdGlwbGVSZW5kZXJUYXJnZXRzIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBXZWJHTDIgb3IgV0VCR0xfZHJhd19idWZmZXJzIGV4dGVuc2lvbi4nKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGlzV2ViR0wyICYmIHJlbmRlclRhcmdldC5zYW1wbGVzID4gMCAmJiB1c2VNdWx0aXNhbXBsZWRSVFQocmVuZGVyVGFyZ2V0KSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0Y29uc3QgdGV4dHVyZXMgPSBpc011bHRpcGxlUmVuZGVyVGFyZ2V0cyA/IHRleHR1cmUgOiBbdGV4dHVyZV07XG5cdFx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbE11bHRpc2FtcGxlZEZyYW1lYnVmZmVyID0gX2dsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG5cdFx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbENvbG9yUmVuZGVyYnVmZmVyID0gW107XG5cdFx0XHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlcihfZ2wuRlJBTUVCVUZGRVIsIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbE11bHRpc2FtcGxlZEZyYW1lYnVmZmVyKTtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0dXJlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGNvbnN0IHRleHR1cmUgPSB0ZXh0dXJlc1tpXTtcblx0XHRcdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xDb2xvclJlbmRlcmJ1ZmZlcltpXSA9IF9nbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcblx0XHRcdFx0XHRfZ2wuYmluZFJlbmRlcmJ1ZmZlcihfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xDb2xvclJlbmRlcmJ1ZmZlcltpXSk7XG5cdFx0XHRcdFx0Y29uc3QgZ2xGb3JtYXQgPSB1dGlscy5jb252ZXJ0KHRleHR1cmUuZm9ybWF0LCB0ZXh0dXJlLmVuY29kaW5nKTtcblx0XHRcdFx0XHRjb25zdCBnbFR5cGUgPSB1dGlscy5jb252ZXJ0KHRleHR1cmUudHlwZSk7XG5cdFx0XHRcdFx0Y29uc3QgZ2xJbnRlcm5hbEZvcm1hdCA9IGdldEludGVybmFsRm9ybWF0KHRleHR1cmUuaW50ZXJuYWxGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUsIHRleHR1cmUuZW5jb2RpbmcsIHJlbmRlclRhcmdldC5pc1hSUmVuZGVyVGFyZ2V0ID09PSB0cnVlKTtcblx0XHRcdFx0XHRjb25zdCBzYW1wbGVzID0gZ2V0UmVuZGVyVGFyZ2V0U2FtcGxlcyhyZW5kZXJUYXJnZXQpO1xuXHRcdFx0XHRcdF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUoX2dsLlJFTkRFUkJVRkZFUiwgc2FtcGxlcywgZ2xJbnRlcm5hbEZvcm1hdCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0KTtcblx0XHRcdFx0XHRfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoX2dsLkZSQU1FQlVGRkVSLCBfZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpLCBfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xDb2xvclJlbmRlcmJ1ZmZlcltpXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0X2dsLmJpbmRSZW5kZXJidWZmZXIoX2dsLlJFTkRFUkJVRkZFUiwgbnVsbCk7XG5cdFx0XHRcdGlmIChyZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIpIHtcblx0XHRcdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aFJlbmRlcmJ1ZmZlciA9IF9nbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcblx0XHRcdFx0XHRzZXR1cFJlbmRlckJ1ZmZlclN0b3JhZ2UocmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhSZW5kZXJidWZmZXIsIHJlbmRlclRhcmdldCwgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RhdGUuYmluZEZyYW1lYnVmZmVyKF9nbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2V0dXAgY29sb3IgYnVmZmVyXG5cblx0XHRpZiAoaXNDdWJlKSB7XG5cdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZShfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUpO1xuXHRcdFx0c2V0VGV4dHVyZVBhcmFtZXRlcnMoX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmUsIHN1cHBvcnRzTWlwcyk7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xuXHRcdFx0XHRzZXR1cEZyYW1lQnVmZmVyVGV4dHVyZShyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlcltpXSwgcmVuZGVyVGFyZ2V0LCB0ZXh0dXJlLCBfZ2wuQ09MT1JfQVRUQUNITUVOVDAsIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpKTtcblx0XHRcdH1cblx0XHRcdGlmICh0ZXh0dXJlTmVlZHNHZW5lcmF0ZU1pcG1hcHModGV4dHVyZSwgc3VwcG9ydHNNaXBzKSkge1xuXHRcdFx0XHRnZW5lcmF0ZU1pcG1hcChfZ2wuVEVYVFVSRV9DVUJFX01BUCk7XG5cdFx0XHR9XG5cdFx0XHRzdGF0ZS51bmJpbmRUZXh0dXJlKCk7XG5cdFx0fSBlbHNlIGlmIChpc011bHRpcGxlUmVuZGVyVGFyZ2V0cykge1xuXHRcdFx0Y29uc3QgdGV4dHVyZXMgPSByZW5kZXJUYXJnZXQudGV4dHVyZTtcblx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IHRleHR1cmVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgYXR0YWNobWVudCA9IHRleHR1cmVzW2ldO1xuXHRcdFx0XHRjb25zdCBhdHRhY2htZW50UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KGF0dGFjaG1lbnQpO1xuXHRcdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZShfZ2wuVEVYVFVSRV8yRCwgYXR0YWNobWVudFByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUpO1xuXHRcdFx0XHRzZXRUZXh0dXJlUGFyYW1ldGVycyhfZ2wuVEVYVFVSRV8yRCwgYXR0YWNobWVudCwgc3VwcG9ydHNNaXBzKTtcblx0XHRcdFx0c2V0dXBGcmFtZUJ1ZmZlclRleHR1cmUocmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIsIHJlbmRlclRhcmdldCwgYXR0YWNobWVudCwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwICsgaSwgX2dsLlRFWFRVUkVfMkQpO1xuXHRcdFx0XHRpZiAodGV4dHVyZU5lZWRzR2VuZXJhdGVNaXBtYXBzKGF0dGFjaG1lbnQsIHN1cHBvcnRzTWlwcykpIHtcblx0XHRcdFx0XHRnZW5lcmF0ZU1pcG1hcChfZ2wuVEVYVFVSRV8yRCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHN0YXRlLnVuYmluZFRleHR1cmUoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGV0IGdsVGV4dHVyZVR5cGUgPSBfZ2wuVEVYVFVSRV8yRDtcblx0XHRcdGlmIChyZW5kZXJUYXJnZXQuaXNXZWJHTDNEUmVuZGVyVGFyZ2V0IHx8IHJlbmRlclRhcmdldC5pc1dlYkdMQXJyYXlSZW5kZXJUYXJnZXQpIHtcblx0XHRcdFx0aWYgKGlzV2ViR0wyKSB7XG5cdFx0XHRcdFx0Z2xUZXh0dXJlVHlwZSA9IHJlbmRlclRhcmdldC5pc1dlYkdMM0RSZW5kZXJUYXJnZXQgPyBfZ2wuVEVYVFVSRV8zRCA6IF9nbC5URVhUVVJFXzJEX0FSUkFZO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLldlYkdMVGV4dHVyZXM6IFRIUkVFLkRhdGEzRFRleHR1cmUgYW5kIFRIUkVFLkRhdGFBcnJheVRleHR1cmUgb25seSBzdXBwb3J0ZWQgd2l0aCBXZWJHTDIuJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKGdsVGV4dHVyZVR5cGUsIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlKTtcblx0XHRcdHNldFRleHR1cmVQYXJhbWV0ZXJzKGdsVGV4dHVyZVR5cGUsIHRleHR1cmUsIHN1cHBvcnRzTWlwcyk7XG5cdFx0XHRzZXR1cEZyYW1lQnVmZmVyVGV4dHVyZShyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciwgcmVuZGVyVGFyZ2V0LCB0ZXh0dXJlLCBfZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsVGV4dHVyZVR5cGUpO1xuXHRcdFx0aWYgKHRleHR1cmVOZWVkc0dlbmVyYXRlTWlwbWFwcyh0ZXh0dXJlLCBzdXBwb3J0c01pcHMpKSB7XG5cdFx0XHRcdGdlbmVyYXRlTWlwbWFwKGdsVGV4dHVyZVR5cGUpO1xuXHRcdFx0fVxuXHRcdFx0c3RhdGUudW5iaW5kVGV4dHVyZSgpO1xuXHRcdH1cblxuXHRcdC8vIFNldHVwIGRlcHRoIGFuZCBzdGVuY2lsIGJ1ZmZlcnNcblxuXHRcdGlmIChyZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIpIHtcblx0XHRcdHNldHVwRGVwdGhSZW5kZXJidWZmZXIocmVuZGVyVGFyZ2V0KTtcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwKHJlbmRlclRhcmdldCkge1xuXHRcdGNvbnN0IHN1cHBvcnRzTWlwcyA9IGlzUG93ZXJPZlR3byQxKHJlbmRlclRhcmdldCkgfHwgaXNXZWJHTDI7XG5cdFx0Y29uc3QgdGV4dHVyZXMgPSByZW5kZXJUYXJnZXQuaXNXZWJHTE11bHRpcGxlUmVuZGVyVGFyZ2V0cyA9PT0gdHJ1ZSA/IHJlbmRlclRhcmdldC50ZXh0dXJlIDogW3JlbmRlclRhcmdldC50ZXh0dXJlXTtcblx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSB0ZXh0dXJlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRjb25zdCB0ZXh0dXJlID0gdGV4dHVyZXNbaV07XG5cdFx0XHRpZiAodGV4dHVyZU5lZWRzR2VuZXJhdGVNaXBtYXBzKHRleHR1cmUsIHN1cHBvcnRzTWlwcykpIHtcblx0XHRcdFx0Y29uc3QgdGFyZ2V0ID0gcmVuZGVyVGFyZ2V0LmlzV2ViR0xDdWJlUmVuZGVyVGFyZ2V0ID8gX2dsLlRFWFRVUkVfQ1VCRV9NQVAgOiBfZ2wuVEVYVFVSRV8yRDtcblx0XHRcdFx0Y29uc3Qgd2ViZ2xUZXh0dXJlID0gcHJvcGVydGllcy5nZXQodGV4dHVyZSkuX193ZWJnbFRleHR1cmU7XG5cdFx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKHRhcmdldCwgd2ViZ2xUZXh0dXJlKTtcblx0XHRcdFx0Z2VuZXJhdGVNaXBtYXAodGFyZ2V0KTtcblx0XHRcdFx0c3RhdGUudW5iaW5kVGV4dHVyZSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVNdWx0aXNhbXBsZVJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQpIHtcblx0XHRpZiAoaXNXZWJHTDIgJiYgcmVuZGVyVGFyZ2V0LnNhbXBsZXMgPiAwICYmIHVzZU11bHRpc2FtcGxlZFJUVChyZW5kZXJUYXJnZXQpID09PSBmYWxzZSkge1xuXHRcdFx0Y29uc3QgdGV4dHVyZXMgPSByZW5kZXJUYXJnZXQuaXNXZWJHTE11bHRpcGxlUmVuZGVyVGFyZ2V0cyA/IHJlbmRlclRhcmdldC50ZXh0dXJlIDogW3JlbmRlclRhcmdldC50ZXh0dXJlXTtcblx0XHRcdGNvbnN0IHdpZHRoID0gcmVuZGVyVGFyZ2V0LndpZHRoO1xuXHRcdFx0Y29uc3QgaGVpZ2h0ID0gcmVuZGVyVGFyZ2V0LmhlaWdodDtcblx0XHRcdGxldCBtYXNrID0gX2dsLkNPTE9SX0JVRkZFUl9CSVQ7XG5cdFx0XHRjb25zdCBpbnZhbGlkYXRpb25BcnJheSA9IFtdO1xuXHRcdFx0Y29uc3QgZGVwdGhTdHlsZSA9IHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyID8gX2dsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCA6IF9nbC5ERVBUSF9BVFRBQ0hNRU5UO1xuXHRcdFx0Y29uc3QgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KHJlbmRlclRhcmdldCk7XG5cdFx0XHRjb25zdCBpc011bHRpcGxlUmVuZGVyVGFyZ2V0cyA9IHJlbmRlclRhcmdldC5pc1dlYkdMTXVsdGlwbGVSZW5kZXJUYXJnZXRzID09PSB0cnVlO1xuXG5cdFx0XHQvLyBJZiBNUlQgd2UgbmVlZCB0byByZW1vdmUgRkJPIGF0dGFjaG1lbnRzXG5cdFx0XHRpZiAoaXNNdWx0aXBsZVJlbmRlclRhcmdldHMpIHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0dXJlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlcihfZ2wuRlJBTUVCVUZGRVIsIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbE11bHRpc2FtcGxlZEZyYW1lYnVmZmVyKTtcblx0XHRcdFx0XHRfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoX2dsLkZSQU1FQlVGRkVSLCBfZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpLCBfZ2wuUkVOREVSQlVGRkVSLCBudWxsKTtcblx0XHRcdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoX2dsLkZSQU1FQlVGRkVSLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlcik7XG5cdFx0XHRcdFx0X2dsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKF9nbC5EUkFXX0ZSQU1FQlVGRkVSLCBfZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpLCBfZ2wuVEVYVFVSRV8yRCwgbnVsbCwgMCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlcihfZ2wuUkVBRF9GUkFNRUJVRkZFUiwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsTXVsdGlzYW1wbGVkRnJhbWVidWZmZXIpO1xuXHRcdFx0c3RhdGUuYmluZEZyYW1lYnVmZmVyKF9nbC5EUkFXX0ZSQU1FQlVGRkVSLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlcik7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRleHR1cmVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGludmFsaWRhdGlvbkFycmF5LnB1c2goX2dsLkNPTE9SX0FUVEFDSE1FTlQwICsgaSk7XG5cdFx0XHRcdGlmIChyZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIpIHtcblx0XHRcdFx0XHRpbnZhbGlkYXRpb25BcnJheS5wdXNoKGRlcHRoU3R5bGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnN0IGlnbm9yZURlcHRoVmFsdWVzID0gcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX2lnbm9yZURlcHRoVmFsdWVzICE9PSB1bmRlZmluZWQgPyByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9faWdub3JlRGVwdGhWYWx1ZXMgOiBmYWxzZTtcblx0XHRcdFx0aWYgKGlnbm9yZURlcHRoVmFsdWVzID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdGlmIChyZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIpIG1hc2sgfD0gX2dsLkRFUFRIX0JVRkZFUl9CSVQ7XG5cdFx0XHRcdFx0aWYgKHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyKSBtYXNrIHw9IF9nbC5TVEVOQ0lMX0JVRkZFUl9CSVQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGlzTXVsdGlwbGVSZW5kZXJUYXJnZXRzKSB7XG5cdFx0XHRcdFx0X2dsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKF9nbC5SRUFEX0ZSQU1FQlVGRkVSLCBfZ2wuQ09MT1JfQVRUQUNITUVOVDAsIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbENvbG9yUmVuZGVyYnVmZmVyW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaWdub3JlRGVwdGhWYWx1ZXMgPT09IHRydWUpIHtcblx0XHRcdFx0XHRfZ2wuaW52YWxpZGF0ZUZyYW1lYnVmZmVyKF9nbC5SRUFEX0ZSQU1FQlVGRkVSLCBbZGVwdGhTdHlsZV0pO1xuXHRcdFx0XHRcdF9nbC5pbnZhbGlkYXRlRnJhbWVidWZmZXIoX2dsLkRSQVdfRlJBTUVCVUZGRVIsIFtkZXB0aFN0eWxlXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGlzTXVsdGlwbGVSZW5kZXJUYXJnZXRzKSB7XG5cdFx0XHRcdFx0Y29uc3Qgd2ViZ2xUZXh0dXJlID0gcHJvcGVydGllcy5nZXQodGV4dHVyZXNbaV0pLl9fd2ViZ2xUZXh0dXJlO1xuXHRcdFx0XHRcdF9nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChfZ2wuRFJBV19GUkFNRUJVRkZFUiwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwLCBfZ2wuVEVYVFVSRV8yRCwgd2ViZ2xUZXh0dXJlLCAwKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRfZ2wuYmxpdEZyYW1lYnVmZmVyKDAsIDAsIHdpZHRoLCBoZWlnaHQsIDAsIDAsIHdpZHRoLCBoZWlnaHQsIG1hc2ssIF9nbC5ORUFSRVNUKTtcblx0XHRcdFx0aWYgKHN1cHBvcnRzSW52YWxpZGF0ZUZyYW1lYnVmZmVyKSB7XG5cdFx0XHRcdFx0X2dsLmludmFsaWRhdGVGcmFtZWJ1ZmZlcihfZ2wuUkVBRF9GUkFNRUJVRkZFUiwgaW52YWxpZGF0aW9uQXJyYXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoX2dsLlJFQURfRlJBTUVCVUZGRVIsIG51bGwpO1xuXHRcdFx0c3RhdGUuYmluZEZyYW1lYnVmZmVyKF9nbC5EUkFXX0ZSQU1FQlVGRkVSLCBudWxsKTtcblxuXHRcdFx0Ly8gSWYgTVJUIHNpbmNlIHByZS1ibGl0IHdlIHJlbW92ZWQgdGhlIEZCTyB3ZSBuZWVkIHRvIHJlY29uc3RydWN0IHRoZSBhdHRhY2htZW50c1xuXHRcdFx0aWYgKGlzTXVsdGlwbGVSZW5kZXJUYXJnZXRzKSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dHVyZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoX2dsLkZSQU1FQlVGRkVSLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xNdWx0aXNhbXBsZWRGcmFtZWJ1ZmZlcik7XG5cdFx0XHRcdFx0X2dsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKF9nbC5GUkFNRUJVRkZFUiwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwICsgaSwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsQ29sb3JSZW5kZXJidWZmZXJbaV0pO1xuXHRcdFx0XHRcdGNvbnN0IHdlYmdsVGV4dHVyZSA9IHByb3BlcnRpZXMuZ2V0KHRleHR1cmVzW2ldKS5fX3dlYmdsVGV4dHVyZTtcblx0XHRcdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoX2dsLkZSQU1FQlVGRkVSLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlcik7XG5cdFx0XHRcdFx0X2dsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKF9nbC5EUkFXX0ZSQU1FQlVGRkVSLCBfZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpLCBfZ2wuVEVYVFVSRV8yRCwgd2ViZ2xUZXh0dXJlLCAwKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0c3RhdGUuYmluZEZyYW1lYnVmZmVyKF9nbC5EUkFXX0ZSQU1FQlVGRkVSLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xNdWx0aXNhbXBsZWRGcmFtZWJ1ZmZlcik7XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIGdldFJlbmRlclRhcmdldFNhbXBsZXMocmVuZGVyVGFyZ2V0KSB7XG5cdFx0cmV0dXJuIE1hdGgubWluKG1heFNhbXBsZXMsIHJlbmRlclRhcmdldC5zYW1wbGVzKTtcblx0fVxuXHRmdW5jdGlvbiB1c2VNdWx0aXNhbXBsZWRSVFQocmVuZGVyVGFyZ2V0KSB7XG5cdFx0Y29uc3QgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KHJlbmRlclRhcmdldCk7XG5cdFx0cmV0dXJuIGlzV2ViR0wyICYmIHJlbmRlclRhcmdldC5zYW1wbGVzID4gMCAmJiBleHRlbnNpb25zLmhhcygnV0VCR0xfbXVsdGlzYW1wbGVkX3JlbmRlcl90b190ZXh0dXJlJykgPT09IHRydWUgJiYgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3VzZVJlbmRlclRvVGV4dHVyZSAhPT0gZmFsc2U7XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlVmlkZW9UZXh0dXJlKHRleHR1cmUpIHtcblx0XHRjb25zdCBmcmFtZSA9IGluZm8ucmVuZGVyLmZyYW1lO1xuXG5cdFx0Ly8gQ2hlY2sgdGhlIGxhc3QgZnJhbWUgd2UgdXBkYXRlZCB0aGUgVmlkZW9UZXh0dXJlXG5cblx0XHRpZiAoX3ZpZGVvVGV4dHVyZXMuZ2V0KHRleHR1cmUpICE9PSBmcmFtZSkge1xuXHRcdFx0X3ZpZGVvVGV4dHVyZXMuc2V0KHRleHR1cmUsIGZyYW1lKTtcblx0XHRcdHRleHR1cmUudXBkYXRlKCk7XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHZlcmlmeUNvbG9yU3BhY2UodGV4dHVyZSwgaW1hZ2UpIHtcblx0XHRjb25zdCBlbmNvZGluZyA9IHRleHR1cmUuZW5jb2Rpbmc7XG5cdFx0Y29uc3QgZm9ybWF0ID0gdGV4dHVyZS5mb3JtYXQ7XG5cdFx0Y29uc3QgdHlwZSA9IHRleHR1cmUudHlwZTtcblx0XHRpZiAodGV4dHVyZS5pc0NvbXByZXNzZWRUZXh0dXJlID09PSB0cnVlIHx8IHRleHR1cmUuaXNWaWRlb1RleHR1cmUgPT09IHRydWUgfHwgdGV4dHVyZS5mb3JtYXQgPT09IF9TUkdCQUZvcm1hdCkgcmV0dXJuIGltYWdlO1xuXHRcdGlmIChlbmNvZGluZyAhPT0gTGluZWFyRW5jb2RpbmcpIHtcblx0XHRcdC8vIHNSR0JcblxuXHRcdFx0aWYgKGVuY29kaW5nID09PSBzUkdCRW5jb2RpbmcpIHtcblx0XHRcdFx0aWYgKGlzV2ViR0wyID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdC8vIGluIFdlYkdMIDEsIHRyeSB0byB1c2UgRVhUX3NSR0IgZXh0ZW5zaW9uIGFuZCB1bnNpemVkIGZvcm1hdHNcblxuXHRcdFx0XHRcdGlmIChleHRlbnNpb25zLmhhcygnRVhUX3NSR0InKSA9PT0gdHJ1ZSAmJiBmb3JtYXQgPT09IFJHQkFGb3JtYXQpIHtcblx0XHRcdFx0XHRcdHRleHR1cmUuZm9ybWF0ID0gX1NSR0JBRm9ybWF0O1xuXG5cdFx0XHRcdFx0XHQvLyBpdCdzIG5vdCBwb3NzaWJsZSB0byBnZW5lcmF0ZSBtaXBzIGluIFdlYkdMIDEgd2l0aCB0aGlzIGV4dGVuc2lvblxuXG5cdFx0XHRcdFx0XHR0ZXh0dXJlLm1pbkZpbHRlciA9IExpbmVhckZpbHRlcjtcblx0XHRcdFx0XHRcdHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIHNsb3cgZmFsbGJhY2sgKENQVSBkZWNvZGUpXG5cblx0XHRcdFx0XHRcdGltYWdlID0gSW1hZ2VVdGlscy5zUkdCVG9MaW5lYXIoaW1hZ2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBpbiBXZWJHTCAyIHVuY29tcHJlc3NlZCB0ZXh0dXJlcyBjYW4gb25seSBiZSBzUkdCIGVuY29kZWQgaWYgdGhleSBoYXZlIHRoZSBSR0JBOCBmb3JtYXRcblxuXHRcdFx0XHRcdGlmIChmb3JtYXQgIT09IFJHQkFGb3JtYXQgfHwgdHlwZSAhPT0gVW5zaWduZWRCeXRlVHlwZSkge1xuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFRleHR1cmVzOiBzUkdCIGVuY29kZWQgdGV4dHVyZXMgaGF2ZSB0byB1c2UgUkdCQUZvcm1hdCBhbmQgVW5zaWduZWRCeXRlVHlwZS4nKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLldlYkdMVGV4dHVyZXM6IFVuc3VwcG9ydGVkIHRleHR1cmUgZW5jb2Rpbmc6JywgZW5jb2RpbmcpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gaW1hZ2U7XG5cdH1cblxuXHQvL1xuXG5cdHRoaXMuYWxsb2NhdGVUZXh0dXJlVW5pdCA9IGFsbG9jYXRlVGV4dHVyZVVuaXQ7XG5cdHRoaXMucmVzZXRUZXh0dXJlVW5pdHMgPSByZXNldFRleHR1cmVVbml0cztcblx0dGhpcy5zZXRUZXh0dXJlMkQgPSBzZXRUZXh0dXJlMkQ7XG5cdHRoaXMuc2V0VGV4dHVyZTJEQXJyYXkgPSBzZXRUZXh0dXJlMkRBcnJheTtcblx0dGhpcy5zZXRUZXh0dXJlM0QgPSBzZXRUZXh0dXJlM0Q7XG5cdHRoaXMuc2V0VGV4dHVyZUN1YmUgPSBzZXRUZXh0dXJlQ3ViZTtcblx0dGhpcy5yZWJpbmRUZXh0dXJlcyA9IHJlYmluZFRleHR1cmVzO1xuXHR0aGlzLnNldHVwUmVuZGVyVGFyZ2V0ID0gc2V0dXBSZW5kZXJUYXJnZXQ7XG5cdHRoaXMudXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwID0gdXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwO1xuXHR0aGlzLnVwZGF0ZU11bHRpc2FtcGxlUmVuZGVyVGFyZ2V0ID0gdXBkYXRlTXVsdGlzYW1wbGVSZW5kZXJUYXJnZXQ7XG5cdHRoaXMuc2V0dXBEZXB0aFJlbmRlcmJ1ZmZlciA9IHNldHVwRGVwdGhSZW5kZXJidWZmZXI7XG5cdHRoaXMuc2V0dXBGcmFtZUJ1ZmZlclRleHR1cmUgPSBzZXR1cEZyYW1lQnVmZmVyVGV4dHVyZTtcblx0dGhpcy51c2VNdWx0aXNhbXBsZWRSVFQgPSB1c2VNdWx0aXNhbXBsZWRSVFQ7XG59XG5cbmZ1bmN0aW9uIFdlYkdMVXRpbHMoZ2wsIGV4dGVuc2lvbnMsIGNhcGFiaWxpdGllcykge1xuXHRjb25zdCBpc1dlYkdMMiA9IGNhcGFiaWxpdGllcy5pc1dlYkdMMjtcblx0ZnVuY3Rpb24gY29udmVydChwLCBlbmNvZGluZyA9IG51bGwpIHtcblx0XHRsZXQgZXh0ZW5zaW9uO1xuXHRcdGlmIChwID09PSBVbnNpZ25lZEJ5dGVUeXBlKSByZXR1cm4gZ2wuVU5TSUdORURfQllURTtcblx0XHRpZiAocCA9PT0gVW5zaWduZWRTaG9ydDQ0NDRUeXBlKSByZXR1cm4gZ2wuVU5TSUdORURfU0hPUlRfNF80XzRfNDtcblx0XHRpZiAocCA9PT0gVW5zaWduZWRTaG9ydDU1NTFUeXBlKSByZXR1cm4gZ2wuVU5TSUdORURfU0hPUlRfNV81XzVfMTtcblx0XHRpZiAocCA9PT0gQnl0ZVR5cGUpIHJldHVybiBnbC5CWVRFO1xuXHRcdGlmIChwID09PSBTaG9ydFR5cGUpIHJldHVybiBnbC5TSE9SVDtcblx0XHRpZiAocCA9PT0gVW5zaWduZWRTaG9ydFR5cGUpIHJldHVybiBnbC5VTlNJR05FRF9TSE9SVDtcblx0XHRpZiAocCA9PT0gSW50VHlwZSkgcmV0dXJuIGdsLklOVDtcblx0XHRpZiAocCA9PT0gVW5zaWduZWRJbnRUeXBlKSByZXR1cm4gZ2wuVU5TSUdORURfSU5UO1xuXHRcdGlmIChwID09PSBGbG9hdFR5cGUpIHJldHVybiBnbC5GTE9BVDtcblx0XHRpZiAocCA9PT0gSGFsZkZsb2F0VHlwZSkge1xuXHRcdFx0aWYgKGlzV2ViR0wyKSByZXR1cm4gZ2wuSEFMRl9GTE9BVDtcblx0XHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0Jyk7XG5cdFx0XHRpZiAoZXh0ZW5zaW9uICE9PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiBleHRlbnNpb24uSEFMRl9GTE9BVF9PRVM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHAgPT09IEFscGhhRm9ybWF0KSByZXR1cm4gZ2wuQUxQSEE7XG5cdFx0aWYgKHAgPT09IFJHQkFGb3JtYXQpIHJldHVybiBnbC5SR0JBO1xuXHRcdGlmIChwID09PSBMdW1pbmFuY2VGb3JtYXQpIHJldHVybiBnbC5MVU1JTkFOQ0U7XG5cdFx0aWYgKHAgPT09IEx1bWluYW5jZUFscGhhRm9ybWF0KSByZXR1cm4gZ2wuTFVNSU5BTkNFX0FMUEhBO1xuXHRcdGlmIChwID09PSBEZXB0aEZvcm1hdCkgcmV0dXJuIGdsLkRFUFRIX0NPTVBPTkVOVDtcblx0XHRpZiAocCA9PT0gRGVwdGhTdGVuY2lsRm9ybWF0KSByZXR1cm4gZ2wuREVQVEhfU1RFTkNJTDtcblx0XHRpZiAocCA9PT0gUmVkRm9ybWF0KSByZXR1cm4gZ2wuUkVEO1xuXG5cdFx0Ly8gQGRlcHJlY2F0ZWQgc2luY2UgcjEzN1xuXG5cdFx0aWYgKHAgPT09IFJHQkZvcm1hdCkge1xuXHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUSFJFRS5SR0JGb3JtYXQgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLlJHQkFGb3JtYXQgaW5zdGVhZC4gaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9wdWxsLzIzMjI4Jyk7XG5cdFx0XHRyZXR1cm4gZ2wuUkdCQTtcblx0XHR9XG5cblx0XHQvLyBXZWJHTCAxIHNSR0IgZmFsbGJhY2tcblxuXHRcdGlmIChwID09PSBfU1JHQkFGb3JtYXQpIHtcblx0XHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCdFWFRfc1JHQicpO1xuXHRcdFx0aWYgKGV4dGVuc2lvbiAhPT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gZXh0ZW5zaW9uLlNSR0JfQUxQSEFfRVhUO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gV2ViR0wyIGZvcm1hdHMuXG5cblx0XHRpZiAocCA9PT0gUmVkSW50ZWdlckZvcm1hdCkgcmV0dXJuIGdsLlJFRF9JTlRFR0VSO1xuXHRcdGlmIChwID09PSBSR0Zvcm1hdCkgcmV0dXJuIGdsLlJHO1xuXHRcdGlmIChwID09PSBSR0ludGVnZXJGb3JtYXQpIHJldHVybiBnbC5SR19JTlRFR0VSO1xuXHRcdGlmIChwID09PSBSR0JBSW50ZWdlckZvcm1hdCkgcmV0dXJuIGdsLlJHQkFfSU5URUdFUjtcblxuXHRcdC8vIFMzVENcblxuXHRcdGlmIChwID09PSBSR0JfUzNUQ19EWFQxX0Zvcm1hdCB8fCBwID09PSBSR0JBX1MzVENfRFhUMV9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9TM1RDX0RYVDNfRm9ybWF0IHx8IHAgPT09IFJHQkFfUzNUQ19EWFQ1X0Zvcm1hdCkge1xuXHRcdFx0aWYgKGVuY29kaW5nID09PSBzUkdCRW5jb2RpbmcpIHtcblx0XHRcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjX3NyZ2InKTtcblx0XHRcdFx0aWYgKGV4dGVuc2lvbiAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmIChwID09PSBSR0JfUzNUQ19EWFQxX0Zvcm1hdCkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1NSR0JfUzNUQ19EWFQxX0VYVDtcblx0XHRcdFx0XHRpZiAocCA9PT0gUkdCQV9TM1RDX0RYVDFfRm9ybWF0KSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQl9BTFBIQV9TM1RDX0RYVDFfRVhUO1xuXHRcdFx0XHRcdGlmIChwID09PSBSR0JBX1MzVENfRFhUM19Gb3JtYXQpIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCX0FMUEhBX1MzVENfRFhUM19FWFQ7XG5cdFx0XHRcdFx0aWYgKHAgPT09IFJHQkFfUzNUQ19EWFQ1X0Zvcm1hdCkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1NSR0JfQUxQSEFfUzNUQ19EWFQ1X0VYVDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyk7XG5cdFx0XHRcdGlmIChleHRlbnNpb24gIT09IG51bGwpIHtcblx0XHRcdFx0XHRpZiAocCA9PT0gUkdCX1MzVENfRFhUMV9Gb3JtYXQpIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JfUzNUQ19EWFQxX0VYVDtcblx0XHRcdFx0XHRpZiAocCA9PT0gUkdCQV9TM1RDX0RYVDFfRm9ybWF0KSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDFfRVhUO1xuXHRcdFx0XHRcdGlmIChwID09PSBSR0JBX1MzVENfRFhUM19Gb3JtYXQpIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUM19FWFQ7XG5cdFx0XHRcdFx0aWYgKHAgPT09IFJHQkFfUzNUQ19EWFQ1X0Zvcm1hdCkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQ1X0VYVDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFBWUlRDXG5cblx0XHRpZiAocCA9PT0gUkdCX1BWUlRDXzRCUFBWMV9Gb3JtYXQgfHwgcCA9PT0gUkdCX1BWUlRDXzJCUFBWMV9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0IHx8IHAgPT09IFJHQkFfUFZSVENfMkJQUFYxX0Zvcm1hdCkge1xuXHRcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YycpO1xuXHRcdFx0aWYgKGV4dGVuc2lvbiAhPT0gbnVsbCkge1xuXHRcdFx0XHRpZiAocCA9PT0gUkdCX1BWUlRDXzRCUFBWMV9Gb3JtYXQpIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JfUFZSVENfNEJQUFYxX0lNRztcblx0XHRcdFx0aWYgKHAgPT09IFJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0KSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCX1BWUlRDXzJCUFBWMV9JTUc7XG5cdFx0XHRcdGlmIChwID09PSBSR0JBX1BWUlRDXzRCUFBWMV9Gb3JtYXQpIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzRCUFBWMV9JTUc7XG5cdFx0XHRcdGlmIChwID09PSBSR0JBX1BWUlRDXzJCUFBWMV9Gb3JtYXQpIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzJCUFBWMV9JTUc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBFVEMxXG5cblx0XHRpZiAocCA9PT0gUkdCX0VUQzFfRm9ybWF0KSB7XG5cdFx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCgnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YzEnKTtcblx0XHRcdGlmIChleHRlbnNpb24gIT09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQl9FVEMxX1dFQkdMO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRVRDMlxuXG5cdFx0aWYgKHAgPT09IFJHQl9FVEMyX0Zvcm1hdCB8fCBwID09PSBSR0JBX0VUQzJfRUFDX0Zvcm1hdCkge1xuXHRcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9ldGMnKTtcblx0XHRcdGlmIChleHRlbnNpb24gIT09IG51bGwpIHtcblx0XHRcdFx0aWYgKHAgPT09IFJHQl9FVEMyX0Zvcm1hdCkgcmV0dXJuIGVuY29kaW5nID09PSBzUkdCRW5jb2RpbmcgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCOF9FVEMyIDogZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCOF9FVEMyO1xuXHRcdFx0XHRpZiAocCA9PT0gUkdCQV9FVEMyX0VBQ19Gb3JtYXQpIHJldHVybiBlbmNvZGluZyA9PT0gc1JHQkVuY29kaW5nID8gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0VUQzJfRUFDIDogZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQThfRVRDMl9FQUM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBU1RDXG5cblx0XHRpZiAocCA9PT0gUkdCQV9BU1RDXzR4NF9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzV4NF9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzV4NV9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzZ4NV9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzZ4Nl9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzh4NV9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzh4Nl9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzh4OF9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzEweDVfRm9ybWF0IHx8IHAgPT09IFJHQkFfQVNUQ18xMHg2X0Zvcm1hdCB8fCBwID09PSBSR0JBX0FTVENfMTB4OF9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzEweDEwX0Zvcm1hdCB8fCBwID09PSBSR0JBX0FTVENfMTJ4MTBfRm9ybWF0IHx8IHAgPT09IFJHQkFfQVNUQ18xMngxMl9Gb3JtYXQpIHtcblx0XHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfYXN0YycpO1xuXHRcdFx0aWYgKGV4dGVuc2lvbiAhPT0gbnVsbCkge1xuXHRcdFx0XHRpZiAocCA9PT0gUkdCQV9BU1RDXzR4NF9Gb3JtYXQpIHJldHVybiBlbmNvZGluZyA9PT0gc1JHQkVuY29kaW5nID8gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfNHg0X0tIUiA6IGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfQVNUQ180eDRfS0hSO1xuXHRcdFx0XHRpZiAocCA9PT0gUkdCQV9BU1RDXzV4NF9Gb3JtYXQpIHJldHVybiBlbmNvZGluZyA9PT0gc1JHQkVuY29kaW5nID8gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfNXg0X0tIUiA6IGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfQVNUQ181eDRfS0hSO1xuXHRcdFx0XHRpZiAocCA9PT0gUkdCQV9BU1RDXzV4NV9Gb3JtYXQpIHJldHVybiBlbmNvZGluZyA9PT0gc1JHQkVuY29kaW5nID8gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfNXg1X0tIUiA6IGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfQVNUQ181eDVfS0hSO1xuXHRcdFx0XHRpZiAocCA9PT0gUkdCQV9BU1RDXzZ4NV9Gb3JtYXQpIHJldHVybiBlbmNvZGluZyA9PT0gc1JHQkVuY29kaW5nID8gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfNng1X0tIUiA6IGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfQVNUQ182eDVfS0hSO1xuXHRcdFx0XHRpZiAocCA9PT0gUkdCQV9BU1RDXzZ4Nl9Gb3JtYXQpIHJldHVybiBlbmNvZGluZyA9PT0gc1JHQkVuY29kaW5nID8gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfNng2X0tIUiA6IGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfQVNUQ182eDZfS0hSO1xuXHRcdFx0XHRpZiAocCA9PT0gUkdCQV9BU1RDXzh4NV9Gb3JtYXQpIHJldHVybiBlbmNvZGluZyA9PT0gc1JHQkVuY29kaW5nID8gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfOHg1X0tIUiA6IGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfQVNUQ184eDVfS0hSO1xuXHRcdFx0XHRpZiAocCA9PT0gUkdCQV9BU1RDXzh4Nl9Gb3JtYXQpIHJldHVybiBlbmNvZGluZyA9PT0gc1JHQkVuY29kaW5nID8gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfOHg2X0tIUiA6IGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfQVNUQ184eDZfS0hSO1xuXHRcdFx0XHRpZiAocCA9PT0gUkdCQV9BU1RDXzh4OF9Gb3JtYXQpIHJldHVybiBlbmNvZGluZyA9PT0gc1JHQkVuY29kaW5nID8gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfOHg4X0tIUiA6IGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfQVNUQ184eDhfS0hSO1xuXHRcdFx0XHRpZiAocCA9PT0gUkdCQV9BU1RDXzEweDVfRm9ybWF0KSByZXR1cm4gZW5jb2RpbmcgPT09IHNSR0JFbmNvZGluZyA/IGV4dGVuc2lvbi5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzEweDVfS0hSIDogZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9BU1RDXzEweDVfS0hSO1xuXHRcdFx0XHRpZiAocCA9PT0gUkdCQV9BU1RDXzEweDZfRm9ybWF0KSByZXR1cm4gZW5jb2RpbmcgPT09IHNSR0JFbmNvZGluZyA/IGV4dGVuc2lvbi5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzEweDZfS0hSIDogZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9BU1RDXzEweDZfS0hSO1xuXHRcdFx0XHRpZiAocCA9PT0gUkdCQV9BU1RDXzEweDhfRm9ybWF0KSByZXR1cm4gZW5jb2RpbmcgPT09IHNSR0JFbmNvZGluZyA/IGV4dGVuc2lvbi5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzEweDhfS0hSIDogZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9BU1RDXzEweDhfS0hSO1xuXHRcdFx0XHRpZiAocCA9PT0gUkdCQV9BU1RDXzEweDEwX0Zvcm1hdCkgcmV0dXJuIGVuY29kaW5nID09PSBzUkdCRW5jb2RpbmcgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ18xMHgxMF9LSFIgOiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX0FTVENfMTB4MTBfS0hSO1xuXHRcdFx0XHRpZiAocCA9PT0gUkdCQV9BU1RDXzEyeDEwX0Zvcm1hdCkgcmV0dXJuIGVuY29kaW5nID09PSBzUkdCRW5jb2RpbmcgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ18xMngxMF9LSFIgOiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX0FTVENfMTJ4MTBfS0hSO1xuXHRcdFx0XHRpZiAocCA9PT0gUkdCQV9BU1RDXzEyeDEyX0Zvcm1hdCkgcmV0dXJuIGVuY29kaW5nID09PSBzUkdCRW5jb2RpbmcgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ18xMngxMl9LSFIgOiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX0FTVENfMTJ4MTJfS0hSO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQlBUQ1xuXG5cdFx0aWYgKHAgPT09IFJHQkFfQlBUQ19Gb3JtYXQpIHtcblx0XHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCdFWFRfdGV4dHVyZV9jb21wcmVzc2lvbl9icHRjJyk7XG5cdFx0XHRpZiAoZXh0ZW5zaW9uICE9PSBudWxsKSB7XG5cdFx0XHRcdGlmIChwID09PSBSR0JBX0JQVENfRm9ybWF0KSByZXR1cm4gZW5jb2RpbmcgPT09IHNSR0JFbmNvZGluZyA/IGV4dGVuc2lvbi5DT01QUkVTU0VEX1NSR0JfQUxQSEFfQlBUQ19VTk9STV9FWFQgOiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX0JQVENfVU5PUk1fRVhUO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdGlmIChwID09PSBVbnNpZ25lZEludDI0OFR5cGUpIHtcblx0XHRcdGlmIChpc1dlYkdMMikgcmV0dXJuIGdsLlVOU0lHTkVEX0lOVF8yNF84O1xuXHRcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoJ1dFQkdMX2RlcHRoX3RleHR1cmUnKTtcblx0XHRcdGlmIChleHRlbnNpb24gIT09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIGV4dGVuc2lvbi5VTlNJR05FRF9JTlRfMjRfOF9XRUJHTDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGlmIFwicFwiIGNhbid0IGJlIHJlc29sdmVkLCBhc3N1bWUgdGhlIHVzZXIgZGVmaW5lcyBhIFdlYkdMIGNvbnN0YW50IGFzIGEgc3RyaW5nIChmYWxsYmFjay93b3JrYXJvdW5kIGZvciBwYWNrZWQgUkdCIGZvcm1hdHMpXG5cblx0XHRyZXR1cm4gZ2xbcF0gIT09IHVuZGVmaW5lZCA/IGdsW3BdIDogbnVsbDtcblx0fVxuXHRyZXR1cm4ge1xuXHRcdGNvbnZlcnQ6IGNvbnZlcnRcblx0fTtcbn1cblxuY2xhc3MgQXJyYXlDYW1lcmEgZXh0ZW5kcyBQZXJzcGVjdGl2ZUNhbWVyYSB7XG5cdGNvbnN0cnVjdG9yKGFycmF5ID0gW10pIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuaXNBcnJheUNhbWVyYSA9IHRydWU7XG5cdFx0dGhpcy5jYW1lcmFzID0gYXJyYXk7XG5cdH1cbn1cblxuY2xhc3MgR3JvdXAgZXh0ZW5kcyBPYmplY3QzRCB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5pc0dyb3VwID0gdHJ1ZTtcblx0XHR0aGlzLnR5cGUgPSAnR3JvdXAnO1xuXHR9XG59XG5cbmNvbnN0IF9tb3ZlRXZlbnQgPSB7XG5cdHR5cGU6ICdtb3ZlJ1xufTtcbmNsYXNzIFdlYlhSQ29udHJvbGxlciB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHRoaXMuX3RhcmdldFJheSA9IG51bGw7XG5cdFx0dGhpcy5fZ3JpcCA9IG51bGw7XG5cdFx0dGhpcy5faGFuZCA9IG51bGw7XG5cdH1cblx0Z2V0SGFuZFNwYWNlKCkge1xuXHRcdGlmICh0aGlzLl9oYW5kID09PSBudWxsKSB7XG5cdFx0XHR0aGlzLl9oYW5kID0gbmV3IEdyb3VwKCk7XG5cdFx0XHR0aGlzLl9oYW5kLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblx0XHRcdHRoaXMuX2hhbmQudmlzaWJsZSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5faGFuZC5qb2ludHMgPSB7fTtcblx0XHRcdHRoaXMuX2hhbmQuaW5wdXRTdGF0ZSA9IHtcblx0XHRcdFx0cGluY2hpbmc6IGZhbHNlXG5cdFx0XHR9O1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5faGFuZDtcblx0fVxuXHRnZXRUYXJnZXRSYXlTcGFjZSgpIHtcblx0XHRpZiAodGhpcy5fdGFyZ2V0UmF5ID09PSBudWxsKSB7XG5cdFx0XHR0aGlzLl90YXJnZXRSYXkgPSBuZXcgR3JvdXAoKTtcblx0XHRcdHRoaXMuX3RhcmdldFJheS5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cdFx0XHR0aGlzLl90YXJnZXRSYXkudmlzaWJsZSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fdGFyZ2V0UmF5Lmhhc0xpbmVhclZlbG9jaXR5ID0gZmFsc2U7XG5cdFx0XHR0aGlzLl90YXJnZXRSYXkubGluZWFyVmVsb2NpdHkgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0dGhpcy5fdGFyZ2V0UmF5Lmhhc0FuZ3VsYXJWZWxvY2l0eSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fdGFyZ2V0UmF5LmFuZ3VsYXJWZWxvY2l0eSA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl90YXJnZXRSYXk7XG5cdH1cblx0Z2V0R3JpcFNwYWNlKCkge1xuXHRcdGlmICh0aGlzLl9ncmlwID09PSBudWxsKSB7XG5cdFx0XHR0aGlzLl9ncmlwID0gbmV3IEdyb3VwKCk7XG5cdFx0XHR0aGlzLl9ncmlwLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblx0XHRcdHRoaXMuX2dyaXAudmlzaWJsZSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fZ3JpcC5oYXNMaW5lYXJWZWxvY2l0eSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fZ3JpcC5saW5lYXJWZWxvY2l0eSA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHR0aGlzLl9ncmlwLmhhc0FuZ3VsYXJWZWxvY2l0eSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fZ3JpcC5hbmd1bGFyVmVsb2NpdHkgPSBuZXcgVmVjdG9yMygpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fZ3JpcDtcblx0fVxuXHRkaXNwYXRjaEV2ZW50KGV2ZW50KSB7XG5cdFx0aWYgKHRoaXMuX3RhcmdldFJheSAhPT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fdGFyZ2V0UmF5LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHRcdH1cblx0XHRpZiAodGhpcy5fZ3JpcCAhPT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fZ3JpcC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0XHR9XG5cdFx0aWYgKHRoaXMuX2hhbmQgIT09IG51bGwpIHtcblx0XHRcdHRoaXMuX2hhbmQuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGRpc2Nvbm5lY3QoaW5wdXRTb3VyY2UpIHtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoe1xuXHRcdFx0dHlwZTogJ2Rpc2Nvbm5lY3RlZCcsXG5cdFx0XHRkYXRhOiBpbnB1dFNvdXJjZVxuXHRcdH0pO1xuXHRcdGlmICh0aGlzLl90YXJnZXRSYXkgIT09IG51bGwpIHtcblx0XHRcdHRoaXMuX3RhcmdldFJheS52aXNpYmxlID0gZmFsc2U7XG5cdFx0fVxuXHRcdGlmICh0aGlzLl9ncmlwICE9PSBudWxsKSB7XG5cdFx0XHR0aGlzLl9ncmlwLnZpc2libGUgPSBmYWxzZTtcblx0XHR9XG5cdFx0aWYgKHRoaXMuX2hhbmQgIT09IG51bGwpIHtcblx0XHRcdHRoaXMuX2hhbmQudmlzaWJsZSA9IGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHR1cGRhdGUoaW5wdXRTb3VyY2UsIGZyYW1lLCByZWZlcmVuY2VTcGFjZSkge1xuXHRcdGxldCBpbnB1dFBvc2UgPSBudWxsO1xuXHRcdGxldCBncmlwUG9zZSA9IG51bGw7XG5cdFx0bGV0IGhhbmRQb3NlID0gbnVsbDtcblx0XHRjb25zdCB0YXJnZXRSYXkgPSB0aGlzLl90YXJnZXRSYXk7XG5cdFx0Y29uc3QgZ3JpcCA9IHRoaXMuX2dyaXA7XG5cdFx0Y29uc3QgaGFuZCA9IHRoaXMuX2hhbmQ7XG5cdFx0aWYgKGlucHV0U291cmNlICYmIGZyYW1lLnNlc3Npb24udmlzaWJpbGl0eVN0YXRlICE9PSAndmlzaWJsZS1ibHVycmVkJykge1xuXHRcdFx0aWYgKGhhbmQgJiYgaW5wdXRTb3VyY2UuaGFuZCkge1xuXHRcdFx0XHRoYW5kUG9zZSA9IHRydWU7XG5cdFx0XHRcdGZvciAoY29uc3QgaW5wdXRqb2ludCBvZiBpbnB1dFNvdXJjZS5oYW5kLnZhbHVlcygpKSB7XG5cdFx0XHRcdFx0Ly8gVXBkYXRlIHRoZSBqb2ludHMgZ3JvdXBzIHdpdGggdGhlIFhSSm9pbnQgcG9zZXNcblx0XHRcdFx0XHRjb25zdCBqb2ludFBvc2UgPSBmcmFtZS5nZXRKb2ludFBvc2UoaW5wdXRqb2ludCwgcmVmZXJlbmNlU3BhY2UpO1xuXHRcdFx0XHRcdGlmIChoYW5kLmpvaW50c1tpbnB1dGpvaW50LmpvaW50TmFtZV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0Ly8gVGhlIHRyYW5zZm9ybSBvZiB0aGlzIGpvaW50IHdpbGwgYmUgdXBkYXRlZCB3aXRoIHRoZSBqb2ludCBwb3NlIG9uIGVhY2ggZnJhbWVcblx0XHRcdFx0XHRcdGNvbnN0IGpvaW50ID0gbmV3IEdyb3VwKCk7XG5cdFx0XHRcdFx0XHRqb2ludC5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRqb2ludC52aXNpYmxlID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRoYW5kLmpvaW50c1tpbnB1dGpvaW50LmpvaW50TmFtZV0gPSBqb2ludDtcblx0XHRcdFx0XHRcdC8vID8/XG5cdFx0XHRcdFx0XHRoYW5kLmFkZChqb2ludCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvbnN0IGpvaW50ID0gaGFuZC5qb2ludHNbaW5wdXRqb2ludC5qb2ludE5hbWVdO1xuXHRcdFx0XHRcdGlmIChqb2ludFBvc2UgIT09IG51bGwpIHtcblx0XHRcdFx0XHRcdGpvaW50Lm1hdHJpeC5mcm9tQXJyYXkoam9pbnRQb3NlLnRyYW5zZm9ybS5tYXRyaXgpO1xuXHRcdFx0XHRcdFx0am9pbnQubWF0cml4LmRlY29tcG9zZShqb2ludC5wb3NpdGlvbiwgam9pbnQucm90YXRpb24sIGpvaW50LnNjYWxlKTtcblx0XHRcdFx0XHRcdGpvaW50LmpvaW50UmFkaXVzID0gam9pbnRQb3NlLnJhZGl1cztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0am9pbnQudmlzaWJsZSA9IGpvaW50UG9zZSAhPT0gbnVsbDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEN1c3RvbSBldmVudHNcblxuXHRcdFx0XHQvLyBDaGVjayBwaW5jaHpcblx0XHRcdFx0Y29uc3QgaW5kZXhUaXAgPSBoYW5kLmpvaW50c1snaW5kZXgtZmluZ2VyLXRpcCddO1xuXHRcdFx0XHRjb25zdCB0aHVtYlRpcCA9IGhhbmQuam9pbnRzWyd0aHVtYi10aXAnXTtcblx0XHRcdFx0Y29uc3QgZGlzdGFuY2UgPSBpbmRleFRpcC5wb3NpdGlvbi5kaXN0YW5jZVRvKHRodW1iVGlwLnBvc2l0aW9uKTtcblx0XHRcdFx0Y29uc3QgZGlzdGFuY2VUb1BpbmNoID0gMC4wMjtcblx0XHRcdFx0Y29uc3QgdGhyZXNob2xkID0gMC4wMDU7XG5cdFx0XHRcdGlmIChoYW5kLmlucHV0U3RhdGUucGluY2hpbmcgJiYgZGlzdGFuY2UgPiBkaXN0YW5jZVRvUGluY2ggKyB0aHJlc2hvbGQpIHtcblx0XHRcdFx0XHRoYW5kLmlucHV0U3RhdGUucGluY2hpbmcgPSBmYWxzZTtcblx0XHRcdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoe1xuXHRcdFx0XHRcdFx0dHlwZTogJ3BpbmNoZW5kJyxcblx0XHRcdFx0XHRcdGhhbmRlZG5lc3M6IGlucHV0U291cmNlLmhhbmRlZG5lc3MsXG5cdFx0XHRcdFx0XHR0YXJnZXQ6IHRoaXNcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSBlbHNlIGlmICghaGFuZC5pbnB1dFN0YXRlLnBpbmNoaW5nICYmIGRpc3RhbmNlIDw9IGRpc3RhbmNlVG9QaW5jaCAtIHRocmVzaG9sZCkge1xuXHRcdFx0XHRcdGhhbmQuaW5wdXRTdGF0ZS5waW5jaGluZyA9IHRydWU7XG5cdFx0XHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KHtcblx0XHRcdFx0XHRcdHR5cGU6ICdwaW5jaHN0YXJ0Jyxcblx0XHRcdFx0XHRcdGhhbmRlZG5lc3M6IGlucHV0U291cmNlLmhhbmRlZG5lc3MsXG5cdFx0XHRcdFx0XHR0YXJnZXQ6IHRoaXNcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKGdyaXAgIT09IG51bGwgJiYgaW5wdXRTb3VyY2UuZ3JpcFNwYWNlKSB7XG5cdFx0XHRcdFx0Z3JpcFBvc2UgPSBmcmFtZS5nZXRQb3NlKGlucHV0U291cmNlLmdyaXBTcGFjZSwgcmVmZXJlbmNlU3BhY2UpO1xuXHRcdFx0XHRcdGlmIChncmlwUG9zZSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0Z3JpcC5tYXRyaXguZnJvbUFycmF5KGdyaXBQb3NlLnRyYW5zZm9ybS5tYXRyaXgpO1xuXHRcdFx0XHRcdFx0Z3JpcC5tYXRyaXguZGVjb21wb3NlKGdyaXAucG9zaXRpb24sIGdyaXAucm90YXRpb24sIGdyaXAuc2NhbGUpO1xuXHRcdFx0XHRcdFx0aWYgKGdyaXBQb3NlLmxpbmVhclZlbG9jaXR5KSB7XG5cdFx0XHRcdFx0XHRcdGdyaXAuaGFzTGluZWFyVmVsb2NpdHkgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRncmlwLmxpbmVhclZlbG9jaXR5LmNvcHkoZ3JpcFBvc2UubGluZWFyVmVsb2NpdHkpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Z3JpcC5oYXNMaW5lYXJWZWxvY2l0eSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKGdyaXBQb3NlLmFuZ3VsYXJWZWxvY2l0eSkge1xuXHRcdFx0XHRcdFx0XHRncmlwLmhhc0FuZ3VsYXJWZWxvY2l0eSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGdyaXAuYW5ndWxhclZlbG9jaXR5LmNvcHkoZ3JpcFBvc2UuYW5ndWxhclZlbG9jaXR5KTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGdyaXAuaGFzQW5ndWxhclZlbG9jaXR5ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAodGFyZ2V0UmF5ICE9PSBudWxsKSB7XG5cdFx0XHRcdGlucHV0UG9zZSA9IGZyYW1lLmdldFBvc2UoaW5wdXRTb3VyY2UudGFyZ2V0UmF5U3BhY2UsIHJlZmVyZW5jZVNwYWNlKTtcblxuXHRcdFx0XHQvLyBTb21lIHJ1bnRpbWVzIChuYW1lbHkgVml2ZSBDb3Ntb3Mgd2l0aCBWaXZlIE9wZW5YUiBSdW50aW1lKSBoYXZlIG9ubHkgZ3JpcCBzcGFjZSBhbmQgcmF5IHNwYWNlIGlzIGVxdWFsIHRvIGl0XG5cdFx0XHRcdGlmIChpbnB1dFBvc2UgPT09IG51bGwgJiYgZ3JpcFBvc2UgIT09IG51bGwpIHtcblx0XHRcdFx0XHRpbnB1dFBvc2UgPSBncmlwUG9zZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaW5wdXRQb3NlICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0dGFyZ2V0UmF5Lm1hdHJpeC5mcm9tQXJyYXkoaW5wdXRQb3NlLnRyYW5zZm9ybS5tYXRyaXgpO1xuXHRcdFx0XHRcdHRhcmdldFJheS5tYXRyaXguZGVjb21wb3NlKHRhcmdldFJheS5wb3NpdGlvbiwgdGFyZ2V0UmF5LnJvdGF0aW9uLCB0YXJnZXRSYXkuc2NhbGUpO1xuXHRcdFx0XHRcdGlmIChpbnB1dFBvc2UubGluZWFyVmVsb2NpdHkpIHtcblx0XHRcdFx0XHRcdHRhcmdldFJheS5oYXNMaW5lYXJWZWxvY2l0eSA9IHRydWU7XG5cdFx0XHRcdFx0XHR0YXJnZXRSYXkubGluZWFyVmVsb2NpdHkuY29weShpbnB1dFBvc2UubGluZWFyVmVsb2NpdHkpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRSYXkuaGFzTGluZWFyVmVsb2NpdHkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGlucHV0UG9zZS5hbmd1bGFyVmVsb2NpdHkpIHtcblx0XHRcdFx0XHRcdHRhcmdldFJheS5oYXNBbmd1bGFyVmVsb2NpdHkgPSB0cnVlO1xuXHRcdFx0XHRcdFx0dGFyZ2V0UmF5LmFuZ3VsYXJWZWxvY2l0eS5jb3B5KGlucHV0UG9zZS5hbmd1bGFyVmVsb2NpdHkpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRSYXkuaGFzQW5ndWxhclZlbG9jaXR5ID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuZGlzcGF0Y2hFdmVudChfbW92ZUV2ZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAodGFyZ2V0UmF5ICE9PSBudWxsKSB7XG5cdFx0XHR0YXJnZXRSYXkudmlzaWJsZSA9IGlucHV0UG9zZSAhPT0gbnVsbDtcblx0XHR9XG5cdFx0aWYgKGdyaXAgIT09IG51bGwpIHtcblx0XHRcdGdyaXAudmlzaWJsZSA9IGdyaXBQb3NlICE9PSBudWxsO1xuXHRcdH1cblx0XHRpZiAoaGFuZCAhPT0gbnVsbCkge1xuXHRcdFx0aGFuZC52aXNpYmxlID0gaGFuZFBvc2UgIT09IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59XG5cbmNsYXNzIERlcHRoVGV4dHVyZSBleHRlbmRzIFRleHR1cmUge1xuXHRjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0LCB0eXBlLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBhbmlzb3Ryb3B5LCBmb3JtYXQpIHtcblx0XHRmb3JtYXQgPSBmb3JtYXQgIT09IHVuZGVmaW5lZCA/IGZvcm1hdCA6IERlcHRoRm9ybWF0O1xuXHRcdGlmIChmb3JtYXQgIT09IERlcHRoRm9ybWF0ICYmIGZvcm1hdCAhPT0gRGVwdGhTdGVuY2lsRm9ybWF0KSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0RlcHRoVGV4dHVyZSBmb3JtYXQgbXVzdCBiZSBlaXRoZXIgVEhSRUUuRGVwdGhGb3JtYXQgb3IgVEhSRUUuRGVwdGhTdGVuY2lsRm9ybWF0Jyk7XG5cdFx0fVxuXHRcdGlmICh0eXBlID09PSB1bmRlZmluZWQgJiYgZm9ybWF0ID09PSBEZXB0aEZvcm1hdCkgdHlwZSA9IFVuc2lnbmVkSW50VHlwZTtcblx0XHRpZiAodHlwZSA9PT0gdW5kZWZpbmVkICYmIGZvcm1hdCA9PT0gRGVwdGhTdGVuY2lsRm9ybWF0KSB0eXBlID0gVW5zaWduZWRJbnQyNDhUeXBlO1xuXHRcdHN1cGVyKG51bGwsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSk7XG5cdFx0dGhpcy5pc0RlcHRoVGV4dHVyZSA9IHRydWU7XG5cdFx0dGhpcy5pbWFnZSA9IHtcblx0XHRcdHdpZHRoOiB3aWR0aCxcblx0XHRcdGhlaWdodDogaGVpZ2h0XG5cdFx0fTtcblx0XHR0aGlzLm1hZ0ZpbHRlciA9IG1hZ0ZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWFnRmlsdGVyIDogTmVhcmVzdEZpbHRlcjtcblx0XHR0aGlzLm1pbkZpbHRlciA9IG1pbkZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWluRmlsdGVyIDogTmVhcmVzdEZpbHRlcjtcblx0XHR0aGlzLmZsaXBZID0gZmFsc2U7XG5cdFx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblx0fVxufVxuXG5jbGFzcyBXZWJYUk1hbmFnZXIgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXIge1xuXHRjb25zdHJ1Y3RvcihyZW5kZXJlciwgZ2wpIHtcblx0XHRzdXBlcigpO1xuXHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblx0XHRsZXQgc2Vzc2lvbiA9IG51bGw7XG5cdFx0bGV0IGZyYW1lYnVmZmVyU2NhbGVGYWN0b3IgPSAxLjA7XG5cdFx0bGV0IHJlZmVyZW5jZVNwYWNlID0gbnVsbDtcblx0XHRsZXQgcmVmZXJlbmNlU3BhY2VUeXBlID0gJ2xvY2FsLWZsb29yJztcblx0XHRsZXQgY3VzdG9tUmVmZXJlbmNlU3BhY2UgPSBudWxsO1xuXHRcdGxldCBwb3NlID0gbnVsbDtcblx0XHRsZXQgZ2xCaW5kaW5nID0gbnVsbDtcblx0XHRsZXQgZ2xQcm9qTGF5ZXIgPSBudWxsO1xuXHRcdGxldCBnbEJhc2VMYXllciA9IG51bGw7XG5cdFx0bGV0IHhyRnJhbWUgPSBudWxsO1xuXHRcdGNvbnN0IGF0dHJpYnV0ZXMgPSBnbC5nZXRDb250ZXh0QXR0cmlidXRlcygpO1xuXHRcdGxldCBpbml0aWFsUmVuZGVyVGFyZ2V0ID0gbnVsbDtcblx0XHRsZXQgbmV3UmVuZGVyVGFyZ2V0ID0gbnVsbDtcblx0XHRjb25zdCBjb250cm9sbGVycyA9IFtdO1xuXHRcdGNvbnN0IGNvbnRyb2xsZXJJbnB1dFNvdXJjZXMgPSBbXTtcblxuXHRcdC8vXG5cblx0XHRjb25zdCBjYW1lcmFMID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCk7XG5cdFx0Y2FtZXJhTC5sYXllcnMuZW5hYmxlKDEpO1xuXHRcdGNhbWVyYUwudmlld3BvcnQgPSBuZXcgVmVjdG9yNCgpO1xuXHRcdGNvbnN0IGNhbWVyYVIgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoKTtcblx0XHRjYW1lcmFSLmxheWVycy5lbmFibGUoMik7XG5cdFx0Y2FtZXJhUi52aWV3cG9ydCA9IG5ldyBWZWN0b3I0KCk7XG5cdFx0Y29uc3QgY2FtZXJhcyA9IFtjYW1lcmFMLCBjYW1lcmFSXTtcblx0XHRjb25zdCBjYW1lcmFWUiA9IG5ldyBBcnJheUNhbWVyYSgpO1xuXHRcdGNhbWVyYVZSLmxheWVycy5lbmFibGUoMSk7XG5cdFx0Y2FtZXJhVlIubGF5ZXJzLmVuYWJsZSgyKTtcblx0XHRsZXQgX2N1cnJlbnREZXB0aE5lYXIgPSBudWxsO1xuXHRcdGxldCBfY3VycmVudERlcHRoRmFyID0gbnVsbDtcblxuXHRcdC8vXG5cblx0XHR0aGlzLmNhbWVyYUF1dG9VcGRhdGUgPSB0cnVlO1xuXHRcdHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuXHRcdHRoaXMuaXNQcmVzZW50aW5nID0gZmFsc2U7XG5cdFx0dGhpcy5nZXRDb250cm9sbGVyID0gZnVuY3Rpb24gKGluZGV4KSB7XG5cdFx0XHRsZXQgY29udHJvbGxlciA9IGNvbnRyb2xsZXJzW2luZGV4XTtcblx0XHRcdGlmIChjb250cm9sbGVyID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y29udHJvbGxlciA9IG5ldyBXZWJYUkNvbnRyb2xsZXIoKTtcblx0XHRcdFx0Y29udHJvbGxlcnNbaW5kZXhdID0gY29udHJvbGxlcjtcblx0XHRcdH1cblx0XHRcdHJldHVybiBjb250cm9sbGVyLmdldFRhcmdldFJheVNwYWNlKCk7XG5cdFx0fTtcblx0XHR0aGlzLmdldENvbnRyb2xsZXJHcmlwID0gZnVuY3Rpb24gKGluZGV4KSB7XG5cdFx0XHRsZXQgY29udHJvbGxlciA9IGNvbnRyb2xsZXJzW2luZGV4XTtcblx0XHRcdGlmIChjb250cm9sbGVyID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y29udHJvbGxlciA9IG5ldyBXZWJYUkNvbnRyb2xsZXIoKTtcblx0XHRcdFx0Y29udHJvbGxlcnNbaW5kZXhdID0gY29udHJvbGxlcjtcblx0XHRcdH1cblx0XHRcdHJldHVybiBjb250cm9sbGVyLmdldEdyaXBTcGFjZSgpO1xuXHRcdH07XG5cdFx0dGhpcy5nZXRIYW5kID0gZnVuY3Rpb24gKGluZGV4KSB7XG5cdFx0XHRsZXQgY29udHJvbGxlciA9IGNvbnRyb2xsZXJzW2luZGV4XTtcblx0XHRcdGlmIChjb250cm9sbGVyID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y29udHJvbGxlciA9IG5ldyBXZWJYUkNvbnRyb2xsZXIoKTtcblx0XHRcdFx0Y29udHJvbGxlcnNbaW5kZXhdID0gY29udHJvbGxlcjtcblx0XHRcdH1cblx0XHRcdHJldHVybiBjb250cm9sbGVyLmdldEhhbmRTcGFjZSgpO1xuXHRcdH07XG5cblx0XHQvL1xuXG5cdFx0ZnVuY3Rpb24gb25TZXNzaW9uRXZlbnQoZXZlbnQpIHtcblx0XHRcdGNvbnN0IGNvbnRyb2xsZXJJbmRleCA9IGNvbnRyb2xsZXJJbnB1dFNvdXJjZXMuaW5kZXhPZihldmVudC5pbnB1dFNvdXJjZSk7XG5cdFx0XHRpZiAoY29udHJvbGxlckluZGV4ID09PSAtMSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRjb25zdCBjb250cm9sbGVyID0gY29udHJvbGxlcnNbY29udHJvbGxlckluZGV4XTtcblx0XHRcdGlmIChjb250cm9sbGVyICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y29udHJvbGxlci5kaXNwYXRjaEV2ZW50KHtcblx0XHRcdFx0XHR0eXBlOiBldmVudC50eXBlLFxuXHRcdFx0XHRcdGRhdGE6IGV2ZW50LmlucHV0U291cmNlXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRmdW5jdGlvbiBvblNlc3Npb25FbmQoKSB7XG5cdFx0XHRzZXNzaW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlbGVjdCcsIG9uU2Vzc2lvbkV2ZW50KTtcblx0XHRcdHNlc3Npb24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2VsZWN0c3RhcnQnLCBvblNlc3Npb25FdmVudCk7XG5cdFx0XHRzZXNzaW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlbGVjdGVuZCcsIG9uU2Vzc2lvbkV2ZW50KTtcblx0XHRcdHNlc3Npb24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3F1ZWV6ZScsIG9uU2Vzc2lvbkV2ZW50KTtcblx0XHRcdHNlc3Npb24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3F1ZWV6ZXN0YXJ0Jywgb25TZXNzaW9uRXZlbnQpO1xuXHRcdFx0c2Vzc2lvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdzcXVlZXplZW5kJywgb25TZXNzaW9uRXZlbnQpO1xuXHRcdFx0c2Vzc2lvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmQnLCBvblNlc3Npb25FbmQpO1xuXHRcdFx0c2Vzc2lvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dHNvdXJjZXNjaGFuZ2UnLCBvbklucHV0U291cmNlc0NoYW5nZSk7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRyb2xsZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGlucHV0U291cmNlID0gY29udHJvbGxlcklucHV0U291cmNlc1tpXTtcblx0XHRcdFx0aWYgKGlucHV0U291cmNlID09PSBudWxsKSBjb250aW51ZTtcblx0XHRcdFx0Y29udHJvbGxlcklucHV0U291cmNlc1tpXSA9IG51bGw7XG5cdFx0XHRcdGNvbnRyb2xsZXJzW2ldLmRpc2Nvbm5lY3QoaW5wdXRTb3VyY2UpO1xuXHRcdFx0fVxuXHRcdFx0X2N1cnJlbnREZXB0aE5lYXIgPSBudWxsO1xuXHRcdFx0X2N1cnJlbnREZXB0aEZhciA9IG51bGw7XG5cblx0XHRcdC8vIHJlc3RvcmUgZnJhbWVidWZmZXIvcmVuZGVyaW5nIHN0YXRlXG5cblx0XHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldChpbml0aWFsUmVuZGVyVGFyZ2V0KTtcblx0XHRcdGdsQmFzZUxheWVyID0gbnVsbDtcblx0XHRcdGdsUHJvakxheWVyID0gbnVsbDtcblx0XHRcdGdsQmluZGluZyA9IG51bGw7XG5cdFx0XHRzZXNzaW9uID0gbnVsbDtcblx0XHRcdG5ld1JlbmRlclRhcmdldCA9IG51bGw7XG5cblx0XHRcdC8vXG5cblx0XHRcdGFuaW1hdGlvbi5zdG9wKCk7XG5cdFx0XHRzY29wZS5pc1ByZXNlbnRpbmcgPSBmYWxzZTtcblx0XHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoe1xuXHRcdFx0XHR0eXBlOiAnc2Vzc2lvbmVuZCdcblx0XHRcdH0pO1xuXHRcdH1cblx0XHR0aGlzLnNldEZyYW1lYnVmZmVyU2NhbGVGYWN0b3IgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdGZyYW1lYnVmZmVyU2NhbGVGYWN0b3IgPSB2YWx1ZTtcblx0XHRcdGlmIChzY29wZS5pc1ByZXNlbnRpbmcgPT09IHRydWUpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJYUk1hbmFnZXI6IENhbm5vdCBjaGFuZ2UgZnJhbWVidWZmZXIgc2NhbGUgd2hpbGUgcHJlc2VudGluZy4nKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHRoaXMuc2V0UmVmZXJlbmNlU3BhY2VUeXBlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRyZWZlcmVuY2VTcGFjZVR5cGUgPSB2YWx1ZTtcblx0XHRcdGlmIChzY29wZS5pc1ByZXNlbnRpbmcgPT09IHRydWUpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJYUk1hbmFnZXI6IENhbm5vdCBjaGFuZ2UgcmVmZXJlbmNlIHNwYWNlIHR5cGUgd2hpbGUgcHJlc2VudGluZy4nKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHRoaXMuZ2V0UmVmZXJlbmNlU3BhY2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gY3VzdG9tUmVmZXJlbmNlU3BhY2UgfHwgcmVmZXJlbmNlU3BhY2U7XG5cdFx0fTtcblx0XHR0aGlzLnNldFJlZmVyZW5jZVNwYWNlID0gZnVuY3Rpb24gKHNwYWNlKSB7XG5cdFx0XHRjdXN0b21SZWZlcmVuY2VTcGFjZSA9IHNwYWNlO1xuXHRcdH07XG5cdFx0dGhpcy5nZXRCYXNlTGF5ZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gZ2xQcm9qTGF5ZXIgIT09IG51bGwgPyBnbFByb2pMYXllciA6IGdsQmFzZUxheWVyO1xuXHRcdH07XG5cdFx0dGhpcy5nZXRCaW5kaW5nID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGdsQmluZGluZztcblx0XHR9O1xuXHRcdHRoaXMuZ2V0RnJhbWUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4geHJGcmFtZTtcblx0XHR9O1xuXHRcdHRoaXMuZ2V0U2Vzc2lvbiA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBzZXNzaW9uO1xuXHRcdH07XG5cdFx0dGhpcy5zZXRTZXNzaW9uID0gYXN5bmMgZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRzZXNzaW9uID0gdmFsdWU7XG5cdFx0XHRpZiAoc2Vzc2lvbiAhPT0gbnVsbCkge1xuXHRcdFx0XHRpbml0aWFsUmVuZGVyVGFyZ2V0ID0gcmVuZGVyZXIuZ2V0UmVuZGVyVGFyZ2V0KCk7XG5cdFx0XHRcdHNlc3Npb24uYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0Jywgb25TZXNzaW9uRXZlbnQpO1xuXHRcdFx0XHRzZXNzaW9uLmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdHN0YXJ0Jywgb25TZXNzaW9uRXZlbnQpO1xuXHRcdFx0XHRzZXNzaW9uLmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGVuZCcsIG9uU2Vzc2lvbkV2ZW50KTtcblx0XHRcdFx0c2Vzc2lvbi5hZGRFdmVudExpc3RlbmVyKCdzcXVlZXplJywgb25TZXNzaW9uRXZlbnQpO1xuXHRcdFx0XHRzZXNzaW9uLmFkZEV2ZW50TGlzdGVuZXIoJ3NxdWVlemVzdGFydCcsIG9uU2Vzc2lvbkV2ZW50KTtcblx0XHRcdFx0c2Vzc2lvbi5hZGRFdmVudExpc3RlbmVyKCdzcXVlZXplZW5kJywgb25TZXNzaW9uRXZlbnQpO1xuXHRcdFx0XHRzZXNzaW9uLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZCcsIG9uU2Vzc2lvbkVuZCk7XG5cdFx0XHRcdHNlc3Npb24uYWRkRXZlbnRMaXN0ZW5lcignaW5wdXRzb3VyY2VzY2hhbmdlJywgb25JbnB1dFNvdXJjZXNDaGFuZ2UpO1xuXHRcdFx0XHRpZiAoYXR0cmlidXRlcy54ckNvbXBhdGlibGUgIT09IHRydWUpIHtcblx0XHRcdFx0XHRhd2FpdCBnbC5tYWtlWFJDb21wYXRpYmxlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHNlc3Npb24ucmVuZGVyU3RhdGUubGF5ZXJzID09PSB1bmRlZmluZWQgfHwgcmVuZGVyZXIuY2FwYWJpbGl0aWVzLmlzV2ViR0wyID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdGNvbnN0IGxheWVySW5pdCA9IHtcblx0XHRcdFx0XHRcdGFudGlhbGlhczogc2Vzc2lvbi5yZW5kZXJTdGF0ZS5sYXllcnMgPT09IHVuZGVmaW5lZCA/IGF0dHJpYnV0ZXMuYW50aWFsaWFzIDogdHJ1ZSxcblx0XHRcdFx0XHRcdGFscGhhOiBhdHRyaWJ1dGVzLmFscGhhLFxuXHRcdFx0XHRcdFx0ZGVwdGg6IGF0dHJpYnV0ZXMuZGVwdGgsXG5cdFx0XHRcdFx0XHRzdGVuY2lsOiBhdHRyaWJ1dGVzLnN0ZW5jaWwsXG5cdFx0XHRcdFx0XHRmcmFtZWJ1ZmZlclNjYWxlRmFjdG9yOiBmcmFtZWJ1ZmZlclNjYWxlRmFjdG9yXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRnbEJhc2VMYXllciA9IG5ldyBYUldlYkdMTGF5ZXIoc2Vzc2lvbiwgZ2wsIGxheWVySW5pdCk7XG5cdFx0XHRcdFx0c2Vzc2lvbi51cGRhdGVSZW5kZXJTdGF0ZSh7XG5cdFx0XHRcdFx0XHRiYXNlTGF5ZXI6IGdsQmFzZUxheWVyXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0bmV3UmVuZGVyVGFyZ2V0ID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0KGdsQmFzZUxheWVyLmZyYW1lYnVmZmVyV2lkdGgsIGdsQmFzZUxheWVyLmZyYW1lYnVmZmVySGVpZ2h0LCB7XG5cdFx0XHRcdFx0XHRmb3JtYXQ6IFJHQkFGb3JtYXQsXG5cdFx0XHRcdFx0XHR0eXBlOiBVbnNpZ25lZEJ5dGVUeXBlLFxuXHRcdFx0XHRcdFx0ZW5jb2Rpbmc6IHJlbmRlcmVyLm91dHB1dEVuY29kaW5nLFxuXHRcdFx0XHRcdFx0c3RlbmNpbEJ1ZmZlcjogYXR0cmlidXRlcy5zdGVuY2lsXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGV0IGRlcHRoRm9ybWF0ID0gbnVsbDtcblx0XHRcdFx0XHRsZXQgZGVwdGhUeXBlID0gbnVsbDtcblx0XHRcdFx0XHRsZXQgZ2xEZXB0aEZvcm1hdCA9IG51bGw7XG5cdFx0XHRcdFx0aWYgKGF0dHJpYnV0ZXMuZGVwdGgpIHtcblx0XHRcdFx0XHRcdGdsRGVwdGhGb3JtYXQgPSBhdHRyaWJ1dGVzLnN0ZW5jaWwgPyBnbC5ERVBUSDI0X1NURU5DSUw4IDogZ2wuREVQVEhfQ09NUE9ORU5UMjQ7XG5cdFx0XHRcdFx0XHRkZXB0aEZvcm1hdCA9IGF0dHJpYnV0ZXMuc3RlbmNpbCA/IERlcHRoU3RlbmNpbEZvcm1hdCA6IERlcHRoRm9ybWF0O1xuXHRcdFx0XHRcdFx0ZGVwdGhUeXBlID0gYXR0cmlidXRlcy5zdGVuY2lsID8gVW5zaWduZWRJbnQyNDhUeXBlIDogVW5zaWduZWRJbnRUeXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb25zdCBwcm9qZWN0aW9ubGF5ZXJJbml0ID0ge1xuXHRcdFx0XHRcdFx0Y29sb3JGb3JtYXQ6IGdsLlJHQkE4LFxuXHRcdFx0XHRcdFx0ZGVwdGhGb3JtYXQ6IGdsRGVwdGhGb3JtYXQsXG5cdFx0XHRcdFx0XHRzY2FsZUZhY3RvcjogZnJhbWVidWZmZXJTY2FsZUZhY3RvclxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0Z2xCaW5kaW5nID0gbmV3IFhSV2ViR0xCaW5kaW5nKHNlc3Npb24sIGdsKTtcblx0XHRcdFx0XHRnbFByb2pMYXllciA9IGdsQmluZGluZy5jcmVhdGVQcm9qZWN0aW9uTGF5ZXIocHJvamVjdGlvbmxheWVySW5pdCk7XG5cdFx0XHRcdFx0c2Vzc2lvbi51cGRhdGVSZW5kZXJTdGF0ZSh7XG5cdFx0XHRcdFx0XHRsYXllcnM6IFtnbFByb2pMYXllcl1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRuZXdSZW5kZXJUYXJnZXQgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQoZ2xQcm9qTGF5ZXIudGV4dHVyZVdpZHRoLCBnbFByb2pMYXllci50ZXh0dXJlSGVpZ2h0LCB7XG5cdFx0XHRcdFx0XHRmb3JtYXQ6IFJHQkFGb3JtYXQsXG5cdFx0XHRcdFx0XHR0eXBlOiBVbnNpZ25lZEJ5dGVUeXBlLFxuXHRcdFx0XHRcdFx0ZGVwdGhUZXh0dXJlOiBuZXcgRGVwdGhUZXh0dXJlKGdsUHJvakxheWVyLnRleHR1cmVXaWR0aCwgZ2xQcm9qTGF5ZXIudGV4dHVyZUhlaWdodCwgZGVwdGhUeXBlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZXB0aEZvcm1hdCksXG5cdFx0XHRcdFx0XHRzdGVuY2lsQnVmZmVyOiBhdHRyaWJ1dGVzLnN0ZW5jaWwsXG5cdFx0XHRcdFx0XHRlbmNvZGluZzogcmVuZGVyZXIub3V0cHV0RW5jb2RpbmcsXG5cdFx0XHRcdFx0XHRzYW1wbGVzOiBhdHRyaWJ1dGVzLmFudGlhbGlhcyA/IDQgOiAwXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0Y29uc3QgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHJlbmRlcmVyLnByb3BlcnRpZXMuZ2V0KG5ld1JlbmRlclRhcmdldCk7XG5cdFx0XHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX2lnbm9yZURlcHRoVmFsdWVzID0gZ2xQcm9qTGF5ZXIuaWdub3JlRGVwdGhWYWx1ZXM7XG5cdFx0XHRcdH1cblx0XHRcdFx0bmV3UmVuZGVyVGFyZ2V0LmlzWFJSZW5kZXJUYXJnZXQgPSB0cnVlOyAvLyBUT0RPIFJlbW92ZSB0aGlzIHdoZW4gcG9zc2libGUsIHNlZSAjMjMyNzhcblxuXHRcdFx0XHQvLyBTZXQgZm92ZWF0aW9uIHRvIG1heGltdW0uXG5cdFx0XHRcdHRoaXMuc2V0Rm92ZWF0aW9uKDEuMCk7XG5cdFx0XHRcdGN1c3RvbVJlZmVyZW5jZVNwYWNlID0gbnVsbDtcblx0XHRcdFx0cmVmZXJlbmNlU3BhY2UgPSBhd2FpdCBzZXNzaW9uLnJlcXVlc3RSZWZlcmVuY2VTcGFjZShyZWZlcmVuY2VTcGFjZVR5cGUpO1xuXHRcdFx0XHRhbmltYXRpb24uc2V0Q29udGV4dChzZXNzaW9uKTtcblx0XHRcdFx0YW5pbWF0aW9uLnN0YXJ0KCk7XG5cdFx0XHRcdHNjb3BlLmlzUHJlc2VudGluZyA9IHRydWU7XG5cdFx0XHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoe1xuXHRcdFx0XHRcdHR5cGU6ICdzZXNzaW9uc3RhcnQnXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0ZnVuY3Rpb24gb25JbnB1dFNvdXJjZXNDaGFuZ2UoZXZlbnQpIHtcblx0XHRcdC8vIE5vdGlmeSBkaXNjb25uZWN0ZWRcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBldmVudC5yZW1vdmVkLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGlucHV0U291cmNlID0gZXZlbnQucmVtb3ZlZFtpXTtcblx0XHRcdFx0Y29uc3QgaW5kZXggPSBjb250cm9sbGVySW5wdXRTb3VyY2VzLmluZGV4T2YoaW5wdXRTb3VyY2UpO1xuXHRcdFx0XHRpZiAoaW5kZXggPj0gMCkge1xuXHRcdFx0XHRcdGNvbnRyb2xsZXJJbnB1dFNvdXJjZXNbaW5kZXhdID0gbnVsbDtcblx0XHRcdFx0XHRjb250cm9sbGVyc1tpbmRleF0uZGlzcGF0Y2hFdmVudCh7XG5cdFx0XHRcdFx0XHR0eXBlOiAnZGlzY29ubmVjdGVkJyxcblx0XHRcdFx0XHRcdGRhdGE6IGlucHV0U291cmNlXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gTm90aWZ5IGNvbm5lY3RlZFxuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50LmFkZGVkLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGlucHV0U291cmNlID0gZXZlbnQuYWRkZWRbaV07XG5cdFx0XHRcdGxldCBjb250cm9sbGVySW5kZXggPSBjb250cm9sbGVySW5wdXRTb3VyY2VzLmluZGV4T2YoaW5wdXRTb3VyY2UpO1xuXHRcdFx0XHRpZiAoY29udHJvbGxlckluZGV4ID09PSAtMSkge1xuXHRcdFx0XHRcdC8vIEFzc2lnbiBpbnB1dCBzb3VyY2UgYSBjb250cm9sbGVyIHRoYXQgY3VycmVudGx5IGhhcyBubyBpbnB1dCBzb3VyY2VcblxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgY29udHJvbGxlcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGlmIChpID49IGNvbnRyb2xsZXJJbnB1dFNvdXJjZXMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2xsZXJJbnB1dFNvdXJjZXMucHVzaChpbnB1dFNvdXJjZSk7XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2xsZXJJbmRleCA9IGk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChjb250cm9sbGVySW5wdXRTb3VyY2VzW2ldID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2xsZXJJbnB1dFNvdXJjZXNbaV0gPSBpbnB1dFNvdXJjZTtcblx0XHRcdFx0XHRcdFx0Y29udHJvbGxlckluZGV4ID0gaTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gSWYgYWxsIGNvbnRyb2xsZXJzIGRvIGN1cnJlbnRseSByZWNlaXZlIGlucHV0IHdlIGlnbm9yZSBuZXcgb25lc1xuXG5cdFx0XHRcdFx0aWYgKGNvbnRyb2xsZXJJbmRleCA9PT0gLTEpIGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnN0IGNvbnRyb2xsZXIgPSBjb250cm9sbGVyc1tjb250cm9sbGVySW5kZXhdO1xuXHRcdFx0XHRpZiAoY29udHJvbGxlcikge1xuXHRcdFx0XHRcdGNvbnRyb2xsZXIuZGlzcGF0Y2hFdmVudCh7XG5cdFx0XHRcdFx0XHR0eXBlOiAnY29ubmVjdGVkJyxcblx0XHRcdFx0XHRcdGRhdGE6IGlucHV0U291cmNlXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0Y29uc3QgY2FtZXJhTFBvcyA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgY2FtZXJhUlBvcyA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHQvKipcblx0XHQgKiBBc3N1bWVzIDIgY2FtZXJhcyB0aGF0IGFyZSBwYXJhbGxlbCBhbmQgc2hhcmUgYW4gWC1heGlzLCBhbmQgdGhhdFxuXHRcdCAqIHRoZSBjYW1lcmFzJyBwcm9qZWN0aW9uIGFuZCB3b3JsZCBtYXRyaWNlcyBoYXZlIGFscmVhZHkgYmVlbiBzZXQuXG5cdFx0ICogQW5kIHRoYXQgbmVhciBhbmQgZmFyIHBsYW5lcyBhcmUgaWRlbnRpY2FsIGZvciBib3RoIGNhbWVyYXMuXG5cdFx0ICogVmlzdWFsaXphdGlvbiBvZiB0aGlzIHRlY2huaXF1ZTogaHR0cHM6Ly9jb21wdXRlcmdyYXBoaWNzLnN0YWNrZXhjaGFuZ2UuY29tL2EvNDc2NVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIHNldFByb2plY3Rpb25Gcm9tVW5pb24oY2FtZXJhLCBjYW1lcmFMLCBjYW1lcmFSKSB7XG5cdFx0XHRjYW1lcmFMUG9zLnNldEZyb21NYXRyaXhQb3NpdGlvbihjYW1lcmFMLm1hdHJpeFdvcmxkKTtcblx0XHRcdGNhbWVyYVJQb3Muc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGNhbWVyYVIubWF0cml4V29ybGQpO1xuXHRcdFx0Y29uc3QgaXBkID0gY2FtZXJhTFBvcy5kaXN0YW5jZVRvKGNhbWVyYVJQb3MpO1xuXHRcdFx0Y29uc3QgcHJvakwgPSBjYW1lcmFMLnByb2plY3Rpb25NYXRyaXguZWxlbWVudHM7XG5cdFx0XHRjb25zdCBwcm9qUiA9IGNhbWVyYVIucHJvamVjdGlvbk1hdHJpeC5lbGVtZW50cztcblxuXHRcdFx0Ly8gVlIgc3lzdGVtcyB3aWxsIGhhdmUgaWRlbnRpY2FsIGZhciBhbmQgbmVhciBwbGFuZXMsIGFuZFxuXHRcdFx0Ly8gbW9zdCBsaWtlbHkgaWRlbnRpY2FsIHRvcCBhbmQgYm90dG9tIGZydXN0dW0gZXh0ZW50cy5cblx0XHRcdC8vIFVzZSB0aGUgbGVmdCBjYW1lcmEgZm9yIHRoZXNlIHZhbHVlcy5cblx0XHRcdGNvbnN0IG5lYXIgPSBwcm9qTFsxNF0gLyAocHJvakxbMTBdIC0gMSk7XG5cdFx0XHRjb25zdCBmYXIgPSBwcm9qTFsxNF0gLyAocHJvakxbMTBdICsgMSk7XG5cdFx0XHRjb25zdCB0b3BGb3YgPSAocHJvakxbOV0gKyAxKSAvIHByb2pMWzVdO1xuXHRcdFx0Y29uc3QgYm90dG9tRm92ID0gKHByb2pMWzldIC0gMSkgLyBwcm9qTFs1XTtcblx0XHRcdGNvbnN0IGxlZnRGb3YgPSAocHJvakxbOF0gLSAxKSAvIHByb2pMWzBdO1xuXHRcdFx0Y29uc3QgcmlnaHRGb3YgPSAocHJvalJbOF0gKyAxKSAvIHByb2pSWzBdO1xuXHRcdFx0Y29uc3QgbGVmdCA9IG5lYXIgKiBsZWZ0Rm92O1xuXHRcdFx0Y29uc3QgcmlnaHQgPSBuZWFyICogcmlnaHRGb3Y7XG5cblx0XHRcdC8vIENhbGN1bGF0ZSB0aGUgbmV3IGNhbWVyYSdzIHBvc2l0aW9uIG9mZnNldCBmcm9tIHRoZVxuXHRcdFx0Ly8gbGVmdCBjYW1lcmEuIHhPZmZzZXQgc2hvdWxkIGJlIHJvdWdobHkgaGFsZiBgaXBkYC5cblx0XHRcdGNvbnN0IHpPZmZzZXQgPSBpcGQgLyAoLWxlZnRGb3YgKyByaWdodEZvdik7XG5cdFx0XHRjb25zdCB4T2Zmc2V0ID0gek9mZnNldCAqIC1sZWZ0Rm92O1xuXG5cdFx0XHQvLyBUT0RPOiBCZXR0ZXIgd2F5IHRvIGFwcGx5IHRoaXMgb2Zmc2V0P1xuXHRcdFx0Y2FtZXJhTC5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoY2FtZXJhLnBvc2l0aW9uLCBjYW1lcmEucXVhdGVybmlvbiwgY2FtZXJhLnNjYWxlKTtcblx0XHRcdGNhbWVyYS50cmFuc2xhdGVYKHhPZmZzZXQpO1xuXHRcdFx0Y2FtZXJhLnRyYW5zbGF0ZVooek9mZnNldCk7XG5cdFx0XHRjYW1lcmEubWF0cml4V29ybGQuY29tcG9zZShjYW1lcmEucG9zaXRpb24sIGNhbWVyYS5xdWF0ZXJuaW9uLCBjYW1lcmEuc2NhbGUpO1xuXHRcdFx0Y2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZS5jb3B5KGNhbWVyYS5tYXRyaXhXb3JsZCkuaW52ZXJ0KCk7XG5cblx0XHRcdC8vIEZpbmQgdGhlIHVuaW9uIG9mIHRoZSBmcnVzdHVtIHZhbHVlcyBvZiB0aGUgY2FtZXJhcyBhbmQgc2NhbGVcblx0XHRcdC8vIHRoZSB2YWx1ZXMgc28gdGhhdCB0aGUgbmVhciBwbGFuZSdzIHBvc2l0aW9uIGRvZXMgbm90IGNoYW5nZSBpbiB3b3JsZCBzcGFjZSxcblx0XHRcdC8vIGFsdGhvdWdoIG11c3Qgbm93IGJlIHJlbGF0aXZlIHRvIHRoZSBuZXcgdW5pb24gY2FtZXJhLlxuXHRcdFx0Y29uc3QgbmVhcjIgPSBuZWFyICsgek9mZnNldDtcblx0XHRcdGNvbnN0IGZhcjIgPSBmYXIgKyB6T2Zmc2V0O1xuXHRcdFx0Y29uc3QgbGVmdDIgPSBsZWZ0IC0geE9mZnNldDtcblx0XHRcdGNvbnN0IHJpZ2h0MiA9IHJpZ2h0ICsgKGlwZCAtIHhPZmZzZXQpO1xuXHRcdFx0Y29uc3QgdG9wMiA9IHRvcEZvdiAqIGZhciAvIGZhcjIgKiBuZWFyMjtcblx0XHRcdGNvbnN0IGJvdHRvbTIgPSBib3R0b21Gb3YgKiBmYXIgLyBmYXIyICogbmVhcjI7XG5cdFx0XHRjYW1lcmEucHJvamVjdGlvbk1hdHJpeC5tYWtlUGVyc3BlY3RpdmUobGVmdDIsIHJpZ2h0MiwgdG9wMiwgYm90dG9tMiwgbmVhcjIsIGZhcjIpO1xuXHRcdH1cblx0XHRmdW5jdGlvbiB1cGRhdGVDYW1lcmEoY2FtZXJhLCBwYXJlbnQpIHtcblx0XHRcdGlmIChwYXJlbnQgPT09IG51bGwpIHtcblx0XHRcdFx0Y2FtZXJhLm1hdHJpeFdvcmxkLmNvcHkoY2FtZXJhLm1hdHJpeCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjYW1lcmEubWF0cml4V29ybGQubXVsdGlwbHlNYXRyaWNlcyhwYXJlbnQubWF0cml4V29ybGQsIGNhbWVyYS5tYXRyaXgpO1xuXHRcdFx0fVxuXHRcdFx0Y2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZS5jb3B5KGNhbWVyYS5tYXRyaXhXb3JsZCkuaW52ZXJ0KCk7XG5cdFx0fVxuXHRcdHRoaXMudXBkYXRlQ2FtZXJhID0gZnVuY3Rpb24gKGNhbWVyYSkge1xuXHRcdFx0aWYgKHNlc3Npb24gPT09IG51bGwpIHJldHVybjtcblx0XHRcdGNhbWVyYVZSLm5lYXIgPSBjYW1lcmFSLm5lYXIgPSBjYW1lcmFMLm5lYXIgPSBjYW1lcmEubmVhcjtcblx0XHRcdGNhbWVyYVZSLmZhciA9IGNhbWVyYVIuZmFyID0gY2FtZXJhTC5mYXIgPSBjYW1lcmEuZmFyO1xuXHRcdFx0aWYgKF9jdXJyZW50RGVwdGhOZWFyICE9PSBjYW1lcmFWUi5uZWFyIHx8IF9jdXJyZW50RGVwdGhGYXIgIT09IGNhbWVyYVZSLmZhcikge1xuXHRcdFx0XHQvLyBOb3RlIHRoYXQgdGhlIG5ldyByZW5kZXJTdGF0ZSB3b24ndCBhcHBseSB1bnRpbCB0aGUgbmV4dCBmcmFtZS4gU2VlICMxODMyMFxuXG5cdFx0XHRcdHNlc3Npb24udXBkYXRlUmVuZGVyU3RhdGUoe1xuXHRcdFx0XHRcdGRlcHRoTmVhcjogY2FtZXJhVlIubmVhcixcblx0XHRcdFx0XHRkZXB0aEZhcjogY2FtZXJhVlIuZmFyXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRfY3VycmVudERlcHRoTmVhciA9IGNhbWVyYVZSLm5lYXI7XG5cdFx0XHRcdF9jdXJyZW50RGVwdGhGYXIgPSBjYW1lcmFWUi5mYXI7XG5cdFx0XHR9XG5cdFx0XHRjb25zdCBwYXJlbnQgPSBjYW1lcmEucGFyZW50O1xuXHRcdFx0Y29uc3QgY2FtZXJhcyA9IGNhbWVyYVZSLmNhbWVyYXM7XG5cdFx0XHR1cGRhdGVDYW1lcmEoY2FtZXJhVlIsIHBhcmVudCk7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNhbWVyYXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dXBkYXRlQ2FtZXJhKGNhbWVyYXNbaV0sIHBhcmVudCk7XG5cdFx0XHR9XG5cdFx0XHRjYW1lcmFWUi5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoY2FtZXJhVlIucG9zaXRpb24sIGNhbWVyYVZSLnF1YXRlcm5pb24sIGNhbWVyYVZSLnNjYWxlKTtcblxuXHRcdFx0Ly8gdXBkYXRlIHVzZXIgY2FtZXJhIGFuZCBpdHMgY2hpbGRyZW5cblxuXHRcdFx0Y2FtZXJhLm1hdHJpeC5jb3B5KGNhbWVyYVZSLm1hdHJpeCk7XG5cdFx0XHRjYW1lcmEubWF0cml4LmRlY29tcG9zZShjYW1lcmEucG9zaXRpb24sIGNhbWVyYS5xdWF0ZXJuaW9uLCBjYW1lcmEuc2NhbGUpO1xuXHRcdFx0Y29uc3QgY2hpbGRyZW4gPSBjYW1lcmEuY2hpbGRyZW47XG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRjaGlsZHJlbltpXS51cGRhdGVNYXRyaXhXb3JsZCh0cnVlKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gdXBkYXRlIHByb2plY3Rpb24gbWF0cml4IGZvciBwcm9wZXIgdmlldyBmcnVzdHVtIGN1bGxpbmdcblxuXHRcdFx0aWYgKGNhbWVyYXMubGVuZ3RoID09PSAyKSB7XG5cdFx0XHRcdHNldFByb2plY3Rpb25Gcm9tVW5pb24oY2FtZXJhVlIsIGNhbWVyYUwsIGNhbWVyYVIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gYXNzdW1lIHNpbmdsZSBjYW1lcmEgc2V0dXAgKEFSKVxuXG5cdFx0XHRcdGNhbWVyYVZSLnByb2plY3Rpb25NYXRyaXguY29weShjYW1lcmFMLnByb2plY3Rpb25NYXRyaXgpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0dGhpcy5nZXRDYW1lcmEgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gY2FtZXJhVlI7XG5cdFx0fTtcblx0XHR0aGlzLmdldEZvdmVhdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmIChnbFByb2pMYXllciAhPT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gZ2xQcm9qTGF5ZXIuZml4ZWRGb3ZlYXRpb247XG5cdFx0XHR9XG5cdFx0XHRpZiAoZ2xCYXNlTGF5ZXIgIT09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIGdsQmFzZUxheWVyLmZpeGVkRm92ZWF0aW9uO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9O1xuXHRcdHRoaXMuc2V0Rm92ZWF0aW9uID0gZnVuY3Rpb24gKGZvdmVhdGlvbikge1xuXHRcdFx0Ly8gMCA9IG5vIGZvdmVhdGlvbiA9IGZ1bGwgcmVzb2x1dGlvblxuXHRcdFx0Ly8gMSA9IG1heGltdW0gZm92ZWF0aW9uID0gdGhlIGVkZ2VzIHJlbmRlciBhdCBsb3dlciByZXNvbHV0aW9uXG5cblx0XHRcdGlmIChnbFByb2pMYXllciAhPT0gbnVsbCkge1xuXHRcdFx0XHRnbFByb2pMYXllci5maXhlZEZvdmVhdGlvbiA9IGZvdmVhdGlvbjtcblx0XHRcdH1cblx0XHRcdGlmIChnbEJhc2VMYXllciAhPT0gbnVsbCAmJiBnbEJhc2VMYXllci5maXhlZEZvdmVhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGdsQmFzZUxheWVyLmZpeGVkRm92ZWF0aW9uID0gZm92ZWF0aW9uO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvLyBBbmltYXRpb24gTG9vcFxuXG5cdFx0bGV0IG9uQW5pbWF0aW9uRnJhbWVDYWxsYmFjayA9IG51bGw7XG5cdFx0ZnVuY3Rpb24gb25BbmltYXRpb25GcmFtZSh0aW1lLCBmcmFtZSkge1xuXHRcdFx0cG9zZSA9IGZyYW1lLmdldFZpZXdlclBvc2UoY3VzdG9tUmVmZXJlbmNlU3BhY2UgfHwgcmVmZXJlbmNlU3BhY2UpO1xuXHRcdFx0eHJGcmFtZSA9IGZyYW1lO1xuXHRcdFx0aWYgKHBvc2UgIT09IG51bGwpIHtcblx0XHRcdFx0Y29uc3Qgdmlld3MgPSBwb3NlLnZpZXdzO1xuXHRcdFx0XHRpZiAoZ2xCYXNlTGF5ZXIgIT09IG51bGwpIHtcblx0XHRcdFx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXRGcmFtZWJ1ZmZlcihuZXdSZW5kZXJUYXJnZXQsIGdsQmFzZUxheWVyLmZyYW1lYnVmZmVyKTtcblx0XHRcdFx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQobmV3UmVuZGVyVGFyZ2V0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRsZXQgY2FtZXJhVlJOZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0XHRcdC8vIGNoZWNrIGlmIGl0J3MgbmVjZXNzYXJ5IHRvIHJlYnVpbGQgY2FtZXJhVlIncyBjYW1lcmEgbGlzdFxuXG5cdFx0XHRcdGlmICh2aWV3cy5sZW5ndGggIT09IGNhbWVyYVZSLmNhbWVyYXMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0Y2FtZXJhVlIuY2FtZXJhcy5sZW5ndGggPSAwO1xuXHRcdFx0XHRcdGNhbWVyYVZSTmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdmlld3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCB2aWV3ID0gdmlld3NbaV07XG5cdFx0XHRcdFx0bGV0IHZpZXdwb3J0ID0gbnVsbDtcblx0XHRcdFx0XHRpZiAoZ2xCYXNlTGF5ZXIgIT09IG51bGwpIHtcblx0XHRcdFx0XHRcdHZpZXdwb3J0ID0gZ2xCYXNlTGF5ZXIuZ2V0Vmlld3BvcnQodmlldyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnN0IGdsU3ViSW1hZ2UgPSBnbEJpbmRpbmcuZ2V0Vmlld1N1YkltYWdlKGdsUHJvakxheWVyLCB2aWV3KTtcblx0XHRcdFx0XHRcdHZpZXdwb3J0ID0gZ2xTdWJJbWFnZS52aWV3cG9ydDtcblxuXHRcdFx0XHRcdFx0Ly8gRm9yIHNpZGUtYnktc2lkZSBwcm9qZWN0aW9uLCB3ZSBvbmx5IHByb2R1Y2UgYSBzaW5nbGUgdGV4dHVyZSBmb3IgYm90aCBleWVzLlxuXHRcdFx0XHRcdFx0aWYgKGkgPT09IDApIHtcblx0XHRcdFx0XHRcdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0VGV4dHVyZXMobmV3UmVuZGVyVGFyZ2V0LCBnbFN1YkltYWdlLmNvbG9yVGV4dHVyZSwgZ2xQcm9qTGF5ZXIuaWdub3JlRGVwdGhWYWx1ZXMgPyB1bmRlZmluZWQgOiBnbFN1YkltYWdlLmRlcHRoU3RlbmNpbFRleHR1cmUpO1xuXHRcdFx0XHRcdFx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQobmV3UmVuZGVyVGFyZ2V0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bGV0IGNhbWVyYSA9IGNhbWVyYXNbaV07XG5cdFx0XHRcdFx0aWYgKGNhbWVyYSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRjYW1lcmEgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoKTtcblx0XHRcdFx0XHRcdGNhbWVyYS5sYXllcnMuZW5hYmxlKGkpO1xuXHRcdFx0XHRcdFx0Y2FtZXJhLnZpZXdwb3J0ID0gbmV3IFZlY3RvcjQoKTtcblx0XHRcdFx0XHRcdGNhbWVyYXNbaV0gPSBjYW1lcmE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNhbWVyYS5tYXRyaXguZnJvbUFycmF5KHZpZXcudHJhbnNmb3JtLm1hdHJpeCk7XG5cdFx0XHRcdFx0Y2FtZXJhLnByb2plY3Rpb25NYXRyaXguZnJvbUFycmF5KHZpZXcucHJvamVjdGlvbk1hdHJpeCk7XG5cdFx0XHRcdFx0Y2FtZXJhLnZpZXdwb3J0LnNldCh2aWV3cG9ydC54LCB2aWV3cG9ydC55LCB2aWV3cG9ydC53aWR0aCwgdmlld3BvcnQuaGVpZ2h0KTtcblx0XHRcdFx0XHRpZiAoaSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0Y2FtZXJhVlIubWF0cml4LmNvcHkoY2FtZXJhLm1hdHJpeCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChjYW1lcmFWUk5lZWRzVXBkYXRlID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRjYW1lcmFWUi5jYW1lcmFzLnB1c2goY2FtZXJhKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly9cblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjb250cm9sbGVycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRjb25zdCBpbnB1dFNvdXJjZSA9IGNvbnRyb2xsZXJJbnB1dFNvdXJjZXNbaV07XG5cdFx0XHRcdGNvbnN0IGNvbnRyb2xsZXIgPSBjb250cm9sbGVyc1tpXTtcblx0XHRcdFx0aWYgKGlucHV0U291cmNlICE9PSBudWxsICYmIGNvbnRyb2xsZXIgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGNvbnRyb2xsZXIudXBkYXRlKGlucHV0U291cmNlLCBmcmFtZSwgY3VzdG9tUmVmZXJlbmNlU3BhY2UgfHwgcmVmZXJlbmNlU3BhY2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAob25BbmltYXRpb25GcmFtZUNhbGxiYWNrKSBvbkFuaW1hdGlvbkZyYW1lQ2FsbGJhY2sodGltZSwgZnJhbWUpO1xuXHRcdFx0eHJGcmFtZSA9IG51bGw7XG5cdFx0fVxuXHRcdGNvbnN0IGFuaW1hdGlvbiA9IG5ldyBXZWJHTEFuaW1hdGlvbigpO1xuXHRcdGFuaW1hdGlvbi5zZXRBbmltYXRpb25Mb29wKG9uQW5pbWF0aW9uRnJhbWUpO1xuXHRcdHRoaXMuc2V0QW5pbWF0aW9uTG9vcCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHRcdFx0b25BbmltYXRpb25GcmFtZUNhbGxiYWNrID0gY2FsbGJhY2s7XG5cdFx0fTtcblx0XHR0aGlzLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7fTtcblx0fVxufVxuXG5mdW5jdGlvbiBXZWJHTE1hdGVyaWFscyhyZW5kZXJlciwgcHJvcGVydGllcykge1xuXHRmdW5jdGlvbiByZWZyZXNoRm9nVW5pZm9ybXModW5pZm9ybXMsIGZvZykge1xuXHRcdHVuaWZvcm1zLmZvZ0NvbG9yLnZhbHVlLmNvcHkoZm9nLmNvbG9yKTtcblx0XHRpZiAoZm9nLmlzRm9nKSB7XG5cdFx0XHR1bmlmb3Jtcy5mb2dOZWFyLnZhbHVlID0gZm9nLm5lYXI7XG5cdFx0XHR1bmlmb3Jtcy5mb2dGYXIudmFsdWUgPSBmb2cuZmFyO1xuXHRcdH0gZWxzZSBpZiAoZm9nLmlzRm9nRXhwMikge1xuXHRcdFx0dW5pZm9ybXMuZm9nRGVuc2l0eS52YWx1ZSA9IGZvZy5kZW5zaXR5O1xuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiByZWZyZXNoTWF0ZXJpYWxVbmlmb3Jtcyh1bmlmb3JtcywgbWF0ZXJpYWwsIHBpeGVsUmF0aW8sIGhlaWdodCwgdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0KSB7XG5cdFx0aWYgKG1hdGVyaWFsLmlzTWVzaEJhc2ljTWF0ZXJpYWwpIHtcblx0XHRcdHJlZnJlc2hVbmlmb3Jtc0NvbW1vbih1bmlmb3JtcywgbWF0ZXJpYWwpO1xuXHRcdH0gZWxzZSBpZiAobWF0ZXJpYWwuaXNNZXNoTGFtYmVydE1hdGVyaWFsKSB7XG5cdFx0XHRyZWZyZXNoVW5pZm9ybXNDb21tb24odW5pZm9ybXMsIG1hdGVyaWFsKTtcblx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsLmlzTWVzaFRvb25NYXRlcmlhbCkge1xuXHRcdFx0cmVmcmVzaFVuaWZvcm1zQ29tbW9uKHVuaWZvcm1zLCBtYXRlcmlhbCk7XG5cdFx0XHRyZWZyZXNoVW5pZm9ybXNUb29uKHVuaWZvcm1zLCBtYXRlcmlhbCk7XG5cdFx0fSBlbHNlIGlmIChtYXRlcmlhbC5pc01lc2hQaG9uZ01hdGVyaWFsKSB7XG5cdFx0XHRyZWZyZXNoVW5pZm9ybXNDb21tb24odW5pZm9ybXMsIG1hdGVyaWFsKTtcblx0XHRcdHJlZnJlc2hVbmlmb3Jtc1Bob25nKHVuaWZvcm1zLCBtYXRlcmlhbCk7XG5cdFx0fSBlbHNlIGlmIChtYXRlcmlhbC5pc01lc2hTdGFuZGFyZE1hdGVyaWFsKSB7XG5cdFx0XHRyZWZyZXNoVW5pZm9ybXNDb21tb24odW5pZm9ybXMsIG1hdGVyaWFsKTtcblx0XHRcdHJlZnJlc2hVbmlmb3Jtc1N0YW5kYXJkKHVuaWZvcm1zLCBtYXRlcmlhbCk7XG5cdFx0XHRpZiAobWF0ZXJpYWwuaXNNZXNoUGh5c2ljYWxNYXRlcmlhbCkge1xuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNQaHlzaWNhbCh1bmlmb3JtcywgbWF0ZXJpYWwsIHRyYW5zbWlzc2lvblJlbmRlclRhcmdldCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChtYXRlcmlhbC5pc01lc2hNYXRjYXBNYXRlcmlhbCkge1xuXHRcdFx0cmVmcmVzaFVuaWZvcm1zQ29tbW9uKHVuaWZvcm1zLCBtYXRlcmlhbCk7XG5cdFx0XHRyZWZyZXNoVW5pZm9ybXNNYXRjYXAodW5pZm9ybXMsIG1hdGVyaWFsKTtcblx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsLmlzTWVzaERlcHRoTWF0ZXJpYWwpIHtcblx0XHRcdHJlZnJlc2hVbmlmb3Jtc0NvbW1vbih1bmlmb3JtcywgbWF0ZXJpYWwpO1xuXHRcdH0gZWxzZSBpZiAobWF0ZXJpYWwuaXNNZXNoRGlzdGFuY2VNYXRlcmlhbCkge1xuXHRcdFx0cmVmcmVzaFVuaWZvcm1zQ29tbW9uKHVuaWZvcm1zLCBtYXRlcmlhbCk7XG5cdFx0XHRyZWZyZXNoVW5pZm9ybXNEaXN0YW5jZSh1bmlmb3JtcywgbWF0ZXJpYWwpO1xuXHRcdH0gZWxzZSBpZiAobWF0ZXJpYWwuaXNNZXNoTm9ybWFsTWF0ZXJpYWwpIHtcblx0XHRcdHJlZnJlc2hVbmlmb3Jtc0NvbW1vbih1bmlmb3JtcywgbWF0ZXJpYWwpO1xuXHRcdH0gZWxzZSBpZiAobWF0ZXJpYWwuaXNMaW5lQmFzaWNNYXRlcmlhbCkge1xuXHRcdFx0cmVmcmVzaFVuaWZvcm1zTGluZSh1bmlmb3JtcywgbWF0ZXJpYWwpO1xuXHRcdFx0aWYgKG1hdGVyaWFsLmlzTGluZURhc2hlZE1hdGVyaWFsKSB7XG5cdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc0Rhc2godW5pZm9ybXMsIG1hdGVyaWFsKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsLmlzUG9pbnRzTWF0ZXJpYWwpIHtcblx0XHRcdHJlZnJlc2hVbmlmb3Jtc1BvaW50cyh1bmlmb3JtcywgbWF0ZXJpYWwsIHBpeGVsUmF0aW8sIGhlaWdodCk7XG5cdFx0fSBlbHNlIGlmIChtYXRlcmlhbC5pc1Nwcml0ZU1hdGVyaWFsKSB7XG5cdFx0XHRyZWZyZXNoVW5pZm9ybXNTcHJpdGVzKHVuaWZvcm1zLCBtYXRlcmlhbCk7XG5cdFx0fSBlbHNlIGlmIChtYXRlcmlhbC5pc1NoYWRvd01hdGVyaWFsKSB7XG5cdFx0XHR1bmlmb3Jtcy5jb2xvci52YWx1ZS5jb3B5KG1hdGVyaWFsLmNvbG9yKTtcblx0XHRcdHVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xuXHRcdH0gZWxzZSBpZiAobWF0ZXJpYWwuaXNTaGFkZXJNYXRlcmlhbCkge1xuXHRcdFx0bWF0ZXJpYWwudW5pZm9ybXNOZWVkVXBkYXRlID0gZmFsc2U7IC8vICMxNTU4MVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0NvbW1vbih1bmlmb3JtcywgbWF0ZXJpYWwpIHtcblx0XHR1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcblx0XHRpZiAobWF0ZXJpYWwuY29sb3IpIHtcblx0XHRcdHVuaWZvcm1zLmRpZmZ1c2UudmFsdWUuY29weShtYXRlcmlhbC5jb2xvcik7XG5cdFx0fVxuXHRcdGlmIChtYXRlcmlhbC5lbWlzc2l2ZSkge1xuXHRcdFx0dW5pZm9ybXMuZW1pc3NpdmUudmFsdWUuY29weShtYXRlcmlhbC5lbWlzc2l2ZSkubXVsdGlwbHlTY2FsYXIobWF0ZXJpYWwuZW1pc3NpdmVJbnRlbnNpdHkpO1xuXHRcdH1cblx0XHRpZiAobWF0ZXJpYWwubWFwKSB7XG5cdFx0XHR1bmlmb3Jtcy5tYXAudmFsdWUgPSBtYXRlcmlhbC5tYXA7XG5cdFx0fVxuXHRcdGlmIChtYXRlcmlhbC5hbHBoYU1hcCkge1xuXHRcdFx0dW5pZm9ybXMuYWxwaGFNYXAudmFsdWUgPSBtYXRlcmlhbC5hbHBoYU1hcDtcblx0XHR9XG5cdFx0aWYgKG1hdGVyaWFsLmJ1bXBNYXApIHtcblx0XHRcdHVuaWZvcm1zLmJ1bXBNYXAudmFsdWUgPSBtYXRlcmlhbC5idW1wTWFwO1xuXHRcdFx0dW5pZm9ybXMuYnVtcFNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuYnVtcFNjYWxlO1xuXHRcdFx0aWYgKG1hdGVyaWFsLnNpZGUgPT09IEJhY2tTaWRlKSB1bmlmb3Jtcy5idW1wU2NhbGUudmFsdWUgKj0gLTE7XG5cdFx0fVxuXHRcdGlmIChtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXApIHtcblx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudE1hcC52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcDtcblx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudFNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50U2NhbGU7XG5cdFx0XHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRCaWFzLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50Qmlhcztcblx0XHR9XG5cdFx0aWYgKG1hdGVyaWFsLmVtaXNzaXZlTWFwKSB7XG5cdFx0XHR1bmlmb3Jtcy5lbWlzc2l2ZU1hcC52YWx1ZSA9IG1hdGVyaWFsLmVtaXNzaXZlTWFwO1xuXHRcdH1cblx0XHRpZiAobWF0ZXJpYWwubm9ybWFsTWFwKSB7XG5cdFx0XHR1bmlmb3Jtcy5ub3JtYWxNYXAudmFsdWUgPSBtYXRlcmlhbC5ub3JtYWxNYXA7XG5cdFx0XHR1bmlmb3Jtcy5ub3JtYWxTY2FsZS52YWx1ZS5jb3B5KG1hdGVyaWFsLm5vcm1hbFNjYWxlKTtcblx0XHRcdGlmIChtYXRlcmlhbC5zaWRlID09PSBCYWNrU2lkZSkgdW5pZm9ybXMubm9ybWFsU2NhbGUudmFsdWUubmVnYXRlKCk7XG5cdFx0fVxuXHRcdGlmIChtYXRlcmlhbC5zcGVjdWxhck1hcCkge1xuXHRcdFx0dW5pZm9ybXMuc3BlY3VsYXJNYXAudmFsdWUgPSBtYXRlcmlhbC5zcGVjdWxhck1hcDtcblx0XHR9XG5cdFx0aWYgKG1hdGVyaWFsLmFscGhhVGVzdCA+IDApIHtcblx0XHRcdHVuaWZvcm1zLmFscGhhVGVzdC52YWx1ZSA9IG1hdGVyaWFsLmFscGhhVGVzdDtcblx0XHR9XG5cdFx0Y29uc3QgZW52TWFwID0gcHJvcGVydGllcy5nZXQobWF0ZXJpYWwpLmVudk1hcDtcblx0XHRpZiAoZW52TWFwKSB7XG5cdFx0XHR1bmlmb3Jtcy5lbnZNYXAudmFsdWUgPSBlbnZNYXA7XG5cdFx0XHR1bmlmb3Jtcy5mbGlwRW52TWFwLnZhbHVlID0gZW52TWFwLmlzQ3ViZVRleHR1cmUgJiYgZW52TWFwLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSA9PT0gZmFsc2UgPyAtMSA6IDE7XG5cdFx0XHR1bmlmb3Jtcy5yZWZsZWN0aXZpdHkudmFsdWUgPSBtYXRlcmlhbC5yZWZsZWN0aXZpdHk7XG5cdFx0XHR1bmlmb3Jtcy5pb3IudmFsdWUgPSBtYXRlcmlhbC5pb3I7XG5cdFx0XHR1bmlmb3Jtcy5yZWZyYWN0aW9uUmF0aW8udmFsdWUgPSBtYXRlcmlhbC5yZWZyYWN0aW9uUmF0aW87XG5cdFx0fVxuXHRcdGlmIChtYXRlcmlhbC5saWdodE1hcCkge1xuXHRcdFx0dW5pZm9ybXMubGlnaHRNYXAudmFsdWUgPSBtYXRlcmlhbC5saWdodE1hcDtcblxuXHRcdFx0Ly8gYXJ0aXN0LWZyaWVuZGx5IGxpZ2h0IGludGVuc2l0eSBzY2FsaW5nIGZhY3RvclxuXHRcdFx0Y29uc3Qgc2NhbGVGYWN0b3IgPSByZW5kZXJlci5waHlzaWNhbGx5Q29ycmVjdExpZ2h0cyAhPT0gdHJ1ZSA/IE1hdGguUEkgOiAxO1xuXHRcdFx0dW5pZm9ybXMubGlnaHRNYXBJbnRlbnNpdHkudmFsdWUgPSBtYXRlcmlhbC5saWdodE1hcEludGVuc2l0eSAqIHNjYWxlRmFjdG9yO1xuXHRcdH1cblx0XHRpZiAobWF0ZXJpYWwuYW9NYXApIHtcblx0XHRcdHVuaWZvcm1zLmFvTWFwLnZhbHVlID0gbWF0ZXJpYWwuYW9NYXA7XG5cdFx0XHR1bmlmb3Jtcy5hb01hcEludGVuc2l0eS52YWx1ZSA9IG1hdGVyaWFsLmFvTWFwSW50ZW5zaXR5O1xuXHRcdH1cblxuXHRcdC8vIHV2IHJlcGVhdCBhbmQgb2Zmc2V0IHNldHRpbmcgcHJpb3JpdGllc1xuXHRcdC8vIDEuIGNvbG9yIG1hcFxuXHRcdC8vIDIuIHNwZWN1bGFyIG1hcFxuXHRcdC8vIDMuIGRpc3BsYWNlbWVudE1hcCBtYXBcblx0XHQvLyA0LiBub3JtYWwgbWFwXG5cdFx0Ly8gNS4gYnVtcCBtYXBcblx0XHQvLyA2LiByb3VnaG5lc3NNYXAgbWFwXG5cdFx0Ly8gNy4gbWV0YWxuZXNzTWFwIG1hcFxuXHRcdC8vIDguIGFscGhhTWFwIG1hcFxuXHRcdC8vIDkuIGVtaXNzaXZlTWFwIG1hcFxuXHRcdC8vIDEwLiBjbGVhcmNvYXQgbWFwXG5cdFx0Ly8gMTEuIGNsZWFyY29hdCBub3JtYWwgbWFwXG5cdFx0Ly8gMTIuIGNsZWFyY29hdCByb3VnaG5lc3NNYXAgbWFwXG5cdFx0Ly8gMTMuIGlyaWRlc2NlbmNlIG1hcFxuXHRcdC8vIDE0LiBpcmlkZXNjZW5jZSB0aGlja25lc3MgbWFwXG5cdFx0Ly8gMTUuIHNwZWN1bGFyIGludGVuc2l0eSBtYXBcblx0XHQvLyAxNi4gc3BlY3VsYXIgdGludCBtYXBcblx0XHQvLyAxNy4gdHJhbnNtaXNzaW9uIG1hcFxuXHRcdC8vIDE4LiB0aGlja25lc3MgbWFwXG5cblx0XHRsZXQgdXZTY2FsZU1hcDtcblx0XHRpZiAobWF0ZXJpYWwubWFwKSB7XG5cdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwubWFwO1xuXHRcdH0gZWxzZSBpZiAobWF0ZXJpYWwuc3BlY3VsYXJNYXApIHtcblx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5zcGVjdWxhck1hcDtcblx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCkge1xuXHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcDtcblx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsLm5vcm1hbE1hcCkge1xuXHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLm5vcm1hbE1hcDtcblx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsLmJ1bXBNYXApIHtcblx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5idW1wTWFwO1xuXHRcdH0gZWxzZSBpZiAobWF0ZXJpYWwucm91Z2huZXNzTWFwKSB7XG5cdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwucm91Z2huZXNzTWFwO1xuXHRcdH0gZWxzZSBpZiAobWF0ZXJpYWwubWV0YWxuZXNzTWFwKSB7XG5cdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwubWV0YWxuZXNzTWFwO1xuXHRcdH0gZWxzZSBpZiAobWF0ZXJpYWwuYWxwaGFNYXApIHtcblx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5hbHBoYU1hcDtcblx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsLmVtaXNzaXZlTWFwKSB7XG5cdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwuZW1pc3NpdmVNYXA7XG5cdFx0fSBlbHNlIGlmIChtYXRlcmlhbC5jbGVhcmNvYXRNYXApIHtcblx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5jbGVhcmNvYXRNYXA7XG5cdFx0fSBlbHNlIGlmIChtYXRlcmlhbC5jbGVhcmNvYXROb3JtYWxNYXApIHtcblx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5jbGVhcmNvYXROb3JtYWxNYXA7XG5cdFx0fSBlbHNlIGlmIChtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3NNYXApIHtcblx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3NNYXA7XG5cdFx0fSBlbHNlIGlmIChtYXRlcmlhbC5pcmlkZXNjZW5jZU1hcCkge1xuXHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLmlyaWRlc2NlbmNlTWFwO1xuXHRcdH0gZWxzZSBpZiAobWF0ZXJpYWwuaXJpZGVzY2VuY2VUaGlja25lc3NNYXApIHtcblx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcDtcblx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsLnNwZWN1bGFySW50ZW5zaXR5TWFwKSB7XG5cdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwuc3BlY3VsYXJJbnRlbnNpdHlNYXA7XG5cdFx0fSBlbHNlIGlmIChtYXRlcmlhbC5zcGVjdWxhckNvbG9yTWFwKSB7XG5cdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwuc3BlY3VsYXJDb2xvck1hcDtcblx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsLnRyYW5zbWlzc2lvbk1hcCkge1xuXHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLnRyYW5zbWlzc2lvbk1hcDtcblx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsLnRoaWNrbmVzc01hcCkge1xuXHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLnRoaWNrbmVzc01hcDtcblx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsLnNoZWVuQ29sb3JNYXApIHtcblx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5zaGVlbkNvbG9yTWFwO1xuXHRcdH0gZWxzZSBpZiAobWF0ZXJpYWwuc2hlZW5Sb3VnaG5lc3NNYXApIHtcblx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5zaGVlblJvdWdobmVzc01hcDtcblx0XHR9XG5cdFx0aWYgKHV2U2NhbGVNYXAgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Ly8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0XHRcdGlmICh1dlNjYWxlTWFwLmlzV2ViR0xSZW5kZXJUYXJnZXQpIHtcblx0XHRcdFx0dXZTY2FsZU1hcCA9IHV2U2NhbGVNYXAudGV4dHVyZTtcblx0XHRcdH1cblx0XHRcdGlmICh1dlNjYWxlTWFwLm1hdHJpeEF1dG9VcGRhdGUgPT09IHRydWUpIHtcblx0XHRcdFx0dXZTY2FsZU1hcC51cGRhdGVNYXRyaXgoKTtcblx0XHRcdH1cblx0XHRcdHVuaWZvcm1zLnV2VHJhbnNmb3JtLnZhbHVlLmNvcHkodXZTY2FsZU1hcC5tYXRyaXgpO1xuXHRcdH1cblxuXHRcdC8vIHV2IHJlcGVhdCBhbmQgb2Zmc2V0IHNldHRpbmcgcHJpb3JpdGllcyBmb3IgdXYyXG5cdFx0Ly8gMS4gYW8gbWFwXG5cdFx0Ly8gMi4gbGlnaHQgbWFwXG5cblx0XHRsZXQgdXYyU2NhbGVNYXA7XG5cdFx0aWYgKG1hdGVyaWFsLmFvTWFwKSB7XG5cdFx0XHR1djJTY2FsZU1hcCA9IG1hdGVyaWFsLmFvTWFwO1xuXHRcdH0gZWxzZSBpZiAobWF0ZXJpYWwubGlnaHRNYXApIHtcblx0XHRcdHV2MlNjYWxlTWFwID0gbWF0ZXJpYWwubGlnaHRNYXA7XG5cdFx0fVxuXHRcdGlmICh1djJTY2FsZU1hcCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHQvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHRcdFx0aWYgKHV2MlNjYWxlTWFwLmlzV2ViR0xSZW5kZXJUYXJnZXQpIHtcblx0XHRcdFx0dXYyU2NhbGVNYXAgPSB1djJTY2FsZU1hcC50ZXh0dXJlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHV2MlNjYWxlTWFwLm1hdHJpeEF1dG9VcGRhdGUgPT09IHRydWUpIHtcblx0XHRcdFx0dXYyU2NhbGVNYXAudXBkYXRlTWF0cml4KCk7XG5cdFx0XHR9XG5cdFx0XHR1bmlmb3Jtcy51djJUcmFuc2Zvcm0udmFsdWUuY29weSh1djJTY2FsZU1hcC5tYXRyaXgpO1xuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNMaW5lKHVuaWZvcm1zLCBtYXRlcmlhbCkge1xuXHRcdHVuaWZvcm1zLmRpZmZ1c2UudmFsdWUuY29weShtYXRlcmlhbC5jb2xvcik7XG5cdFx0dW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHk7XG5cdH1cblx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zRGFzaCh1bmlmb3JtcywgbWF0ZXJpYWwpIHtcblx0XHR1bmlmb3Jtcy5kYXNoU2l6ZS52YWx1ZSA9IG1hdGVyaWFsLmRhc2hTaXplO1xuXHRcdHVuaWZvcm1zLnRvdGFsU2l6ZS52YWx1ZSA9IG1hdGVyaWFsLmRhc2hTaXplICsgbWF0ZXJpYWwuZ2FwU2l6ZTtcblx0XHR1bmlmb3Jtcy5zY2FsZS52YWx1ZSA9IG1hdGVyaWFsLnNjYWxlO1xuXHR9XG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc1BvaW50cyh1bmlmb3JtcywgbWF0ZXJpYWwsIHBpeGVsUmF0aW8sIGhlaWdodCkge1xuXHRcdHVuaWZvcm1zLmRpZmZ1c2UudmFsdWUuY29weShtYXRlcmlhbC5jb2xvcik7XG5cdFx0dW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHk7XG5cdFx0dW5pZm9ybXMuc2l6ZS52YWx1ZSA9IG1hdGVyaWFsLnNpemUgKiBwaXhlbFJhdGlvO1xuXHRcdHVuaWZvcm1zLnNjYWxlLnZhbHVlID0gaGVpZ2h0ICogMC41O1xuXHRcdGlmIChtYXRlcmlhbC5tYXApIHtcblx0XHRcdHVuaWZvcm1zLm1hcC52YWx1ZSA9IG1hdGVyaWFsLm1hcDtcblx0XHR9XG5cdFx0aWYgKG1hdGVyaWFsLmFscGhhTWFwKSB7XG5cdFx0XHR1bmlmb3Jtcy5hbHBoYU1hcC52YWx1ZSA9IG1hdGVyaWFsLmFscGhhTWFwO1xuXHRcdH1cblx0XHRpZiAobWF0ZXJpYWwuYWxwaGFUZXN0ID4gMCkge1xuXHRcdFx0dW5pZm9ybXMuYWxwaGFUZXN0LnZhbHVlID0gbWF0ZXJpYWwuYWxwaGFUZXN0O1xuXHRcdH1cblxuXHRcdC8vIHV2IHJlcGVhdCBhbmQgb2Zmc2V0IHNldHRpbmcgcHJpb3JpdGllc1xuXHRcdC8vIDEuIGNvbG9yIG1hcFxuXHRcdC8vIDIuIGFscGhhIG1hcFxuXG5cdFx0bGV0IHV2U2NhbGVNYXA7XG5cdFx0aWYgKG1hdGVyaWFsLm1hcCkge1xuXHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLm1hcDtcblx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsLmFscGhhTWFwKSB7XG5cdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwuYWxwaGFNYXA7XG5cdFx0fVxuXHRcdGlmICh1dlNjYWxlTWFwICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGlmICh1dlNjYWxlTWFwLm1hdHJpeEF1dG9VcGRhdGUgPT09IHRydWUpIHtcblx0XHRcdFx0dXZTY2FsZU1hcC51cGRhdGVNYXRyaXgoKTtcblx0XHRcdH1cblx0XHRcdHVuaWZvcm1zLnV2VHJhbnNmb3JtLnZhbHVlLmNvcHkodXZTY2FsZU1hcC5tYXRyaXgpO1xuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNTcHJpdGVzKHVuaWZvcm1zLCBtYXRlcmlhbCkge1xuXHRcdHVuaWZvcm1zLmRpZmZ1c2UudmFsdWUuY29weShtYXRlcmlhbC5jb2xvcik7XG5cdFx0dW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHk7XG5cdFx0dW5pZm9ybXMucm90YXRpb24udmFsdWUgPSBtYXRlcmlhbC5yb3RhdGlvbjtcblx0XHRpZiAobWF0ZXJpYWwubWFwKSB7XG5cdFx0XHR1bmlmb3Jtcy5tYXAudmFsdWUgPSBtYXRlcmlhbC5tYXA7XG5cdFx0fVxuXHRcdGlmIChtYXRlcmlhbC5hbHBoYU1hcCkge1xuXHRcdFx0dW5pZm9ybXMuYWxwaGFNYXAudmFsdWUgPSBtYXRlcmlhbC5hbHBoYU1hcDtcblx0XHR9XG5cdFx0aWYgKG1hdGVyaWFsLmFscGhhVGVzdCA+IDApIHtcblx0XHRcdHVuaWZvcm1zLmFscGhhVGVzdC52YWx1ZSA9IG1hdGVyaWFsLmFscGhhVGVzdDtcblx0XHR9XG5cblx0XHQvLyB1diByZXBlYXQgYW5kIG9mZnNldCBzZXR0aW5nIHByaW9yaXRpZXNcblx0XHQvLyAxLiBjb2xvciBtYXBcblx0XHQvLyAyLiBhbHBoYSBtYXBcblxuXHRcdGxldCB1dlNjYWxlTWFwO1xuXHRcdGlmIChtYXRlcmlhbC5tYXApIHtcblx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5tYXA7XG5cdFx0fSBlbHNlIGlmIChtYXRlcmlhbC5hbHBoYU1hcCkge1xuXHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLmFscGhhTWFwO1xuXHRcdH1cblx0XHRpZiAodXZTY2FsZU1hcCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRpZiAodXZTY2FsZU1hcC5tYXRyaXhBdXRvVXBkYXRlID09PSB0cnVlKSB7XG5cdFx0XHRcdHV2U2NhbGVNYXAudXBkYXRlTWF0cml4KCk7XG5cdFx0XHR9XG5cdFx0XHR1bmlmb3Jtcy51dlRyYW5zZm9ybS52YWx1ZS5jb3B5KHV2U2NhbGVNYXAubWF0cml4KTtcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zUGhvbmcodW5pZm9ybXMsIG1hdGVyaWFsKSB7XG5cdFx0dW5pZm9ybXMuc3BlY3VsYXIudmFsdWUuY29weShtYXRlcmlhbC5zcGVjdWxhcik7XG5cdFx0dW5pZm9ybXMuc2hpbmluZXNzLnZhbHVlID0gTWF0aC5tYXgobWF0ZXJpYWwuc2hpbmluZXNzLCAxZS00KTsgLy8gdG8gcHJldmVudCBwb3coIDAuMCwgMC4wIClcblx0fVxuXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc1Rvb24odW5pZm9ybXMsIG1hdGVyaWFsKSB7XG5cdFx0aWYgKG1hdGVyaWFsLmdyYWRpZW50TWFwKSB7XG5cdFx0XHR1bmlmb3Jtcy5ncmFkaWVudE1hcC52YWx1ZSA9IG1hdGVyaWFsLmdyYWRpZW50TWFwO1xuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNTdGFuZGFyZCh1bmlmb3JtcywgbWF0ZXJpYWwpIHtcblx0XHR1bmlmb3Jtcy5yb3VnaG5lc3MudmFsdWUgPSBtYXRlcmlhbC5yb3VnaG5lc3M7XG5cdFx0dW5pZm9ybXMubWV0YWxuZXNzLnZhbHVlID0gbWF0ZXJpYWwubWV0YWxuZXNzO1xuXHRcdGlmIChtYXRlcmlhbC5yb3VnaG5lc3NNYXApIHtcblx0XHRcdHVuaWZvcm1zLnJvdWdobmVzc01hcC52YWx1ZSA9IG1hdGVyaWFsLnJvdWdobmVzc01hcDtcblx0XHR9XG5cdFx0aWYgKG1hdGVyaWFsLm1ldGFsbmVzc01hcCkge1xuXHRcdFx0dW5pZm9ybXMubWV0YWxuZXNzTWFwLnZhbHVlID0gbWF0ZXJpYWwubWV0YWxuZXNzTWFwO1xuXHRcdH1cblx0XHRjb25zdCBlbnZNYXAgPSBwcm9wZXJ0aWVzLmdldChtYXRlcmlhbCkuZW52TWFwO1xuXHRcdGlmIChlbnZNYXApIHtcblx0XHRcdC8vdW5pZm9ybXMuZW52TWFwLnZhbHVlID0gbWF0ZXJpYWwuZW52TWFwOyAvLyBwYXJ0IG9mIHVuaWZvcm1zIGNvbW1vblxuXHRcdFx0dW5pZm9ybXMuZW52TWFwSW50ZW5zaXR5LnZhbHVlID0gbWF0ZXJpYWwuZW52TWFwSW50ZW5zaXR5O1xuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNQaHlzaWNhbCh1bmlmb3JtcywgbWF0ZXJpYWwsIHRyYW5zbWlzc2lvblJlbmRlclRhcmdldCkge1xuXHRcdHVuaWZvcm1zLmlvci52YWx1ZSA9IG1hdGVyaWFsLmlvcjsgLy8gYWxzbyBwYXJ0IG9mIHVuaWZvcm1zIGNvbW1vblxuXG5cdFx0aWYgKG1hdGVyaWFsLnNoZWVuID4gMCkge1xuXHRcdFx0dW5pZm9ybXMuc2hlZW5Db2xvci52YWx1ZS5jb3B5KG1hdGVyaWFsLnNoZWVuQ29sb3IpLm11bHRpcGx5U2NhbGFyKG1hdGVyaWFsLnNoZWVuKTtcblx0XHRcdHVuaWZvcm1zLnNoZWVuUm91Z2huZXNzLnZhbHVlID0gbWF0ZXJpYWwuc2hlZW5Sb3VnaG5lc3M7XG5cdFx0XHRpZiAobWF0ZXJpYWwuc2hlZW5Db2xvck1hcCkge1xuXHRcdFx0XHR1bmlmb3Jtcy5zaGVlbkNvbG9yTWFwLnZhbHVlID0gbWF0ZXJpYWwuc2hlZW5Db2xvck1hcDtcblx0XHRcdH1cblx0XHRcdGlmIChtYXRlcmlhbC5zaGVlblJvdWdobmVzc01hcCkge1xuXHRcdFx0XHR1bmlmb3Jtcy5zaGVlblJvdWdobmVzc01hcC52YWx1ZSA9IG1hdGVyaWFsLnNoZWVuUm91Z2huZXNzTWFwO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAobWF0ZXJpYWwuY2xlYXJjb2F0ID4gMCkge1xuXHRcdFx0dW5pZm9ybXMuY2xlYXJjb2F0LnZhbHVlID0gbWF0ZXJpYWwuY2xlYXJjb2F0O1xuXHRcdFx0dW5pZm9ybXMuY2xlYXJjb2F0Um91Z2huZXNzLnZhbHVlID0gbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzO1xuXHRcdFx0aWYgKG1hdGVyaWFsLmNsZWFyY29hdE1hcCkge1xuXHRcdFx0XHR1bmlmb3Jtcy5jbGVhcmNvYXRNYXAudmFsdWUgPSBtYXRlcmlhbC5jbGVhcmNvYXRNYXA7XG5cdFx0XHR9XG5cdFx0XHRpZiAobWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzTWFwKSB7XG5cdFx0XHRcdHVuaWZvcm1zLmNsZWFyY29hdFJvdWdobmVzc01hcC52YWx1ZSA9IG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzc01hcDtcblx0XHRcdH1cblx0XHRcdGlmIChtYXRlcmlhbC5jbGVhcmNvYXROb3JtYWxNYXApIHtcblx0XHRcdFx0dW5pZm9ybXMuY2xlYXJjb2F0Tm9ybWFsU2NhbGUudmFsdWUuY29weShtYXRlcmlhbC5jbGVhcmNvYXROb3JtYWxTY2FsZSk7XG5cdFx0XHRcdHVuaWZvcm1zLmNsZWFyY29hdE5vcm1hbE1hcC52YWx1ZSA9IG1hdGVyaWFsLmNsZWFyY29hdE5vcm1hbE1hcDtcblx0XHRcdFx0aWYgKG1hdGVyaWFsLnNpZGUgPT09IEJhY2tTaWRlKSB7XG5cdFx0XHRcdFx0dW5pZm9ybXMuY2xlYXJjb2F0Tm9ybWFsU2NhbGUudmFsdWUubmVnYXRlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKG1hdGVyaWFsLmlyaWRlc2NlbmNlID4gMCkge1xuXHRcdFx0dW5pZm9ybXMuaXJpZGVzY2VuY2UudmFsdWUgPSBtYXRlcmlhbC5pcmlkZXNjZW5jZTtcblx0XHRcdHVuaWZvcm1zLmlyaWRlc2NlbmNlSU9SLnZhbHVlID0gbWF0ZXJpYWwuaXJpZGVzY2VuY2VJT1I7XG5cdFx0XHR1bmlmb3Jtcy5pcmlkZXNjZW5jZVRoaWNrbmVzc01pbmltdW0udmFsdWUgPSBtYXRlcmlhbC5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlWzBdO1xuXHRcdFx0dW5pZm9ybXMuaXJpZGVzY2VuY2VUaGlja25lc3NNYXhpbXVtLnZhbHVlID0gbWF0ZXJpYWwuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZVsxXTtcblx0XHRcdGlmIChtYXRlcmlhbC5pcmlkZXNjZW5jZU1hcCkge1xuXHRcdFx0XHR1bmlmb3Jtcy5pcmlkZXNjZW5jZU1hcC52YWx1ZSA9IG1hdGVyaWFsLmlyaWRlc2NlbmNlTWFwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKG1hdGVyaWFsLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwKSB7XG5cdFx0XHRcdHVuaWZvcm1zLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwLnZhbHVlID0gbWF0ZXJpYWwuaXJpZGVzY2VuY2VUaGlja25lc3NNYXA7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChtYXRlcmlhbC50cmFuc21pc3Npb24gPiAwKSB7XG5cdFx0XHR1bmlmb3Jtcy50cmFuc21pc3Npb24udmFsdWUgPSBtYXRlcmlhbC50cmFuc21pc3Npb247XG5cdFx0XHR1bmlmb3Jtcy50cmFuc21pc3Npb25TYW1wbGVyTWFwLnZhbHVlID0gdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0LnRleHR1cmU7XG5cdFx0XHR1bmlmb3Jtcy50cmFuc21pc3Npb25TYW1wbGVyU2l6ZS52YWx1ZS5zZXQodHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0LndpZHRoLCB0cmFuc21pc3Npb25SZW5kZXJUYXJnZXQuaGVpZ2h0KTtcblx0XHRcdGlmIChtYXRlcmlhbC50cmFuc21pc3Npb25NYXApIHtcblx0XHRcdFx0dW5pZm9ybXMudHJhbnNtaXNzaW9uTWFwLnZhbHVlID0gbWF0ZXJpYWwudHJhbnNtaXNzaW9uTWFwO1xuXHRcdFx0fVxuXHRcdFx0dW5pZm9ybXMudGhpY2tuZXNzLnZhbHVlID0gbWF0ZXJpYWwudGhpY2tuZXNzO1xuXHRcdFx0aWYgKG1hdGVyaWFsLnRoaWNrbmVzc01hcCkge1xuXHRcdFx0XHR1bmlmb3Jtcy50aGlja25lc3NNYXAudmFsdWUgPSBtYXRlcmlhbC50aGlja25lc3NNYXA7XG5cdFx0XHR9XG5cdFx0XHR1bmlmb3Jtcy5hdHRlbnVhdGlvbkRpc3RhbmNlLnZhbHVlID0gbWF0ZXJpYWwuYXR0ZW51YXRpb25EaXN0YW5jZTtcblx0XHRcdHVuaWZvcm1zLmF0dGVudWF0aW9uQ29sb3IudmFsdWUuY29weShtYXRlcmlhbC5hdHRlbnVhdGlvbkNvbG9yKTtcblx0XHR9XG5cdFx0dW5pZm9ybXMuc3BlY3VsYXJJbnRlbnNpdHkudmFsdWUgPSBtYXRlcmlhbC5zcGVjdWxhckludGVuc2l0eTtcblx0XHR1bmlmb3Jtcy5zcGVjdWxhckNvbG9yLnZhbHVlLmNvcHkobWF0ZXJpYWwuc3BlY3VsYXJDb2xvcik7XG5cdFx0aWYgKG1hdGVyaWFsLnNwZWN1bGFySW50ZW5zaXR5TWFwKSB7XG5cdFx0XHR1bmlmb3Jtcy5zcGVjdWxhckludGVuc2l0eU1hcC52YWx1ZSA9IG1hdGVyaWFsLnNwZWN1bGFySW50ZW5zaXR5TWFwO1xuXHRcdH1cblx0XHRpZiAobWF0ZXJpYWwuc3BlY3VsYXJDb2xvck1hcCkge1xuXHRcdFx0dW5pZm9ybXMuc3BlY3VsYXJDb2xvck1hcC52YWx1ZSA9IG1hdGVyaWFsLnNwZWN1bGFyQ29sb3JNYXA7XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc01hdGNhcCh1bmlmb3JtcywgbWF0ZXJpYWwpIHtcblx0XHRpZiAobWF0ZXJpYWwubWF0Y2FwKSB7XG5cdFx0XHR1bmlmb3Jtcy5tYXRjYXAudmFsdWUgPSBtYXRlcmlhbC5tYXRjYXA7XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0Rpc3RhbmNlKHVuaWZvcm1zLCBtYXRlcmlhbCkge1xuXHRcdHVuaWZvcm1zLnJlZmVyZW5jZVBvc2l0aW9uLnZhbHVlLmNvcHkobWF0ZXJpYWwucmVmZXJlbmNlUG9zaXRpb24pO1xuXHRcdHVuaWZvcm1zLm5lYXJEaXN0YW5jZS52YWx1ZSA9IG1hdGVyaWFsLm5lYXJEaXN0YW5jZTtcblx0XHR1bmlmb3Jtcy5mYXJEaXN0YW5jZS52YWx1ZSA9IG1hdGVyaWFsLmZhckRpc3RhbmNlO1xuXHR9XG5cdHJldHVybiB7XG5cdFx0cmVmcmVzaEZvZ1VuaWZvcm1zOiByZWZyZXNoRm9nVW5pZm9ybXMsXG5cdFx0cmVmcmVzaE1hdGVyaWFsVW5pZm9ybXM6IHJlZnJlc2hNYXRlcmlhbFVuaWZvcm1zXG5cdH07XG59XG5cbmZ1bmN0aW9uIFdlYkdMVW5pZm9ybXNHcm91cHMoZ2wsIGluZm8sIGNhcGFiaWxpdGllcywgc3RhdGUpIHtcblx0bGV0IGJ1ZmZlcnMgPSB7fTtcblx0bGV0IHVwZGF0ZUxpc3QgPSB7fTtcblx0bGV0IGFsbG9jYXRlZEJpbmRpbmdQb2ludHMgPSBbXTtcblx0Y29uc3QgbWF4QmluZGluZ1BvaW50cyA9IGNhcGFiaWxpdGllcy5pc1dlYkdMMiA/IGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVU5JRk9STV9CVUZGRVJfQklORElOR1MpIDogMDsgLy8gYmluZGluZyBwb2ludHMgYXJlIGdsb2JhbCB3aGVyZWFzIGJsb2NrIGluZGljZXMgYXJlIHBlciBzaGFkZXIgcHJvZ3JhbVxuXG5cdGZ1bmN0aW9uIGJpbmQodW5pZm9ybXNHcm91cCwgcHJvZ3JhbSkge1xuXHRcdGNvbnN0IHdlYmdsUHJvZ3JhbSA9IHByb2dyYW0ucHJvZ3JhbTtcblx0XHRzdGF0ZS51bmlmb3JtQmxvY2tCaW5kaW5nKHVuaWZvcm1zR3JvdXAsIHdlYmdsUHJvZ3JhbSk7XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlKHVuaWZvcm1zR3JvdXAsIHByb2dyYW0pIHtcblx0XHRsZXQgYnVmZmVyID0gYnVmZmVyc1t1bmlmb3Jtc0dyb3VwLmlkXTtcblx0XHRpZiAoYnVmZmVyID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHByZXBhcmVVbmlmb3Jtc0dyb3VwKHVuaWZvcm1zR3JvdXApO1xuXHRcdFx0YnVmZmVyID0gY3JlYXRlQnVmZmVyKHVuaWZvcm1zR3JvdXApO1xuXHRcdFx0YnVmZmVyc1t1bmlmb3Jtc0dyb3VwLmlkXSA9IGJ1ZmZlcjtcblx0XHRcdHVuaWZvcm1zR3JvdXAuYWRkRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIG9uVW5pZm9ybXNHcm91cHNEaXNwb3NlKTtcblx0XHR9XG5cblx0XHQvLyBlbnN1cmUgdG8gdXBkYXRlIHRoZSBiaW5kaW5nIHBvaW50cy9ibG9jayBpbmRpY2VzIG1hcHBpbmcgZm9yIHRoaXMgcHJvZ3JhbVxuXG5cdFx0Y29uc3Qgd2ViZ2xQcm9ncmFtID0gcHJvZ3JhbS5wcm9ncmFtO1xuXHRcdHN0YXRlLnVwZGF0ZVVCT01hcHBpbmcodW5pZm9ybXNHcm91cCwgd2ViZ2xQcm9ncmFtKTtcblxuXHRcdC8vIHVwZGF0ZSBVQk8gb25jZSBwZXIgZnJhbWVcblxuXHRcdGNvbnN0IGZyYW1lID0gaW5mby5yZW5kZXIuZnJhbWU7XG5cdFx0aWYgKHVwZGF0ZUxpc3RbdW5pZm9ybXNHcm91cC5pZF0gIT09IGZyYW1lKSB7XG5cdFx0XHR1cGRhdGVCdWZmZXJEYXRhKHVuaWZvcm1zR3JvdXApO1xuXHRcdFx0dXBkYXRlTGlzdFt1bmlmb3Jtc0dyb3VwLmlkXSA9IGZyYW1lO1xuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVCdWZmZXIodW5pZm9ybXNHcm91cCkge1xuXHRcdC8vIHRoZSBzZXR1cCBvZiBhbiBVQk8gaXMgaW5kZXBlbmRlbnQgb2YgYSBwYXJ0aWN1bGFyIHNoYWRlciBwcm9ncmFtIGJ1dCBnbG9iYWxcblxuXHRcdGNvbnN0IGJpbmRpbmdQb2ludEluZGV4ID0gYWxsb2NhdGVCaW5kaW5nUG9pbnRJbmRleCgpO1xuXHRcdHVuaWZvcm1zR3JvdXAuX19iaW5kaW5nUG9pbnRJbmRleCA9IGJpbmRpbmdQb2ludEluZGV4O1xuXHRcdGNvbnN0IGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXHRcdGNvbnN0IHNpemUgPSB1bmlmb3Jtc0dyb3VwLl9fc2l6ZTtcblx0XHRjb25zdCB1c2FnZSA9IHVuaWZvcm1zR3JvdXAudXNhZ2U7XG5cdFx0Z2wuYmluZEJ1ZmZlcihnbC5VTklGT1JNX0JVRkZFUiwgYnVmZmVyKTtcblx0XHRnbC5idWZmZXJEYXRhKGdsLlVOSUZPUk1fQlVGRkVSLCBzaXplLCB1c2FnZSk7XG5cdFx0Z2wuYmluZEJ1ZmZlcihnbC5VTklGT1JNX0JVRkZFUiwgbnVsbCk7XG5cdFx0Z2wuYmluZEJ1ZmZlckJhc2UoZ2wuVU5JRk9STV9CVUZGRVIsIGJpbmRpbmdQb2ludEluZGV4LCBidWZmZXIpO1xuXHRcdHJldHVybiBidWZmZXI7XG5cdH1cblx0ZnVuY3Rpb24gYWxsb2NhdGVCaW5kaW5nUG9pbnRJbmRleCgpIHtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG1heEJpbmRpbmdQb2ludHM7IGkrKykge1xuXHRcdFx0aWYgKGFsbG9jYXRlZEJpbmRpbmdQb2ludHMuaW5kZXhPZihpKSA9PT0gLTEpIHtcblx0XHRcdFx0YWxsb2NhdGVkQmluZGluZ1BvaW50cy5wdXNoKGkpO1xuXHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Y29uc29sZS5lcnJvcignVEhSRUUuV2ViR0xSZW5kZXJlcjogTWF4aW11bSBudW1iZXIgb2Ygc2ltdWx0YW5lb3VzbHkgdXNhYmxlIHVuaWZvcm1zIGdyb3VwcyByZWFjaGVkLicpO1xuXHRcdHJldHVybiAwO1xuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUJ1ZmZlckRhdGEodW5pZm9ybXNHcm91cCkge1xuXHRcdGNvbnN0IGJ1ZmZlciA9IGJ1ZmZlcnNbdW5pZm9ybXNHcm91cC5pZF07XG5cdFx0Y29uc3QgdW5pZm9ybXMgPSB1bmlmb3Jtc0dyb3VwLnVuaWZvcm1zO1xuXHRcdGNvbnN0IGNhY2hlID0gdW5pZm9ybXNHcm91cC5fX2NhY2hlO1xuXHRcdGdsLmJpbmRCdWZmZXIoZ2wuVU5JRk9STV9CVUZGRVIsIGJ1ZmZlcik7XG5cdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gdW5pZm9ybXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0Y29uc3QgdW5pZm9ybSA9IHVuaWZvcm1zW2ldO1xuXG5cdFx0XHQvLyBwYXJ0bHkgdXBkYXRlIHRoZSBidWZmZXIgaWYgbmVjZXNzYXJ5XG5cblx0XHRcdGlmIChoYXNVbmlmb3JtQ2hhbmdlZCh1bmlmb3JtLCBpLCBjYWNoZSkgPT09IHRydWUpIHtcblx0XHRcdFx0Y29uc3QgdmFsdWUgPSB1bmlmb3JtLnZhbHVlO1xuXHRcdFx0XHRjb25zdCBvZmZzZXQgPSB1bmlmb3JtLl9fb2Zmc2V0O1xuXHRcdFx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRcdHVuaWZvcm0uX19kYXRhWzBdID0gdmFsdWU7XG5cdFx0XHRcdFx0Z2wuYnVmZmVyU3ViRGF0YShnbC5VTklGT1JNX0JVRkZFUiwgb2Zmc2V0LCB1bmlmb3JtLl9fZGF0YSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKHVuaWZvcm0udmFsdWUuaXNNYXRyaXgzKSB7XG5cdFx0XHRcdFx0XHQvLyBtYW51YWxseSBjb252ZXJ0aW5nIDN4MyB0byAzeDRcblxuXHRcdFx0XHRcdFx0dW5pZm9ybS5fX2RhdGFbMF0gPSB1bmlmb3JtLnZhbHVlLmVsZW1lbnRzWzBdO1xuXHRcdFx0XHRcdFx0dW5pZm9ybS5fX2RhdGFbMV0gPSB1bmlmb3JtLnZhbHVlLmVsZW1lbnRzWzFdO1xuXHRcdFx0XHRcdFx0dW5pZm9ybS5fX2RhdGFbMl0gPSB1bmlmb3JtLnZhbHVlLmVsZW1lbnRzWzJdO1xuXHRcdFx0XHRcdFx0dW5pZm9ybS5fX2RhdGFbM10gPSB1bmlmb3JtLnZhbHVlLmVsZW1lbnRzWzBdO1xuXHRcdFx0XHRcdFx0dW5pZm9ybS5fX2RhdGFbNF0gPSB1bmlmb3JtLnZhbHVlLmVsZW1lbnRzWzNdO1xuXHRcdFx0XHRcdFx0dW5pZm9ybS5fX2RhdGFbNV0gPSB1bmlmb3JtLnZhbHVlLmVsZW1lbnRzWzRdO1xuXHRcdFx0XHRcdFx0dW5pZm9ybS5fX2RhdGFbNl0gPSB1bmlmb3JtLnZhbHVlLmVsZW1lbnRzWzVdO1xuXHRcdFx0XHRcdFx0dW5pZm9ybS5fX2RhdGFbN10gPSB1bmlmb3JtLnZhbHVlLmVsZW1lbnRzWzBdO1xuXHRcdFx0XHRcdFx0dW5pZm9ybS5fX2RhdGFbOF0gPSB1bmlmb3JtLnZhbHVlLmVsZW1lbnRzWzZdO1xuXHRcdFx0XHRcdFx0dW5pZm9ybS5fX2RhdGFbOV0gPSB1bmlmb3JtLnZhbHVlLmVsZW1lbnRzWzddO1xuXHRcdFx0XHRcdFx0dW5pZm9ybS5fX2RhdGFbMTBdID0gdW5pZm9ybS52YWx1ZS5lbGVtZW50c1s4XTtcblx0XHRcdFx0XHRcdHVuaWZvcm0uX19kYXRhWzExXSA9IHVuaWZvcm0udmFsdWUuZWxlbWVudHNbMF07XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHZhbHVlLnRvQXJyYXkodW5pZm9ybS5fX2RhdGEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRnbC5idWZmZXJTdWJEYXRhKGdsLlVOSUZPUk1fQlVGRkVSLCBvZmZzZXQsIHVuaWZvcm0uX19kYXRhKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRnbC5iaW5kQnVmZmVyKGdsLlVOSUZPUk1fQlVGRkVSLCBudWxsKTtcblx0fVxuXHRmdW5jdGlvbiBoYXNVbmlmb3JtQ2hhbmdlZCh1bmlmb3JtLCBpbmRleCwgY2FjaGUpIHtcblx0XHRjb25zdCB2YWx1ZSA9IHVuaWZvcm0udmFsdWU7XG5cdFx0aWYgKGNhY2hlW2luZGV4XSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHQvLyBjYWNoZSBlbnRyeSBkb2VzIG5vdCBleGlzdCBzbyBmYXJcblxuXHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0Y2FjaGVbaW5kZXhdID0gdmFsdWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjYWNoZVtpbmRleF0gPSB2YWx1ZS5jbG9uZSgpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGNvbXBhcmUgY3VycmVudCB2YWx1ZSB3aXRoIGNhY2hlZCBlbnRyeVxuXG5cdFx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRpZiAoY2FjaGVbaW5kZXhdICE9PSB2YWx1ZSkge1xuXHRcdFx0XHRcdGNhY2hlW2luZGV4XSA9IHZhbHVlO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zdCBjYWNoZWRPYmplY3QgPSBjYWNoZVtpbmRleF07XG5cdFx0XHRcdGlmIChjYWNoZWRPYmplY3QuZXF1YWxzKHZhbHVlKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRjYWNoZWRPYmplY3QuY29weSh2YWx1ZSk7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdGZ1bmN0aW9uIHByZXBhcmVVbmlmb3Jtc0dyb3VwKHVuaWZvcm1zR3JvdXApIHtcblx0XHQvLyBkZXRlcm1pbmUgdG90YWwgYnVmZmVyIHNpemUgYWNjb3JkaW5nIHRvIHRoZSBTVEQxNDAgbGF5b3V0XG5cdFx0Ly8gSGludDogU1REMTQwIGlzIHRoZSBvbmx5IHN1cHBvcnRlZCBsYXlvdXQgaW4gV2ViR0wgMlxuXG5cdFx0Y29uc3QgdW5pZm9ybXMgPSB1bmlmb3Jtc0dyb3VwLnVuaWZvcm1zO1xuXHRcdGxldCBvZmZzZXQgPSAwOyAvLyBnbG9iYWwgYnVmZmVyIG9mZnNldCBpbiBieXRlc1xuXHRcdGNvbnN0IGNodW5rU2l6ZSA9IDE2OyAvLyBzaXplIG9mIGEgY2h1bmsgaW4gYnl0ZXNcblx0XHRsZXQgY2h1bmtPZmZzZXQgPSAwOyAvLyBvZmZzZXQgd2l0aGluIGEgc2luZ2xlIGNodW5rIGluIGJ5dGVzXG5cblx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHVuaWZvcm1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0Y29uc3QgdW5pZm9ybSA9IHVuaWZvcm1zW2ldO1xuXHRcdFx0Y29uc3QgaW5mbyA9IGdldFVuaWZvcm1TaXplKHVuaWZvcm0pO1xuXG5cdFx0XHQvLyB0aGUgZm9sbG93aW5nIHR3byBwcm9wZXJ0aWVzIHdpbGwgYmUgdXNlZCBmb3IgcGFydGlhbCBidWZmZXIgdXBkYXRlc1xuXG5cdFx0XHR1bmlmb3JtLl9fZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoaW5mby5zdG9yYWdlIC8gRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UKTtcblx0XHRcdHVuaWZvcm0uX19vZmZzZXQgPSBvZmZzZXQ7XG5cblx0XHRcdC8vXG5cblx0XHRcdGlmIChpID4gMCkge1xuXHRcdFx0XHRjaHVua09mZnNldCA9IG9mZnNldCAlIGNodW5rU2l6ZTtcblx0XHRcdFx0Y29uc3QgcmVtYWluaW5nU2l6ZUluQ2h1bmsgPSBjaHVua1NpemUgLSBjaHVua09mZnNldDtcblxuXHRcdFx0XHQvLyBjaGVjayBmb3IgY2h1bmsgb3ZlcmZsb3dcblxuXHRcdFx0XHRpZiAoY2h1bmtPZmZzZXQgIT09IDAgJiYgcmVtYWluaW5nU2l6ZUluQ2h1bmsgLSBpbmZvLmJvdW5kYXJ5IDwgMCkge1xuXHRcdFx0XHRcdC8vIGFkZCBwYWRkaW5nIGFuZCBhZGp1c3Qgb2Zmc2V0XG5cblx0XHRcdFx0XHRvZmZzZXQgKz0gY2h1bmtTaXplIC0gY2h1bmtPZmZzZXQ7XG5cdFx0XHRcdFx0dW5pZm9ybS5fX29mZnNldCA9IG9mZnNldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0b2Zmc2V0ICs9IGluZm8uc3RvcmFnZTtcblx0XHR9XG5cblx0XHQvLyBlbnN1cmUgY29ycmVjdCBmaW5hbCBwYWRkaW5nXG5cblx0XHRjaHVua09mZnNldCA9IG9mZnNldCAlIGNodW5rU2l6ZTtcblx0XHRpZiAoY2h1bmtPZmZzZXQgPiAwKSBvZmZzZXQgKz0gY2h1bmtTaXplIC0gY2h1bmtPZmZzZXQ7XG5cblx0XHQvL1xuXG5cdFx0dW5pZm9ybXNHcm91cC5fX3NpemUgPSBvZmZzZXQ7XG5cdFx0dW5pZm9ybXNHcm91cC5fX2NhY2hlID0ge307XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0ZnVuY3Rpb24gZ2V0VW5pZm9ybVNpemUodW5pZm9ybSkge1xuXHRcdGNvbnN0IHZhbHVlID0gdW5pZm9ybS52YWx1ZTtcblx0XHRjb25zdCBpbmZvID0ge1xuXHRcdFx0Ym91bmRhcnk6IDAsXG5cdFx0XHQvLyBieXRlc1xuXHRcdFx0c3RvcmFnZTogMCAvLyBieXRlc1xuXHRcdH07XG5cblx0XHQvLyBkZXRlcm1pbmUgc2l6ZXMgYWNjb3JkaW5nIHRvIFNURDE0MFxuXG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdC8vIGZsb2F0L2ludFxuXG5cdFx0XHRpbmZvLmJvdW5kYXJ5ID0gNDtcblx0XHRcdGluZm8uc3RvcmFnZSA9IDQ7XG5cdFx0fSBlbHNlIGlmICh2YWx1ZS5pc1ZlY3RvcjIpIHtcblx0XHRcdC8vIHZlYzJcblxuXHRcdFx0aW5mby5ib3VuZGFyeSA9IDg7XG5cdFx0XHRpbmZvLnN0b3JhZ2UgPSA4O1xuXHRcdH0gZWxzZSBpZiAodmFsdWUuaXNWZWN0b3IzIHx8IHZhbHVlLmlzQ29sb3IpIHtcblx0XHRcdC8vIHZlYzNcblxuXHRcdFx0aW5mby5ib3VuZGFyeSA9IDE2O1xuXHRcdFx0aW5mby5zdG9yYWdlID0gMTI7IC8vIGV2aWw6IHZlYzMgbXVzdCBzdGFydCBvbiBhIDE2LWJ5dGUgYm91bmRhcnkgYnV0IGl0IG9ubHkgY29uc3VtZXMgMTIgYnl0ZXNcblx0XHR9IGVsc2UgaWYgKHZhbHVlLmlzVmVjdG9yNCkge1xuXHRcdFx0Ly8gdmVjNFxuXG5cdFx0XHRpbmZvLmJvdW5kYXJ5ID0gMTY7XG5cdFx0XHRpbmZvLnN0b3JhZ2UgPSAxNjtcblx0XHR9IGVsc2UgaWYgKHZhbHVlLmlzTWF0cml4Mykge1xuXHRcdFx0Ly8gbWF0MyAoaW4gU1REMTQwIGEgM3gzIG1hdHJpeCBpcyByZXByZXNlbnRlZCBhcyAzeDQpXG5cblx0XHRcdGluZm8uYm91bmRhcnkgPSA0ODtcblx0XHRcdGluZm8uc3RvcmFnZSA9IDQ4O1xuXHRcdH0gZWxzZSBpZiAodmFsdWUuaXNNYXRyaXg0KSB7XG5cdFx0XHQvLyBtYXQ0XG5cblx0XHRcdGluZm8uYm91bmRhcnkgPSA2NDtcblx0XHRcdGluZm8uc3RvcmFnZSA9IDY0O1xuXHRcdH0gZWxzZSBpZiAodmFsdWUuaXNUZXh0dXJlKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgc2FtcGxlcnMgY2FuIG5vdCBiZSBwYXJ0IG9mIGFuIHVuaWZvcm1zIGdyb3VwLicpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFVuc3VwcG9ydGVkIHVuaWZvcm0gdmFsdWUgdHlwZS4nLCB2YWx1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiBpbmZvO1xuXHR9XG5cdGZ1bmN0aW9uIG9uVW5pZm9ybXNHcm91cHNEaXNwb3NlKGV2ZW50KSB7XG5cdFx0Y29uc3QgdW5pZm9ybXNHcm91cCA9IGV2ZW50LnRhcmdldDtcblx0XHR1bmlmb3Jtc0dyb3VwLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBvblVuaWZvcm1zR3JvdXBzRGlzcG9zZSk7XG5cdFx0Y29uc3QgaW5kZXggPSBhbGxvY2F0ZWRCaW5kaW5nUG9pbnRzLmluZGV4T2YodW5pZm9ybXNHcm91cC5fX2JpbmRpbmdQb2ludEluZGV4KTtcblx0XHRhbGxvY2F0ZWRCaW5kaW5nUG9pbnRzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0Z2wuZGVsZXRlQnVmZmVyKGJ1ZmZlcnNbdW5pZm9ybXNHcm91cC5pZF0pO1xuXHRcdGRlbGV0ZSBidWZmZXJzW3VuaWZvcm1zR3JvdXAuaWRdO1xuXHRcdGRlbGV0ZSB1cGRhdGVMaXN0W3VuaWZvcm1zR3JvdXAuaWRdO1xuXHR9XG5cdGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG5cdFx0Zm9yIChjb25zdCBpZCBpbiBidWZmZXJzKSB7XG5cdFx0XHRnbC5kZWxldGVCdWZmZXIoYnVmZmVyc1tpZF0pO1xuXHRcdH1cblx0XHRhbGxvY2F0ZWRCaW5kaW5nUG9pbnRzID0gW107XG5cdFx0YnVmZmVycyA9IHt9O1xuXHRcdHVwZGF0ZUxpc3QgPSB7fTtcblx0fVxuXHRyZXR1cm4ge1xuXHRcdGJpbmQ6IGJpbmQsXG5cdFx0dXBkYXRlOiB1cGRhdGUsXG5cdFx0ZGlzcG9zZTogZGlzcG9zZVxuXHR9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDYW52YXNFbGVtZW50KCkge1xuXHRjb25zdCBjYW52YXMgPSBjcmVhdGVFbGVtZW50TlMoJ2NhbnZhcycpO1xuXHRjYW52YXMuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cdHJldHVybiBjYW52YXM7XG59XG5mdW5jdGlvbiBXZWJHTFJlbmRlcmVyKHBhcmFtZXRlcnMgPSB7fSkge1xuXHR0aGlzLmlzV2ViR0xSZW5kZXJlciA9IHRydWU7XG5cdGNvbnN0IF9jYW52YXMgPSBwYXJhbWV0ZXJzLmNhbnZhcyAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5jYW52YXMgOiBjcmVhdGVDYW52YXNFbGVtZW50KCksXG5cdFx0X2NvbnRleHQgPSBwYXJhbWV0ZXJzLmNvbnRleHQgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuY29udGV4dCA6IG51bGwsXG5cdFx0X2RlcHRoID0gcGFyYW1ldGVycy5kZXB0aCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5kZXB0aCA6IHRydWUsXG5cdFx0X3N0ZW5jaWwgPSBwYXJhbWV0ZXJzLnN0ZW5jaWwgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuc3RlbmNpbCA6IHRydWUsXG5cdFx0X2FudGlhbGlhcyA9IHBhcmFtZXRlcnMuYW50aWFsaWFzICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmFudGlhbGlhcyA6IGZhbHNlLFxuXHRcdF9wcmVtdWx0aXBsaWVkQWxwaGEgPSBwYXJhbWV0ZXJzLnByZW11bHRpcGxpZWRBbHBoYSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wcmVtdWx0aXBsaWVkQWxwaGEgOiB0cnVlLFxuXHRcdF9wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgPSBwYXJhbWV0ZXJzLnByZXNlcnZlRHJhd2luZ0J1ZmZlciAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgOiBmYWxzZSxcblx0XHRfcG93ZXJQcmVmZXJlbmNlID0gcGFyYW1ldGVycy5wb3dlclByZWZlcmVuY2UgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMucG93ZXJQcmVmZXJlbmNlIDogJ2RlZmF1bHQnLFxuXHRcdF9mYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0ID0gcGFyYW1ldGVycy5mYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0ICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQgOiBmYWxzZTtcblx0bGV0IF9hbHBoYTtcblx0aWYgKF9jb250ZXh0ICE9PSBudWxsKSB7XG5cdFx0X2FscGhhID0gX2NvbnRleHQuZ2V0Q29udGV4dEF0dHJpYnV0ZXMoKS5hbHBoYTtcblx0fSBlbHNlIHtcblx0XHRfYWxwaGEgPSBwYXJhbWV0ZXJzLmFscGhhICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmFscGhhIDogZmFsc2U7XG5cdH1cblx0bGV0IGN1cnJlbnRSZW5kZXJMaXN0ID0gbnVsbDtcblx0bGV0IGN1cnJlbnRSZW5kZXJTdGF0ZSA9IG51bGw7XG5cblx0Ly8gcmVuZGVyKCkgY2FuIGJlIGNhbGxlZCBmcm9tIHdpdGhpbiBhIGNhbGxiYWNrIHRyaWdnZXJlZCBieSBhbm90aGVyIHJlbmRlci5cblx0Ly8gV2UgdHJhY2sgdGhpcyBzbyB0aGF0IHRoZSBuZXN0ZWQgcmVuZGVyIGNhbGwgZ2V0cyBpdHMgbGlzdCBhbmQgc3RhdGUgaXNvbGF0ZWQgZnJvbSB0aGUgcGFyZW50IHJlbmRlciBjYWxsLlxuXG5cdGNvbnN0IHJlbmRlckxpc3RTdGFjayA9IFtdO1xuXHRjb25zdCByZW5kZXJTdGF0ZVN0YWNrID0gW107XG5cblx0Ly8gcHVibGljIHByb3BlcnRpZXNcblxuXHR0aGlzLmRvbUVsZW1lbnQgPSBfY2FudmFzO1xuXG5cdC8vIERlYnVnIGNvbmZpZ3VyYXRpb24gY29udGFpbmVyXG5cdHRoaXMuZGVidWcgPSB7XG5cdFx0LyoqXG5cdFx0ICogRW5hYmxlcyBlcnJvciBjaGVja2luZyBhbmQgcmVwb3J0aW5nIHdoZW4gc2hhZGVyIHByb2dyYW1zIGFyZSBiZWluZyBjb21waWxlZFxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqL1xuXHRcdGNoZWNrU2hhZGVyRXJyb3JzOiB0cnVlXG5cdH07XG5cblx0Ly8gY2xlYXJpbmdcblxuXHR0aGlzLmF1dG9DbGVhciA9IHRydWU7XG5cdHRoaXMuYXV0b0NsZWFyQ29sb3IgPSB0cnVlO1xuXHR0aGlzLmF1dG9DbGVhckRlcHRoID0gdHJ1ZTtcblx0dGhpcy5hdXRvQ2xlYXJTdGVuY2lsID0gdHJ1ZTtcblxuXHQvLyBzY2VuZSBncmFwaFxuXG5cdHRoaXMuc29ydE9iamVjdHMgPSB0cnVlO1xuXG5cdC8vIHVzZXItZGVmaW5lZCBjbGlwcGluZ1xuXG5cdHRoaXMuY2xpcHBpbmdQbGFuZXMgPSBbXTtcblx0dGhpcy5sb2NhbENsaXBwaW5nRW5hYmxlZCA9IGZhbHNlO1xuXG5cdC8vIHBoeXNpY2FsbHkgYmFzZWQgc2hhZGluZ1xuXG5cdHRoaXMub3V0cHV0RW5jb2RpbmcgPSBMaW5lYXJFbmNvZGluZztcblxuXHQvLyBwaHlzaWNhbCBsaWdodHNcblxuXHR0aGlzLnBoeXNpY2FsbHlDb3JyZWN0TGlnaHRzID0gZmFsc2U7XG5cblx0Ly8gdG9uZSBtYXBwaW5nXG5cblx0dGhpcy50b25lTWFwcGluZyA9IE5vVG9uZU1hcHBpbmc7XG5cdHRoaXMudG9uZU1hcHBpbmdFeHBvc3VyZSA9IDEuMDtcblxuXHQvL1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcblx0XHQvLyBAZGVwcmVjYXRlZCBzaW5jZSByMTM2LCAwZTIxMDg4MTAyYjRkZTdlMGEwYTMzMTQwNjIwYjdhMzQyNGI5ZTZkXG5cblx0XHRnYW1tYUZhY3Rvcjoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogLmdhbW1hRmFjdG9yIGhhcyBiZWVuIHJlbW92ZWQuJyk7XG5cdFx0XHRcdHJldHVybiAyO1xuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5nYW1tYUZhY3RvciBoYXMgYmVlbiByZW1vdmVkLicpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0Ly8gaW50ZXJuYWwgcHJvcGVydGllc1xuXG5cdGNvbnN0IF90aGlzID0gdGhpcztcblx0bGV0IF9pc0NvbnRleHRMb3N0ID0gZmFsc2U7XG5cblx0Ly8gaW50ZXJuYWwgc3RhdGUgY2FjaGVcblxuXHRsZXQgX2N1cnJlbnRBY3RpdmVDdWJlRmFjZSA9IDA7XG5cdGxldCBfY3VycmVudEFjdGl2ZU1pcG1hcExldmVsID0gMDtcblx0bGV0IF9jdXJyZW50UmVuZGVyVGFyZ2V0ID0gbnVsbDtcblx0bGV0IF9jdXJyZW50TWF0ZXJpYWxJZCA9IC0xO1xuXHRsZXQgX2N1cnJlbnRDYW1lcmEgPSBudWxsO1xuXHRjb25zdCBfY3VycmVudFZpZXdwb3J0ID0gbmV3IFZlY3RvcjQoKTtcblx0Y29uc3QgX2N1cnJlbnRTY2lzc29yID0gbmV3IFZlY3RvcjQoKTtcblx0bGV0IF9jdXJyZW50U2Npc3NvclRlc3QgPSBudWxsO1xuXG5cdC8vXG5cblx0bGV0IF93aWR0aCA9IF9jYW52YXMud2lkdGg7XG5cdGxldCBfaGVpZ2h0ID0gX2NhbnZhcy5oZWlnaHQ7XG5cdGxldCBfcGl4ZWxSYXRpbyA9IDE7XG5cdGxldCBfb3BhcXVlU29ydCA9IG51bGw7XG5cdGxldCBfdHJhbnNwYXJlbnRTb3J0ID0gbnVsbDtcblx0Y29uc3QgX3ZpZXdwb3J0ID0gbmV3IFZlY3RvcjQoMCwgMCwgX3dpZHRoLCBfaGVpZ2h0KTtcblx0Y29uc3QgX3NjaXNzb3IgPSBuZXcgVmVjdG9yNCgwLCAwLCBfd2lkdGgsIF9oZWlnaHQpO1xuXHRsZXQgX3NjaXNzb3JUZXN0ID0gZmFsc2U7XG5cblx0Ly8gZnJ1c3R1bVxuXG5cdGNvbnN0IF9mcnVzdHVtID0gbmV3IEZydXN0dW0oKTtcblxuXHQvLyBjbGlwcGluZ1xuXG5cdGxldCBfY2xpcHBpbmdFbmFibGVkID0gZmFsc2U7XG5cdGxldCBfbG9jYWxDbGlwcGluZ0VuYWJsZWQgPSBmYWxzZTtcblxuXHQvLyB0cmFuc21pc3Npb25cblxuXHRsZXQgX3RyYW5zbWlzc2lvblJlbmRlclRhcmdldCA9IG51bGw7XG5cblx0Ly8gY2FtZXJhIG1hdHJpY2VzIGNhY2hlXG5cblx0Y29uc3QgX3Byb2pTY3JlZW5NYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuXHRjb25zdCBfdmVjdG9yMiA9IG5ldyBWZWN0b3IyKCk7XG5cdGNvbnN0IF92ZWN0b3IzID0gbmV3IFZlY3RvcjMoKTtcblx0Y29uc3QgX2VtcHR5U2NlbmUgPSB7XG5cdFx0YmFja2dyb3VuZDogbnVsbCxcblx0XHRmb2c6IG51bGwsXG5cdFx0ZW52aXJvbm1lbnQ6IG51bGwsXG5cdFx0b3ZlcnJpZGVNYXRlcmlhbDogbnVsbCxcblx0XHRpc1NjZW5lOiB0cnVlXG5cdH07XG5cdGZ1bmN0aW9uIGdldFRhcmdldFBpeGVsUmF0aW8oKSB7XG5cdFx0cmV0dXJuIF9jdXJyZW50UmVuZGVyVGFyZ2V0ID09PSBudWxsID8gX3BpeGVsUmF0aW8gOiAxO1xuXHR9XG5cblx0Ly8gaW5pdGlhbGl6ZVxuXG5cdGxldCBfZ2wgPSBfY29udGV4dDtcblx0ZnVuY3Rpb24gZ2V0Q29udGV4dChjb250ZXh0TmFtZXMsIGNvbnRleHRBdHRyaWJ1dGVzKSB7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjb250ZXh0TmFtZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IGNvbnRleHROYW1lID0gY29udGV4dE5hbWVzW2ldO1xuXHRcdFx0Y29uc3QgY29udGV4dCA9IF9jYW52YXMuZ2V0Q29udGV4dChjb250ZXh0TmFtZSwgY29udGV4dEF0dHJpYnV0ZXMpO1xuXHRcdFx0aWYgKGNvbnRleHQgIT09IG51bGwpIHJldHVybiBjb250ZXh0O1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHR0cnkge1xuXHRcdGNvbnN0IGNvbnRleHRBdHRyaWJ1dGVzID0ge1xuXHRcdFx0YWxwaGE6IHRydWUsXG5cdFx0XHRkZXB0aDogX2RlcHRoLFxuXHRcdFx0c3RlbmNpbDogX3N0ZW5jaWwsXG5cdFx0XHRhbnRpYWxpYXM6IF9hbnRpYWxpYXMsXG5cdFx0XHRwcmVtdWx0aXBsaWVkQWxwaGE6IF9wcmVtdWx0aXBsaWVkQWxwaGEsXG5cdFx0XHRwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IF9wcmVzZXJ2ZURyYXdpbmdCdWZmZXIsXG5cdFx0XHRwb3dlclByZWZlcmVuY2U6IF9wb3dlclByZWZlcmVuY2UsXG5cdFx0XHRmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0OiBfZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdFxuXHRcdH07XG5cblx0XHQvLyBPZmZzY3JlZW5DYW52YXMgZG9lcyBub3QgaGF2ZSBzZXRBdHRyaWJ1dGUsIHNlZSAjMjI4MTFcblx0XHRpZiAoJ3NldEF0dHJpYnV0ZScgaW4gX2NhbnZhcykgX2NhbnZhcy5zZXRBdHRyaWJ1dGUoJ2RhdGEtZW5naW5lJywgYHRocmVlLmpzIHIke1JFVklTSU9OfWApO1xuXG5cdFx0Ly8gZXZlbnQgbGlzdGVuZXJzIG11c3QgYmUgcmVnaXN0ZXJlZCBiZWZvcmUgV2ViR0wgY29udGV4dCBpcyBjcmVhdGVkLCBzZWUgIzEyNzUzXG5cdFx0X2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRsb3N0Jywgb25Db250ZXh0TG9zdCwgZmFsc2UpO1xuXHRcdF9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0cmVzdG9yZWQnLCBvbkNvbnRleHRSZXN0b3JlLCBmYWxzZSk7XG5cdFx0X2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRjcmVhdGlvbmVycm9yJywgb25Db250ZXh0Q3JlYXRpb25FcnJvciwgZmFsc2UpO1xuXHRcdGlmIChfZ2wgPT09IG51bGwpIHtcblx0XHRcdGNvbnN0IGNvbnRleHROYW1lcyA9IFsnd2ViZ2wyJywgJ3dlYmdsJywgJ2V4cGVyaW1lbnRhbC13ZWJnbCddO1xuXHRcdFx0aWYgKF90aGlzLmlzV2ViR0wxUmVuZGVyZXIgPT09IHRydWUpIHtcblx0XHRcdFx0Y29udGV4dE5hbWVzLnNoaWZ0KCk7XG5cdFx0XHR9XG5cdFx0XHRfZ2wgPSBnZXRDb250ZXh0KGNvbnRleHROYW1lcywgY29udGV4dEF0dHJpYnV0ZXMpO1xuXHRcdFx0aWYgKF9nbCA9PT0gbnVsbCkge1xuXHRcdFx0XHRpZiAoZ2V0Q29udGV4dChjb250ZXh0TmFtZXMpKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdFcnJvciBjcmVhdGluZyBXZWJHTCBjb250ZXh0IHdpdGggeW91ciBzZWxlY3RlZCBhdHRyaWJ1dGVzLicpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignRXJyb3IgY3JlYXRpbmcgV2ViR0wgY29udGV4dC4nKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNvbWUgZXhwZXJpbWVudGFsLXdlYmdsIGltcGxlbWVudGF0aW9ucyBkbyBub3QgaGF2ZSBnZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXRcblxuXHRcdGlmIChfZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdF9nbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0J3JhbmdlTWluJzogMSxcblx0XHRcdFx0XHQncmFuZ2VNYXgnOiAxLFxuXHRcdFx0XHRcdCdwcmVjaXNpb24nOiAxXG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdH1cblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiAnICsgZXJyb3IubWVzc2FnZSk7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH1cblx0bGV0IGV4dGVuc2lvbnMsIGNhcGFiaWxpdGllcywgc3RhdGUsIGluZm87XG5cdGxldCBwcm9wZXJ0aWVzLCB0ZXh0dXJlcywgY3ViZW1hcHMsIGN1YmV1dm1hcHMsIGF0dHJpYnV0ZXMsIGdlb21ldHJpZXMsIG9iamVjdHM7XG5cdGxldCBwcm9ncmFtQ2FjaGUsIG1hdGVyaWFscywgcmVuZGVyTGlzdHMsIHJlbmRlclN0YXRlcywgY2xpcHBpbmcsIHNoYWRvd01hcDtcblx0bGV0IGJhY2tncm91bmQsIG1vcnBodGFyZ2V0cywgYnVmZmVyUmVuZGVyZXIsIGluZGV4ZWRCdWZmZXJSZW5kZXJlcjtcblx0bGV0IHV0aWxzLCBiaW5kaW5nU3RhdGVzLCB1bmlmb3Jtc0dyb3Vwcztcblx0ZnVuY3Rpb24gaW5pdEdMQ29udGV4dCgpIHtcblx0XHRleHRlbnNpb25zID0gbmV3IFdlYkdMRXh0ZW5zaW9ucyhfZ2wpO1xuXHRcdGNhcGFiaWxpdGllcyA9IG5ldyBXZWJHTENhcGFiaWxpdGllcyhfZ2wsIGV4dGVuc2lvbnMsIHBhcmFtZXRlcnMpO1xuXHRcdGV4dGVuc2lvbnMuaW5pdChjYXBhYmlsaXRpZXMpO1xuXHRcdHV0aWxzID0gbmV3IFdlYkdMVXRpbHMoX2dsLCBleHRlbnNpb25zLCBjYXBhYmlsaXRpZXMpO1xuXHRcdHN0YXRlID0gbmV3IFdlYkdMU3RhdGUoX2dsLCBleHRlbnNpb25zLCBjYXBhYmlsaXRpZXMpO1xuXHRcdGluZm8gPSBuZXcgV2ViR0xJbmZvKF9nbCk7XG5cdFx0cHJvcGVydGllcyA9IG5ldyBXZWJHTFByb3BlcnRpZXMoKTtcblx0XHR0ZXh0dXJlcyA9IG5ldyBXZWJHTFRleHR1cmVzKF9nbCwgZXh0ZW5zaW9ucywgc3RhdGUsIHByb3BlcnRpZXMsIGNhcGFiaWxpdGllcywgdXRpbHMsIGluZm8pO1xuXHRcdGN1YmVtYXBzID0gbmV3IFdlYkdMQ3ViZU1hcHMoX3RoaXMpO1xuXHRcdGN1YmV1dm1hcHMgPSBuZXcgV2ViR0xDdWJlVVZNYXBzKF90aGlzKTtcblx0XHRhdHRyaWJ1dGVzID0gbmV3IFdlYkdMQXR0cmlidXRlcyhfZ2wsIGNhcGFiaWxpdGllcyk7XG5cdFx0YmluZGluZ1N0YXRlcyA9IG5ldyBXZWJHTEJpbmRpbmdTdGF0ZXMoX2dsLCBleHRlbnNpb25zLCBhdHRyaWJ1dGVzLCBjYXBhYmlsaXRpZXMpO1xuXHRcdGdlb21ldHJpZXMgPSBuZXcgV2ViR0xHZW9tZXRyaWVzKF9nbCwgYXR0cmlidXRlcywgaW5mbywgYmluZGluZ1N0YXRlcyk7XG5cdFx0b2JqZWN0cyA9IG5ldyBXZWJHTE9iamVjdHMoX2dsLCBnZW9tZXRyaWVzLCBhdHRyaWJ1dGVzLCBpbmZvKTtcblx0XHRtb3JwaHRhcmdldHMgPSBuZXcgV2ViR0xNb3JwaHRhcmdldHMoX2dsLCBjYXBhYmlsaXRpZXMsIHRleHR1cmVzKTtcblx0XHRjbGlwcGluZyA9IG5ldyBXZWJHTENsaXBwaW5nKHByb3BlcnRpZXMpO1xuXHRcdHByb2dyYW1DYWNoZSA9IG5ldyBXZWJHTFByb2dyYW1zKF90aGlzLCBjdWJlbWFwcywgY3ViZXV2bWFwcywgZXh0ZW5zaW9ucywgY2FwYWJpbGl0aWVzLCBiaW5kaW5nU3RhdGVzLCBjbGlwcGluZyk7XG5cdFx0bWF0ZXJpYWxzID0gbmV3IFdlYkdMTWF0ZXJpYWxzKF90aGlzLCBwcm9wZXJ0aWVzKTtcblx0XHRyZW5kZXJMaXN0cyA9IG5ldyBXZWJHTFJlbmRlckxpc3RzKCk7XG5cdFx0cmVuZGVyU3RhdGVzID0gbmV3IFdlYkdMUmVuZGVyU3RhdGVzKGV4dGVuc2lvbnMsIGNhcGFiaWxpdGllcyk7XG5cdFx0YmFja2dyb3VuZCA9IG5ldyBXZWJHTEJhY2tncm91bmQoX3RoaXMsIGN1YmVtYXBzLCBjdWJldXZtYXBzLCBzdGF0ZSwgb2JqZWN0cywgX2FscGhhLCBfcHJlbXVsdGlwbGllZEFscGhhKTtcblx0XHRzaGFkb3dNYXAgPSBuZXcgV2ViR0xTaGFkb3dNYXAoX3RoaXMsIG9iamVjdHMsIGNhcGFiaWxpdGllcyk7XG5cdFx0dW5pZm9ybXNHcm91cHMgPSBuZXcgV2ViR0xVbmlmb3Jtc0dyb3VwcyhfZ2wsIGluZm8sIGNhcGFiaWxpdGllcywgc3RhdGUpO1xuXHRcdGJ1ZmZlclJlbmRlcmVyID0gbmV3IFdlYkdMQnVmZmVyUmVuZGVyZXIoX2dsLCBleHRlbnNpb25zLCBpbmZvLCBjYXBhYmlsaXRpZXMpO1xuXHRcdGluZGV4ZWRCdWZmZXJSZW5kZXJlciA9IG5ldyBXZWJHTEluZGV4ZWRCdWZmZXJSZW5kZXJlcihfZ2wsIGV4dGVuc2lvbnMsIGluZm8sIGNhcGFiaWxpdGllcyk7XG5cdFx0aW5mby5wcm9ncmFtcyA9IHByb2dyYW1DYWNoZS5wcm9ncmFtcztcblx0XHRfdGhpcy5jYXBhYmlsaXRpZXMgPSBjYXBhYmlsaXRpZXM7XG5cdFx0X3RoaXMuZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG5cdFx0X3RoaXMucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XG5cdFx0X3RoaXMucmVuZGVyTGlzdHMgPSByZW5kZXJMaXN0cztcblx0XHRfdGhpcy5zaGFkb3dNYXAgPSBzaGFkb3dNYXA7XG5cdFx0X3RoaXMuc3RhdGUgPSBzdGF0ZTtcblx0XHRfdGhpcy5pbmZvID0gaW5mbztcblx0fVxuXHRpbml0R0xDb250ZXh0KCk7XG5cblx0Ly8geHJcblxuXHRjb25zdCB4ciA9IG5ldyBXZWJYUk1hbmFnZXIoX3RoaXMsIF9nbCk7XG5cdHRoaXMueHIgPSB4cjtcblxuXHQvLyBBUElcblxuXHR0aGlzLmdldENvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIF9nbDtcblx0fTtcblx0dGhpcy5nZXRDb250ZXh0QXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gX2dsLmdldENvbnRleHRBdHRyaWJ1dGVzKCk7XG5cdH07XG5cdHRoaXMuZm9yY2VDb250ZXh0TG9zcyA9IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zdCBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCgnV0VCR0xfbG9zZV9jb250ZXh0Jyk7XG5cdFx0aWYgKGV4dGVuc2lvbikgZXh0ZW5zaW9uLmxvc2VDb250ZXh0KCk7XG5cdH07XG5cdHRoaXMuZm9yY2VDb250ZXh0UmVzdG9yZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zdCBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCgnV0VCR0xfbG9zZV9jb250ZXh0Jyk7XG5cdFx0aWYgKGV4dGVuc2lvbikgZXh0ZW5zaW9uLnJlc3RvcmVDb250ZXh0KCk7XG5cdH07XG5cdHRoaXMuZ2V0UGl4ZWxSYXRpbyA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gX3BpeGVsUmF0aW87XG5cdH07XG5cdHRoaXMuc2V0UGl4ZWxSYXRpbyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cdFx0X3BpeGVsUmF0aW8gPSB2YWx1ZTtcblx0XHR0aGlzLnNldFNpemUoX3dpZHRoLCBfaGVpZ2h0LCBmYWxzZSk7XG5cdH07XG5cdHRoaXMuZ2V0U2l6ZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0XHRyZXR1cm4gdGFyZ2V0LnNldChfd2lkdGgsIF9oZWlnaHQpO1xuXHR9O1xuXHR0aGlzLnNldFNpemUgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCwgdXBkYXRlU3R5bGUpIHtcblx0XHRpZiAoeHIuaXNQcmVzZW50aW5nKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IENhblxcJ3QgY2hhbmdlIHNpemUgd2hpbGUgVlIgZGV2aWNlIGlzIHByZXNlbnRpbmcuJyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdF93aWR0aCA9IHdpZHRoO1xuXHRcdF9oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0X2NhbnZhcy53aWR0aCA9IE1hdGguZmxvb3Iod2lkdGggKiBfcGl4ZWxSYXRpbyk7XG5cdFx0X2NhbnZhcy5oZWlnaHQgPSBNYXRoLmZsb29yKGhlaWdodCAqIF9waXhlbFJhdGlvKTtcblx0XHRpZiAodXBkYXRlU3R5bGUgIT09IGZhbHNlKSB7XG5cdFx0XHRfY2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuXHRcdFx0X2NhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuXHRcdH1cblx0XHR0aGlzLnNldFZpZXdwb3J0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuXHR9O1xuXHR0aGlzLmdldERyYXdpbmdCdWZmZXJTaXplID0gZnVuY3Rpb24gKHRhcmdldCkge1xuXHRcdHJldHVybiB0YXJnZXQuc2V0KF93aWR0aCAqIF9waXhlbFJhdGlvLCBfaGVpZ2h0ICogX3BpeGVsUmF0aW8pLmZsb29yKCk7XG5cdH07XG5cdHRoaXMuc2V0RHJhd2luZ0J1ZmZlclNpemUgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCwgcGl4ZWxSYXRpbykge1xuXHRcdF93aWR0aCA9IHdpZHRoO1xuXHRcdF9oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0X3BpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xuXHRcdF9jYW52YXMud2lkdGggPSBNYXRoLmZsb29yKHdpZHRoICogcGl4ZWxSYXRpbyk7XG5cdFx0X2NhbnZhcy5oZWlnaHQgPSBNYXRoLmZsb29yKGhlaWdodCAqIHBpeGVsUmF0aW8pO1xuXHRcdHRoaXMuc2V0Vmlld3BvcnQoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cdH07XG5cdHRoaXMuZ2V0Q3VycmVudFZpZXdwb3J0ID0gZnVuY3Rpb24gKHRhcmdldCkge1xuXHRcdHJldHVybiB0YXJnZXQuY29weShfY3VycmVudFZpZXdwb3J0KTtcblx0fTtcblx0dGhpcy5nZXRWaWV3cG9ydCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoX3ZpZXdwb3J0KTtcblx0fTtcblx0dGhpcy5zZXRWaWV3cG9ydCA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0aWYgKHguaXNWZWN0b3I0KSB7XG5cdFx0XHRfdmlld3BvcnQuc2V0KHgueCwgeC55LCB4LnosIHgudyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdF92aWV3cG9ydC5zZXQoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG5cdFx0fVxuXHRcdHN0YXRlLnZpZXdwb3J0KF9jdXJyZW50Vmlld3BvcnQuY29weShfdmlld3BvcnQpLm11bHRpcGx5U2NhbGFyKF9waXhlbFJhdGlvKS5mbG9vcigpKTtcblx0fTtcblx0dGhpcy5nZXRTY2lzc29yID0gZnVuY3Rpb24gKHRhcmdldCkge1xuXHRcdHJldHVybiB0YXJnZXQuY29weShfc2Npc3Nvcik7XG5cdH07XG5cdHRoaXMuc2V0U2Npc3NvciA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0aWYgKHguaXNWZWN0b3I0KSB7XG5cdFx0XHRfc2Npc3Nvci5zZXQoeC54LCB4LnksIHgueiwgeC53KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0X3NjaXNzb3Iuc2V0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuXHRcdH1cblx0XHRzdGF0ZS5zY2lzc29yKF9jdXJyZW50U2Npc3Nvci5jb3B5KF9zY2lzc29yKS5tdWx0aXBseVNjYWxhcihfcGl4ZWxSYXRpbykuZmxvb3IoKSk7XG5cdH07XG5cdHRoaXMuZ2V0U2Npc3NvclRlc3QgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIF9zY2lzc29yVGVzdDtcblx0fTtcblx0dGhpcy5zZXRTY2lzc29yVGVzdCA9IGZ1bmN0aW9uIChib29sZWFuKSB7XG5cdFx0c3RhdGUuc2V0U2Npc3NvclRlc3QoX3NjaXNzb3JUZXN0ID0gYm9vbGVhbik7XG5cdH07XG5cdHRoaXMuc2V0T3BhcXVlU29ydCA9IGZ1bmN0aW9uIChtZXRob2QpIHtcblx0XHRfb3BhcXVlU29ydCA9IG1ldGhvZDtcblx0fTtcblx0dGhpcy5zZXRUcmFuc3BhcmVudFNvcnQgPSBmdW5jdGlvbiAobWV0aG9kKSB7XG5cdFx0X3RyYW5zcGFyZW50U29ydCA9IG1ldGhvZDtcblx0fTtcblxuXHQvLyBDbGVhcmluZ1xuXG5cdHRoaXMuZ2V0Q2xlYXJDb2xvciA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoYmFja2dyb3VuZC5nZXRDbGVhckNvbG9yKCkpO1xuXHR9O1xuXHR0aGlzLnNldENsZWFyQ29sb3IgPSBmdW5jdGlvbiAoKSB7XG5cdFx0YmFja2dyb3VuZC5zZXRDbGVhckNvbG9yLmFwcGx5KGJhY2tncm91bmQsIGFyZ3VtZW50cyk7XG5cdH07XG5cdHRoaXMuZ2V0Q2xlYXJBbHBoYSA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gYmFja2dyb3VuZC5nZXRDbGVhckFscGhhKCk7XG5cdH07XG5cdHRoaXMuc2V0Q2xlYXJBbHBoYSA9IGZ1bmN0aW9uICgpIHtcblx0XHRiYWNrZ3JvdW5kLnNldENsZWFyQWxwaGEuYXBwbHkoYmFja2dyb3VuZCwgYXJndW1lbnRzKTtcblx0fTtcblx0dGhpcy5jbGVhciA9IGZ1bmN0aW9uIChjb2xvciA9IHRydWUsIGRlcHRoID0gdHJ1ZSwgc3RlbmNpbCA9IHRydWUpIHtcblx0XHRsZXQgYml0cyA9IDA7XG5cdFx0aWYgKGNvbG9yKSBiaXRzIHw9IF9nbC5DT0xPUl9CVUZGRVJfQklUO1xuXHRcdGlmIChkZXB0aCkgYml0cyB8PSBfZ2wuREVQVEhfQlVGRkVSX0JJVDtcblx0XHRpZiAoc3RlbmNpbCkgYml0cyB8PSBfZ2wuU1RFTkNJTF9CVUZGRVJfQklUO1xuXHRcdF9nbC5jbGVhcihiaXRzKTtcblx0fTtcblx0dGhpcy5jbGVhckNvbG9yID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuY2xlYXIodHJ1ZSwgZmFsc2UsIGZhbHNlKTtcblx0fTtcblx0dGhpcy5jbGVhckRlcHRoID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuY2xlYXIoZmFsc2UsIHRydWUsIGZhbHNlKTtcblx0fTtcblx0dGhpcy5jbGVhclN0ZW5jaWwgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5jbGVhcihmYWxzZSwgZmFsc2UsIHRydWUpO1xuXHR9O1xuXG5cdC8vXG5cblx0dGhpcy5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHRcdF9jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0bG9zdCcsIG9uQ29udGV4dExvc3QsIGZhbHNlKTtcblx0XHRfY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dHJlc3RvcmVkJywgb25Db250ZXh0UmVzdG9yZSwgZmFsc2UpO1xuXHRcdF9jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0Y3JlYXRpb25lcnJvcicsIG9uQ29udGV4dENyZWF0aW9uRXJyb3IsIGZhbHNlKTtcblx0XHRyZW5kZXJMaXN0cy5kaXNwb3NlKCk7XG5cdFx0cmVuZGVyU3RhdGVzLmRpc3Bvc2UoKTtcblx0XHRwcm9wZXJ0aWVzLmRpc3Bvc2UoKTtcblx0XHRjdWJlbWFwcy5kaXNwb3NlKCk7XG5cdFx0Y3ViZXV2bWFwcy5kaXNwb3NlKCk7XG5cdFx0b2JqZWN0cy5kaXNwb3NlKCk7XG5cdFx0YmluZGluZ1N0YXRlcy5kaXNwb3NlKCk7XG5cdFx0dW5pZm9ybXNHcm91cHMuZGlzcG9zZSgpO1xuXHRcdHByb2dyYW1DYWNoZS5kaXNwb3NlKCk7XG5cdFx0eHIuZGlzcG9zZSgpO1xuXHRcdHhyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Nlc3Npb25zdGFydCcsIG9uWFJTZXNzaW9uU3RhcnQpO1xuXHRcdHhyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Nlc3Npb25lbmQnLCBvblhSU2Vzc2lvbkVuZCk7XG5cdFx0aWYgKF90cmFuc21pc3Npb25SZW5kZXJUYXJnZXQpIHtcblx0XHRcdF90cmFuc21pc3Npb25SZW5kZXJUYXJnZXQuZGlzcG9zZSgpO1xuXHRcdFx0X3RyYW5zbWlzc2lvblJlbmRlclRhcmdldCA9IG51bGw7XG5cdFx0fVxuXHRcdGFuaW1hdGlvbi5zdG9wKCk7XG5cdH07XG5cblx0Ly8gRXZlbnRzXG5cblx0ZnVuY3Rpb24gb25Db250ZXh0TG9zdChldmVudCkge1xuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0Y29uc29sZS5sb2coJ1RIUkVFLldlYkdMUmVuZGVyZXI6IENvbnRleHQgTG9zdC4nKTtcblx0XHRfaXNDb250ZXh0TG9zdCA9IHRydWU7XG5cdH1cblx0ZnVuY3Rpb24gLyogZXZlbnQgKi9cblx0b25Db250ZXh0UmVzdG9yZSgpIHtcblx0XHRjb25zb2xlLmxvZygnVEhSRUUuV2ViR0xSZW5kZXJlcjogQ29udGV4dCBSZXN0b3JlZC4nKTtcblx0XHRfaXNDb250ZXh0TG9zdCA9IGZhbHNlO1xuXHRcdGNvbnN0IGluZm9BdXRvUmVzZXQgPSBpbmZvLmF1dG9SZXNldDtcblx0XHRjb25zdCBzaGFkb3dNYXBFbmFibGVkID0gc2hhZG93TWFwLmVuYWJsZWQ7XG5cdFx0Y29uc3Qgc2hhZG93TWFwQXV0b1VwZGF0ZSA9IHNoYWRvd01hcC5hdXRvVXBkYXRlO1xuXHRcdGNvbnN0IHNoYWRvd01hcE5lZWRzVXBkYXRlID0gc2hhZG93TWFwLm5lZWRzVXBkYXRlO1xuXHRcdGNvbnN0IHNoYWRvd01hcFR5cGUgPSBzaGFkb3dNYXAudHlwZTtcblx0XHRpbml0R0xDb250ZXh0KCk7XG5cdFx0aW5mby5hdXRvUmVzZXQgPSBpbmZvQXV0b1Jlc2V0O1xuXHRcdHNoYWRvd01hcC5lbmFibGVkID0gc2hhZG93TWFwRW5hYmxlZDtcblx0XHRzaGFkb3dNYXAuYXV0b1VwZGF0ZSA9IHNoYWRvd01hcEF1dG9VcGRhdGU7XG5cdFx0c2hhZG93TWFwLm5lZWRzVXBkYXRlID0gc2hhZG93TWFwTmVlZHNVcGRhdGU7XG5cdFx0c2hhZG93TWFwLnR5cGUgPSBzaGFkb3dNYXBUeXBlO1xuXHR9XG5cdGZ1bmN0aW9uIG9uQ29udGV4dENyZWF0aW9uRXJyb3IoZXZlbnQpIHtcblx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiBBIFdlYkdMIGNvbnRleHQgY291bGQgbm90IGJlIGNyZWF0ZWQuIFJlYXNvbjogJywgZXZlbnQuc3RhdHVzTWVzc2FnZSk7XG5cdH1cblx0ZnVuY3Rpb24gb25NYXRlcmlhbERpc3Bvc2UoZXZlbnQpIHtcblx0XHRjb25zdCBtYXRlcmlhbCA9IGV2ZW50LnRhcmdldDtcblx0XHRtYXRlcmlhbC5yZW1vdmVFdmVudExpc3RlbmVyKCdkaXNwb3NlJywgb25NYXRlcmlhbERpc3Bvc2UpO1xuXHRcdGRlYWxsb2NhdGVNYXRlcmlhbChtYXRlcmlhbCk7XG5cdH1cblxuXHQvLyBCdWZmZXIgZGVhbGxvY2F0aW9uXG5cblx0ZnVuY3Rpb24gZGVhbGxvY2F0ZU1hdGVyaWFsKG1hdGVyaWFsKSB7XG5cdFx0cmVsZWFzZU1hdGVyaWFsUHJvZ3JhbVJlZmVyZW5jZXMobWF0ZXJpYWwpO1xuXHRcdHByb3BlcnRpZXMucmVtb3ZlKG1hdGVyaWFsKTtcblx0fVxuXHRmdW5jdGlvbiByZWxlYXNlTWF0ZXJpYWxQcm9ncmFtUmVmZXJlbmNlcyhtYXRlcmlhbCkge1xuXHRcdGNvbnN0IHByb2dyYW1zID0gcHJvcGVydGllcy5nZXQobWF0ZXJpYWwpLnByb2dyYW1zO1xuXHRcdGlmIChwcm9ncmFtcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRwcm9ncmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9ncmFtKSB7XG5cdFx0XHRcdHByb2dyYW1DYWNoZS5yZWxlYXNlUHJvZ3JhbShwcm9ncmFtKTtcblx0XHRcdH0pO1xuXHRcdFx0aWYgKG1hdGVyaWFsLmlzU2hhZGVyTWF0ZXJpYWwpIHtcblx0XHRcdFx0cHJvZ3JhbUNhY2hlLnJlbGVhc2VTaGFkZXJDYWNoZShtYXRlcmlhbCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQnVmZmVyIHJlbmRlcmluZ1xuXG5cdHRoaXMucmVuZGVyQnVmZmVyRGlyZWN0ID0gZnVuY3Rpb24gKGNhbWVyYSwgc2NlbmUsIGdlb21ldHJ5LCBtYXRlcmlhbCwgb2JqZWN0LCBncm91cCkge1xuXHRcdGlmIChzY2VuZSA9PT0gbnVsbCkgc2NlbmUgPSBfZW1wdHlTY2VuZTsgLy8gcmVuZGVyQnVmZmVyRGlyZWN0IHNlY29uZCBwYXJhbWV0ZXIgdXNlZCB0byBiZSBmb2cgKGNvdWxkIGJlIG51bGwpXG5cblx0XHRjb25zdCBmcm9udEZhY2VDVyA9IG9iamVjdC5pc01lc2ggJiYgb2JqZWN0Lm1hdHJpeFdvcmxkLmRldGVybWluYW50KCkgPCAwO1xuXHRcdGNvbnN0IHByb2dyYW0gPSBzZXRQcm9ncmFtKGNhbWVyYSwgc2NlbmUsIGdlb21ldHJ5LCBtYXRlcmlhbCwgb2JqZWN0KTtcblx0XHRzdGF0ZS5zZXRNYXRlcmlhbChtYXRlcmlhbCwgZnJvbnRGYWNlQ1cpO1xuXG5cdFx0Ly9cblxuXHRcdGxldCBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuXHRcdGNvbnN0IHBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuXHRcdC8vXG5cblx0XHRpZiAoaW5kZXggPT09IG51bGwpIHtcblx0XHRcdGlmIChwb3NpdGlvbiA9PT0gdW5kZWZpbmVkIHx8IHBvc2l0aW9uLmNvdW50ID09PSAwKSByZXR1cm47XG5cdFx0fSBlbHNlIGlmIChpbmRleC5jb3VudCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRsZXQgcmFuZ2VGYWN0b3IgPSAxO1xuXHRcdGlmIChtYXRlcmlhbC53aXJlZnJhbWUgPT09IHRydWUpIHtcblx0XHRcdGluZGV4ID0gZ2VvbWV0cmllcy5nZXRXaXJlZnJhbWVBdHRyaWJ1dGUoZ2VvbWV0cnkpO1xuXHRcdFx0cmFuZ2VGYWN0b3IgPSAyO1xuXHRcdH1cblx0XHRiaW5kaW5nU3RhdGVzLnNldHVwKG9iamVjdCwgbWF0ZXJpYWwsIHByb2dyYW0sIGdlb21ldHJ5LCBpbmRleCk7XG5cdFx0bGV0IGF0dHJpYnV0ZTtcblx0XHRsZXQgcmVuZGVyZXIgPSBidWZmZXJSZW5kZXJlcjtcblx0XHRpZiAoaW5kZXggIT09IG51bGwpIHtcblx0XHRcdGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXMuZ2V0KGluZGV4KTtcblx0XHRcdHJlbmRlcmVyID0gaW5kZXhlZEJ1ZmZlclJlbmRlcmVyO1xuXHRcdFx0cmVuZGVyZXIuc2V0SW5kZXgoYXR0cmlidXRlKTtcblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0Y29uc3QgZGF0YUNvdW50ID0gaW5kZXggIT09IG51bGwgPyBpbmRleC5jb3VudCA6IHBvc2l0aW9uLmNvdW50O1xuXHRcdGNvbnN0IHJhbmdlU3RhcnQgPSBnZW9tZXRyeS5kcmF3UmFuZ2Uuc3RhcnQgKiByYW5nZUZhY3Rvcjtcblx0XHRjb25zdCByYW5nZUNvdW50ID0gZ2VvbWV0cnkuZHJhd1JhbmdlLmNvdW50ICogcmFuZ2VGYWN0b3I7XG5cdFx0Y29uc3QgZ3JvdXBTdGFydCA9IGdyb3VwICE9PSBudWxsID8gZ3JvdXAuc3RhcnQgKiByYW5nZUZhY3RvciA6IDA7XG5cdFx0Y29uc3QgZ3JvdXBDb3VudCA9IGdyb3VwICE9PSBudWxsID8gZ3JvdXAuY291bnQgKiByYW5nZUZhY3RvciA6IEluZmluaXR5O1xuXHRcdGNvbnN0IGRyYXdTdGFydCA9IE1hdGgubWF4KHJhbmdlU3RhcnQsIGdyb3VwU3RhcnQpO1xuXHRcdGNvbnN0IGRyYXdFbmQgPSBNYXRoLm1pbihkYXRhQ291bnQsIHJhbmdlU3RhcnQgKyByYW5nZUNvdW50LCBncm91cFN0YXJ0ICsgZ3JvdXBDb3VudCkgLSAxO1xuXHRcdGNvbnN0IGRyYXdDb3VudCA9IE1hdGgubWF4KDAsIGRyYXdFbmQgLSBkcmF3U3RhcnQgKyAxKTtcblx0XHRpZiAoZHJhd0NvdW50ID09PSAwKSByZXR1cm47XG5cblx0XHQvL1xuXG5cdFx0aWYgKG9iamVjdC5pc01lc2gpIHtcblx0XHRcdGlmIChtYXRlcmlhbC53aXJlZnJhbWUgPT09IHRydWUpIHtcblx0XHRcdFx0c3RhdGUuc2V0TGluZVdpZHRoKG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCAqIGdldFRhcmdldFBpeGVsUmF0aW8oKSk7XG5cdFx0XHRcdHJlbmRlcmVyLnNldE1vZGUoX2dsLkxJTkVTKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlbmRlcmVyLnNldE1vZGUoX2dsLlRSSUFOR0xFUyk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChvYmplY3QuaXNMaW5lKSB7XG5cdFx0XHRsZXQgbGluZVdpZHRoID0gbWF0ZXJpYWwubGluZXdpZHRoO1xuXHRcdFx0aWYgKGxpbmVXaWR0aCA9PT0gdW5kZWZpbmVkKSBsaW5lV2lkdGggPSAxOyAvLyBOb3QgdXNpbmcgTGluZSpNYXRlcmlhbFxuXG5cdFx0XHRzdGF0ZS5zZXRMaW5lV2lkdGgobGluZVdpZHRoICogZ2V0VGFyZ2V0UGl4ZWxSYXRpbygpKTtcblx0XHRcdGlmIChvYmplY3QuaXNMaW5lU2VnbWVudHMpIHtcblx0XHRcdFx0cmVuZGVyZXIuc2V0TW9kZShfZ2wuTElORVMpO1xuXHRcdFx0fSBlbHNlIGlmIChvYmplY3QuaXNMaW5lTG9vcCkge1xuXHRcdFx0XHRyZW5kZXJlci5zZXRNb2RlKF9nbC5MSU5FX0xPT1ApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVuZGVyZXIuc2V0TW9kZShfZ2wuTElORV9TVFJJUCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChvYmplY3QuaXNQb2ludHMpIHtcblx0XHRcdHJlbmRlcmVyLnNldE1vZGUoX2dsLlBPSU5UUyk7XG5cdFx0fSBlbHNlIGlmIChvYmplY3QuaXNTcHJpdGUpIHtcblx0XHRcdHJlbmRlcmVyLnNldE1vZGUoX2dsLlRSSUFOR0xFUyk7XG5cdFx0fVxuXHRcdGlmIChvYmplY3QuaXNJbnN0YW5jZWRNZXNoKSB7XG5cdFx0XHRyZW5kZXJlci5yZW5kZXJJbnN0YW5jZXMoZHJhd1N0YXJ0LCBkcmF3Q291bnQsIG9iamVjdC5jb3VudCk7XG5cdFx0fSBlbHNlIGlmIChnZW9tZXRyeS5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5KSB7XG5cdFx0XHRjb25zdCBpbnN0YW5jZUNvdW50ID0gTWF0aC5taW4oZ2VvbWV0cnkuaW5zdGFuY2VDb3VudCwgZ2VvbWV0cnkuX21heEluc3RhbmNlQ291bnQpO1xuXHRcdFx0cmVuZGVyZXIucmVuZGVySW5zdGFuY2VzKGRyYXdTdGFydCwgZHJhd0NvdW50LCBpbnN0YW5jZUNvdW50KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVuZGVyZXIucmVuZGVyKGRyYXdTdGFydCwgZHJhd0NvdW50KTtcblx0XHR9XG5cdH07XG5cblx0Ly8gQ29tcGlsZVxuXG5cdHRoaXMuY29tcGlsZSA9IGZ1bmN0aW9uIChzY2VuZSwgY2FtZXJhKSB7XG5cdFx0ZnVuY3Rpb24gcHJlcGFyZShtYXRlcmlhbCwgc2NlbmUsIG9iamVjdCkge1xuXHRcdFx0aWYgKG1hdGVyaWFsLnRyYW5zcGFyZW50ID09PSB0cnVlICYmIG1hdGVyaWFsLnNpZGUgPT09IERvdWJsZVNpZGUpIHtcblx0XHRcdFx0bWF0ZXJpYWwuc2lkZSA9IEJhY2tTaWRlO1xuXHRcdFx0XHRtYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdGdldFByb2dyYW0obWF0ZXJpYWwsIHNjZW5lLCBvYmplY3QpO1xuXHRcdFx0XHRtYXRlcmlhbC5zaWRlID0gRnJvbnRTaWRlO1xuXHRcdFx0XHRtYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdGdldFByb2dyYW0obWF0ZXJpYWwsIHNjZW5lLCBvYmplY3QpO1xuXHRcdFx0XHRtYXRlcmlhbC5zaWRlID0gRG91YmxlU2lkZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGdldFByb2dyYW0obWF0ZXJpYWwsIHNjZW5lLCBvYmplY3QpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRjdXJyZW50UmVuZGVyU3RhdGUgPSByZW5kZXJTdGF0ZXMuZ2V0KHNjZW5lKTtcblx0XHRjdXJyZW50UmVuZGVyU3RhdGUuaW5pdCgpO1xuXHRcdHJlbmRlclN0YXRlU3RhY2sucHVzaChjdXJyZW50UmVuZGVyU3RhdGUpO1xuXHRcdHNjZW5lLnRyYXZlcnNlVmlzaWJsZShmdW5jdGlvbiAob2JqZWN0KSB7XG5cdFx0XHRpZiAob2JqZWN0LmlzTGlnaHQgJiYgb2JqZWN0LmxheWVycy50ZXN0KGNhbWVyYS5sYXllcnMpKSB7XG5cdFx0XHRcdGN1cnJlbnRSZW5kZXJTdGF0ZS5wdXNoTGlnaHQob2JqZWN0KTtcblx0XHRcdFx0aWYgKG9iamVjdC5jYXN0U2hhZG93KSB7XG5cdFx0XHRcdFx0Y3VycmVudFJlbmRlclN0YXRlLnB1c2hTaGFkb3cob2JqZWN0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGN1cnJlbnRSZW5kZXJTdGF0ZS5zZXR1cExpZ2h0cyhfdGhpcy5waHlzaWNhbGx5Q29ycmVjdExpZ2h0cyk7XG5cdFx0c2NlbmUudHJhdmVyc2UoZnVuY3Rpb24gKG9iamVjdCkge1xuXHRcdFx0Y29uc3QgbWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XG5cdFx0XHRpZiAobWF0ZXJpYWwpIHtcblx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkobWF0ZXJpYWwpKSB7XG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBtYXRlcmlhbC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0Y29uc3QgbWF0ZXJpYWwyID0gbWF0ZXJpYWxbaV07XG5cdFx0XHRcdFx0XHRwcmVwYXJlKG1hdGVyaWFsMiwgc2NlbmUsIG9iamVjdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHByZXBhcmUobWF0ZXJpYWwsIHNjZW5lLCBvYmplY3QpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0cmVuZGVyU3RhdGVTdGFjay5wb3AoKTtcblx0XHRjdXJyZW50UmVuZGVyU3RhdGUgPSBudWxsO1xuXHR9O1xuXG5cdC8vIEFuaW1hdGlvbiBMb29wXG5cblx0bGV0IG9uQW5pbWF0aW9uRnJhbWVDYWxsYmFjayA9IG51bGw7XG5cdGZ1bmN0aW9uIG9uQW5pbWF0aW9uRnJhbWUodGltZSkge1xuXHRcdGlmIChvbkFuaW1hdGlvbkZyYW1lQ2FsbGJhY2spIG9uQW5pbWF0aW9uRnJhbWVDYWxsYmFjayh0aW1lKTtcblx0fVxuXHRmdW5jdGlvbiBvblhSU2Vzc2lvblN0YXJ0KCkge1xuXHRcdGFuaW1hdGlvbi5zdG9wKCk7XG5cdH1cblx0ZnVuY3Rpb24gb25YUlNlc3Npb25FbmQoKSB7XG5cdFx0YW5pbWF0aW9uLnN0YXJ0KCk7XG5cdH1cblx0Y29uc3QgYW5pbWF0aW9uID0gbmV3IFdlYkdMQW5pbWF0aW9uKCk7XG5cdGFuaW1hdGlvbi5zZXRBbmltYXRpb25Mb29wKG9uQW5pbWF0aW9uRnJhbWUpO1xuXHRpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSBhbmltYXRpb24uc2V0Q29udGV4dChzZWxmKTtcblx0dGhpcy5zZXRBbmltYXRpb25Mb29wID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdFx0b25BbmltYXRpb25GcmFtZUNhbGxiYWNrID0gY2FsbGJhY2s7XG5cdFx0eHIuc2V0QW5pbWF0aW9uTG9vcChjYWxsYmFjayk7XG5cdFx0Y2FsbGJhY2sgPT09IG51bGwgPyBhbmltYXRpb24uc3RvcCgpIDogYW5pbWF0aW9uLnN0YXJ0KCk7XG5cdH07XG5cdHhyLmFkZEV2ZW50TGlzdGVuZXIoJ3Nlc3Npb25zdGFydCcsIG9uWFJTZXNzaW9uU3RhcnQpO1xuXHR4ci5hZGRFdmVudExpc3RlbmVyKCdzZXNzaW9uZW5kJywgb25YUlNlc3Npb25FbmQpO1xuXG5cdC8vIFJlbmRlcmluZ1xuXG5cdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKHNjZW5lLCBjYW1lcmEpIHtcblx0XHRpZiAoY2FtZXJhICE9PSB1bmRlZmluZWQgJiYgY2FtZXJhLmlzQ2FtZXJhICE9PSB0cnVlKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlbmRlcjogY2FtZXJhIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5DYW1lcmEuJyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmIChfaXNDb250ZXh0TG9zdCA9PT0gdHJ1ZSkgcmV0dXJuO1xuXG5cdFx0Ly8gdXBkYXRlIHNjZW5lIGdyYXBoXG5cblx0XHRpZiAoc2NlbmUubWF0cml4V29ybGRBdXRvVXBkYXRlID09PSB0cnVlKSBzY2VuZS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG5cdFx0Ly8gdXBkYXRlIGNhbWVyYSBtYXRyaWNlcyBhbmQgZnJ1c3R1bVxuXG5cdFx0aWYgKGNhbWVyYS5wYXJlbnQgPT09IG51bGwgJiYgY2FtZXJhLm1hdHJpeFdvcmxkQXV0b1VwZGF0ZSA9PT0gdHJ1ZSkgY2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cdFx0aWYgKHhyLmVuYWJsZWQgPT09IHRydWUgJiYgeHIuaXNQcmVzZW50aW5nID09PSB0cnVlKSB7XG5cdFx0XHRpZiAoeHIuY2FtZXJhQXV0b1VwZGF0ZSA9PT0gdHJ1ZSkgeHIudXBkYXRlQ2FtZXJhKGNhbWVyYSk7XG5cdFx0XHRjYW1lcmEgPSB4ci5nZXRDYW1lcmEoKTsgLy8gdXNlIFhSIGNhbWVyYSBmb3IgcmVuZGVyaW5nXG5cdFx0fVxuXG5cdFx0Ly9cblx0XHRpZiAoc2NlbmUuaXNTY2VuZSA9PT0gdHJ1ZSkgc2NlbmUub25CZWZvcmVSZW5kZXIoX3RoaXMsIHNjZW5lLCBjYW1lcmEsIF9jdXJyZW50UmVuZGVyVGFyZ2V0KTtcblx0XHRjdXJyZW50UmVuZGVyU3RhdGUgPSByZW5kZXJTdGF0ZXMuZ2V0KHNjZW5lLCByZW5kZXJTdGF0ZVN0YWNrLmxlbmd0aCk7XG5cdFx0Y3VycmVudFJlbmRlclN0YXRlLmluaXQoKTtcblx0XHRyZW5kZXJTdGF0ZVN0YWNrLnB1c2goY3VycmVudFJlbmRlclN0YXRlKTtcblx0XHRfcHJvalNjcmVlbk1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlKTtcblx0XHRfZnJ1c3R1bS5zZXRGcm9tUHJvamVjdGlvbk1hdHJpeChfcHJvalNjcmVlbk1hdHJpeCk7XG5cdFx0X2xvY2FsQ2xpcHBpbmdFbmFibGVkID0gdGhpcy5sb2NhbENsaXBwaW5nRW5hYmxlZDtcblx0XHRfY2xpcHBpbmdFbmFibGVkID0gY2xpcHBpbmcuaW5pdCh0aGlzLmNsaXBwaW5nUGxhbmVzLCBfbG9jYWxDbGlwcGluZ0VuYWJsZWQsIGNhbWVyYSk7XG5cdFx0Y3VycmVudFJlbmRlckxpc3QgPSByZW5kZXJMaXN0cy5nZXQoc2NlbmUsIHJlbmRlckxpc3RTdGFjay5sZW5ndGgpO1xuXHRcdGN1cnJlbnRSZW5kZXJMaXN0LmluaXQoKTtcblx0XHRyZW5kZXJMaXN0U3RhY2sucHVzaChjdXJyZW50UmVuZGVyTGlzdCk7XG5cdFx0cHJvamVjdE9iamVjdChzY2VuZSwgY2FtZXJhLCAwLCBfdGhpcy5zb3J0T2JqZWN0cyk7XG5cdFx0Y3VycmVudFJlbmRlckxpc3QuZmluaXNoKCk7XG5cdFx0aWYgKF90aGlzLnNvcnRPYmplY3RzID09PSB0cnVlKSB7XG5cdFx0XHRjdXJyZW50UmVuZGVyTGlzdC5zb3J0KF9vcGFxdWVTb3J0LCBfdHJhbnNwYXJlbnRTb3J0KTtcblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0aWYgKF9jbGlwcGluZ0VuYWJsZWQgPT09IHRydWUpIGNsaXBwaW5nLmJlZ2luU2hhZG93cygpO1xuXHRcdGNvbnN0IHNoYWRvd3NBcnJheSA9IGN1cnJlbnRSZW5kZXJTdGF0ZS5zdGF0ZS5zaGFkb3dzQXJyYXk7XG5cdFx0c2hhZG93TWFwLnJlbmRlcihzaGFkb3dzQXJyYXksIHNjZW5lLCBjYW1lcmEpO1xuXHRcdGlmIChfY2xpcHBpbmdFbmFibGVkID09PSB0cnVlKSBjbGlwcGluZy5lbmRTaGFkb3dzKCk7XG5cblx0XHQvL1xuXG5cdFx0aWYgKHRoaXMuaW5mby5hdXRvUmVzZXQgPT09IHRydWUpIHRoaXMuaW5mby5yZXNldCgpO1xuXG5cdFx0Ly9cblxuXHRcdGJhY2tncm91bmQucmVuZGVyKGN1cnJlbnRSZW5kZXJMaXN0LCBzY2VuZSk7XG5cblx0XHQvLyByZW5kZXIgc2NlbmVcblxuXHRcdGN1cnJlbnRSZW5kZXJTdGF0ZS5zZXR1cExpZ2h0cyhfdGhpcy5waHlzaWNhbGx5Q29ycmVjdExpZ2h0cyk7XG5cdFx0aWYgKGNhbWVyYS5pc0FycmF5Q2FtZXJhKSB7XG5cdFx0XHRjb25zdCBjYW1lcmFzID0gY2FtZXJhLmNhbWVyYXM7XG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGNhbWVyYXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGNhbWVyYTIgPSBjYW1lcmFzW2ldO1xuXHRcdFx0XHRyZW5kZXJTY2VuZShjdXJyZW50UmVuZGVyTGlzdCwgc2NlbmUsIGNhbWVyYTIsIGNhbWVyYTIudmlld3BvcnQpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZW5kZXJTY2VuZShjdXJyZW50UmVuZGVyTGlzdCwgc2NlbmUsIGNhbWVyYSk7XG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdGlmIChfY3VycmVudFJlbmRlclRhcmdldCAhPT0gbnVsbCkge1xuXHRcdFx0Ly8gcmVzb2x2ZSBtdWx0aXNhbXBsZSByZW5kZXJidWZmZXJzIHRvIGEgc2luZ2xlLXNhbXBsZSB0ZXh0dXJlIGlmIG5lY2Vzc2FyeVxuXG5cdFx0XHR0ZXh0dXJlcy51cGRhdGVNdWx0aXNhbXBsZVJlbmRlclRhcmdldChfY3VycmVudFJlbmRlclRhcmdldCk7XG5cblx0XHRcdC8vIEdlbmVyYXRlIG1pcG1hcCBpZiB3ZSdyZSB1c2luZyBhbnkga2luZCBvZiBtaXBtYXAgZmlsdGVyaW5nXG5cblx0XHRcdHRleHR1cmVzLnVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcChfY3VycmVudFJlbmRlclRhcmdldCk7XG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdGlmIChzY2VuZS5pc1NjZW5lID09PSB0cnVlKSBzY2VuZS5vbkFmdGVyUmVuZGVyKF90aGlzLCBzY2VuZSwgY2FtZXJhKTtcblxuXHRcdC8vIF9nbC5maW5pc2goKTtcblxuXHRcdGJpbmRpbmdTdGF0ZXMucmVzZXREZWZhdWx0U3RhdGUoKTtcblx0XHRfY3VycmVudE1hdGVyaWFsSWQgPSAtMTtcblx0XHRfY3VycmVudENhbWVyYSA9IG51bGw7XG5cdFx0cmVuZGVyU3RhdGVTdGFjay5wb3AoKTtcblx0XHRpZiAocmVuZGVyU3RhdGVTdGFjay5sZW5ndGggPiAwKSB7XG5cdFx0XHRjdXJyZW50UmVuZGVyU3RhdGUgPSByZW5kZXJTdGF0ZVN0YWNrW3JlbmRlclN0YXRlU3RhY2subGVuZ3RoIC0gMV07XG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1cnJlbnRSZW5kZXJTdGF0ZSA9IG51bGw7XG5cdFx0fVxuXHRcdHJlbmRlckxpc3RTdGFjay5wb3AoKTtcblx0XHRpZiAocmVuZGVyTGlzdFN0YWNrLmxlbmd0aCA+IDApIHtcblx0XHRcdGN1cnJlbnRSZW5kZXJMaXN0ID0gcmVuZGVyTGlzdFN0YWNrW3JlbmRlckxpc3RTdGFjay5sZW5ndGggLSAxXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VycmVudFJlbmRlckxpc3QgPSBudWxsO1xuXHRcdH1cblx0fTtcblx0ZnVuY3Rpb24gcHJvamVjdE9iamVjdChvYmplY3QsIGNhbWVyYSwgZ3JvdXBPcmRlciwgc29ydE9iamVjdHMpIHtcblx0XHRpZiAob2JqZWN0LnZpc2libGUgPT09IGZhbHNlKSByZXR1cm47XG5cdFx0Y29uc3QgdmlzaWJsZSA9IG9iamVjdC5sYXllcnMudGVzdChjYW1lcmEubGF5ZXJzKTtcblx0XHRpZiAodmlzaWJsZSkge1xuXHRcdFx0aWYgKG9iamVjdC5pc0dyb3VwKSB7XG5cdFx0XHRcdGdyb3VwT3JkZXIgPSBvYmplY3QucmVuZGVyT3JkZXI7XG5cdFx0XHR9IGVsc2UgaWYgKG9iamVjdC5pc0xPRCkge1xuXHRcdFx0XHRpZiAob2JqZWN0LmF1dG9VcGRhdGUgPT09IHRydWUpIG9iamVjdC51cGRhdGUoY2FtZXJhKTtcblx0XHRcdH0gZWxzZSBpZiAob2JqZWN0LmlzTGlnaHQpIHtcblx0XHRcdFx0Y3VycmVudFJlbmRlclN0YXRlLnB1c2hMaWdodChvYmplY3QpO1xuXHRcdFx0XHRpZiAob2JqZWN0LmNhc3RTaGFkb3cpIHtcblx0XHRcdFx0XHRjdXJyZW50UmVuZGVyU3RhdGUucHVzaFNoYWRvdyhvYmplY3QpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKG9iamVjdC5pc1Nwcml0ZSkge1xuXHRcdFx0XHRpZiAoIW9iamVjdC5mcnVzdHVtQ3VsbGVkIHx8IF9mcnVzdHVtLmludGVyc2VjdHNTcHJpdGUob2JqZWN0KSkge1xuXHRcdFx0XHRcdGlmIChzb3J0T2JqZWN0cykge1xuXHRcdFx0XHRcdFx0X3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKG9iamVjdC5tYXRyaXhXb3JsZCkuYXBwbHlNYXRyaXg0KF9wcm9qU2NyZWVuTWF0cml4KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBvYmplY3RzLnVwZGF0ZShvYmplY3QpO1xuXHRcdFx0XHRcdGNvbnN0IG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xuXHRcdFx0XHRcdGlmIChtYXRlcmlhbC52aXNpYmxlKSB7XG5cdFx0XHRcdFx0XHRjdXJyZW50UmVuZGVyTGlzdC5wdXNoKG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cE9yZGVyLCBfdmVjdG9yMy56LCBudWxsKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAob2JqZWN0LmlzTWVzaCB8fCBvYmplY3QuaXNMaW5lIHx8IG9iamVjdC5pc1BvaW50cykge1xuXHRcdFx0XHRpZiAob2JqZWN0LmlzU2tpbm5lZE1lc2gpIHtcblx0XHRcdFx0XHQvLyB1cGRhdGUgc2tlbGV0b24gb25seSBvbmNlIGluIGEgZnJhbWVcblxuXHRcdFx0XHRcdGlmIChvYmplY3Quc2tlbGV0b24uZnJhbWUgIT09IGluZm8ucmVuZGVyLmZyYW1lKSB7XG5cdFx0XHRcdFx0XHRvYmplY3Quc2tlbGV0b24udXBkYXRlKCk7XG5cdFx0XHRcdFx0XHRvYmplY3Quc2tlbGV0b24uZnJhbWUgPSBpbmZvLnJlbmRlci5mcmFtZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFvYmplY3QuZnJ1c3R1bUN1bGxlZCB8fCBfZnJ1c3R1bS5pbnRlcnNlY3RzT2JqZWN0KG9iamVjdCkpIHtcblx0XHRcdFx0XHRpZiAoc29ydE9iamVjdHMpIHtcblx0XHRcdFx0XHRcdF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbihvYmplY3QubWF0cml4V29ybGQpLmFwcGx5TWF0cml4NChfcHJvalNjcmVlbk1hdHJpeCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gb2JqZWN0cy51cGRhdGUob2JqZWN0KTtcblx0XHRcdFx0XHRjb25zdCBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcblx0XHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheShtYXRlcmlhbCkpIHtcblx0XHRcdFx0XHRcdGNvbnN0IGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3Vwcztcblx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBncm91cCA9IGdyb3Vwc1tpXTtcblx0XHRcdFx0XHRcdFx0Y29uc3QgZ3JvdXBNYXRlcmlhbCA9IG1hdGVyaWFsW2dyb3VwLm1hdGVyaWFsSW5kZXhdO1xuXHRcdFx0XHRcdFx0XHRpZiAoZ3JvdXBNYXRlcmlhbCAmJiBncm91cE1hdGVyaWFsLnZpc2libGUpIHtcblx0XHRcdFx0XHRcdFx0XHRjdXJyZW50UmVuZGVyTGlzdC5wdXNoKG9iamVjdCwgZ2VvbWV0cnksIGdyb3VwTWF0ZXJpYWwsIGdyb3VwT3JkZXIsIF92ZWN0b3IzLnosIGdyb3VwKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAobWF0ZXJpYWwudmlzaWJsZSkge1xuXHRcdFx0XHRcdFx0Y3VycmVudFJlbmRlckxpc3QucHVzaChvYmplY3QsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXBPcmRlciwgX3ZlY3RvcjMueiwgbnVsbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNvbnN0IGNoaWxkcmVuID0gb2JqZWN0LmNoaWxkcmVuO1xuXHRcdGZvciAobGV0IGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRwcm9qZWN0T2JqZWN0KGNoaWxkcmVuW2ldLCBjYW1lcmEsIGdyb3VwT3JkZXIsIHNvcnRPYmplY3RzKTtcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gcmVuZGVyU2NlbmUoY3VycmVudFJlbmRlckxpc3QsIHNjZW5lLCBjYW1lcmEsIHZpZXdwb3J0KSB7XG5cdFx0Y29uc3Qgb3BhcXVlT2JqZWN0cyA9IGN1cnJlbnRSZW5kZXJMaXN0Lm9wYXF1ZTtcblx0XHRjb25zdCB0cmFuc21pc3NpdmVPYmplY3RzID0gY3VycmVudFJlbmRlckxpc3QudHJhbnNtaXNzaXZlO1xuXHRcdGNvbnN0IHRyYW5zcGFyZW50T2JqZWN0cyA9IGN1cnJlbnRSZW5kZXJMaXN0LnRyYW5zcGFyZW50O1xuXHRcdGN1cnJlbnRSZW5kZXJTdGF0ZS5zZXR1cExpZ2h0c1ZpZXcoY2FtZXJhKTtcblx0XHRpZiAodHJhbnNtaXNzaXZlT2JqZWN0cy5sZW5ndGggPiAwKSByZW5kZXJUcmFuc21pc3Npb25QYXNzKG9wYXF1ZU9iamVjdHMsIHNjZW5lLCBjYW1lcmEpO1xuXHRcdGlmICh2aWV3cG9ydCkgc3RhdGUudmlld3BvcnQoX2N1cnJlbnRWaWV3cG9ydC5jb3B5KHZpZXdwb3J0KSk7XG5cdFx0aWYgKG9wYXF1ZU9iamVjdHMubGVuZ3RoID4gMCkgcmVuZGVyT2JqZWN0cyhvcGFxdWVPYmplY3RzLCBzY2VuZSwgY2FtZXJhKTtcblx0XHRpZiAodHJhbnNtaXNzaXZlT2JqZWN0cy5sZW5ndGggPiAwKSByZW5kZXJPYmplY3RzKHRyYW5zbWlzc2l2ZU9iamVjdHMsIHNjZW5lLCBjYW1lcmEpO1xuXHRcdGlmICh0cmFuc3BhcmVudE9iamVjdHMubGVuZ3RoID4gMCkgcmVuZGVyT2JqZWN0cyh0cmFuc3BhcmVudE9iamVjdHMsIHNjZW5lLCBjYW1lcmEpO1xuXG5cdFx0Ly8gRW5zdXJlIGRlcHRoIGJ1ZmZlciB3cml0aW5nIGlzIGVuYWJsZWQgc28gaXQgY2FuIGJlIGNsZWFyZWQgb24gbmV4dCByZW5kZXJcblxuXHRcdHN0YXRlLmJ1ZmZlcnMuZGVwdGguc2V0VGVzdCh0cnVlKTtcblx0XHRzdGF0ZS5idWZmZXJzLmRlcHRoLnNldE1hc2sodHJ1ZSk7XG5cdFx0c3RhdGUuYnVmZmVycy5jb2xvci5zZXRNYXNrKHRydWUpO1xuXHRcdHN0YXRlLnNldFBvbHlnb25PZmZzZXQoZmFsc2UpO1xuXHR9XG5cdGZ1bmN0aW9uIHJlbmRlclRyYW5zbWlzc2lvblBhc3Mob3BhcXVlT2JqZWN0cywgc2NlbmUsIGNhbWVyYSkge1xuXHRcdGNvbnN0IGlzV2ViR0wyID0gY2FwYWJpbGl0aWVzLmlzV2ViR0wyO1xuXHRcdGlmIChfdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0ID09PSBudWxsKSB7XG5cdFx0XHRfdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0ID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0KDEsIDEsIHtcblx0XHRcdFx0Z2VuZXJhdGVNaXBtYXBzOiB0cnVlLFxuXHRcdFx0XHR0eXBlOiBleHRlbnNpb25zLmhhcygnRVhUX2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0JykgPyBIYWxmRmxvYXRUeXBlIDogVW5zaWduZWRCeXRlVHlwZSxcblx0XHRcdFx0bWluRmlsdGVyOiBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIsXG5cdFx0XHRcdHNhbXBsZXM6IGlzV2ViR0wyICYmIF9hbnRpYWxpYXMgPT09IHRydWUgPyA0IDogMFxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdF90aGlzLmdldERyYXdpbmdCdWZmZXJTaXplKF92ZWN0b3IyKTtcblx0XHRpZiAoaXNXZWJHTDIpIHtcblx0XHRcdF90cmFuc21pc3Npb25SZW5kZXJUYXJnZXQuc2V0U2l6ZShfdmVjdG9yMi54LCBfdmVjdG9yMi55KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0X3RyYW5zbWlzc2lvblJlbmRlclRhcmdldC5zZXRTaXplKGZsb29yUG93ZXJPZlR3byhfdmVjdG9yMi54KSwgZmxvb3JQb3dlck9mVHdvKF92ZWN0b3IyLnkpKTtcblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0Y29uc3QgY3VycmVudFJlbmRlclRhcmdldCA9IF90aGlzLmdldFJlbmRlclRhcmdldCgpO1xuXHRcdF90aGlzLnNldFJlbmRlclRhcmdldChfdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0KTtcblx0XHRfdGhpcy5jbGVhcigpO1xuXG5cdFx0Ly8gVHVybiBvZmYgdGhlIGZlYXR1cmVzIHdoaWNoIGNhbiBhZmZlY3QgdGhlIGZyYWcgY29sb3IgZm9yIG9wYXF1ZSBvYmplY3RzIHBhc3MuXG5cdFx0Ly8gT3RoZXJ3aXNlIHRoZXkgYXJlIGFwcGxpZWQgdHdpY2UgaW4gb3BhcXVlIG9iamVjdHMgcGFzcyBhbmQgdHJhbnNtaXNzaW9uIG9iamVjdHMgcGFzcy5cblx0XHRjb25zdCBjdXJyZW50VG9uZU1hcHBpbmcgPSBfdGhpcy50b25lTWFwcGluZztcblx0XHRfdGhpcy50b25lTWFwcGluZyA9IE5vVG9uZU1hcHBpbmc7XG5cdFx0cmVuZGVyT2JqZWN0cyhvcGFxdWVPYmplY3RzLCBzY2VuZSwgY2FtZXJhKTtcblx0XHRfdGhpcy50b25lTWFwcGluZyA9IGN1cnJlbnRUb25lTWFwcGluZztcblx0XHR0ZXh0dXJlcy51cGRhdGVNdWx0aXNhbXBsZVJlbmRlclRhcmdldChfdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0KTtcblx0XHR0ZXh0dXJlcy51cGRhdGVSZW5kZXJUYXJnZXRNaXBtYXAoX3RyYW5zbWlzc2lvblJlbmRlclRhcmdldCk7XG5cdFx0X3RoaXMuc2V0UmVuZGVyVGFyZ2V0KGN1cnJlbnRSZW5kZXJUYXJnZXQpO1xuXHR9XG5cdGZ1bmN0aW9uIHJlbmRlck9iamVjdHMocmVuZGVyTGlzdCwgc2NlbmUsIGNhbWVyYSkge1xuXHRcdGNvbnN0IG92ZXJyaWRlTWF0ZXJpYWwgPSBzY2VuZS5pc1NjZW5lID09PSB0cnVlID8gc2NlbmUub3ZlcnJpZGVNYXRlcmlhbCA6IG51bGw7XG5cdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSByZW5kZXJMaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0Y29uc3QgcmVuZGVySXRlbSA9IHJlbmRlckxpc3RbaV07XG5cdFx0XHRjb25zdCBvYmplY3QgPSByZW5kZXJJdGVtLm9iamVjdDtcblx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gcmVuZGVySXRlbS5nZW9tZXRyeTtcblx0XHRcdGNvbnN0IG1hdGVyaWFsID0gb3ZlcnJpZGVNYXRlcmlhbCA9PT0gbnVsbCA/IHJlbmRlckl0ZW0ubWF0ZXJpYWwgOiBvdmVycmlkZU1hdGVyaWFsO1xuXHRcdFx0Y29uc3QgZ3JvdXAgPSByZW5kZXJJdGVtLmdyb3VwO1xuXHRcdFx0aWYgKG9iamVjdC5sYXllcnMudGVzdChjYW1lcmEubGF5ZXJzKSkge1xuXHRcdFx0XHRyZW5kZXJPYmplY3Qob2JqZWN0LCBzY2VuZSwgY2FtZXJhLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gcmVuZGVyT2JqZWN0KG9iamVjdCwgc2NlbmUsIGNhbWVyYSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cCkge1xuXHRcdG9iamVjdC5vbkJlZm9yZVJlbmRlcihfdGhpcywgc2NlbmUsIGNhbWVyYSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cCk7XG5cdFx0b2JqZWN0Lm1vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UsIG9iamVjdC5tYXRyaXhXb3JsZCk7XG5cdFx0b2JqZWN0Lm5vcm1hbE1hdHJpeC5nZXROb3JtYWxNYXRyaXgob2JqZWN0Lm1vZGVsVmlld01hdHJpeCk7XG5cdFx0bWF0ZXJpYWwub25CZWZvcmVSZW5kZXIoX3RoaXMsIHNjZW5lLCBjYW1lcmEsIGdlb21ldHJ5LCBvYmplY3QsIGdyb3VwKTtcblx0XHRpZiAobWF0ZXJpYWwudHJhbnNwYXJlbnQgPT09IHRydWUgJiYgbWF0ZXJpYWwuc2lkZSA9PT0gRG91YmxlU2lkZSkge1xuXHRcdFx0bWF0ZXJpYWwuc2lkZSA9IEJhY2tTaWRlO1xuXHRcdFx0bWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0X3RoaXMucmVuZGVyQnVmZmVyRGlyZWN0KGNhbWVyYSwgc2NlbmUsIGdlb21ldHJ5LCBtYXRlcmlhbCwgb2JqZWN0LCBncm91cCk7XG5cdFx0XHRtYXRlcmlhbC5zaWRlID0gRnJvbnRTaWRlO1xuXHRcdFx0bWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0X3RoaXMucmVuZGVyQnVmZmVyRGlyZWN0KGNhbWVyYSwgc2NlbmUsIGdlb21ldHJ5LCBtYXRlcmlhbCwgb2JqZWN0LCBncm91cCk7XG5cdFx0XHRtYXRlcmlhbC5zaWRlID0gRG91YmxlU2lkZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0X3RoaXMucmVuZGVyQnVmZmVyRGlyZWN0KGNhbWVyYSwgc2NlbmUsIGdlb21ldHJ5LCBtYXRlcmlhbCwgb2JqZWN0LCBncm91cCk7XG5cdFx0fVxuXHRcdG9iamVjdC5vbkFmdGVyUmVuZGVyKF90aGlzLCBzY2VuZSwgY2FtZXJhLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwKTtcblx0fVxuXHRmdW5jdGlvbiBnZXRQcm9ncmFtKG1hdGVyaWFsLCBzY2VuZSwgb2JqZWN0KSB7XG5cdFx0aWYgKHNjZW5lLmlzU2NlbmUgIT09IHRydWUpIHNjZW5lID0gX2VtcHR5U2NlbmU7IC8vIHNjZW5lIGNvdWxkIGJlIGEgTWVzaCwgTGluZSwgUG9pbnRzLCAuLi5cblxuXHRcdGNvbnN0IG1hdGVyaWFsUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KG1hdGVyaWFsKTtcblx0XHRjb25zdCBsaWdodHMgPSBjdXJyZW50UmVuZGVyU3RhdGUuc3RhdGUubGlnaHRzO1xuXHRcdGNvbnN0IHNoYWRvd3NBcnJheSA9IGN1cnJlbnRSZW5kZXJTdGF0ZS5zdGF0ZS5zaGFkb3dzQXJyYXk7XG5cdFx0Y29uc3QgbGlnaHRzU3RhdGVWZXJzaW9uID0gbGlnaHRzLnN0YXRlLnZlcnNpb247XG5cdFx0Y29uc3QgcGFyYW1ldGVycyA9IHByb2dyYW1DYWNoZS5nZXRQYXJhbWV0ZXJzKG1hdGVyaWFsLCBsaWdodHMuc3RhdGUsIHNoYWRvd3NBcnJheSwgc2NlbmUsIG9iamVjdCk7XG5cdFx0Y29uc3QgcHJvZ3JhbUNhY2hlS2V5ID0gcHJvZ3JhbUNhY2hlLmdldFByb2dyYW1DYWNoZUtleShwYXJhbWV0ZXJzKTtcblx0XHRsZXQgcHJvZ3JhbXMgPSBtYXRlcmlhbFByb3BlcnRpZXMucHJvZ3JhbXM7XG5cblx0XHQvLyBhbHdheXMgdXBkYXRlIGVudmlyb25tZW50IGFuZCBmb2cgLSBjaGFuZ2luZyB0aGVzZSB0cmlnZ2VyIGFuIGdldFByb2dyYW0gY2FsbCwgYnV0IGl0J3MgcG9zc2libGUgdGhhdCB0aGUgcHJvZ3JhbSBkb2Vzbid0IGNoYW5nZVxuXG5cdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLmVudmlyb25tZW50ID0gbWF0ZXJpYWwuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCA/IHNjZW5lLmVudmlyb25tZW50IDogbnVsbDtcblx0XHRtYXRlcmlhbFByb3BlcnRpZXMuZm9nID0gc2NlbmUuZm9nO1xuXHRcdG1hdGVyaWFsUHJvcGVydGllcy5lbnZNYXAgPSAobWF0ZXJpYWwuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCA/IGN1YmV1dm1hcHMgOiBjdWJlbWFwcykuZ2V0KG1hdGVyaWFsLmVudk1hcCB8fCBtYXRlcmlhbFByb3BlcnRpZXMuZW52aXJvbm1lbnQpO1xuXHRcdGlmIChwcm9ncmFtcyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHQvLyBuZXcgbWF0ZXJpYWxcblxuXHRcdFx0bWF0ZXJpYWwuYWRkRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIG9uTWF0ZXJpYWxEaXNwb3NlKTtcblx0XHRcdHByb2dyYW1zID0gbmV3IE1hcCgpO1xuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLnByb2dyYW1zID0gcHJvZ3JhbXM7XG5cdFx0fVxuXHRcdGxldCBwcm9ncmFtID0gcHJvZ3JhbXMuZ2V0KHByb2dyYW1DYWNoZUtleSk7XG5cdFx0aWYgKHByb2dyYW0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Ly8gZWFybHkgb3V0IGlmIHByb2dyYW0gYW5kIGxpZ2h0IHN0YXRlIGlzIGlkZW50aWNhbFxuXG5cdFx0XHRpZiAobWF0ZXJpYWxQcm9wZXJ0aWVzLmN1cnJlbnRQcm9ncmFtID09PSBwcm9ncmFtICYmIG1hdGVyaWFsUHJvcGVydGllcy5saWdodHNTdGF0ZVZlcnNpb24gPT09IGxpZ2h0c1N0YXRlVmVyc2lvbikge1xuXHRcdFx0XHR1cGRhdGVDb21tb25NYXRlcmlhbFByb3BlcnRpZXMobWF0ZXJpYWwsIHBhcmFtZXRlcnMpO1xuXHRcdFx0XHRyZXR1cm4gcHJvZ3JhbTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0cGFyYW1ldGVycy51bmlmb3JtcyA9IHByb2dyYW1DYWNoZS5nZXRVbmlmb3JtcyhtYXRlcmlhbCk7XG5cdFx0XHRtYXRlcmlhbC5vbkJ1aWxkKG9iamVjdCwgcGFyYW1ldGVycywgX3RoaXMpO1xuXHRcdFx0bWF0ZXJpYWwub25CZWZvcmVDb21waWxlKHBhcmFtZXRlcnMsIF90aGlzKTtcblx0XHRcdHByb2dyYW0gPSBwcm9ncmFtQ2FjaGUuYWNxdWlyZVByb2dyYW0ocGFyYW1ldGVycywgcHJvZ3JhbUNhY2hlS2V5KTtcblx0XHRcdHByb2dyYW1zLnNldChwcm9ncmFtQ2FjaGVLZXksIHByb2dyYW0pO1xuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLnVuaWZvcm1zID0gcGFyYW1ldGVycy51bmlmb3Jtcztcblx0XHR9XG5cdFx0Y29uc3QgdW5pZm9ybXMgPSBtYXRlcmlhbFByb3BlcnRpZXMudW5pZm9ybXM7XG5cdFx0aWYgKCFtYXRlcmlhbC5pc1NoYWRlck1hdGVyaWFsICYmICFtYXRlcmlhbC5pc1Jhd1NoYWRlck1hdGVyaWFsIHx8IG1hdGVyaWFsLmNsaXBwaW5nID09PSB0cnVlKSB7XG5cdFx0XHR1bmlmb3Jtcy5jbGlwcGluZ1BsYW5lcyA9IGNsaXBwaW5nLnVuaWZvcm07XG5cdFx0fVxuXHRcdHVwZGF0ZUNvbW1vbk1hdGVyaWFsUHJvcGVydGllcyhtYXRlcmlhbCwgcGFyYW1ldGVycyk7XG5cblx0XHQvLyBzdG9yZSB0aGUgbGlnaHQgc2V0dXAgaXQgd2FzIGNyZWF0ZWQgZm9yXG5cblx0XHRtYXRlcmlhbFByb3BlcnRpZXMubmVlZHNMaWdodHMgPSBtYXRlcmlhbE5lZWRzTGlnaHRzKG1hdGVyaWFsKTtcblx0XHRtYXRlcmlhbFByb3BlcnRpZXMubGlnaHRzU3RhdGVWZXJzaW9uID0gbGlnaHRzU3RhdGVWZXJzaW9uO1xuXHRcdGlmIChtYXRlcmlhbFByb3BlcnRpZXMubmVlZHNMaWdodHMpIHtcblx0XHRcdC8vIHdpcmUgdXAgdGhlIG1hdGVyaWFsIHRvIHRoaXMgcmVuZGVyZXIncyBsaWdodGluZyBzdGF0ZVxuXG5cdFx0XHR1bmlmb3Jtcy5hbWJpZW50TGlnaHRDb2xvci52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5hbWJpZW50O1xuXHRcdFx0dW5pZm9ybXMubGlnaHRQcm9iZS52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5wcm9iZTtcblx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbmFsTGlnaHRzLnZhbHVlID0gbGlnaHRzLnN0YXRlLmRpcmVjdGlvbmFsO1xuXHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uYWxMaWdodFNoYWRvd3MudmFsdWUgPSBsaWdodHMuc3RhdGUuZGlyZWN0aW9uYWxTaGFkb3c7XG5cdFx0XHR1bmlmb3Jtcy5zcG90TGlnaHRzLnZhbHVlID0gbGlnaHRzLnN0YXRlLnNwb3Q7XG5cdFx0XHR1bmlmb3Jtcy5zcG90TGlnaHRTaGFkb3dzLnZhbHVlID0gbGlnaHRzLnN0YXRlLnNwb3RTaGFkb3c7XG5cdFx0XHR1bmlmb3Jtcy5yZWN0QXJlYUxpZ2h0cy52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5yZWN0QXJlYTtcblx0XHRcdHVuaWZvcm1zLmx0Y18xLnZhbHVlID0gbGlnaHRzLnN0YXRlLnJlY3RBcmVhTFRDMTtcblx0XHRcdHVuaWZvcm1zLmx0Y18yLnZhbHVlID0gbGlnaHRzLnN0YXRlLnJlY3RBcmVhTFRDMjtcblx0XHRcdHVuaWZvcm1zLnBvaW50TGlnaHRzLnZhbHVlID0gbGlnaHRzLnN0YXRlLnBvaW50O1xuXHRcdFx0dW5pZm9ybXMucG9pbnRMaWdodFNoYWRvd3MudmFsdWUgPSBsaWdodHMuc3RhdGUucG9pbnRTaGFkb3c7XG5cdFx0XHR1bmlmb3Jtcy5oZW1pc3BoZXJlTGlnaHRzLnZhbHVlID0gbGlnaHRzLnN0YXRlLmhlbWk7XG5cdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb25hbFNoYWRvd01hcC52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5kaXJlY3Rpb25hbFNoYWRvd01hcDtcblx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbmFsU2hhZG93TWF0cml4LnZhbHVlID0gbGlnaHRzLnN0YXRlLmRpcmVjdGlvbmFsU2hhZG93TWF0cml4O1xuXHRcdFx0dW5pZm9ybXMuc3BvdFNoYWRvd01hcC52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5zcG90U2hhZG93TWFwO1xuXHRcdFx0dW5pZm9ybXMuc3BvdExpZ2h0TWF0cml4LnZhbHVlID0gbGlnaHRzLnN0YXRlLnNwb3RMaWdodE1hdHJpeDtcblx0XHRcdHVuaWZvcm1zLnNwb3RMaWdodE1hcC52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5zcG90TGlnaHRNYXA7XG5cdFx0XHR1bmlmb3Jtcy5wb2ludFNoYWRvd01hcC52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5wb2ludFNoYWRvd01hcDtcblx0XHRcdHVuaWZvcm1zLnBvaW50U2hhZG93TWF0cml4LnZhbHVlID0gbGlnaHRzLnN0YXRlLnBvaW50U2hhZG93TWF0cml4O1xuXHRcdFx0Ly8gVE9ETyAoYWJlbG5hdGlvbik6IGFkZCBhcmVhIGxpZ2h0cyBzaGFkb3cgaW5mbyB0byB1bmlmb3Jtc1xuXHRcdH1cblxuXHRcdGNvbnN0IHByb2dVbmlmb3JtcyA9IHByb2dyYW0uZ2V0VW5pZm9ybXMoKTtcblx0XHRjb25zdCB1bmlmb3Jtc0xpc3QgPSBXZWJHTFVuaWZvcm1zLnNlcVdpdGhWYWx1ZShwcm9nVW5pZm9ybXMuc2VxLCB1bmlmb3Jtcyk7XG5cdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLmN1cnJlbnRQcm9ncmFtID0gcHJvZ3JhbTtcblx0XHRtYXRlcmlhbFByb3BlcnRpZXMudW5pZm9ybXNMaXN0ID0gdW5pZm9ybXNMaXN0O1xuXHRcdHJldHVybiBwcm9ncmFtO1xuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUNvbW1vbk1hdGVyaWFsUHJvcGVydGllcyhtYXRlcmlhbCwgcGFyYW1ldGVycykge1xuXHRcdGNvbnN0IG1hdGVyaWFsUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KG1hdGVyaWFsKTtcblx0XHRtYXRlcmlhbFByb3BlcnRpZXMub3V0cHV0RW5jb2RpbmcgPSBwYXJhbWV0ZXJzLm91dHB1dEVuY29kaW5nO1xuXHRcdG1hdGVyaWFsUHJvcGVydGllcy5pbnN0YW5jaW5nID0gcGFyYW1ldGVycy5pbnN0YW5jaW5nO1xuXHRcdG1hdGVyaWFsUHJvcGVydGllcy5za2lubmluZyA9IHBhcmFtZXRlcnMuc2tpbm5pbmc7XG5cdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLm1vcnBoVGFyZ2V0cyA9IHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzO1xuXHRcdG1hdGVyaWFsUHJvcGVydGllcy5tb3JwaE5vcm1hbHMgPSBwYXJhbWV0ZXJzLm1vcnBoTm9ybWFscztcblx0XHRtYXRlcmlhbFByb3BlcnRpZXMubW9ycGhDb2xvcnMgPSBwYXJhbWV0ZXJzLm1vcnBoQ29sb3JzO1xuXHRcdG1hdGVyaWFsUHJvcGVydGllcy5tb3JwaFRhcmdldHNDb3VudCA9IHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzQ291bnQ7XG5cdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLm51bUNsaXBwaW5nUGxhbmVzID0gcGFyYW1ldGVycy5udW1DbGlwcGluZ1BsYW5lcztcblx0XHRtYXRlcmlhbFByb3BlcnRpZXMubnVtSW50ZXJzZWN0aW9uID0gcGFyYW1ldGVycy5udW1DbGlwSW50ZXJzZWN0aW9uO1xuXHRcdG1hdGVyaWFsUHJvcGVydGllcy52ZXJ0ZXhBbHBoYXMgPSBwYXJhbWV0ZXJzLnZlcnRleEFscGhhcztcblx0XHRtYXRlcmlhbFByb3BlcnRpZXMudmVydGV4VGFuZ2VudHMgPSBwYXJhbWV0ZXJzLnZlcnRleFRhbmdlbnRzO1xuXHRcdG1hdGVyaWFsUHJvcGVydGllcy50b25lTWFwcGluZyA9IHBhcmFtZXRlcnMudG9uZU1hcHBpbmc7XG5cdH1cblx0ZnVuY3Rpb24gc2V0UHJvZ3JhbShjYW1lcmEsIHNjZW5lLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIG9iamVjdCkge1xuXHRcdGlmIChzY2VuZS5pc1NjZW5lICE9PSB0cnVlKSBzY2VuZSA9IF9lbXB0eVNjZW5lOyAvLyBzY2VuZSBjb3VsZCBiZSBhIE1lc2gsIExpbmUsIFBvaW50cywgLi4uXG5cblx0XHR0ZXh0dXJlcy5yZXNldFRleHR1cmVVbml0cygpO1xuXHRcdGNvbnN0IGZvZyA9IHNjZW5lLmZvZztcblx0XHRjb25zdCBlbnZpcm9ubWVudCA9IG1hdGVyaWFsLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgPyBzY2VuZS5lbnZpcm9ubWVudCA6IG51bGw7XG5cdFx0Y29uc3QgZW5jb2RpbmcgPSBfY3VycmVudFJlbmRlclRhcmdldCA9PT0gbnVsbCA/IF90aGlzLm91dHB1dEVuY29kaW5nIDogX2N1cnJlbnRSZW5kZXJUYXJnZXQuaXNYUlJlbmRlclRhcmdldCA9PT0gdHJ1ZSA/IF9jdXJyZW50UmVuZGVyVGFyZ2V0LnRleHR1cmUuZW5jb2RpbmcgOiBMaW5lYXJFbmNvZGluZztcblx0XHRjb25zdCBlbnZNYXAgPSAobWF0ZXJpYWwuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCA/IGN1YmV1dm1hcHMgOiBjdWJlbWFwcykuZ2V0KG1hdGVyaWFsLmVudk1hcCB8fCBlbnZpcm9ubWVudCk7XG5cdFx0Y29uc3QgdmVydGV4QWxwaGFzID0gbWF0ZXJpYWwudmVydGV4Q29sb3JzID09PSB0cnVlICYmICEhZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvciAmJiBnZW9tZXRyeS5hdHRyaWJ1dGVzLmNvbG9yLml0ZW1TaXplID09PSA0O1xuXHRcdGNvbnN0IHZlcnRleFRhbmdlbnRzID0gISFtYXRlcmlhbC5ub3JtYWxNYXAgJiYgISFnZW9tZXRyeS5hdHRyaWJ1dGVzLnRhbmdlbnQ7XG5cdFx0Y29uc3QgbW9ycGhUYXJnZXRzID0gISFnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0Y29uc3QgbW9ycGhOb3JtYWxzID0gISFnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsO1xuXHRcdGNvbnN0IG1vcnBoQ29sb3JzID0gISFnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMuY29sb3I7XG5cdFx0Y29uc3QgdG9uZU1hcHBpbmcgPSBtYXRlcmlhbC50b25lTWFwcGVkID8gX3RoaXMudG9uZU1hcHBpbmcgOiBOb1RvbmVNYXBwaW5nO1xuXHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uIHx8IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5ub3JtYWwgfHwgZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLmNvbG9yO1xuXHRcdGNvbnN0IG1vcnBoVGFyZ2V0c0NvdW50ID0gbW9ycGhBdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCA/IG1vcnBoQXR0cmlidXRlLmxlbmd0aCA6IDA7XG5cdFx0Y29uc3QgbWF0ZXJpYWxQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQobWF0ZXJpYWwpO1xuXHRcdGNvbnN0IGxpZ2h0cyA9IGN1cnJlbnRSZW5kZXJTdGF0ZS5zdGF0ZS5saWdodHM7XG5cdFx0aWYgKF9jbGlwcGluZ0VuYWJsZWQgPT09IHRydWUpIHtcblx0XHRcdGlmIChfbG9jYWxDbGlwcGluZ0VuYWJsZWQgPT09IHRydWUgfHwgY2FtZXJhICE9PSBfY3VycmVudENhbWVyYSkge1xuXHRcdFx0XHRjb25zdCB1c2VDYWNoZSA9IGNhbWVyYSA9PT0gX2N1cnJlbnRDYW1lcmEgJiYgbWF0ZXJpYWwuaWQgPT09IF9jdXJyZW50TWF0ZXJpYWxJZDtcblxuXHRcdFx0XHQvLyB3ZSBtaWdodCB3YW50IHRvIGNhbGwgdGhpcyBmdW5jdGlvbiB3aXRoIHNvbWUgQ2xpcHBpbmdHcm91cFxuXHRcdFx0XHQvLyBvYmplY3QgaW5zdGVhZCBvZiB0aGUgbWF0ZXJpYWwsIG9uY2UgaXQgYmVjb21lcyBmZWFzaWJsZVxuXHRcdFx0XHQvLyAoIzg0NjUsICM4Mzc5KVxuXHRcdFx0XHRjbGlwcGluZy5zZXRTdGF0ZShtYXRlcmlhbCwgY2FtZXJhLCB1c2VDYWNoZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdGxldCBuZWVkc1Byb2dyYW1DaGFuZ2UgPSBmYWxzZTtcblx0XHRpZiAobWF0ZXJpYWwudmVyc2lvbiA9PT0gbWF0ZXJpYWxQcm9wZXJ0aWVzLl9fdmVyc2lvbikge1xuXHRcdFx0aWYgKG1hdGVyaWFsUHJvcGVydGllcy5uZWVkc0xpZ2h0cyAmJiBtYXRlcmlhbFByb3BlcnRpZXMubGlnaHRzU3RhdGVWZXJzaW9uICE9PSBsaWdodHMuc3RhdGUudmVyc2lvbikge1xuXHRcdFx0XHRuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIGlmIChtYXRlcmlhbFByb3BlcnRpZXMub3V0cHV0RW5jb2RpbmcgIT09IGVuY29kaW5nKSB7XG5cdFx0XHRcdG5lZWRzUHJvZ3JhbUNoYW5nZSA9IHRydWU7XG5cdFx0XHR9IGVsc2UgaWYgKG9iamVjdC5pc0luc3RhbmNlZE1lc2ggJiYgbWF0ZXJpYWxQcm9wZXJ0aWVzLmluc3RhbmNpbmcgPT09IGZhbHNlKSB7XG5cdFx0XHRcdG5lZWRzUHJvZ3JhbUNoYW5nZSA9IHRydWU7XG5cdFx0XHR9IGVsc2UgaWYgKCFvYmplY3QuaXNJbnN0YW5jZWRNZXNoICYmIG1hdGVyaWFsUHJvcGVydGllcy5pbnN0YW5jaW5nID09PSB0cnVlKSB7XG5cdFx0XHRcdG5lZWRzUHJvZ3JhbUNoYW5nZSA9IHRydWU7XG5cdFx0XHR9IGVsc2UgaWYgKG9iamVjdC5pc1NraW5uZWRNZXNoICYmIG1hdGVyaWFsUHJvcGVydGllcy5za2lubmluZyA9PT0gZmFsc2UpIHtcblx0XHRcdFx0bmVlZHNQcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSBpZiAoIW9iamVjdC5pc1NraW5uZWRNZXNoICYmIG1hdGVyaWFsUHJvcGVydGllcy5za2lubmluZyA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIGlmIChtYXRlcmlhbFByb3BlcnRpZXMuZW52TWFwICE9PSBlbnZNYXApIHtcblx0XHRcdFx0bmVlZHNQcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSBpZiAobWF0ZXJpYWwuZm9nID09PSB0cnVlICYmIG1hdGVyaWFsUHJvcGVydGllcy5mb2cgIT09IGZvZykge1xuXHRcdFx0XHRuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIGlmIChtYXRlcmlhbFByb3BlcnRpZXMubnVtQ2xpcHBpbmdQbGFuZXMgIT09IHVuZGVmaW5lZCAmJiAobWF0ZXJpYWxQcm9wZXJ0aWVzLm51bUNsaXBwaW5nUGxhbmVzICE9PSBjbGlwcGluZy5udW1QbGFuZXMgfHwgbWF0ZXJpYWxQcm9wZXJ0aWVzLm51bUludGVyc2VjdGlvbiAhPT0gY2xpcHBpbmcubnVtSW50ZXJzZWN0aW9uKSkge1xuXHRcdFx0XHRuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIGlmIChtYXRlcmlhbFByb3BlcnRpZXMudmVydGV4QWxwaGFzICE9PSB2ZXJ0ZXhBbHBoYXMpIHtcblx0XHRcdFx0bmVlZHNQcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSBpZiAobWF0ZXJpYWxQcm9wZXJ0aWVzLnZlcnRleFRhbmdlbnRzICE9PSB2ZXJ0ZXhUYW5nZW50cykge1xuXHRcdFx0XHRuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIGlmIChtYXRlcmlhbFByb3BlcnRpZXMubW9ycGhUYXJnZXRzICE9PSBtb3JwaFRhcmdldHMpIHtcblx0XHRcdFx0bmVlZHNQcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSBpZiAobWF0ZXJpYWxQcm9wZXJ0aWVzLm1vcnBoTm9ybWFscyAhPT0gbW9ycGhOb3JtYWxzKSB7XG5cdFx0XHRcdG5lZWRzUHJvZ3JhbUNoYW5nZSA9IHRydWU7XG5cdFx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsUHJvcGVydGllcy5tb3JwaENvbG9ycyAhPT0gbW9ycGhDb2xvcnMpIHtcblx0XHRcdFx0bmVlZHNQcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSBpZiAobWF0ZXJpYWxQcm9wZXJ0aWVzLnRvbmVNYXBwaW5nICE9PSB0b25lTWFwcGluZykge1xuXHRcdFx0XHRuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIGlmIChjYXBhYmlsaXRpZXMuaXNXZWJHTDIgPT09IHRydWUgJiYgbWF0ZXJpYWxQcm9wZXJ0aWVzLm1vcnBoVGFyZ2V0c0NvdW50ICE9PSBtb3JwaFRhcmdldHNDb3VudCkge1xuXHRcdFx0XHRuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLl9fdmVyc2lvbiA9IG1hdGVyaWFsLnZlcnNpb247XG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdGxldCBwcm9ncmFtID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLmN1cnJlbnRQcm9ncmFtO1xuXHRcdGlmIChuZWVkc1Byb2dyYW1DaGFuZ2UgPT09IHRydWUpIHtcblx0XHRcdHByb2dyYW0gPSBnZXRQcm9ncmFtKG1hdGVyaWFsLCBzY2VuZSwgb2JqZWN0KTtcblx0XHR9XG5cdFx0bGV0IHJlZnJlc2hQcm9ncmFtID0gZmFsc2U7XG5cdFx0bGV0IHJlZnJlc2hNYXRlcmlhbCA9IGZhbHNlO1xuXHRcdGxldCByZWZyZXNoTGlnaHRzID0gZmFsc2U7XG5cdFx0Y29uc3QgcF91bmlmb3JtcyA9IHByb2dyYW0uZ2V0VW5pZm9ybXMoKSxcblx0XHRcdG1fdW5pZm9ybXMgPSBtYXRlcmlhbFByb3BlcnRpZXMudW5pZm9ybXM7XG5cdFx0aWYgKHN0YXRlLnVzZVByb2dyYW0ocHJvZ3JhbS5wcm9ncmFtKSkge1xuXHRcdFx0cmVmcmVzaFByb2dyYW0gPSB0cnVlO1xuXHRcdFx0cmVmcmVzaE1hdGVyaWFsID0gdHJ1ZTtcblx0XHRcdHJlZnJlc2hMaWdodHMgPSB0cnVlO1xuXHRcdH1cblx0XHRpZiAobWF0ZXJpYWwuaWQgIT09IF9jdXJyZW50TWF0ZXJpYWxJZCkge1xuXHRcdFx0X2N1cnJlbnRNYXRlcmlhbElkID0gbWF0ZXJpYWwuaWQ7XG5cdFx0XHRyZWZyZXNoTWF0ZXJpYWwgPSB0cnVlO1xuXHRcdH1cblx0XHRpZiAocmVmcmVzaFByb2dyYW0gfHwgX2N1cnJlbnRDYW1lcmEgIT09IGNhbWVyYSkge1xuXHRcdFx0cF91bmlmb3Jtcy5zZXRWYWx1ZShfZ2wsICdwcm9qZWN0aW9uTWF0cml4JywgY2FtZXJhLnByb2plY3Rpb25NYXRyaXgpO1xuXHRcdFx0aWYgKGNhcGFiaWxpdGllcy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyKSB7XG5cdFx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoX2dsLCAnbG9nRGVwdGhCdWZGQycsIDIuMCAvIChNYXRoLmxvZyhjYW1lcmEuZmFyICsgMS4wKSAvIE1hdGguTE4yKSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoX2N1cnJlbnRDYW1lcmEgIT09IGNhbWVyYSkge1xuXHRcdFx0XHRfY3VycmVudENhbWVyYSA9IGNhbWVyYTtcblxuXHRcdFx0XHQvLyBsaWdodGluZyB1bmlmb3JtcyBkZXBlbmQgb24gdGhlIGNhbWVyYSBzbyBlbmZvcmNlIGFuIHVwZGF0ZVxuXHRcdFx0XHQvLyBub3csIGluIGNhc2UgdGhpcyBtYXRlcmlhbCBzdXBwb3J0cyBsaWdodHMgLSBvciBsYXRlciwgd2hlblxuXHRcdFx0XHQvLyB0aGUgbmV4dCBtYXRlcmlhbCB0aGF0IGRvZXMgZ2V0cyBhY3RpdmF0ZWQ6XG5cblx0XHRcdFx0cmVmcmVzaE1hdGVyaWFsID0gdHJ1ZTsgLy8gc2V0IHRvIHRydWUgb24gbWF0ZXJpYWwgY2hhbmdlXG5cdFx0XHRcdHJlZnJlc2hMaWdodHMgPSB0cnVlOyAvLyByZW1haW5zIHNldCB1bnRpbCB1cGRhdGUgZG9uZVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBsb2FkIG1hdGVyaWFsIHNwZWNpZmljIHVuaWZvcm1zXG5cdFx0XHQvLyAoc2hhZGVyIG1hdGVyaWFsIGFsc28gZ2V0cyB0aGVtIGZvciB0aGUgc2FrZSBvZiBnZW5lcmljaXR5KVxuXG5cdFx0XHRpZiAobWF0ZXJpYWwuaXNTaGFkZXJNYXRlcmlhbCB8fCBtYXRlcmlhbC5pc01lc2hQaG9uZ01hdGVyaWFsIHx8IG1hdGVyaWFsLmlzTWVzaFRvb25NYXRlcmlhbCB8fCBtYXRlcmlhbC5pc01lc2hTdGFuZGFyZE1hdGVyaWFsIHx8IG1hdGVyaWFsLmVudk1hcCkge1xuXHRcdFx0XHRjb25zdCB1Q2FtUG9zID0gcF91bmlmb3Jtcy5tYXAuY2FtZXJhUG9zaXRpb247XG5cdFx0XHRcdGlmICh1Q2FtUG9zICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHR1Q2FtUG9zLnNldFZhbHVlKF9nbCwgX3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGNhbWVyYS5tYXRyaXhXb3JsZCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAobWF0ZXJpYWwuaXNNZXNoUGhvbmdNYXRlcmlhbCB8fCBtYXRlcmlhbC5pc01lc2hUb29uTWF0ZXJpYWwgfHwgbWF0ZXJpYWwuaXNNZXNoTGFtYmVydE1hdGVyaWFsIHx8IG1hdGVyaWFsLmlzTWVzaEJhc2ljTWF0ZXJpYWwgfHwgbWF0ZXJpYWwuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCB8fCBtYXRlcmlhbC5pc1NoYWRlck1hdGVyaWFsKSB7XG5cdFx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoX2dsLCAnaXNPcnRob2dyYXBoaWMnLCBjYW1lcmEuaXNPcnRob2dyYXBoaWNDYW1lcmEgPT09IHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKG1hdGVyaWFsLmlzTWVzaFBob25nTWF0ZXJpYWwgfHwgbWF0ZXJpYWwuaXNNZXNoVG9vbk1hdGVyaWFsIHx8IG1hdGVyaWFsLmlzTWVzaExhbWJlcnRNYXRlcmlhbCB8fCBtYXRlcmlhbC5pc01lc2hCYXNpY01hdGVyaWFsIHx8IG1hdGVyaWFsLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgfHwgbWF0ZXJpYWwuaXNTaGFkZXJNYXRlcmlhbCB8fCBtYXRlcmlhbC5pc1NoYWRvd01hdGVyaWFsIHx8IG9iamVjdC5pc1NraW5uZWRNZXNoKSB7XG5cdFx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoX2dsLCAndmlld01hdHJpeCcsIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHNraW5uaW5nIGFuZCBtb3JwaCB0YXJnZXQgdW5pZm9ybXMgbXVzdCBiZSBzZXQgZXZlbiBpZiBtYXRlcmlhbCBkaWRuJ3QgY2hhbmdlXG5cdFx0Ly8gYXV0by1zZXR0aW5nIG9mIHRleHR1cmUgdW5pdCBmb3IgYm9uZSBhbmQgbW9ycGggdGV4dHVyZSBtdXN0IGdvIGJlZm9yZSBvdGhlciB0ZXh0dXJlc1xuXHRcdC8vIG90aGVyd2lzZSB0ZXh0dXJlcyB1c2VkIGZvciBza2lubmluZyBhbmQgbW9ycGhpbmcgY2FuIHRha2Ugb3ZlciB0ZXh0dXJlIHVuaXRzIHJlc2VydmVkIGZvciBvdGhlciBtYXRlcmlhbCB0ZXh0dXJlc1xuXG5cdFx0aWYgKG9iamVjdC5pc1NraW5uZWRNZXNoKSB7XG5cdFx0XHRwX3VuaWZvcm1zLnNldE9wdGlvbmFsKF9nbCwgb2JqZWN0LCAnYmluZE1hdHJpeCcpO1xuXHRcdFx0cF91bmlmb3Jtcy5zZXRPcHRpb25hbChfZ2wsIG9iamVjdCwgJ2JpbmRNYXRyaXhJbnZlcnNlJyk7XG5cdFx0XHRjb25zdCBza2VsZXRvbiA9IG9iamVjdC5za2VsZXRvbjtcblx0XHRcdGlmIChza2VsZXRvbikge1xuXHRcdFx0XHRpZiAoY2FwYWJpbGl0aWVzLmZsb2F0VmVydGV4VGV4dHVyZXMpIHtcblx0XHRcdFx0XHRpZiAoc2tlbGV0b24uYm9uZVRleHR1cmUgPT09IG51bGwpIHNrZWxldG9uLmNvbXB1dGVCb25lVGV4dHVyZSgpO1xuXHRcdFx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoX2dsLCAnYm9uZVRleHR1cmUnLCBza2VsZXRvbi5ib25lVGV4dHVyZSwgdGV4dHVyZXMpO1xuXHRcdFx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoX2dsLCAnYm9uZVRleHR1cmVTaXplJywgc2tlbGV0b24uYm9uZVRleHR1cmVTaXplKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFNraW5uZWRNZXNoIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBXZWJHTCAyLiBXaXRoIFdlYkdMIDEgT0VTX3RleHR1cmVfZmxvYXQgYW5kIHZlcnRleCB0ZXh0dXJlcyBzdXBwb3J0IGlzIHJlcXVpcmVkLicpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlcyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcztcblx0XHRpZiAobW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uICE9PSB1bmRlZmluZWQgfHwgbW9ycGhBdHRyaWJ1dGVzLm5vcm1hbCAhPT0gdW5kZWZpbmVkIHx8IG1vcnBoQXR0cmlidXRlcy5jb2xvciAhPT0gdW5kZWZpbmVkICYmIGNhcGFiaWxpdGllcy5pc1dlYkdMMiA9PT0gdHJ1ZSkge1xuXHRcdFx0bW9ycGh0YXJnZXRzLnVwZGF0ZShvYmplY3QsIGdlb21ldHJ5LCBtYXRlcmlhbCwgcHJvZ3JhbSk7XG5cdFx0fVxuXHRcdGlmIChyZWZyZXNoTWF0ZXJpYWwgfHwgbWF0ZXJpYWxQcm9wZXJ0aWVzLnJlY2VpdmVTaGFkb3cgIT09IG9iamVjdC5yZWNlaXZlU2hhZG93KSB7XG5cdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMucmVjZWl2ZVNoYWRvdyA9IG9iamVjdC5yZWNlaXZlU2hhZG93O1xuXHRcdFx0cF91bmlmb3Jtcy5zZXRWYWx1ZShfZ2wsICdyZWNlaXZlU2hhZG93Jywgb2JqZWN0LnJlY2VpdmVTaGFkb3cpO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvcHVsbC8yNDQ2NyNpc3N1ZWNvbW1lbnQtMTIwOTAzMTUxMlxuXG5cdFx0aWYgKG1hdGVyaWFsLmlzTWVzaEdvdXJhdWRNYXRlcmlhbCAmJiBtYXRlcmlhbC5lbnZNYXAgIT09IG51bGwpIHtcblx0XHRcdG1fdW5pZm9ybXMuZW52TWFwLnZhbHVlID0gZW52TWFwO1xuXHRcdFx0bV91bmlmb3Jtcy5mbGlwRW52TWFwLnZhbHVlID0gZW52TWFwLmlzQ3ViZVRleHR1cmUgJiYgZW52TWFwLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSA9PT0gZmFsc2UgPyAtMSA6IDE7XG5cdFx0fVxuXHRcdGlmIChyZWZyZXNoTWF0ZXJpYWwpIHtcblx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoX2dsLCAndG9uZU1hcHBpbmdFeHBvc3VyZScsIF90aGlzLnRvbmVNYXBwaW5nRXhwb3N1cmUpO1xuXHRcdFx0aWYgKG1hdGVyaWFsUHJvcGVydGllcy5uZWVkc0xpZ2h0cykge1xuXHRcdFx0XHQvLyB0aGUgY3VycmVudCBtYXRlcmlhbCByZXF1aXJlcyBsaWdodGluZyBpbmZvXG5cblx0XHRcdFx0Ly8gbm90ZTogYWxsIGxpZ2h0aW5nIHVuaWZvcm1zIGFyZSBhbHdheXMgc2V0IGNvcnJlY3RseVxuXHRcdFx0XHQvLyB0aGV5IHNpbXBseSByZWZlcmVuY2UgdGhlIHJlbmRlcmVyJ3Mgc3RhdGUgZm9yIHRoZWlyXG5cdFx0XHRcdC8vIHZhbHVlc1xuXHRcdFx0XHQvL1xuXHRcdFx0XHQvLyB1c2UgdGhlIGN1cnJlbnQgbWF0ZXJpYWwncyAubmVlZHNVcGRhdGUgZmxhZ3MgdG8gc2V0XG5cdFx0XHRcdC8vIHRoZSBHTCBzdGF0ZSB3aGVuIHJlcXVpcmVkXG5cblx0XHRcdFx0bWFya1VuaWZvcm1zTGlnaHRzTmVlZHNVcGRhdGUobV91bmlmb3JtcywgcmVmcmVzaExpZ2h0cyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHJlZnJlc2ggdW5pZm9ybXMgY29tbW9uIHRvIHNldmVyYWwgbWF0ZXJpYWxzXG5cblx0XHRcdGlmIChmb2cgJiYgbWF0ZXJpYWwuZm9nID09PSB0cnVlKSB7XG5cdFx0XHRcdG1hdGVyaWFscy5yZWZyZXNoRm9nVW5pZm9ybXMobV91bmlmb3JtcywgZm9nKTtcblx0XHRcdH1cblx0XHRcdG1hdGVyaWFscy5yZWZyZXNoTWF0ZXJpYWxVbmlmb3JtcyhtX3VuaWZvcm1zLCBtYXRlcmlhbCwgX3BpeGVsUmF0aW8sIF9oZWlnaHQsIF90cmFuc21pc3Npb25SZW5kZXJUYXJnZXQpO1xuXHRcdFx0V2ViR0xVbmlmb3Jtcy51cGxvYWQoX2dsLCBtYXRlcmlhbFByb3BlcnRpZXMudW5pZm9ybXNMaXN0LCBtX3VuaWZvcm1zLCB0ZXh0dXJlcyk7XG5cdFx0fVxuXHRcdGlmIChtYXRlcmlhbC5pc1NoYWRlck1hdGVyaWFsICYmIG1hdGVyaWFsLnVuaWZvcm1zTmVlZFVwZGF0ZSA9PT0gdHJ1ZSkge1xuXHRcdFx0V2ViR0xVbmlmb3Jtcy51cGxvYWQoX2dsLCBtYXRlcmlhbFByb3BlcnRpZXMudW5pZm9ybXNMaXN0LCBtX3VuaWZvcm1zLCB0ZXh0dXJlcyk7XG5cdFx0XHRtYXRlcmlhbC51bmlmb3Jtc05lZWRVcGRhdGUgPSBmYWxzZTtcblx0XHR9XG5cdFx0aWYgKG1hdGVyaWFsLmlzU3ByaXRlTWF0ZXJpYWwpIHtcblx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoX2dsLCAnY2VudGVyJywgb2JqZWN0LmNlbnRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gY29tbW9uIG1hdHJpY2VzXG5cblx0XHRwX3VuaWZvcm1zLnNldFZhbHVlKF9nbCwgJ21vZGVsVmlld01hdHJpeCcsIG9iamVjdC5tb2RlbFZpZXdNYXRyaXgpO1xuXHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoX2dsLCAnbm9ybWFsTWF0cml4Jywgb2JqZWN0Lm5vcm1hbE1hdHJpeCk7XG5cdFx0cF91bmlmb3Jtcy5zZXRWYWx1ZShfZ2wsICdtb2RlbE1hdHJpeCcsIG9iamVjdC5tYXRyaXhXb3JsZCk7XG5cblx0XHQvLyBVQk9zXG5cblx0XHRpZiAobWF0ZXJpYWwuaXNTaGFkZXJNYXRlcmlhbCB8fCBtYXRlcmlhbC5pc1Jhd1NoYWRlck1hdGVyaWFsKSB7XG5cdFx0XHRjb25zdCBncm91cHMgPSBtYXRlcmlhbC51bmlmb3Jtc0dyb3Vwcztcblx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRpZiAoY2FwYWJpbGl0aWVzLmlzV2ViR0wyKSB7XG5cdFx0XHRcdFx0Y29uc3QgZ3JvdXAgPSBncm91cHNbaV07XG5cdFx0XHRcdFx0dW5pZm9ybXNHcm91cHMudXBkYXRlKGdyb3VwLCBwcm9ncmFtKTtcblx0XHRcdFx0XHR1bmlmb3Jtc0dyb3Vwcy5iaW5kKGdyb3VwLCBwcm9ncmFtKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFVuaWZvcm0gQnVmZmVyIE9iamVjdHMgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIFdlYkdMIDIuJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHByb2dyYW07XG5cdH1cblxuXHQvLyBJZiB1bmlmb3JtcyBhcmUgbWFya2VkIGFzIGNsZWFuLCB0aGV5IGRvbid0IG5lZWQgdG8gYmUgbG9hZGVkIHRvIHRoZSBHUFUuXG5cblx0ZnVuY3Rpb24gbWFya1VuaWZvcm1zTGlnaHRzTmVlZHNVcGRhdGUodW5pZm9ybXMsIHZhbHVlKSB7XG5cdFx0dW5pZm9ybXMuYW1iaWVudExpZ2h0Q29sb3IubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblx0XHR1bmlmb3Jtcy5saWdodFByb2JlLm5lZWRzVXBkYXRlID0gdmFsdWU7XG5cdFx0dW5pZm9ybXMuZGlyZWN0aW9uYWxMaWdodHMubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblx0XHR1bmlmb3Jtcy5kaXJlY3Rpb25hbExpZ2h0U2hhZG93cy5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXHRcdHVuaWZvcm1zLnBvaW50TGlnaHRzLm5lZWRzVXBkYXRlID0gdmFsdWU7XG5cdFx0dW5pZm9ybXMucG9pbnRMaWdodFNoYWRvd3MubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblx0XHR1bmlmb3Jtcy5zcG90TGlnaHRzLm5lZWRzVXBkYXRlID0gdmFsdWU7XG5cdFx0dW5pZm9ybXMuc3BvdExpZ2h0U2hhZG93cy5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXHRcdHVuaWZvcm1zLnJlY3RBcmVhTGlnaHRzLm5lZWRzVXBkYXRlID0gdmFsdWU7XG5cdFx0dW5pZm9ybXMuaGVtaXNwaGVyZUxpZ2h0cy5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXHR9XG5cdGZ1bmN0aW9uIG1hdGVyaWFsTmVlZHNMaWdodHMobWF0ZXJpYWwpIHtcblx0XHRyZXR1cm4gbWF0ZXJpYWwuaXNNZXNoTGFtYmVydE1hdGVyaWFsIHx8IG1hdGVyaWFsLmlzTWVzaFRvb25NYXRlcmlhbCB8fCBtYXRlcmlhbC5pc01lc2hQaG9uZ01hdGVyaWFsIHx8IG1hdGVyaWFsLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgfHwgbWF0ZXJpYWwuaXNTaGFkb3dNYXRlcmlhbCB8fCBtYXRlcmlhbC5pc1NoYWRlck1hdGVyaWFsICYmIG1hdGVyaWFsLmxpZ2h0cyA9PT0gdHJ1ZTtcblx0fVxuXHR0aGlzLmdldEFjdGl2ZUN1YmVGYWNlID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBfY3VycmVudEFjdGl2ZUN1YmVGYWNlO1xuXHR9O1xuXHR0aGlzLmdldEFjdGl2ZU1pcG1hcExldmVsID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBfY3VycmVudEFjdGl2ZU1pcG1hcExldmVsO1xuXHR9O1xuXHR0aGlzLmdldFJlbmRlclRhcmdldCA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gX2N1cnJlbnRSZW5kZXJUYXJnZXQ7XG5cdH07XG5cdHRoaXMuc2V0UmVuZGVyVGFyZ2V0VGV4dHVyZXMgPSBmdW5jdGlvbiAocmVuZGVyVGFyZ2V0LCBjb2xvclRleHR1cmUsIGRlcHRoVGV4dHVyZSkge1xuXHRcdHByb3BlcnRpZXMuZ2V0KHJlbmRlclRhcmdldC50ZXh0dXJlKS5fX3dlYmdsVGV4dHVyZSA9IGNvbG9yVGV4dHVyZTtcblx0XHRwcm9wZXJ0aWVzLmdldChyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlKS5fX3dlYmdsVGV4dHVyZSA9IGRlcHRoVGV4dHVyZTtcblx0XHRjb25zdCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQocmVuZGVyVGFyZ2V0KTtcblx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9faGFzRXh0ZXJuYWxUZXh0dXJlcyA9IHRydWU7XG5cdFx0aWYgKHJlbmRlclRhcmdldFByb3BlcnRpZXMuX19oYXNFeHRlcm5hbFRleHR1cmVzKSB7XG5cdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fYXV0b0FsbG9jYXRlRGVwdGhCdWZmZXIgPSBkZXB0aFRleHR1cmUgPT09IHVuZGVmaW5lZDtcblx0XHRcdGlmICghcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX2F1dG9BbGxvY2F0ZURlcHRoQnVmZmVyKSB7XG5cdFx0XHRcdC8vIFRoZSBtdWx0aXNhbXBsZV9yZW5kZXJfdG9fdGV4dHVyZSBleHRlbnNpb24gZG9lc24ndCB3b3JrIHByb3Blcmx5IGlmIHRoZXJlXG5cdFx0XHRcdC8vIGFyZSBtaWRmcmFtZSBmbHVzaGVzIGFuZCBhbiBleHRlcm5hbCBkZXB0aCBidWZmZXIuIERpc2FibGUgdXNlIG9mIHRoZSBleHRlbnNpb24uXG5cdFx0XHRcdGlmIChleHRlbnNpb25zLmhhcygnV0VCR0xfbXVsdGlzYW1wbGVkX3JlbmRlcl90b190ZXh0dXJlJykgPT09IHRydWUpIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFJlbmRlci10by10ZXh0dXJlIGV4dGVuc2lvbiB3YXMgZGlzYWJsZWQgYmVjYXVzZSBhbiBleHRlcm5hbCB0ZXh0dXJlIHdhcyBwcm92aWRlZCcpO1xuXHRcdFx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX191c2VSZW5kZXJUb1RleHR1cmUgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0dGhpcy5zZXRSZW5kZXJUYXJnZXRGcmFtZWJ1ZmZlciA9IGZ1bmN0aW9uIChyZW5kZXJUYXJnZXQsIGRlZmF1bHRGcmFtZWJ1ZmZlcikge1xuXHRcdGNvbnN0IHJlbmRlclRhcmdldFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldChyZW5kZXJUYXJnZXQpO1xuXHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyID0gZGVmYXVsdEZyYW1lYnVmZmVyO1xuXHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX191c2VEZWZhdWx0RnJhbWVidWZmZXIgPSBkZWZhdWx0RnJhbWVidWZmZXIgPT09IHVuZGVmaW5lZDtcblx0fTtcblx0dGhpcy5zZXRSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiAocmVuZGVyVGFyZ2V0LCBhY3RpdmVDdWJlRmFjZSA9IDAsIGFjdGl2ZU1pcG1hcExldmVsID0gMCkge1xuXHRcdF9jdXJyZW50UmVuZGVyVGFyZ2V0ID0gcmVuZGVyVGFyZ2V0O1xuXHRcdF9jdXJyZW50QWN0aXZlQ3ViZUZhY2UgPSBhY3RpdmVDdWJlRmFjZTtcblx0XHRfY3VycmVudEFjdGl2ZU1pcG1hcExldmVsID0gYWN0aXZlTWlwbWFwTGV2ZWw7XG5cdFx0bGV0IHVzZURlZmF1bHRGcmFtZWJ1ZmZlciA9IHRydWU7XG5cdFx0bGV0IGZyYW1lYnVmZmVyID0gbnVsbDtcblx0XHRsZXQgaXNDdWJlID0gZmFsc2U7XG5cdFx0bGV0IGlzUmVuZGVyVGFyZ2V0M0QgPSBmYWxzZTtcblx0XHRpZiAocmVuZGVyVGFyZ2V0KSB7XG5cdFx0XHRjb25zdCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQocmVuZGVyVGFyZ2V0KTtcblx0XHRcdGlmIChyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fdXNlRGVmYXVsdEZyYW1lYnVmZmVyICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Ly8gV2UgbmVlZCB0byBtYWtlIHN1cmUgdG8gcmViaW5kIHRoZSBmcmFtZWJ1ZmZlci5cblx0XHRcdFx0c3RhdGUuYmluZEZyYW1lYnVmZmVyKF9nbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG5cdFx0XHRcdHVzZURlZmF1bHRGcmFtZWJ1ZmZlciA9IGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmIChyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRleHR1cmVzLnNldHVwUmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCk7XG5cdFx0XHR9IGVsc2UgaWYgKHJlbmRlclRhcmdldFByb3BlcnRpZXMuX19oYXNFeHRlcm5hbFRleHR1cmVzKSB7XG5cdFx0XHRcdC8vIENvbG9yIGFuZCBkZXB0aCB0ZXh0dXJlIG11c3QgYmUgcmVib3VuZCBpbiBvcmRlciBmb3IgdGhlIHN3YXBjaGFpbiB0byB1cGRhdGUuXG5cdFx0XHRcdHRleHR1cmVzLnJlYmluZFRleHR1cmVzKHJlbmRlclRhcmdldCwgcHJvcGVydGllcy5nZXQocmVuZGVyVGFyZ2V0LnRleHR1cmUpLl9fd2ViZ2xUZXh0dXJlLCBwcm9wZXJ0aWVzLmdldChyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlKS5fX3dlYmdsVGV4dHVyZSk7XG5cdFx0XHR9XG5cdFx0XHRjb25zdCB0ZXh0dXJlID0gcmVuZGVyVGFyZ2V0LnRleHR1cmU7XG5cdFx0XHRpZiAodGV4dHVyZS5pc0RhdGEzRFRleHR1cmUgfHwgdGV4dHVyZS5pc0RhdGFBcnJheVRleHR1cmUgfHwgdGV4dHVyZS5pc0NvbXByZXNzZWRBcnJheVRleHR1cmUpIHtcblx0XHRcdFx0aXNSZW5kZXJUYXJnZXQzRCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRjb25zdCBfX3dlYmdsRnJhbWVidWZmZXIgPSBwcm9wZXJ0aWVzLmdldChyZW5kZXJUYXJnZXQpLl9fd2ViZ2xGcmFtZWJ1ZmZlcjtcblx0XHRcdGlmIChyZW5kZXJUYXJnZXQuaXNXZWJHTEN1YmVSZW5kZXJUYXJnZXQpIHtcblx0XHRcdFx0ZnJhbWVidWZmZXIgPSBfX3dlYmdsRnJhbWVidWZmZXJbYWN0aXZlQ3ViZUZhY2VdO1xuXHRcdFx0XHRpc0N1YmUgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIGlmIChjYXBhYmlsaXRpZXMuaXNXZWJHTDIgJiYgcmVuZGVyVGFyZ2V0LnNhbXBsZXMgPiAwICYmIHRleHR1cmVzLnVzZU11bHRpc2FtcGxlZFJUVChyZW5kZXJUYXJnZXQpID09PSBmYWxzZSkge1xuXHRcdFx0XHRmcmFtZWJ1ZmZlciA9IHByb3BlcnRpZXMuZ2V0KHJlbmRlclRhcmdldCkuX193ZWJnbE11bHRpc2FtcGxlZEZyYW1lYnVmZmVyO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZnJhbWVidWZmZXIgPSBfX3dlYmdsRnJhbWVidWZmZXI7XG5cdFx0XHR9XG5cdFx0XHRfY3VycmVudFZpZXdwb3J0LmNvcHkocmVuZGVyVGFyZ2V0LnZpZXdwb3J0KTtcblx0XHRcdF9jdXJyZW50U2Npc3Nvci5jb3B5KHJlbmRlclRhcmdldC5zY2lzc29yKTtcblx0XHRcdF9jdXJyZW50U2Npc3NvclRlc3QgPSByZW5kZXJUYXJnZXQuc2Npc3NvclRlc3Q7XG5cdFx0fSBlbHNlIHtcblx0XHRcdF9jdXJyZW50Vmlld3BvcnQuY29weShfdmlld3BvcnQpLm11bHRpcGx5U2NhbGFyKF9waXhlbFJhdGlvKS5mbG9vcigpO1xuXHRcdFx0X2N1cnJlbnRTY2lzc29yLmNvcHkoX3NjaXNzb3IpLm11bHRpcGx5U2NhbGFyKF9waXhlbFJhdGlvKS5mbG9vcigpO1xuXHRcdFx0X2N1cnJlbnRTY2lzc29yVGVzdCA9IF9zY2lzc29yVGVzdDtcblx0XHR9XG5cdFx0Y29uc3QgZnJhbWVidWZmZXJCb3VuZCA9IHN0YXRlLmJpbmRGcmFtZWJ1ZmZlcihfZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyKTtcblx0XHRpZiAoZnJhbWVidWZmZXJCb3VuZCAmJiBjYXBhYmlsaXRpZXMuZHJhd0J1ZmZlcnMgJiYgdXNlRGVmYXVsdEZyYW1lYnVmZmVyKSB7XG5cdFx0XHRzdGF0ZS5kcmF3QnVmZmVycyhyZW5kZXJUYXJnZXQsIGZyYW1lYnVmZmVyKTtcblx0XHR9XG5cdFx0c3RhdGUudmlld3BvcnQoX2N1cnJlbnRWaWV3cG9ydCk7XG5cdFx0c3RhdGUuc2Npc3NvcihfY3VycmVudFNjaXNzb3IpO1xuXHRcdHN0YXRlLnNldFNjaXNzb3JUZXN0KF9jdXJyZW50U2Npc3NvclRlc3QpO1xuXHRcdGlmIChpc0N1YmUpIHtcblx0XHRcdGNvbnN0IHRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQocmVuZGVyVGFyZ2V0LnRleHR1cmUpO1xuXHRcdFx0X2dsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKF9nbC5GUkFNRUJVRkZFUiwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwLCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgYWN0aXZlQ3ViZUZhY2UsIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlLCBhY3RpdmVNaXBtYXBMZXZlbCk7XG5cdFx0fSBlbHNlIGlmIChpc1JlbmRlclRhcmdldDNEKSB7XG5cdFx0XHRjb25zdCB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KHJlbmRlclRhcmdldC50ZXh0dXJlKTtcblx0XHRcdGNvbnN0IGxheWVyID0gYWN0aXZlQ3ViZUZhY2UgfHwgMDtcblx0XHRcdF9nbC5mcmFtZWJ1ZmZlclRleHR1cmVMYXllcihfZ2wuRlJBTUVCVUZGRVIsIF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUsIGFjdGl2ZU1pcG1hcExldmVsIHx8IDAsIGxheWVyKTtcblx0XHR9XG5cdFx0X2N1cnJlbnRNYXRlcmlhbElkID0gLTE7IC8vIHJlc2V0IGN1cnJlbnQgbWF0ZXJpYWwgdG8gZW5zdXJlIGNvcnJlY3QgdW5pZm9ybSBiaW5kaW5nc1xuXHR9O1xuXG5cdHRoaXMucmVhZFJlbmRlclRhcmdldFBpeGVscyA9IGZ1bmN0aW9uIChyZW5kZXJUYXJnZXQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGJ1ZmZlciwgYWN0aXZlQ3ViZUZhY2VJbmRleCkge1xuXHRcdGlmICghKHJlbmRlclRhcmdldCAmJiByZW5kZXJUYXJnZXQuaXNXZWJHTFJlbmRlclRhcmdldCkpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsczogcmVuZGVyVGFyZ2V0IGlzIG5vdCBUSFJFRS5XZWJHTFJlbmRlclRhcmdldC4nKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0bGV0IGZyYW1lYnVmZmVyID0gcHJvcGVydGllcy5nZXQocmVuZGVyVGFyZ2V0KS5fX3dlYmdsRnJhbWVidWZmZXI7XG5cdFx0aWYgKHJlbmRlclRhcmdldC5pc1dlYkdMQ3ViZVJlbmRlclRhcmdldCAmJiBhY3RpdmVDdWJlRmFjZUluZGV4ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGZyYW1lYnVmZmVyID0gZnJhbWVidWZmZXJbYWN0aXZlQ3ViZUZhY2VJbmRleF07XG5cdFx0fVxuXHRcdGlmIChmcmFtZWJ1ZmZlcikge1xuXHRcdFx0c3RhdGUuYmluZEZyYW1lYnVmZmVyKF9nbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIpO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29uc3QgdGV4dHVyZSA9IHJlbmRlclRhcmdldC50ZXh0dXJlO1xuXHRcdFx0XHRjb25zdCB0ZXh0dXJlRm9ybWF0ID0gdGV4dHVyZS5mb3JtYXQ7XG5cdFx0XHRcdGNvbnN0IHRleHR1cmVUeXBlID0gdGV4dHVyZS50eXBlO1xuXHRcdFx0XHRpZiAodGV4dHVyZUZvcm1hdCAhPT0gUkdCQUZvcm1hdCAmJiB1dGlscy5jb252ZXJ0KHRleHR1cmVGb3JtYXQpICE9PSBfZ2wuZ2V0UGFyYW1ldGVyKF9nbC5JTVBMRU1FTlRBVElPTl9DT0xPUl9SRUFEX0ZPUk1BVCkpIHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlbmRlclRhcmdldCBpcyBub3QgaW4gUkdCQSBvciBpbXBsZW1lbnRhdGlvbiBkZWZpbmVkIGZvcm1hdC4nKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29uc3QgaGFsZkZsb2F0U3VwcG9ydGVkQnlFeHQgPSB0ZXh0dXJlVHlwZSA9PT0gSGFsZkZsb2F0VHlwZSAmJiAoZXh0ZW5zaW9ucy5oYXMoJ0VYVF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdCcpIHx8IGNhcGFiaWxpdGllcy5pc1dlYkdMMiAmJiBleHRlbnNpb25zLmhhcygnRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdCcpKTtcblx0XHRcdFx0aWYgKHRleHR1cmVUeXBlICE9PSBVbnNpZ25lZEJ5dGVUeXBlICYmIHV0aWxzLmNvbnZlcnQodGV4dHVyZVR5cGUpICE9PSBfZ2wuZ2V0UGFyYW1ldGVyKF9nbC5JTVBMRU1FTlRBVElPTl9DT0xPUl9SRUFEX1RZUEUpICYmXG5cdFx0XHRcdC8vIEVkZ2UgYW5kIENocm9tZSBNYWMgPCA1MiAoIzk1MTMpXG5cdFx0XHRcdCEodGV4dHVyZVR5cGUgPT09IEZsb2F0VHlwZSAmJiAoY2FwYWJpbGl0aWVzLmlzV2ViR0wyIHx8IGV4dGVuc2lvbnMuaGFzKCdPRVNfdGV4dHVyZV9mbG9hdCcpIHx8IGV4dGVuc2lvbnMuaGFzKCdXRUJHTF9jb2xvcl9idWZmZXJfZmxvYXQnKSkpICYmXG5cdFx0XHRcdC8vIENocm9tZSBNYWMgPj0gNTIgYW5kIEZpcmVmb3hcblx0XHRcdFx0IWhhbGZGbG9hdFN1cHBvcnRlZEJ5RXh0KSB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzOiByZW5kZXJUYXJnZXQgaXMgbm90IGluIFVuc2lnbmVkQnl0ZVR5cGUgb3IgaW1wbGVtZW50YXRpb24gZGVmaW5lZCB0eXBlLicpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHRoZSBmb2xsb3dpbmcgaWYgc3RhdGVtZW50IGVuc3VyZXMgdmFsaWQgcmVhZCByZXF1ZXN0cyAobm8gb3V0LW9mLWJvdW5kcyBwaXhlbHMsIHNlZSAjODYwNClcblxuXHRcdFx0XHRpZiAoeCA+PSAwICYmIHggPD0gcmVuZGVyVGFyZ2V0LndpZHRoIC0gd2lkdGggJiYgeSA+PSAwICYmIHkgPD0gcmVuZGVyVGFyZ2V0LmhlaWdodCAtIGhlaWdodCkge1xuXHRcdFx0XHRcdF9nbC5yZWFkUGl4ZWxzKHgsIHksIHdpZHRoLCBoZWlnaHQsIHV0aWxzLmNvbnZlcnQodGV4dHVyZUZvcm1hdCksIHV0aWxzLmNvbnZlcnQodGV4dHVyZVR5cGUpLCBidWZmZXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHQvLyByZXN0b3JlIGZyYW1lYnVmZmVyIG9mIGN1cnJlbnQgcmVuZGVyIHRhcmdldCBpZiBuZWNlc3NhcnlcblxuXHRcdFx0XHRjb25zdCBmcmFtZWJ1ZmZlciA9IF9jdXJyZW50UmVuZGVyVGFyZ2V0ICE9PSBudWxsID8gcHJvcGVydGllcy5nZXQoX2N1cnJlbnRSZW5kZXJUYXJnZXQpLl9fd2ViZ2xGcmFtZWJ1ZmZlciA6IG51bGw7XG5cdFx0XHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlcihfZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHRoaXMuY29weUZyYW1lYnVmZmVyVG9UZXh0dXJlID0gZnVuY3Rpb24gKHBvc2l0aW9uLCB0ZXh0dXJlLCBsZXZlbCA9IDApIHtcblx0XHRjb25zdCBsZXZlbFNjYWxlID0gTWF0aC5wb3coMiwgLWxldmVsKTtcblx0XHRjb25zdCB3aWR0aCA9IE1hdGguZmxvb3IodGV4dHVyZS5pbWFnZS53aWR0aCAqIGxldmVsU2NhbGUpO1xuXHRcdGNvbnN0IGhlaWdodCA9IE1hdGguZmxvb3IodGV4dHVyZS5pbWFnZS5oZWlnaHQgKiBsZXZlbFNjYWxlKTtcblx0XHR0ZXh0dXJlcy5zZXRUZXh0dXJlMkQodGV4dHVyZSwgMCk7XG5cdFx0X2dsLmNvcHlUZXhTdWJJbWFnZTJEKF9nbC5URVhUVVJFXzJELCBsZXZlbCwgMCwgMCwgcG9zaXRpb24ueCwgcG9zaXRpb24ueSwgd2lkdGgsIGhlaWdodCk7XG5cdFx0c3RhdGUudW5iaW5kVGV4dHVyZSgpO1xuXHR9O1xuXHR0aGlzLmNvcHlUZXh0dXJlVG9UZXh0dXJlID0gZnVuY3Rpb24gKHBvc2l0aW9uLCBzcmNUZXh0dXJlLCBkc3RUZXh0dXJlLCBsZXZlbCA9IDApIHtcblx0XHRjb25zdCB3aWR0aCA9IHNyY1RleHR1cmUuaW1hZ2Uud2lkdGg7XG5cdFx0Y29uc3QgaGVpZ2h0ID0gc3JjVGV4dHVyZS5pbWFnZS5oZWlnaHQ7XG5cdFx0Y29uc3QgZ2xGb3JtYXQgPSB1dGlscy5jb252ZXJ0KGRzdFRleHR1cmUuZm9ybWF0KTtcblx0XHRjb25zdCBnbFR5cGUgPSB1dGlscy5jb252ZXJ0KGRzdFRleHR1cmUudHlwZSk7XG5cdFx0dGV4dHVyZXMuc2V0VGV4dHVyZTJEKGRzdFRleHR1cmUsIDApO1xuXG5cdFx0Ly8gQXMgYW5vdGhlciB0ZXh0dXJlIHVwbG9hZCBtYXkgaGF2ZSBjaGFuZ2VkIHBpeGVsU3RvcmVpXG5cdFx0Ly8gcGFyYW1ldGVycywgbWFrZSBzdXJlIHRoZXkgYXJlIGNvcnJlY3QgZm9yIHRoZSBkc3RUZXh0dXJlXG5cdFx0X2dsLnBpeGVsU3RvcmVpKF9nbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBkc3RUZXh0dXJlLmZsaXBZKTtcblx0XHRfZ2wucGl4ZWxTdG9yZWkoX2dsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgZHN0VGV4dHVyZS5wcmVtdWx0aXBseUFscGhhKTtcblx0XHRfZ2wucGl4ZWxTdG9yZWkoX2dsLlVOUEFDS19BTElHTk1FTlQsIGRzdFRleHR1cmUudW5wYWNrQWxpZ25tZW50KTtcblx0XHRpZiAoc3JjVGV4dHVyZS5pc0RhdGFUZXh0dXJlKSB7XG5cdFx0XHRfZ2wudGV4U3ViSW1hZ2UyRChfZ2wuVEVYVFVSRV8yRCwgbGV2ZWwsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHdpZHRoLCBoZWlnaHQsIGdsRm9ybWF0LCBnbFR5cGUsIHNyY1RleHR1cmUuaW1hZ2UuZGF0YSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChzcmNUZXh0dXJlLmlzQ29tcHJlc3NlZFRleHR1cmUpIHtcblx0XHRcdFx0X2dsLmNvbXByZXNzZWRUZXhTdWJJbWFnZTJEKF9nbC5URVhUVVJFXzJELCBsZXZlbCwgcG9zaXRpb24ueCwgcG9zaXRpb24ueSwgc3JjVGV4dHVyZS5taXBtYXBzWzBdLndpZHRoLCBzcmNUZXh0dXJlLm1pcG1hcHNbMF0uaGVpZ2h0LCBnbEZvcm1hdCwgc3JjVGV4dHVyZS5taXBtYXBzWzBdLmRhdGEpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0X2dsLnRleFN1YkltYWdlMkQoX2dsLlRFWFRVUkVfMkQsIGxldmVsLCBwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBnbEZvcm1hdCwgZ2xUeXBlLCBzcmNUZXh0dXJlLmltYWdlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBHZW5lcmF0ZSBtaXBtYXBzIG9ubHkgd2hlbiBjb3B5aW5nIGxldmVsIDBcblx0XHRpZiAobGV2ZWwgPT09IDAgJiYgZHN0VGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMpIF9nbC5nZW5lcmF0ZU1pcG1hcChfZ2wuVEVYVFVSRV8yRCk7XG5cdFx0c3RhdGUudW5iaW5kVGV4dHVyZSgpO1xuXHR9O1xuXHR0aGlzLmNvcHlUZXh0dXJlVG9UZXh0dXJlM0QgPSBmdW5jdGlvbiAoc291cmNlQm94LCBwb3NpdGlvbiwgc3JjVGV4dHVyZSwgZHN0VGV4dHVyZSwgbGV2ZWwgPSAwKSB7XG5cdFx0aWYgKF90aGlzLmlzV2ViR0wxUmVuZGVyZXIpIHtcblx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlci5jb3B5VGV4dHVyZVRvVGV4dHVyZTNEOiBjYW4gb25seSBiZSB1c2VkIHdpdGggV2ViR0wyLicpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRjb25zdCB3aWR0aCA9IHNvdXJjZUJveC5tYXgueCAtIHNvdXJjZUJveC5taW4ueCArIDE7XG5cdFx0Y29uc3QgaGVpZ2h0ID0gc291cmNlQm94Lm1heC55IC0gc291cmNlQm94Lm1pbi55ICsgMTtcblx0XHRjb25zdCBkZXB0aCA9IHNvdXJjZUJveC5tYXgueiAtIHNvdXJjZUJveC5taW4ueiArIDE7XG5cdFx0Y29uc3QgZ2xGb3JtYXQgPSB1dGlscy5jb252ZXJ0KGRzdFRleHR1cmUuZm9ybWF0KTtcblx0XHRjb25zdCBnbFR5cGUgPSB1dGlscy5jb252ZXJ0KGRzdFRleHR1cmUudHlwZSk7XG5cdFx0bGV0IGdsVGFyZ2V0O1xuXHRcdGlmIChkc3RUZXh0dXJlLmlzRGF0YTNEVGV4dHVyZSkge1xuXHRcdFx0dGV4dHVyZXMuc2V0VGV4dHVyZTNEKGRzdFRleHR1cmUsIDApO1xuXHRcdFx0Z2xUYXJnZXQgPSBfZ2wuVEVYVFVSRV8zRDtcblx0XHR9IGVsc2UgaWYgKGRzdFRleHR1cmUuaXNEYXRhQXJyYXlUZXh0dXJlKSB7XG5cdFx0XHR0ZXh0dXJlcy5zZXRUZXh0dXJlMkRBcnJheShkc3RUZXh0dXJlLCAwKTtcblx0XHRcdGdsVGFyZ2V0ID0gX2dsLlRFWFRVUkVfMkRfQVJSQVk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlci5jb3B5VGV4dHVyZVRvVGV4dHVyZTNEOiBvbmx5IHN1cHBvcnRzIFRIUkVFLkRhdGFUZXh0dXJlM0QgYW5kIFRIUkVFLkRhdGFUZXh0dXJlMkRBcnJheS4nKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0X2dsLnBpeGVsU3RvcmVpKF9nbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBkc3RUZXh0dXJlLmZsaXBZKTtcblx0XHRfZ2wucGl4ZWxTdG9yZWkoX2dsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgZHN0VGV4dHVyZS5wcmVtdWx0aXBseUFscGhhKTtcblx0XHRfZ2wucGl4ZWxTdG9yZWkoX2dsLlVOUEFDS19BTElHTk1FTlQsIGRzdFRleHR1cmUudW5wYWNrQWxpZ25tZW50KTtcblx0XHRjb25zdCB1bnBhY2tSb3dMZW4gPSBfZ2wuZ2V0UGFyYW1ldGVyKF9nbC5VTlBBQ0tfUk9XX0xFTkdUSCk7XG5cdFx0Y29uc3QgdW5wYWNrSW1hZ2VIZWlnaHQgPSBfZ2wuZ2V0UGFyYW1ldGVyKF9nbC5VTlBBQ0tfSU1BR0VfSEVJR0hUKTtcblx0XHRjb25zdCB1bnBhY2tTa2lwUGl4ZWxzID0gX2dsLmdldFBhcmFtZXRlcihfZ2wuVU5QQUNLX1NLSVBfUElYRUxTKTtcblx0XHRjb25zdCB1bnBhY2tTa2lwUm93cyA9IF9nbC5nZXRQYXJhbWV0ZXIoX2dsLlVOUEFDS19TS0lQX1JPV1MpO1xuXHRcdGNvbnN0IHVucGFja1NraXBJbWFnZXMgPSBfZ2wuZ2V0UGFyYW1ldGVyKF9nbC5VTlBBQ0tfU0tJUF9JTUFHRVMpO1xuXHRcdGNvbnN0IGltYWdlID0gc3JjVGV4dHVyZS5pc0NvbXByZXNzZWRUZXh0dXJlID8gc3JjVGV4dHVyZS5taXBtYXBzWzBdIDogc3JjVGV4dHVyZS5pbWFnZTtcblx0XHRfZ2wucGl4ZWxTdG9yZWkoX2dsLlVOUEFDS19ST1dfTEVOR1RILCBpbWFnZS53aWR0aCk7XG5cdFx0X2dsLnBpeGVsU3RvcmVpKF9nbC5VTlBBQ0tfSU1BR0VfSEVJR0hULCBpbWFnZS5oZWlnaHQpO1xuXHRcdF9nbC5waXhlbFN0b3JlaShfZ2wuVU5QQUNLX1NLSVBfUElYRUxTLCBzb3VyY2VCb3gubWluLngpO1xuXHRcdF9nbC5waXhlbFN0b3JlaShfZ2wuVU5QQUNLX1NLSVBfUk9XUywgc291cmNlQm94Lm1pbi55KTtcblx0XHRfZ2wucGl4ZWxTdG9yZWkoX2dsLlVOUEFDS19TS0lQX0lNQUdFUywgc291cmNlQm94Lm1pbi56KTtcblx0XHRpZiAoc3JjVGV4dHVyZS5pc0RhdGFUZXh0dXJlIHx8IHNyY1RleHR1cmUuaXNEYXRhM0RUZXh0dXJlKSB7XG5cdFx0XHRfZ2wudGV4U3ViSW1hZ2UzRChnbFRhcmdldCwgbGV2ZWwsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHBvc2l0aW9uLnosIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCBnbEZvcm1hdCwgZ2xUeXBlLCBpbWFnZS5kYXRhKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKHNyY1RleHR1cmUuaXNDb21wcmVzc2VkQXJyYXlUZXh0dXJlKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlci5jb3B5VGV4dHVyZVRvVGV4dHVyZTNEOiB1bnRlc3RlZCBzdXBwb3J0IGZvciBjb21wcmVzc2VkIHNyY1RleHR1cmUuJyk7XG5cdFx0XHRcdF9nbC5jb21wcmVzc2VkVGV4U3ViSW1hZ2UzRChnbFRhcmdldCwgbGV2ZWwsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHBvc2l0aW9uLnosIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCBnbEZvcm1hdCwgaW1hZ2UuZGF0YSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRfZ2wudGV4U3ViSW1hZ2UzRChnbFRhcmdldCwgbGV2ZWwsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHBvc2l0aW9uLnosIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCBnbEZvcm1hdCwgZ2xUeXBlLCBpbWFnZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdF9nbC5waXhlbFN0b3JlaShfZ2wuVU5QQUNLX1JPV19MRU5HVEgsIHVucGFja1Jvd0xlbik7XG5cdFx0X2dsLnBpeGVsU3RvcmVpKF9nbC5VTlBBQ0tfSU1BR0VfSEVJR0hULCB1bnBhY2tJbWFnZUhlaWdodCk7XG5cdFx0X2dsLnBpeGVsU3RvcmVpKF9nbC5VTlBBQ0tfU0tJUF9QSVhFTFMsIHVucGFja1NraXBQaXhlbHMpO1xuXHRcdF9nbC5waXhlbFN0b3JlaShfZ2wuVU5QQUNLX1NLSVBfUk9XUywgdW5wYWNrU2tpcFJvd3MpO1xuXHRcdF9nbC5waXhlbFN0b3JlaShfZ2wuVU5QQUNLX1NLSVBfSU1BR0VTLCB1bnBhY2tTa2lwSW1hZ2VzKTtcblxuXHRcdC8vIEdlbmVyYXRlIG1pcG1hcHMgb25seSB3aGVuIGNvcHlpbmcgbGV2ZWwgMFxuXHRcdGlmIChsZXZlbCA9PT0gMCAmJiBkc3RUZXh0dXJlLmdlbmVyYXRlTWlwbWFwcykgX2dsLmdlbmVyYXRlTWlwbWFwKGdsVGFyZ2V0KTtcblx0XHRzdGF0ZS51bmJpbmRUZXh0dXJlKCk7XG5cdH07XG5cdHRoaXMuaW5pdFRleHR1cmUgPSBmdW5jdGlvbiAodGV4dHVyZSkge1xuXHRcdGlmICh0ZXh0dXJlLmlzQ3ViZVRleHR1cmUpIHtcblx0XHRcdHRleHR1cmVzLnNldFRleHR1cmVDdWJlKHRleHR1cmUsIDApO1xuXHRcdH0gZWxzZSBpZiAodGV4dHVyZS5pc0RhdGEzRFRleHR1cmUpIHtcblx0XHRcdHRleHR1cmVzLnNldFRleHR1cmUzRCh0ZXh0dXJlLCAwKTtcblx0XHR9IGVsc2UgaWYgKHRleHR1cmUuaXNEYXRhQXJyYXlUZXh0dXJlIHx8IHRleHR1cmUuaXNDb21wcmVzc2VkQXJyYXlUZXh0dXJlKSB7XG5cdFx0XHR0ZXh0dXJlcy5zZXRUZXh0dXJlMkRBcnJheSh0ZXh0dXJlLCAwKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGV4dHVyZXMuc2V0VGV4dHVyZTJEKHRleHR1cmUsIDApO1xuXHRcdH1cblx0XHRzdGF0ZS51bmJpbmRUZXh0dXJlKCk7XG5cdH07XG5cdHRoaXMucmVzZXRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRfY3VycmVudEFjdGl2ZUN1YmVGYWNlID0gMDtcblx0XHRfY3VycmVudEFjdGl2ZU1pcG1hcExldmVsID0gMDtcblx0XHRfY3VycmVudFJlbmRlclRhcmdldCA9IG51bGw7XG5cdFx0c3RhdGUucmVzZXQoKTtcblx0XHRiaW5kaW5nU3RhdGVzLnJlc2V0KCk7XG5cdH07XG5cdGlmICh0eXBlb2YgX19USFJFRV9ERVZUT09MU19fICE9PSAndW5kZWZpbmVkJykge1xuXHRcdF9fVEhSRUVfREVWVE9PTFNfXy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnb2JzZXJ2ZScsIHtcblx0XHRcdGRldGFpbDogdGhpc1xuXHRcdH0pKTtcblx0fVxufVxuXG5jbGFzcyBXZWJHTDFSZW5kZXJlciBleHRlbmRzIFdlYkdMUmVuZGVyZXIge31cbldlYkdMMVJlbmRlcmVyLnByb3RvdHlwZS5pc1dlYkdMMVJlbmRlcmVyID0gdHJ1ZTtcblxuY2xhc3MgRm9nRXhwMiB7XG5cdGNvbnN0cnVjdG9yKGNvbG9yLCBkZW5zaXR5ID0gMC4wMDAyNSkge1xuXHRcdHRoaXMuaXNGb2dFeHAyID0gdHJ1ZTtcblx0XHR0aGlzLm5hbWUgPSAnJztcblx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKGNvbG9yKTtcblx0XHR0aGlzLmRlbnNpdHkgPSBkZW5zaXR5O1xuXHR9XG5cdGNsb25lKCkge1xuXHRcdHJldHVybiBuZXcgRm9nRXhwMih0aGlzLmNvbG9yLCB0aGlzLmRlbnNpdHkpO1xuXHR9XG5cdHRvSlNPTigpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dHlwZTogJ0ZvZ0V4cDInLFxuXHRcdFx0Y29sb3I6IHRoaXMuY29sb3IuZ2V0SGV4KCksXG5cdFx0XHRkZW5zaXR5OiB0aGlzLmRlbnNpdHlcblx0XHR9O1xuXHR9XG59XG5cbmNsYXNzIEZvZyB7XG5cdGNvbnN0cnVjdG9yKGNvbG9yLCBuZWFyID0gMSwgZmFyID0gMTAwMCkge1xuXHRcdHRoaXMuaXNGb2cgPSB0cnVlO1xuXHRcdHRoaXMubmFtZSA9ICcnO1xuXHRcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoY29sb3IpO1xuXHRcdHRoaXMubmVhciA9IG5lYXI7XG5cdFx0dGhpcy5mYXIgPSBmYXI7XG5cdH1cblx0Y2xvbmUoKSB7XG5cdFx0cmV0dXJuIG5ldyBGb2codGhpcy5jb2xvciwgdGhpcy5uZWFyLCB0aGlzLmZhcik7XG5cdH1cblx0dG9KU09OKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR0eXBlOiAnRm9nJyxcblx0XHRcdGNvbG9yOiB0aGlzLmNvbG9yLmdldEhleCgpLFxuXHRcdFx0bmVhcjogdGhpcy5uZWFyLFxuXHRcdFx0ZmFyOiB0aGlzLmZhclxuXHRcdH07XG5cdH1cbn1cblxuY2xhc3MgU2NlbmUgZXh0ZW5kcyBPYmplY3QzRCB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5pc1NjZW5lID0gdHJ1ZTtcblx0XHR0aGlzLnR5cGUgPSAnU2NlbmUnO1xuXHRcdHRoaXMuYmFja2dyb3VuZCA9IG51bGw7XG5cdFx0dGhpcy5lbnZpcm9ubWVudCA9IG51bGw7XG5cdFx0dGhpcy5mb2cgPSBudWxsO1xuXHRcdHRoaXMuYmFja2dyb3VuZEJsdXJyaW5lc3MgPSAwO1xuXHRcdHRoaXMub3ZlcnJpZGVNYXRlcmlhbCA9IG51bGw7XG5cdFx0aWYgKHR5cGVvZiBfX1RIUkVFX0RFVlRPT0xTX18gIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRfX1RIUkVFX0RFVlRPT0xTX18uZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ29ic2VydmUnLCB7XG5cdFx0XHRcdGRldGFpbDogdGhpc1xuXHRcdFx0fSkpO1xuXHRcdH1cblx0fVxuXHRjb3B5KHNvdXJjZSwgcmVjdXJzaXZlKSB7XG5cdFx0c3VwZXIuY29weShzb3VyY2UsIHJlY3Vyc2l2ZSk7XG5cdFx0aWYgKHNvdXJjZS5iYWNrZ3JvdW5kICE9PSBudWxsKSB0aGlzLmJhY2tncm91bmQgPSBzb3VyY2UuYmFja2dyb3VuZC5jbG9uZSgpO1xuXHRcdGlmIChzb3VyY2UuZW52aXJvbm1lbnQgIT09IG51bGwpIHRoaXMuZW52aXJvbm1lbnQgPSBzb3VyY2UuZW52aXJvbm1lbnQuY2xvbmUoKTtcblx0XHRpZiAoc291cmNlLmZvZyAhPT0gbnVsbCkgdGhpcy5mb2cgPSBzb3VyY2UuZm9nLmNsb25lKCk7XG5cdFx0dGhpcy5iYWNrZ3JvdW5kQmx1cnJpbmVzcyA9IHNvdXJjZS5iYWNrZ3JvdW5kQmx1cnJpbmVzcztcblx0XHRpZiAoc291cmNlLm92ZXJyaWRlTWF0ZXJpYWwgIT09IG51bGwpIHRoaXMub3ZlcnJpZGVNYXRlcmlhbCA9IHNvdXJjZS5vdmVycmlkZU1hdGVyaWFsLmNsb25lKCk7XG5cdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gc291cmNlLm1hdHJpeEF1dG9VcGRhdGU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0dG9KU09OKG1ldGEpIHtcblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKG1ldGEpO1xuXHRcdGlmICh0aGlzLmZvZyAhPT0gbnVsbCkgZGF0YS5vYmplY3QuZm9nID0gdGhpcy5mb2cudG9KU09OKCk7XG5cdFx0aWYgKHRoaXMuYmFja2dyb3VuZEJsdXJyaW5lc3MgPiAwKSBkYXRhLmJhY2tncm91bmRCbHVycmluZXNzID0gdGhpcy5iYWNrZ3JvdW5kQmx1cnJpbmVzcztcblx0XHRyZXR1cm4gZGF0YTtcblx0fVxuXG5cdC8vIEBkZXByZWNhdGVkXG5cblx0Z2V0IGF1dG9VcGRhdGUoKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5TY2VuZTogYXV0b1VwZGF0ZSB3YXMgcmVuYW1lZCB0byBtYXRyaXhXb3JsZEF1dG9VcGRhdGUgaW4gcjE0NC4nKTtcblx0XHRyZXR1cm4gdGhpcy5tYXRyaXhXb3JsZEF1dG9VcGRhdGU7XG5cdH1cblx0c2V0IGF1dG9VcGRhdGUodmFsdWUpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlNjZW5lOiBhdXRvVXBkYXRlIHdhcyByZW5hbWVkIHRvIG1hdHJpeFdvcmxkQXV0b1VwZGF0ZSBpbiByMTQ0LicpO1xuXHRcdHRoaXMubWF0cml4V29ybGRBdXRvVXBkYXRlID0gdmFsdWU7XG5cdH1cbn1cblxuY2xhc3MgSW50ZXJsZWF2ZWRCdWZmZXIge1xuXHRjb25zdHJ1Y3RvcihhcnJheSwgc3RyaWRlKSB7XG5cdFx0dGhpcy5pc0ludGVybGVhdmVkQnVmZmVyID0gdHJ1ZTtcblx0XHR0aGlzLmFycmF5ID0gYXJyYXk7XG5cdFx0dGhpcy5zdHJpZGUgPSBzdHJpZGU7XG5cdFx0dGhpcy5jb3VudCA9IGFycmF5ICE9PSB1bmRlZmluZWQgPyBhcnJheS5sZW5ndGggLyBzdHJpZGUgOiAwO1xuXHRcdHRoaXMudXNhZ2UgPSBTdGF0aWNEcmF3VXNhZ2U7XG5cdFx0dGhpcy51cGRhdGVSYW5nZSA9IHtcblx0XHRcdG9mZnNldDogMCxcblx0XHRcdGNvdW50OiAtMVxuXHRcdH07XG5cdFx0dGhpcy52ZXJzaW9uID0gMDtcblx0XHR0aGlzLnV1aWQgPSBnZW5lcmF0ZVVVSUQoKTtcblx0fVxuXHRvblVwbG9hZENhbGxiYWNrKCkge31cblx0c2V0IG5lZWRzVXBkYXRlKHZhbHVlKSB7XG5cdFx0aWYgKHZhbHVlID09PSB0cnVlKSB0aGlzLnZlcnNpb24rKztcblx0fVxuXHRzZXRVc2FnZSh2YWx1ZSkge1xuXHRcdHRoaXMudXNhZ2UgPSB2YWx1ZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRjb3B5KHNvdXJjZSkge1xuXHRcdHRoaXMuYXJyYXkgPSBuZXcgc291cmNlLmFycmF5LmNvbnN0cnVjdG9yKHNvdXJjZS5hcnJheSk7XG5cdFx0dGhpcy5jb3VudCA9IHNvdXJjZS5jb3VudDtcblx0XHR0aGlzLnN0cmlkZSA9IHNvdXJjZS5zdHJpZGU7XG5cdFx0dGhpcy51c2FnZSA9IHNvdXJjZS51c2FnZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRjb3B5QXQoaW5kZXgxLCBhdHRyaWJ1dGUsIGluZGV4Mikge1xuXHRcdGluZGV4MSAqPSB0aGlzLnN0cmlkZTtcblx0XHRpbmRleDIgKj0gYXR0cmlidXRlLnN0cmlkZTtcblx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMuc3RyaWRlOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR0aGlzLmFycmF5W2luZGV4MSArIGldID0gYXR0cmlidXRlLmFycmF5W2luZGV4MiArIGldO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRzZXQodmFsdWUsIG9mZnNldCA9IDApIHtcblx0XHR0aGlzLmFycmF5LnNldCh2YWx1ZSwgb2Zmc2V0KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRjbG9uZShkYXRhKSB7XG5cdFx0aWYgKGRhdGEuYXJyYXlCdWZmZXJzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGRhdGEuYXJyYXlCdWZmZXJzID0ge307XG5cdFx0fVxuXHRcdGlmICh0aGlzLmFycmF5LmJ1ZmZlci5fdXVpZCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLmFycmF5LmJ1ZmZlci5fdXVpZCA9IGdlbmVyYXRlVVVJRCgpO1xuXHRcdH1cblx0XHRpZiAoZGF0YS5hcnJheUJ1ZmZlcnNbdGhpcy5hcnJheS5idWZmZXIuX3V1aWRdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGRhdGEuYXJyYXlCdWZmZXJzW3RoaXMuYXJyYXkuYnVmZmVyLl91dWlkXSA9IHRoaXMuYXJyYXkuc2xpY2UoMCkuYnVmZmVyO1xuXHRcdH1cblx0XHRjb25zdCBhcnJheSA9IG5ldyB0aGlzLmFycmF5LmNvbnN0cnVjdG9yKGRhdGEuYXJyYXlCdWZmZXJzW3RoaXMuYXJyYXkuYnVmZmVyLl91dWlkXSk7XG5cdFx0Y29uc3QgaWIgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihhcnJheSwgdGhpcy5zdHJpZGUpO1xuXHRcdGliLnNldFVzYWdlKHRoaXMudXNhZ2UpO1xuXHRcdHJldHVybiBpYjtcblx0fVxuXHRvblVwbG9hZChjYWxsYmFjaykge1xuXHRcdHRoaXMub25VcGxvYWRDYWxsYmFjayA9IGNhbGxiYWNrO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHRvSlNPTihkYXRhKSB7XG5cdFx0aWYgKGRhdGEuYXJyYXlCdWZmZXJzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGRhdGEuYXJyYXlCdWZmZXJzID0ge307XG5cdFx0fVxuXG5cdFx0Ly8gZ2VuZXJhdGUgVVVJRCBmb3IgYXJyYXkgYnVmZmVyIGlmIG5lY2Vzc2FyeVxuXG5cdFx0aWYgKHRoaXMuYXJyYXkuYnVmZmVyLl91dWlkID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuYXJyYXkuYnVmZmVyLl91dWlkID0gZ2VuZXJhdGVVVUlEKCk7XG5cdFx0fVxuXHRcdGlmIChkYXRhLmFycmF5QnVmZmVyc1t0aGlzLmFycmF5LmJ1ZmZlci5fdXVpZF0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0ZGF0YS5hcnJheUJ1ZmZlcnNbdGhpcy5hcnJheS5idWZmZXIuX3V1aWRdID0gQXJyYXkuZnJvbShuZXcgVWludDMyQXJyYXkodGhpcy5hcnJheS5idWZmZXIpKTtcblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHV1aWQ6IHRoaXMudXVpZCxcblx0XHRcdGJ1ZmZlcjogdGhpcy5hcnJheS5idWZmZXIuX3V1aWQsXG5cdFx0XHR0eXBlOiB0aGlzLmFycmF5LmNvbnN0cnVjdG9yLm5hbWUsXG5cdFx0XHRzdHJpZGU6IHRoaXMuc3RyaWRlXG5cdFx0fTtcblx0fVxufVxuXG5jb25zdCBfdmVjdG9yJDYgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcbmNsYXNzIEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlIHtcblx0Y29uc3RydWN0b3IoaW50ZXJsZWF2ZWRCdWZmZXIsIGl0ZW1TaXplLCBvZmZzZXQsIG5vcm1hbGl6ZWQgPSBmYWxzZSkge1xuXHRcdHRoaXMuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSA9IHRydWU7XG5cdFx0dGhpcy5uYW1lID0gJyc7XG5cdFx0dGhpcy5kYXRhID0gaW50ZXJsZWF2ZWRCdWZmZXI7XG5cdFx0dGhpcy5pdGVtU2l6ZSA9IGl0ZW1TaXplO1xuXHRcdHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuXHRcdHRoaXMubm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQgPT09IHRydWU7XG5cdH1cblx0Z2V0IGNvdW50KCkge1xuXHRcdHJldHVybiB0aGlzLmRhdGEuY291bnQ7XG5cdH1cblx0Z2V0IGFycmF5KCkge1xuXHRcdHJldHVybiB0aGlzLmRhdGEuYXJyYXk7XG5cdH1cblx0c2V0IG5lZWRzVXBkYXRlKHZhbHVlKSB7XG5cdFx0dGhpcy5kYXRhLm5lZWRzVXBkYXRlID0gdmFsdWU7XG5cdH1cblx0YXBwbHlNYXRyaXg0KG0pIHtcblx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMuZGF0YS5jb3VudDsgaSA8IGw7IGkrKykge1xuXHRcdFx0X3ZlY3RvciQ2LmZyb21CdWZmZXJBdHRyaWJ1dGUodGhpcywgaSk7XG5cdFx0XHRfdmVjdG9yJDYuYXBwbHlNYXRyaXg0KG0pO1xuXHRcdFx0dGhpcy5zZXRYWVooaSwgX3ZlY3RvciQ2LngsIF92ZWN0b3IkNi55LCBfdmVjdG9yJDYueik7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGFwcGx5Tm9ybWFsTWF0cml4KG0pIHtcblx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMuY291bnQ7IGkgPCBsOyBpKyspIHtcblx0XHRcdF92ZWN0b3IkNi5mcm9tQnVmZmVyQXR0cmlidXRlKHRoaXMsIGkpO1xuXHRcdFx0X3ZlY3RvciQ2LmFwcGx5Tm9ybWFsTWF0cml4KG0pO1xuXHRcdFx0dGhpcy5zZXRYWVooaSwgX3ZlY3RvciQ2LngsIF92ZWN0b3IkNi55LCBfdmVjdG9yJDYueik7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHRyYW5zZm9ybURpcmVjdGlvbihtKSB7XG5cdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLmNvdW50OyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRfdmVjdG9yJDYuZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0aGlzLCBpKTtcblx0XHRcdF92ZWN0b3IkNi50cmFuc2Zvcm1EaXJlY3Rpb24obSk7XG5cdFx0XHR0aGlzLnNldFhZWihpLCBfdmVjdG9yJDYueCwgX3ZlY3RvciQ2LnksIF92ZWN0b3IkNi56KTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0c2V0WChpbmRleCwgeCkge1xuXHRcdGlmICh0aGlzLm5vcm1hbGl6ZWQpIHggPSBub3JtYWxpemUoeCwgdGhpcy5hcnJheSk7XG5cdFx0dGhpcy5kYXRhLmFycmF5W2luZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0XSA9IHg7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0c2V0WShpbmRleCwgeSkge1xuXHRcdGlmICh0aGlzLm5vcm1hbGl6ZWQpIHkgPSBub3JtYWxpemUoeSwgdGhpcy5hcnJheSk7XG5cdFx0dGhpcy5kYXRhLmFycmF5W2luZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMV0gPSB5O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHNldFooaW5kZXgsIHopIHtcblx0XHRpZiAodGhpcy5ub3JtYWxpemVkKSB6ID0gbm9ybWFsaXplKHosIHRoaXMuYXJyYXkpO1xuXHRcdHRoaXMuZGF0YS5hcnJheVtpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDJdID0gejtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRzZXRXKGluZGV4LCB3KSB7XG5cdFx0aWYgKHRoaXMubm9ybWFsaXplZCkgdyA9IG5vcm1hbGl6ZSh3LCB0aGlzLmFycmF5KTtcblx0XHR0aGlzLmRhdGEuYXJyYXlbaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAzXSA9IHc7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0Z2V0WChpbmRleCkge1xuXHRcdGxldCB4ID0gdGhpcy5kYXRhLmFycmF5W2luZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0XTtcblx0XHRpZiAodGhpcy5ub3JtYWxpemVkKSB4ID0gZGVub3JtYWxpemUoeCwgdGhpcy5hcnJheSk7XG5cdFx0cmV0dXJuIHg7XG5cdH1cblx0Z2V0WShpbmRleCkge1xuXHRcdGxldCB5ID0gdGhpcy5kYXRhLmFycmF5W2luZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMV07XG5cdFx0aWYgKHRoaXMubm9ybWFsaXplZCkgeSA9IGRlbm9ybWFsaXplKHksIHRoaXMuYXJyYXkpO1xuXHRcdHJldHVybiB5O1xuXHR9XG5cdGdldFooaW5kZXgpIHtcblx0XHRsZXQgeiA9IHRoaXMuZGF0YS5hcnJheVtpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDJdO1xuXHRcdGlmICh0aGlzLm5vcm1hbGl6ZWQpIHogPSBkZW5vcm1hbGl6ZSh6LCB0aGlzLmFycmF5KTtcblx0XHRyZXR1cm4gejtcblx0fVxuXHRnZXRXKGluZGV4KSB7XG5cdFx0bGV0IHcgPSB0aGlzLmRhdGEuYXJyYXlbaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAzXTtcblx0XHRpZiAodGhpcy5ub3JtYWxpemVkKSB3ID0gZGVub3JtYWxpemUodywgdGhpcy5hcnJheSk7XG5cdFx0cmV0dXJuIHc7XG5cdH1cblx0c2V0WFkoaW5kZXgsIHgsIHkpIHtcblx0XHRpbmRleCA9IGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0O1xuXHRcdGlmICh0aGlzLm5vcm1hbGl6ZWQpIHtcblx0XHRcdHggPSBub3JtYWxpemUoeCwgdGhpcy5hcnJheSk7XG5cdFx0XHR5ID0gbm9ybWFsaXplKHksIHRoaXMuYXJyYXkpO1xuXHRcdH1cblx0XHR0aGlzLmRhdGEuYXJyYXlbaW5kZXggKyAwXSA9IHg7XG5cdFx0dGhpcy5kYXRhLmFycmF5W2luZGV4ICsgMV0gPSB5O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHNldFhZWihpbmRleCwgeCwgeSwgeikge1xuXHRcdGluZGV4ID0gaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XG5cdFx0aWYgKHRoaXMubm9ybWFsaXplZCkge1xuXHRcdFx0eCA9IG5vcm1hbGl6ZSh4LCB0aGlzLmFycmF5KTtcblx0XHRcdHkgPSBub3JtYWxpemUoeSwgdGhpcy5hcnJheSk7XG5cdFx0XHR6ID0gbm9ybWFsaXplKHosIHRoaXMuYXJyYXkpO1xuXHRcdH1cblx0XHR0aGlzLmRhdGEuYXJyYXlbaW5kZXggKyAwXSA9IHg7XG5cdFx0dGhpcy5kYXRhLmFycmF5W2luZGV4ICsgMV0gPSB5O1xuXHRcdHRoaXMuZGF0YS5hcnJheVtpbmRleCArIDJdID0gejtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRzZXRYWVpXKGluZGV4LCB4LCB5LCB6LCB3KSB7XG5cdFx0aW5kZXggPSBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldDtcblx0XHRpZiAodGhpcy5ub3JtYWxpemVkKSB7XG5cdFx0XHR4ID0gbm9ybWFsaXplKHgsIHRoaXMuYXJyYXkpO1xuXHRcdFx0eSA9IG5vcm1hbGl6ZSh5LCB0aGlzLmFycmF5KTtcblx0XHRcdHogPSBub3JtYWxpemUoeiwgdGhpcy5hcnJheSk7XG5cdFx0XHR3ID0gbm9ybWFsaXplKHcsIHRoaXMuYXJyYXkpO1xuXHRcdH1cblx0XHR0aGlzLmRhdGEuYXJyYXlbaW5kZXggKyAwXSA9IHg7XG5cdFx0dGhpcy5kYXRhLmFycmF5W2luZGV4ICsgMV0gPSB5O1xuXHRcdHRoaXMuZGF0YS5hcnJheVtpbmRleCArIDJdID0gejtcblx0XHR0aGlzLmRhdGEuYXJyYXlbaW5kZXggKyAzXSA9IHc7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0Y2xvbmUoZGF0YSkge1xuXHRcdGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGNvbnNvbGUubG9nKCdUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZS5jbG9uZSgpOiBDbG9uaW5nIGFuIGludGVybGVhdmVkIGJ1ZmZlciBhdHRyaWJ1dGUgd2lsbCBkZWludGVybGVhdmUgYnVmZmVyIGRhdGEuJyk7XG5cdFx0XHRjb25zdCBhcnJheSA9IFtdO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvdW50OyBpKyspIHtcblx0XHRcdFx0Y29uc3QgaW5kZXggPSBpICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0O1xuXHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuaXRlbVNpemU7IGorKykge1xuXHRcdFx0XHRcdGFycmF5LnB1c2godGhpcy5kYXRhLmFycmF5W2luZGV4ICsgal0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbmV3IEJ1ZmZlckF0dHJpYnV0ZShuZXcgdGhpcy5hcnJheS5jb25zdHJ1Y3RvcihhcnJheSksIHRoaXMuaXRlbVNpemUsIHRoaXMubm9ybWFsaXplZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChkYXRhLmludGVybGVhdmVkQnVmZmVycyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGRhdGEuaW50ZXJsZWF2ZWRCdWZmZXJzID0ge307XG5cdFx0XHR9XG5cdFx0XHRpZiAoZGF0YS5pbnRlcmxlYXZlZEJ1ZmZlcnNbdGhpcy5kYXRhLnV1aWRdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0ZGF0YS5pbnRlcmxlYXZlZEJ1ZmZlcnNbdGhpcy5kYXRhLnV1aWRdID0gdGhpcy5kYXRhLmNsb25lKGRhdGEpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG5ldyBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZShkYXRhLmludGVybGVhdmVkQnVmZmVyc1t0aGlzLmRhdGEudXVpZF0sIHRoaXMuaXRlbVNpemUsIHRoaXMub2Zmc2V0LCB0aGlzLm5vcm1hbGl6ZWQpO1xuXHRcdH1cblx0fVxuXHR0b0pTT04oZGF0YSkge1xuXHRcdGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGNvbnNvbGUubG9nKCdUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZS50b0pTT04oKTogU2VyaWFsaXppbmcgYW4gaW50ZXJsZWF2ZWQgYnVmZmVyIGF0dHJpYnV0ZSB3aWxsIGRlaW50ZXJsZWF2ZSBidWZmZXIgZGF0YS4nKTtcblx0XHRcdGNvbnN0IGFycmF5ID0gW107XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY291bnQ7IGkrKykge1xuXHRcdFx0XHRjb25zdCBpbmRleCA9IGkgKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XG5cdFx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5pdGVtU2l6ZTsgaisrKSB7XG5cdFx0XHRcdFx0YXJyYXkucHVzaCh0aGlzLmRhdGEuYXJyYXlbaW5kZXggKyBqXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gZGVpbnRlcmxlYXZlIGRhdGEgYW5kIHNhdmUgaXQgYXMgYW4gb3JkaW5hcnkgYnVmZmVyIGF0dHJpYnV0ZSBmb3Igbm93XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGl0ZW1TaXplOiB0aGlzLml0ZW1TaXplLFxuXHRcdFx0XHR0eXBlOiB0aGlzLmFycmF5LmNvbnN0cnVjdG9yLm5hbWUsXG5cdFx0XHRcdGFycmF5OiBhcnJheSxcblx0XHRcdFx0bm9ybWFsaXplZDogdGhpcy5ub3JtYWxpemVkXG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBzYXZlIGFzIHRydWUgaW50ZXJsZWF2ZWQgYXR0cmlidHVlXG5cblx0XHRcdGlmIChkYXRhLmludGVybGVhdmVkQnVmZmVycyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGRhdGEuaW50ZXJsZWF2ZWRCdWZmZXJzID0ge307XG5cdFx0XHR9XG5cdFx0XHRpZiAoZGF0YS5pbnRlcmxlYXZlZEJ1ZmZlcnNbdGhpcy5kYXRhLnV1aWRdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0ZGF0YS5pbnRlcmxlYXZlZEJ1ZmZlcnNbdGhpcy5kYXRhLnV1aWRdID0gdGhpcy5kYXRhLnRvSlNPTihkYXRhKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGU6IHRydWUsXG5cdFx0XHRcdGl0ZW1TaXplOiB0aGlzLml0ZW1TaXplLFxuXHRcdFx0XHRkYXRhOiB0aGlzLmRhdGEudXVpZCxcblx0XHRcdFx0b2Zmc2V0OiB0aGlzLm9mZnNldCxcblx0XHRcdFx0bm9ybWFsaXplZDogdGhpcy5ub3JtYWxpemVkXG5cdFx0XHR9O1xuXHRcdH1cblx0fVxufVxuXG5jbGFzcyBTcHJpdGVNYXRlcmlhbCBleHRlbmRzIE1hdGVyaWFsIHtcblx0Y29uc3RydWN0b3IocGFyYW1ldGVycykge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5pc1Nwcml0ZU1hdGVyaWFsID0gdHJ1ZTtcblx0XHR0aGlzLnR5cGUgPSAnU3ByaXRlTWF0ZXJpYWwnO1xuXHRcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoMHhmZmZmZmYpO1xuXHRcdHRoaXMubWFwID0gbnVsbDtcblx0XHR0aGlzLmFscGhhTWFwID0gbnVsbDtcblx0XHR0aGlzLnJvdGF0aW9uID0gMDtcblx0XHR0aGlzLnNpemVBdHRlbnVhdGlvbiA9IHRydWU7XG5cdFx0dGhpcy50cmFuc3BhcmVudCA9IHRydWU7XG5cdFx0dGhpcy5mb2cgPSB0cnVlO1xuXHRcdHRoaXMuc2V0VmFsdWVzKHBhcmFtZXRlcnMpO1xuXHR9XG5cdGNvcHkoc291cmNlKSB7XG5cdFx0c3VwZXIuY29weShzb3VyY2UpO1xuXHRcdHRoaXMuY29sb3IuY29weShzb3VyY2UuY29sb3IpO1xuXHRcdHRoaXMubWFwID0gc291cmNlLm1hcDtcblx0XHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xuXHRcdHRoaXMucm90YXRpb24gPSBzb3VyY2Uucm90YXRpb247XG5cdFx0dGhpcy5zaXplQXR0ZW51YXRpb24gPSBzb3VyY2Uuc2l6ZUF0dGVudWF0aW9uO1xuXHRcdHRoaXMuZm9nID0gc291cmNlLmZvZztcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufVxuXG5sZXQgX2dlb21ldHJ5O1xuY29uc3QgX2ludGVyc2VjdFBvaW50ID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5jb25zdCBfd29ybGRTY2FsZSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuY29uc3QgX212UG9zaXRpb24gPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9hbGlnbmVkUG9zaXRpb24gPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjIoKTtcbmNvbnN0IF9yb3RhdGVkUG9zaXRpb24gPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjIoKTtcbmNvbnN0IF92aWV3V29ybGRNYXRyaXggPSAvKkBfX1BVUkVfXyovbmV3IE1hdHJpeDQoKTtcbmNvbnN0IF92QSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuY29uc3QgX3ZCID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5jb25zdCBfdkMgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF91dkEgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjIoKTtcbmNvbnN0IF91dkIgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjIoKTtcbmNvbnN0IF91dkMgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjIoKTtcbmNsYXNzIFNwcml0ZSBleHRlbmRzIE9iamVjdDNEIHtcblx0Y29uc3RydWN0b3IobWF0ZXJpYWwpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuaXNTcHJpdGUgPSB0cnVlO1xuXHRcdHRoaXMudHlwZSA9ICdTcHJpdGUnO1xuXHRcdGlmIChfZ2VvbWV0cnkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0X2dlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdFx0XHRjb25zdCBmbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KFstMC41LCAtMC41LCAwLCAwLCAwLCAwLjUsIC0wLjUsIDAsIDEsIDAsIDAuNSwgMC41LCAwLCAxLCAxLCAtMC41LCAwLjUsIDAsIDAsIDFdKTtcblx0XHRcdGNvbnN0IGludGVybGVhdmVkQnVmZmVyID0gbmV3IEludGVybGVhdmVkQnVmZmVyKGZsb2F0MzJBcnJheSwgNSk7XG5cdFx0XHRfZ2VvbWV0cnkuc2V0SW5kZXgoWzAsIDEsIDIsIDAsIDIsIDNdKTtcblx0XHRcdF9nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKGludGVybGVhdmVkQnVmZmVyLCAzLCAwLCBmYWxzZSkpO1xuXHRcdFx0X2dlb21ldHJ5LnNldEF0dHJpYnV0ZSgndXYnLCBuZXcgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUoaW50ZXJsZWF2ZWRCdWZmZXIsIDIsIDMsIGZhbHNlKSk7XG5cdFx0fVxuXHRcdHRoaXMuZ2VvbWV0cnkgPSBfZ2VvbWV0cnk7XG5cdFx0dGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsICE9PSB1bmRlZmluZWQgPyBtYXRlcmlhbCA6IG5ldyBTcHJpdGVNYXRlcmlhbCgpO1xuXHRcdHRoaXMuY2VudGVyID0gbmV3IFZlY3RvcjIoMC41LCAwLjUpO1xuXHR9XG5cdHJheWNhc3QocmF5Y2FzdGVyLCBpbnRlcnNlY3RzKSB7XG5cdFx0aWYgKHJheWNhc3Rlci5jYW1lcmEgPT09IG51bGwpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLlNwcml0ZTogXCJSYXljYXN0ZXIuY2FtZXJhXCIgbmVlZHMgdG8gYmUgc2V0IGluIG9yZGVyIHRvIHJheWNhc3QgYWdhaW5zdCBzcHJpdGVzLicpO1xuXHRcdH1cblx0XHRfd29ybGRTY2FsZS5zZXRGcm9tTWF0cml4U2NhbGUodGhpcy5tYXRyaXhXb3JsZCk7XG5cdFx0X3ZpZXdXb3JsZE1hdHJpeC5jb3B5KHJheWNhc3Rlci5jYW1lcmEubWF0cml4V29ybGQpO1xuXHRcdHRoaXMubW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMocmF5Y2FzdGVyLmNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UsIHRoaXMubWF0cml4V29ybGQpO1xuXHRcdF9tdlBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbih0aGlzLm1vZGVsVmlld01hdHJpeCk7XG5cdFx0aWYgKHJheWNhc3Rlci5jYW1lcmEuaXNQZXJzcGVjdGl2ZUNhbWVyYSAmJiB0aGlzLm1hdGVyaWFsLnNpemVBdHRlbnVhdGlvbiA9PT0gZmFsc2UpIHtcblx0XHRcdF93b3JsZFNjYWxlLm11bHRpcGx5U2NhbGFyKC1fbXZQb3NpdGlvbi56KTtcblx0XHR9XG5cdFx0Y29uc3Qgcm90YXRpb24gPSB0aGlzLm1hdGVyaWFsLnJvdGF0aW9uO1xuXHRcdGxldCBzaW4sIGNvcztcblx0XHRpZiAocm90YXRpb24gIT09IDApIHtcblx0XHRcdGNvcyA9IE1hdGguY29zKHJvdGF0aW9uKTtcblx0XHRcdHNpbiA9IE1hdGguc2luKHJvdGF0aW9uKTtcblx0XHR9XG5cdFx0Y29uc3QgY2VudGVyID0gdGhpcy5jZW50ZXI7XG5cdFx0dHJhbnNmb3JtVmVydGV4KF92QS5zZXQoLTAuNSwgLTAuNSwgMCksIF9tdlBvc2l0aW9uLCBjZW50ZXIsIF93b3JsZFNjYWxlLCBzaW4sIGNvcyk7XG5cdFx0dHJhbnNmb3JtVmVydGV4KF92Qi5zZXQoMC41LCAtMC41LCAwKSwgX212UG9zaXRpb24sIGNlbnRlciwgX3dvcmxkU2NhbGUsIHNpbiwgY29zKTtcblx0XHR0cmFuc2Zvcm1WZXJ0ZXgoX3ZDLnNldCgwLjUsIDAuNSwgMCksIF9tdlBvc2l0aW9uLCBjZW50ZXIsIF93b3JsZFNjYWxlLCBzaW4sIGNvcyk7XG5cdFx0X3V2QS5zZXQoMCwgMCk7XG5cdFx0X3V2Qi5zZXQoMSwgMCk7XG5cdFx0X3V2Qy5zZXQoMSwgMSk7XG5cblx0XHQvLyBjaGVjayBmaXJzdCB0cmlhbmdsZVxuXHRcdGxldCBpbnRlcnNlY3QgPSByYXljYXN0ZXIucmF5LmludGVyc2VjdFRyaWFuZ2xlKF92QSwgX3ZCLCBfdkMsIGZhbHNlLCBfaW50ZXJzZWN0UG9pbnQpO1xuXHRcdGlmIChpbnRlcnNlY3QgPT09IG51bGwpIHtcblx0XHRcdC8vIGNoZWNrIHNlY29uZCB0cmlhbmdsZVxuXHRcdFx0dHJhbnNmb3JtVmVydGV4KF92Qi5zZXQoLTAuNSwgMC41LCAwKSwgX212UG9zaXRpb24sIGNlbnRlciwgX3dvcmxkU2NhbGUsIHNpbiwgY29zKTtcblx0XHRcdF91dkIuc2V0KDAsIDEpO1xuXHRcdFx0aW50ZXJzZWN0ID0gcmF5Y2FzdGVyLnJheS5pbnRlcnNlY3RUcmlhbmdsZShfdkEsIF92QywgX3ZCLCBmYWxzZSwgX2ludGVyc2VjdFBvaW50KTtcblx0XHRcdGlmIChpbnRlcnNlY3QgPT09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRjb25zdCBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oX2ludGVyc2VjdFBvaW50KTtcblx0XHRpZiAoZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIpIHJldHVybjtcblx0XHRpbnRlcnNlY3RzLnB1c2goe1xuXHRcdFx0ZGlzdGFuY2U6IGRpc3RhbmNlLFxuXHRcdFx0cG9pbnQ6IF9pbnRlcnNlY3RQb2ludC5jbG9uZSgpLFxuXHRcdFx0dXY6IFRyaWFuZ2xlLmdldFVWKF9pbnRlcnNlY3RQb2ludCwgX3ZBLCBfdkIsIF92QywgX3V2QSwgX3V2QiwgX3V2QywgbmV3IFZlY3RvcjIoKSksXG5cdFx0XHRmYWNlOiBudWxsLFxuXHRcdFx0b2JqZWN0OiB0aGlzXG5cdFx0fSk7XG5cdH1cblx0Y29weShzb3VyY2UsIHJlY3Vyc2l2ZSkge1xuXHRcdHN1cGVyLmNvcHkoc291cmNlLCByZWN1cnNpdmUpO1xuXHRcdGlmIChzb3VyY2UuY2VudGVyICE9PSB1bmRlZmluZWQpIHRoaXMuY2VudGVyLmNvcHkoc291cmNlLmNlbnRlcik7XG5cdFx0dGhpcy5tYXRlcmlhbCA9IHNvdXJjZS5tYXRlcmlhbDtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufVxuZnVuY3Rpb24gdHJhbnNmb3JtVmVydGV4KHZlcnRleFBvc2l0aW9uLCBtdlBvc2l0aW9uLCBjZW50ZXIsIHNjYWxlLCBzaW4sIGNvcykge1xuXHQvLyBjb21wdXRlIHBvc2l0aW9uIGluIGNhbWVyYSBzcGFjZVxuXHRfYWxpZ25lZFBvc2l0aW9uLnN1YlZlY3RvcnModmVydGV4UG9zaXRpb24sIGNlbnRlcikuYWRkU2NhbGFyKDAuNSkubXVsdGlwbHkoc2NhbGUpO1xuXG5cdC8vIHRvIGNoZWNrIGlmIHJvdGF0aW9uIGlzIG5vdCB6ZXJvXG5cdGlmIChzaW4gIT09IHVuZGVmaW5lZCkge1xuXHRcdF9yb3RhdGVkUG9zaXRpb24ueCA9IGNvcyAqIF9hbGlnbmVkUG9zaXRpb24ueCAtIHNpbiAqIF9hbGlnbmVkUG9zaXRpb24ueTtcblx0XHRfcm90YXRlZFBvc2l0aW9uLnkgPSBzaW4gKiBfYWxpZ25lZFBvc2l0aW9uLnggKyBjb3MgKiBfYWxpZ25lZFBvc2l0aW9uLnk7XG5cdH0gZWxzZSB7XG5cdFx0X3JvdGF0ZWRQb3NpdGlvbi5jb3B5KF9hbGlnbmVkUG9zaXRpb24pO1xuXHR9XG5cdHZlcnRleFBvc2l0aW9uLmNvcHkobXZQb3NpdGlvbik7XG5cdHZlcnRleFBvc2l0aW9uLnggKz0gX3JvdGF0ZWRQb3NpdGlvbi54O1xuXHR2ZXJ0ZXhQb3NpdGlvbi55ICs9IF9yb3RhdGVkUG9zaXRpb24ueTtcblxuXHQvLyB0cmFuc2Zvcm0gdG8gd29ybGQgc3BhY2Vcblx0dmVydGV4UG9zaXRpb24uYXBwbHlNYXRyaXg0KF92aWV3V29ybGRNYXRyaXgpO1xufVxuXG5jb25zdCBfdjEkMiA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuY29uc3QgX3YyJDEgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcbmNsYXNzIExPRCBleHRlbmRzIE9iamVjdDNEIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLl9jdXJyZW50TGV2ZWwgPSAwO1xuXHRcdHRoaXMudHlwZSA9ICdMT0QnO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcblx0XHRcdGxldmVsczoge1xuXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZTogW11cblx0XHRcdH0sXG5cdFx0XHRpc0xPRDoge1xuXHRcdFx0XHR2YWx1ZTogdHJ1ZVxuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHRoaXMuYXV0b1VwZGF0ZSA9IHRydWU7XG5cdH1cblx0Y29weShzb3VyY2UpIHtcblx0XHRzdXBlci5jb3B5KHNvdXJjZSwgZmFsc2UpO1xuXHRcdGNvbnN0IGxldmVscyA9IHNvdXJjZS5sZXZlbHM7XG5cdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBsZXZlbHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRjb25zdCBsZXZlbCA9IGxldmVsc1tpXTtcblx0XHRcdHRoaXMuYWRkTGV2ZWwobGV2ZWwub2JqZWN0LmNsb25lKCksIGxldmVsLmRpc3RhbmNlKTtcblx0XHR9XG5cdFx0dGhpcy5hdXRvVXBkYXRlID0gc291cmNlLmF1dG9VcGRhdGU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0YWRkTGV2ZWwob2JqZWN0LCBkaXN0YW5jZSA9IDApIHtcblx0XHRkaXN0YW5jZSA9IE1hdGguYWJzKGRpc3RhbmNlKTtcblx0XHRjb25zdCBsZXZlbHMgPSB0aGlzLmxldmVscztcblx0XHRsZXQgbDtcblx0XHRmb3IgKGwgPSAwOyBsIDwgbGV2ZWxzLmxlbmd0aDsgbCsrKSB7XG5cdFx0XHRpZiAoZGlzdGFuY2UgPCBsZXZlbHNbbF0uZGlzdGFuY2UpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGxldmVscy5zcGxpY2UobCwgMCwge1xuXHRcdFx0ZGlzdGFuY2U6IGRpc3RhbmNlLFxuXHRcdFx0b2JqZWN0OiBvYmplY3Rcblx0XHR9KTtcblx0XHR0aGlzLmFkZChvYmplY3QpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGdldEN1cnJlbnRMZXZlbCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fY3VycmVudExldmVsO1xuXHR9XG5cdGdldE9iamVjdEZvckRpc3RhbmNlKGRpc3RhbmNlKSB7XG5cdFx0Y29uc3QgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG5cdFx0aWYgKGxldmVscy5sZW5ndGggPiAwKSB7XG5cdFx0XHRsZXQgaSwgbDtcblx0XHRcdGZvciAoaSA9IDEsIGwgPSBsZXZlbHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGlmIChkaXN0YW5jZSA8IGxldmVsc1tpXS5kaXN0YW5jZSkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbGV2ZWxzW2kgLSAxXS5vYmplY3Q7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdHJheWNhc3QocmF5Y2FzdGVyLCBpbnRlcnNlY3RzKSB7XG5cdFx0Y29uc3QgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG5cdFx0aWYgKGxldmVscy5sZW5ndGggPiAwKSB7XG5cdFx0XHRfdjEkMi5zZXRGcm9tTWF0cml4UG9zaXRpb24odGhpcy5tYXRyaXhXb3JsZCk7XG5cdFx0XHRjb25zdCBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oX3YxJDIpO1xuXHRcdFx0dGhpcy5nZXRPYmplY3RGb3JEaXN0YW5jZShkaXN0YW5jZSkucmF5Y2FzdChyYXljYXN0ZXIsIGludGVyc2VjdHMpO1xuXHRcdH1cblx0fVxuXHR1cGRhdGUoY2FtZXJhKSB7XG5cdFx0Y29uc3QgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG5cdFx0aWYgKGxldmVscy5sZW5ndGggPiAxKSB7XG5cdFx0XHRfdjEkMi5zZXRGcm9tTWF0cml4UG9zaXRpb24oY2FtZXJhLm1hdHJpeFdvcmxkKTtcblx0XHRcdF92MiQxLnNldEZyb21NYXRyaXhQb3NpdGlvbih0aGlzLm1hdHJpeFdvcmxkKTtcblx0XHRcdGNvbnN0IGRpc3RhbmNlID0gX3YxJDIuZGlzdGFuY2VUbyhfdjIkMSkgLyBjYW1lcmEuem9vbTtcblx0XHRcdGxldmVsc1swXS5vYmplY3QudmlzaWJsZSA9IHRydWU7XG5cdFx0XHRsZXQgaSwgbDtcblx0XHRcdGZvciAoaSA9IDEsIGwgPSBsZXZlbHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGlmIChkaXN0YW5jZSA+PSBsZXZlbHNbaV0uZGlzdGFuY2UpIHtcblx0XHRcdFx0XHRsZXZlbHNbaSAtIDFdLm9iamVjdC52aXNpYmxlID0gZmFsc2U7XG5cdFx0XHRcdFx0bGV2ZWxzW2ldLm9iamVjdC52aXNpYmxlID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5fY3VycmVudExldmVsID0gaSAtIDE7XG5cdFx0XHRmb3IgKDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRsZXZlbHNbaV0ub2JqZWN0LnZpc2libGUgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0dG9KU09OKG1ldGEpIHtcblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKG1ldGEpO1xuXHRcdGlmICh0aGlzLmF1dG9VcGRhdGUgPT09IGZhbHNlKSBkYXRhLm9iamVjdC5hdXRvVXBkYXRlID0gZmFsc2U7XG5cdFx0ZGF0YS5vYmplY3QubGV2ZWxzID0gW107XG5cdFx0Y29uc3QgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG5cdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBsZXZlbHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRjb25zdCBsZXZlbCA9IGxldmVsc1tpXTtcblx0XHRcdGRhdGEub2JqZWN0LmxldmVscy5wdXNoKHtcblx0XHRcdFx0b2JqZWN0OiBsZXZlbC5vYmplY3QudXVpZCxcblx0XHRcdFx0ZGlzdGFuY2U6IGxldmVsLmRpc3RhbmNlXG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0cmV0dXJuIGRhdGE7XG5cdH1cbn1cblxuY29uc3QgX2Jhc2VQb3NpdGlvbiA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuY29uc3QgX3NraW5JbmRleCA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yNCgpO1xuY29uc3QgX3NraW5XZWlnaHQgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjQoKTtcbmNvbnN0IF92ZWN0b3IkNSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuY29uc3QgX21hdHJpeCA9IC8qQF9fUFVSRV9fKi9uZXcgTWF0cml4NCgpO1xuY2xhc3MgU2tpbm5lZE1lc2ggZXh0ZW5kcyBNZXNoIHtcblx0Y29uc3RydWN0b3IoZ2VvbWV0cnksIG1hdGVyaWFsKSB7XG5cdFx0c3VwZXIoZ2VvbWV0cnksIG1hdGVyaWFsKTtcblx0XHR0aGlzLmlzU2tpbm5lZE1lc2ggPSB0cnVlO1xuXHRcdHRoaXMudHlwZSA9ICdTa2lubmVkTWVzaCc7XG5cdFx0dGhpcy5iaW5kTW9kZSA9ICdhdHRhY2hlZCc7XG5cdFx0dGhpcy5iaW5kTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblx0XHR0aGlzLmJpbmRNYXRyaXhJbnZlcnNlID0gbmV3IE1hdHJpeDQoKTtcblx0fVxuXHRjb3B5KHNvdXJjZSwgcmVjdXJzaXZlKSB7XG5cdFx0c3VwZXIuY29weShzb3VyY2UsIHJlY3Vyc2l2ZSk7XG5cdFx0dGhpcy5iaW5kTW9kZSA9IHNvdXJjZS5iaW5kTW9kZTtcblx0XHR0aGlzLmJpbmRNYXRyaXguY29weShzb3VyY2UuYmluZE1hdHJpeCk7XG5cdFx0dGhpcy5iaW5kTWF0cml4SW52ZXJzZS5jb3B5KHNvdXJjZS5iaW5kTWF0cml4SW52ZXJzZSk7XG5cdFx0dGhpcy5za2VsZXRvbiA9IHNvdXJjZS5za2VsZXRvbjtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRiaW5kKHNrZWxldG9uLCBiaW5kTWF0cml4KSB7XG5cdFx0dGhpcy5za2VsZXRvbiA9IHNrZWxldG9uO1xuXHRcdGlmIChiaW5kTWF0cml4ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMudXBkYXRlTWF0cml4V29ybGQodHJ1ZSk7XG5cdFx0XHR0aGlzLnNrZWxldG9uLmNhbGN1bGF0ZUludmVyc2VzKCk7XG5cdFx0XHRiaW5kTWF0cml4ID0gdGhpcy5tYXRyaXhXb3JsZDtcblx0XHR9XG5cdFx0dGhpcy5iaW5kTWF0cml4LmNvcHkoYmluZE1hdHJpeCk7XG5cdFx0dGhpcy5iaW5kTWF0cml4SW52ZXJzZS5jb3B5KGJpbmRNYXRyaXgpLmludmVydCgpO1xuXHR9XG5cdHBvc2UoKSB7XG5cdFx0dGhpcy5za2VsZXRvbi5wb3NlKCk7XG5cdH1cblx0bm9ybWFsaXplU2tpbldlaWdodHMoKSB7XG5cdFx0Y29uc3QgdmVjdG9yID0gbmV3IFZlY3RvcjQoKTtcblx0XHRjb25zdCBza2luV2VpZ2h0ID0gdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLnNraW5XZWlnaHQ7XG5cdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBza2luV2VpZ2h0LmNvdW50OyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2ZWN0b3IuZnJvbUJ1ZmZlckF0dHJpYnV0ZShza2luV2VpZ2h0LCBpKTtcblx0XHRcdGNvbnN0IHNjYWxlID0gMS4wIC8gdmVjdG9yLm1hbmhhdHRhbkxlbmd0aCgpO1xuXHRcdFx0aWYgKHNjYWxlICE9PSBJbmZpbml0eSkge1xuXHRcdFx0XHR2ZWN0b3IubXVsdGlwbHlTY2FsYXIoc2NhbGUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmVjdG9yLnNldCgxLCAwLCAwLCAwKTsgLy8gZG8gc29tZXRoaW5nIHJlYXNvbmFibGVcblx0XHRcdH1cblxuXHRcdFx0c2tpbldlaWdodC5zZXRYWVpXKGksIHZlY3Rvci54LCB2ZWN0b3IueSwgdmVjdG9yLnosIHZlY3Rvci53KTtcblx0XHR9XG5cdH1cblx0dXBkYXRlTWF0cml4V29ybGQoZm9yY2UpIHtcblx0XHRzdXBlci51cGRhdGVNYXRyaXhXb3JsZChmb3JjZSk7XG5cdFx0aWYgKHRoaXMuYmluZE1vZGUgPT09ICdhdHRhY2hlZCcpIHtcblx0XHRcdHRoaXMuYmluZE1hdHJpeEludmVyc2UuY29weSh0aGlzLm1hdHJpeFdvcmxkKS5pbnZlcnQoKTtcblx0XHR9IGVsc2UgaWYgKHRoaXMuYmluZE1vZGUgPT09ICdkZXRhY2hlZCcpIHtcblx0XHRcdHRoaXMuYmluZE1hdHJpeEludmVyc2UuY29weSh0aGlzLmJpbmRNYXRyaXgpLmludmVydCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlNraW5uZWRNZXNoOiBVbnJlY29nbml6ZWQgYmluZE1vZGU6ICcgKyB0aGlzLmJpbmRNb2RlKTtcblx0XHR9XG5cdH1cblx0Ym9uZVRyYW5zZm9ybShpbmRleCwgdGFyZ2V0KSB7XG5cdFx0Y29uc3Qgc2tlbGV0b24gPSB0aGlzLnNrZWxldG9uO1xuXHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblx0XHRfc2tpbkluZGV4LmZyb21CdWZmZXJBdHRyaWJ1dGUoZ2VvbWV0cnkuYXR0cmlidXRlcy5za2luSW5kZXgsIGluZGV4KTtcblx0XHRfc2tpbldlaWdodC5mcm9tQnVmZmVyQXR0cmlidXRlKGdlb21ldHJ5LmF0dHJpYnV0ZXMuc2tpbldlaWdodCwgaW5kZXgpO1xuXHRcdF9iYXNlUG9zaXRpb24uY29weSh0YXJnZXQpLmFwcGx5TWF0cml4NCh0aGlzLmJpbmRNYXRyaXgpO1xuXHRcdHRhcmdldC5zZXQoMCwgMCwgMCk7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0XHRcdGNvbnN0IHdlaWdodCA9IF9za2luV2VpZ2h0LmdldENvbXBvbmVudChpKTtcblx0XHRcdGlmICh3ZWlnaHQgIT09IDApIHtcblx0XHRcdFx0Y29uc3QgYm9uZUluZGV4ID0gX3NraW5JbmRleC5nZXRDb21wb25lbnQoaSk7XG5cdFx0XHRcdF9tYXRyaXgubXVsdGlwbHlNYXRyaWNlcyhza2VsZXRvbi5ib25lc1tib25lSW5kZXhdLm1hdHJpeFdvcmxkLCBza2VsZXRvbi5ib25lSW52ZXJzZXNbYm9uZUluZGV4XSk7XG5cdFx0XHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoX3ZlY3RvciQ1LmNvcHkoX2Jhc2VQb3NpdGlvbikuYXBwbHlNYXRyaXg0KF9tYXRyaXgpLCB3ZWlnaHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGFyZ2V0LmFwcGx5TWF0cml4NCh0aGlzLmJpbmRNYXRyaXhJbnZlcnNlKTtcblx0fVxufVxuXG5jbGFzcyBCb25lIGV4dGVuZHMgT2JqZWN0M0Qge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuaXNCb25lID0gdHJ1ZTtcblx0XHR0aGlzLnR5cGUgPSAnQm9uZSc7XG5cdH1cbn1cblxuY2xhc3MgRGF0YVRleHR1cmUgZXh0ZW5kcyBUZXh0dXJlIHtcblx0Y29uc3RydWN0b3IoZGF0YSA9IG51bGwsIHdpZHRoID0gMSwgaGVpZ2h0ID0gMSwgZm9ybWF0LCB0eXBlLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciA9IE5lYXJlc3RGaWx0ZXIsIG1pbkZpbHRlciA9IE5lYXJlc3RGaWx0ZXIsIGFuaXNvdHJvcHksIGVuY29kaW5nKSB7XG5cdFx0c3VwZXIobnVsbCwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5LCBlbmNvZGluZyk7XG5cdFx0dGhpcy5pc0RhdGFUZXh0dXJlID0gdHJ1ZTtcblx0XHR0aGlzLmltYWdlID0ge1xuXHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdHdpZHRoOiB3aWR0aCxcblx0XHRcdGhlaWdodDogaGVpZ2h0XG5cdFx0fTtcblx0XHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXHRcdHRoaXMuZmxpcFkgPSBmYWxzZTtcblx0XHR0aGlzLnVucGFja0FsaWdubWVudCA9IDE7XG5cdH1cbn1cblxuY29uc3QgX29mZnNldE1hdHJpeCA9IC8qQF9fUFVSRV9fKi9uZXcgTWF0cml4NCgpO1xuY29uc3QgX2lkZW50aXR5TWF0cml4ID0gLypAX19QVVJFX18qL25ldyBNYXRyaXg0KCk7XG5jbGFzcyBTa2VsZXRvbiB7XG5cdGNvbnN0cnVjdG9yKGJvbmVzID0gW10sIGJvbmVJbnZlcnNlcyA9IFtdKSB7XG5cdFx0dGhpcy51dWlkID0gZ2VuZXJhdGVVVUlEKCk7XG5cdFx0dGhpcy5ib25lcyA9IGJvbmVzLnNsaWNlKDApO1xuXHRcdHRoaXMuYm9uZUludmVyc2VzID0gYm9uZUludmVyc2VzO1xuXHRcdHRoaXMuYm9uZU1hdHJpY2VzID0gbnVsbDtcblx0XHR0aGlzLmJvbmVUZXh0dXJlID0gbnVsbDtcblx0XHR0aGlzLmJvbmVUZXh0dXJlU2l6ZSA9IDA7XG5cdFx0dGhpcy5mcmFtZSA9IC0xO1xuXHRcdHRoaXMuaW5pdCgpO1xuXHR9XG5cdGluaXQoKSB7XG5cdFx0Y29uc3QgYm9uZXMgPSB0aGlzLmJvbmVzO1xuXHRcdGNvbnN0IGJvbmVJbnZlcnNlcyA9IHRoaXMuYm9uZUludmVyc2VzO1xuXHRcdHRoaXMuYm9uZU1hdHJpY2VzID0gbmV3IEZsb2F0MzJBcnJheShib25lcy5sZW5ndGggKiAxNik7XG5cblx0XHQvLyBjYWxjdWxhdGUgaW52ZXJzZSBib25lIG1hdHJpY2VzIGlmIG5lY2Vzc2FyeVxuXG5cdFx0aWYgKGJvbmVJbnZlcnNlcy5sZW5ndGggPT09IDApIHtcblx0XHRcdHRoaXMuY2FsY3VsYXRlSW52ZXJzZXMoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaGFuZGxlIHNwZWNpYWwgY2FzZVxuXG5cdFx0XHRpZiAoYm9uZXMubGVuZ3RoICE9PSBib25lSW52ZXJzZXMubGVuZ3RoKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuU2tlbGV0b246IE51bWJlciBvZiBpbnZlcnNlIGJvbmUgbWF0cmljZXMgZG9lcyBub3QgbWF0Y2ggYW1vdW50IG9mIGJvbmVzLicpO1xuXHRcdFx0XHR0aGlzLmJvbmVJbnZlcnNlcyA9IFtdO1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0XHR0aGlzLmJvbmVJbnZlcnNlcy5wdXNoKG5ldyBNYXRyaXg0KCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGNhbGN1bGF0ZUludmVyc2VzKCkge1xuXHRcdHRoaXMuYm9uZUludmVyc2VzLmxlbmd0aCA9IDA7XG5cdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gdGhpcy5ib25lcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRjb25zdCBpbnZlcnNlID0gbmV3IE1hdHJpeDQoKTtcblx0XHRcdGlmICh0aGlzLmJvbmVzW2ldKSB7XG5cdFx0XHRcdGludmVyc2UuY29weSh0aGlzLmJvbmVzW2ldLm1hdHJpeFdvcmxkKS5pbnZlcnQoKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuYm9uZUludmVyc2VzLnB1c2goaW52ZXJzZSk7XG5cdFx0fVxuXHR9XG5cdHBvc2UoKSB7XG5cdFx0Ly8gcmVjb3ZlciB0aGUgYmluZC10aW1lIHdvcmxkIG1hdHJpY2VzXG5cblx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdGNvbnN0IGJvbmUgPSB0aGlzLmJvbmVzW2ldO1xuXHRcdFx0aWYgKGJvbmUpIHtcblx0XHRcdFx0Ym9uZS5tYXRyaXhXb3JsZC5jb3B5KHRoaXMuYm9uZUludmVyc2VzW2ldKS5pbnZlcnQoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBjb21wdXRlIHRoZSBsb2NhbCBtYXRyaWNlcywgcG9zaXRpb25zLCByb3RhdGlvbnMgYW5kIHNjYWxlc1xuXG5cdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gdGhpcy5ib25lcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRjb25zdCBib25lID0gdGhpcy5ib25lc1tpXTtcblx0XHRcdGlmIChib25lKSB7XG5cdFx0XHRcdGlmIChib25lLnBhcmVudCAmJiBib25lLnBhcmVudC5pc0JvbmUpIHtcblx0XHRcdFx0XHRib25lLm1hdHJpeC5jb3B5KGJvbmUucGFyZW50Lm1hdHJpeFdvcmxkKS5pbnZlcnQoKTtcblx0XHRcdFx0XHRib25lLm1hdHJpeC5tdWx0aXBseShib25lLm1hdHJpeFdvcmxkKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRib25lLm1hdHJpeC5jb3B5KGJvbmUubWF0cml4V29ybGQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJvbmUubWF0cml4LmRlY29tcG9zZShib25lLnBvc2l0aW9uLCBib25lLnF1YXRlcm5pb24sIGJvbmUuc2NhbGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHR1cGRhdGUoKSB7XG5cdFx0Y29uc3QgYm9uZXMgPSB0aGlzLmJvbmVzO1xuXHRcdGNvbnN0IGJvbmVJbnZlcnNlcyA9IHRoaXMuYm9uZUludmVyc2VzO1xuXHRcdGNvbnN0IGJvbmVNYXRyaWNlcyA9IHRoaXMuYm9uZU1hdHJpY2VzO1xuXHRcdGNvbnN0IGJvbmVUZXh0dXJlID0gdGhpcy5ib25lVGV4dHVyZTtcblxuXHRcdC8vIGZsYXR0ZW4gYm9uZSBtYXRyaWNlcyB0byBhcnJheVxuXG5cdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gYm9uZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0Ly8gY29tcHV0ZSB0aGUgb2Zmc2V0IGJldHdlZW4gdGhlIGN1cnJlbnQgYW5kIHRoZSBvcmlnaW5hbCB0cmFuc2Zvcm1cblxuXHRcdFx0Y29uc3QgbWF0cml4ID0gYm9uZXNbaV0gPyBib25lc1tpXS5tYXRyaXhXb3JsZCA6IF9pZGVudGl0eU1hdHJpeDtcblx0XHRcdF9vZmZzZXRNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyhtYXRyaXgsIGJvbmVJbnZlcnNlc1tpXSk7XG5cdFx0XHRfb2Zmc2V0TWF0cml4LnRvQXJyYXkoYm9uZU1hdHJpY2VzLCBpICogMTYpO1xuXHRcdH1cblx0XHRpZiAoYm9uZVRleHR1cmUgIT09IG51bGwpIHtcblx0XHRcdGJvbmVUZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHR9XG5cdH1cblx0Y2xvbmUoKSB7XG5cdFx0cmV0dXJuIG5ldyBTa2VsZXRvbih0aGlzLmJvbmVzLCB0aGlzLmJvbmVJbnZlcnNlcyk7XG5cdH1cblx0Y29tcHV0ZUJvbmVUZXh0dXJlKCkge1xuXHRcdC8vIGxheW91dCAoMSBtYXRyaXggPSA0IHBpeGVscylcblx0XHQvL1x0XHRcdFJHQkEgUkdCQSBSR0JBIFJHQkEgKD0+IGNvbHVtbjEsIGNvbHVtbjIsIGNvbHVtbjMsIGNvbHVtbjQpXG5cdFx0Ly9cdHdpdGhcdDh4OFx0cGl4ZWwgdGV4dHVyZSBtYXhcdCAxNiBib25lcyAqIDQgcGl4ZWxzID1cdCg4ICogOClcblx0XHQvL1x0XHRcdCAxNngxNiBwaXhlbCB0ZXh0dXJlIG1heFx0IDY0IGJvbmVzICogNCBwaXhlbHMgPSAoMTYgKiAxNilcblx0XHQvL1x0XHRcdCAzMngzMiBwaXhlbCB0ZXh0dXJlIG1heFx0MjU2IGJvbmVzICogNCBwaXhlbHMgPSAoMzIgKiAzMilcblx0XHQvL1x0XHRcdCA2NHg2NCBwaXhlbCB0ZXh0dXJlIG1heCAxMDI0IGJvbmVzICogNCBwaXhlbHMgPSAoNjQgKiA2NClcblxuXHRcdGxldCBzaXplID0gTWF0aC5zcXJ0KHRoaXMuYm9uZXMubGVuZ3RoICogNCk7IC8vIDQgcGl4ZWxzIG5lZWRlZCBmb3IgMSBtYXRyaXhcblx0XHRzaXplID0gY2VpbFBvd2VyT2ZUd28oc2l6ZSk7XG5cdFx0c2l6ZSA9IE1hdGgubWF4KHNpemUsIDQpO1xuXHRcdGNvbnN0IGJvbmVNYXRyaWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSAqIHNpemUgKiA0KTsgLy8gNCBmbG9hdHMgcGVyIFJHQkEgcGl4ZWxcblx0XHRib25lTWF0cmljZXMuc2V0KHRoaXMuYm9uZU1hdHJpY2VzKTsgLy8gY29weSBjdXJyZW50IHZhbHVlc1xuXG5cdFx0Y29uc3QgYm9uZVRleHR1cmUgPSBuZXcgRGF0YVRleHR1cmUoYm9uZU1hdHJpY2VzLCBzaXplLCBzaXplLCBSR0JBRm9ybWF0LCBGbG9hdFR5cGUpO1xuXHRcdGJvbmVUZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHR0aGlzLmJvbmVNYXRyaWNlcyA9IGJvbmVNYXRyaWNlcztcblx0XHR0aGlzLmJvbmVUZXh0dXJlID0gYm9uZVRleHR1cmU7XG5cdFx0dGhpcy5ib25lVGV4dHVyZVNpemUgPSBzaXplO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGdldEJvbmVCeU5hbWUobmFtZSkge1xuXHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0Y29uc3QgYm9uZSA9IHRoaXMuYm9uZXNbaV07XG5cdFx0XHRpZiAoYm9uZS5uYW1lID09PSBuYW1lKSB7XG5cdFx0XHRcdHJldHVybiBib25lO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHR9XG5cdGRpc3Bvc2UoKSB7XG5cdFx0aWYgKHRoaXMuYm9uZVRleHR1cmUgIT09IG51bGwpIHtcblx0XHRcdHRoaXMuYm9uZVRleHR1cmUuZGlzcG9zZSgpO1xuXHRcdFx0dGhpcy5ib25lVGV4dHVyZSA9IG51bGw7XG5cdFx0fVxuXHR9XG5cdGZyb21KU09OKGpzb24sIGJvbmVzKSB7XG5cdFx0dGhpcy51dWlkID0ganNvbi51dWlkO1xuXHRcdGZvciAobGV0IGkgPSAwLCBsID0ganNvbi5ib25lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGNvbnN0IHV1aWQgPSBqc29uLmJvbmVzW2ldO1xuXHRcdFx0bGV0IGJvbmUgPSBib25lc1t1dWlkXTtcblx0XHRcdGlmIChib25lID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5Ta2VsZXRvbjogTm8gYm9uZSBmb3VuZCB3aXRoIFVVSUQ6JywgdXVpZCk7XG5cdFx0XHRcdGJvbmUgPSBuZXcgQm9uZSgpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5ib25lcy5wdXNoKGJvbmUpO1xuXHRcdFx0dGhpcy5ib25lSW52ZXJzZXMucHVzaChuZXcgTWF0cml4NCgpLmZyb21BcnJheShqc29uLmJvbmVJbnZlcnNlc1tpXSkpO1xuXHRcdH1cblx0XHR0aGlzLmluaXQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHR0b0pTT04oKSB7XG5cdFx0Y29uc3QgZGF0YSA9IHtcblx0XHRcdG1ldGFkYXRhOiB7XG5cdFx0XHRcdHZlcnNpb246IDQuNSxcblx0XHRcdFx0dHlwZTogJ1NrZWxldG9uJyxcblx0XHRcdFx0Z2VuZXJhdG9yOiAnU2tlbGV0b24udG9KU09OJ1xuXHRcdFx0fSxcblx0XHRcdGJvbmVzOiBbXSxcblx0XHRcdGJvbmVJbnZlcnNlczogW11cblx0XHR9O1xuXHRcdGRhdGEudXVpZCA9IHRoaXMudXVpZDtcblx0XHRjb25zdCBib25lcyA9IHRoaXMuYm9uZXM7XG5cdFx0Y29uc3QgYm9uZUludmVyc2VzID0gdGhpcy5ib25lSW52ZXJzZXM7XG5cdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBib25lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGNvbnN0IGJvbmUgPSBib25lc1tpXTtcblx0XHRcdGRhdGEuYm9uZXMucHVzaChib25lLnV1aWQpO1xuXHRcdFx0Y29uc3QgYm9uZUludmVyc2UgPSBib25lSW52ZXJzZXNbaV07XG5cdFx0XHRkYXRhLmJvbmVJbnZlcnNlcy5wdXNoKGJvbmVJbnZlcnNlLnRvQXJyYXkoKSk7XG5cdFx0fVxuXHRcdHJldHVybiBkYXRhO1xuXHR9XG59XG5cbmNsYXNzIEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSBleHRlbmRzIEJ1ZmZlckF0dHJpYnV0ZSB7XG5cdGNvbnN0cnVjdG9yKGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCwgbWVzaFBlckF0dHJpYnV0ZSA9IDEpIHtcblx0XHRzdXBlcihhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQpO1xuXHRcdHRoaXMuaXNJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgPSB0cnVlO1xuXHRcdHRoaXMubWVzaFBlckF0dHJpYnV0ZSA9IG1lc2hQZXJBdHRyaWJ1dGU7XG5cdH1cblx0Y29weShzb3VyY2UpIHtcblx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0dGhpcy5tZXNoUGVyQXR0cmlidXRlID0gc291cmNlLm1lc2hQZXJBdHRyaWJ1dGU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0dG9KU09OKCkge1xuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oKTtcblx0XHRkYXRhLm1lc2hQZXJBdHRyaWJ1dGUgPSB0aGlzLm1lc2hQZXJBdHRyaWJ1dGU7XG5cdFx0ZGF0YS5pc0luc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSA9IHRydWU7XG5cdFx0cmV0dXJuIGRhdGE7XG5cdH1cbn1cblxuY29uc3QgX2luc3RhbmNlTG9jYWxNYXRyaXggPSAvKkBfX1BVUkVfXyovbmV3IE1hdHJpeDQoKTtcbmNvbnN0IF9pbnN0YW5jZVdvcmxkTWF0cml4ID0gLypAX19QVVJFX18qL25ldyBNYXRyaXg0KCk7XG5jb25zdCBfaW5zdGFuY2VJbnRlcnNlY3RzID0gW107XG5jb25zdCBfaWRlbnRpdHkgPSAvKkBfX1BVUkVfXyovbmV3IE1hdHJpeDQoKTtcbmNvbnN0IF9tZXNoID0gLypAX19QVVJFX18qL25ldyBNZXNoKCk7XG5jbGFzcyBJbnN0YW5jZWRNZXNoIGV4dGVuZHMgTWVzaCB7XG5cdGNvbnN0cnVjdG9yKGdlb21ldHJ5LCBtYXRlcmlhbCwgY291bnQpIHtcblx0XHRzdXBlcihnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuXHRcdHRoaXMuaXNJbnN0YW5jZWRNZXNoID0gdHJ1ZTtcblx0XHR0aGlzLmluc3RhbmNlTWF0cml4ID0gbmV3IEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZShuZXcgRmxvYXQzMkFycmF5KGNvdW50ICogMTYpLCAxNik7XG5cdFx0dGhpcy5pbnN0YW5jZUNvbG9yID0gbnVsbDtcblx0XHR0aGlzLmNvdW50ID0gY291bnQ7XG5cdFx0dGhpcy5mcnVzdHVtQ3VsbGVkID0gZmFsc2U7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG5cdFx0XHR0aGlzLnNldE1hdHJpeEF0KGksIF9pZGVudGl0eSk7XG5cdFx0fVxuXHR9XG5cdGNvcHkoc291cmNlLCByZWN1cnNpdmUpIHtcblx0XHRzdXBlci5jb3B5KHNvdXJjZSwgcmVjdXJzaXZlKTtcblx0XHR0aGlzLmluc3RhbmNlTWF0cml4LmNvcHkoc291cmNlLmluc3RhbmNlTWF0cml4KTtcblx0XHRpZiAoc291cmNlLmluc3RhbmNlQ29sb3IgIT09IG51bGwpIHRoaXMuaW5zdGFuY2VDb2xvciA9IHNvdXJjZS5pbnN0YW5jZUNvbG9yLmNsb25lKCk7XG5cdFx0dGhpcy5jb3VudCA9IHNvdXJjZS5jb3VudDtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRnZXRDb2xvckF0KGluZGV4LCBjb2xvcikge1xuXHRcdGNvbG9yLmZyb21BcnJheSh0aGlzLmluc3RhbmNlQ29sb3IuYXJyYXksIGluZGV4ICogMyk7XG5cdH1cblx0Z2V0TWF0cml4QXQoaW5kZXgsIG1hdHJpeCkge1xuXHRcdG1hdHJpeC5mcm9tQXJyYXkodGhpcy5pbnN0YW5jZU1hdHJpeC5hcnJheSwgaW5kZXggKiAxNik7XG5cdH1cblx0cmF5Y2FzdChyYXljYXN0ZXIsIGludGVyc2VjdHMpIHtcblx0XHRjb25zdCBtYXRyaXhXb3JsZCA9IHRoaXMubWF0cml4V29ybGQ7XG5cdFx0Y29uc3QgcmF5Y2FzdFRpbWVzID0gdGhpcy5jb3VudDtcblx0XHRfbWVzaC5nZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cdFx0X21lc2gubWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsO1xuXHRcdGlmIChfbWVzaC5tYXRlcmlhbCA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cdFx0Zm9yIChsZXQgaW5zdGFuY2VJZCA9IDA7IGluc3RhbmNlSWQgPCByYXljYXN0VGltZXM7IGluc3RhbmNlSWQrKykge1xuXHRcdFx0Ly8gY2FsY3VsYXRlIHRoZSB3b3JsZCBtYXRyaXggZm9yIGVhY2ggaW5zdGFuY2VcblxuXHRcdFx0dGhpcy5nZXRNYXRyaXhBdChpbnN0YW5jZUlkLCBfaW5zdGFuY2VMb2NhbE1hdHJpeCk7XG5cdFx0XHRfaW5zdGFuY2VXb3JsZE1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKG1hdHJpeFdvcmxkLCBfaW5zdGFuY2VMb2NhbE1hdHJpeCk7XG5cblx0XHRcdC8vIHRoZSBtZXNoIHJlcHJlc2VudHMgdGhpcyBzaW5nbGUgaW5zdGFuY2VcblxuXHRcdFx0X21lc2gubWF0cml4V29ybGQgPSBfaW5zdGFuY2VXb3JsZE1hdHJpeDtcblx0XHRcdF9tZXNoLnJheWNhc3QocmF5Y2FzdGVyLCBfaW5zdGFuY2VJbnRlcnNlY3RzKTtcblxuXHRcdFx0Ly8gcHJvY2VzcyB0aGUgcmVzdWx0IG9mIHJheWNhc3RcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBfaW5zdGFuY2VJbnRlcnNlY3RzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRjb25zdCBpbnRlcnNlY3QgPSBfaW5zdGFuY2VJbnRlcnNlY3RzW2ldO1xuXHRcdFx0XHRpbnRlcnNlY3QuaW5zdGFuY2VJZCA9IGluc3RhbmNlSWQ7XG5cdFx0XHRcdGludGVyc2VjdC5vYmplY3QgPSB0aGlzO1xuXHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goaW50ZXJzZWN0KTtcblx0XHRcdH1cblx0XHRcdF9pbnN0YW5jZUludGVyc2VjdHMubGVuZ3RoID0gMDtcblx0XHR9XG5cdH1cblx0c2V0Q29sb3JBdChpbmRleCwgY29sb3IpIHtcblx0XHRpZiAodGhpcy5pbnN0YW5jZUNvbG9yID09PSBudWxsKSB7XG5cdFx0XHR0aGlzLmluc3RhbmNlQ29sb3IgPSBuZXcgSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlKG5ldyBGbG9hdDMyQXJyYXkodGhpcy5pbnN0YW5jZU1hdHJpeC5jb3VudCAqIDMpLCAzKTtcblx0XHR9XG5cdFx0Y29sb3IudG9BcnJheSh0aGlzLmluc3RhbmNlQ29sb3IuYXJyYXksIGluZGV4ICogMyk7XG5cdH1cblx0c2V0TWF0cml4QXQoaW5kZXgsIG1hdHJpeCkge1xuXHRcdG1hdHJpeC50b0FycmF5KHRoaXMuaW5zdGFuY2VNYXRyaXguYXJyYXksIGluZGV4ICogMTYpO1xuXHR9XG5cdHVwZGF0ZU1vcnBoVGFyZ2V0cygpIHt9XG5cdGRpc3Bvc2UoKSB7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KHtcblx0XHRcdHR5cGU6ICdkaXNwb3NlJ1xuXHRcdH0pO1xuXHR9XG59XG5cbmNsYXNzIExpbmVCYXNpY01hdGVyaWFsIGV4dGVuZHMgTWF0ZXJpYWwge1xuXHRjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLmlzTGluZUJhc2ljTWF0ZXJpYWwgPSB0cnVlO1xuXHRcdHRoaXMudHlwZSA9ICdMaW5lQmFzaWNNYXRlcmlhbCc7XG5cdFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvcigweGZmZmZmZik7XG5cdFx0dGhpcy5saW5ld2lkdGggPSAxO1xuXHRcdHRoaXMubGluZWNhcCA9ICdyb3VuZCc7XG5cdFx0dGhpcy5saW5lam9pbiA9ICdyb3VuZCc7XG5cdFx0dGhpcy5mb2cgPSB0cnVlO1xuXHRcdHRoaXMuc2V0VmFsdWVzKHBhcmFtZXRlcnMpO1xuXHR9XG5cdGNvcHkoc291cmNlKSB7XG5cdFx0c3VwZXIuY29weShzb3VyY2UpO1xuXHRcdHRoaXMuY29sb3IuY29weShzb3VyY2UuY29sb3IpO1xuXHRcdHRoaXMubGluZXdpZHRoID0gc291cmNlLmxpbmV3aWR0aDtcblx0XHR0aGlzLmxpbmVjYXAgPSBzb3VyY2UubGluZWNhcDtcblx0XHR0aGlzLmxpbmVqb2luID0gc291cmNlLmxpbmVqb2luO1xuXHRcdHRoaXMuZm9nID0gc291cmNlLmZvZztcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufVxuXG5jb25zdCBfc3RhcnQkMSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuY29uc3QgX2VuZCQxID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5jb25zdCBfaW52ZXJzZU1hdHJpeCQxID0gLypAX19QVVJFX18qL25ldyBNYXRyaXg0KCk7XG5jb25zdCBfcmF5JDEgPSAvKkBfX1BVUkVfXyovbmV3IFJheSgpO1xuY29uc3QgX3NwaGVyZSQxID0gLypAX19QVVJFX18qL25ldyBTcGhlcmUoKTtcbmNsYXNzIExpbmUgZXh0ZW5kcyBPYmplY3QzRCB7XG5cdGNvbnN0cnVjdG9yKGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCksIG1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKCkpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuaXNMaW5lID0gdHJ1ZTtcblx0XHR0aGlzLnR5cGUgPSAnTGluZSc7XG5cdFx0dGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5O1xuXHRcdHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbDtcblx0XHR0aGlzLnVwZGF0ZU1vcnBoVGFyZ2V0cygpO1xuXHR9XG5cdGNvcHkoc291cmNlLCByZWN1cnNpdmUpIHtcblx0XHRzdXBlci5jb3B5KHNvdXJjZSwgcmVjdXJzaXZlKTtcblx0XHR0aGlzLm1hdGVyaWFsID0gc291cmNlLm1hdGVyaWFsO1xuXHRcdHRoaXMuZ2VvbWV0cnkgPSBzb3VyY2UuZ2VvbWV0cnk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0Y29tcHV0ZUxpbmVEaXN0YW5jZXMoKSB7XG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXG5cdFx0Ly8gd2UgYXNzdW1lIG5vbi1pbmRleGVkIGdlb21ldHJ5XG5cblx0XHRpZiAoZ2VvbWV0cnkuaW5kZXggPT09IG51bGwpIHtcblx0XHRcdGNvbnN0IHBvc2l0aW9uQXR0cmlidXRlID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRcdGNvbnN0IGxpbmVEaXN0YW5jZXMgPSBbMF07XG5cdFx0XHRmb3IgKGxldCBpID0gMSwgbCA9IHBvc2l0aW9uQXR0cmlidXRlLmNvdW50OyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdF9zdGFydCQxLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25BdHRyaWJ1dGUsIGkgLSAxKTtcblx0XHRcdFx0X2VuZCQxLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25BdHRyaWJ1dGUsIGkpO1xuXHRcdFx0XHRsaW5lRGlzdGFuY2VzW2ldID0gbGluZURpc3RhbmNlc1tpIC0gMV07XG5cdFx0XHRcdGxpbmVEaXN0YW5jZXNbaV0gKz0gX3N0YXJ0JDEuZGlzdGFuY2VUbyhfZW5kJDEpO1xuXHRcdFx0fVxuXHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCdsaW5lRGlzdGFuY2UnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShsaW5lRGlzdGFuY2VzLCAxKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuTGluZS5jb21wdXRlTGluZURpc3RhbmNlcygpOiBDb21wdXRhdGlvbiBvbmx5IHBvc3NpYmxlIHdpdGggbm9uLWluZGV4ZWQgQnVmZmVyR2VvbWV0cnkuJyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHJheWNhc3QocmF5Y2FzdGVyLCBpbnRlcnNlY3RzKSB7XG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXHRcdGNvbnN0IG1hdHJpeFdvcmxkID0gdGhpcy5tYXRyaXhXb3JsZDtcblx0XHRjb25zdCB0aHJlc2hvbGQgPSByYXljYXN0ZXIucGFyYW1zLkxpbmUudGhyZXNob2xkO1xuXHRcdGNvbnN0IGRyYXdSYW5nZSA9IGdlb21ldHJ5LmRyYXdSYW5nZTtcblxuXHRcdC8vIENoZWNraW5nIGJvdW5kaW5nU3BoZXJlIGRpc3RhbmNlIHRvIHJheVxuXG5cdFx0aWYgKGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsKSBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblx0XHRfc3BoZXJlJDEuY29weShnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSk7XG5cdFx0X3NwaGVyZSQxLmFwcGx5TWF0cml4NChtYXRyaXhXb3JsZCk7XG5cdFx0X3NwaGVyZSQxLnJhZGl1cyArPSB0aHJlc2hvbGQ7XG5cdFx0aWYgKHJheWNhc3Rlci5yYXkuaW50ZXJzZWN0c1NwaGVyZShfc3BoZXJlJDEpID09PSBmYWxzZSkgcmV0dXJuO1xuXG5cdFx0Ly9cblxuXHRcdF9pbnZlcnNlTWF0cml4JDEuY29weShtYXRyaXhXb3JsZCkuaW52ZXJ0KCk7XG5cdFx0X3JheSQxLmNvcHkocmF5Y2FzdGVyLnJheSkuYXBwbHlNYXRyaXg0KF9pbnZlcnNlTWF0cml4JDEpO1xuXHRcdGNvbnN0IGxvY2FsVGhyZXNob2xkID0gdGhyZXNob2xkIC8gKCh0aGlzLnNjYWxlLnggKyB0aGlzLnNjYWxlLnkgKyB0aGlzLnNjYWxlLnopIC8gMyk7XG5cdFx0Y29uc3QgbG9jYWxUaHJlc2hvbGRTcSA9IGxvY2FsVGhyZXNob2xkICogbG9jYWxUaHJlc2hvbGQ7XG5cdFx0Y29uc3QgdlN0YXJ0ID0gbmV3IFZlY3RvcjMoKTtcblx0XHRjb25zdCB2RW5kID0gbmV3IFZlY3RvcjMoKTtcblx0XHRjb25zdCBpbnRlclNlZ21lbnQgPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IGludGVyUmF5ID0gbmV3IFZlY3RvcjMoKTtcblx0XHRjb25zdCBzdGVwID0gdGhpcy5pc0xpbmVTZWdtZW50cyA/IDIgOiAxO1xuXHRcdGNvbnN0IGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG5cdFx0Y29uc3QgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG5cdFx0Y29uc3QgcG9zaXRpb25BdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdGlmIChpbmRleCAhPT0gbnVsbCkge1xuXHRcdFx0Y29uc3Qgc3RhcnQgPSBNYXRoLm1heCgwLCBkcmF3UmFuZ2Uuc3RhcnQpO1xuXHRcdFx0Y29uc3QgZW5kID0gTWF0aC5taW4oaW5kZXguY291bnQsIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCk7XG5cdFx0XHRmb3IgKGxldCBpID0gc3RhcnQsIGwgPSBlbmQgLSAxOyBpIDwgbDsgaSArPSBzdGVwKSB7XG5cdFx0XHRcdGNvbnN0IGEgPSBpbmRleC5nZXRYKGkpO1xuXHRcdFx0XHRjb25zdCBiID0gaW5kZXguZ2V0WChpICsgMSk7XG5cdFx0XHRcdHZTdGFydC5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uQXR0cmlidXRlLCBhKTtcblx0XHRcdFx0dkVuZC5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uQXR0cmlidXRlLCBiKTtcblx0XHRcdFx0Y29uc3QgZGlzdFNxID0gX3JheSQxLmRpc3RhbmNlU3FUb1NlZ21lbnQodlN0YXJ0LCB2RW5kLCBpbnRlclJheSwgaW50ZXJTZWdtZW50KTtcblx0XHRcdFx0aWYgKGRpc3RTcSA+IGxvY2FsVGhyZXNob2xkU3EpIGNvbnRpbnVlO1xuXHRcdFx0XHRpbnRlclJheS5hcHBseU1hdHJpeDQodGhpcy5tYXRyaXhXb3JsZCk7IC8vTW92ZSBiYWNrIHRvIHdvcmxkIHNwYWNlIGZvciBkaXN0YW5jZSBjYWxjdWxhdGlvblxuXG5cdFx0XHRcdGNvbnN0IGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyhpbnRlclJheSk7XG5cdFx0XHRcdGlmIChkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhcikgY29udGludWU7XG5cdFx0XHRcdGludGVyc2VjdHMucHVzaCh7XG5cdFx0XHRcdFx0ZGlzdGFuY2U6IGRpc3RhbmNlLFxuXHRcdFx0XHRcdC8vIFdoYXQgZG8gd2Ugd2FudD8gaW50ZXJzZWN0aW9uIHBvaW50IG9uIHRoZSByYXkgb3Igb24gdGhlIHNlZ21lbnQ/P1xuXHRcdFx0XHRcdC8vIHBvaW50OiByYXljYXN0ZXIucmF5LmF0KCBkaXN0YW5jZSApLFxuXHRcdFx0XHRcdHBvaW50OiBpbnRlclNlZ21lbnQuY2xvbmUoKS5hcHBseU1hdHJpeDQodGhpcy5tYXRyaXhXb3JsZCksXG5cdFx0XHRcdFx0aW5kZXg6IGksXG5cdFx0XHRcdFx0ZmFjZTogbnVsbCxcblx0XHRcdFx0XHRmYWNlSW5kZXg6IG51bGwsXG5cdFx0XHRcdFx0b2JqZWN0OiB0aGlzXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCBzdGFydCA9IE1hdGgubWF4KDAsIGRyYXdSYW5nZS5zdGFydCk7XG5cdFx0XHRjb25zdCBlbmQgPSBNYXRoLm1pbihwb3NpdGlvbkF0dHJpYnV0ZS5jb3VudCwgZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50KTtcblx0XHRcdGZvciAobGV0IGkgPSBzdGFydCwgbCA9IGVuZCAtIDE7IGkgPCBsOyBpICs9IHN0ZXApIHtcblx0XHRcdFx0dlN0YXJ0LmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25BdHRyaWJ1dGUsIGkpO1xuXHRcdFx0XHR2RW5kLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25BdHRyaWJ1dGUsIGkgKyAxKTtcblx0XHRcdFx0Y29uc3QgZGlzdFNxID0gX3JheSQxLmRpc3RhbmNlU3FUb1NlZ21lbnQodlN0YXJ0LCB2RW5kLCBpbnRlclJheSwgaW50ZXJTZWdtZW50KTtcblx0XHRcdFx0aWYgKGRpc3RTcSA+IGxvY2FsVGhyZXNob2xkU3EpIGNvbnRpbnVlO1xuXHRcdFx0XHRpbnRlclJheS5hcHBseU1hdHJpeDQodGhpcy5tYXRyaXhXb3JsZCk7IC8vTW92ZSBiYWNrIHRvIHdvcmxkIHNwYWNlIGZvciBkaXN0YW5jZSBjYWxjdWxhdGlvblxuXG5cdFx0XHRcdGNvbnN0IGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyhpbnRlclJheSk7XG5cdFx0XHRcdGlmIChkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhcikgY29udGludWU7XG5cdFx0XHRcdGludGVyc2VjdHMucHVzaCh7XG5cdFx0XHRcdFx0ZGlzdGFuY2U6IGRpc3RhbmNlLFxuXHRcdFx0XHRcdC8vIFdoYXQgZG8gd2Ugd2FudD8gaW50ZXJzZWN0aW9uIHBvaW50IG9uIHRoZSByYXkgb3Igb24gdGhlIHNlZ21lbnQ/P1xuXHRcdFx0XHRcdC8vIHBvaW50OiByYXljYXN0ZXIucmF5LmF0KCBkaXN0YW5jZSApLFxuXHRcdFx0XHRcdHBvaW50OiBpbnRlclNlZ21lbnQuY2xvbmUoKS5hcHBseU1hdHJpeDQodGhpcy5tYXRyaXhXb3JsZCksXG5cdFx0XHRcdFx0aW5kZXg6IGksXG5cdFx0XHRcdFx0ZmFjZTogbnVsbCxcblx0XHRcdFx0XHRmYWNlSW5kZXg6IG51bGwsXG5cdFx0XHRcdFx0b2JqZWN0OiB0aGlzXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHR1cGRhdGVNb3JwaFRhcmdldHMoKSB7XG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlcyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcztcblx0XHRjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobW9ycGhBdHRyaWJ1dGVzKTtcblx0XHRpZiAoa2V5cy5sZW5ndGggPiAwKSB7XG5cdFx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZSA9IG1vcnBoQXR0cmlidXRlc1trZXlzWzBdXTtcblx0XHRcdGlmIChtb3JwaEF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzID0gW107XG5cdFx0XHRcdHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5ID0ge307XG5cdFx0XHRcdGZvciAobGV0IG0gPSAwLCBtbCA9IG1vcnBoQXR0cmlidXRlLmxlbmd0aDsgbSA8IG1sOyBtKyspIHtcblx0XHRcdFx0XHRjb25zdCBuYW1lID0gbW9ycGhBdHRyaWJ1dGVbbV0ubmFtZSB8fCBTdHJpbmcobSk7XG5cdFx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMucHVzaCgwKTtcblx0XHRcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVtuYW1lXSA9IG07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuY29uc3QgX3N0YXJ0ID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5jb25zdCBfZW5kID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5jbGFzcyBMaW5lU2VnbWVudHMgZXh0ZW5kcyBMaW5lIHtcblx0Y29uc3RydWN0b3IoZ2VvbWV0cnksIG1hdGVyaWFsKSB7XG5cdFx0c3VwZXIoZ2VvbWV0cnksIG1hdGVyaWFsKTtcblx0XHR0aGlzLmlzTGluZVNlZ21lbnRzID0gdHJ1ZTtcblx0XHR0aGlzLnR5cGUgPSAnTGluZVNlZ21lbnRzJztcblx0fVxuXHRjb21wdXRlTGluZURpc3RhbmNlcygpIHtcblx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cblx0XHQvLyB3ZSBhc3N1bWUgbm9uLWluZGV4ZWQgZ2VvbWV0cnlcblxuXHRcdGlmIChnZW9tZXRyeS5pbmRleCA9PT0gbnVsbCkge1xuXHRcdFx0Y29uc3QgcG9zaXRpb25BdHRyaWJ1dGUgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdFx0Y29uc3QgbGluZURpc3RhbmNlcyA9IFtdO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBwb3NpdGlvbkF0dHJpYnV0ZS5jb3VudDsgaSA8IGw7IGkgKz0gMikge1xuXHRcdFx0XHRfc3RhcnQuZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbkF0dHJpYnV0ZSwgaSk7XG5cdFx0XHRcdF9lbmQuZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbkF0dHJpYnV0ZSwgaSArIDEpO1xuXHRcdFx0XHRsaW5lRGlzdGFuY2VzW2ldID0gaSA9PT0gMCA/IDAgOiBsaW5lRGlzdGFuY2VzW2kgLSAxXTtcblx0XHRcdFx0bGluZURpc3RhbmNlc1tpICsgMV0gPSBsaW5lRGlzdGFuY2VzW2ldICsgX3N0YXJ0LmRpc3RhbmNlVG8oX2VuZCk7XG5cdFx0XHR9XG5cdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2xpbmVEaXN0YW5jZScsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKGxpbmVEaXN0YW5jZXMsIDEpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5MaW5lU2VnbWVudHMuY29tcHV0ZUxpbmVEaXN0YW5jZXMoKTogQ29tcHV0YXRpb24gb25seSBwb3NzaWJsZSB3aXRoIG5vbi1pbmRleGVkIEJ1ZmZlckdlb21ldHJ5LicpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufVxuXG5jbGFzcyBMaW5lTG9vcCBleHRlbmRzIExpbmUge1xuXHRjb25zdHJ1Y3RvcihnZW9tZXRyeSwgbWF0ZXJpYWwpIHtcblx0XHRzdXBlcihnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuXHRcdHRoaXMuaXNMaW5lTG9vcCA9IHRydWU7XG5cdFx0dGhpcy50eXBlID0gJ0xpbmVMb29wJztcblx0fVxufVxuXG5jbGFzcyBQb2ludHNNYXRlcmlhbCBleHRlbmRzIE1hdGVyaWFsIHtcblx0Y29uc3RydWN0b3IocGFyYW1ldGVycykge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5pc1BvaW50c01hdGVyaWFsID0gdHJ1ZTtcblx0XHR0aGlzLnR5cGUgPSAnUG9pbnRzTWF0ZXJpYWwnO1xuXHRcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoMHhmZmZmZmYpO1xuXHRcdHRoaXMubWFwID0gbnVsbDtcblx0XHR0aGlzLmFscGhhTWFwID0gbnVsbDtcblx0XHR0aGlzLnNpemUgPSAxO1xuXHRcdHRoaXMuc2l6ZUF0dGVudWF0aW9uID0gdHJ1ZTtcblx0XHR0aGlzLmZvZyA9IHRydWU7XG5cdFx0dGhpcy5zZXRWYWx1ZXMocGFyYW1ldGVycyk7XG5cdH1cblx0Y29weShzb3VyY2UpIHtcblx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0dGhpcy5jb2xvci5jb3B5KHNvdXJjZS5jb2xvcik7XG5cdFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXHRcdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XG5cdFx0dGhpcy5zaXplID0gc291cmNlLnNpemU7XG5cdFx0dGhpcy5zaXplQXR0ZW51YXRpb24gPSBzb3VyY2Uuc2l6ZUF0dGVudWF0aW9uO1xuXHRcdHRoaXMuZm9nID0gc291cmNlLmZvZztcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufVxuXG5jb25zdCBfaW52ZXJzZU1hdHJpeCA9IC8qQF9fUFVSRV9fKi9uZXcgTWF0cml4NCgpO1xuY29uc3QgX3JheSA9IC8qQF9fUFVSRV9fKi9uZXcgUmF5KCk7XG5jb25zdCBfc3BoZXJlID0gLypAX19QVVJFX18qL25ldyBTcGhlcmUoKTtcbmNvbnN0IF9wb3NpdGlvbiQyID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5jbGFzcyBQb2ludHMgZXh0ZW5kcyBPYmplY3QzRCB7XG5cdGNvbnN0cnVjdG9yKGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCksIG1hdGVyaWFsID0gbmV3IFBvaW50c01hdGVyaWFsKCkpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuaXNQb2ludHMgPSB0cnVlO1xuXHRcdHRoaXMudHlwZSA9ICdQb2ludHMnO1xuXHRcdHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcblx0XHR0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWw7XG5cdFx0dGhpcy51cGRhdGVNb3JwaFRhcmdldHMoKTtcblx0fVxuXHRjb3B5KHNvdXJjZSwgcmVjdXJzaXZlKSB7XG5cdFx0c3VwZXIuY29weShzb3VyY2UsIHJlY3Vyc2l2ZSk7XG5cdFx0dGhpcy5tYXRlcmlhbCA9IHNvdXJjZS5tYXRlcmlhbDtcblx0XHR0aGlzLmdlb21ldHJ5ID0gc291cmNlLmdlb21ldHJ5O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHJheWNhc3QocmF5Y2FzdGVyLCBpbnRlcnNlY3RzKSB7XG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXHRcdGNvbnN0IG1hdHJpeFdvcmxkID0gdGhpcy5tYXRyaXhXb3JsZDtcblx0XHRjb25zdCB0aHJlc2hvbGQgPSByYXljYXN0ZXIucGFyYW1zLlBvaW50cy50aHJlc2hvbGQ7XG5cdFx0Y29uc3QgZHJhd1JhbmdlID0gZ2VvbWV0cnkuZHJhd1JhbmdlO1xuXG5cdFx0Ly8gQ2hlY2tpbmcgYm91bmRpbmdTcGhlcmUgZGlzdGFuY2UgdG8gcmF5XG5cblx0XHRpZiAoZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwpIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXHRcdF9zcGhlcmUuY29weShnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSk7XG5cdFx0X3NwaGVyZS5hcHBseU1hdHJpeDQobWF0cml4V29ybGQpO1xuXHRcdF9zcGhlcmUucmFkaXVzICs9IHRocmVzaG9sZDtcblx0XHRpZiAocmF5Y2FzdGVyLnJheS5pbnRlcnNlY3RzU3BoZXJlKF9zcGhlcmUpID09PSBmYWxzZSkgcmV0dXJuO1xuXG5cdFx0Ly9cblxuXHRcdF9pbnZlcnNlTWF0cml4LmNvcHkobWF0cml4V29ybGQpLmludmVydCgpO1xuXHRcdF9yYXkuY29weShyYXljYXN0ZXIucmF5KS5hcHBseU1hdHJpeDQoX2ludmVyc2VNYXRyaXgpO1xuXHRcdGNvbnN0IGxvY2FsVGhyZXNob2xkID0gdGhyZXNob2xkIC8gKCh0aGlzLnNjYWxlLnggKyB0aGlzLnNjYWxlLnkgKyB0aGlzLnNjYWxlLnopIC8gMyk7XG5cdFx0Y29uc3QgbG9jYWxUaHJlc2hvbGRTcSA9IGxvY2FsVGhyZXNob2xkICogbG9jYWxUaHJlc2hvbGQ7XG5cdFx0Y29uc3QgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcblx0XHRjb25zdCBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcblx0XHRjb25zdCBwb3NpdGlvbkF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0aWYgKGluZGV4ICE9PSBudWxsKSB7XG5cdFx0XHRjb25zdCBzdGFydCA9IE1hdGgubWF4KDAsIGRyYXdSYW5nZS5zdGFydCk7XG5cdFx0XHRjb25zdCBlbmQgPSBNYXRoLm1pbihpbmRleC5jb3VudCwgZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50KTtcblx0XHRcdGZvciAobGV0IGkgPSBzdGFydCwgaWwgPSBlbmQ7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGEgPSBpbmRleC5nZXRYKGkpO1xuXHRcdFx0XHRfcG9zaXRpb24kMi5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uQXR0cmlidXRlLCBhKTtcblx0XHRcdFx0dGVzdFBvaW50KF9wb3NpdGlvbiQyLCBhLCBsb2NhbFRocmVzaG9sZFNxLCBtYXRyaXhXb3JsZCwgcmF5Y2FzdGVyLCBpbnRlcnNlY3RzLCB0aGlzKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3Qgc3RhcnQgPSBNYXRoLm1heCgwLCBkcmF3UmFuZ2Uuc3RhcnQpO1xuXHRcdFx0Y29uc3QgZW5kID0gTWF0aC5taW4ocG9zaXRpb25BdHRyaWJ1dGUuY291bnQsIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCk7XG5cdFx0XHRmb3IgKGxldCBpID0gc3RhcnQsIGwgPSBlbmQ7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0X3Bvc2l0aW9uJDIuZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbkF0dHJpYnV0ZSwgaSk7XG5cdFx0XHRcdHRlc3RQb2ludChfcG9zaXRpb24kMiwgaSwgbG9jYWxUaHJlc2hvbGRTcSwgbWF0cml4V29ybGQsIHJheWNhc3RlciwgaW50ZXJzZWN0cywgdGhpcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHVwZGF0ZU1vcnBoVGFyZ2V0cygpIHtcblx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGVzID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzO1xuXHRcdGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhtb3JwaEF0dHJpYnV0ZXMpO1xuXHRcdGlmIChrZXlzLmxlbmd0aCA+IDApIHtcblx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVzW2tleXNbMF1dO1xuXHRcdFx0aWYgKG1vcnBoQXR0cmlidXRlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMgPSBbXTtcblx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnkgPSB7fTtcblx0XHRcdFx0Zm9yIChsZXQgbSA9IDAsIG1sID0gbW9ycGhBdHRyaWJ1dGUubGVuZ3RoOyBtIDwgbWw7IG0rKykge1xuXHRcdFx0XHRcdGNvbnN0IG5hbWUgPSBtb3JwaEF0dHJpYnV0ZVttXS5uYW1lIHx8IFN0cmluZyhtKTtcblx0XHRcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5wdXNoKDApO1xuXHRcdFx0XHRcdHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5W25hbWVdID0gbTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuZnVuY3Rpb24gdGVzdFBvaW50KHBvaW50LCBpbmRleCwgbG9jYWxUaHJlc2hvbGRTcSwgbWF0cml4V29ybGQsIHJheWNhc3RlciwgaW50ZXJzZWN0cywgb2JqZWN0KSB7XG5cdGNvbnN0IHJheVBvaW50RGlzdGFuY2VTcSA9IF9yYXkuZGlzdGFuY2VTcVRvUG9pbnQocG9pbnQpO1xuXHRpZiAocmF5UG9pbnREaXN0YW5jZVNxIDwgbG9jYWxUaHJlc2hvbGRTcSkge1xuXHRcdGNvbnN0IGludGVyc2VjdFBvaW50ID0gbmV3IFZlY3RvcjMoKTtcblx0XHRfcmF5LmNsb3Nlc3RQb2ludFRvUG9pbnQocG9pbnQsIGludGVyc2VjdFBvaW50KTtcblx0XHRpbnRlcnNlY3RQb2ludC5hcHBseU1hdHJpeDQobWF0cml4V29ybGQpO1xuXHRcdGNvbnN0IGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyhpbnRlcnNlY3RQb2ludCk7XG5cdFx0aWYgKGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyKSByZXR1cm47XG5cdFx0aW50ZXJzZWN0cy5wdXNoKHtcblx0XHRcdGRpc3RhbmNlOiBkaXN0YW5jZSxcblx0XHRcdGRpc3RhbmNlVG9SYXk6IE1hdGguc3FydChyYXlQb2ludERpc3RhbmNlU3EpLFxuXHRcdFx0cG9pbnQ6IGludGVyc2VjdFBvaW50LFxuXHRcdFx0aW5kZXg6IGluZGV4LFxuXHRcdFx0ZmFjZTogbnVsbCxcblx0XHRcdG9iamVjdDogb2JqZWN0XG5cdFx0fSk7XG5cdH1cbn1cblxuY2xhc3MgVmlkZW9UZXh0dXJlIGV4dGVuZHMgVGV4dHVyZSB7XG5cdGNvbnN0cnVjdG9yKHZpZGVvLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkpIHtcblx0XHRzdXBlcih2aWRlbywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5KTtcblx0XHR0aGlzLmlzVmlkZW9UZXh0dXJlID0gdHJ1ZTtcblx0XHR0aGlzLm1pbkZpbHRlciA9IG1pbkZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWluRmlsdGVyIDogTGluZWFyRmlsdGVyO1xuXHRcdHRoaXMubWFnRmlsdGVyID0gbWFnRmlsdGVyICE9PSB1bmRlZmluZWQgPyBtYWdGaWx0ZXIgOiBMaW5lYXJGaWx0ZXI7XG5cdFx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cdFx0ZnVuY3Rpb24gdXBkYXRlVmlkZW8oKSB7XG5cdFx0XHRzY29wZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHR2aWRlby5yZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrKHVwZGF0ZVZpZGVvKTtcblx0XHR9XG5cdFx0aWYgKCdyZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrJyBpbiB2aWRlbykge1xuXHRcdFx0dmlkZW8ucmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjayh1cGRhdGVWaWRlbyk7XG5cdFx0fVxuXHR9XG5cdGNsb25lKCkge1xuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLmltYWdlKS5jb3B5KHRoaXMpO1xuXHR9XG5cdHVwZGF0ZSgpIHtcblx0XHRjb25zdCB2aWRlbyA9IHRoaXMuaW1hZ2U7XG5cdFx0Y29uc3QgaGFzVmlkZW9GcmFtZUNhbGxiYWNrID0gKCdyZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrJyBpbiB2aWRlbyk7XG5cdFx0aWYgKGhhc1ZpZGVvRnJhbWVDYWxsYmFjayA9PT0gZmFsc2UgJiYgdmlkZW8ucmVhZHlTdGF0ZSA+PSB2aWRlby5IQVZFX0NVUlJFTlRfREFUQSkge1xuXHRcdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0fVxuXHR9XG59XG5cbmNsYXNzIEZyYW1lYnVmZmVyVGV4dHVyZSBleHRlbmRzIFRleHR1cmUge1xuXHRjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0LCBmb3JtYXQpIHtcblx0XHRzdXBlcih7XG5cdFx0XHR3aWR0aCxcblx0XHRcdGhlaWdodFxuXHRcdH0pO1xuXHRcdHRoaXMuaXNGcmFtZWJ1ZmZlclRleHR1cmUgPSB0cnVlO1xuXHRcdHRoaXMuZm9ybWF0ID0gZm9ybWF0O1xuXHRcdHRoaXMubWFnRmlsdGVyID0gTmVhcmVzdEZpbHRlcjtcblx0XHR0aGlzLm1pbkZpbHRlciA9IE5lYXJlc3RGaWx0ZXI7XG5cdFx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblx0XHR0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0fVxufVxuXG5jbGFzcyBDb21wcmVzc2VkVGV4dHVyZSBleHRlbmRzIFRleHR1cmUge1xuXHRjb25zdHJ1Y3RvcihtaXBtYXBzLCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGFuaXNvdHJvcHksIGVuY29kaW5nKSB7XG5cdFx0c3VwZXIobnVsbCwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5LCBlbmNvZGluZyk7XG5cdFx0dGhpcy5pc0NvbXByZXNzZWRUZXh0dXJlID0gdHJ1ZTtcblx0XHR0aGlzLmltYWdlID0ge1xuXHRcdFx0d2lkdGg6IHdpZHRoLFxuXHRcdFx0aGVpZ2h0OiBoZWlnaHRcblx0XHR9O1xuXHRcdHRoaXMubWlwbWFwcyA9IG1pcG1hcHM7XG5cblx0XHQvLyBubyBmbGlwcGluZyBmb3IgY3ViZSB0ZXh0dXJlc1xuXHRcdC8vIChhbHNvIGZsaXBwaW5nIGRvZXNuJ3Qgd29yayBmb3IgY29tcHJlc3NlZCB0ZXh0dXJlcyApXG5cblx0XHR0aGlzLmZsaXBZID0gZmFsc2U7XG5cblx0XHQvLyBjYW4ndCBnZW5lcmF0ZSBtaXBtYXBzIGZvciBjb21wcmVzc2VkIHRleHR1cmVzXG5cdFx0Ly8gbWlwcyBtdXN0IGJlIGVtYmVkZGVkIGluIEREUyBmaWxlc1xuXG5cdFx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblx0fVxufVxuXG5jbGFzcyBDb21wcmVzc2VkQXJyYXlUZXh0dXJlIGV4dGVuZHMgQ29tcHJlc3NlZFRleHR1cmUge1xuXHRjb25zdHJ1Y3RvcihtaXBtYXBzLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgZm9ybWF0LCB0eXBlKSB7XG5cdFx0c3VwZXIobWlwbWFwcywgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlKTtcblx0XHR0aGlzLmlzQ29tcHJlc3NlZEFycmF5VGV4dHVyZSA9IHRydWU7XG5cdFx0dGhpcy5pbWFnZS5kZXB0aCA9IGRlcHRoO1xuXHRcdHRoaXMud3JhcFIgPSBDbGFtcFRvRWRnZVdyYXBwaW5nO1xuXHR9XG59XG5cbmNsYXNzIENhbnZhc1RleHR1cmUgZXh0ZW5kcyBUZXh0dXJlIHtcblx0Y29uc3RydWN0b3IoY2FudmFzLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkpIHtcblx0XHRzdXBlcihjYW52YXMsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSk7XG5cdFx0dGhpcy5pc0NhbnZhc1RleHR1cmUgPSB0cnVlO1xuXHRcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHR9XG59XG5cbi8qKlxuICogRXh0ZW5zaWJsZSBjdXJ2ZSBvYmplY3QuXG4gKlxuICogU29tZSBjb21tb24gb2YgY3VydmUgbWV0aG9kczpcbiAqIC5nZXRQb2ludCggdCwgb3B0aW9uYWxUYXJnZXQgKSwgLmdldFRhbmdlbnQoIHQsIG9wdGlvbmFsVGFyZ2V0IClcbiAqIC5nZXRQb2ludEF0KCB1LCBvcHRpb25hbFRhcmdldCApLCAuZ2V0VGFuZ2VudEF0KCB1LCBvcHRpb25hbFRhcmdldCApXG4gKiAuZ2V0UG9pbnRzKCksIC5nZXRTcGFjZWRQb2ludHMoKVxuICogLmdldExlbmd0aCgpXG4gKiAudXBkYXRlQXJjTGVuZ3RocygpXG4gKlxuICogVGhpcyBmb2xsb3dpbmcgY3VydmVzIGluaGVyaXQgZnJvbSBUSFJFRS5DdXJ2ZTpcbiAqXG4gKiAtLSAyRCBjdXJ2ZXMgLS1cbiAqIFRIUkVFLkFyY0N1cnZlXG4gKiBUSFJFRS5DdWJpY0JlemllckN1cnZlXG4gKiBUSFJFRS5FbGxpcHNlQ3VydmVcbiAqIFRIUkVFLkxpbmVDdXJ2ZVxuICogVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmVcbiAqIFRIUkVFLlNwbGluZUN1cnZlXG4gKlxuICogLS0gM0QgY3VydmVzIC0tXG4gKiBUSFJFRS5DYXRtdWxsUm9tQ3VydmUzXG4gKiBUSFJFRS5DdWJpY0JlemllckN1cnZlM1xuICogVEhSRUUuTGluZUN1cnZlM1xuICogVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUzXG4gKlxuICogQSBzZXJpZXMgb2YgY3VydmVzIGNhbiBiZSByZXByZXNlbnRlZCBhcyBhIFRIUkVFLkN1cnZlUGF0aC5cbiAqXG4gKiovXG5cbmNsYXNzIEN1cnZlIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0dGhpcy50eXBlID0gJ0N1cnZlJztcblx0XHR0aGlzLmFyY0xlbmd0aERpdmlzaW9ucyA9IDIwMDtcblx0fVxuXG5cdC8vIFZpcnR1YWwgYmFzZSBjbGFzcyBtZXRob2QgdG8gb3ZlcndyaXRlIGFuZCBpbXBsZW1lbnQgaW4gc3ViY2xhc3Nlc1xuXHQvL1x0LSB0IFswIC4uIDFdXG5cblx0Z2V0UG9pbnQoKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5DdXJ2ZTogLmdldFBvaW50KCkgbm90IGltcGxlbWVudGVkLicpO1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gR2V0IHBvaW50IGF0IHJlbGF0aXZlIHBvc2l0aW9uIGluIGN1cnZlIGFjY29yZGluZyB0byBhcmMgbGVuZ3RoXG5cdC8vIC0gdSBbMCAuLiAxXVxuXG5cdGdldFBvaW50QXQodSwgb3B0aW9uYWxUYXJnZXQpIHtcblx0XHRjb25zdCB0ID0gdGhpcy5nZXRVdG9UbWFwcGluZyh1KTtcblx0XHRyZXR1cm4gdGhpcy5nZXRQb2ludCh0LCBvcHRpb25hbFRhcmdldCk7XG5cdH1cblxuXHQvLyBHZXQgc2VxdWVuY2Ugb2YgcG9pbnRzIHVzaW5nIGdldFBvaW50KCB0IClcblxuXHRnZXRQb2ludHMoZGl2aXNpb25zID0gNSkge1xuXHRcdGNvbnN0IHBvaW50cyA9IFtdO1xuXHRcdGZvciAobGV0IGQgPSAwOyBkIDw9IGRpdmlzaW9uczsgZCsrKSB7XG5cdFx0XHRwb2ludHMucHVzaCh0aGlzLmdldFBvaW50KGQgLyBkaXZpc2lvbnMpKTtcblx0XHR9XG5cdFx0cmV0dXJuIHBvaW50cztcblx0fVxuXG5cdC8vIEdldCBzZXF1ZW5jZSBvZiBwb2ludHMgdXNpbmcgZ2V0UG9pbnRBdCggdSApXG5cblx0Z2V0U3BhY2VkUG9pbnRzKGRpdmlzaW9ucyA9IDUpIHtcblx0XHRjb25zdCBwb2ludHMgPSBbXTtcblx0XHRmb3IgKGxldCBkID0gMDsgZCA8PSBkaXZpc2lvbnM7IGQrKykge1xuXHRcdFx0cG9pbnRzLnB1c2godGhpcy5nZXRQb2ludEF0KGQgLyBkaXZpc2lvbnMpKTtcblx0XHR9XG5cdFx0cmV0dXJuIHBvaW50cztcblx0fVxuXG5cdC8vIEdldCB0b3RhbCBjdXJ2ZSBhcmMgbGVuZ3RoXG5cblx0Z2V0TGVuZ3RoKCkge1xuXHRcdGNvbnN0IGxlbmd0aHMgPSB0aGlzLmdldExlbmd0aHMoKTtcblx0XHRyZXR1cm4gbGVuZ3Roc1tsZW5ndGhzLmxlbmd0aCAtIDFdO1xuXHR9XG5cblx0Ly8gR2V0IGxpc3Qgb2YgY3VtdWxhdGl2ZSBzZWdtZW50IGxlbmd0aHNcblxuXHRnZXRMZW5ndGhzKGRpdmlzaW9ucyA9IHRoaXMuYXJjTGVuZ3RoRGl2aXNpb25zKSB7XG5cdFx0aWYgKHRoaXMuY2FjaGVBcmNMZW5ndGhzICYmIHRoaXMuY2FjaGVBcmNMZW5ndGhzLmxlbmd0aCA9PT0gZGl2aXNpb25zICsgMSAmJiAhdGhpcy5uZWVkc1VwZGF0ZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuY2FjaGVBcmNMZW5ndGhzO1xuXHRcdH1cblx0XHR0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cdFx0Y29uc3QgY2FjaGUgPSBbXTtcblx0XHRsZXQgY3VycmVudCxcblx0XHRcdGxhc3QgPSB0aGlzLmdldFBvaW50KDApO1xuXHRcdGxldCBzdW0gPSAwO1xuXHRcdGNhY2hlLnB1c2goMCk7XG5cdFx0Zm9yIChsZXQgcCA9IDE7IHAgPD0gZGl2aXNpb25zOyBwKyspIHtcblx0XHRcdGN1cnJlbnQgPSB0aGlzLmdldFBvaW50KHAgLyBkaXZpc2lvbnMpO1xuXHRcdFx0c3VtICs9IGN1cnJlbnQuZGlzdGFuY2VUbyhsYXN0KTtcblx0XHRcdGNhY2hlLnB1c2goc3VtKTtcblx0XHRcdGxhc3QgPSBjdXJyZW50O1xuXHRcdH1cblx0XHR0aGlzLmNhY2hlQXJjTGVuZ3RocyA9IGNhY2hlO1xuXHRcdHJldHVybiBjYWNoZTsgLy8geyBzdW1zOiBjYWNoZSwgc3VtOiBzdW0gfTsgU3VtIGlzIGluIHRoZSBsYXN0IGVsZW1lbnQuXG5cdH1cblxuXHR1cGRhdGVBcmNMZW5ndGhzKCkge1xuXHRcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdHRoaXMuZ2V0TGVuZ3RocygpO1xuXHR9XG5cblx0Ly8gR2l2ZW4gdSAoIDAgLi4gMSApLCBnZXQgYSB0IHRvIGZpbmQgcC4gVGhpcyBnaXZlcyB5b3UgcG9pbnRzIHdoaWNoIGFyZSBlcXVpZGlzdGFudFxuXG5cdGdldFV0b1RtYXBwaW5nKHUsIGRpc3RhbmNlKSB7XG5cdFx0Y29uc3QgYXJjTGVuZ3RocyA9IHRoaXMuZ2V0TGVuZ3RocygpO1xuXHRcdGxldCBpID0gMDtcblx0XHRjb25zdCBpbCA9IGFyY0xlbmd0aHMubGVuZ3RoO1xuXHRcdGxldCB0YXJnZXRBcmNMZW5ndGg7IC8vIFRoZSB0YXJnZXRlZCB1IGRpc3RhbmNlIHZhbHVlIHRvIGdldFxuXG5cdFx0aWYgKGRpc3RhbmNlKSB7XG5cdFx0XHR0YXJnZXRBcmNMZW5ndGggPSBkaXN0YW5jZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0QXJjTGVuZ3RoID0gdSAqIGFyY0xlbmd0aHNbaWwgLSAxXTtcblx0XHR9XG5cblx0XHQvLyBiaW5hcnkgc2VhcmNoIGZvciB0aGUgaW5kZXggd2l0aCBsYXJnZXN0IHZhbHVlIHNtYWxsZXIgdGhhbiB0YXJnZXQgdSBkaXN0YW5jZVxuXG5cdFx0bGV0IGxvdyA9IDAsXG5cdFx0XHRoaWdoID0gaWwgLSAxLFxuXHRcdFx0Y29tcGFyaXNvbjtcblx0XHR3aGlsZSAobG93IDw9IGhpZ2gpIHtcblx0XHRcdGkgPSBNYXRoLmZsb29yKGxvdyArIChoaWdoIC0gbG93KSAvIDIpOyAvLyBsZXNzIGxpa2VseSB0byBvdmVyZmxvdywgdGhvdWdoIHByb2JhYmx5IG5vdCBpc3N1ZSBoZXJlLCBKUyBkb2Vzbid0IHJlYWxseSBoYXZlIGludGVnZXJzLCBhbGwgbnVtYmVycyBhcmUgZmxvYXRzXG5cblx0XHRcdGNvbXBhcmlzb24gPSBhcmNMZW5ndGhzW2ldIC0gdGFyZ2V0QXJjTGVuZ3RoO1xuXHRcdFx0aWYgKGNvbXBhcmlzb24gPCAwKSB7XG5cdFx0XHRcdGxvdyA9IGkgKyAxO1xuXHRcdFx0fSBlbHNlIGlmIChjb21wYXJpc29uID4gMCkge1xuXHRcdFx0XHRoaWdoID0gaSAtIDE7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoaWdoID0gaTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Ly8gRE9ORVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGkgPSBoaWdoO1xuXHRcdGlmIChhcmNMZW5ndGhzW2ldID09PSB0YXJnZXRBcmNMZW5ndGgpIHtcblx0XHRcdHJldHVybiBpIC8gKGlsIC0gMSk7XG5cdFx0fVxuXG5cdFx0Ly8gd2UgY291bGQgZ2V0IGZpbmVyIGdyYWluIGF0IGxlbmd0aHMsIG9yIHVzZSBzaW1wbGUgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBwb2ludHNcblxuXHRcdGNvbnN0IGxlbmd0aEJlZm9yZSA9IGFyY0xlbmd0aHNbaV07XG5cdFx0Y29uc3QgbGVuZ3RoQWZ0ZXIgPSBhcmNMZW5ndGhzW2kgKyAxXTtcblx0XHRjb25zdCBzZWdtZW50TGVuZ3RoID0gbGVuZ3RoQWZ0ZXIgLSBsZW5ndGhCZWZvcmU7XG5cblx0XHQvLyBkZXRlcm1pbmUgd2hlcmUgd2UgYXJlIGJldHdlZW4gdGhlICdiZWZvcmUnIGFuZCAnYWZ0ZXInIHBvaW50c1xuXG5cdFx0Y29uc3Qgc2VnbWVudEZyYWN0aW9uID0gKHRhcmdldEFyY0xlbmd0aCAtIGxlbmd0aEJlZm9yZSkgLyBzZWdtZW50TGVuZ3RoO1xuXG5cdFx0Ly8gYWRkIHRoYXQgZnJhY3Rpb25hbCBhbW91bnQgdG8gdFxuXG5cdFx0Y29uc3QgdCA9IChpICsgc2VnbWVudEZyYWN0aW9uKSAvIChpbCAtIDEpO1xuXHRcdHJldHVybiB0O1xuXHR9XG5cblx0Ly8gUmV0dXJucyBhIHVuaXQgdmVjdG9yIHRhbmdlbnQgYXQgdFxuXHQvLyBJbiBjYXNlIGFueSBzdWIgY3VydmUgZG9lcyBub3QgaW1wbGVtZW50IGl0cyB0YW5nZW50IGRlcml2YXRpb24sXG5cdC8vIDIgcG9pbnRzIGEgc21hbGwgZGVsdGEgYXBhcnQgd2lsbCBiZSB1c2VkIHRvIGZpbmQgaXRzIGdyYWRpZW50XG5cdC8vIHdoaWNoIHNlZW1zIHRvIGdpdmUgYSByZWFzb25hYmxlIGFwcHJveGltYXRpb25cblxuXHRnZXRUYW5nZW50KHQsIG9wdGlvbmFsVGFyZ2V0KSB7XG5cdFx0Y29uc3QgZGVsdGEgPSAwLjAwMDE7XG5cdFx0bGV0IHQxID0gdCAtIGRlbHRhO1xuXHRcdGxldCB0MiA9IHQgKyBkZWx0YTtcblxuXHRcdC8vIENhcHBpbmcgaW4gY2FzZSBvZiBkYW5nZXJcblxuXHRcdGlmICh0MSA8IDApIHQxID0gMDtcblx0XHRpZiAodDIgPiAxKSB0MiA9IDE7XG5cdFx0Y29uc3QgcHQxID0gdGhpcy5nZXRQb2ludCh0MSk7XG5cdFx0Y29uc3QgcHQyID0gdGhpcy5nZXRQb2ludCh0Mik7XG5cdFx0Y29uc3QgdGFuZ2VudCA9IG9wdGlvbmFsVGFyZ2V0IHx8IChwdDEuaXNWZWN0b3IyID8gbmV3IFZlY3RvcjIoKSA6IG5ldyBWZWN0b3IzKCkpO1xuXHRcdHRhbmdlbnQuY29weShwdDIpLnN1YihwdDEpLm5vcm1hbGl6ZSgpO1xuXHRcdHJldHVybiB0YW5nZW50O1xuXHR9XG5cdGdldFRhbmdlbnRBdCh1LCBvcHRpb25hbFRhcmdldCkge1xuXHRcdGNvbnN0IHQgPSB0aGlzLmdldFV0b1RtYXBwaW5nKHUpO1xuXHRcdHJldHVybiB0aGlzLmdldFRhbmdlbnQodCwgb3B0aW9uYWxUYXJnZXQpO1xuXHR9XG5cdGNvbXB1dGVGcmVuZXRGcmFtZXMoc2VnbWVudHMsIGNsb3NlZCkge1xuXHRcdC8vIHNlZSBodHRwOi8vd3d3LmNzLmluZGlhbmEuZWR1L3B1Yi90ZWNocmVwb3J0cy9UUjQyNS5wZGZcblxuXHRcdGNvbnN0IG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgdGFuZ2VudHMgPSBbXTtcblx0XHRjb25zdCBub3JtYWxzID0gW107XG5cdFx0Y29uc3QgYmlub3JtYWxzID0gW107XG5cdFx0Y29uc3QgdmVjID0gbmV3IFZlY3RvcjMoKTtcblx0XHRjb25zdCBtYXQgPSBuZXcgTWF0cml4NCgpO1xuXG5cdFx0Ly8gY29tcHV0ZSB0aGUgdGFuZ2VudCB2ZWN0b3JzIGZvciBlYWNoIHNlZ21lbnQgb24gdGhlIGN1cnZlXG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8PSBzZWdtZW50czsgaSsrKSB7XG5cdFx0XHRjb25zdCB1ID0gaSAvIHNlZ21lbnRzO1xuXHRcdFx0dGFuZ2VudHNbaV0gPSB0aGlzLmdldFRhbmdlbnRBdCh1LCBuZXcgVmVjdG9yMygpKTtcblx0XHR9XG5cblx0XHQvLyBzZWxlY3QgYW4gaW5pdGlhbCBub3JtYWwgdmVjdG9yIHBlcnBlbmRpY3VsYXIgdG8gdGhlIGZpcnN0IHRhbmdlbnQgdmVjdG9yLFxuXHRcdC8vIGFuZCBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBtaW5pbXVtIHRhbmdlbnQgeHl6IGNvbXBvbmVudFxuXG5cdFx0bm9ybWFsc1swXSA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Ymlub3JtYWxzWzBdID0gbmV3IFZlY3RvcjMoKTtcblx0XHRsZXQgbWluID0gTnVtYmVyLk1BWF9WQUxVRTtcblx0XHRjb25zdCB0eCA9IE1hdGguYWJzKHRhbmdlbnRzWzBdLngpO1xuXHRcdGNvbnN0IHR5ID0gTWF0aC5hYnModGFuZ2VudHNbMF0ueSk7XG5cdFx0Y29uc3QgdHogPSBNYXRoLmFicyh0YW5nZW50c1swXS56KTtcblx0XHRpZiAodHggPD0gbWluKSB7XG5cdFx0XHRtaW4gPSB0eDtcblx0XHRcdG5vcm1hbC5zZXQoMSwgMCwgMCk7XG5cdFx0fVxuXHRcdGlmICh0eSA8PSBtaW4pIHtcblx0XHRcdG1pbiA9IHR5O1xuXHRcdFx0bm9ybWFsLnNldCgwLCAxLCAwKTtcblx0XHR9XG5cdFx0aWYgKHR6IDw9IG1pbikge1xuXHRcdFx0bm9ybWFsLnNldCgwLCAwLCAxKTtcblx0XHR9XG5cdFx0dmVjLmNyb3NzVmVjdG9ycyh0YW5nZW50c1swXSwgbm9ybWFsKS5ub3JtYWxpemUoKTtcblx0XHRub3JtYWxzWzBdLmNyb3NzVmVjdG9ycyh0YW5nZW50c1swXSwgdmVjKTtcblx0XHRiaW5vcm1hbHNbMF0uY3Jvc3NWZWN0b3JzKHRhbmdlbnRzWzBdLCBub3JtYWxzWzBdKTtcblxuXHRcdC8vIGNvbXB1dGUgdGhlIHNsb3dseS12YXJ5aW5nIG5vcm1hbCBhbmQgYmlub3JtYWwgdmVjdG9ycyBmb3IgZWFjaCBzZWdtZW50IG9uIHRoZSBjdXJ2ZVxuXG5cdFx0Zm9yIChsZXQgaSA9IDE7IGkgPD0gc2VnbWVudHM7IGkrKykge1xuXHRcdFx0bm9ybWFsc1tpXSA9IG5vcm1hbHNbaSAtIDFdLmNsb25lKCk7XG5cdFx0XHRiaW5vcm1hbHNbaV0gPSBiaW5vcm1hbHNbaSAtIDFdLmNsb25lKCk7XG5cdFx0XHR2ZWMuY3Jvc3NWZWN0b3JzKHRhbmdlbnRzW2kgLSAxXSwgdGFuZ2VudHNbaV0pO1xuXHRcdFx0aWYgKHZlYy5sZW5ndGgoKSA+IE51bWJlci5FUFNJTE9OKSB7XG5cdFx0XHRcdHZlYy5ub3JtYWxpemUoKTtcblx0XHRcdFx0Y29uc3QgdGhldGEgPSBNYXRoLmFjb3MoY2xhbXAodGFuZ2VudHNbaSAtIDFdLmRvdCh0YW5nZW50c1tpXSksIC0xLCAxKSk7IC8vIGNsYW1wIGZvciBmbG9hdGluZyBwdCBlcnJvcnNcblxuXHRcdFx0XHRub3JtYWxzW2ldLmFwcGx5TWF0cml4NChtYXQubWFrZVJvdGF0aW9uQXhpcyh2ZWMsIHRoZXRhKSk7XG5cdFx0XHR9XG5cdFx0XHRiaW5vcm1hbHNbaV0uY3Jvc3NWZWN0b3JzKHRhbmdlbnRzW2ldLCBub3JtYWxzW2ldKTtcblx0XHR9XG5cblx0XHQvLyBpZiB0aGUgY3VydmUgaXMgY2xvc2VkLCBwb3N0cHJvY2VzcyB0aGUgdmVjdG9ycyBzbyB0aGUgZmlyc3QgYW5kIGxhc3Qgbm9ybWFsIHZlY3RvcnMgYXJlIHRoZSBzYW1lXG5cblx0XHRpZiAoY2xvc2VkID09PSB0cnVlKSB7XG5cdFx0XHRsZXQgdGhldGEgPSBNYXRoLmFjb3MoY2xhbXAobm9ybWFsc1swXS5kb3Qobm9ybWFsc1tzZWdtZW50c10pLCAtMSwgMSkpO1xuXHRcdFx0dGhldGEgLz0gc2VnbWVudHM7XG5cdFx0XHRpZiAodGFuZ2VudHNbMF0uZG90KHZlYy5jcm9zc1ZlY3RvcnMobm9ybWFsc1swXSwgbm9ybWFsc1tzZWdtZW50c10pKSA+IDApIHtcblx0XHRcdFx0dGhldGEgPSAtdGhldGE7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKGxldCBpID0gMTsgaSA8PSBzZWdtZW50czsgaSsrKSB7XG5cdFx0XHRcdC8vIHR3aXN0IGEgbGl0dGxlLi4uXG5cdFx0XHRcdG5vcm1hbHNbaV0uYXBwbHlNYXRyaXg0KG1hdC5tYWtlUm90YXRpb25BeGlzKHRhbmdlbnRzW2ldLCB0aGV0YSAqIGkpKTtcblx0XHRcdFx0Ymlub3JtYWxzW2ldLmNyb3NzVmVjdG9ycyh0YW5nZW50c1tpXSwgbm9ybWFsc1tpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB7XG5cdFx0XHR0YW5nZW50czogdGFuZ2VudHMsXG5cdFx0XHRub3JtYWxzOiBub3JtYWxzLFxuXHRcdFx0Ymlub3JtYWxzOiBiaW5vcm1hbHNcblx0XHR9O1xuXHR9XG5cdGNsb25lKCkge1xuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyk7XG5cdH1cblx0Y29weShzb3VyY2UpIHtcblx0XHR0aGlzLmFyY0xlbmd0aERpdmlzaW9ucyA9IHNvdXJjZS5hcmNMZW5ndGhEaXZpc2lvbnM7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0dG9KU09OKCkge1xuXHRcdGNvbnN0IGRhdGEgPSB7XG5cdFx0XHRtZXRhZGF0YToge1xuXHRcdFx0XHR2ZXJzaW9uOiA0LjUsXG5cdFx0XHRcdHR5cGU6ICdDdXJ2ZScsXG5cdFx0XHRcdGdlbmVyYXRvcjogJ0N1cnZlLnRvSlNPTidcblx0XHRcdH1cblx0XHR9O1xuXHRcdGRhdGEuYXJjTGVuZ3RoRGl2aXNpb25zID0gdGhpcy5hcmNMZW5ndGhEaXZpc2lvbnM7XG5cdFx0ZGF0YS50eXBlID0gdGhpcy50eXBlO1xuXHRcdHJldHVybiBkYXRhO1xuXHR9XG5cdGZyb21KU09OKGpzb24pIHtcblx0XHR0aGlzLmFyY0xlbmd0aERpdmlzaW9ucyA9IGpzb24uYXJjTGVuZ3RoRGl2aXNpb25zO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59XG5cbmNsYXNzIEVsbGlwc2VDdXJ2ZSBleHRlbmRzIEN1cnZlIHtcblx0Y29uc3RydWN0b3IoYVggPSAwLCBhWSA9IDAsIHhSYWRpdXMgPSAxLCB5UmFkaXVzID0gMSwgYVN0YXJ0QW5nbGUgPSAwLCBhRW5kQW5nbGUgPSBNYXRoLlBJICogMiwgYUNsb2Nrd2lzZSA9IGZhbHNlLCBhUm90YXRpb24gPSAwKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLmlzRWxsaXBzZUN1cnZlID0gdHJ1ZTtcblx0XHR0aGlzLnR5cGUgPSAnRWxsaXBzZUN1cnZlJztcblx0XHR0aGlzLmFYID0gYVg7XG5cdFx0dGhpcy5hWSA9IGFZO1xuXHRcdHRoaXMueFJhZGl1cyA9IHhSYWRpdXM7XG5cdFx0dGhpcy55UmFkaXVzID0geVJhZGl1cztcblx0XHR0aGlzLmFTdGFydEFuZ2xlID0gYVN0YXJ0QW5nbGU7XG5cdFx0dGhpcy5hRW5kQW5nbGUgPSBhRW5kQW5nbGU7XG5cdFx0dGhpcy5hQ2xvY2t3aXNlID0gYUNsb2Nrd2lzZTtcblx0XHR0aGlzLmFSb3RhdGlvbiA9IGFSb3RhdGlvbjtcblx0fVxuXHRnZXRQb2ludCh0LCBvcHRpb25hbFRhcmdldCkge1xuXHRcdGNvbnN0IHBvaW50ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjIoKTtcblx0XHRjb25zdCB0d29QaSA9IE1hdGguUEkgKiAyO1xuXHRcdGxldCBkZWx0YUFuZ2xlID0gdGhpcy5hRW5kQW5nbGUgLSB0aGlzLmFTdGFydEFuZ2xlO1xuXHRcdGNvbnN0IHNhbWVQb2ludHMgPSBNYXRoLmFicyhkZWx0YUFuZ2xlKSA8IE51bWJlci5FUFNJTE9OO1xuXG5cdFx0Ly8gZW5zdXJlcyB0aGF0IGRlbHRhQW5nbGUgaXMgMCAuLiAyIFBJXG5cdFx0d2hpbGUgKGRlbHRhQW5nbGUgPCAwKSBkZWx0YUFuZ2xlICs9IHR3b1BpO1xuXHRcdHdoaWxlIChkZWx0YUFuZ2xlID4gdHdvUGkpIGRlbHRhQW5nbGUgLT0gdHdvUGk7XG5cdFx0aWYgKGRlbHRhQW5nbGUgPCBOdW1iZXIuRVBTSUxPTikge1xuXHRcdFx0aWYgKHNhbWVQb2ludHMpIHtcblx0XHRcdFx0ZGVsdGFBbmdsZSA9IDA7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWx0YUFuZ2xlID0gdHdvUGk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICh0aGlzLmFDbG9ja3dpc2UgPT09IHRydWUgJiYgIXNhbWVQb2ludHMpIHtcblx0XHRcdGlmIChkZWx0YUFuZ2xlID09PSB0d29QaSkge1xuXHRcdFx0XHRkZWx0YUFuZ2xlID0gLXR3b1BpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVsdGFBbmdsZSA9IGRlbHRhQW5nbGUgLSB0d29QaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Y29uc3QgYW5nbGUgPSB0aGlzLmFTdGFydEFuZ2xlICsgdCAqIGRlbHRhQW5nbGU7XG5cdFx0bGV0IHggPSB0aGlzLmFYICsgdGhpcy54UmFkaXVzICogTWF0aC5jb3MoYW5nbGUpO1xuXHRcdGxldCB5ID0gdGhpcy5hWSArIHRoaXMueVJhZGl1cyAqIE1hdGguc2luKGFuZ2xlKTtcblx0XHRpZiAodGhpcy5hUm90YXRpb24gIT09IDApIHtcblx0XHRcdGNvbnN0IGNvcyA9IE1hdGguY29zKHRoaXMuYVJvdGF0aW9uKTtcblx0XHRcdGNvbnN0IHNpbiA9IE1hdGguc2luKHRoaXMuYVJvdGF0aW9uKTtcblx0XHRcdGNvbnN0IHR4ID0geCAtIHRoaXMuYVg7XG5cdFx0XHRjb25zdCB0eSA9IHkgLSB0aGlzLmFZO1xuXG5cdFx0XHQvLyBSb3RhdGUgdGhlIHBvaW50IGFib3V0IHRoZSBjZW50ZXIgb2YgdGhlIGVsbGlwc2UuXG5cdFx0XHR4ID0gdHggKiBjb3MgLSB0eSAqIHNpbiArIHRoaXMuYVg7XG5cdFx0XHR5ID0gdHggKiBzaW4gKyB0eSAqIGNvcyArIHRoaXMuYVk7XG5cdFx0fVxuXHRcdHJldHVybiBwb2ludC5zZXQoeCwgeSk7XG5cdH1cblx0Y29weShzb3VyY2UpIHtcblx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0dGhpcy5hWCA9IHNvdXJjZS5hWDtcblx0XHR0aGlzLmFZID0gc291cmNlLmFZO1xuXHRcdHRoaXMueFJhZGl1cyA9IHNvdXJjZS54UmFkaXVzO1xuXHRcdHRoaXMueVJhZGl1cyA9IHNvdXJjZS55UmFkaXVzO1xuXHRcdHRoaXMuYVN0YXJ0QW5nbGUgPSBzb3VyY2UuYVN0YXJ0QW5nbGU7XG5cdFx0dGhpcy5hRW5kQW5nbGUgPSBzb3VyY2UuYUVuZEFuZ2xlO1xuXHRcdHRoaXMuYUNsb2Nrd2lzZSA9IHNvdXJjZS5hQ2xvY2t3aXNlO1xuXHRcdHRoaXMuYVJvdGF0aW9uID0gc291cmNlLmFSb3RhdGlvbjtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHR0b0pTT04oKSB7XG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTigpO1xuXHRcdGRhdGEuYVggPSB0aGlzLmFYO1xuXHRcdGRhdGEuYVkgPSB0aGlzLmFZO1xuXHRcdGRhdGEueFJhZGl1cyA9IHRoaXMueFJhZGl1cztcblx0XHRkYXRhLnlSYWRpdXMgPSB0aGlzLnlSYWRpdXM7XG5cdFx0ZGF0YS5hU3RhcnRBbmdsZSA9IHRoaXMuYVN0YXJ0QW5nbGU7XG5cdFx0ZGF0YS5hRW5kQW5nbGUgPSB0aGlzLmFFbmRBbmdsZTtcblx0XHRkYXRhLmFDbG9ja3dpc2UgPSB0aGlzLmFDbG9ja3dpc2U7XG5cdFx0ZGF0YS5hUm90YXRpb24gPSB0aGlzLmFSb3RhdGlvbjtcblx0XHRyZXR1cm4gZGF0YTtcblx0fVxuXHRmcm9tSlNPTihqc29uKSB7XG5cdFx0c3VwZXIuZnJvbUpTT04oanNvbik7XG5cdFx0dGhpcy5hWCA9IGpzb24uYVg7XG5cdFx0dGhpcy5hWSA9IGpzb24uYVk7XG5cdFx0dGhpcy54UmFkaXVzID0ganNvbi54UmFkaXVzO1xuXHRcdHRoaXMueVJhZGl1cyA9IGpzb24ueVJhZGl1cztcblx0XHR0aGlzLmFTdGFydEFuZ2xlID0ganNvbi5hU3RhcnRBbmdsZTtcblx0XHR0aGlzLmFFbmRBbmdsZSA9IGpzb24uYUVuZEFuZ2xlO1xuXHRcdHRoaXMuYUNsb2Nrd2lzZSA9IGpzb24uYUNsb2Nrd2lzZTtcblx0XHR0aGlzLmFSb3RhdGlvbiA9IGpzb24uYVJvdGF0aW9uO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59XG5cbmNsYXNzIEFyY0N1cnZlIGV4dGVuZHMgRWxsaXBzZUN1cnZlIHtcblx0Y29uc3RydWN0b3IoYVgsIGFZLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlKSB7XG5cdFx0c3VwZXIoYVgsIGFZLCBhUmFkaXVzLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlKTtcblx0XHR0aGlzLmlzQXJjQ3VydmUgPSB0cnVlO1xuXHRcdHRoaXMudHlwZSA9ICdBcmNDdXJ2ZSc7XG5cdH1cbn1cblxuLyoqXG4gKiBDZW50cmlwZXRhbCBDYXRtdWxsUm9tIEN1cnZlIC0gd2hpY2ggaXMgdXNlZnVsIGZvciBhdm9pZGluZ1xuICogY3VzcHMgYW5kIHNlbGYtaW50ZXJzZWN0aW9ucyBpbiBub24tdW5pZm9ybSBjYXRtdWxsIHJvbSBjdXJ2ZXMuXG4gKiBodHRwOi8vd3d3LmNlbXl1a3NlbC5jb20vcmVzZWFyY2gvY2F0bXVsbHJvbV9wYXJhbS9jYXRtdWxscm9tLnBkZlxuICpcbiAqIGN1cnZlLnR5cGUgYWNjZXB0cyBjZW50cmlwZXRhbChkZWZhdWx0KSwgY2hvcmRhbCBhbmQgY2F0bXVsbHJvbVxuICogY3VydmUudGVuc2lvbiBpcyB1c2VkIGZvciBjYXRtdWxscm9tIHdoaWNoIGRlZmF1bHRzIHRvIDAuNVxuICovXG5cbi8qXG5CYXNlZCBvbiBhbiBvcHRpbWl6ZWQgYysrIHNvbHV0aW9uIGluXG4gLSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzk0ODk3MzYvY2F0bXVsbC1yb20tY3VydmUtd2l0aC1uby1jdXNwcy1hbmQtbm8tc2VsZi1pbnRlcnNlY3Rpb25zL1xuIC0gaHR0cDovL2lkZW9uZS5jb20vTm9FYlZNXG5cblRoaXMgQ3ViaWNQb2x5IGNsYXNzIGNvdWxkIGJlIHVzZWQgZm9yIHJldXNpbmcgc29tZSB2YXJpYWJsZXMgYW5kIGNhbGN1bGF0aW9ucyxcbmJ1dCBmb3IgdGhyZWUuanMgY3VydmUgdXNlLCBpdCBjb3VsZCBiZSBwb3NzaWJsZSBpbmxpbmVkIGFuZCBmbGF0dGVuIGludG8gYSBzaW5nbGUgZnVuY3Rpb24gY2FsbFxud2hpY2ggY2FuIGJlIHBsYWNlZCBpbiBDdXJ2ZVV0aWxzLlxuKi9cblxuZnVuY3Rpb24gQ3ViaWNQb2x5KCkge1xuXHRsZXQgYzAgPSAwLFxuXHRcdGMxID0gMCxcblx0XHRjMiA9IDAsXG5cdFx0YzMgPSAwO1xuXG5cdC8qXG5cdCAqIENvbXB1dGUgY29lZmZpY2llbnRzIGZvciBhIGN1YmljIHBvbHlub21pYWxcblx0ICpcdCBwKHMpID0gYzAgKyBjMSpzICsgYzIqc14yICsgYzMqc14zXG5cdCAqIHN1Y2ggdGhhdFxuXHQgKlx0IHAoMCkgPSB4MCwgcCgxKSA9IHgxXG5cdCAqXHRhbmRcblx0ICpcdCBwJygwKSA9IHQwLCBwJygxKSA9IHQxLlxuXHQgKi9cblx0ZnVuY3Rpb24gaW5pdCh4MCwgeDEsIHQwLCB0MSkge1xuXHRcdGMwID0geDA7XG5cdFx0YzEgPSB0MDtcblx0XHRjMiA9IC0zICogeDAgKyAzICogeDEgLSAyICogdDAgLSB0MTtcblx0XHRjMyA9IDIgKiB4MCAtIDIgKiB4MSArIHQwICsgdDE7XG5cdH1cblx0cmV0dXJuIHtcblx0XHRpbml0Q2F0bXVsbFJvbTogZnVuY3Rpb24gKHgwLCB4MSwgeDIsIHgzLCB0ZW5zaW9uKSB7XG5cdFx0XHRpbml0KHgxLCB4MiwgdGVuc2lvbiAqICh4MiAtIHgwKSwgdGVuc2lvbiAqICh4MyAtIHgxKSk7XG5cdFx0fSxcblx0XHRpbml0Tm9udW5pZm9ybUNhdG11bGxSb206IGZ1bmN0aW9uICh4MCwgeDEsIHgyLCB4MywgZHQwLCBkdDEsIGR0Mikge1xuXHRcdFx0Ly8gY29tcHV0ZSB0YW5nZW50cyB3aGVuIHBhcmFtZXRlcml6ZWQgaW4gW3QxLHQyXVxuXHRcdFx0bGV0IHQxID0gKHgxIC0geDApIC8gZHQwIC0gKHgyIC0geDApIC8gKGR0MCArIGR0MSkgKyAoeDIgLSB4MSkgLyBkdDE7XG5cdFx0XHRsZXQgdDIgPSAoeDIgLSB4MSkgLyBkdDEgLSAoeDMgLSB4MSkgLyAoZHQxICsgZHQyKSArICh4MyAtIHgyKSAvIGR0MjtcblxuXHRcdFx0Ly8gcmVzY2FsZSB0YW5nZW50cyBmb3IgcGFyYW1ldHJpemF0aW9uIGluIFswLDFdXG5cdFx0XHR0MSAqPSBkdDE7XG5cdFx0XHR0MiAqPSBkdDE7XG5cdFx0XHRpbml0KHgxLCB4MiwgdDEsIHQyKTtcblx0XHR9LFxuXHRcdGNhbGM6IGZ1bmN0aW9uICh0KSB7XG5cdFx0XHRjb25zdCB0MiA9IHQgKiB0O1xuXHRcdFx0Y29uc3QgdDMgPSB0MiAqIHQ7XG5cdFx0XHRyZXR1cm4gYzAgKyBjMSAqIHQgKyBjMiAqIHQyICsgYzMgKiB0Mztcblx0XHR9XG5cdH07XG59XG5cbi8vXG5cbmNvbnN0IHRtcCA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuY29uc3QgcHggPSAvKkBfX1BVUkVfXyovbmV3IEN1YmljUG9seSgpO1xuY29uc3QgcHkgPSAvKkBfX1BVUkVfXyovbmV3IEN1YmljUG9seSgpO1xuY29uc3QgcHogPSAvKkBfX1BVUkVfXyovbmV3IEN1YmljUG9seSgpO1xuY2xhc3MgQ2F0bXVsbFJvbUN1cnZlMyBleHRlbmRzIEN1cnZlIHtcblx0Y29uc3RydWN0b3IocG9pbnRzID0gW10sIGNsb3NlZCA9IGZhbHNlLCBjdXJ2ZVR5cGUgPSAnY2VudHJpcGV0YWwnLCB0ZW5zaW9uID0gMC41KSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLmlzQ2F0bXVsbFJvbUN1cnZlMyA9IHRydWU7XG5cdFx0dGhpcy50eXBlID0gJ0NhdG11bGxSb21DdXJ2ZTMnO1xuXHRcdHRoaXMucG9pbnRzID0gcG9pbnRzO1xuXHRcdHRoaXMuY2xvc2VkID0gY2xvc2VkO1xuXHRcdHRoaXMuY3VydmVUeXBlID0gY3VydmVUeXBlO1xuXHRcdHRoaXMudGVuc2lvbiA9IHRlbnNpb247XG5cdH1cblx0Z2V0UG9pbnQodCwgb3B0aW9uYWxUYXJnZXQgPSBuZXcgVmVjdG9yMygpKSB7XG5cdFx0Y29uc3QgcG9pbnQgPSBvcHRpb25hbFRhcmdldDtcblx0XHRjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcblx0XHRjb25zdCBsID0gcG9pbnRzLmxlbmd0aDtcblx0XHRjb25zdCBwID0gKGwgLSAodGhpcy5jbG9zZWQgPyAwIDogMSkpICogdDtcblx0XHRsZXQgaW50UG9pbnQgPSBNYXRoLmZsb29yKHApO1xuXHRcdGxldCB3ZWlnaHQgPSBwIC0gaW50UG9pbnQ7XG5cdFx0aWYgKHRoaXMuY2xvc2VkKSB7XG5cdFx0XHRpbnRQb2ludCArPSBpbnRQb2ludCA+IDAgPyAwIDogKE1hdGguZmxvb3IoTWF0aC5hYnMoaW50UG9pbnQpIC8gbCkgKyAxKSAqIGw7XG5cdFx0fSBlbHNlIGlmICh3ZWlnaHQgPT09IDAgJiYgaW50UG9pbnQgPT09IGwgLSAxKSB7XG5cdFx0XHRpbnRQb2ludCA9IGwgLSAyO1xuXHRcdFx0d2VpZ2h0ID0gMTtcblx0XHR9XG5cdFx0bGV0IHAwLCBwMzsgLy8gNCBwb2ludHMgKHAxICYgcDIgZGVmaW5lZCBiZWxvdylcblxuXHRcdGlmICh0aGlzLmNsb3NlZCB8fCBpbnRQb2ludCA+IDApIHtcblx0XHRcdHAwID0gcG9pbnRzWyhpbnRQb2ludCAtIDEpICUgbF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGV4dHJhcG9sYXRlIGZpcnN0IHBvaW50XG5cdFx0XHR0bXAuc3ViVmVjdG9ycyhwb2ludHNbMF0sIHBvaW50c1sxXSkuYWRkKHBvaW50c1swXSk7XG5cdFx0XHRwMCA9IHRtcDtcblx0XHR9XG5cdFx0Y29uc3QgcDEgPSBwb2ludHNbaW50UG9pbnQgJSBsXTtcblx0XHRjb25zdCBwMiA9IHBvaW50c1soaW50UG9pbnQgKyAxKSAlIGxdO1xuXHRcdGlmICh0aGlzLmNsb3NlZCB8fCBpbnRQb2ludCArIDIgPCBsKSB7XG5cdFx0XHRwMyA9IHBvaW50c1soaW50UG9pbnQgKyAyKSAlIGxdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBleHRyYXBvbGF0ZSBsYXN0IHBvaW50XG5cdFx0XHR0bXAuc3ViVmVjdG9ycyhwb2ludHNbbCAtIDFdLCBwb2ludHNbbCAtIDJdKS5hZGQocG9pbnRzW2wgLSAxXSk7XG5cdFx0XHRwMyA9IHRtcDtcblx0XHR9XG5cdFx0aWYgKHRoaXMuY3VydmVUeXBlID09PSAnY2VudHJpcGV0YWwnIHx8IHRoaXMuY3VydmVUeXBlID09PSAnY2hvcmRhbCcpIHtcblx0XHRcdC8vIGluaXQgQ2VudHJpcGV0YWwgLyBDaG9yZGFsIENhdG11bGwtUm9tXG5cdFx0XHRjb25zdCBwb3cgPSB0aGlzLmN1cnZlVHlwZSA9PT0gJ2Nob3JkYWwnID8gMC41IDogMC4yNTtcblx0XHRcdGxldCBkdDAgPSBNYXRoLnBvdyhwMC5kaXN0YW5jZVRvU3F1YXJlZChwMSksIHBvdyk7XG5cdFx0XHRsZXQgZHQxID0gTWF0aC5wb3cocDEuZGlzdGFuY2VUb1NxdWFyZWQocDIpLCBwb3cpO1xuXHRcdFx0bGV0IGR0MiA9IE1hdGgucG93KHAyLmRpc3RhbmNlVG9TcXVhcmVkKHAzKSwgcG93KTtcblxuXHRcdFx0Ly8gc2FmZXR5IGNoZWNrIGZvciByZXBlYXRlZCBwb2ludHNcblx0XHRcdGlmIChkdDEgPCAxZS00KSBkdDEgPSAxLjA7XG5cdFx0XHRpZiAoZHQwIDwgMWUtNCkgZHQwID0gZHQxO1xuXHRcdFx0aWYgKGR0MiA8IDFlLTQpIGR0MiA9IGR0MTtcblx0XHRcdHB4LmluaXROb251bmlmb3JtQ2F0bXVsbFJvbShwMC54LCBwMS54LCBwMi54LCBwMy54LCBkdDAsIGR0MSwgZHQyKTtcblx0XHRcdHB5LmluaXROb251bmlmb3JtQ2F0bXVsbFJvbShwMC55LCBwMS55LCBwMi55LCBwMy55LCBkdDAsIGR0MSwgZHQyKTtcblx0XHRcdHB6LmluaXROb251bmlmb3JtQ2F0bXVsbFJvbShwMC56LCBwMS56LCBwMi56LCBwMy56LCBkdDAsIGR0MSwgZHQyKTtcblx0XHR9IGVsc2UgaWYgKHRoaXMuY3VydmVUeXBlID09PSAnY2F0bXVsbHJvbScpIHtcblx0XHRcdHB4LmluaXRDYXRtdWxsUm9tKHAwLngsIHAxLngsIHAyLngsIHAzLngsIHRoaXMudGVuc2lvbik7XG5cdFx0XHRweS5pbml0Q2F0bXVsbFJvbShwMC55LCBwMS55LCBwMi55LCBwMy55LCB0aGlzLnRlbnNpb24pO1xuXHRcdFx0cHouaW5pdENhdG11bGxSb20ocDAueiwgcDEueiwgcDIueiwgcDMueiwgdGhpcy50ZW5zaW9uKTtcblx0XHR9XG5cdFx0cG9pbnQuc2V0KHB4LmNhbGMod2VpZ2h0KSwgcHkuY2FsYyh3ZWlnaHQpLCBwei5jYWxjKHdlaWdodCkpO1xuXHRcdHJldHVybiBwb2ludDtcblx0fVxuXHRjb3B5KHNvdXJjZSkge1xuXHRcdHN1cGVyLmNvcHkoc291cmNlKTtcblx0XHR0aGlzLnBvaW50cyA9IFtdO1xuXHRcdGZvciAobGV0IGkgPSAwLCBsID0gc291cmNlLnBvaW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGNvbnN0IHBvaW50ID0gc291cmNlLnBvaW50c1tpXTtcblx0XHRcdHRoaXMucG9pbnRzLnB1c2gocG9pbnQuY2xvbmUoKSk7XG5cdFx0fVxuXHRcdHRoaXMuY2xvc2VkID0gc291cmNlLmNsb3NlZDtcblx0XHR0aGlzLmN1cnZlVHlwZSA9IHNvdXJjZS5jdXJ2ZVR5cGU7XG5cdFx0dGhpcy50ZW5zaW9uID0gc291cmNlLnRlbnNpb247XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0dG9KU09OKCkge1xuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oKTtcblx0XHRkYXRhLnBvaW50cyA9IFtdO1xuXHRcdGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5wb2ludHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRjb25zdCBwb2ludCA9IHRoaXMucG9pbnRzW2ldO1xuXHRcdFx0ZGF0YS5wb2ludHMucHVzaChwb2ludC50b0FycmF5KCkpO1xuXHRcdH1cblx0XHRkYXRhLmNsb3NlZCA9IHRoaXMuY2xvc2VkO1xuXHRcdGRhdGEuY3VydmVUeXBlID0gdGhpcy5jdXJ2ZVR5cGU7XG5cdFx0ZGF0YS50ZW5zaW9uID0gdGhpcy50ZW5zaW9uO1xuXHRcdHJldHVybiBkYXRhO1xuXHR9XG5cdGZyb21KU09OKGpzb24pIHtcblx0XHRzdXBlci5mcm9tSlNPTihqc29uKTtcblx0XHR0aGlzLnBvaW50cyA9IFtdO1xuXHRcdGZvciAobGV0IGkgPSAwLCBsID0ganNvbi5wb2ludHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRjb25zdCBwb2ludCA9IGpzb24ucG9pbnRzW2ldO1xuXHRcdFx0dGhpcy5wb2ludHMucHVzaChuZXcgVmVjdG9yMygpLmZyb21BcnJheShwb2ludCkpO1xuXHRcdH1cblx0XHR0aGlzLmNsb3NlZCA9IGpzb24uY2xvc2VkO1xuXHRcdHRoaXMuY3VydmVUeXBlID0ganNvbi5jdXJ2ZVR5cGU7XG5cdFx0dGhpcy50ZW5zaW9uID0ganNvbi50ZW5zaW9uO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59XG5cbi8qKlxuICogQmV6aWVyIEN1cnZlcyBmb3JtdWxhcyBvYnRhaW5lZCBmcm9tXG4gKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CJUMzJUE5emllcl9jdXJ2ZVxuICovXG5cbmZ1bmN0aW9uIENhdG11bGxSb20odCwgcDAsIHAxLCBwMiwgcDMpIHtcblx0Y29uc3QgdjAgPSAocDIgLSBwMCkgKiAwLjU7XG5cdGNvbnN0IHYxID0gKHAzIC0gcDEpICogMC41O1xuXHRjb25zdCB0MiA9IHQgKiB0O1xuXHRjb25zdCB0MyA9IHQgKiB0Mjtcblx0cmV0dXJuICgyICogcDEgLSAyICogcDIgKyB2MCArIHYxKSAqIHQzICsgKC0zICogcDEgKyAzICogcDIgLSAyICogdjAgLSB2MSkgKiB0MiArIHYwICogdCArIHAxO1xufVxuXG4vL1xuXG5mdW5jdGlvbiBRdWFkcmF0aWNCZXppZXJQMCh0LCBwKSB7XG5cdGNvbnN0IGsgPSAxIC0gdDtcblx0cmV0dXJuIGsgKiBrICogcDtcbn1cbmZ1bmN0aW9uIFF1YWRyYXRpY0JlemllclAxKHQsIHApIHtcblx0cmV0dXJuIDIgKiAoMSAtIHQpICogdCAqIHA7XG59XG5mdW5jdGlvbiBRdWFkcmF0aWNCZXppZXJQMih0LCBwKSB7XG5cdHJldHVybiB0ICogdCAqIHA7XG59XG5mdW5jdGlvbiBRdWFkcmF0aWNCZXppZXIodCwgcDAsIHAxLCBwMikge1xuXHRyZXR1cm4gUXVhZHJhdGljQmV6aWVyUDAodCwgcDApICsgUXVhZHJhdGljQmV6aWVyUDEodCwgcDEpICsgUXVhZHJhdGljQmV6aWVyUDIodCwgcDIpO1xufVxuXG4vL1xuXG5mdW5jdGlvbiBDdWJpY0JlemllclAwKHQsIHApIHtcblx0Y29uc3QgayA9IDEgLSB0O1xuXHRyZXR1cm4gayAqIGsgKiBrICogcDtcbn1cbmZ1bmN0aW9uIEN1YmljQmV6aWVyUDEodCwgcCkge1xuXHRjb25zdCBrID0gMSAtIHQ7XG5cdHJldHVybiAzICogayAqIGsgKiB0ICogcDtcbn1cbmZ1bmN0aW9uIEN1YmljQmV6aWVyUDIodCwgcCkge1xuXHRyZXR1cm4gMyAqICgxIC0gdCkgKiB0ICogdCAqIHA7XG59XG5mdW5jdGlvbiBDdWJpY0JlemllclAzKHQsIHApIHtcblx0cmV0dXJuIHQgKiB0ICogdCAqIHA7XG59XG5mdW5jdGlvbiBDdWJpY0Jlemllcih0LCBwMCwgcDEsIHAyLCBwMykge1xuXHRyZXR1cm4gQ3ViaWNCZXppZXJQMCh0LCBwMCkgKyBDdWJpY0JlemllclAxKHQsIHAxKSArIEN1YmljQmV6aWVyUDIodCwgcDIpICsgQ3ViaWNCZXppZXJQMyh0LCBwMyk7XG59XG5cbmNsYXNzIEN1YmljQmV6aWVyQ3VydmUgZXh0ZW5kcyBDdXJ2ZSB7XG5cdGNvbnN0cnVjdG9yKHYwID0gbmV3IFZlY3RvcjIoKSwgdjEgPSBuZXcgVmVjdG9yMigpLCB2MiA9IG5ldyBWZWN0b3IyKCksIHYzID0gbmV3IFZlY3RvcjIoKSkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5pc0N1YmljQmV6aWVyQ3VydmUgPSB0cnVlO1xuXHRcdHRoaXMudHlwZSA9ICdDdWJpY0JlemllckN1cnZlJztcblx0XHR0aGlzLnYwID0gdjA7XG5cdFx0dGhpcy52MSA9IHYxO1xuXHRcdHRoaXMudjIgPSB2Mjtcblx0XHR0aGlzLnYzID0gdjM7XG5cdH1cblx0Z2V0UG9pbnQodCwgb3B0aW9uYWxUYXJnZXQgPSBuZXcgVmVjdG9yMigpKSB7XG5cdFx0Y29uc3QgcG9pbnQgPSBvcHRpb25hbFRhcmdldDtcblx0XHRjb25zdCB2MCA9IHRoaXMudjAsXG5cdFx0XHR2MSA9IHRoaXMudjEsXG5cdFx0XHR2MiA9IHRoaXMudjIsXG5cdFx0XHR2MyA9IHRoaXMudjM7XG5cdFx0cG9pbnQuc2V0KEN1YmljQmV6aWVyKHQsIHYwLngsIHYxLngsIHYyLngsIHYzLngpLCBDdWJpY0Jlemllcih0LCB2MC55LCB2MS55LCB2Mi55LCB2My55KSk7XG5cdFx0cmV0dXJuIHBvaW50O1xuXHR9XG5cdGNvcHkoc291cmNlKSB7XG5cdFx0c3VwZXIuY29weShzb3VyY2UpO1xuXHRcdHRoaXMudjAuY29weShzb3VyY2UudjApO1xuXHRcdHRoaXMudjEuY29weShzb3VyY2UudjEpO1xuXHRcdHRoaXMudjIuY29weShzb3VyY2UudjIpO1xuXHRcdHRoaXMudjMuY29weShzb3VyY2UudjMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHRvSlNPTigpIHtcblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cdFx0ZGF0YS52MCA9IHRoaXMudjAudG9BcnJheSgpO1xuXHRcdGRhdGEudjEgPSB0aGlzLnYxLnRvQXJyYXkoKTtcblx0XHRkYXRhLnYyID0gdGhpcy52Mi50b0FycmF5KCk7XG5cdFx0ZGF0YS52MyA9IHRoaXMudjMudG9BcnJheSgpO1xuXHRcdHJldHVybiBkYXRhO1xuXHR9XG5cdGZyb21KU09OKGpzb24pIHtcblx0XHRzdXBlci5mcm9tSlNPTihqc29uKTtcblx0XHR0aGlzLnYwLmZyb21BcnJheShqc29uLnYwKTtcblx0XHR0aGlzLnYxLmZyb21BcnJheShqc29uLnYxKTtcblx0XHR0aGlzLnYyLmZyb21BcnJheShqc29uLnYyKTtcblx0XHR0aGlzLnYzLmZyb21BcnJheShqc29uLnYzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufVxuXG5jbGFzcyBDdWJpY0JlemllckN1cnZlMyBleHRlbmRzIEN1cnZlIHtcblx0Y29uc3RydWN0b3IodjAgPSBuZXcgVmVjdG9yMygpLCB2MSA9IG5ldyBWZWN0b3IzKCksIHYyID0gbmV3IFZlY3RvcjMoKSwgdjMgPSBuZXcgVmVjdG9yMygpKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLmlzQ3ViaWNCZXppZXJDdXJ2ZTMgPSB0cnVlO1xuXHRcdHRoaXMudHlwZSA9ICdDdWJpY0JlemllckN1cnZlMyc7XG5cdFx0dGhpcy52MCA9IHYwO1xuXHRcdHRoaXMudjEgPSB2MTtcblx0XHR0aGlzLnYyID0gdjI7XG5cdFx0dGhpcy52MyA9IHYzO1xuXHR9XG5cdGdldFBvaW50KHQsIG9wdGlvbmFsVGFyZ2V0ID0gbmV3IFZlY3RvcjMoKSkge1xuXHRcdGNvbnN0IHBvaW50ID0gb3B0aW9uYWxUYXJnZXQ7XG5cdFx0Y29uc3QgdjAgPSB0aGlzLnYwLFxuXHRcdFx0djEgPSB0aGlzLnYxLFxuXHRcdFx0djIgPSB0aGlzLnYyLFxuXHRcdFx0djMgPSB0aGlzLnYzO1xuXHRcdHBvaW50LnNldChDdWJpY0Jlemllcih0LCB2MC54LCB2MS54LCB2Mi54LCB2My54KSwgQ3ViaWNCZXppZXIodCwgdjAueSwgdjEueSwgdjIueSwgdjMueSksIEN1YmljQmV6aWVyKHQsIHYwLnosIHYxLnosIHYyLnosIHYzLnopKTtcblx0XHRyZXR1cm4gcG9pbnQ7XG5cdH1cblx0Y29weShzb3VyY2UpIHtcblx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0dGhpcy52MC5jb3B5KHNvdXJjZS52MCk7XG5cdFx0dGhpcy52MS5jb3B5KHNvdXJjZS52MSk7XG5cdFx0dGhpcy52Mi5jb3B5KHNvdXJjZS52Mik7XG5cdFx0dGhpcy52My5jb3B5KHNvdXJjZS52Myk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0dG9KU09OKCkge1xuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oKTtcblx0XHRkYXRhLnYwID0gdGhpcy52MC50b0FycmF5KCk7XG5cdFx0ZGF0YS52MSA9IHRoaXMudjEudG9BcnJheSgpO1xuXHRcdGRhdGEudjIgPSB0aGlzLnYyLnRvQXJyYXkoKTtcblx0XHRkYXRhLnYzID0gdGhpcy52My50b0FycmF5KCk7XG5cdFx0cmV0dXJuIGRhdGE7XG5cdH1cblx0ZnJvbUpTT04oanNvbikge1xuXHRcdHN1cGVyLmZyb21KU09OKGpzb24pO1xuXHRcdHRoaXMudjAuZnJvbUFycmF5KGpzb24udjApO1xuXHRcdHRoaXMudjEuZnJvbUFycmF5KGpzb24udjEpO1xuXHRcdHRoaXMudjIuZnJvbUFycmF5KGpzb24udjIpO1xuXHRcdHRoaXMudjMuZnJvbUFycmF5KGpzb24udjMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59XG5cbmNsYXNzIExpbmVDdXJ2ZSBleHRlbmRzIEN1cnZlIHtcblx0Y29uc3RydWN0b3IodjEgPSBuZXcgVmVjdG9yMigpLCB2MiA9IG5ldyBWZWN0b3IyKCkpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuaXNMaW5lQ3VydmUgPSB0cnVlO1xuXHRcdHRoaXMudHlwZSA9ICdMaW5lQ3VydmUnO1xuXHRcdHRoaXMudjEgPSB2MTtcblx0XHR0aGlzLnYyID0gdjI7XG5cdH1cblx0Z2V0UG9pbnQodCwgb3B0aW9uYWxUYXJnZXQgPSBuZXcgVmVjdG9yMigpKSB7XG5cdFx0Y29uc3QgcG9pbnQgPSBvcHRpb25hbFRhcmdldDtcblx0XHRpZiAodCA9PT0gMSkge1xuXHRcdFx0cG9pbnQuY29weSh0aGlzLnYyKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cG9pbnQuY29weSh0aGlzLnYyKS5zdWIodGhpcy52MSk7XG5cdFx0XHRwb2ludC5tdWx0aXBseVNjYWxhcih0KS5hZGQodGhpcy52MSk7XG5cdFx0fVxuXHRcdHJldHVybiBwb2ludDtcblx0fVxuXG5cdC8vIExpbmUgY3VydmUgaXMgbGluZWFyLCBzbyB3ZSBjYW4gb3ZlcndyaXRlIGRlZmF1bHQgZ2V0UG9pbnRBdFxuXHRnZXRQb2ludEF0KHUsIG9wdGlvbmFsVGFyZ2V0KSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UG9pbnQodSwgb3B0aW9uYWxUYXJnZXQpO1xuXHR9XG5cdGdldFRhbmdlbnQodCwgb3B0aW9uYWxUYXJnZXQpIHtcblx0XHRjb25zdCB0YW5nZW50ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjIoKTtcblx0XHR0YW5nZW50LmNvcHkodGhpcy52Mikuc3ViKHRoaXMudjEpLm5vcm1hbGl6ZSgpO1xuXHRcdHJldHVybiB0YW5nZW50O1xuXHR9XG5cdGNvcHkoc291cmNlKSB7XG5cdFx0c3VwZXIuY29weShzb3VyY2UpO1xuXHRcdHRoaXMudjEuY29weShzb3VyY2UudjEpO1xuXHRcdHRoaXMudjIuY29weShzb3VyY2UudjIpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHRvSlNPTigpIHtcblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cdFx0ZGF0YS52MSA9IHRoaXMudjEudG9BcnJheSgpO1xuXHRcdGRhdGEudjIgPSB0aGlzLnYyLnRvQXJyYXkoKTtcblx0XHRyZXR1cm4gZGF0YTtcblx0fVxuXHRmcm9tSlNPTihqc29uKSB7XG5cdFx0c3VwZXIuZnJvbUpTT04oanNvbik7XG5cdFx0dGhpcy52MS5mcm9tQXJyYXkoanNvbi52MSk7XG5cdFx0dGhpcy52Mi5mcm9tQXJyYXkoanNvbi52Mik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn1cblxuY2xhc3MgTGluZUN1cnZlMyBleHRlbmRzIEN1cnZlIHtcblx0Y29uc3RydWN0b3IodjEgPSBuZXcgVmVjdG9yMygpLCB2MiA9IG5ldyBWZWN0b3IzKCkpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuaXNMaW5lQ3VydmUzID0gdHJ1ZTtcblx0XHR0aGlzLnR5cGUgPSAnTGluZUN1cnZlMyc7XG5cdFx0dGhpcy52MSA9IHYxO1xuXHRcdHRoaXMudjIgPSB2Mjtcblx0fVxuXHRnZXRQb2ludCh0LCBvcHRpb25hbFRhcmdldCA9IG5ldyBWZWN0b3IzKCkpIHtcblx0XHRjb25zdCBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0O1xuXHRcdGlmICh0ID09PSAxKSB7XG5cdFx0XHRwb2ludC5jb3B5KHRoaXMudjIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwb2ludC5jb3B5KHRoaXMudjIpLnN1Yih0aGlzLnYxKTtcblx0XHRcdHBvaW50Lm11bHRpcGx5U2NhbGFyKHQpLmFkZCh0aGlzLnYxKTtcblx0XHR9XG5cdFx0cmV0dXJuIHBvaW50O1xuXHR9XG5cdC8vIExpbmUgY3VydmUgaXMgbGluZWFyLCBzbyB3ZSBjYW4gb3ZlcndyaXRlIGRlZmF1bHQgZ2V0UG9pbnRBdFxuXHRnZXRQb2ludEF0KHUsIG9wdGlvbmFsVGFyZ2V0KSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UG9pbnQodSwgb3B0aW9uYWxUYXJnZXQpO1xuXHR9XG5cdGNvcHkoc291cmNlKSB7XG5cdFx0c3VwZXIuY29weShzb3VyY2UpO1xuXHRcdHRoaXMudjEuY29weShzb3VyY2UudjEpO1xuXHRcdHRoaXMudjIuY29weShzb3VyY2UudjIpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHRvSlNPTigpIHtcblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cdFx0ZGF0YS52MSA9IHRoaXMudjEudG9BcnJheSgpO1xuXHRcdGRhdGEudjIgPSB0aGlzLnYyLnRvQXJyYXkoKTtcblx0XHRyZXR1cm4gZGF0YTtcblx0fVxuXHRmcm9tSlNPTihqc29uKSB7XG5cdFx0c3VwZXIuZnJvbUpTT04oanNvbik7XG5cdFx0dGhpcy52MS5mcm9tQXJyYXkoanNvbi52MSk7XG5cdFx0dGhpcy52Mi5mcm9tQXJyYXkoanNvbi52Mik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn1cblxuY2xhc3MgUXVhZHJhdGljQmV6aWVyQ3VydmUgZXh0ZW5kcyBDdXJ2ZSB7XG5cdGNvbnN0cnVjdG9yKHYwID0gbmV3IFZlY3RvcjIoKSwgdjEgPSBuZXcgVmVjdG9yMigpLCB2MiA9IG5ldyBWZWN0b3IyKCkpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuaXNRdWFkcmF0aWNCZXppZXJDdXJ2ZSA9IHRydWU7XG5cdFx0dGhpcy50eXBlID0gJ1F1YWRyYXRpY0JlemllckN1cnZlJztcblx0XHR0aGlzLnYwID0gdjA7XG5cdFx0dGhpcy52MSA9IHYxO1xuXHRcdHRoaXMudjIgPSB2Mjtcblx0fVxuXHRnZXRQb2ludCh0LCBvcHRpb25hbFRhcmdldCA9IG5ldyBWZWN0b3IyKCkpIHtcblx0XHRjb25zdCBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0O1xuXHRcdGNvbnN0IHYwID0gdGhpcy52MCxcblx0XHRcdHYxID0gdGhpcy52MSxcblx0XHRcdHYyID0gdGhpcy52Mjtcblx0XHRwb2ludC5zZXQoUXVhZHJhdGljQmV6aWVyKHQsIHYwLngsIHYxLngsIHYyLngpLCBRdWFkcmF0aWNCZXppZXIodCwgdjAueSwgdjEueSwgdjIueSkpO1xuXHRcdHJldHVybiBwb2ludDtcblx0fVxuXHRjb3B5KHNvdXJjZSkge1xuXHRcdHN1cGVyLmNvcHkoc291cmNlKTtcblx0XHR0aGlzLnYwLmNvcHkoc291cmNlLnYwKTtcblx0XHR0aGlzLnYxLmNvcHkoc291cmNlLnYxKTtcblx0XHR0aGlzLnYyLmNvcHkoc291cmNlLnYyKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHR0b0pTT04oKSB7XG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTigpO1xuXHRcdGRhdGEudjAgPSB0aGlzLnYwLnRvQXJyYXkoKTtcblx0XHRkYXRhLnYxID0gdGhpcy52MS50b0FycmF5KCk7XG5cdFx0ZGF0YS52MiA9IHRoaXMudjIudG9BcnJheSgpO1xuXHRcdHJldHVybiBkYXRhO1xuXHR9XG5cdGZyb21KU09OKGpzb24pIHtcblx0XHRzdXBlci5mcm9tSlNPTihqc29uKTtcblx0XHR0aGlzLnYwLmZyb21BcnJheShqc29uLnYwKTtcblx0XHR0aGlzLnYxLmZyb21BcnJheShqc29uLnYxKTtcblx0XHR0aGlzLnYyLmZyb21BcnJheShqc29uLnYyKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufVxuXG5jbGFzcyBRdWFkcmF0aWNCZXppZXJDdXJ2ZTMgZXh0ZW5kcyBDdXJ2ZSB7XG5cdGNvbnN0cnVjdG9yKHYwID0gbmV3IFZlY3RvcjMoKSwgdjEgPSBuZXcgVmVjdG9yMygpLCB2MiA9IG5ldyBWZWN0b3IzKCkpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuaXNRdWFkcmF0aWNCZXppZXJDdXJ2ZTMgPSB0cnVlO1xuXHRcdHRoaXMudHlwZSA9ICdRdWFkcmF0aWNCZXppZXJDdXJ2ZTMnO1xuXHRcdHRoaXMudjAgPSB2MDtcblx0XHR0aGlzLnYxID0gdjE7XG5cdFx0dGhpcy52MiA9IHYyO1xuXHR9XG5cdGdldFBvaW50KHQsIG9wdGlvbmFsVGFyZ2V0ID0gbmV3IFZlY3RvcjMoKSkge1xuXHRcdGNvbnN0IHBvaW50ID0gb3B0aW9uYWxUYXJnZXQ7XG5cdFx0Y29uc3QgdjAgPSB0aGlzLnYwLFxuXHRcdFx0djEgPSB0aGlzLnYxLFxuXHRcdFx0djIgPSB0aGlzLnYyO1xuXHRcdHBvaW50LnNldChRdWFkcmF0aWNCZXppZXIodCwgdjAueCwgdjEueCwgdjIueCksIFF1YWRyYXRpY0Jlemllcih0LCB2MC55LCB2MS55LCB2Mi55KSwgUXVhZHJhdGljQmV6aWVyKHQsIHYwLnosIHYxLnosIHYyLnopKTtcblx0XHRyZXR1cm4gcG9pbnQ7XG5cdH1cblx0Y29weShzb3VyY2UpIHtcblx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0dGhpcy52MC5jb3B5KHNvdXJjZS52MCk7XG5cdFx0dGhpcy52MS5jb3B5KHNvdXJjZS52MSk7XG5cdFx0dGhpcy52Mi5jb3B5KHNvdXJjZS52Mik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0dG9KU09OKCkge1xuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oKTtcblx0XHRkYXRhLnYwID0gdGhpcy52MC50b0FycmF5KCk7XG5cdFx0ZGF0YS52MSA9IHRoaXMudjEudG9BcnJheSgpO1xuXHRcdGRhdGEudjIgPSB0aGlzLnYyLnRvQXJyYXkoKTtcblx0XHRyZXR1cm4gZGF0YTtcblx0fVxuXHRmcm9tSlNPTihqc29uKSB7XG5cdFx0c3VwZXIuZnJvbUpTT04oanNvbik7XG5cdFx0dGhpcy52MC5mcm9tQXJyYXkoanNvbi52MCk7XG5cdFx0dGhpcy52MS5mcm9tQXJyYXkoanNvbi52MSk7XG5cdFx0dGhpcy52Mi5mcm9tQXJyYXkoanNvbi52Mik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn1cblxuY2xhc3MgU3BsaW5lQ3VydmUgZXh0ZW5kcyBDdXJ2ZSB7XG5cdGNvbnN0cnVjdG9yKHBvaW50cyA9IFtdKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLmlzU3BsaW5lQ3VydmUgPSB0cnVlO1xuXHRcdHRoaXMudHlwZSA9ICdTcGxpbmVDdXJ2ZSc7XG5cdFx0dGhpcy5wb2ludHMgPSBwb2ludHM7XG5cdH1cblx0Z2V0UG9pbnQodCwgb3B0aW9uYWxUYXJnZXQgPSBuZXcgVmVjdG9yMigpKSB7XG5cdFx0Y29uc3QgcG9pbnQgPSBvcHRpb25hbFRhcmdldDtcblx0XHRjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcblx0XHRjb25zdCBwID0gKHBvaW50cy5sZW5ndGggLSAxKSAqIHQ7XG5cdFx0Y29uc3QgaW50UG9pbnQgPSBNYXRoLmZsb29yKHApO1xuXHRcdGNvbnN0IHdlaWdodCA9IHAgLSBpbnRQb2ludDtcblx0XHRjb25zdCBwMCA9IHBvaW50c1tpbnRQb2ludCA9PT0gMCA/IGludFBvaW50IDogaW50UG9pbnQgLSAxXTtcblx0XHRjb25zdCBwMSA9IHBvaW50c1tpbnRQb2ludF07XG5cdFx0Y29uc3QgcDIgPSBwb2ludHNbaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMiA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAxXTtcblx0XHRjb25zdCBwMyA9IHBvaW50c1tpbnRQb2ludCA+IHBvaW50cy5sZW5ndGggLSAzID8gcG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDJdO1xuXHRcdHBvaW50LnNldChDYXRtdWxsUm9tKHdlaWdodCwgcDAueCwgcDEueCwgcDIueCwgcDMueCksIENhdG11bGxSb20od2VpZ2h0LCBwMC55LCBwMS55LCBwMi55LCBwMy55KSk7XG5cdFx0cmV0dXJuIHBvaW50O1xuXHR9XG5cdGNvcHkoc291cmNlKSB7XG5cdFx0c3VwZXIuY29weShzb3VyY2UpO1xuXHRcdHRoaXMucG9pbnRzID0gW107XG5cdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBzb3VyY2UucG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0Y29uc3QgcG9pbnQgPSBzb3VyY2UucG9pbnRzW2ldO1xuXHRcdFx0dGhpcy5wb2ludHMucHVzaChwb2ludC5jbG9uZSgpKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0dG9KU09OKCkge1xuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oKTtcblx0XHRkYXRhLnBvaW50cyA9IFtdO1xuXHRcdGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5wb2ludHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRjb25zdCBwb2ludCA9IHRoaXMucG9pbnRzW2ldO1xuXHRcdFx0ZGF0YS5wb2ludHMucHVzaChwb2ludC50b0FycmF5KCkpO1xuXHRcdH1cblx0XHRyZXR1cm4gZGF0YTtcblx0fVxuXHRmcm9tSlNPTihqc29uKSB7XG5cdFx0c3VwZXIuZnJvbUpTT04oanNvbik7XG5cdFx0dGhpcy5wb2ludHMgPSBbXTtcblx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGpzb24ucG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0Y29uc3QgcG9pbnQgPSBqc29uLnBvaW50c1tpXTtcblx0XHRcdHRoaXMucG9pbnRzLnB1c2gobmV3IFZlY3RvcjIoKS5mcm9tQXJyYXkocG9pbnQpKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn1cblxudmFyIEN1cnZlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRBcmNDdXJ2ZTogQXJjQ3VydmUsXG5cdENhdG11bGxSb21DdXJ2ZTM6IENhdG11bGxSb21DdXJ2ZTMsXG5cdEN1YmljQmV6aWVyQ3VydmU6IEN1YmljQmV6aWVyQ3VydmUsXG5cdEN1YmljQmV6aWVyQ3VydmUzOiBDdWJpY0JlemllckN1cnZlMyxcblx0RWxsaXBzZUN1cnZlOiBFbGxpcHNlQ3VydmUsXG5cdExpbmVDdXJ2ZTogTGluZUN1cnZlLFxuXHRMaW5lQ3VydmUzOiBMaW5lQ3VydmUzLFxuXHRRdWFkcmF0aWNCZXppZXJDdXJ2ZTogUXVhZHJhdGljQmV6aWVyQ3VydmUsXG5cdFF1YWRyYXRpY0JlemllckN1cnZlMzogUXVhZHJhdGljQmV6aWVyQ3VydmUzLFxuXHRTcGxpbmVDdXJ2ZTogU3BsaW5lQ3VydmVcbn0pO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHRDdXJ2ZWQgUGF0aCAtIGEgY3VydmUgcGF0aCBpcyBzaW1wbHkgYSBhcnJheSBvZiBjb25uZWN0ZWRcbiAqXHRjdXJ2ZXMsIGJ1dCByZXRhaW5zIHRoZSBhcGkgb2YgYSBjdXJ2ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5jbGFzcyBDdXJ2ZVBhdGggZXh0ZW5kcyBDdXJ2ZSB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy50eXBlID0gJ0N1cnZlUGF0aCc7XG5cdFx0dGhpcy5jdXJ2ZXMgPSBbXTtcblx0XHR0aGlzLmF1dG9DbG9zZSA9IGZhbHNlOyAvLyBBdXRvbWF0aWNhbGx5IGNsb3NlcyB0aGUgcGF0aFxuXHR9XG5cblx0YWRkKGN1cnZlKSB7XG5cdFx0dGhpcy5jdXJ2ZXMucHVzaChjdXJ2ZSk7XG5cdH1cblx0Y2xvc2VQYXRoKCkge1xuXHRcdC8vIEFkZCBhIGxpbmUgY3VydmUgaWYgc3RhcnQgYW5kIGVuZCBvZiBsaW5lcyBhcmUgbm90IGNvbm5lY3RlZFxuXHRcdGNvbnN0IHN0YXJ0UG9pbnQgPSB0aGlzLmN1cnZlc1swXS5nZXRQb2ludCgwKTtcblx0XHRjb25zdCBlbmRQb2ludCA9IHRoaXMuY3VydmVzW3RoaXMuY3VydmVzLmxlbmd0aCAtIDFdLmdldFBvaW50KDEpO1xuXHRcdGlmICghc3RhcnRQb2ludC5lcXVhbHMoZW5kUG9pbnQpKSB7XG5cdFx0XHR0aGlzLmN1cnZlcy5wdXNoKG5ldyBMaW5lQ3VydmUoZW5kUG9pbnQsIHN0YXJ0UG9pbnQpKTtcblx0XHR9XG5cdH1cblxuXHQvLyBUbyBnZXQgYWNjdXJhdGUgcG9pbnQgd2l0aCByZWZlcmVuY2UgdG9cblx0Ly8gZW50aXJlIHBhdGggZGlzdGFuY2UgYXQgdGltZSB0LFxuXHQvLyBmb2xsb3dpbmcgaGFzIHRvIGJlIGRvbmU6XG5cblx0Ly8gMS4gTGVuZ3RoIG9mIGVhY2ggc3ViIHBhdGggaGF2ZSB0byBiZSBrbm93blxuXHQvLyAyLiBMb2NhdGUgYW5kIGlkZW50aWZ5IHR5cGUgb2YgY3VydmVcblx0Ly8gMy4gR2V0IHQgZm9yIHRoZSBjdXJ2ZVxuXHQvLyA0LiBSZXR1cm4gY3VydmUuZ2V0UG9pbnRBdCh0JylcblxuXHRnZXRQb2ludCh0LCBvcHRpb25hbFRhcmdldCkge1xuXHRcdGNvbnN0IGQgPSB0ICogdGhpcy5nZXRMZW5ndGgoKTtcblx0XHRjb25zdCBjdXJ2ZUxlbmd0aHMgPSB0aGlzLmdldEN1cnZlTGVuZ3RocygpO1xuXHRcdGxldCBpID0gMDtcblxuXHRcdC8vIFRvIHRoaW5rIGFib3V0IGJvdW5kYXJpZXMgcG9pbnRzLlxuXG5cdFx0d2hpbGUgKGkgPCBjdXJ2ZUxlbmd0aHMubGVuZ3RoKSB7XG5cdFx0XHRpZiAoY3VydmVMZW5ndGhzW2ldID49IGQpIHtcblx0XHRcdFx0Y29uc3QgZGlmZiA9IGN1cnZlTGVuZ3Roc1tpXSAtIGQ7XG5cdFx0XHRcdGNvbnN0IGN1cnZlID0gdGhpcy5jdXJ2ZXNbaV07XG5cdFx0XHRcdGNvbnN0IHNlZ21lbnRMZW5ndGggPSBjdXJ2ZS5nZXRMZW5ndGgoKTtcblx0XHRcdFx0Y29uc3QgdSA9IHNlZ21lbnRMZW5ndGggPT09IDAgPyAwIDogMSAtIGRpZmYgLyBzZWdtZW50TGVuZ3RoO1xuXHRcdFx0XHRyZXR1cm4gY3VydmUuZ2V0UG9pbnRBdCh1LCBvcHRpb25hbFRhcmdldCk7XG5cdFx0XHR9XG5cdFx0XHRpKys7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXG5cdFx0Ly8gbG9vcCB3aGVyZSBzdW0gIT0gMCwgc3VtID4gZCAsIHN1bSsxIDxkXG5cdH1cblxuXHQvLyBXZSBjYW5ub3QgdXNlIHRoZSBkZWZhdWx0IFRIUkVFLkN1cnZlIGdldFBvaW50KCkgd2l0aCBnZXRMZW5ndGgoKSBiZWNhdXNlIGluXG5cdC8vIFRIUkVFLkN1cnZlLCBnZXRMZW5ndGgoKSBkZXBlbmRzIG9uIGdldFBvaW50KCkgYnV0IGluIFRIUkVFLkN1cnZlUGF0aFxuXHQvLyBnZXRQb2ludCgpIGRlcGVuZHMgb24gZ2V0TGVuZ3RoXG5cblx0Z2V0TGVuZ3RoKCkge1xuXHRcdGNvbnN0IGxlbnMgPSB0aGlzLmdldEN1cnZlTGVuZ3RocygpO1xuXHRcdHJldHVybiBsZW5zW2xlbnMubGVuZ3RoIC0gMV07XG5cdH1cblxuXHQvLyBjYWNoZUxlbmd0aHMgbXVzdCBiZSByZWNhbGN1bGF0ZWQuXG5cdHVwZGF0ZUFyY0xlbmd0aHMoKSB7XG5cdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0dGhpcy5jYWNoZUxlbmd0aHMgPSBudWxsO1xuXHRcdHRoaXMuZ2V0Q3VydmVMZW5ndGhzKCk7XG5cdH1cblxuXHQvLyBDb21wdXRlIGxlbmd0aHMgYW5kIGNhY2hlIHRoZW1cblx0Ly8gV2UgY2Fubm90IG92ZXJ3cml0ZSBnZXRMZW5ndGhzKCkgYmVjYXVzZSBVdG9UIG1hcHBpbmcgdXNlcyBpdC5cblxuXHRnZXRDdXJ2ZUxlbmd0aHMoKSB7XG5cdFx0Ly8gV2UgdXNlIGNhY2hlIHZhbHVlcyBpZiBjdXJ2ZXMgYW5kIGNhY2hlIGFycmF5IGFyZSBzYW1lIGxlbmd0aFxuXG5cdFx0aWYgKHRoaXMuY2FjaGVMZW5ndGhzICYmIHRoaXMuY2FjaGVMZW5ndGhzLmxlbmd0aCA9PT0gdGhpcy5jdXJ2ZXMubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jYWNoZUxlbmd0aHM7XG5cdFx0fVxuXG5cdFx0Ly8gR2V0IGxlbmd0aCBvZiBzdWItY3VydmVcblx0XHQvLyBQdXNoIHN1bXMgaW50byBjYWNoZWQgYXJyYXlcblxuXHRcdGNvbnN0IGxlbmd0aHMgPSBbXTtcblx0XHRsZXQgc3VtcyA9IDA7XG5cdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLmN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHN1bXMgKz0gdGhpcy5jdXJ2ZXNbaV0uZ2V0TGVuZ3RoKCk7XG5cdFx0XHRsZW5ndGhzLnB1c2goc3Vtcyk7XG5cdFx0fVxuXHRcdHRoaXMuY2FjaGVMZW5ndGhzID0gbGVuZ3Rocztcblx0XHRyZXR1cm4gbGVuZ3Rocztcblx0fVxuXHRnZXRTcGFjZWRQb2ludHMoZGl2aXNpb25zID0gNDApIHtcblx0XHRjb25zdCBwb2ludHMgPSBbXTtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8PSBkaXZpc2lvbnM7IGkrKykge1xuXHRcdFx0cG9pbnRzLnB1c2godGhpcy5nZXRQb2ludChpIC8gZGl2aXNpb25zKSk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLmF1dG9DbG9zZSkge1xuXHRcdFx0cG9pbnRzLnB1c2gocG9pbnRzWzBdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHBvaW50cztcblx0fVxuXHRnZXRQb2ludHMoZGl2aXNpb25zID0gMTIpIHtcblx0XHRjb25zdCBwb2ludHMgPSBbXTtcblx0XHRsZXQgbGFzdDtcblx0XHRmb3IgKGxldCBpID0gMCwgY3VydmVzID0gdGhpcy5jdXJ2ZXM7IGkgPCBjdXJ2ZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IGN1cnZlID0gY3VydmVzW2ldO1xuXHRcdFx0Y29uc3QgcmVzb2x1dGlvbiA9IGN1cnZlLmlzRWxsaXBzZUN1cnZlID8gZGl2aXNpb25zICogMiA6IGN1cnZlLmlzTGluZUN1cnZlIHx8IGN1cnZlLmlzTGluZUN1cnZlMyA/IDEgOiBjdXJ2ZS5pc1NwbGluZUN1cnZlID8gZGl2aXNpb25zICogY3VydmUucG9pbnRzLmxlbmd0aCA6IGRpdmlzaW9ucztcblx0XHRcdGNvbnN0IHB0cyA9IGN1cnZlLmdldFBvaW50cyhyZXNvbHV0aW9uKTtcblx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgcHRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGNvbnN0IHBvaW50ID0gcHRzW2pdO1xuXHRcdFx0XHRpZiAobGFzdCAmJiBsYXN0LmVxdWFscyhwb2ludCkpIGNvbnRpbnVlOyAvLyBlbnN1cmVzIG5vIGNvbnNlY3V0aXZlIHBvaW50cyBhcmUgZHVwbGljYXRlc1xuXG5cdFx0XHRcdHBvaW50cy5wdXNoKHBvaW50KTtcblx0XHRcdFx0bGFzdCA9IHBvaW50O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAodGhpcy5hdXRvQ2xvc2UgJiYgcG9pbnRzLmxlbmd0aCA+IDEgJiYgIXBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0uZXF1YWxzKHBvaW50c1swXSkpIHtcblx0XHRcdHBvaW50cy5wdXNoKHBvaW50c1swXSk7XG5cdFx0fVxuXHRcdHJldHVybiBwb2ludHM7XG5cdH1cblx0Y29weShzb3VyY2UpIHtcblx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0dGhpcy5jdXJ2ZXMgPSBbXTtcblx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHNvdXJjZS5jdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRjb25zdCBjdXJ2ZSA9IHNvdXJjZS5jdXJ2ZXNbaV07XG5cdFx0XHR0aGlzLmN1cnZlcy5wdXNoKGN1cnZlLmNsb25lKCkpO1xuXHRcdH1cblx0XHR0aGlzLmF1dG9DbG9zZSA9IHNvdXJjZS5hdXRvQ2xvc2U7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0dG9KU09OKCkge1xuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oKTtcblx0XHRkYXRhLmF1dG9DbG9zZSA9IHRoaXMuYXV0b0Nsb3NlO1xuXHRcdGRhdGEuY3VydmVzID0gW107XG5cdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLmN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGNvbnN0IGN1cnZlID0gdGhpcy5jdXJ2ZXNbaV07XG5cdFx0XHRkYXRhLmN1cnZlcy5wdXNoKGN1cnZlLnRvSlNPTigpKTtcblx0XHR9XG5cdFx0cmV0dXJuIGRhdGE7XG5cdH1cblx0ZnJvbUpTT04oanNvbikge1xuXHRcdHN1cGVyLmZyb21KU09OKGpzb24pO1xuXHRcdHRoaXMuYXV0b0Nsb3NlID0ganNvbi5hdXRvQ2xvc2U7XG5cdFx0dGhpcy5jdXJ2ZXMgPSBbXTtcblx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGpzb24uY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0Y29uc3QgY3VydmUgPSBqc29uLmN1cnZlc1tpXTtcblx0XHRcdHRoaXMuY3VydmVzLnB1c2gobmV3IEN1cnZlc1tjdXJ2ZS50eXBlXSgpLmZyb21KU09OKGN1cnZlKSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59XG5cbmNsYXNzIFBhdGggZXh0ZW5kcyBDdXJ2ZVBhdGgge1xuXHRjb25zdHJ1Y3Rvcihwb2ludHMpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMudHlwZSA9ICdQYXRoJztcblx0XHR0aGlzLmN1cnJlbnRQb2ludCA9IG5ldyBWZWN0b3IyKCk7XG5cdFx0aWYgKHBvaW50cykge1xuXHRcdFx0dGhpcy5zZXRGcm9tUG9pbnRzKHBvaW50cyk7XG5cdFx0fVxuXHR9XG5cdHNldEZyb21Qb2ludHMocG9pbnRzKSB7XG5cdFx0dGhpcy5tb3ZlVG8ocG9pbnRzWzBdLngsIHBvaW50c1swXS55KTtcblx0XHRmb3IgKGxldCBpID0gMSwgbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHRoaXMubGluZVRvKHBvaW50c1tpXS54LCBwb2ludHNbaV0ueSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdG1vdmVUbyh4LCB5KSB7XG5cdFx0dGhpcy5jdXJyZW50UG9pbnQuc2V0KHgsIHkpOyAvLyBUT0RPIGNvbnNpZGVyIHJlZmVyZW5jaW5nIHZlY3RvcnMgaW5zdGVhZCBvZiBjb3B5aW5nP1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0bGluZVRvKHgsIHkpIHtcblx0XHRjb25zdCBjdXJ2ZSA9IG5ldyBMaW5lQ3VydmUodGhpcy5jdXJyZW50UG9pbnQuY2xvbmUoKSwgbmV3IFZlY3RvcjIoeCwgeSkpO1xuXHRcdHRoaXMuY3VydmVzLnB1c2goY3VydmUpO1xuXHRcdHRoaXMuY3VycmVudFBvaW50LnNldCh4LCB5KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRxdWFkcmF0aWNDdXJ2ZVRvKGFDUHgsIGFDUHksIGFYLCBhWSkge1xuXHRcdGNvbnN0IGN1cnZlID0gbmV3IFF1YWRyYXRpY0JlemllckN1cnZlKHRoaXMuY3VycmVudFBvaW50LmNsb25lKCksIG5ldyBWZWN0b3IyKGFDUHgsIGFDUHkpLCBuZXcgVmVjdG9yMihhWCwgYVkpKTtcblx0XHR0aGlzLmN1cnZlcy5wdXNoKGN1cnZlKTtcblx0XHR0aGlzLmN1cnJlbnRQb2ludC5zZXQoYVgsIGFZKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRiZXppZXJDdXJ2ZVRvKGFDUDF4LCBhQ1AxeSwgYUNQMngsIGFDUDJ5LCBhWCwgYVkpIHtcblx0XHRjb25zdCBjdXJ2ZSA9IG5ldyBDdWJpY0JlemllckN1cnZlKHRoaXMuY3VycmVudFBvaW50LmNsb25lKCksIG5ldyBWZWN0b3IyKGFDUDF4LCBhQ1AxeSksIG5ldyBWZWN0b3IyKGFDUDJ4LCBhQ1AyeSksIG5ldyBWZWN0b3IyKGFYLCBhWSkpO1xuXHRcdHRoaXMuY3VydmVzLnB1c2goY3VydmUpO1xuXHRcdHRoaXMuY3VycmVudFBvaW50LnNldChhWCwgYVkpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHNwbGluZVRocnUocHRzIC8qQXJyYXkgb2YgVmVjdG9yKi8pIHtcblx0XHRjb25zdCBucHRzID0gW3RoaXMuY3VycmVudFBvaW50LmNsb25lKCldLmNvbmNhdChwdHMpO1xuXHRcdGNvbnN0IGN1cnZlID0gbmV3IFNwbGluZUN1cnZlKG5wdHMpO1xuXHRcdHRoaXMuY3VydmVzLnB1c2goY3VydmUpO1xuXHRcdHRoaXMuY3VycmVudFBvaW50LmNvcHkocHRzW3B0cy5sZW5ndGggLSAxXSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0YXJjKGFYLCBhWSwgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSkge1xuXHRcdGNvbnN0IHgwID0gdGhpcy5jdXJyZW50UG9pbnQueDtcblx0XHRjb25zdCB5MCA9IHRoaXMuY3VycmVudFBvaW50Lnk7XG5cdFx0dGhpcy5hYnNhcmMoYVggKyB4MCwgYVkgKyB5MCwgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0YWJzYXJjKGFYLCBhWSwgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSkge1xuXHRcdHRoaXMuYWJzZWxsaXBzZShhWCwgYVksIGFSYWRpdXMsIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGVsbGlwc2UoYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24pIHtcblx0XHRjb25zdCB4MCA9IHRoaXMuY3VycmVudFBvaW50Lng7XG5cdFx0Y29uc3QgeTAgPSB0aGlzLmN1cnJlbnRQb2ludC55O1xuXHRcdHRoaXMuYWJzZWxsaXBzZShhWCArIHgwLCBhWSArIHkwLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGFic2VsbGlwc2UoYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24pIHtcblx0XHRjb25zdCBjdXJ2ZSA9IG5ldyBFbGxpcHNlQ3VydmUoYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24pO1xuXHRcdGlmICh0aGlzLmN1cnZlcy5sZW5ndGggPiAwKSB7XG5cdFx0XHQvLyBpZiBhIHByZXZpb3VzIGN1cnZlIGlzIHByZXNlbnQsIGF0dGVtcHQgdG8gam9pblxuXHRcdFx0Y29uc3QgZmlyc3RQb2ludCA9IGN1cnZlLmdldFBvaW50KDApO1xuXHRcdFx0aWYgKCFmaXJzdFBvaW50LmVxdWFscyh0aGlzLmN1cnJlbnRQb2ludCkpIHtcblx0XHRcdFx0dGhpcy5saW5lVG8oZmlyc3RQb2ludC54LCBmaXJzdFBvaW50LnkpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLmN1cnZlcy5wdXNoKGN1cnZlKTtcblx0XHRjb25zdCBsYXN0UG9pbnQgPSBjdXJ2ZS5nZXRQb2ludCgxKTtcblx0XHR0aGlzLmN1cnJlbnRQb2ludC5jb3B5KGxhc3RQb2ludCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0Y29weShzb3VyY2UpIHtcblx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0dGhpcy5jdXJyZW50UG9pbnQuY29weShzb3VyY2UuY3VycmVudFBvaW50KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHR0b0pTT04oKSB7XG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTigpO1xuXHRcdGRhdGEuY3VycmVudFBvaW50ID0gdGhpcy5jdXJyZW50UG9pbnQudG9BcnJheSgpO1xuXHRcdHJldHVybiBkYXRhO1xuXHR9XG5cdGZyb21KU09OKGpzb24pIHtcblx0XHRzdXBlci5mcm9tSlNPTihqc29uKTtcblx0XHR0aGlzLmN1cnJlbnRQb2ludC5mcm9tQXJyYXkoanNvbi5jdXJyZW50UG9pbnQpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59XG5cbmNsYXNzIExhdGhlR2VvbWV0cnkgZXh0ZW5kcyBCdWZmZXJHZW9tZXRyeSB7XG5cdGNvbnN0cnVjdG9yKHBvaW50cyA9IFtuZXcgVmVjdG9yMigwLCAtMC41KSwgbmV3IFZlY3RvcjIoMC41LCAwKSwgbmV3IFZlY3RvcjIoMCwgMC41KV0sIHNlZ21lbnRzID0gMTIsIHBoaVN0YXJ0ID0gMCwgcGhpTGVuZ3RoID0gTWF0aC5QSSAqIDIpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMudHlwZSA9ICdMYXRoZUdlb21ldHJ5Jztcblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRwb2ludHM6IHBvaW50cyxcblx0XHRcdHNlZ21lbnRzOiBzZWdtZW50cyxcblx0XHRcdHBoaVN0YXJ0OiBwaGlTdGFydCxcblx0XHRcdHBoaUxlbmd0aDogcGhpTGVuZ3RoXG5cdFx0fTtcblx0XHRzZWdtZW50cyA9IE1hdGguZmxvb3Ioc2VnbWVudHMpO1xuXG5cdFx0Ly8gY2xhbXAgcGhpTGVuZ3RoIHNvIGl0J3MgaW4gcmFuZ2Ugb2YgWyAwLCAyUEkgXVxuXG5cdFx0cGhpTGVuZ3RoID0gY2xhbXAocGhpTGVuZ3RoLCAwLCBNYXRoLlBJICogMik7XG5cblx0XHQvLyBidWZmZXJzXG5cblx0XHRjb25zdCBpbmRpY2VzID0gW107XG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblx0XHRjb25zdCB1dnMgPSBbXTtcblx0XHRjb25zdCBpbml0Tm9ybWFscyA9IFtdO1xuXHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcblxuXHRcdC8vIGhlbHBlciB2YXJpYWJsZXNcblxuXHRcdGNvbnN0IGludmVyc2VTZWdtZW50cyA9IDEuMCAvIHNlZ21lbnRzO1xuXHRcdGNvbnN0IHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgdXYgPSBuZXcgVmVjdG9yMigpO1xuXHRcdGNvbnN0IG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgY3VyTm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcblx0XHRjb25zdCBwcmV2Tm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcblx0XHRsZXQgZHggPSAwO1xuXHRcdGxldCBkeSA9IDA7XG5cblx0XHQvLyBwcmUtY29tcHV0ZSBub3JtYWxzIGZvciBpbml0aWFsIFwibWVyaWRpYW5cIlxuXG5cdFx0Zm9yIChsZXQgaiA9IDA7IGogPD0gcG9pbnRzLmxlbmd0aCAtIDE7IGorKykge1xuXHRcdFx0c3dpdGNoIChqKSB7XG5cdFx0XHRcdGNhc2UgMDpcblx0XHRcdFx0XHQvLyBzcGVjaWFsIGhhbmRsaW5nIGZvciAxc3QgdmVydGV4IG9uIHBhdGhcblxuXHRcdFx0XHRcdGR4ID0gcG9pbnRzW2ogKyAxXS54IC0gcG9pbnRzW2pdLng7XG5cdFx0XHRcdFx0ZHkgPSBwb2ludHNbaiArIDFdLnkgLSBwb2ludHNbal0ueTtcblx0XHRcdFx0XHRub3JtYWwueCA9IGR5ICogMS4wO1xuXHRcdFx0XHRcdG5vcm1hbC55ID0gLWR4O1xuXHRcdFx0XHRcdG5vcm1hbC56ID0gZHkgKiAwLjA7XG5cdFx0XHRcdFx0cHJldk5vcm1hbC5jb3B5KG5vcm1hbCk7XG5cdFx0XHRcdFx0bm9ybWFsLm5vcm1hbGl6ZSgpO1xuXHRcdFx0XHRcdGluaXROb3JtYWxzLnB1c2gobm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueik7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgcG9pbnRzLmxlbmd0aCAtIDE6XG5cdFx0XHRcdFx0Ly8gc3BlY2lhbCBoYW5kbGluZyBmb3IgbGFzdCBWZXJ0ZXggb24gcGF0aFxuXG5cdFx0XHRcdFx0aW5pdE5vcm1hbHMucHVzaChwcmV2Tm9ybWFsLngsIHByZXZOb3JtYWwueSwgcHJldk5vcm1hbC56KTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHQvLyBkZWZhdWx0IGhhbmRsaW5nIGZvciBhbGwgdmVydGljZXMgaW4gYmV0d2VlblxuXG5cdFx0XHRcdFx0ZHggPSBwb2ludHNbaiArIDFdLnggLSBwb2ludHNbal0ueDtcblx0XHRcdFx0XHRkeSA9IHBvaW50c1tqICsgMV0ueSAtIHBvaW50c1tqXS55O1xuXHRcdFx0XHRcdG5vcm1hbC54ID0gZHkgKiAxLjA7XG5cdFx0XHRcdFx0bm9ybWFsLnkgPSAtZHg7XG5cdFx0XHRcdFx0bm9ybWFsLnogPSBkeSAqIDAuMDtcblx0XHRcdFx0XHRjdXJOb3JtYWwuY29weShub3JtYWwpO1xuXHRcdFx0XHRcdG5vcm1hbC54ICs9IHByZXZOb3JtYWwueDtcblx0XHRcdFx0XHRub3JtYWwueSArPSBwcmV2Tm9ybWFsLnk7XG5cdFx0XHRcdFx0bm9ybWFsLnogKz0gcHJldk5vcm1hbC56O1xuXHRcdFx0XHRcdG5vcm1hbC5ub3JtYWxpemUoKTtcblx0XHRcdFx0XHRpbml0Tm9ybWFscy5wdXNoKG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnopO1xuXHRcdFx0XHRcdHByZXZOb3JtYWwuY29weShjdXJOb3JtYWwpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGdlbmVyYXRlIHZlcnRpY2VzLCB1dnMgYW5kIG5vcm1hbHNcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDw9IHNlZ21lbnRzOyBpKyspIHtcblx0XHRcdGNvbnN0IHBoaSA9IHBoaVN0YXJ0ICsgaSAqIGludmVyc2VTZWdtZW50cyAqIHBoaUxlbmd0aDtcblx0XHRcdGNvbnN0IHNpbiA9IE1hdGguc2luKHBoaSk7XG5cdFx0XHRjb25zdCBjb3MgPSBNYXRoLmNvcyhwaGkpO1xuXHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPD0gcG9pbnRzLmxlbmd0aCAtIDE7IGorKykge1xuXHRcdFx0XHQvLyB2ZXJ0ZXhcblxuXHRcdFx0XHR2ZXJ0ZXgueCA9IHBvaW50c1tqXS54ICogc2luO1xuXHRcdFx0XHR2ZXJ0ZXgueSA9IHBvaW50c1tqXS55O1xuXHRcdFx0XHR2ZXJ0ZXgueiA9IHBvaW50c1tqXS54ICogY29zO1xuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnopO1xuXG5cdFx0XHRcdC8vIHV2XG5cblx0XHRcdFx0dXYueCA9IGkgLyBzZWdtZW50cztcblx0XHRcdFx0dXYueSA9IGogLyAocG9pbnRzLmxlbmd0aCAtIDEpO1xuXHRcdFx0XHR1dnMucHVzaCh1di54LCB1di55KTtcblxuXHRcdFx0XHQvLyBub3JtYWxcblxuXHRcdFx0XHRjb25zdCB4ID0gaW5pdE5vcm1hbHNbMyAqIGogKyAwXSAqIHNpbjtcblx0XHRcdFx0Y29uc3QgeSA9IGluaXROb3JtYWxzWzMgKiBqICsgMV07XG5cdFx0XHRcdGNvbnN0IHogPSBpbml0Tm9ybWFsc1szICogaiArIDBdICogY29zO1xuXHRcdFx0XHRub3JtYWxzLnB1c2goeCwgeSwgeik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gaW5kaWNlc1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50czsgaSsrKSB7XG5cdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IHBvaW50cy5sZW5ndGggLSAxOyBqKyspIHtcblx0XHRcdFx0Y29uc3QgYmFzZSA9IGogKyBpICogcG9pbnRzLmxlbmd0aDtcblx0XHRcdFx0Y29uc3QgYSA9IGJhc2U7XG5cdFx0XHRcdGNvbnN0IGIgPSBiYXNlICsgcG9pbnRzLmxlbmd0aDtcblx0XHRcdFx0Y29uc3QgYyA9IGJhc2UgKyBwb2ludHMubGVuZ3RoICsgMTtcblx0XHRcdFx0Y29uc3QgZCA9IGJhc2UgKyAxO1xuXG5cdFx0XHRcdC8vIGZhY2VzXG5cblx0XHRcdFx0aW5kaWNlcy5wdXNoKGEsIGIsIGQpO1xuXHRcdFx0XHRpbmRpY2VzLnB1c2goYywgZCwgYik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gYnVpbGQgZ2VvbWV0cnlcblxuXHRcdHRoaXMuc2V0SW5kZXgoaW5kaWNlcyk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodmVydGljZXMsIDMpKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSgndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh1dnMsIDIpKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSgnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUobm9ybWFscywgMykpO1xuXHR9XG5cdHN0YXRpYyBmcm9tSlNPTihkYXRhKSB7XG5cdFx0cmV0dXJuIG5ldyBMYXRoZUdlb21ldHJ5KGRhdGEucG9pbnRzLCBkYXRhLnNlZ21lbnRzLCBkYXRhLnBoaVN0YXJ0LCBkYXRhLnBoaUxlbmd0aCk7XG5cdH1cbn1cblxuY2xhc3MgQ2Fwc3VsZUdlb21ldHJ5IGV4dGVuZHMgTGF0aGVHZW9tZXRyeSB7XG5cdGNvbnN0cnVjdG9yKHJhZGl1cyA9IDEsIGxlbmd0aCA9IDEsIGNhcFNlZ21lbnRzID0gNCwgcmFkaWFsU2VnbWVudHMgPSA4KSB7XG5cdFx0Y29uc3QgcGF0aCA9IG5ldyBQYXRoKCk7XG5cdFx0cGF0aC5hYnNhcmMoMCwgLWxlbmd0aCAvIDIsIHJhZGl1cywgTWF0aC5QSSAqIDEuNSwgMCk7XG5cdFx0cGF0aC5hYnNhcmMoMCwgbGVuZ3RoIC8gMiwgcmFkaXVzLCAwLCBNYXRoLlBJICogMC41KTtcblx0XHRzdXBlcihwYXRoLmdldFBvaW50cyhjYXBTZWdtZW50cyksIHJhZGlhbFNlZ21lbnRzKTtcblx0XHR0aGlzLnR5cGUgPSAnQ2Fwc3VsZUdlb21ldHJ5Jztcblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRcdGhlaWdodDogbGVuZ3RoLFxuXHRcdFx0Y2FwU2VnbWVudHM6IGNhcFNlZ21lbnRzLFxuXHRcdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzXG5cdFx0fTtcblx0fVxuXHRzdGF0aWMgZnJvbUpTT04oZGF0YSkge1xuXHRcdHJldHVybiBuZXcgQ2Fwc3VsZUdlb21ldHJ5KGRhdGEucmFkaXVzLCBkYXRhLmxlbmd0aCwgZGF0YS5jYXBTZWdtZW50cywgZGF0YS5yYWRpYWxTZWdtZW50cyk7XG5cdH1cbn1cblxuY2xhc3MgQ2lyY2xlR2VvbWV0cnkgZXh0ZW5kcyBCdWZmZXJHZW9tZXRyeSB7XG5cdGNvbnN0cnVjdG9yKHJhZGl1cyA9IDEsIHNlZ21lbnRzID0gOCwgdGhldGFTdGFydCA9IDAsIHRoZXRhTGVuZ3RoID0gTWF0aC5QSSAqIDIpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMudHlwZSA9ICdDaXJjbGVHZW9tZXRyeSc7XG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRzZWdtZW50czogc2VnbWVudHMsXG5cdFx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuXHRcdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG5cdFx0fTtcblx0XHRzZWdtZW50cyA9IE1hdGgubWF4KDMsIHNlZ21lbnRzKTtcblxuXHRcdC8vIGJ1ZmZlcnNcblxuXHRcdGNvbnN0IGluZGljZXMgPSBbXTtcblx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcblx0XHRjb25zdCB1dnMgPSBbXTtcblxuXHRcdC8vIGhlbHBlciB2YXJpYWJsZXNcblxuXHRcdGNvbnN0IHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgdXYgPSBuZXcgVmVjdG9yMigpO1xuXG5cdFx0Ly8gY2VudGVyIHBvaW50XG5cblx0XHR2ZXJ0aWNlcy5wdXNoKDAsIDAsIDApO1xuXHRcdG5vcm1hbHMucHVzaCgwLCAwLCAxKTtcblx0XHR1dnMucHVzaCgwLjUsIDAuNSk7XG5cdFx0Zm9yIChsZXQgcyA9IDAsIGkgPSAzOyBzIDw9IHNlZ21lbnRzOyBzKyssIGkgKz0gMykge1xuXHRcdFx0Y29uc3Qgc2VnbWVudCA9IHRoZXRhU3RhcnQgKyBzIC8gc2VnbWVudHMgKiB0aGV0YUxlbmd0aDtcblxuXHRcdFx0Ly8gdmVydGV4XG5cblx0XHRcdHZlcnRleC54ID0gcmFkaXVzICogTWF0aC5jb3Moc2VnbWVudCk7XG5cdFx0XHR2ZXJ0ZXgueSA9IHJhZGl1cyAqIE1hdGguc2luKHNlZ21lbnQpO1xuXHRcdFx0dmVydGljZXMucHVzaCh2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56KTtcblxuXHRcdFx0Ly8gbm9ybWFsXG5cblx0XHRcdG5vcm1hbHMucHVzaCgwLCAwLCAxKTtcblxuXHRcdFx0Ly8gdXZzXG5cblx0XHRcdHV2LnggPSAodmVydGljZXNbaV0gLyByYWRpdXMgKyAxKSAvIDI7XG5cdFx0XHR1di55ID0gKHZlcnRpY2VzW2kgKyAxXSAvIHJhZGl1cyArIDEpIC8gMjtcblx0XHRcdHV2cy5wdXNoKHV2LngsIHV2LnkpO1xuXHRcdH1cblxuXHRcdC8vIGluZGljZXNcblxuXHRcdGZvciAobGV0IGkgPSAxOyBpIDw9IHNlZ21lbnRzOyBpKyspIHtcblx0XHRcdGluZGljZXMucHVzaChpLCBpICsgMSwgMCk7XG5cdFx0fVxuXG5cdFx0Ly8gYnVpbGQgZ2VvbWV0cnlcblxuXHRcdHRoaXMuc2V0SW5kZXgoaW5kaWNlcyk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodmVydGljZXMsIDMpKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSgnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUobm9ybWFscywgMykpO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHV2cywgMikpO1xuXHR9XG5cdHN0YXRpYyBmcm9tSlNPTihkYXRhKSB7XG5cdFx0cmV0dXJuIG5ldyBDaXJjbGVHZW9tZXRyeShkYXRhLnJhZGl1cywgZGF0YS5zZWdtZW50cywgZGF0YS50aGV0YVN0YXJ0LCBkYXRhLnRoZXRhTGVuZ3RoKTtcblx0fVxufVxuXG5jbGFzcyBDeWxpbmRlckdlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXHRjb25zdHJ1Y3RvcihyYWRpdXNUb3AgPSAxLCByYWRpdXNCb3R0b20gPSAxLCBoZWlnaHQgPSAxLCByYWRpYWxTZWdtZW50cyA9IDgsIGhlaWdodFNlZ21lbnRzID0gMSwgb3BlbkVuZGVkID0gZmFsc2UsIHRoZXRhU3RhcnQgPSAwLCB0aGV0YUxlbmd0aCA9IE1hdGguUEkgKiAyKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLnR5cGUgPSAnQ3lsaW5kZXJHZW9tZXRyeSc7XG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0cmFkaXVzVG9wOiByYWRpdXNUb3AsXG5cdFx0XHRyYWRpdXNCb3R0b206IHJhZGl1c0JvdHRvbSxcblx0XHRcdGhlaWdodDogaGVpZ2h0LFxuXHRcdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuXHRcdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxuXHRcdFx0b3BlbkVuZGVkOiBvcGVuRW5kZWQsXG5cdFx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuXHRcdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG5cdFx0fTtcblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cdFx0cmFkaWFsU2VnbWVudHMgPSBNYXRoLmZsb29yKHJhZGlhbFNlZ21lbnRzKTtcblx0XHRoZWlnaHRTZWdtZW50cyA9IE1hdGguZmxvb3IoaGVpZ2h0U2VnbWVudHMpO1xuXG5cdFx0Ly8gYnVmZmVyc1xuXG5cdFx0Y29uc3QgaW5kaWNlcyA9IFtdO1xuXHRcdGNvbnN0IHZlcnRpY2VzID0gW107XG5cdFx0Y29uc3Qgbm9ybWFscyA9IFtdO1xuXHRcdGNvbnN0IHV2cyA9IFtdO1xuXG5cdFx0Ly8gaGVscGVyIHZhcmlhYmxlc1xuXG5cdFx0bGV0IGluZGV4ID0gMDtcblx0XHRjb25zdCBpbmRleEFycmF5ID0gW107XG5cdFx0Y29uc3QgaGFsZkhlaWdodCA9IGhlaWdodCAvIDI7XG5cdFx0bGV0IGdyb3VwU3RhcnQgPSAwO1xuXG5cdFx0Ly8gZ2VuZXJhdGUgZ2VvbWV0cnlcblxuXHRcdGdlbmVyYXRlVG9yc28oKTtcblx0XHRpZiAob3BlbkVuZGVkID09PSBmYWxzZSkge1xuXHRcdFx0aWYgKHJhZGl1c1RvcCA+IDApIGdlbmVyYXRlQ2FwKHRydWUpO1xuXHRcdFx0aWYgKHJhZGl1c0JvdHRvbSA+IDApIGdlbmVyYXRlQ2FwKGZhbHNlKTtcblx0XHR9XG5cblx0XHQvLyBidWlsZCBnZW9tZXRyeVxuXG5cdFx0dGhpcy5zZXRJbmRleChpbmRpY2VzKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh2ZXJ0aWNlcywgMykpO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShub3JtYWxzLCAzKSk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodXZzLCAyKSk7XG5cdFx0ZnVuY3Rpb24gZ2VuZXJhdGVUb3JzbygpIHtcblx0XHRcdGNvbnN0IG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRjb25zdCB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0bGV0IGdyb3VwQ291bnQgPSAwO1xuXG5cdFx0XHQvLyB0aGlzIHdpbGwgYmUgdXNlZCB0byBjYWxjdWxhdGUgdGhlIG5vcm1hbFxuXHRcdFx0Y29uc3Qgc2xvcGUgPSAocmFkaXVzQm90dG9tIC0gcmFkaXVzVG9wKSAvIGhlaWdodDtcblxuXHRcdFx0Ly8gZ2VuZXJhdGUgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xuXG5cdFx0XHRmb3IgKGxldCB5ID0gMDsgeSA8PSBoZWlnaHRTZWdtZW50czsgeSsrKSB7XG5cdFx0XHRcdGNvbnN0IGluZGV4Um93ID0gW107XG5cdFx0XHRcdGNvbnN0IHYgPSB5IC8gaGVpZ2h0U2VnbWVudHM7XG5cblx0XHRcdFx0Ly8gY2FsY3VsYXRlIHRoZSByYWRpdXMgb2YgdGhlIGN1cnJlbnQgcm93XG5cblx0XHRcdFx0Y29uc3QgcmFkaXVzID0gdiAqIChyYWRpdXNCb3R0b20gLSByYWRpdXNUb3ApICsgcmFkaXVzVG9wO1xuXHRcdFx0XHRmb3IgKGxldCB4ID0gMDsgeCA8PSByYWRpYWxTZWdtZW50czsgeCsrKSB7XG5cdFx0XHRcdFx0Y29uc3QgdSA9IHggLyByYWRpYWxTZWdtZW50cztcblx0XHRcdFx0XHRjb25zdCB0aGV0YSA9IHUgKiB0aGV0YUxlbmd0aCArIHRoZXRhU3RhcnQ7XG5cdFx0XHRcdFx0Y29uc3Qgc2luVGhldGEgPSBNYXRoLnNpbih0aGV0YSk7XG5cdFx0XHRcdFx0Y29uc3QgY29zVGhldGEgPSBNYXRoLmNvcyh0aGV0YSk7XG5cblx0XHRcdFx0XHQvLyB2ZXJ0ZXhcblxuXHRcdFx0XHRcdHZlcnRleC54ID0gcmFkaXVzICogc2luVGhldGE7XG5cdFx0XHRcdFx0dmVydGV4LnkgPSAtdiAqIGhlaWdodCArIGhhbGZIZWlnaHQ7XG5cdFx0XHRcdFx0dmVydGV4LnogPSByYWRpdXMgKiBjb3NUaGV0YTtcblx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnopO1xuXG5cdFx0XHRcdFx0Ly8gbm9ybWFsXG5cblx0XHRcdFx0XHRub3JtYWwuc2V0KHNpblRoZXRhLCBzbG9wZSwgY29zVGhldGEpLm5vcm1hbGl6ZSgpO1xuXHRcdFx0XHRcdG5vcm1hbHMucHVzaChub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56KTtcblxuXHRcdFx0XHRcdC8vIHV2XG5cblx0XHRcdFx0XHR1dnMucHVzaCh1LCAxIC0gdik7XG5cblx0XHRcdFx0XHQvLyBzYXZlIGluZGV4IG9mIHZlcnRleCBpbiByZXNwZWN0aXZlIHJvd1xuXG5cdFx0XHRcdFx0aW5kZXhSb3cucHVzaChpbmRleCsrKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG5vdyBzYXZlIHZlcnRpY2VzIG9mIHRoZSByb3cgaW4gb3VyIGluZGV4IGFycmF5XG5cblx0XHRcdFx0aW5kZXhBcnJheS5wdXNoKGluZGV4Um93KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZ2VuZXJhdGUgaW5kaWNlc1xuXG5cdFx0XHRmb3IgKGxldCB4ID0gMDsgeCA8IHJhZGlhbFNlZ21lbnRzOyB4KyspIHtcblx0XHRcdFx0Zm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHRTZWdtZW50czsgeSsrKSB7XG5cdFx0XHRcdFx0Ly8gd2UgdXNlIHRoZSBpbmRleCBhcnJheSB0byBhY2Nlc3MgdGhlIGNvcnJlY3QgaW5kaWNlc1xuXG5cdFx0XHRcdFx0Y29uc3QgYSA9IGluZGV4QXJyYXlbeV1beF07XG5cdFx0XHRcdFx0Y29uc3QgYiA9IGluZGV4QXJyYXlbeSArIDFdW3hdO1xuXHRcdFx0XHRcdGNvbnN0IGMgPSBpbmRleEFycmF5W3kgKyAxXVt4ICsgMV07XG5cdFx0XHRcdFx0Y29uc3QgZCA9IGluZGV4QXJyYXlbeV1beCArIDFdO1xuXG5cdFx0XHRcdFx0Ly8gZmFjZXNcblxuXHRcdFx0XHRcdGluZGljZXMucHVzaChhLCBiLCBkKTtcblx0XHRcdFx0XHRpbmRpY2VzLnB1c2goYiwgYywgZCk7XG5cblx0XHRcdFx0XHQvLyB1cGRhdGUgZ3JvdXAgY291bnRlclxuXG5cdFx0XHRcdFx0Z3JvdXBDb3VudCArPSA2O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGFkZCBhIGdyb3VwIHRvIHRoZSBnZW9tZXRyeS4gdGhpcyB3aWxsIGVuc3VyZSBtdWx0aSBtYXRlcmlhbCBzdXBwb3J0XG5cblx0XHRcdHNjb3BlLmFkZEdyb3VwKGdyb3VwU3RhcnQsIGdyb3VwQ291bnQsIDApO1xuXG5cdFx0XHQvLyBjYWxjdWxhdGUgbmV3IHN0YXJ0IHZhbHVlIGZvciBncm91cHNcblxuXHRcdFx0Z3JvdXBTdGFydCArPSBncm91cENvdW50O1xuXHRcdH1cblx0XHRmdW5jdGlvbiBnZW5lcmF0ZUNhcCh0b3ApIHtcblx0XHRcdC8vIHNhdmUgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBjZW50ZXIgdmVydGV4XG5cdFx0XHRjb25zdCBjZW50ZXJJbmRleFN0YXJ0ID0gaW5kZXg7XG5cdFx0XHRjb25zdCB1diA9IG5ldyBWZWN0b3IyKCk7XG5cdFx0XHRjb25zdCB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0bGV0IGdyb3VwQ291bnQgPSAwO1xuXHRcdFx0Y29uc3QgcmFkaXVzID0gdG9wID09PSB0cnVlID8gcmFkaXVzVG9wIDogcmFkaXVzQm90dG9tO1xuXHRcdFx0Y29uc3Qgc2lnbiA9IHRvcCA9PT0gdHJ1ZSA/IDEgOiAtMTtcblxuXHRcdFx0Ly8gZmlyc3Qgd2UgZ2VuZXJhdGUgdGhlIGNlbnRlciB2ZXJ0ZXggZGF0YSBvZiB0aGUgY2FwLlxuXHRcdFx0Ly8gYmVjYXVzZSB0aGUgZ2VvbWV0cnkgbmVlZHMgb25lIHNldCBvZiB1dnMgcGVyIGZhY2UsXG5cdFx0XHQvLyB3ZSBtdXN0IGdlbmVyYXRlIGEgY2VudGVyIHZlcnRleCBwZXIgZmFjZS9zZWdtZW50XG5cblx0XHRcdGZvciAobGV0IHggPSAxOyB4IDw9IHJhZGlhbFNlZ21lbnRzOyB4KyspIHtcblx0XHRcdFx0Ly8gdmVydGV4XG5cblx0XHRcdFx0dmVydGljZXMucHVzaCgwLCBoYWxmSGVpZ2h0ICogc2lnbiwgMCk7XG5cblx0XHRcdFx0Ly8gbm9ybWFsXG5cblx0XHRcdFx0bm9ybWFscy5wdXNoKDAsIHNpZ24sIDApO1xuXG5cdFx0XHRcdC8vIHV2XG5cblx0XHRcdFx0dXZzLnB1c2goMC41LCAwLjUpO1xuXG5cdFx0XHRcdC8vIGluY3JlYXNlIGluZGV4XG5cblx0XHRcdFx0aW5kZXgrKztcblx0XHRcdH1cblxuXHRcdFx0Ly8gc2F2ZSB0aGUgaW5kZXggb2YgdGhlIGxhc3QgY2VudGVyIHZlcnRleFxuXHRcdFx0Y29uc3QgY2VudGVySW5kZXhFbmQgPSBpbmRleDtcblxuXHRcdFx0Ly8gbm93IHdlIGdlbmVyYXRlIHRoZSBzdXJyb3VuZGluZyB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdXZzXG5cblx0XHRcdGZvciAobGV0IHggPSAwOyB4IDw9IHJhZGlhbFNlZ21lbnRzOyB4KyspIHtcblx0XHRcdFx0Y29uc3QgdSA9IHggLyByYWRpYWxTZWdtZW50cztcblx0XHRcdFx0Y29uc3QgdGhldGEgPSB1ICogdGhldGFMZW5ndGggKyB0aGV0YVN0YXJ0O1xuXHRcdFx0XHRjb25zdCBjb3NUaGV0YSA9IE1hdGguY29zKHRoZXRhKTtcblx0XHRcdFx0Y29uc3Qgc2luVGhldGEgPSBNYXRoLnNpbih0aGV0YSk7XG5cblx0XHRcdFx0Ly8gdmVydGV4XG5cblx0XHRcdFx0dmVydGV4LnggPSByYWRpdXMgKiBzaW5UaGV0YTtcblx0XHRcdFx0dmVydGV4LnkgPSBoYWxmSGVpZ2h0ICogc2lnbjtcblx0XHRcdFx0dmVydGV4LnogPSByYWRpdXMgKiBjb3NUaGV0YTtcblx0XHRcdFx0dmVydGljZXMucHVzaCh2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56KTtcblxuXHRcdFx0XHQvLyBub3JtYWxcblxuXHRcdFx0XHRub3JtYWxzLnB1c2goMCwgc2lnbiwgMCk7XG5cblx0XHRcdFx0Ly8gdXZcblxuXHRcdFx0XHR1di54ID0gY29zVGhldGEgKiAwLjUgKyAwLjU7XG5cdFx0XHRcdHV2LnkgPSBzaW5UaGV0YSAqIDAuNSAqIHNpZ24gKyAwLjU7XG5cdFx0XHRcdHV2cy5wdXNoKHV2LngsIHV2LnkpO1xuXG5cdFx0XHRcdC8vIGluY3JlYXNlIGluZGV4XG5cblx0XHRcdFx0aW5kZXgrKztcblx0XHRcdH1cblxuXHRcdFx0Ly8gZ2VuZXJhdGUgaW5kaWNlc1xuXG5cdFx0XHRmb3IgKGxldCB4ID0gMDsgeCA8IHJhZGlhbFNlZ21lbnRzOyB4KyspIHtcblx0XHRcdFx0Y29uc3QgYyA9IGNlbnRlckluZGV4U3RhcnQgKyB4O1xuXHRcdFx0XHRjb25zdCBpID0gY2VudGVySW5kZXhFbmQgKyB4O1xuXHRcdFx0XHRpZiAodG9wID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0Ly8gZmFjZSB0b3BcblxuXHRcdFx0XHRcdGluZGljZXMucHVzaChpLCBpICsgMSwgYyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gZmFjZSBib3R0b21cblxuXHRcdFx0XHRcdGluZGljZXMucHVzaChpICsgMSwgaSwgYyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Z3JvdXBDb3VudCArPSAzO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBhZGQgYSBncm91cCB0byB0aGUgZ2VvbWV0cnkuIHRoaXMgd2lsbCBlbnN1cmUgbXVsdGkgbWF0ZXJpYWwgc3VwcG9ydFxuXG5cdFx0XHRzY29wZS5hZGRHcm91cChncm91cFN0YXJ0LCBncm91cENvdW50LCB0b3AgPT09IHRydWUgPyAxIDogMik7XG5cblx0XHRcdC8vIGNhbGN1bGF0ZSBuZXcgc3RhcnQgdmFsdWUgZm9yIGdyb3Vwc1xuXG5cdFx0XHRncm91cFN0YXJ0ICs9IGdyb3VwQ291bnQ7XG5cdFx0fVxuXHR9XG5cdHN0YXRpYyBmcm9tSlNPTihkYXRhKSB7XG5cdFx0cmV0dXJuIG5ldyBDeWxpbmRlckdlb21ldHJ5KGRhdGEucmFkaXVzVG9wLCBkYXRhLnJhZGl1c0JvdHRvbSwgZGF0YS5oZWlnaHQsIGRhdGEucmFkaWFsU2VnbWVudHMsIGRhdGEuaGVpZ2h0U2VnbWVudHMsIGRhdGEub3BlbkVuZGVkLCBkYXRhLnRoZXRhU3RhcnQsIGRhdGEudGhldGFMZW5ndGgpO1xuXHR9XG59XG5cbmNsYXNzIENvbmVHZW9tZXRyeSBleHRlbmRzIEN5bGluZGVyR2VvbWV0cnkge1xuXHRjb25zdHJ1Y3RvcihyYWRpdXMgPSAxLCBoZWlnaHQgPSAxLCByYWRpYWxTZWdtZW50cyA9IDgsIGhlaWdodFNlZ21lbnRzID0gMSwgb3BlbkVuZGVkID0gZmFsc2UsIHRoZXRhU3RhcnQgPSAwLCB0aGV0YUxlbmd0aCA9IE1hdGguUEkgKiAyKSB7XG5cdFx0c3VwZXIoMCwgcmFkaXVzLCBoZWlnaHQsIHJhZGlhbFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgb3BlbkVuZGVkLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCk7XG5cdFx0dGhpcy50eXBlID0gJ0NvbmVHZW9tZXRyeSc7XG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRoZWlnaHQ6IGhlaWdodCxcblx0XHRcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcblx0XHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcblx0XHRcdG9wZW5FbmRlZDogb3BlbkVuZGVkLFxuXHRcdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcblx0XHRcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxuXHRcdH07XG5cdH1cblx0c3RhdGljIGZyb21KU09OKGRhdGEpIHtcblx0XHRyZXR1cm4gbmV3IENvbmVHZW9tZXRyeShkYXRhLnJhZGl1cywgZGF0YS5oZWlnaHQsIGRhdGEucmFkaWFsU2VnbWVudHMsIGRhdGEuaGVpZ2h0U2VnbWVudHMsIGRhdGEub3BlbkVuZGVkLCBkYXRhLnRoZXRhU3RhcnQsIGRhdGEudGhldGFMZW5ndGgpO1xuXHR9XG59XG5cbmNsYXNzIFBvbHloZWRyb25HZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblx0Y29uc3RydWN0b3IodmVydGljZXMgPSBbXSwgaW5kaWNlcyA9IFtdLCByYWRpdXMgPSAxLCBkZXRhaWwgPSAwKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLnR5cGUgPSAnUG9seWhlZHJvbkdlb21ldHJ5Jztcblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHR2ZXJ0aWNlczogdmVydGljZXMsXG5cdFx0XHRpbmRpY2VzOiBpbmRpY2VzLFxuXHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRkZXRhaWw6IGRldGFpbFxuXHRcdH07XG5cblx0XHQvLyBkZWZhdWx0IGJ1ZmZlciBkYXRhXG5cblx0XHRjb25zdCB2ZXJ0ZXhCdWZmZXIgPSBbXTtcblx0XHRjb25zdCB1dkJ1ZmZlciA9IFtdO1xuXG5cdFx0Ly8gdGhlIHN1YmRpdmlzaW9uIGNyZWF0ZXMgdGhlIHZlcnRleCBidWZmZXIgZGF0YVxuXG5cdFx0c3ViZGl2aWRlKGRldGFpbCk7XG5cblx0XHQvLyBhbGwgdmVydGljZXMgc2hvdWxkIGxpZSBvbiBhIGNvbmNlcHR1YWwgc3BoZXJlIHdpdGggYSBnaXZlbiByYWRpdXNcblxuXHRcdGFwcGx5UmFkaXVzKHJhZGl1cyk7XG5cblx0XHQvLyBmaW5hbGx5LCBjcmVhdGUgdGhlIHV2IGRhdGFcblxuXHRcdGdlbmVyYXRlVVZzKCk7XG5cblx0XHQvLyBidWlsZCBub24taW5kZXhlZCBnZW9tZXRyeVxuXG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodmVydGV4QnVmZmVyLCAzKSk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHZlcnRleEJ1ZmZlci5zbGljZSgpLCAzKSk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodXZCdWZmZXIsIDIpKTtcblx0XHRpZiAoZGV0YWlsID09PSAwKSB7XG5cdFx0XHR0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7IC8vIGZsYXQgbm9ybWFsc1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLm5vcm1hbGl6ZU5vcm1hbHMoKTsgLy8gc21vb3RoIG5vcm1hbHNcblx0XHR9XG5cblx0XHQvLyBoZWxwZXIgZnVuY3Rpb25zXG5cblx0XHRmdW5jdGlvbiBzdWJkaXZpZGUoZGV0YWlsKSB7XG5cdFx0XHRjb25zdCBhID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdGNvbnN0IGIgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0Y29uc3QgYyA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdC8vIGl0ZXJhdGUgb3ZlciBhbGwgZmFjZXMgYW5kIGFwcGx5IGEgc3ViZGl2aXNvbiB3aXRoIHRoZSBnaXZlbiBkZXRhaWwgdmFsdWVcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHRcdC8vIGdldCB0aGUgdmVydGljZXMgb2YgdGhlIGZhY2VcblxuXHRcdFx0XHRnZXRWZXJ0ZXhCeUluZGV4KGluZGljZXNbaSArIDBdLCBhKTtcblx0XHRcdFx0Z2V0VmVydGV4QnlJbmRleChpbmRpY2VzW2kgKyAxXSwgYik7XG5cdFx0XHRcdGdldFZlcnRleEJ5SW5kZXgoaW5kaWNlc1tpICsgMl0sIGMpO1xuXG5cdFx0XHRcdC8vIHBlcmZvcm0gc3ViZGl2aXNpb25cblxuXHRcdFx0XHRzdWJkaXZpZGVGYWNlKGEsIGIsIGMsIGRldGFpbCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIHN1YmRpdmlkZUZhY2UoYSwgYiwgYywgZGV0YWlsKSB7XG5cdFx0XHRjb25zdCBjb2xzID0gZGV0YWlsICsgMTtcblxuXHRcdFx0Ly8gd2UgdXNlIHRoaXMgbXVsdGlkaW1lbnNpb25hbCBhcnJheSBhcyBhIGRhdGEgc3RydWN0dXJlIGZvciBjcmVhdGluZyB0aGUgc3ViZGl2aXNpb25cblxuXHRcdFx0Y29uc3QgdiA9IFtdO1xuXG5cdFx0XHQvLyBjb25zdHJ1Y3QgYWxsIG9mIHRoZSB2ZXJ0aWNlcyBmb3IgdGhpcyBzdWJkaXZpc2lvblxuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8PSBjb2xzOyBpKyspIHtcblx0XHRcdFx0dltpXSA9IFtdO1xuXHRcdFx0XHRjb25zdCBhaiA9IGEuY2xvbmUoKS5sZXJwKGMsIGkgLyBjb2xzKTtcblx0XHRcdFx0Y29uc3QgYmogPSBiLmNsb25lKCkubGVycChjLCBpIC8gY29scyk7XG5cdFx0XHRcdGNvbnN0IHJvd3MgPSBjb2xzIC0gaTtcblx0XHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPD0gcm93czsgaisrKSB7XG5cdFx0XHRcdFx0aWYgKGogPT09IDAgJiYgaSA9PT0gY29scykge1xuXHRcdFx0XHRcdFx0dltpXVtqXSA9IGFqO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR2W2ldW2pdID0gYWouY2xvbmUoKS5sZXJwKGJqLCBqIC8gcm93cyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNvbnN0cnVjdCBhbGwgb2YgdGhlIGZhY2VzXG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgY29sczsgaSsrKSB7XG5cdFx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgMiAqIChjb2xzIC0gaSkgLSAxOyBqKyspIHtcblx0XHRcdFx0XHRjb25zdCBrID0gTWF0aC5mbG9vcihqIC8gMik7XG5cdFx0XHRcdFx0aWYgKGogJSAyID09PSAwKSB7XG5cdFx0XHRcdFx0XHRwdXNoVmVydGV4KHZbaV1bayArIDFdKTtcblx0XHRcdFx0XHRcdHB1c2hWZXJ0ZXgodltpICsgMV1ba10pO1xuXHRcdFx0XHRcdFx0cHVzaFZlcnRleCh2W2ldW2tdKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cHVzaFZlcnRleCh2W2ldW2sgKyAxXSk7XG5cdFx0XHRcdFx0XHRwdXNoVmVydGV4KHZbaSArIDFdW2sgKyAxXSk7XG5cdFx0XHRcdFx0XHRwdXNoVmVydGV4KHZbaSArIDFdW2tdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZnVuY3Rpb24gYXBwbHlSYWRpdXMocmFkaXVzKSB7XG5cdFx0XHRjb25zdCB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHQvLyBpdGVyYXRlIG92ZXIgdGhlIGVudGlyZSBidWZmZXIgYW5kIGFwcGx5IHRoZSByYWRpdXMgdG8gZWFjaCB2ZXJ0ZXhcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0ZXhCdWZmZXIubGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdFx0dmVydGV4LnggPSB2ZXJ0ZXhCdWZmZXJbaSArIDBdO1xuXHRcdFx0XHR2ZXJ0ZXgueSA9IHZlcnRleEJ1ZmZlcltpICsgMV07XG5cdFx0XHRcdHZlcnRleC56ID0gdmVydGV4QnVmZmVyW2kgKyAyXTtcblx0XHRcdFx0dmVydGV4Lm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKHJhZGl1cyk7XG5cdFx0XHRcdHZlcnRleEJ1ZmZlcltpICsgMF0gPSB2ZXJ0ZXgueDtcblx0XHRcdFx0dmVydGV4QnVmZmVyW2kgKyAxXSA9IHZlcnRleC55O1xuXHRcdFx0XHR2ZXJ0ZXhCdWZmZXJbaSArIDJdID0gdmVydGV4Lno7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIGdlbmVyYXRlVVZzKCkge1xuXHRcdFx0Y29uc3QgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdmVydGV4QnVmZmVyLmxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHRcdHZlcnRleC54ID0gdmVydGV4QnVmZmVyW2kgKyAwXTtcblx0XHRcdFx0dmVydGV4LnkgPSB2ZXJ0ZXhCdWZmZXJbaSArIDFdO1xuXHRcdFx0XHR2ZXJ0ZXgueiA9IHZlcnRleEJ1ZmZlcltpICsgMl07XG5cdFx0XHRcdGNvbnN0IHUgPSBhemltdXRoKHZlcnRleCkgLyAyIC8gTWF0aC5QSSArIDAuNTtcblx0XHRcdFx0Y29uc3QgdiA9IGluY2xpbmF0aW9uKHZlcnRleCkgLyBNYXRoLlBJICsgMC41O1xuXHRcdFx0XHR1dkJ1ZmZlci5wdXNoKHUsIDEgLSB2KTtcblx0XHRcdH1cblx0XHRcdGNvcnJlY3RVVnMoKTtcblx0XHRcdGNvcnJlY3RTZWFtKCk7XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIGNvcnJlY3RTZWFtKCkge1xuXHRcdFx0Ly8gaGFuZGxlIGNhc2Ugd2hlbiBmYWNlIHN0cmFkZGxlcyB0aGUgc2VhbSwgc2VlICMzMjY5XG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdXZCdWZmZXIubGVuZ3RoOyBpICs9IDYpIHtcblx0XHRcdFx0Ly8gdXYgZGF0YSBvZiBhIHNpbmdsZSBmYWNlXG5cblx0XHRcdFx0Y29uc3QgeDAgPSB1dkJ1ZmZlcltpICsgMF07XG5cdFx0XHRcdGNvbnN0IHgxID0gdXZCdWZmZXJbaSArIDJdO1xuXHRcdFx0XHRjb25zdCB4MiA9IHV2QnVmZmVyW2kgKyA0XTtcblx0XHRcdFx0Y29uc3QgbWF4ID0gTWF0aC5tYXgoeDAsIHgxLCB4Mik7XG5cdFx0XHRcdGNvbnN0IG1pbiA9IE1hdGgubWluKHgwLCB4MSwgeDIpO1xuXG5cdFx0XHRcdC8vIDAuOSBpcyBzb21ld2hhdCBhcmJpdHJhcnlcblxuXHRcdFx0XHRpZiAobWF4ID4gMC45ICYmIG1pbiA8IDAuMSkge1xuXHRcdFx0XHRcdGlmICh4MCA8IDAuMikgdXZCdWZmZXJbaSArIDBdICs9IDE7XG5cdFx0XHRcdFx0aWYgKHgxIDwgMC4yKSB1dkJ1ZmZlcltpICsgMl0gKz0gMTtcblx0XHRcdFx0XHRpZiAoeDIgPCAwLjIpIHV2QnVmZmVyW2kgKyA0XSArPSAxO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIHB1c2hWZXJ0ZXgodmVydGV4KSB7XG5cdFx0XHR2ZXJ0ZXhCdWZmZXIucHVzaCh2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56KTtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gZ2V0VmVydGV4QnlJbmRleChpbmRleCwgdmVydGV4KSB7XG5cdFx0XHRjb25zdCBzdHJpZGUgPSBpbmRleCAqIDM7XG5cdFx0XHR2ZXJ0ZXgueCA9IHZlcnRpY2VzW3N0cmlkZSArIDBdO1xuXHRcdFx0dmVydGV4LnkgPSB2ZXJ0aWNlc1tzdHJpZGUgKyAxXTtcblx0XHRcdHZlcnRleC56ID0gdmVydGljZXNbc3RyaWRlICsgMl07XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIGNvcnJlY3RVVnMoKSB7XG5cdFx0XHRjb25zdCBhID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdGNvbnN0IGIgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0Y29uc3QgYyA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRjb25zdCBjZW50cm9pZCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRjb25zdCB1dkEgPSBuZXcgVmVjdG9yMigpO1xuXHRcdFx0Y29uc3QgdXZCID0gbmV3IFZlY3RvcjIoKTtcblx0XHRcdGNvbnN0IHV2QyA9IG5ldyBWZWN0b3IyKCk7XG5cdFx0XHRmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCB2ZXJ0ZXhCdWZmZXIubGVuZ3RoOyBpICs9IDksIGogKz0gNikge1xuXHRcdFx0XHRhLnNldCh2ZXJ0ZXhCdWZmZXJbaSArIDBdLCB2ZXJ0ZXhCdWZmZXJbaSArIDFdLCB2ZXJ0ZXhCdWZmZXJbaSArIDJdKTtcblx0XHRcdFx0Yi5zZXQodmVydGV4QnVmZmVyW2kgKyAzXSwgdmVydGV4QnVmZmVyW2kgKyA0XSwgdmVydGV4QnVmZmVyW2kgKyA1XSk7XG5cdFx0XHRcdGMuc2V0KHZlcnRleEJ1ZmZlcltpICsgNl0sIHZlcnRleEJ1ZmZlcltpICsgN10sIHZlcnRleEJ1ZmZlcltpICsgOF0pO1xuXHRcdFx0XHR1dkEuc2V0KHV2QnVmZmVyW2ogKyAwXSwgdXZCdWZmZXJbaiArIDFdKTtcblx0XHRcdFx0dXZCLnNldCh1dkJ1ZmZlcltqICsgMl0sIHV2QnVmZmVyW2ogKyAzXSk7XG5cdFx0XHRcdHV2Qy5zZXQodXZCdWZmZXJbaiArIDRdLCB1dkJ1ZmZlcltqICsgNV0pO1xuXHRcdFx0XHRjZW50cm9pZC5jb3B5KGEpLmFkZChiKS5hZGQoYykuZGl2aWRlU2NhbGFyKDMpO1xuXHRcdFx0XHRjb25zdCBhemkgPSBhemltdXRoKGNlbnRyb2lkKTtcblx0XHRcdFx0Y29ycmVjdFVWKHV2QSwgaiArIDAsIGEsIGF6aSk7XG5cdFx0XHRcdGNvcnJlY3RVVih1dkIsIGogKyAyLCBiLCBhemkpO1xuXHRcdFx0XHRjb3JyZWN0VVYodXZDLCBqICsgNCwgYywgYXppKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZnVuY3Rpb24gY29ycmVjdFVWKHV2LCBzdHJpZGUsIHZlY3RvciwgYXppbXV0aCkge1xuXHRcdFx0aWYgKGF6aW11dGggPCAwICYmIHV2LnggPT09IDEpIHtcblx0XHRcdFx0dXZCdWZmZXJbc3RyaWRlXSA9IHV2LnggLSAxO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHZlY3Rvci54ID09PSAwICYmIHZlY3Rvci56ID09PSAwKSB7XG5cdFx0XHRcdHV2QnVmZmVyW3N0cmlkZV0gPSBhemltdXRoIC8gMiAvIE1hdGguUEkgKyAwLjU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQW5nbGUgYXJvdW5kIHRoZSBZIGF4aXMsIGNvdW50ZXItY2xvY2t3aXNlIHdoZW4gbG9va2luZyBmcm9tIGFib3ZlLlxuXG5cdFx0ZnVuY3Rpb24gYXppbXV0aCh2ZWN0b3IpIHtcblx0XHRcdHJldHVybiBNYXRoLmF0YW4yKHZlY3Rvci56LCAtdmVjdG9yLngpO1xuXHRcdH1cblxuXHRcdC8vIEFuZ2xlIGFib3ZlIHRoZSBYWiBwbGFuZS5cblxuXHRcdGZ1bmN0aW9uIGluY2xpbmF0aW9uKHZlY3Rvcikge1xuXHRcdFx0cmV0dXJuIE1hdGguYXRhbjIoLXZlY3Rvci55LCBNYXRoLnNxcnQodmVjdG9yLnggKiB2ZWN0b3IueCArIHZlY3Rvci56ICogdmVjdG9yLnopKTtcblx0XHR9XG5cdH1cblx0c3RhdGljIGZyb21KU09OKGRhdGEpIHtcblx0XHRyZXR1cm4gbmV3IFBvbHloZWRyb25HZW9tZXRyeShkYXRhLnZlcnRpY2VzLCBkYXRhLmluZGljZXMsIGRhdGEucmFkaXVzLCBkYXRhLmRldGFpbHMpO1xuXHR9XG59XG5cbmNsYXNzIERvZGVjYWhlZHJvbkdlb21ldHJ5IGV4dGVuZHMgUG9seWhlZHJvbkdlb21ldHJ5IHtcblx0Y29uc3RydWN0b3IocmFkaXVzID0gMSwgZGV0YWlsID0gMCkge1xuXHRcdGNvbnN0IHQgPSAoMSArIE1hdGguc3FydCg1KSkgLyAyO1xuXHRcdGNvbnN0IHIgPSAxIC8gdDtcblx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtcblx0XHQvLyAowrExLCDCsTEsIMKxMSlcblx0XHQtMSwgLTEsIC0xLCAtMSwgLTEsIDEsIC0xLCAxLCAtMSwgLTEsIDEsIDEsIDEsIC0xLCAtMSwgMSwgLTEsIDEsIDEsIDEsIC0xLCAxLCAxLCAxLFxuXHRcdC8vICgwLCDCsTEvz4YsIMKxz4YpXG5cdFx0MCwgLXIsIC10LCAwLCAtciwgdCwgMCwgciwgLXQsIDAsIHIsIHQsXG5cdFx0Ly8gKMKxMS/PhiwgwrHPhiwgMClcblx0XHQtciwgLXQsIDAsIC1yLCB0LCAwLCByLCAtdCwgMCwgciwgdCwgMCxcblx0XHQvLyAowrHPhiwgMCwgwrExL8+GKVxuXHRcdC10LCAwLCAtciwgdCwgMCwgLXIsIC10LCAwLCByLCB0LCAwLCByXTtcblx0XHRjb25zdCBpbmRpY2VzID0gWzMsIDExLCA3LCAzLCA3LCAxNSwgMywgMTUsIDEzLCA3LCAxOSwgMTcsIDcsIDE3LCA2LCA3LCA2LCAxNSwgMTcsIDQsIDgsIDE3LCA4LCAxMCwgMTcsIDEwLCA2LCA4LCAwLCAxNiwgOCwgMTYsIDIsIDgsIDIsIDEwLCAwLCAxMiwgMSwgMCwgMSwgMTgsIDAsIDE4LCAxNiwgNiwgMTAsIDIsIDYsIDIsIDEzLCA2LCAxMywgMTUsIDIsIDE2LCAxOCwgMiwgMTgsIDMsIDIsIDMsIDEzLCAxOCwgMSwgOSwgMTgsIDksIDExLCAxOCwgMTEsIDMsIDQsIDE0LCAxMiwgNCwgMTIsIDAsIDQsIDAsIDgsIDExLCA5LCA1LCAxMSwgNSwgMTksIDExLCAxOSwgNywgMTksIDUsIDE0LCAxOSwgMTQsIDQsIDE5LCA0LCAxNywgMSwgMTIsIDE0LCAxLCAxNCwgNSwgMSwgNSwgOV07XG5cdFx0c3VwZXIodmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsKTtcblx0XHR0aGlzLnR5cGUgPSAnRG9kZWNhaGVkcm9uR2VvbWV0cnknO1xuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdFx0ZGV0YWlsOiBkZXRhaWxcblx0XHR9O1xuXHR9XG5cdHN0YXRpYyBmcm9tSlNPTihkYXRhKSB7XG5cdFx0cmV0dXJuIG5ldyBEb2RlY2FoZWRyb25HZW9tZXRyeShkYXRhLnJhZGl1cywgZGF0YS5kZXRhaWwpO1xuXHR9XG59XG5cbmNvbnN0IF92MCA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuY29uc3QgX3YxJDEgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9ub3JtYWwgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF90cmlhbmdsZSA9IC8qQF9fUFVSRV9fKi9uZXcgVHJpYW5nbGUoKTtcbmNsYXNzIEVkZ2VzR2VvbWV0cnkgZXh0ZW5kcyBCdWZmZXJHZW9tZXRyeSB7XG5cdGNvbnN0cnVjdG9yKGdlb21ldHJ5ID0gbnVsbCwgdGhyZXNob2xkQW5nbGUgPSAxKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLnR5cGUgPSAnRWRnZXNHZW9tZXRyeSc7XG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0Z2VvbWV0cnk6IGdlb21ldHJ5LFxuXHRcdFx0dGhyZXNob2xkQW5nbGU6IHRocmVzaG9sZEFuZ2xlXG5cdFx0fTtcblx0XHRpZiAoZ2VvbWV0cnkgIT09IG51bGwpIHtcblx0XHRcdGNvbnN0IHByZWNpc2lvblBvaW50cyA9IDQ7XG5cdFx0XHRjb25zdCBwcmVjaXNpb24gPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uUG9pbnRzKTtcblx0XHRcdGNvbnN0IHRocmVzaG9sZERvdCA9IE1hdGguY29zKERFRzJSQUQgKiB0aHJlc2hvbGRBbmdsZSk7XG5cdFx0XHRjb25zdCBpbmRleEF0dHIgPSBnZW9tZXRyeS5nZXRJbmRleCgpO1xuXHRcdFx0Y29uc3QgcG9zaXRpb25BdHRyID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCdwb3NpdGlvbicpO1xuXHRcdFx0Y29uc3QgaW5kZXhDb3VudCA9IGluZGV4QXR0ciA/IGluZGV4QXR0ci5jb3VudCA6IHBvc2l0aW9uQXR0ci5jb3VudDtcblx0XHRcdGNvbnN0IGluZGV4QXJyID0gWzAsIDAsIDBdO1xuXHRcdFx0Y29uc3QgdmVydEtleXMgPSBbJ2EnLCAnYicsICdjJ107XG5cdFx0XHRjb25zdCBoYXNoZXMgPSBuZXcgQXJyYXkoMyk7XG5cdFx0XHRjb25zdCBlZGdlRGF0YSA9IHt9O1xuXHRcdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXhDb3VudDsgaSArPSAzKSB7XG5cdFx0XHRcdGlmIChpbmRleEF0dHIpIHtcblx0XHRcdFx0XHRpbmRleEFyclswXSA9IGluZGV4QXR0ci5nZXRYKGkpO1xuXHRcdFx0XHRcdGluZGV4QXJyWzFdID0gaW5kZXhBdHRyLmdldFgoaSArIDEpO1xuXHRcdFx0XHRcdGluZGV4QXJyWzJdID0gaW5kZXhBdHRyLmdldFgoaSArIDIpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGluZGV4QXJyWzBdID0gaTtcblx0XHRcdFx0XHRpbmRleEFyclsxXSA9IGkgKyAxO1xuXHRcdFx0XHRcdGluZGV4QXJyWzJdID0gaSArIDI7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29uc3Qge1xuXHRcdFx0XHRcdGEsXG5cdFx0XHRcdFx0Yixcblx0XHRcdFx0XHRjXG5cdFx0XHRcdH0gPSBfdHJpYW5nbGU7XG5cdFx0XHRcdGEuZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbkF0dHIsIGluZGV4QXJyWzBdKTtcblx0XHRcdFx0Yi5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uQXR0ciwgaW5kZXhBcnJbMV0pO1xuXHRcdFx0XHRjLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25BdHRyLCBpbmRleEFyclsyXSk7XG5cdFx0XHRcdF90cmlhbmdsZS5nZXROb3JtYWwoX25vcm1hbCk7XG5cblx0XHRcdFx0Ly8gY3JlYXRlIGhhc2hlcyBmb3IgdGhlIGVkZ2UgZnJvbSB0aGUgdmVydGljZXNcblx0XHRcdFx0aGFzaGVzWzBdID0gYCR7TWF0aC5yb3VuZChhLnggKiBwcmVjaXNpb24pfSwke01hdGgucm91bmQoYS55ICogcHJlY2lzaW9uKX0sJHtNYXRoLnJvdW5kKGEueiAqIHByZWNpc2lvbil9YDtcblx0XHRcdFx0aGFzaGVzWzFdID0gYCR7TWF0aC5yb3VuZChiLnggKiBwcmVjaXNpb24pfSwke01hdGgucm91bmQoYi55ICogcHJlY2lzaW9uKX0sJHtNYXRoLnJvdW5kKGIueiAqIHByZWNpc2lvbil9YDtcblx0XHRcdFx0aGFzaGVzWzJdID0gYCR7TWF0aC5yb3VuZChjLnggKiBwcmVjaXNpb24pfSwke01hdGgucm91bmQoYy55ICogcHJlY2lzaW9uKX0sJHtNYXRoLnJvdW5kKGMueiAqIHByZWNpc2lvbil9YDtcblxuXHRcdFx0XHQvLyBza2lwIGRlZ2VuZXJhdGUgdHJpYW5nbGVzXG5cdFx0XHRcdGlmIChoYXNoZXNbMF0gPT09IGhhc2hlc1sxXSB8fCBoYXNoZXNbMV0gPT09IGhhc2hlc1syXSB8fCBoYXNoZXNbMl0gPT09IGhhc2hlc1swXSkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaXRlcmF0ZSBvdmVyIGV2ZXJ5IGVkZ2Vcblx0XHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCAzOyBqKyspIHtcblx0XHRcdFx0XHQvLyBnZXQgdGhlIGZpcnN0IGFuZCBuZXh0IHZlcnRleCBtYWtpbmcgdXAgdGhlIGVkZ2Vcblx0XHRcdFx0XHRjb25zdCBqTmV4dCA9IChqICsgMSkgJSAzO1xuXHRcdFx0XHRcdGNvbnN0IHZlY0hhc2gwID0gaGFzaGVzW2pdO1xuXHRcdFx0XHRcdGNvbnN0IHZlY0hhc2gxID0gaGFzaGVzW2pOZXh0XTtcblx0XHRcdFx0XHRjb25zdCB2MCA9IF90cmlhbmdsZVt2ZXJ0S2V5c1tqXV07XG5cdFx0XHRcdFx0Y29uc3QgdjEgPSBfdHJpYW5nbGVbdmVydEtleXNbak5leHRdXTtcblx0XHRcdFx0XHRjb25zdCBoYXNoID0gYCR7dmVjSGFzaDB9XyR7dmVjSGFzaDF9YDtcblx0XHRcdFx0XHRjb25zdCByZXZlcnNlSGFzaCA9IGAke3ZlY0hhc2gxfV8ke3ZlY0hhc2gwfWA7XG5cdFx0XHRcdFx0aWYgKHJldmVyc2VIYXNoIGluIGVkZ2VEYXRhICYmIGVkZ2VEYXRhW3JldmVyc2VIYXNoXSkge1xuXHRcdFx0XHRcdFx0Ly8gaWYgd2UgZm91bmQgYSBzaWJsaW5nIGVkZ2UgYWRkIGl0IGludG8gdGhlIHZlcnRleCBhcnJheSBpZlxuXHRcdFx0XHRcdFx0Ly8gaXQgbWVldHMgdGhlIGFuZ2xlIHRocmVzaG9sZCBhbmQgZGVsZXRlIHRoZSBlZGdlIGZyb20gdGhlIG1hcC5cblx0XHRcdFx0XHRcdGlmIChfbm9ybWFsLmRvdChlZGdlRGF0YVtyZXZlcnNlSGFzaF0ubm9ybWFsKSA8PSB0aHJlc2hvbGREb3QpIHtcblx0XHRcdFx0XHRcdFx0dmVydGljZXMucHVzaCh2MC54LCB2MC55LCB2MC56KTtcblx0XHRcdFx0XHRcdFx0dmVydGljZXMucHVzaCh2MS54LCB2MS55LCB2MS56KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVkZ2VEYXRhW3JldmVyc2VIYXNoXSA9IG51bGw7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICghKGhhc2ggaW4gZWRnZURhdGEpKSB7XG5cdFx0XHRcdFx0XHQvLyBpZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBlZGdlIGhlcmUgdGhlbiBza2lwIGFkZGluZyBhIG5ldyBvbmVcblx0XHRcdFx0XHRcdGVkZ2VEYXRhW2hhc2hdID0ge1xuXHRcdFx0XHRcdFx0XHRpbmRleDA6IGluZGV4QXJyW2pdLFxuXHRcdFx0XHRcdFx0XHRpbmRleDE6IGluZGV4QXJyW2pOZXh0XSxcblx0XHRcdFx0XHRcdFx0bm9ybWFsOiBfbm9ybWFsLmNsb25lKClcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGl0ZXJhdGUgb3ZlciBhbGwgcmVtYWluaW5nLCB1bm1hdGNoZWQgZWRnZXMgYW5kIGFkZCB0aGVtIHRvIHRoZSB2ZXJ0ZXggYXJyYXlcblx0XHRcdGZvciAoY29uc3Qga2V5IGluIGVkZ2VEYXRhKSB7XG5cdFx0XHRcdGlmIChlZGdlRGF0YVtrZXldKSB7XG5cdFx0XHRcdFx0Y29uc3Qge1xuXHRcdFx0XHRcdFx0aW5kZXgwLFxuXHRcdFx0XHRcdFx0aW5kZXgxXG5cdFx0XHRcdFx0fSA9IGVkZ2VEYXRhW2tleV07XG5cdFx0XHRcdFx0X3YwLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25BdHRyLCBpbmRleDApO1xuXHRcdFx0XHRcdF92MSQxLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25BdHRyLCBpbmRleDEpO1xuXHRcdFx0XHRcdHZlcnRpY2VzLnB1c2goX3YwLngsIF92MC55LCBfdjAueik7XG5cdFx0XHRcdFx0dmVydGljZXMucHVzaChfdjEkMS54LCBfdjEkMS55LCBfdjEkMS56KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodmVydGljZXMsIDMpKTtcblx0XHR9XG5cdH1cbn1cblxuY2xhc3MgU2hhcGUgZXh0ZW5kcyBQYXRoIHtcblx0Y29uc3RydWN0b3IocG9pbnRzKSB7XG5cdFx0c3VwZXIocG9pbnRzKTtcblx0XHR0aGlzLnV1aWQgPSBnZW5lcmF0ZVVVSUQoKTtcblx0XHR0aGlzLnR5cGUgPSAnU2hhcGUnO1xuXHRcdHRoaXMuaG9sZXMgPSBbXTtcblx0fVxuXHRnZXRQb2ludHNIb2xlcyhkaXZpc2lvbnMpIHtcblx0XHRjb25zdCBob2xlc1B0cyA9IFtdO1xuXHRcdGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5ob2xlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGhvbGVzUHRzW2ldID0gdGhpcy5ob2xlc1tpXS5nZXRQb2ludHMoZGl2aXNpb25zKTtcblx0XHR9XG5cdFx0cmV0dXJuIGhvbGVzUHRzO1xuXHR9XG5cblx0Ly8gZ2V0IHBvaW50cyBvZiBzaGFwZSBhbmQgaG9sZXMgKGtleXBvaW50cyBiYXNlZCBvbiBzZWdtZW50cyBwYXJhbWV0ZXIpXG5cblx0ZXh0cmFjdFBvaW50cyhkaXZpc2lvbnMpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2hhcGU6IHRoaXMuZ2V0UG9pbnRzKGRpdmlzaW9ucyksXG5cdFx0XHRob2xlczogdGhpcy5nZXRQb2ludHNIb2xlcyhkaXZpc2lvbnMpXG5cdFx0fTtcblx0fVxuXHRjb3B5KHNvdXJjZSkge1xuXHRcdHN1cGVyLmNvcHkoc291cmNlKTtcblx0XHR0aGlzLmhvbGVzID0gW107XG5cdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBzb3VyY2UuaG9sZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRjb25zdCBob2xlID0gc291cmNlLmhvbGVzW2ldO1xuXHRcdFx0dGhpcy5ob2xlcy5wdXNoKGhvbGUuY2xvbmUoKSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHRvSlNPTigpIHtcblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cdFx0ZGF0YS51dWlkID0gdGhpcy51dWlkO1xuXHRcdGRhdGEuaG9sZXMgPSBbXTtcblx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMuaG9sZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRjb25zdCBob2xlID0gdGhpcy5ob2xlc1tpXTtcblx0XHRcdGRhdGEuaG9sZXMucHVzaChob2xlLnRvSlNPTigpKTtcblx0XHR9XG5cdFx0cmV0dXJuIGRhdGE7XG5cdH1cblx0ZnJvbUpTT04oanNvbikge1xuXHRcdHN1cGVyLmZyb21KU09OKGpzb24pO1xuXHRcdHRoaXMudXVpZCA9IGpzb24udXVpZDtcblx0XHR0aGlzLmhvbGVzID0gW107XG5cdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBqc29uLmhvbGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0Y29uc3QgaG9sZSA9IGpzb24uaG9sZXNbaV07XG5cdFx0XHR0aGlzLmhvbGVzLnB1c2gobmV3IFBhdGgoKS5mcm9tSlNPTihob2xlKSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59XG5cbi8qKlxuICogUG9ydCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvZWFyY3V0ICh2Mi4yLjQpXG4gKi9cblxuY29uc3QgRWFyY3V0ID0ge1xuXHR0cmlhbmd1bGF0ZTogZnVuY3Rpb24gKGRhdGEsIGhvbGVJbmRpY2VzLCBkaW0gPSAyKSB7XG5cdFx0Y29uc3QgaGFzSG9sZXMgPSBob2xlSW5kaWNlcyAmJiBob2xlSW5kaWNlcy5sZW5ndGg7XG5cdFx0Y29uc3Qgb3V0ZXJMZW4gPSBoYXNIb2xlcyA/IGhvbGVJbmRpY2VzWzBdICogZGltIDogZGF0YS5sZW5ndGg7XG5cdFx0bGV0IG91dGVyTm9kZSA9IGxpbmtlZExpc3QoZGF0YSwgMCwgb3V0ZXJMZW4sIGRpbSwgdHJ1ZSk7XG5cdFx0Y29uc3QgdHJpYW5nbGVzID0gW107XG5cdFx0aWYgKCFvdXRlck5vZGUgfHwgb3V0ZXJOb2RlLm5leHQgPT09IG91dGVyTm9kZS5wcmV2KSByZXR1cm4gdHJpYW5nbGVzO1xuXHRcdGxldCBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZLCB4LCB5LCBpbnZTaXplO1xuXHRcdGlmIChoYXNIb2xlcykgb3V0ZXJOb2RlID0gZWxpbWluYXRlSG9sZXMoZGF0YSwgaG9sZUluZGljZXMsIG91dGVyTm9kZSwgZGltKTtcblxuXHRcdC8vIGlmIHRoZSBzaGFwZSBpcyBub3QgdG9vIHNpbXBsZSwgd2UnbGwgdXNlIHotb3JkZXIgY3VydmUgaGFzaCBsYXRlcjsgY2FsY3VsYXRlIHBvbHlnb24gYmJveFxuXHRcdGlmIChkYXRhLmxlbmd0aCA+IDgwICogZGltKSB7XG5cdFx0XHRtaW5YID0gbWF4WCA9IGRhdGFbMF07XG5cdFx0XHRtaW5ZID0gbWF4WSA9IGRhdGFbMV07XG5cdFx0XHRmb3IgKGxldCBpID0gZGltOyBpIDwgb3V0ZXJMZW47IGkgKz0gZGltKSB7XG5cdFx0XHRcdHggPSBkYXRhW2ldO1xuXHRcdFx0XHR5ID0gZGF0YVtpICsgMV07XG5cdFx0XHRcdGlmICh4IDwgbWluWCkgbWluWCA9IHg7XG5cdFx0XHRcdGlmICh5IDwgbWluWSkgbWluWSA9IHk7XG5cdFx0XHRcdGlmICh4ID4gbWF4WCkgbWF4WCA9IHg7XG5cdFx0XHRcdGlmICh5ID4gbWF4WSkgbWF4WSA9IHk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIG1pblgsIG1pblkgYW5kIGludlNpemUgYXJlIGxhdGVyIHVzZWQgdG8gdHJhbnNmb3JtIGNvb3JkcyBpbnRvIGludGVnZXJzIGZvciB6LW9yZGVyIGNhbGN1bGF0aW9uXG5cdFx0XHRpbnZTaXplID0gTWF0aC5tYXgobWF4WCAtIG1pblgsIG1heFkgLSBtaW5ZKTtcblx0XHRcdGludlNpemUgPSBpbnZTaXplICE9PSAwID8gMzI3NjcgLyBpbnZTaXplIDogMDtcblx0XHR9XG5cdFx0ZWFyY3V0TGlua2VkKG91dGVyTm9kZSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDApO1xuXHRcdHJldHVybiB0cmlhbmdsZXM7XG5cdH1cbn07XG5cbi8vIGNyZWF0ZSBhIGNpcmN1bGFyIGRvdWJseSBsaW5rZWQgbGlzdCBmcm9tIHBvbHlnb24gcG9pbnRzIGluIHRoZSBzcGVjaWZpZWQgd2luZGluZyBvcmRlclxuZnVuY3Rpb24gbGlua2VkTGlzdChkYXRhLCBzdGFydCwgZW5kLCBkaW0sIGNsb2Nrd2lzZSkge1xuXHRsZXQgaSwgbGFzdDtcblx0aWYgKGNsb2Nrd2lzZSA9PT0gc2lnbmVkQXJlYShkYXRhLCBzdGFydCwgZW5kLCBkaW0pID4gMCkge1xuXHRcdGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IGRpbSkgbGFzdCA9IGluc2VydE5vZGUoaSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxhc3QpO1xuXHR9IGVsc2Uge1xuXHRcdGZvciAoaSA9IGVuZCAtIGRpbTsgaSA+PSBzdGFydDsgaSAtPSBkaW0pIGxhc3QgPSBpbnNlcnROb2RlKGksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBsYXN0KTtcblx0fVxuXHRpZiAobGFzdCAmJiBlcXVhbHMobGFzdCwgbGFzdC5uZXh0KSkge1xuXHRcdHJlbW92ZU5vZGUobGFzdCk7XG5cdFx0bGFzdCA9IGxhc3QubmV4dDtcblx0fVxuXHRyZXR1cm4gbGFzdDtcbn1cblxuLy8gZWxpbWluYXRlIGNvbGluZWFyIG9yIGR1cGxpY2F0ZSBwb2ludHNcbmZ1bmN0aW9uIGZpbHRlclBvaW50cyhzdGFydCwgZW5kKSB7XG5cdGlmICghc3RhcnQpIHJldHVybiBzdGFydDtcblx0aWYgKCFlbmQpIGVuZCA9IHN0YXJ0O1xuXHRsZXQgcCA9IHN0YXJ0LFxuXHRcdGFnYWluO1xuXHRkbyB7XG5cdFx0YWdhaW4gPSBmYWxzZTtcblx0XHRpZiAoIXAuc3RlaW5lciAmJiAoZXF1YWxzKHAsIHAubmV4dCkgfHwgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPT09IDApKSB7XG5cdFx0XHRyZW1vdmVOb2RlKHApO1xuXHRcdFx0cCA9IGVuZCA9IHAucHJldjtcblx0XHRcdGlmIChwID09PSBwLm5leHQpIGJyZWFrO1xuXHRcdFx0YWdhaW4gPSB0cnVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwID0gcC5uZXh0O1xuXHRcdH1cblx0fSB3aGlsZSAoYWdhaW4gfHwgcCAhPT0gZW5kKTtcblx0cmV0dXJuIGVuZDtcbn1cblxuLy8gbWFpbiBlYXIgc2xpY2luZyBsb29wIHdoaWNoIHRyaWFuZ3VsYXRlcyBhIHBvbHlnb24gKGdpdmVuIGFzIGEgbGlua2VkIGxpc3QpXG5mdW5jdGlvbiBlYXJjdXRMaW5rZWQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgcGFzcykge1xuXHRpZiAoIWVhcikgcmV0dXJuO1xuXG5cdC8vIGludGVybGluayBwb2x5Z29uIG5vZGVzIGluIHotb3JkZXJcblx0aWYgKCFwYXNzICYmIGludlNpemUpIGluZGV4Q3VydmUoZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcblx0bGV0IHN0b3AgPSBlYXIsXG5cdFx0cHJldixcblx0XHRuZXh0O1xuXG5cdC8vIGl0ZXJhdGUgdGhyb3VnaCBlYXJzLCBzbGljaW5nIHRoZW0gb25lIGJ5IG9uZVxuXHR3aGlsZSAoZWFyLnByZXYgIT09IGVhci5uZXh0KSB7XG5cdFx0cHJldiA9IGVhci5wcmV2O1xuXHRcdG5leHQgPSBlYXIubmV4dDtcblx0XHRpZiAoaW52U2l6ZSA/IGlzRWFySGFzaGVkKGVhciwgbWluWCwgbWluWSwgaW52U2l6ZSkgOiBpc0VhcihlYXIpKSB7XG5cdFx0XHQvLyBjdXQgb2ZmIHRoZSB0cmlhbmdsZVxuXHRcdFx0dHJpYW5nbGVzLnB1c2gocHJldi5pIC8gZGltIHwgMCk7XG5cdFx0XHR0cmlhbmdsZXMucHVzaChlYXIuaSAvIGRpbSB8IDApO1xuXHRcdFx0dHJpYW5nbGVzLnB1c2gobmV4dC5pIC8gZGltIHwgMCk7XG5cdFx0XHRyZW1vdmVOb2RlKGVhcik7XG5cblx0XHRcdC8vIHNraXBwaW5nIHRoZSBuZXh0IHZlcnRleCBsZWFkcyB0byBsZXNzIHNsaXZlciB0cmlhbmdsZXNcblx0XHRcdGVhciA9IG5leHQubmV4dDtcblx0XHRcdHN0b3AgPSBuZXh0Lm5leHQ7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cdFx0ZWFyID0gbmV4dDtcblxuXHRcdC8vIGlmIHdlIGxvb3BlZCB0aHJvdWdoIHRoZSB3aG9sZSByZW1haW5pbmcgcG9seWdvbiBhbmQgY2FuJ3QgZmluZCBhbnkgbW9yZSBlYXJzXG5cdFx0aWYgKGVhciA9PT0gc3RvcCkge1xuXHRcdFx0Ly8gdHJ5IGZpbHRlcmluZyBwb2ludHMgYW5kIHNsaWNpbmcgYWdhaW5cblx0XHRcdGlmICghcGFzcykge1xuXHRcdFx0XHRlYXJjdXRMaW5rZWQoZmlsdGVyUG9pbnRzKGVhciksIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAxKTtcblxuXHRcdFx0XHQvLyBpZiB0aGlzIGRpZG4ndCB3b3JrLCB0cnkgY3VyaW5nIGFsbCBzbWFsbCBzZWxmLWludGVyc2VjdGlvbnMgbG9jYWxseVxuXHRcdFx0fSBlbHNlIGlmIChwYXNzID09PSAxKSB7XG5cdFx0XHRcdGVhciA9IGN1cmVMb2NhbEludGVyc2VjdGlvbnMoZmlsdGVyUG9pbnRzKGVhciksIHRyaWFuZ2xlcywgZGltKTtcblx0XHRcdFx0ZWFyY3V0TGlua2VkKGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDIpO1xuXG5cdFx0XHRcdC8vIGFzIGEgbGFzdCByZXNvcnQsIHRyeSBzcGxpdHRpbmcgdGhlIHJlbWFpbmluZyBwb2x5Z29uIGludG8gdHdvXG5cdFx0XHR9IGVsc2UgaWYgKHBhc3MgPT09IDIpIHtcblx0XHRcdFx0c3BsaXRFYXJjdXQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG5cdFx0XHR9XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cbn1cblxuLy8gY2hlY2sgd2hldGhlciBhIHBvbHlnb24gbm9kZSBmb3JtcyBhIHZhbGlkIGVhciB3aXRoIGFkamFjZW50IG5vZGVzXG5mdW5jdGlvbiBpc0VhcihlYXIpIHtcblx0Y29uc3QgYSA9IGVhci5wcmV2LFxuXHRcdGIgPSBlYXIsXG5cdFx0YyA9IGVhci5uZXh0O1xuXHRpZiAoYXJlYShhLCBiLCBjKSA+PSAwKSByZXR1cm4gZmFsc2U7IC8vIHJlZmxleCwgY2FuJ3QgYmUgYW4gZWFyXG5cblx0Ly8gbm93IG1ha2Ugc3VyZSB3ZSBkb24ndCBoYXZlIG90aGVyIHBvaW50cyBpbnNpZGUgdGhlIHBvdGVudGlhbCBlYXJcblx0Y29uc3QgYXggPSBhLngsXG5cdFx0YnggPSBiLngsXG5cdFx0Y3ggPSBjLngsXG5cdFx0YXkgPSBhLnksXG5cdFx0YnkgPSBiLnksXG5cdFx0Y3kgPSBjLnk7XG5cblx0Ly8gdHJpYW5nbGUgYmJveDsgbWluICYgbWF4IGFyZSBjYWxjdWxhdGVkIGxpa2UgdGhpcyBmb3Igc3BlZWRcblx0Y29uc3QgeDAgPSBheCA8IGJ4ID8gYXggPCBjeCA/IGF4IDogY3ggOiBieCA8IGN4ID8gYnggOiBjeCxcblx0XHR5MCA9IGF5IDwgYnkgPyBheSA8IGN5ID8gYXkgOiBjeSA6IGJ5IDwgY3kgPyBieSA6IGN5LFxuXHRcdHgxID0gYXggPiBieCA/IGF4ID4gY3ggPyBheCA6IGN4IDogYnggPiBjeCA/IGJ4IDogY3gsXG5cdFx0eTEgPSBheSA+IGJ5ID8gYXkgPiBjeSA/IGF5IDogY3kgOiBieSA+IGN5ID8gYnkgOiBjeTtcblx0bGV0IHAgPSBjLm5leHQ7XG5cdHdoaWxlIChwICE9PSBhKSB7XG5cdFx0aWYgKHAueCA+PSB4MCAmJiBwLnggPD0geDEgJiYgcC55ID49IHkwICYmIHAueSA8PSB5MSAmJiBwb2ludEluVHJpYW5nbGUoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcC54LCBwLnkpICYmIGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcblx0XHRwID0gcC5uZXh0O1xuXHR9XG5cdHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gaXNFYXJIYXNoZWQoZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSB7XG5cdGNvbnN0IGEgPSBlYXIucHJldixcblx0XHRiID0gZWFyLFxuXHRcdGMgPSBlYXIubmV4dDtcblx0aWYgKGFyZWEoYSwgYiwgYykgPj0gMCkgcmV0dXJuIGZhbHNlOyAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxuXG5cdGNvbnN0IGF4ID0gYS54LFxuXHRcdGJ4ID0gYi54LFxuXHRcdGN4ID0gYy54LFxuXHRcdGF5ID0gYS55LFxuXHRcdGJ5ID0gYi55LFxuXHRcdGN5ID0gYy55O1xuXG5cdC8vIHRyaWFuZ2xlIGJib3g7IG1pbiAmIG1heCBhcmUgY2FsY3VsYXRlZCBsaWtlIHRoaXMgZm9yIHNwZWVkXG5cdGNvbnN0IHgwID0gYXggPCBieCA/IGF4IDwgY3ggPyBheCA6IGN4IDogYnggPCBjeCA/IGJ4IDogY3gsXG5cdFx0eTAgPSBheSA8IGJ5ID8gYXkgPCBjeSA/IGF5IDogY3kgOiBieSA8IGN5ID8gYnkgOiBjeSxcblx0XHR4MSA9IGF4ID4gYnggPyBheCA+IGN4ID8gYXggOiBjeCA6IGJ4ID4gY3ggPyBieCA6IGN4LFxuXHRcdHkxID0gYXkgPiBieSA/IGF5ID4gY3kgPyBheSA6IGN5IDogYnkgPiBjeSA/IGJ5IDogY3k7XG5cblx0Ly8gei1vcmRlciByYW5nZSBmb3IgdGhlIGN1cnJlbnQgdHJpYW5nbGUgYmJveDtcblx0Y29uc3QgbWluWiA9IHpPcmRlcih4MCwgeTAsIG1pblgsIG1pblksIGludlNpemUpLFxuXHRcdG1heFogPSB6T3JkZXIoeDEsIHkxLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcblx0bGV0IHAgPSBlYXIucHJldlosXG5cdFx0biA9IGVhci5uZXh0WjtcblxuXHQvLyBsb29rIGZvciBwb2ludHMgaW5zaWRlIHRoZSB0cmlhbmdsZSBpbiBib3RoIGRpcmVjdGlvbnNcblx0d2hpbGUgKHAgJiYgcC56ID49IG1pblogJiYgbiAmJiBuLnogPD0gbWF4Wikge1xuXHRcdGlmIChwLnggPj0geDAgJiYgcC54IDw9IHgxICYmIHAueSA+PSB5MCAmJiBwLnkgPD0geTEgJiYgcCAhPT0gYSAmJiBwICE9PSBjICYmIHBvaW50SW5UcmlhbmdsZShheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBwLngsIHAueSkgJiYgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuXHRcdHAgPSBwLnByZXZaO1xuXHRcdGlmIChuLnggPj0geDAgJiYgbi54IDw9IHgxICYmIG4ueSA+PSB5MCAmJiBuLnkgPD0geTEgJiYgbiAhPT0gYSAmJiBuICE9PSBjICYmIHBvaW50SW5UcmlhbmdsZShheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBuLngsIG4ueSkgJiYgYXJlYShuLnByZXYsIG4sIG4ubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuXHRcdG4gPSBuLm5leHRaO1xuXHR9XG5cblx0Ly8gbG9vayBmb3IgcmVtYWluaW5nIHBvaW50cyBpbiBkZWNyZWFzaW5nIHotb3JkZXJcblx0d2hpbGUgKHAgJiYgcC56ID49IG1pblopIHtcblx0XHRpZiAocC54ID49IHgwICYmIHAueCA8PSB4MSAmJiBwLnkgPj0geTAgJiYgcC55IDw9IHkxICYmIHAgIT09IGEgJiYgcCAhPT0gYyAmJiBwb2ludEluVHJpYW5nbGUoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcC54LCBwLnkpICYmIGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcblx0XHRwID0gcC5wcmV2Wjtcblx0fVxuXG5cdC8vIGxvb2sgZm9yIHJlbWFpbmluZyBwb2ludHMgaW4gaW5jcmVhc2luZyB6LW9yZGVyXG5cdHdoaWxlIChuICYmIG4ueiA8PSBtYXhaKSB7XG5cdFx0aWYgKG4ueCA+PSB4MCAmJiBuLnggPD0geDEgJiYgbi55ID49IHkwICYmIG4ueSA8PSB5MSAmJiBuICE9PSBhICYmIG4gIT09IGMgJiYgcG9pbnRJblRyaWFuZ2xlKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIG4ueCwgbi55KSAmJiBhcmVhKG4ucHJldiwgbiwgbi5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG5cdFx0biA9IG4ubmV4dFo7XG5cdH1cblx0cmV0dXJuIHRydWU7XG59XG5cbi8vIGdvIHRocm91Z2ggYWxsIHBvbHlnb24gbm9kZXMgYW5kIGN1cmUgc21hbGwgbG9jYWwgc2VsZi1pbnRlcnNlY3Rpb25zXG5mdW5jdGlvbiBjdXJlTG9jYWxJbnRlcnNlY3Rpb25zKHN0YXJ0LCB0cmlhbmdsZXMsIGRpbSkge1xuXHRsZXQgcCA9IHN0YXJ0O1xuXHRkbyB7XG5cdFx0Y29uc3QgYSA9IHAucHJldixcblx0XHRcdGIgPSBwLm5leHQubmV4dDtcblx0XHRpZiAoIWVxdWFscyhhLCBiKSAmJiBpbnRlcnNlY3RzKGEsIHAsIHAubmV4dCwgYikgJiYgbG9jYWxseUluc2lkZShhLCBiKSAmJiBsb2NhbGx5SW5zaWRlKGIsIGEpKSB7XG5cdFx0XHR0cmlhbmdsZXMucHVzaChhLmkgLyBkaW0gfCAwKTtcblx0XHRcdHRyaWFuZ2xlcy5wdXNoKHAuaSAvIGRpbSB8IDApO1xuXHRcdFx0dHJpYW5nbGVzLnB1c2goYi5pIC8gZGltIHwgMCk7XG5cblx0XHRcdC8vIHJlbW92ZSB0d28gbm9kZXMgaW52b2x2ZWRcblx0XHRcdHJlbW92ZU5vZGUocCk7XG5cdFx0XHRyZW1vdmVOb2RlKHAubmV4dCk7XG5cdFx0XHRwID0gc3RhcnQgPSBiO1xuXHRcdH1cblx0XHRwID0gcC5uZXh0O1xuXHR9IHdoaWxlIChwICE9PSBzdGFydCk7XG5cdHJldHVybiBmaWx0ZXJQb2ludHMocCk7XG59XG5cbi8vIHRyeSBzcGxpdHRpbmcgcG9seWdvbiBpbnRvIHR3byBhbmQgdHJpYW5ndWxhdGUgdGhlbSBpbmRlcGVuZGVudGx5XG5mdW5jdGlvbiBzcGxpdEVhcmN1dChzdGFydCwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUpIHtcblx0Ly8gbG9vayBmb3IgYSB2YWxpZCBkaWFnb25hbCB0aGF0IGRpdmlkZXMgdGhlIHBvbHlnb24gaW50byB0d29cblx0bGV0IGEgPSBzdGFydDtcblx0ZG8ge1xuXHRcdGxldCBiID0gYS5uZXh0Lm5leHQ7XG5cdFx0d2hpbGUgKGIgIT09IGEucHJldikge1xuXHRcdFx0aWYgKGEuaSAhPT0gYi5pICYmIGlzVmFsaWREaWFnb25hbChhLCBiKSkge1xuXHRcdFx0XHQvLyBzcGxpdCB0aGUgcG9seWdvbiBpbiB0d28gYnkgdGhlIGRpYWdvbmFsXG5cdFx0XHRcdGxldCBjID0gc3BsaXRQb2x5Z29uKGEsIGIpO1xuXG5cdFx0XHRcdC8vIGZpbHRlciBjb2xpbmVhciBwb2ludHMgYXJvdW5kIHRoZSBjdXRzXG5cdFx0XHRcdGEgPSBmaWx0ZXJQb2ludHMoYSwgYS5uZXh0KTtcblx0XHRcdFx0YyA9IGZpbHRlclBvaW50cyhjLCBjLm5leHQpO1xuXG5cdFx0XHRcdC8vIHJ1biBlYXJjdXQgb24gZWFjaCBoYWxmXG5cdFx0XHRcdGVhcmN1dExpbmtlZChhLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMCk7XG5cdFx0XHRcdGVhcmN1dExpbmtlZChjLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGIgPSBiLm5leHQ7XG5cdFx0fVxuXHRcdGEgPSBhLm5leHQ7XG5cdH0gd2hpbGUgKGEgIT09IHN0YXJ0KTtcbn1cblxuLy8gbGluayBldmVyeSBob2xlIGludG8gdGhlIG91dGVyIGxvb3AsIHByb2R1Y2luZyBhIHNpbmdsZS1yaW5nIHBvbHlnb24gd2l0aG91dCBob2xlc1xuZnVuY3Rpb24gZWxpbWluYXRlSG9sZXMoZGF0YSwgaG9sZUluZGljZXMsIG91dGVyTm9kZSwgZGltKSB7XG5cdGNvbnN0IHF1ZXVlID0gW107XG5cdGxldCBpLCBsZW4sIHN0YXJ0LCBlbmQsIGxpc3Q7XG5cdGZvciAoaSA9IDAsIGxlbiA9IGhvbGVJbmRpY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0c3RhcnQgPSBob2xlSW5kaWNlc1tpXSAqIGRpbTtcblx0XHRlbmQgPSBpIDwgbGVuIC0gMSA/IGhvbGVJbmRpY2VzW2kgKyAxXSAqIGRpbSA6IGRhdGEubGVuZ3RoO1xuXHRcdGxpc3QgPSBsaW5rZWRMaXN0KGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSwgZmFsc2UpO1xuXHRcdGlmIChsaXN0ID09PSBsaXN0Lm5leHQpIGxpc3Quc3RlaW5lciA9IHRydWU7XG5cdFx0cXVldWUucHVzaChnZXRMZWZ0bW9zdChsaXN0KSk7XG5cdH1cblx0cXVldWUuc29ydChjb21wYXJlWCk7XG5cblx0Ly8gcHJvY2VzcyBob2xlcyBmcm9tIGxlZnQgdG8gcmlnaHRcblx0Zm9yIChpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG5cdFx0b3V0ZXJOb2RlID0gZWxpbWluYXRlSG9sZShxdWV1ZVtpXSwgb3V0ZXJOb2RlKTtcblx0fVxuXHRyZXR1cm4gb3V0ZXJOb2RlO1xufVxuZnVuY3Rpb24gY29tcGFyZVgoYSwgYikge1xuXHRyZXR1cm4gYS54IC0gYi54O1xufVxuXG4vLyBmaW5kIGEgYnJpZGdlIGJldHdlZW4gdmVydGljZXMgdGhhdCBjb25uZWN0cyBob2xlIHdpdGggYW4gb3V0ZXIgcmluZyBhbmQgbGluayBpdFxuZnVuY3Rpb24gZWxpbWluYXRlSG9sZShob2xlLCBvdXRlck5vZGUpIHtcblx0Y29uc3QgYnJpZGdlID0gZmluZEhvbGVCcmlkZ2UoaG9sZSwgb3V0ZXJOb2RlKTtcblx0aWYgKCFicmlkZ2UpIHtcblx0XHRyZXR1cm4gb3V0ZXJOb2RlO1xuXHR9XG5cdGNvbnN0IGJyaWRnZVJldmVyc2UgPSBzcGxpdFBvbHlnb24oYnJpZGdlLCBob2xlKTtcblxuXHQvLyBmaWx0ZXIgY29sbGluZWFyIHBvaW50cyBhcm91bmQgdGhlIGN1dHNcblx0ZmlsdGVyUG9pbnRzKGJyaWRnZVJldmVyc2UsIGJyaWRnZVJldmVyc2UubmV4dCk7XG5cdHJldHVybiBmaWx0ZXJQb2ludHMoYnJpZGdlLCBicmlkZ2UubmV4dCk7XG59XG5cbi8vIERhdmlkIEViZXJseSdzIGFsZ29yaXRobSBmb3IgZmluZGluZyBhIGJyaWRnZSBiZXR3ZWVuIGhvbGUgYW5kIG91dGVyIHBvbHlnb25cbmZ1bmN0aW9uIGZpbmRIb2xlQnJpZGdlKGhvbGUsIG91dGVyTm9kZSkge1xuXHRsZXQgcCA9IG91dGVyTm9kZSxcblx0XHRxeCA9IC1JbmZpbml0eSxcblx0XHRtO1xuXHRjb25zdCBoeCA9IGhvbGUueCxcblx0XHRoeSA9IGhvbGUueTtcblxuXHQvLyBmaW5kIGEgc2VnbWVudCBpbnRlcnNlY3RlZCBieSBhIHJheSBmcm9tIHRoZSBob2xlJ3MgbGVmdG1vc3QgcG9pbnQgdG8gdGhlIGxlZnQ7XG5cdC8vIHNlZ21lbnQncyBlbmRwb2ludCB3aXRoIGxlc3NlciB4IHdpbGwgYmUgcG90ZW50aWFsIGNvbm5lY3Rpb24gcG9pbnRcblx0ZG8ge1xuXHRcdGlmIChoeSA8PSBwLnkgJiYgaHkgPj0gcC5uZXh0LnkgJiYgcC5uZXh0LnkgIT09IHAueSkge1xuXHRcdFx0Y29uc3QgeCA9IHAueCArIChoeSAtIHAueSkgKiAocC5uZXh0LnggLSBwLngpIC8gKHAubmV4dC55IC0gcC55KTtcblx0XHRcdGlmICh4IDw9IGh4ICYmIHggPiBxeCkge1xuXHRcdFx0XHRxeCA9IHg7XG5cdFx0XHRcdG0gPSBwLnggPCBwLm5leHQueCA/IHAgOiBwLm5leHQ7XG5cdFx0XHRcdGlmICh4ID09PSBoeCkgcmV0dXJuIG07IC8vIGhvbGUgdG91Y2hlcyBvdXRlciBzZWdtZW50OyBwaWNrIGxlZnRtb3N0IGVuZHBvaW50XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cCA9IHAubmV4dDtcblx0fSB3aGlsZSAocCAhPT0gb3V0ZXJOb2RlKTtcblx0aWYgKCFtKSByZXR1cm4gbnVsbDtcblxuXHQvLyBsb29rIGZvciBwb2ludHMgaW5zaWRlIHRoZSB0cmlhbmdsZSBvZiBob2xlIHBvaW50LCBzZWdtZW50IGludGVyc2VjdGlvbiBhbmQgZW5kcG9pbnQ7XG5cdC8vIGlmIHRoZXJlIGFyZSBubyBwb2ludHMgZm91bmQsIHdlIGhhdmUgYSB2YWxpZCBjb25uZWN0aW9uO1xuXHQvLyBvdGhlcndpc2UgY2hvb3NlIHRoZSBwb2ludCBvZiB0aGUgbWluaW11bSBhbmdsZSB3aXRoIHRoZSByYXkgYXMgY29ubmVjdGlvbiBwb2ludFxuXG5cdGNvbnN0IHN0b3AgPSBtLFxuXHRcdG14ID0gbS54LFxuXHRcdG15ID0gbS55O1xuXHRsZXQgdGFuTWluID0gSW5maW5pdHksXG5cdFx0dGFuO1xuXHRwID0gbTtcblx0ZG8ge1xuXHRcdGlmIChoeCA+PSBwLnggJiYgcC54ID49IG14ICYmIGh4ICE9PSBwLnggJiYgcG9pbnRJblRyaWFuZ2xlKGh5IDwgbXkgPyBoeCA6IHF4LCBoeSwgbXgsIG15LCBoeSA8IG15ID8gcXggOiBoeCwgaHksIHAueCwgcC55KSkge1xuXHRcdFx0dGFuID0gTWF0aC5hYnMoaHkgLSBwLnkpIC8gKGh4IC0gcC54KTsgLy8gdGFuZ2VudGlhbFxuXG5cdFx0XHRpZiAobG9jYWxseUluc2lkZShwLCBob2xlKSAmJiAodGFuIDwgdGFuTWluIHx8IHRhbiA9PT0gdGFuTWluICYmIChwLnggPiBtLnggfHwgcC54ID09PSBtLnggJiYgc2VjdG9yQ29udGFpbnNTZWN0b3IobSwgcCkpKSkge1xuXHRcdFx0XHRtID0gcDtcblx0XHRcdFx0dGFuTWluID0gdGFuO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRwID0gcC5uZXh0O1xuXHR9IHdoaWxlIChwICE9PSBzdG9wKTtcblx0cmV0dXJuIG07XG59XG5cbi8vIHdoZXRoZXIgc2VjdG9yIGluIHZlcnRleCBtIGNvbnRhaW5zIHNlY3RvciBpbiB2ZXJ0ZXggcCBpbiB0aGUgc2FtZSBjb29yZGluYXRlc1xuZnVuY3Rpb24gc2VjdG9yQ29udGFpbnNTZWN0b3IobSwgcCkge1xuXHRyZXR1cm4gYXJlYShtLnByZXYsIG0sIHAucHJldikgPCAwICYmIGFyZWEocC5uZXh0LCBtLCBtLm5leHQpIDwgMDtcbn1cblxuLy8gaW50ZXJsaW5rIHBvbHlnb24gbm9kZXMgaW4gei1vcmRlclxuZnVuY3Rpb24gaW5kZXhDdXJ2ZShzdGFydCwgbWluWCwgbWluWSwgaW52U2l6ZSkge1xuXHRsZXQgcCA9IHN0YXJ0O1xuXHRkbyB7XG5cdFx0aWYgKHAueiA9PT0gMCkgcC56ID0gek9yZGVyKHAueCwgcC55LCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcblx0XHRwLnByZXZaID0gcC5wcmV2O1xuXHRcdHAubmV4dFogPSBwLm5leHQ7XG5cdFx0cCA9IHAubmV4dDtcblx0fSB3aGlsZSAocCAhPT0gc3RhcnQpO1xuXHRwLnByZXZaLm5leHRaID0gbnVsbDtcblx0cC5wcmV2WiA9IG51bGw7XG5cdHNvcnRMaW5rZWQocCk7XG59XG5cbi8vIFNpbW9uIFRhdGhhbSdzIGxpbmtlZCBsaXN0IG1lcmdlIHNvcnQgYWxnb3JpdGhtXG4vLyBodHRwOi8vd3d3LmNoaWFyay5ncmVlbmVuZC5vcmcudWsvfnNndGF0aGFtL2FsZ29yaXRobXMvbGlzdHNvcnQuaHRtbFxuZnVuY3Rpb24gc29ydExpbmtlZChsaXN0KSB7XG5cdGxldCBpLFxuXHRcdHAsXG5cdFx0cSxcblx0XHRlLFxuXHRcdHRhaWwsXG5cdFx0bnVtTWVyZ2VzLFxuXHRcdHBTaXplLFxuXHRcdHFTaXplLFxuXHRcdGluU2l6ZSA9IDE7XG5cdGRvIHtcblx0XHRwID0gbGlzdDtcblx0XHRsaXN0ID0gbnVsbDtcblx0XHR0YWlsID0gbnVsbDtcblx0XHRudW1NZXJnZXMgPSAwO1xuXHRcdHdoaWxlIChwKSB7XG5cdFx0XHRudW1NZXJnZXMrKztcblx0XHRcdHEgPSBwO1xuXHRcdFx0cFNpemUgPSAwO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGluU2l6ZTsgaSsrKSB7XG5cdFx0XHRcdHBTaXplKys7XG5cdFx0XHRcdHEgPSBxLm5leHRaO1xuXHRcdFx0XHRpZiAoIXEpIGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0cVNpemUgPSBpblNpemU7XG5cdFx0XHR3aGlsZSAocFNpemUgPiAwIHx8IHFTaXplID4gMCAmJiBxKSB7XG5cdFx0XHRcdGlmIChwU2l6ZSAhPT0gMCAmJiAocVNpemUgPT09IDAgfHwgIXEgfHwgcC56IDw9IHEueikpIHtcblx0XHRcdFx0XHRlID0gcDtcblx0XHRcdFx0XHRwID0gcC5uZXh0Wjtcblx0XHRcdFx0XHRwU2l6ZS0tO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGUgPSBxO1xuXHRcdFx0XHRcdHEgPSBxLm5leHRaO1xuXHRcdFx0XHRcdHFTaXplLS07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRhaWwpIHRhaWwubmV4dFogPSBlO2Vsc2UgbGlzdCA9IGU7XG5cdFx0XHRcdGUucHJldlogPSB0YWlsO1xuXHRcdFx0XHR0YWlsID0gZTtcblx0XHRcdH1cblx0XHRcdHAgPSBxO1xuXHRcdH1cblx0XHR0YWlsLm5leHRaID0gbnVsbDtcblx0XHRpblNpemUgKj0gMjtcblx0fSB3aGlsZSAobnVtTWVyZ2VzID4gMSk7XG5cdHJldHVybiBsaXN0O1xufVxuXG4vLyB6LW9yZGVyIG9mIGEgcG9pbnQgZ2l2ZW4gY29vcmRzIGFuZCBpbnZlcnNlIG9mIHRoZSBsb25nZXIgc2lkZSBvZiBkYXRhIGJib3hcbmZ1bmN0aW9uIHpPcmRlcih4LCB5LCBtaW5YLCBtaW5ZLCBpbnZTaXplKSB7XG5cdC8vIGNvb3JkcyBhcmUgdHJhbnNmb3JtZWQgaW50byBub24tbmVnYXRpdmUgMTUtYml0IGludGVnZXIgcmFuZ2Vcblx0eCA9ICh4IC0gbWluWCkgKiBpbnZTaXplIHwgMDtcblx0eSA9ICh5IC0gbWluWSkgKiBpbnZTaXplIHwgMDtcblx0eCA9ICh4IHwgeCA8PCA4KSAmIDB4MDBGRjAwRkY7XG5cdHggPSAoeCB8IHggPDwgNCkgJiAweDBGMEYwRjBGO1xuXHR4ID0gKHggfCB4IDw8IDIpICYgMHgzMzMzMzMzMztcblx0eCA9ICh4IHwgeCA8PCAxKSAmIDB4NTU1NTU1NTU7XG5cdHkgPSAoeSB8IHkgPDwgOCkgJiAweDAwRkYwMEZGO1xuXHR5ID0gKHkgfCB5IDw8IDQpICYgMHgwRjBGMEYwRjtcblx0eSA9ICh5IHwgeSA8PCAyKSAmIDB4MzMzMzMzMzM7XG5cdHkgPSAoeSB8IHkgPDwgMSkgJiAweDU1NTU1NTU1O1xuXHRyZXR1cm4geCB8IHkgPDwgMTtcbn1cblxuLy8gZmluZCB0aGUgbGVmdG1vc3Qgbm9kZSBvZiBhIHBvbHlnb24gcmluZ1xuZnVuY3Rpb24gZ2V0TGVmdG1vc3Qoc3RhcnQpIHtcblx0bGV0IHAgPSBzdGFydCxcblx0XHRsZWZ0bW9zdCA9IHN0YXJ0O1xuXHRkbyB7XG5cdFx0aWYgKHAueCA8IGxlZnRtb3N0LnggfHwgcC54ID09PSBsZWZ0bW9zdC54ICYmIHAueSA8IGxlZnRtb3N0LnkpIGxlZnRtb3N0ID0gcDtcblx0XHRwID0gcC5uZXh0O1xuXHR9IHdoaWxlIChwICE9PSBzdGFydCk7XG5cdHJldHVybiBsZWZ0bW9zdDtcbn1cblxuLy8gY2hlY2sgaWYgYSBwb2ludCBsaWVzIHdpdGhpbiBhIGNvbnZleCB0cmlhbmdsZVxuZnVuY3Rpb24gcG9pbnRJblRyaWFuZ2xlKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHB4LCBweSkge1xuXHRyZXR1cm4gKGN4IC0gcHgpICogKGF5IC0gcHkpID49IChheCAtIHB4KSAqIChjeSAtIHB5KSAmJiAoYXggLSBweCkgKiAoYnkgLSBweSkgPj0gKGJ4IC0gcHgpICogKGF5IC0gcHkpICYmIChieCAtIHB4KSAqIChjeSAtIHB5KSA+PSAoY3ggLSBweCkgKiAoYnkgLSBweSk7XG59XG5cbi8vIGNoZWNrIGlmIGEgZGlhZ29uYWwgYmV0d2VlbiB0d28gcG9seWdvbiBub2RlcyBpcyB2YWxpZCAobGllcyBpbiBwb2x5Z29uIGludGVyaW9yKVxuZnVuY3Rpb24gaXNWYWxpZERpYWdvbmFsKGEsIGIpIHtcblx0cmV0dXJuIGEubmV4dC5pICE9PSBiLmkgJiYgYS5wcmV2LmkgIT09IGIuaSAmJiAhaW50ZXJzZWN0c1BvbHlnb24oYSwgYikgJiYgKFxuXHQvLyBkb25lcyd0IGludGVyc2VjdCBvdGhlciBlZGdlc1xuXHRsb2NhbGx5SW5zaWRlKGEsIGIpICYmIGxvY2FsbHlJbnNpZGUoYiwgYSkgJiYgbWlkZGxlSW5zaWRlKGEsIGIpICYmIChcblx0Ly8gbG9jYWxseSB2aXNpYmxlXG5cdGFyZWEoYS5wcmV2LCBhLCBiLnByZXYpIHx8IGFyZWEoYSwgYi5wcmV2LCBiKSkgfHxcblx0Ly8gZG9lcyBub3QgY3JlYXRlIG9wcG9zaXRlLWZhY2luZyBzZWN0b3JzXG5cdGVxdWFscyhhLCBiKSAmJiBhcmVhKGEucHJldiwgYSwgYS5uZXh0KSA+IDAgJiYgYXJlYShiLnByZXYsIGIsIGIubmV4dCkgPiAwKTsgLy8gc3BlY2lhbCB6ZXJvLWxlbmd0aCBjYXNlXG59XG5cbi8vIHNpZ25lZCBhcmVhIG9mIGEgdHJpYW5nbGVcbmZ1bmN0aW9uIGFyZWEocCwgcSwgcikge1xuXHRyZXR1cm4gKHEueSAtIHAueSkgKiAoci54IC0gcS54KSAtIChxLnggLSBwLngpICogKHIueSAtIHEueSk7XG59XG5cbi8vIGNoZWNrIGlmIHR3byBwb2ludHMgYXJlIGVxdWFsXG5mdW5jdGlvbiBlcXVhbHMocDEsIHAyKSB7XG5cdHJldHVybiBwMS54ID09PSBwMi54ICYmIHAxLnkgPT09IHAyLnk7XG59XG5cbi8vIGNoZWNrIGlmIHR3byBzZWdtZW50cyBpbnRlcnNlY3RcbmZ1bmN0aW9uIGludGVyc2VjdHMocDEsIHExLCBwMiwgcTIpIHtcblx0Y29uc3QgbzEgPSBzaWduKGFyZWEocDEsIHExLCBwMikpO1xuXHRjb25zdCBvMiA9IHNpZ24oYXJlYShwMSwgcTEsIHEyKSk7XG5cdGNvbnN0IG8zID0gc2lnbihhcmVhKHAyLCBxMiwgcDEpKTtcblx0Y29uc3QgbzQgPSBzaWduKGFyZWEocDIsIHEyLCBxMSkpO1xuXHRpZiAobzEgIT09IG8yICYmIG8zICE9PSBvNCkgcmV0dXJuIHRydWU7IC8vIGdlbmVyYWwgY2FzZVxuXG5cdGlmIChvMSA9PT0gMCAmJiBvblNlZ21lbnQocDEsIHAyLCBxMSkpIHJldHVybiB0cnVlOyAvLyBwMSwgcTEgYW5kIHAyIGFyZSBjb2xsaW5lYXIgYW5kIHAyIGxpZXMgb24gcDFxMVxuXHRpZiAobzIgPT09IDAgJiYgb25TZWdtZW50KHAxLCBxMiwgcTEpKSByZXR1cm4gdHJ1ZTsgLy8gcDEsIHExIGFuZCBxMiBhcmUgY29sbGluZWFyIGFuZCBxMiBsaWVzIG9uIHAxcTFcblx0aWYgKG8zID09PSAwICYmIG9uU2VnbWVudChwMiwgcDEsIHEyKSkgcmV0dXJuIHRydWU7IC8vIHAyLCBxMiBhbmQgcDEgYXJlIGNvbGxpbmVhciBhbmQgcDEgbGllcyBvbiBwMnEyXG5cdGlmIChvNCA9PT0gMCAmJiBvblNlZ21lbnQocDIsIHExLCBxMikpIHJldHVybiB0cnVlOyAvLyBwMiwgcTIgYW5kIHExIGFyZSBjb2xsaW5lYXIgYW5kIHExIGxpZXMgb24gcDJxMlxuXG5cdHJldHVybiBmYWxzZTtcbn1cblxuLy8gZm9yIGNvbGxpbmVhciBwb2ludHMgcCwgcSwgciwgY2hlY2sgaWYgcG9pbnQgcSBsaWVzIG9uIHNlZ21lbnQgcHJcbmZ1bmN0aW9uIG9uU2VnbWVudChwLCBxLCByKSB7XG5cdHJldHVybiBxLnggPD0gTWF0aC5tYXgocC54LCByLngpICYmIHEueCA+PSBNYXRoLm1pbihwLngsIHIueCkgJiYgcS55IDw9IE1hdGgubWF4KHAueSwgci55KSAmJiBxLnkgPj0gTWF0aC5taW4ocC55LCByLnkpO1xufVxuZnVuY3Rpb24gc2lnbihudW0pIHtcblx0cmV0dXJuIG51bSA+IDAgPyAxIDogbnVtIDwgMCA/IC0xIDogMDtcbn1cblxuLy8gY2hlY2sgaWYgYSBwb2x5Z29uIGRpYWdvbmFsIGludGVyc2VjdHMgYW55IHBvbHlnb24gc2VnbWVudHNcbmZ1bmN0aW9uIGludGVyc2VjdHNQb2x5Z29uKGEsIGIpIHtcblx0bGV0IHAgPSBhO1xuXHRkbyB7XG5cdFx0aWYgKHAuaSAhPT0gYS5pICYmIHAubmV4dC5pICE9PSBhLmkgJiYgcC5pICE9PSBiLmkgJiYgcC5uZXh0LmkgIT09IGIuaSAmJiBpbnRlcnNlY3RzKHAsIHAubmV4dCwgYSwgYikpIHJldHVybiB0cnVlO1xuXHRcdHAgPSBwLm5leHQ7XG5cdH0gd2hpbGUgKHAgIT09IGEpO1xuXHRyZXR1cm4gZmFsc2U7XG59XG5cbi8vIGNoZWNrIGlmIGEgcG9seWdvbiBkaWFnb25hbCBpcyBsb2NhbGx5IGluc2lkZSB0aGUgcG9seWdvblxuZnVuY3Rpb24gbG9jYWxseUluc2lkZShhLCBiKSB7XG5cdHJldHVybiBhcmVhKGEucHJldiwgYSwgYS5uZXh0KSA8IDAgPyBhcmVhKGEsIGIsIGEubmV4dCkgPj0gMCAmJiBhcmVhKGEsIGEucHJldiwgYikgPj0gMCA6IGFyZWEoYSwgYiwgYS5wcmV2KSA8IDAgfHwgYXJlYShhLCBhLm5leHQsIGIpIDwgMDtcbn1cblxuLy8gY2hlY2sgaWYgdGhlIG1pZGRsZSBwb2ludCBvZiBhIHBvbHlnb24gZGlhZ29uYWwgaXMgaW5zaWRlIHRoZSBwb2x5Z29uXG5mdW5jdGlvbiBtaWRkbGVJbnNpZGUoYSwgYikge1xuXHRsZXQgcCA9IGEsXG5cdFx0aW5zaWRlID0gZmFsc2U7XG5cdGNvbnN0IHB4ID0gKGEueCArIGIueCkgLyAyLFxuXHRcdHB5ID0gKGEueSArIGIueSkgLyAyO1xuXHRkbyB7XG5cdFx0aWYgKHAueSA+IHB5ICE9PSBwLm5leHQueSA+IHB5ICYmIHAubmV4dC55ICE9PSBwLnkgJiYgcHggPCAocC5uZXh0LnggLSBwLngpICogKHB5IC0gcC55KSAvIChwLm5leHQueSAtIHAueSkgKyBwLngpIGluc2lkZSA9ICFpbnNpZGU7XG5cdFx0cCA9IHAubmV4dDtcblx0fSB3aGlsZSAocCAhPT0gYSk7XG5cdHJldHVybiBpbnNpZGU7XG59XG5cbi8vIGxpbmsgdHdvIHBvbHlnb24gdmVydGljZXMgd2l0aCBhIGJyaWRnZTsgaWYgdGhlIHZlcnRpY2VzIGJlbG9uZyB0byB0aGUgc2FtZSByaW5nLCBpdCBzcGxpdHMgcG9seWdvbiBpbnRvIHR3bztcbi8vIGlmIG9uZSBiZWxvbmdzIHRvIHRoZSBvdXRlciByaW5nIGFuZCBhbm90aGVyIHRvIGEgaG9sZSwgaXQgbWVyZ2VzIGl0IGludG8gYSBzaW5nbGUgcmluZ1xuZnVuY3Rpb24gc3BsaXRQb2x5Z29uKGEsIGIpIHtcblx0Y29uc3QgYTIgPSBuZXcgTm9kZShhLmksIGEueCwgYS55KSxcblx0XHRiMiA9IG5ldyBOb2RlKGIuaSwgYi54LCBiLnkpLFxuXHRcdGFuID0gYS5uZXh0LFxuXHRcdGJwID0gYi5wcmV2O1xuXHRhLm5leHQgPSBiO1xuXHRiLnByZXYgPSBhO1xuXHRhMi5uZXh0ID0gYW47XG5cdGFuLnByZXYgPSBhMjtcblx0YjIubmV4dCA9IGEyO1xuXHRhMi5wcmV2ID0gYjI7XG5cdGJwLm5leHQgPSBiMjtcblx0YjIucHJldiA9IGJwO1xuXHRyZXR1cm4gYjI7XG59XG5cbi8vIGNyZWF0ZSBhIG5vZGUgYW5kIG9wdGlvbmFsbHkgbGluayBpdCB3aXRoIHByZXZpb3VzIG9uZSAoaW4gYSBjaXJjdWxhciBkb3VibHkgbGlua2VkIGxpc3QpXG5mdW5jdGlvbiBpbnNlcnROb2RlKGksIHgsIHksIGxhc3QpIHtcblx0Y29uc3QgcCA9IG5ldyBOb2RlKGksIHgsIHkpO1xuXHRpZiAoIWxhc3QpIHtcblx0XHRwLnByZXYgPSBwO1xuXHRcdHAubmV4dCA9IHA7XG5cdH0gZWxzZSB7XG5cdFx0cC5uZXh0ID0gbGFzdC5uZXh0O1xuXHRcdHAucHJldiA9IGxhc3Q7XG5cdFx0bGFzdC5uZXh0LnByZXYgPSBwO1xuXHRcdGxhc3QubmV4dCA9IHA7XG5cdH1cblx0cmV0dXJuIHA7XG59XG5mdW5jdGlvbiByZW1vdmVOb2RlKHApIHtcblx0cC5uZXh0LnByZXYgPSBwLnByZXY7XG5cdHAucHJldi5uZXh0ID0gcC5uZXh0O1xuXHRpZiAocC5wcmV2WikgcC5wcmV2Wi5uZXh0WiA9IHAubmV4dFo7XG5cdGlmIChwLm5leHRaKSBwLm5leHRaLnByZXZaID0gcC5wcmV2Wjtcbn1cbmZ1bmN0aW9uIE5vZGUoaSwgeCwgeSkge1xuXHQvLyB2ZXJ0ZXggaW5kZXggaW4gY29vcmRpbmF0ZXMgYXJyYXlcblx0dGhpcy5pID0gaTtcblxuXHQvLyB2ZXJ0ZXggY29vcmRpbmF0ZXNcblx0dGhpcy54ID0geDtcblx0dGhpcy55ID0geTtcblxuXHQvLyBwcmV2aW91cyBhbmQgbmV4dCB2ZXJ0ZXggbm9kZXMgaW4gYSBwb2x5Z29uIHJpbmdcblx0dGhpcy5wcmV2ID0gbnVsbDtcblx0dGhpcy5uZXh0ID0gbnVsbDtcblxuXHQvLyB6LW9yZGVyIGN1cnZlIHZhbHVlXG5cdHRoaXMueiA9IDA7XG5cblx0Ly8gcHJldmlvdXMgYW5kIG5leHQgbm9kZXMgaW4gei1vcmRlclxuXHR0aGlzLnByZXZaID0gbnVsbDtcblx0dGhpcy5uZXh0WiA9IG51bGw7XG5cblx0Ly8gaW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBhIHN0ZWluZXIgcG9pbnRcblx0dGhpcy5zdGVpbmVyID0gZmFsc2U7XG59XG5mdW5jdGlvbiBzaWduZWRBcmVhKGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSkge1xuXHRsZXQgc3VtID0gMDtcblx0Zm9yIChsZXQgaSA9IHN0YXJ0LCBqID0gZW5kIC0gZGltOyBpIDwgZW5kOyBpICs9IGRpbSkge1xuXHRcdHN1bSArPSAoZGF0YVtqXSAtIGRhdGFbaV0pICogKGRhdGFbaSArIDFdICsgZGF0YVtqICsgMV0pO1xuXHRcdGogPSBpO1xuXHR9XG5cdHJldHVybiBzdW07XG59XG5cbmNsYXNzIFNoYXBlVXRpbHMge1xuXHQvLyBjYWxjdWxhdGUgYXJlYSBvZiB0aGUgY29udG91ciBwb2x5Z29uXG5cblx0c3RhdGljIGFyZWEoY29udG91cikge1xuXHRcdGNvbnN0IG4gPSBjb250b3VyLmxlbmd0aDtcblx0XHRsZXQgYSA9IDAuMDtcblx0XHRmb3IgKGxldCBwID0gbiAtIDEsIHEgPSAwOyBxIDwgbjsgcCA9IHErKykge1xuXHRcdFx0YSArPSBjb250b3VyW3BdLnggKiBjb250b3VyW3FdLnkgLSBjb250b3VyW3FdLnggKiBjb250b3VyW3BdLnk7XG5cdFx0fVxuXHRcdHJldHVybiBhICogMC41O1xuXHR9XG5cdHN0YXRpYyBpc0Nsb2NrV2lzZShwdHMpIHtcblx0XHRyZXR1cm4gU2hhcGVVdGlscy5hcmVhKHB0cykgPCAwO1xuXHR9XG5cdHN0YXRpYyB0cmlhbmd1bGF0ZVNoYXBlKGNvbnRvdXIsIGhvbGVzKSB7XG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXTsgLy8gZmxhdCBhcnJheSBvZiB2ZXJ0aWNlcyBsaWtlIFsgeDAseTAsIHgxLHkxLCB4Mix5MiwgLi4uIF1cblx0XHRjb25zdCBob2xlSW5kaWNlcyA9IFtdOyAvLyBhcnJheSBvZiBob2xlIGluZGljZXNcblx0XHRjb25zdCBmYWNlcyA9IFtdOyAvLyBmaW5hbCBhcnJheSBvZiB2ZXJ0ZXggaW5kaWNlcyBsaWtlIFsgWyBhLGIsZCBdLCBbIGIsYyxkIF0gXVxuXG5cdFx0cmVtb3ZlRHVwRW5kUHRzKGNvbnRvdXIpO1xuXHRcdGFkZENvbnRvdXIodmVydGljZXMsIGNvbnRvdXIpO1xuXG5cdFx0Ly9cblxuXHRcdGxldCBob2xlSW5kZXggPSBjb250b3VyLmxlbmd0aDtcblx0XHRob2xlcy5mb3JFYWNoKHJlbW92ZUR1cEVuZFB0cyk7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBob2xlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aG9sZUluZGljZXMucHVzaChob2xlSW5kZXgpO1xuXHRcdFx0aG9sZUluZGV4ICs9IGhvbGVzW2ldLmxlbmd0aDtcblx0XHRcdGFkZENvbnRvdXIodmVydGljZXMsIGhvbGVzW2ldKTtcblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0Y29uc3QgdHJpYW5nbGVzID0gRWFyY3V0LnRyaWFuZ3VsYXRlKHZlcnRpY2VzLCBob2xlSW5kaWNlcyk7XG5cblx0XHQvL1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0cmlhbmdsZXMubGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdGZhY2VzLnB1c2godHJpYW5nbGVzLnNsaWNlKGksIGkgKyAzKSk7XG5cdFx0fVxuXHRcdHJldHVybiBmYWNlcztcblx0fVxufVxuZnVuY3Rpb24gcmVtb3ZlRHVwRW5kUHRzKHBvaW50cykge1xuXHRjb25zdCBsID0gcG9pbnRzLmxlbmd0aDtcblx0aWYgKGwgPiAyICYmIHBvaW50c1tsIC0gMV0uZXF1YWxzKHBvaW50c1swXSkpIHtcblx0XHRwb2ludHMucG9wKCk7XG5cdH1cbn1cbmZ1bmN0aW9uIGFkZENvbnRvdXIodmVydGljZXMsIGNvbnRvdXIpIHtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjb250b3VyLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmVydGljZXMucHVzaChjb250b3VyW2ldLngpO1xuXHRcdHZlcnRpY2VzLnB1c2goY29udG91cltpXS55KTtcblx0fVxufVxuXG4vKipcbiAqIENyZWF0ZXMgZXh0cnVkZWQgZ2VvbWV0cnkgZnJvbSBhIHBhdGggc2hhcGUuXG4gKlxuICogcGFyYW1ldGVycyA9IHtcbiAqXG4gKlx0Y3VydmVTZWdtZW50czogPGludD4sIC8vIG51bWJlciBvZiBwb2ludHMgb24gdGhlIGN1cnZlc1xuICpcdHN0ZXBzOiA8aW50PiwgLy8gbnVtYmVyIG9mIHBvaW50cyBmb3Igei1zaWRlIGV4dHJ1c2lvbnMgLyB1c2VkIGZvciBzdWJkaXZpZGluZyBzZWdtZW50cyBvZiBleHRydWRlIHNwbGluZSB0b29cbiAqXHRkZXB0aDogPGZsb2F0PiwgLy8gRGVwdGggdG8gZXh0cnVkZSB0aGUgc2hhcGVcbiAqXG4gKlx0YmV2ZWxFbmFibGVkOiA8Ym9vbD4sIC8vIHR1cm4gb24gYmV2ZWxcbiAqXHRiZXZlbFRoaWNrbmVzczogPGZsb2F0PiwgLy8gaG93IGRlZXAgaW50byB0aGUgb3JpZ2luYWwgc2hhcGUgYmV2ZWwgZ29lc1xuICpcdGJldmVsU2l6ZTogPGZsb2F0PiwgLy8gaG93IGZhciBmcm9tIHNoYXBlIG91dGxpbmUgKGluY2x1ZGluZyBiZXZlbE9mZnNldCkgaXMgYmV2ZWxcbiAqXHRiZXZlbE9mZnNldDogPGZsb2F0PiwgLy8gaG93IGZhciBmcm9tIHNoYXBlIG91dGxpbmUgZG9lcyBiZXZlbCBzdGFydFxuICpcdGJldmVsU2VnbWVudHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgYmV2ZWwgbGF5ZXJzXG4gKlxuICpcdGV4dHJ1ZGVQYXRoOiA8VEhSRUUuQ3VydmU+IC8vIGN1cnZlIHRvIGV4dHJ1ZGUgc2hhcGUgYWxvbmdcbiAqXG4gKlx0VVZHZW5lcmF0b3I6IDxPYmplY3Q+IC8vIG9iamVjdCB0aGF0IHByb3ZpZGVzIFVWIGdlbmVyYXRvciBmdW5jdGlvbnNcbiAqXG4gKiB9XG4gKi9cbmNsYXNzIEV4dHJ1ZGVHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblx0Y29uc3RydWN0b3Ioc2hhcGVzID0gbmV3IFNoYXBlKFtuZXcgVmVjdG9yMigwLjUsIDAuNSksIG5ldyBWZWN0b3IyKC0wLjUsIDAuNSksIG5ldyBWZWN0b3IyKC0wLjUsIC0wLjUpLCBuZXcgVmVjdG9yMigwLjUsIC0wLjUpXSksIG9wdGlvbnMgPSB7fSkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy50eXBlID0gJ0V4dHJ1ZGVHZW9tZXRyeSc7XG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0c2hhcGVzOiBzaGFwZXMsXG5cdFx0XHRvcHRpb25zOiBvcHRpb25zXG5cdFx0fTtcblx0XHRzaGFwZXMgPSBBcnJheS5pc0FycmF5KHNoYXBlcykgPyBzaGFwZXMgOiBbc2hhcGVzXTtcblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cdFx0Y29uc3QgdmVydGljZXNBcnJheSA9IFtdO1xuXHRcdGNvbnN0IHV2QXJyYXkgPSBbXTtcblx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHNoYXBlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGNvbnN0IHNoYXBlID0gc2hhcGVzW2ldO1xuXHRcdFx0YWRkU2hhcGUoc2hhcGUpO1xuXHRcdH1cblxuXHRcdC8vIGJ1aWxkIGdlb21ldHJ5XG5cblx0XHR0aGlzLnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh2ZXJ0aWNlc0FycmF5LCAzKSk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodXZBcnJheSwgMikpO1xuXHRcdHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcblxuXHRcdC8vIGZ1bmN0aW9uc1xuXG5cdFx0ZnVuY3Rpb24gYWRkU2hhcGUoc2hhcGUpIHtcblx0XHRcdGNvbnN0IHBsYWNlaG9sZGVyID0gW107XG5cblx0XHRcdC8vIG9wdGlvbnNcblxuXHRcdFx0Y29uc3QgY3VydmVTZWdtZW50cyA9IG9wdGlvbnMuY3VydmVTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jdXJ2ZVNlZ21lbnRzIDogMTI7XG5cdFx0XHRjb25zdCBzdGVwcyA9IG9wdGlvbnMuc3RlcHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc3RlcHMgOiAxO1xuXHRcdFx0Y29uc3QgZGVwdGggPSBvcHRpb25zLmRlcHRoICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRlcHRoIDogMTtcblx0XHRcdGxldCBiZXZlbEVuYWJsZWQgPSBvcHRpb25zLmJldmVsRW5hYmxlZCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbEVuYWJsZWQgOiB0cnVlO1xuXHRcdFx0bGV0IGJldmVsVGhpY2tuZXNzID0gb3B0aW9ucy5iZXZlbFRoaWNrbmVzcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFRoaWNrbmVzcyA6IDAuMjtcblx0XHRcdGxldCBiZXZlbFNpemUgPSBvcHRpb25zLmJldmVsU2l6ZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFNpemUgOiBiZXZlbFRoaWNrbmVzcyAtIDAuMTtcblx0XHRcdGxldCBiZXZlbE9mZnNldCA9IG9wdGlvbnMuYmV2ZWxPZmZzZXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxPZmZzZXQgOiAwO1xuXHRcdFx0bGV0IGJldmVsU2VnbWVudHMgPSBvcHRpb25zLmJldmVsU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxTZWdtZW50cyA6IDM7XG5cdFx0XHRjb25zdCBleHRydWRlUGF0aCA9IG9wdGlvbnMuZXh0cnVkZVBhdGg7XG5cdFx0XHRjb25zdCB1dmdlbiA9IG9wdGlvbnMuVVZHZW5lcmF0b3IgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuVVZHZW5lcmF0b3IgOiBXb3JsZFVWR2VuZXJhdG9yO1xuXG5cdFx0XHQvL1xuXG5cdFx0XHRsZXQgZXh0cnVkZVB0cyxcblx0XHRcdFx0ZXh0cnVkZUJ5UGF0aCA9IGZhbHNlO1xuXHRcdFx0bGV0IHNwbGluZVR1YmUsIGJpbm9ybWFsLCBub3JtYWwsIHBvc2l0aW9uMjtcblx0XHRcdGlmIChleHRydWRlUGF0aCkge1xuXHRcdFx0XHRleHRydWRlUHRzID0gZXh0cnVkZVBhdGguZ2V0U3BhY2VkUG9pbnRzKHN0ZXBzKTtcblx0XHRcdFx0ZXh0cnVkZUJ5UGF0aCA9IHRydWU7XG5cdFx0XHRcdGJldmVsRW5hYmxlZCA9IGZhbHNlOyAvLyBiZXZlbHMgbm90IHN1cHBvcnRlZCBmb3IgcGF0aCBleHRydXNpb25cblxuXHRcdFx0XHQvLyBTRVRVUCBUTkIgdmFyaWFibGVzXG5cblx0XHRcdFx0Ly8gVE9ETzEgLSBoYXZlIGEgLmlzQ2xvc2VkIGluIHNwbGluZT9cblxuXHRcdFx0XHRzcGxpbmVUdWJlID0gZXh0cnVkZVBhdGguY29tcHV0ZUZyZW5ldEZyYW1lcyhzdGVwcywgZmFsc2UpO1xuXG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKHNwbGluZVR1YmUsICdzcGxpbmVUdWJlJywgc3BsaW5lVHViZS5ub3JtYWxzLmxlbmd0aCwgJ3N0ZXBzJywgc3RlcHMsICdleHRydWRlUHRzJywgZXh0cnVkZVB0cy5sZW5ndGgpO1xuXG5cdFx0XHRcdGJpbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdFx0bm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdFx0cG9zaXRpb24yID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2FmZWd1YXJkcyBpZiBiZXZlbHMgYXJlIG5vdCBlbmFibGVkXG5cblx0XHRcdGlmICghYmV2ZWxFbmFibGVkKSB7XG5cdFx0XHRcdGJldmVsU2VnbWVudHMgPSAwO1xuXHRcdFx0XHRiZXZlbFRoaWNrbmVzcyA9IDA7XG5cdFx0XHRcdGJldmVsU2l6ZSA9IDA7XG5cdFx0XHRcdGJldmVsT2Zmc2V0ID0gMDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVmFyaWFibGVzIGluaXRpYWxpemF0aW9uXG5cblx0XHRcdGNvbnN0IHNoYXBlUG9pbnRzID0gc2hhcGUuZXh0cmFjdFBvaW50cyhjdXJ2ZVNlZ21lbnRzKTtcblx0XHRcdGxldCB2ZXJ0aWNlcyA9IHNoYXBlUG9pbnRzLnNoYXBlO1xuXHRcdFx0Y29uc3QgaG9sZXMgPSBzaGFwZVBvaW50cy5ob2xlcztcblx0XHRcdGNvbnN0IHJldmVyc2UgPSAhU2hhcGVVdGlscy5pc0Nsb2NrV2lzZSh2ZXJ0aWNlcyk7XG5cdFx0XHRpZiAocmV2ZXJzZSkge1xuXHRcdFx0XHR2ZXJ0aWNlcyA9IHZlcnRpY2VzLnJldmVyc2UoKTtcblxuXHRcdFx0XHQvLyBNYXliZSB3ZSBzaG91bGQgYWxzbyBjaGVjayBpZiBob2xlcyBhcmUgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiwganVzdCB0byBiZSBzYWZlIC4uLlxuXG5cdFx0XHRcdGZvciAobGV0IGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoKyspIHtcblx0XHRcdFx0XHRjb25zdCBhaG9sZSA9IGhvbGVzW2hdO1xuXHRcdFx0XHRcdGlmIChTaGFwZVV0aWxzLmlzQ2xvY2tXaXNlKGFob2xlKSkge1xuXHRcdFx0XHRcdFx0aG9sZXNbaF0gPSBhaG9sZS5yZXZlcnNlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRjb25zdCBmYWNlcyA9IFNoYXBlVXRpbHMudHJpYW5ndWxhdGVTaGFwZSh2ZXJ0aWNlcywgaG9sZXMpO1xuXG5cdFx0XHQvKiBWZXJ0aWNlcyAqL1xuXG5cdFx0XHRjb25zdCBjb250b3VyID0gdmVydGljZXM7IC8vIHZlcnRpY2VzIGhhcyBhbGwgcG9pbnRzIGJ1dCBjb250b3VyIGhhcyBvbmx5IHBvaW50cyBvZiBjaXJjdW1mZXJlbmNlXG5cblx0XHRcdGZvciAobGV0IGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoKyspIHtcblx0XHRcdFx0Y29uc3QgYWhvbGUgPSBob2xlc1toXTtcblx0XHRcdFx0dmVydGljZXMgPSB2ZXJ0aWNlcy5jb25jYXQoYWhvbGUpO1xuXHRcdFx0fVxuXHRcdFx0ZnVuY3Rpb24gc2NhbGVQdDIocHQsIHZlYywgc2l6ZSkge1xuXHRcdFx0XHRpZiAoIXZlYykgY29uc29sZS5lcnJvcignVEhSRUUuRXh0cnVkZUdlb21ldHJ5OiB2ZWMgZG9lcyBub3QgZXhpc3QnKTtcblx0XHRcdFx0cmV0dXJuIHZlYy5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKHNpemUpLmFkZChwdCk7XG5cdFx0XHR9XG5cdFx0XHRjb25zdCB2bGVuID0gdmVydGljZXMubGVuZ3RoLFxuXHRcdFx0XHRmbGVuID0gZmFjZXMubGVuZ3RoO1xuXG5cdFx0XHQvLyBGaW5kIGRpcmVjdGlvbnMgZm9yIHBvaW50IG1vdmVtZW50XG5cblx0XHRcdGZ1bmN0aW9uIGdldEJldmVsVmVjKGluUHQsIGluUHJldiwgaW5OZXh0KSB7XG5cdFx0XHRcdC8vIGNvbXB1dGVzIGZvciBpblB0IHRoZSBjb3JyZXNwb25kaW5nIHBvaW50IGluUHQnIG9uIGEgbmV3IGNvbnRvdXJcblx0XHRcdFx0Ly9cdCBzaGlmdGVkIGJ5IDEgdW5pdCAobGVuZ3RoIG9mIG5vcm1hbGl6ZWQgdmVjdG9yKSB0byB0aGUgbGVmdFxuXHRcdFx0XHQvLyBpZiB3ZSB3YWxrIGFsb25nIGNvbnRvdXIgY2xvY2t3aXNlLCB0aGlzIG5ldyBjb250b3VyIGlzIG91dHNpZGUgdGhlIG9sZCBvbmVcblx0XHRcdFx0Ly9cblx0XHRcdFx0Ly8gaW5QdCcgaXMgdGhlIGludGVyc2VjdGlvbiBvZiB0aGUgdHdvIGxpbmVzIHBhcmFsbGVsIHRvIHRoZSB0d29cblx0XHRcdFx0Ly9cdGFkamFjZW50IGVkZ2VzIG9mIGluUHQgYXQgYSBkaXN0YW5jZSBvZiAxIHVuaXQgb24gdGhlIGxlZnQgc2lkZS5cblxuXHRcdFx0XHRsZXQgdl90cmFuc194LCB2X3RyYW5zX3ksIHNocmlua19ieTsgLy8gcmVzdWx0aW5nIHRyYW5zbGF0aW9uIHZlY3RvciBmb3IgaW5QdFxuXG5cdFx0XHRcdC8vIGdvb2QgcmVhZGluZyBmb3IgZ2VvbWV0cnkgYWxnb3JpdGhtcyAoaGVyZTogbGluZS1saW5lIGludGVyc2VjdGlvbilcblx0XHRcdFx0Ly8gaHR0cDovL2dlb21hbGdvcml0aG1zLmNvbS9hMDUtX2ludGVyc2VjdC0xLmh0bWxcblxuXHRcdFx0XHRjb25zdCB2X3ByZXZfeCA9IGluUHQueCAtIGluUHJldi54LFxuXHRcdFx0XHRcdHZfcHJldl95ID0gaW5QdC55IC0gaW5QcmV2Lnk7XG5cdFx0XHRcdGNvbnN0IHZfbmV4dF94ID0gaW5OZXh0LnggLSBpblB0LngsXG5cdFx0XHRcdFx0dl9uZXh0X3kgPSBpbk5leHQueSAtIGluUHQueTtcblx0XHRcdFx0Y29uc3Qgdl9wcmV2X2xlbnNxID0gdl9wcmV2X3ggKiB2X3ByZXZfeCArIHZfcHJldl95ICogdl9wcmV2X3k7XG5cblx0XHRcdFx0Ly8gY2hlY2sgZm9yIGNvbGxpbmVhciBlZGdlc1xuXHRcdFx0XHRjb25zdCBjb2xsaW5lYXIwID0gdl9wcmV2X3ggKiB2X25leHRfeSAtIHZfcHJldl95ICogdl9uZXh0X3g7XG5cdFx0XHRcdGlmIChNYXRoLmFicyhjb2xsaW5lYXIwKSA+IE51bWJlci5FUFNJTE9OKSB7XG5cdFx0XHRcdFx0Ly8gbm90IGNvbGxpbmVhclxuXG5cdFx0XHRcdFx0Ly8gbGVuZ3RoIG9mIHZlY3RvcnMgZm9yIG5vcm1hbGl6aW5nXG5cblx0XHRcdFx0XHRjb25zdCB2X3ByZXZfbGVuID0gTWF0aC5zcXJ0KHZfcHJldl9sZW5zcSk7XG5cdFx0XHRcdFx0Y29uc3Qgdl9uZXh0X2xlbiA9IE1hdGguc3FydCh2X25leHRfeCAqIHZfbmV4dF94ICsgdl9uZXh0X3kgKiB2X25leHRfeSk7XG5cblx0XHRcdFx0XHQvLyBzaGlmdCBhZGphY2VudCBwb2ludHMgYnkgdW5pdCB2ZWN0b3JzIHRvIHRoZSBsZWZ0XG5cblx0XHRcdFx0XHRjb25zdCBwdFByZXZTaGlmdF94ID0gaW5QcmV2LnggLSB2X3ByZXZfeSAvIHZfcHJldl9sZW47XG5cdFx0XHRcdFx0Y29uc3QgcHRQcmV2U2hpZnRfeSA9IGluUHJldi55ICsgdl9wcmV2X3ggLyB2X3ByZXZfbGVuO1xuXHRcdFx0XHRcdGNvbnN0IHB0TmV4dFNoaWZ0X3ggPSBpbk5leHQueCAtIHZfbmV4dF95IC8gdl9uZXh0X2xlbjtcblx0XHRcdFx0XHRjb25zdCBwdE5leHRTaGlmdF95ID0gaW5OZXh0LnkgKyB2X25leHRfeCAvIHZfbmV4dF9sZW47XG5cblx0XHRcdFx0XHQvLyBzY2FsaW5nIGZhY3RvciBmb3Igdl9wcmV2IHRvIGludGVyc2VjdGlvbiBwb2ludFxuXG5cdFx0XHRcdFx0Y29uc3Qgc2YgPSAoKHB0TmV4dFNoaWZ0X3ggLSBwdFByZXZTaGlmdF94KSAqIHZfbmV4dF95IC0gKHB0TmV4dFNoaWZ0X3kgLSBwdFByZXZTaGlmdF95KSAqIHZfbmV4dF94KSAvICh2X3ByZXZfeCAqIHZfbmV4dF95IC0gdl9wcmV2X3kgKiB2X25leHRfeCk7XG5cblx0XHRcdFx0XHQvLyB2ZWN0b3IgZnJvbSBpblB0IHRvIGludGVyc2VjdGlvbiBwb2ludFxuXG5cdFx0XHRcdFx0dl90cmFuc194ID0gcHRQcmV2U2hpZnRfeCArIHZfcHJldl94ICogc2YgLSBpblB0Lng7XG5cdFx0XHRcdFx0dl90cmFuc195ID0gcHRQcmV2U2hpZnRfeSArIHZfcHJldl95ICogc2YgLSBpblB0Lnk7XG5cblx0XHRcdFx0XHQvLyBEb24ndCBub3JtYWxpemUhLCBvdGhlcndpc2Ugc2hhcnAgY29ybmVycyBiZWNvbWUgdWdseVxuXHRcdFx0XHRcdC8vXHRidXQgcHJldmVudCBjcmF6eSBzcGlrZXNcblx0XHRcdFx0XHRjb25zdCB2X3RyYW5zX2xlbnNxID0gdl90cmFuc194ICogdl90cmFuc194ICsgdl90cmFuc195ICogdl90cmFuc195O1xuXHRcdFx0XHRcdGlmICh2X3RyYW5zX2xlbnNxIDw9IDIpIHtcblx0XHRcdFx0XHRcdHJldHVybiBuZXcgVmVjdG9yMih2X3RyYW5zX3gsIHZfdHJhbnNfeSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNocmlua19ieSA9IE1hdGguc3FydCh2X3RyYW5zX2xlbnNxIC8gMik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIGhhbmRsZSBzcGVjaWFsIGNhc2Ugb2YgY29sbGluZWFyIGVkZ2VzXG5cblx0XHRcdFx0XHRsZXQgZGlyZWN0aW9uX2VxID0gZmFsc2U7IC8vIGFzc3VtZXM6IG9wcG9zaXRlXG5cblx0XHRcdFx0XHRpZiAodl9wcmV2X3ggPiBOdW1iZXIuRVBTSUxPTikge1xuXHRcdFx0XHRcdFx0aWYgKHZfbmV4dF94ID4gTnVtYmVyLkVQU0lMT04pIHtcblx0XHRcdFx0XHRcdFx0ZGlyZWN0aW9uX2VxID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYgKHZfcHJldl94IDwgLU51bWJlci5FUFNJTE9OKSB7XG5cdFx0XHRcdFx0XHRcdGlmICh2X25leHRfeCA8IC1OdW1iZXIuRVBTSUxPTikge1xuXHRcdFx0XHRcdFx0XHRcdGRpcmVjdGlvbl9lcSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGlmIChNYXRoLnNpZ24odl9wcmV2X3kpID09PSBNYXRoLnNpZ24odl9uZXh0X3kpKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZGlyZWN0aW9uX2VxID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoZGlyZWN0aW9uX2VxKSB7XG5cdFx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcIldhcm5pbmc6IGxpbmVzIGFyZSBhIHN0cmFpZ2h0IHNlcXVlbmNlXCIpO1xuXHRcdFx0XHRcdFx0dl90cmFuc194ID0gLXZfcHJldl95O1xuXHRcdFx0XHRcdFx0dl90cmFuc195ID0gdl9wcmV2X3g7XG5cdFx0XHRcdFx0XHRzaHJpbmtfYnkgPSBNYXRoLnNxcnQodl9wcmV2X2xlbnNxKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCJXYXJuaW5nOiBsaW5lcyBhcmUgYSBzdHJhaWdodCBzcGlrZVwiKTtcblx0XHRcdFx0XHRcdHZfdHJhbnNfeCA9IHZfcHJldl94O1xuXHRcdFx0XHRcdFx0dl90cmFuc195ID0gdl9wcmV2X3k7XG5cdFx0XHRcdFx0XHRzaHJpbmtfYnkgPSBNYXRoLnNxcnQodl9wcmV2X2xlbnNxIC8gMik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBuZXcgVmVjdG9yMih2X3RyYW5zX3ggLyBzaHJpbmtfYnksIHZfdHJhbnNfeSAvIHNocmlua19ieSk7XG5cdFx0XHR9XG5cdFx0XHRjb25zdCBjb250b3VyTW92ZW1lbnRzID0gW107XG5cdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSBjb250b3VyLmxlbmd0aCwgaiA9IGlsIC0gMSwgayA9IGkgKyAxOyBpIDwgaWw7IGkrKywgaisrLCBrKyspIHtcblx0XHRcdFx0aWYgKGogPT09IGlsKSBqID0gMDtcblx0XHRcdFx0aWYgKGsgPT09IGlsKSBrID0gMDtcblxuXHRcdFx0XHQvL1x0KGopLS0tKGkpLS0tKGspXG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKCdpLGosaycsIGksIGogLCBrKVxuXG5cdFx0XHRcdGNvbnRvdXJNb3ZlbWVudHNbaV0gPSBnZXRCZXZlbFZlYyhjb250b3VyW2ldLCBjb250b3VyW2pdLCBjb250b3VyW2tdKTtcblx0XHRcdH1cblx0XHRcdGNvbnN0IGhvbGVzTW92ZW1lbnRzID0gW107XG5cdFx0XHRsZXQgb25lSG9sZU1vdmVtZW50cyxcblx0XHRcdFx0dmVydGljZXNNb3ZlbWVudHMgPSBjb250b3VyTW92ZW1lbnRzLmNvbmNhdCgpO1xuXHRcdFx0Zm9yIChsZXQgaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGgrKykge1xuXHRcdFx0XHRjb25zdCBhaG9sZSA9IGhvbGVzW2hdO1xuXHRcdFx0XHRvbmVIb2xlTW92ZW1lbnRzID0gW107XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IGFob2xlLmxlbmd0aCwgaiA9IGlsIC0gMSwgayA9IGkgKyAxOyBpIDwgaWw7IGkrKywgaisrLCBrKyspIHtcblx0XHRcdFx0XHRpZiAoaiA9PT0gaWwpIGogPSAwO1xuXHRcdFx0XHRcdGlmIChrID09PSBpbCkgayA9IDA7XG5cblx0XHRcdFx0XHQvL1x0KGopLS0tKGkpLS0tKGspXG5cdFx0XHRcdFx0b25lSG9sZU1vdmVtZW50c1tpXSA9IGdldEJldmVsVmVjKGFob2xlW2ldLCBhaG9sZVtqXSwgYWhvbGVba10pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGhvbGVzTW92ZW1lbnRzLnB1c2gob25lSG9sZU1vdmVtZW50cyk7XG5cdFx0XHRcdHZlcnRpY2VzTW92ZW1lbnRzID0gdmVydGljZXNNb3ZlbWVudHMuY29uY2F0KG9uZUhvbGVNb3ZlbWVudHMpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29wIGJldmVsU2VnbWVudHMsIDEgZm9yIHRoZSBmcm9udCwgMSBmb3IgdGhlIGJhY2tcblxuXHRcdFx0Zm9yIChsZXQgYiA9IDA7IGIgPCBiZXZlbFNlZ21lbnRzOyBiKyspIHtcblx0XHRcdFx0Ly9mb3IgKCBiID0gYmV2ZWxTZWdtZW50czsgYiA+IDA7IGIgLS0gKSB7XG5cblx0XHRcdFx0Y29uc3QgdCA9IGIgLyBiZXZlbFNlZ21lbnRzO1xuXHRcdFx0XHRjb25zdCB6ID0gYmV2ZWxUaGlja25lc3MgKiBNYXRoLmNvcyh0ICogTWF0aC5QSSAvIDIpO1xuXHRcdFx0XHRjb25zdCBicyA9IGJldmVsU2l6ZSAqIE1hdGguc2luKHQgKiBNYXRoLlBJIC8gMikgKyBiZXZlbE9mZnNldDtcblxuXHRcdFx0XHQvLyBjb250cmFjdCBzaGFwZVxuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHRcdGNvbnN0IHZlcnQgPSBzY2FsZVB0Mihjb250b3VyW2ldLCBjb250b3VyTW92ZW1lbnRzW2ldLCBicyk7XG5cdFx0XHRcdFx0dih2ZXJ0LngsIHZlcnQueSwgLXopO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gZXhwYW5kIGhvbGVzXG5cblx0XHRcdFx0Zm9yIChsZXQgaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGgrKykge1xuXHRcdFx0XHRcdGNvbnN0IGFob2xlID0gaG9sZXNbaF07XG5cdFx0XHRcdFx0b25lSG9sZU1vdmVtZW50cyA9IGhvbGVzTW92ZW1lbnRzW2hdO1xuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IGFob2xlLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0XHRcdGNvbnN0IHZlcnQgPSBzY2FsZVB0MihhaG9sZVtpXSwgb25lSG9sZU1vdmVtZW50c1tpXSwgYnMpO1xuXHRcdFx0XHRcdFx0dih2ZXJ0LngsIHZlcnQueSwgLXopO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Y29uc3QgYnMgPSBiZXZlbFNpemUgKyBiZXZlbE9mZnNldDtcblxuXHRcdFx0Ly8gQmFjayBmYWNpbmcgdmVydGljZXNcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB2bGVuOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgdmVydCA9IGJldmVsRW5hYmxlZCA/IHNjYWxlUHQyKHZlcnRpY2VzW2ldLCB2ZXJ0aWNlc01vdmVtZW50c1tpXSwgYnMpIDogdmVydGljZXNbaV07XG5cdFx0XHRcdGlmICghZXh0cnVkZUJ5UGF0aCkge1xuXHRcdFx0XHRcdHYodmVydC54LCB2ZXJ0LnksIDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHYoIHZlcnQueCwgdmVydC55ICsgZXh0cnVkZVB0c1sgMCBdLnksIGV4dHJ1ZGVQdHNbIDAgXS54ICk7XG5cblx0XHRcdFx0XHRub3JtYWwuY29weShzcGxpbmVUdWJlLm5vcm1hbHNbMF0pLm11bHRpcGx5U2NhbGFyKHZlcnQueCk7XG5cdFx0XHRcdFx0Ymlub3JtYWwuY29weShzcGxpbmVUdWJlLmJpbm9ybWFsc1swXSkubXVsdGlwbHlTY2FsYXIodmVydC55KTtcblx0XHRcdFx0XHRwb3NpdGlvbjIuY29weShleHRydWRlUHRzWzBdKS5hZGQobm9ybWFsKS5hZGQoYmlub3JtYWwpO1xuXHRcdFx0XHRcdHYocG9zaXRpb24yLngsIHBvc2l0aW9uMi55LCBwb3NpdGlvbjIueik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHN0ZXBwZWQgdmVydGljZXMuLi5cblx0XHRcdC8vIEluY2x1ZGluZyBmcm9udCBmYWNpbmcgdmVydGljZXNcblxuXHRcdFx0Zm9yIChsZXQgcyA9IDE7IHMgPD0gc3RlcHM7IHMrKykge1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHZsZW47IGkrKykge1xuXHRcdFx0XHRcdGNvbnN0IHZlcnQgPSBiZXZlbEVuYWJsZWQgPyBzY2FsZVB0Mih2ZXJ0aWNlc1tpXSwgdmVydGljZXNNb3ZlbWVudHNbaV0sIGJzKSA6IHZlcnRpY2VzW2ldO1xuXHRcdFx0XHRcdGlmICghZXh0cnVkZUJ5UGF0aCkge1xuXHRcdFx0XHRcdFx0dih2ZXJ0LngsIHZlcnQueSwgZGVwdGggLyBzdGVwcyAqIHMpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyB2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIHMgLSAxIF0ueSwgZXh0cnVkZVB0c1sgcyAtIDEgXS54ICk7XG5cblx0XHRcdFx0XHRcdG5vcm1hbC5jb3B5KHNwbGluZVR1YmUubm9ybWFsc1tzXSkubXVsdGlwbHlTY2FsYXIodmVydC54KTtcblx0XHRcdFx0XHRcdGJpbm9ybWFsLmNvcHkoc3BsaW5lVHViZS5iaW5vcm1hbHNbc10pLm11bHRpcGx5U2NhbGFyKHZlcnQueSk7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbjIuY29weShleHRydWRlUHRzW3NdKS5hZGQobm9ybWFsKS5hZGQoYmlub3JtYWwpO1xuXHRcdFx0XHRcdFx0dihwb3NpdGlvbjIueCwgcG9zaXRpb24yLnksIHBvc2l0aW9uMi56KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGJldmVsIHNlZ21lbnRzIHBsYW5lc1xuXG5cdFx0XHQvL2ZvciAoIGIgPSAxOyBiIDw9IGJldmVsU2VnbWVudHM7IGIgKysgKSB7XG5cdFx0XHRmb3IgKGxldCBiID0gYmV2ZWxTZWdtZW50cyAtIDE7IGIgPj0gMDsgYi0tKSB7XG5cdFx0XHRcdGNvbnN0IHQgPSBiIC8gYmV2ZWxTZWdtZW50cztcblx0XHRcdFx0Y29uc3QgeiA9IGJldmVsVGhpY2tuZXNzICogTWF0aC5jb3ModCAqIE1hdGguUEkgLyAyKTtcblx0XHRcdFx0Y29uc3QgYnMgPSBiZXZlbFNpemUgKiBNYXRoLnNpbih0ICogTWF0aC5QSSAvIDIpICsgYmV2ZWxPZmZzZXQ7XG5cblx0XHRcdFx0Ly8gY29udHJhY3Qgc2hhcGVcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSBjb250b3VyLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCB2ZXJ0ID0gc2NhbGVQdDIoY29udG91cltpXSwgY29udG91ck1vdmVtZW50c1tpXSwgYnMpO1xuXHRcdFx0XHRcdHYodmVydC54LCB2ZXJ0LnksIGRlcHRoICsgeik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBleHBhbmQgaG9sZXNcblxuXHRcdFx0XHRmb3IgKGxldCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCsrKSB7XG5cdFx0XHRcdFx0Y29uc3QgYWhvbGUgPSBob2xlc1toXTtcblx0XHRcdFx0XHRvbmVIb2xlTW92ZW1lbnRzID0gaG9sZXNNb3ZlbWVudHNbaF07XG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gYWhvbGUubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHRcdFx0Y29uc3QgdmVydCA9IHNjYWxlUHQyKGFob2xlW2ldLCBvbmVIb2xlTW92ZW1lbnRzW2ldLCBicyk7XG5cdFx0XHRcdFx0XHRpZiAoIWV4dHJ1ZGVCeVBhdGgpIHtcblx0XHRcdFx0XHRcdFx0dih2ZXJ0LngsIHZlcnQueSwgZGVwdGggKyB6KTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHYodmVydC54LCB2ZXJ0LnkgKyBleHRydWRlUHRzW3N0ZXBzIC0gMV0ueSwgZXh0cnVkZVB0c1tzdGVwcyAtIDFdLnggKyB6KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0LyogRmFjZXMgKi9cblxuXHRcdFx0Ly8gVG9wIGFuZCBib3R0b20gZmFjZXNcblxuXHRcdFx0YnVpbGRMaWRGYWNlcygpO1xuXG5cdFx0XHQvLyBTaWRlcyBmYWNlc1xuXG5cdFx0XHRidWlsZFNpZGVGYWNlcygpO1xuXG5cdFx0XHQvLy8vL1x0SW50ZXJuYWwgZnVuY3Rpb25zXG5cblx0XHRcdGZ1bmN0aW9uIGJ1aWxkTGlkRmFjZXMoKSB7XG5cdFx0XHRcdGNvbnN0IHN0YXJ0ID0gdmVydGljZXNBcnJheS5sZW5ndGggLyAzO1xuXHRcdFx0XHRpZiAoYmV2ZWxFbmFibGVkKSB7XG5cdFx0XHRcdFx0bGV0IGxheWVyID0gMDsgLy8gc3RlcHMgKyAxXG5cdFx0XHRcdFx0bGV0IG9mZnNldCA9IHZsZW4gKiBsYXllcjtcblxuXHRcdFx0XHRcdC8vIEJvdHRvbSBmYWNlc1xuXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBmbGVuOyBpKyspIHtcblx0XHRcdFx0XHRcdGNvbnN0IGZhY2UgPSBmYWNlc1tpXTtcblx0XHRcdFx0XHRcdGYzKGZhY2VbMl0gKyBvZmZzZXQsIGZhY2VbMV0gKyBvZmZzZXQsIGZhY2VbMF0gKyBvZmZzZXQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRsYXllciA9IHN0ZXBzICsgYmV2ZWxTZWdtZW50cyAqIDI7XG5cdFx0XHRcdFx0b2Zmc2V0ID0gdmxlbiAqIGxheWVyO1xuXG5cdFx0XHRcdFx0Ly8gVG9wIGZhY2VzXG5cblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGZsZW47IGkrKykge1xuXHRcdFx0XHRcdFx0Y29uc3QgZmFjZSA9IGZhY2VzW2ldO1xuXHRcdFx0XHRcdFx0ZjMoZmFjZVswXSArIG9mZnNldCwgZmFjZVsxXSArIG9mZnNldCwgZmFjZVsyXSArIG9mZnNldCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIEJvdHRvbSBmYWNlc1xuXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBmbGVuOyBpKyspIHtcblx0XHRcdFx0XHRcdGNvbnN0IGZhY2UgPSBmYWNlc1tpXTtcblx0XHRcdFx0XHRcdGYzKGZhY2VbMl0sIGZhY2VbMV0sIGZhY2VbMF0pO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFRvcCBmYWNlc1xuXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBmbGVuOyBpKyspIHtcblx0XHRcdFx0XHRcdGNvbnN0IGZhY2UgPSBmYWNlc1tpXTtcblx0XHRcdFx0XHRcdGYzKGZhY2VbMF0gKyB2bGVuICogc3RlcHMsIGZhY2VbMV0gKyB2bGVuICogc3RlcHMsIGZhY2VbMl0gKyB2bGVuICogc3RlcHMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRzY29wZS5hZGRHcm91cChzdGFydCwgdmVydGljZXNBcnJheS5sZW5ndGggLyAzIC0gc3RhcnQsIDApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDcmVhdGUgZmFjZXMgZm9yIHRoZSB6LXNpZGVzIG9mIHRoZSBzaGFwZVxuXG5cdFx0XHRmdW5jdGlvbiBidWlsZFNpZGVGYWNlcygpIHtcblx0XHRcdFx0Y29uc3Qgc3RhcnQgPSB2ZXJ0aWNlc0FycmF5Lmxlbmd0aCAvIDM7XG5cdFx0XHRcdGxldCBsYXllcm9mZnNldCA9IDA7XG5cdFx0XHRcdHNpZGV3YWxscyhjb250b3VyLCBsYXllcm9mZnNldCk7XG5cdFx0XHRcdGxheWVyb2Zmc2V0ICs9IGNvbnRvdXIubGVuZ3RoO1xuXHRcdFx0XHRmb3IgKGxldCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCsrKSB7XG5cdFx0XHRcdFx0Y29uc3QgYWhvbGUgPSBob2xlc1toXTtcblx0XHRcdFx0XHRzaWRld2FsbHMoYWhvbGUsIGxheWVyb2Zmc2V0KTtcblxuXHRcdFx0XHRcdC8vLCB0cnVlXG5cdFx0XHRcdFx0bGF5ZXJvZmZzZXQgKz0gYWhvbGUubGVuZ3RoO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNjb3BlLmFkZEdyb3VwKHN0YXJ0LCB2ZXJ0aWNlc0FycmF5Lmxlbmd0aCAvIDMgLSBzdGFydCwgMSk7XG5cdFx0XHR9XG5cdFx0XHRmdW5jdGlvbiBzaWRld2FsbHMoY29udG91ciwgbGF5ZXJvZmZzZXQpIHtcblx0XHRcdFx0bGV0IGkgPSBjb250b3VyLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+PSAwKSB7XG5cdFx0XHRcdFx0Y29uc3QgaiA9IGk7XG5cdFx0XHRcdFx0bGV0IGsgPSBpIC0gMTtcblx0XHRcdFx0XHRpZiAoayA8IDApIGsgPSBjb250b3VyLmxlbmd0aCAtIDE7XG5cblx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKCdiJywgaSxqLCBpLTEsIGssdmVydGljZXMubGVuZ3RoKTtcblxuXHRcdFx0XHRcdGZvciAobGV0IHMgPSAwLCBzbCA9IHN0ZXBzICsgYmV2ZWxTZWdtZW50cyAqIDI7IHMgPCBzbDsgcysrKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBzbGVuMSA9IHZsZW4gKiBzO1xuXHRcdFx0XHRcdFx0Y29uc3Qgc2xlbjIgPSB2bGVuICogKHMgKyAxKTtcblx0XHRcdFx0XHRcdGNvbnN0IGEgPSBsYXllcm9mZnNldCArIGogKyBzbGVuMSxcblx0XHRcdFx0XHRcdFx0YiA9IGxheWVyb2Zmc2V0ICsgayArIHNsZW4xLFxuXHRcdFx0XHRcdFx0XHRjID0gbGF5ZXJvZmZzZXQgKyBrICsgc2xlbjIsXG5cdFx0XHRcdFx0XHRcdGQgPSBsYXllcm9mZnNldCArIGogKyBzbGVuMjtcblx0XHRcdFx0XHRcdGY0KGEsIGIsIGMsIGQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZnVuY3Rpb24gdih4LCB5LCB6KSB7XG5cdFx0XHRcdHBsYWNlaG9sZGVyLnB1c2goeCk7XG5cdFx0XHRcdHBsYWNlaG9sZGVyLnB1c2goeSk7XG5cdFx0XHRcdHBsYWNlaG9sZGVyLnB1c2goeik7XG5cdFx0XHR9XG5cdFx0XHRmdW5jdGlvbiBmMyhhLCBiLCBjKSB7XG5cdFx0XHRcdGFkZFZlcnRleChhKTtcblx0XHRcdFx0YWRkVmVydGV4KGIpO1xuXHRcdFx0XHRhZGRWZXJ0ZXgoYyk7XG5cdFx0XHRcdGNvbnN0IG5leHRJbmRleCA9IHZlcnRpY2VzQXJyYXkubGVuZ3RoIC8gMztcblx0XHRcdFx0Y29uc3QgdXZzID0gdXZnZW4uZ2VuZXJhdGVUb3BVVihzY29wZSwgdmVydGljZXNBcnJheSwgbmV4dEluZGV4IC0gMywgbmV4dEluZGV4IC0gMiwgbmV4dEluZGV4IC0gMSk7XG5cdFx0XHRcdGFkZFVWKHV2c1swXSk7XG5cdFx0XHRcdGFkZFVWKHV2c1sxXSk7XG5cdFx0XHRcdGFkZFVWKHV2c1syXSk7XG5cdFx0XHR9XG5cdFx0XHRmdW5jdGlvbiBmNChhLCBiLCBjLCBkKSB7XG5cdFx0XHRcdGFkZFZlcnRleChhKTtcblx0XHRcdFx0YWRkVmVydGV4KGIpO1xuXHRcdFx0XHRhZGRWZXJ0ZXgoZCk7XG5cdFx0XHRcdGFkZFZlcnRleChiKTtcblx0XHRcdFx0YWRkVmVydGV4KGMpO1xuXHRcdFx0XHRhZGRWZXJ0ZXgoZCk7XG5cdFx0XHRcdGNvbnN0IG5leHRJbmRleCA9IHZlcnRpY2VzQXJyYXkubGVuZ3RoIC8gMztcblx0XHRcdFx0Y29uc3QgdXZzID0gdXZnZW4uZ2VuZXJhdGVTaWRlV2FsbFVWKHNjb3BlLCB2ZXJ0aWNlc0FycmF5LCBuZXh0SW5kZXggLSA2LCBuZXh0SW5kZXggLSAzLCBuZXh0SW5kZXggLSAyLCBuZXh0SW5kZXggLSAxKTtcblx0XHRcdFx0YWRkVVYodXZzWzBdKTtcblx0XHRcdFx0YWRkVVYodXZzWzFdKTtcblx0XHRcdFx0YWRkVVYodXZzWzNdKTtcblx0XHRcdFx0YWRkVVYodXZzWzFdKTtcblx0XHRcdFx0YWRkVVYodXZzWzJdKTtcblx0XHRcdFx0YWRkVVYodXZzWzNdKTtcblx0XHRcdH1cblx0XHRcdGZ1bmN0aW9uIGFkZFZlcnRleChpbmRleCkge1xuXHRcdFx0XHR2ZXJ0aWNlc0FycmF5LnB1c2gocGxhY2Vob2xkZXJbaW5kZXggKiAzICsgMF0pO1xuXHRcdFx0XHR2ZXJ0aWNlc0FycmF5LnB1c2gocGxhY2Vob2xkZXJbaW5kZXggKiAzICsgMV0pO1xuXHRcdFx0XHR2ZXJ0aWNlc0FycmF5LnB1c2gocGxhY2Vob2xkZXJbaW5kZXggKiAzICsgMl0pO1xuXHRcdFx0fVxuXHRcdFx0ZnVuY3Rpb24gYWRkVVYodmVjdG9yMikge1xuXHRcdFx0XHR1dkFycmF5LnB1c2godmVjdG9yMi54KTtcblx0XHRcdFx0dXZBcnJheS5wdXNoKHZlY3RvcjIueSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHRvSlNPTigpIHtcblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cdFx0Y29uc3Qgc2hhcGVzID0gdGhpcy5wYXJhbWV0ZXJzLnNoYXBlcztcblx0XHRjb25zdCBvcHRpb25zID0gdGhpcy5wYXJhbWV0ZXJzLm9wdGlvbnM7XG5cdFx0cmV0dXJuIHRvSlNPTiQxKHNoYXBlcywgb3B0aW9ucywgZGF0YSk7XG5cdH1cblx0c3RhdGljIGZyb21KU09OKGRhdGEsIHNoYXBlcykge1xuXHRcdGNvbnN0IGdlb21ldHJ5U2hhcGVzID0gW107XG5cdFx0Zm9yIChsZXQgaiA9IDAsIGpsID0gZGF0YS5zaGFwZXMubGVuZ3RoOyBqIDwgamw7IGorKykge1xuXHRcdFx0Y29uc3Qgc2hhcGUgPSBzaGFwZXNbZGF0YS5zaGFwZXNbal1dO1xuXHRcdFx0Z2VvbWV0cnlTaGFwZXMucHVzaChzaGFwZSk7XG5cdFx0fVxuXHRcdGNvbnN0IGV4dHJ1ZGVQYXRoID0gZGF0YS5vcHRpb25zLmV4dHJ1ZGVQYXRoO1xuXHRcdGlmIChleHRydWRlUGF0aCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRkYXRhLm9wdGlvbnMuZXh0cnVkZVBhdGggPSBuZXcgQ3VydmVzW2V4dHJ1ZGVQYXRoLnR5cGVdKCkuZnJvbUpTT04oZXh0cnVkZVBhdGgpO1xuXHRcdH1cblx0XHRyZXR1cm4gbmV3IEV4dHJ1ZGVHZW9tZXRyeShnZW9tZXRyeVNoYXBlcywgZGF0YS5vcHRpb25zKTtcblx0fVxufVxuY29uc3QgV29ybGRVVkdlbmVyYXRvciA9IHtcblx0Z2VuZXJhdGVUb3BVVjogZnVuY3Rpb24gKGdlb21ldHJ5LCB2ZXJ0aWNlcywgaW5kZXhBLCBpbmRleEIsIGluZGV4Qykge1xuXHRcdGNvbnN0IGFfeCA9IHZlcnRpY2VzW2luZGV4QSAqIDNdO1xuXHRcdGNvbnN0IGFfeSA9IHZlcnRpY2VzW2luZGV4QSAqIDMgKyAxXTtcblx0XHRjb25zdCBiX3ggPSB2ZXJ0aWNlc1tpbmRleEIgKiAzXTtcblx0XHRjb25zdCBiX3kgPSB2ZXJ0aWNlc1tpbmRleEIgKiAzICsgMV07XG5cdFx0Y29uc3QgY194ID0gdmVydGljZXNbaW5kZXhDICogM107XG5cdFx0Y29uc3QgY195ID0gdmVydGljZXNbaW5kZXhDICogMyArIDFdO1xuXHRcdHJldHVybiBbbmV3IFZlY3RvcjIoYV94LCBhX3kpLCBuZXcgVmVjdG9yMihiX3gsIGJfeSksIG5ldyBWZWN0b3IyKGNfeCwgY195KV07XG5cdH0sXG5cdGdlbmVyYXRlU2lkZVdhbGxVVjogZnVuY3Rpb24gKGdlb21ldHJ5LCB2ZXJ0aWNlcywgaW5kZXhBLCBpbmRleEIsIGluZGV4QywgaW5kZXhEKSB7XG5cdFx0Y29uc3QgYV94ID0gdmVydGljZXNbaW5kZXhBICogM107XG5cdFx0Y29uc3QgYV95ID0gdmVydGljZXNbaW5kZXhBICogMyArIDFdO1xuXHRcdGNvbnN0IGFfeiA9IHZlcnRpY2VzW2luZGV4QSAqIDMgKyAyXTtcblx0XHRjb25zdCBiX3ggPSB2ZXJ0aWNlc1tpbmRleEIgKiAzXTtcblx0XHRjb25zdCBiX3kgPSB2ZXJ0aWNlc1tpbmRleEIgKiAzICsgMV07XG5cdFx0Y29uc3QgYl96ID0gdmVydGljZXNbaW5kZXhCICogMyArIDJdO1xuXHRcdGNvbnN0IGNfeCA9IHZlcnRpY2VzW2luZGV4QyAqIDNdO1xuXHRcdGNvbnN0IGNfeSA9IHZlcnRpY2VzW2luZGV4QyAqIDMgKyAxXTtcblx0XHRjb25zdCBjX3ogPSB2ZXJ0aWNlc1tpbmRleEMgKiAzICsgMl07XG5cdFx0Y29uc3QgZF94ID0gdmVydGljZXNbaW5kZXhEICogM107XG5cdFx0Y29uc3QgZF95ID0gdmVydGljZXNbaW5kZXhEICogMyArIDFdO1xuXHRcdGNvbnN0IGRfeiA9IHZlcnRpY2VzW2luZGV4RCAqIDMgKyAyXTtcblx0XHRpZiAoTWF0aC5hYnMoYV95IC0gYl95KSA8IE1hdGguYWJzKGFfeCAtIGJfeCkpIHtcblx0XHRcdHJldHVybiBbbmV3IFZlY3RvcjIoYV94LCAxIC0gYV96KSwgbmV3IFZlY3RvcjIoYl94LCAxIC0gYl96KSwgbmV3IFZlY3RvcjIoY194LCAxIC0gY196KSwgbmV3IFZlY3RvcjIoZF94LCAxIC0gZF96KV07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBbbmV3IFZlY3RvcjIoYV95LCAxIC0gYV96KSwgbmV3IFZlY3RvcjIoYl95LCAxIC0gYl96KSwgbmV3IFZlY3RvcjIoY195LCAxIC0gY196KSwgbmV3IFZlY3RvcjIoZF95LCAxIC0gZF96KV07XG5cdFx0fVxuXHR9XG59O1xuZnVuY3Rpb24gdG9KU09OJDEoc2hhcGVzLCBvcHRpb25zLCBkYXRhKSB7XG5cdGRhdGEuc2hhcGVzID0gW107XG5cdGlmIChBcnJheS5pc0FycmF5KHNoYXBlcykpIHtcblx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHNoYXBlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGNvbnN0IHNoYXBlID0gc2hhcGVzW2ldO1xuXHRcdFx0ZGF0YS5zaGFwZXMucHVzaChzaGFwZS51dWlkKTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0ZGF0YS5zaGFwZXMucHVzaChzaGFwZXMudXVpZCk7XG5cdH1cblx0ZGF0YS5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG5cdGlmIChvcHRpb25zLmV4dHJ1ZGVQYXRoICE9PSB1bmRlZmluZWQpIGRhdGEub3B0aW9ucy5leHRydWRlUGF0aCA9IG9wdGlvbnMuZXh0cnVkZVBhdGgudG9KU09OKCk7XG5cdHJldHVybiBkYXRhO1xufVxuXG5jbGFzcyBJY29zYWhlZHJvbkdlb21ldHJ5IGV4dGVuZHMgUG9seWhlZHJvbkdlb21ldHJ5IHtcblx0Y29uc3RydWN0b3IocmFkaXVzID0gMSwgZGV0YWlsID0gMCkge1xuXHRcdGNvbnN0IHQgPSAoMSArIE1hdGguc3FydCg1KSkgLyAyO1xuXHRcdGNvbnN0IHZlcnRpY2VzID0gWy0xLCB0LCAwLCAxLCB0LCAwLCAtMSwgLXQsIDAsIDEsIC10LCAwLCAwLCAtMSwgdCwgMCwgMSwgdCwgMCwgLTEsIC10LCAwLCAxLCAtdCwgdCwgMCwgLTEsIHQsIDAsIDEsIC10LCAwLCAtMSwgLXQsIDAsIDFdO1xuXHRcdGNvbnN0IGluZGljZXMgPSBbMCwgMTEsIDUsIDAsIDUsIDEsIDAsIDEsIDcsIDAsIDcsIDEwLCAwLCAxMCwgMTEsIDEsIDUsIDksIDUsIDExLCA0LCAxMSwgMTAsIDIsIDEwLCA3LCA2LCA3LCAxLCA4LCAzLCA5LCA0LCAzLCA0LCAyLCAzLCAyLCA2LCAzLCA2LCA4LCAzLCA4LCA5LCA0LCA5LCA1LCAyLCA0LCAxMSwgNiwgMiwgMTAsIDgsIDYsIDcsIDksIDgsIDFdO1xuXHRcdHN1cGVyKHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCk7XG5cdFx0dGhpcy50eXBlID0gJ0ljb3NhaGVkcm9uR2VvbWV0cnknO1xuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdFx0ZGV0YWlsOiBkZXRhaWxcblx0XHR9O1xuXHR9XG5cdHN0YXRpYyBmcm9tSlNPTihkYXRhKSB7XG5cdFx0cmV0dXJuIG5ldyBJY29zYWhlZHJvbkdlb21ldHJ5KGRhdGEucmFkaXVzLCBkYXRhLmRldGFpbCk7XG5cdH1cbn1cblxuY2xhc3MgT2N0YWhlZHJvbkdlb21ldHJ5IGV4dGVuZHMgUG9seWhlZHJvbkdlb21ldHJ5IHtcblx0Y29uc3RydWN0b3IocmFkaXVzID0gMSwgZGV0YWlsID0gMCkge1xuXHRcdGNvbnN0IHZlcnRpY2VzID0gWzEsIDAsIDAsIC0xLCAwLCAwLCAwLCAxLCAwLCAwLCAtMSwgMCwgMCwgMCwgMSwgMCwgMCwgLTFdO1xuXHRcdGNvbnN0IGluZGljZXMgPSBbMCwgMiwgNCwgMCwgNCwgMywgMCwgMywgNSwgMCwgNSwgMiwgMSwgMiwgNSwgMSwgNSwgMywgMSwgMywgNCwgMSwgNCwgMl07XG5cdFx0c3VwZXIodmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsKTtcblx0XHR0aGlzLnR5cGUgPSAnT2N0YWhlZHJvbkdlb21ldHJ5Jztcblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRcdGRldGFpbDogZGV0YWlsXG5cdFx0fTtcblx0fVxuXHRzdGF0aWMgZnJvbUpTT04oZGF0YSkge1xuXHRcdHJldHVybiBuZXcgT2N0YWhlZHJvbkdlb21ldHJ5KGRhdGEucmFkaXVzLCBkYXRhLmRldGFpbCk7XG5cdH1cbn1cblxuY2xhc3MgUmluZ0dlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXHRjb25zdHJ1Y3Rvcihpbm5lclJhZGl1cyA9IDAuNSwgb3V0ZXJSYWRpdXMgPSAxLCB0aGV0YVNlZ21lbnRzID0gOCwgcGhpU2VnbWVudHMgPSAxLCB0aGV0YVN0YXJ0ID0gMCwgdGhldGFMZW5ndGggPSBNYXRoLlBJICogMikge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy50eXBlID0gJ1JpbmdHZW9tZXRyeSc7XG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0aW5uZXJSYWRpdXM6IGlubmVyUmFkaXVzLFxuXHRcdFx0b3V0ZXJSYWRpdXM6IG91dGVyUmFkaXVzLFxuXHRcdFx0dGhldGFTZWdtZW50czogdGhldGFTZWdtZW50cyxcblx0XHRcdHBoaVNlZ21lbnRzOiBwaGlTZWdtZW50cyxcblx0XHRcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXG5cdFx0XHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcblx0XHR9O1xuXHRcdHRoZXRhU2VnbWVudHMgPSBNYXRoLm1heCgzLCB0aGV0YVNlZ21lbnRzKTtcblx0XHRwaGlTZWdtZW50cyA9IE1hdGgubWF4KDEsIHBoaVNlZ21lbnRzKTtcblxuXHRcdC8vIGJ1ZmZlcnNcblxuXHRcdGNvbnN0IGluZGljZXMgPSBbXTtcblx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcblx0XHRjb25zdCB1dnMgPSBbXTtcblxuXHRcdC8vIHNvbWUgaGVscGVyIHZhcmlhYmxlc1xuXG5cdFx0bGV0IHJhZGl1cyA9IGlubmVyUmFkaXVzO1xuXHRcdGNvbnN0IHJhZGl1c1N0ZXAgPSAob3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cykgLyBwaGlTZWdtZW50cztcblx0XHRjb25zdCB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IHV2ID0gbmV3IFZlY3RvcjIoKTtcblxuXHRcdC8vIGdlbmVyYXRlIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcblxuXHRcdGZvciAobGV0IGogPSAwOyBqIDw9IHBoaVNlZ21lbnRzOyBqKyspIHtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDw9IHRoZXRhU2VnbWVudHM7IGkrKykge1xuXHRcdFx0XHQvLyB2YWx1ZXMgYXJlIGdlbmVyYXRlIGZyb20gdGhlIGluc2lkZSBvZiB0aGUgcmluZyB0byB0aGUgb3V0c2lkZVxuXG5cdFx0XHRcdGNvbnN0IHNlZ21lbnQgPSB0aGV0YVN0YXJ0ICsgaSAvIHRoZXRhU2VnbWVudHMgKiB0aGV0YUxlbmd0aDtcblxuXHRcdFx0XHQvLyB2ZXJ0ZXhcblxuXHRcdFx0XHR2ZXJ0ZXgueCA9IHJhZGl1cyAqIE1hdGguY29zKHNlZ21lbnQpO1xuXHRcdFx0XHR2ZXJ0ZXgueSA9IHJhZGl1cyAqIE1hdGguc2luKHNlZ21lbnQpO1xuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnopO1xuXG5cdFx0XHRcdC8vIG5vcm1hbFxuXG5cdFx0XHRcdG5vcm1hbHMucHVzaCgwLCAwLCAxKTtcblxuXHRcdFx0XHQvLyB1dlxuXG5cdFx0XHRcdHV2LnggPSAodmVydGV4LnggLyBvdXRlclJhZGl1cyArIDEpIC8gMjtcblx0XHRcdFx0dXYueSA9ICh2ZXJ0ZXgueSAvIG91dGVyUmFkaXVzICsgMSkgLyAyO1xuXHRcdFx0XHR1dnMucHVzaCh1di54LCB1di55KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gaW5jcmVhc2UgdGhlIHJhZGl1cyBmb3IgbmV4dCByb3cgb2YgdmVydGljZXNcblxuXHRcdFx0cmFkaXVzICs9IHJhZGl1c1N0ZXA7XG5cdFx0fVxuXG5cdFx0Ly8gaW5kaWNlc1xuXG5cdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBwaGlTZWdtZW50czsgaisrKSB7XG5cdFx0XHRjb25zdCB0aGV0YVNlZ21lbnRMZXZlbCA9IGogKiAodGhldGFTZWdtZW50cyArIDEpO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGV0YVNlZ21lbnRzOyBpKyspIHtcblx0XHRcdFx0Y29uc3Qgc2VnbWVudCA9IGkgKyB0aGV0YVNlZ21lbnRMZXZlbDtcblx0XHRcdFx0Y29uc3QgYSA9IHNlZ21lbnQ7XG5cdFx0XHRcdGNvbnN0IGIgPSBzZWdtZW50ICsgdGhldGFTZWdtZW50cyArIDE7XG5cdFx0XHRcdGNvbnN0IGMgPSBzZWdtZW50ICsgdGhldGFTZWdtZW50cyArIDI7XG5cdFx0XHRcdGNvbnN0IGQgPSBzZWdtZW50ICsgMTtcblxuXHRcdFx0XHQvLyBmYWNlc1xuXG5cdFx0XHRcdGluZGljZXMucHVzaChhLCBiLCBkKTtcblx0XHRcdFx0aW5kaWNlcy5wdXNoKGIsIGMsIGQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGJ1aWxkIGdlb21ldHJ5XG5cblx0XHR0aGlzLnNldEluZGV4KGluZGljZXMpO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHZlcnRpY2VzLCAzKSk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKG5vcm1hbHMsIDMpKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSgndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh1dnMsIDIpKTtcblx0fVxuXHRzdGF0aWMgZnJvbUpTT04oZGF0YSkge1xuXHRcdHJldHVybiBuZXcgUmluZ0dlb21ldHJ5KGRhdGEuaW5uZXJSYWRpdXMsIGRhdGEub3V0ZXJSYWRpdXMsIGRhdGEudGhldGFTZWdtZW50cywgZGF0YS5waGlTZWdtZW50cywgZGF0YS50aGV0YVN0YXJ0LCBkYXRhLnRoZXRhTGVuZ3RoKTtcblx0fVxufVxuXG5jbGFzcyBTaGFwZUdlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXHRjb25zdHJ1Y3RvcihzaGFwZXMgPSBuZXcgU2hhcGUoW25ldyBWZWN0b3IyKDAsIDAuNSksIG5ldyBWZWN0b3IyKC0wLjUsIC0wLjUpLCBuZXcgVmVjdG9yMigwLjUsIC0wLjUpXSksIGN1cnZlU2VnbWVudHMgPSAxMikge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy50eXBlID0gJ1NoYXBlR2VvbWV0cnknO1xuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdHNoYXBlczogc2hhcGVzLFxuXHRcdFx0Y3VydmVTZWdtZW50czogY3VydmVTZWdtZW50c1xuXHRcdH07XG5cblx0XHQvLyBidWZmZXJzXG5cblx0XHRjb25zdCBpbmRpY2VzID0gW107XG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblx0XHRjb25zdCBub3JtYWxzID0gW107XG5cdFx0Y29uc3QgdXZzID0gW107XG5cblx0XHQvLyBoZWxwZXIgdmFyaWFibGVzXG5cblx0XHRsZXQgZ3JvdXBTdGFydCA9IDA7XG5cdFx0bGV0IGdyb3VwQ291bnQgPSAwO1xuXG5cdFx0Ly8gYWxsb3cgc2luZ2xlIGFuZCBhcnJheSB2YWx1ZXMgZm9yIFwic2hhcGVzXCIgcGFyYW1ldGVyXG5cblx0XHRpZiAoQXJyYXkuaXNBcnJheShzaGFwZXMpID09PSBmYWxzZSkge1xuXHRcdFx0YWRkU2hhcGUoc2hhcGVzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzaGFwZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0YWRkU2hhcGUoc2hhcGVzW2ldKTtcblx0XHRcdFx0dGhpcy5hZGRHcm91cChncm91cFN0YXJ0LCBncm91cENvdW50LCBpKTsgLy8gZW5hYmxlcyBNdWx0aU1hdGVyaWFsIHN1cHBvcnRcblxuXHRcdFx0XHRncm91cFN0YXJ0ICs9IGdyb3VwQ291bnQ7XG5cdFx0XHRcdGdyb3VwQ291bnQgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGJ1aWxkIGdlb21ldHJ5XG5cblx0XHR0aGlzLnNldEluZGV4KGluZGljZXMpO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHZlcnRpY2VzLCAzKSk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKG5vcm1hbHMsIDMpKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSgndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh1dnMsIDIpKTtcblxuXHRcdC8vIGhlbHBlciBmdW5jdGlvbnNcblxuXHRcdGZ1bmN0aW9uIGFkZFNoYXBlKHNoYXBlKSB7XG5cdFx0XHRjb25zdCBpbmRleE9mZnNldCA9IHZlcnRpY2VzLmxlbmd0aCAvIDM7XG5cdFx0XHRjb25zdCBwb2ludHMgPSBzaGFwZS5leHRyYWN0UG9pbnRzKGN1cnZlU2VnbWVudHMpO1xuXHRcdFx0bGV0IHNoYXBlVmVydGljZXMgPSBwb2ludHMuc2hhcGU7XG5cdFx0XHRjb25zdCBzaGFwZUhvbGVzID0gcG9pbnRzLmhvbGVzO1xuXG5cdFx0XHQvLyBjaGVjayBkaXJlY3Rpb24gb2YgdmVydGljZXNcblxuXHRcdFx0aWYgKFNoYXBlVXRpbHMuaXNDbG9ja1dpc2Uoc2hhcGVWZXJ0aWNlcykgPT09IGZhbHNlKSB7XG5cdFx0XHRcdHNoYXBlVmVydGljZXMgPSBzaGFwZVZlcnRpY2VzLnJldmVyc2UoKTtcblx0XHRcdH1cblx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gc2hhcGVIb2xlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0Y29uc3Qgc2hhcGVIb2xlID0gc2hhcGVIb2xlc1tpXTtcblx0XHRcdFx0aWYgKFNoYXBlVXRpbHMuaXNDbG9ja1dpc2Uoc2hhcGVIb2xlKSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdHNoYXBlSG9sZXNbaV0gPSBzaGFwZUhvbGUucmV2ZXJzZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRjb25zdCBmYWNlcyA9IFNoYXBlVXRpbHMudHJpYW5ndWxhdGVTaGFwZShzaGFwZVZlcnRpY2VzLCBzaGFwZUhvbGVzKTtcblxuXHRcdFx0Ly8gam9pbiB2ZXJ0aWNlcyBvZiBpbm5lciBhbmQgb3V0ZXIgcGF0aHMgdG8gYSBzaW5nbGUgYXJyYXlcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBzaGFwZUhvbGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRjb25zdCBzaGFwZUhvbGUgPSBzaGFwZUhvbGVzW2ldO1xuXHRcdFx0XHRzaGFwZVZlcnRpY2VzID0gc2hhcGVWZXJ0aWNlcy5jb25jYXQoc2hhcGVIb2xlKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gdmVydGljZXMsIG5vcm1hbHMsIHV2c1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHNoYXBlVmVydGljZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IHZlcnRleCA9IHNoYXBlVmVydGljZXNbaV07XG5cdFx0XHRcdHZlcnRpY2VzLnB1c2godmVydGV4LngsIHZlcnRleC55LCAwKTtcblx0XHRcdFx0bm9ybWFscy5wdXNoKDAsIDAsIDEpO1xuXHRcdFx0XHR1dnMucHVzaCh2ZXJ0ZXgueCwgdmVydGV4LnkpOyAvLyB3b3JsZCB1dnNcblx0XHRcdH1cblxuXHRcdFx0Ly8gaW5jaWRlc1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRjb25zdCBmYWNlID0gZmFjZXNbaV07XG5cdFx0XHRcdGNvbnN0IGEgPSBmYWNlWzBdICsgaW5kZXhPZmZzZXQ7XG5cdFx0XHRcdGNvbnN0IGIgPSBmYWNlWzFdICsgaW5kZXhPZmZzZXQ7XG5cdFx0XHRcdGNvbnN0IGMgPSBmYWNlWzJdICsgaW5kZXhPZmZzZXQ7XG5cdFx0XHRcdGluZGljZXMucHVzaChhLCBiLCBjKTtcblx0XHRcdFx0Z3JvdXBDb3VudCArPSAzO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHR0b0pTT04oKSB7XG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTigpO1xuXHRcdGNvbnN0IHNoYXBlcyA9IHRoaXMucGFyYW1ldGVycy5zaGFwZXM7XG5cdFx0cmV0dXJuIHRvSlNPTihzaGFwZXMsIGRhdGEpO1xuXHR9XG5cdHN0YXRpYyBmcm9tSlNPTihkYXRhLCBzaGFwZXMpIHtcblx0XHRjb25zdCBnZW9tZXRyeVNoYXBlcyA9IFtdO1xuXHRcdGZvciAobGV0IGogPSAwLCBqbCA9IGRhdGEuc2hhcGVzLmxlbmd0aDsgaiA8IGpsOyBqKyspIHtcblx0XHRcdGNvbnN0IHNoYXBlID0gc2hhcGVzW2RhdGEuc2hhcGVzW2pdXTtcblx0XHRcdGdlb21ldHJ5U2hhcGVzLnB1c2goc2hhcGUpO1xuXHRcdH1cblx0XHRyZXR1cm4gbmV3IFNoYXBlR2VvbWV0cnkoZ2VvbWV0cnlTaGFwZXMsIGRhdGEuY3VydmVTZWdtZW50cyk7XG5cdH1cbn1cbmZ1bmN0aW9uIHRvSlNPTihzaGFwZXMsIGRhdGEpIHtcblx0ZGF0YS5zaGFwZXMgPSBbXTtcblx0aWYgKEFycmF5LmlzQXJyYXkoc2hhcGVzKSkge1xuXHRcdGZvciAobGV0IGkgPSAwLCBsID0gc2hhcGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0Y29uc3Qgc2hhcGUgPSBzaGFwZXNbaV07XG5cdFx0XHRkYXRhLnNoYXBlcy5wdXNoKHNoYXBlLnV1aWQpO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRkYXRhLnNoYXBlcy5wdXNoKHNoYXBlcy51dWlkKTtcblx0fVxuXHRyZXR1cm4gZGF0YTtcbn1cblxuY2xhc3MgU3BoZXJlR2VvbWV0cnkgZXh0ZW5kcyBCdWZmZXJHZW9tZXRyeSB7XG5cdGNvbnN0cnVjdG9yKHJhZGl1cyA9IDEsIHdpZHRoU2VnbWVudHMgPSAzMiwgaGVpZ2h0U2VnbWVudHMgPSAxNiwgcGhpU3RhcnQgPSAwLCBwaGlMZW5ndGggPSBNYXRoLlBJICogMiwgdGhldGFTdGFydCA9IDAsIHRoZXRhTGVuZ3RoID0gTWF0aC5QSSkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy50eXBlID0gJ1NwaGVyZUdlb21ldHJ5Jztcblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRcdHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXG5cdFx0XHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXG5cdFx0XHRwaGlTdGFydDogcGhpU3RhcnQsXG5cdFx0XHRwaGlMZW5ndGg6IHBoaUxlbmd0aCxcblx0XHRcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXG5cdFx0XHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcblx0XHR9O1xuXHRcdHdpZHRoU2VnbWVudHMgPSBNYXRoLm1heCgzLCBNYXRoLmZsb29yKHdpZHRoU2VnbWVudHMpKTtcblx0XHRoZWlnaHRTZWdtZW50cyA9IE1hdGgubWF4KDIsIE1hdGguZmxvb3IoaGVpZ2h0U2VnbWVudHMpKTtcblx0XHRjb25zdCB0aGV0YUVuZCA9IE1hdGgubWluKHRoZXRhU3RhcnQgKyB0aGV0YUxlbmd0aCwgTWF0aC5QSSk7XG5cdFx0bGV0IGluZGV4ID0gMDtcblx0XHRjb25zdCBncmlkID0gW107XG5cdFx0Y29uc3QgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcblx0XHRjb25zdCBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0Ly8gYnVmZmVyc1xuXG5cdFx0Y29uc3QgaW5kaWNlcyA9IFtdO1xuXHRcdGNvbnN0IHZlcnRpY2VzID0gW107XG5cdFx0Y29uc3Qgbm9ybWFscyA9IFtdO1xuXHRcdGNvbnN0IHV2cyA9IFtdO1xuXG5cdFx0Ly8gZ2VuZXJhdGUgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xuXG5cdFx0Zm9yIChsZXQgaXkgPSAwOyBpeSA8PSBoZWlnaHRTZWdtZW50czsgaXkrKykge1xuXHRcdFx0Y29uc3QgdmVydGljZXNSb3cgPSBbXTtcblx0XHRcdGNvbnN0IHYgPSBpeSAvIGhlaWdodFNlZ21lbnRzO1xuXG5cdFx0XHQvLyBzcGVjaWFsIGNhc2UgZm9yIHRoZSBwb2xlc1xuXG5cdFx0XHRsZXQgdU9mZnNldCA9IDA7XG5cdFx0XHRpZiAoaXkgPT0gMCAmJiB0aGV0YVN0YXJ0ID09IDApIHtcblx0XHRcdFx0dU9mZnNldCA9IDAuNSAvIHdpZHRoU2VnbWVudHM7XG5cdFx0XHR9IGVsc2UgaWYgKGl5ID09IGhlaWdodFNlZ21lbnRzICYmIHRoZXRhRW5kID09IE1hdGguUEkpIHtcblx0XHRcdFx0dU9mZnNldCA9IC0wLjUgLyB3aWR0aFNlZ21lbnRzO1xuXHRcdFx0fVxuXHRcdFx0Zm9yIChsZXQgaXggPSAwOyBpeCA8PSB3aWR0aFNlZ21lbnRzOyBpeCsrKSB7XG5cdFx0XHRcdGNvbnN0IHUgPSBpeCAvIHdpZHRoU2VnbWVudHM7XG5cblx0XHRcdFx0Ly8gdmVydGV4XG5cblx0XHRcdFx0dmVydGV4LnggPSAtcmFkaXVzICogTWF0aC5jb3MocGhpU3RhcnQgKyB1ICogcGhpTGVuZ3RoKSAqIE1hdGguc2luKHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGgpO1xuXHRcdFx0XHR2ZXJ0ZXgueSA9IHJhZGl1cyAqIE1hdGguY29zKHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGgpO1xuXHRcdFx0XHR2ZXJ0ZXgueiA9IHJhZGl1cyAqIE1hdGguc2luKHBoaVN0YXJ0ICsgdSAqIHBoaUxlbmd0aCkgKiBNYXRoLnNpbih0aGV0YVN0YXJ0ICsgdiAqIHRoZXRhTGVuZ3RoKTtcblx0XHRcdFx0dmVydGljZXMucHVzaCh2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56KTtcblxuXHRcdFx0XHQvLyBub3JtYWxcblxuXHRcdFx0XHRub3JtYWwuY29weSh2ZXJ0ZXgpLm5vcm1hbGl6ZSgpO1xuXHRcdFx0XHRub3JtYWxzLnB1c2gobm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueik7XG5cblx0XHRcdFx0Ly8gdXZcblxuXHRcdFx0XHR1dnMucHVzaCh1ICsgdU9mZnNldCwgMSAtIHYpO1xuXHRcdFx0XHR2ZXJ0aWNlc1Jvdy5wdXNoKGluZGV4KyspO1xuXHRcdFx0fVxuXHRcdFx0Z3JpZC5wdXNoKHZlcnRpY2VzUm93KTtcblx0XHR9XG5cblx0XHQvLyBpbmRpY2VzXG5cblx0XHRmb3IgKGxldCBpeSA9IDA7IGl5IDwgaGVpZ2h0U2VnbWVudHM7IGl5KyspIHtcblx0XHRcdGZvciAobGV0IGl4ID0gMDsgaXggPCB3aWR0aFNlZ21lbnRzOyBpeCsrKSB7XG5cdFx0XHRcdGNvbnN0IGEgPSBncmlkW2l5XVtpeCArIDFdO1xuXHRcdFx0XHRjb25zdCBiID0gZ3JpZFtpeV1baXhdO1xuXHRcdFx0XHRjb25zdCBjID0gZ3JpZFtpeSArIDFdW2l4XTtcblx0XHRcdFx0Y29uc3QgZCA9IGdyaWRbaXkgKyAxXVtpeCArIDFdO1xuXHRcdFx0XHRpZiAoaXkgIT09IDAgfHwgdGhldGFTdGFydCA+IDApIGluZGljZXMucHVzaChhLCBiLCBkKTtcblx0XHRcdFx0aWYgKGl5ICE9PSBoZWlnaHRTZWdtZW50cyAtIDEgfHwgdGhldGFFbmQgPCBNYXRoLlBJKSBpbmRpY2VzLnB1c2goYiwgYywgZCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gYnVpbGQgZ2VvbWV0cnlcblxuXHRcdHRoaXMuc2V0SW5kZXgoaW5kaWNlcyk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodmVydGljZXMsIDMpKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSgnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUobm9ybWFscywgMykpO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHV2cywgMikpO1xuXHR9XG5cdHN0YXRpYyBmcm9tSlNPTihkYXRhKSB7XG5cdFx0cmV0dXJuIG5ldyBTcGhlcmVHZW9tZXRyeShkYXRhLnJhZGl1cywgZGF0YS53aWR0aFNlZ21lbnRzLCBkYXRhLmhlaWdodFNlZ21lbnRzLCBkYXRhLnBoaVN0YXJ0LCBkYXRhLnBoaUxlbmd0aCwgZGF0YS50aGV0YVN0YXJ0LCBkYXRhLnRoZXRhTGVuZ3RoKTtcblx0fVxufVxuXG5jbGFzcyBUZXRyYWhlZHJvbkdlb21ldHJ5IGV4dGVuZHMgUG9seWhlZHJvbkdlb21ldHJ5IHtcblx0Y29uc3RydWN0b3IocmFkaXVzID0gMSwgZGV0YWlsID0gMCkge1xuXHRcdGNvbnN0IHZlcnRpY2VzID0gWzEsIDEsIDEsIC0xLCAtMSwgMSwgLTEsIDEsIC0xLCAxLCAtMSwgLTFdO1xuXHRcdGNvbnN0IGluZGljZXMgPSBbMiwgMSwgMCwgMCwgMywgMiwgMSwgMywgMCwgMiwgMywgMV07XG5cdFx0c3VwZXIodmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsKTtcblx0XHR0aGlzLnR5cGUgPSAnVGV0cmFoZWRyb25HZW9tZXRyeSc7XG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRkZXRhaWw6IGRldGFpbFxuXHRcdH07XG5cdH1cblx0c3RhdGljIGZyb21KU09OKGRhdGEpIHtcblx0XHRyZXR1cm4gbmV3IFRldHJhaGVkcm9uR2VvbWV0cnkoZGF0YS5yYWRpdXMsIGRhdGEuZGV0YWlsKTtcblx0fVxufVxuXG5jbGFzcyBUb3J1c0dlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXHRjb25zdHJ1Y3RvcihyYWRpdXMgPSAxLCB0dWJlID0gMC40LCByYWRpYWxTZWdtZW50cyA9IDgsIHR1YnVsYXJTZWdtZW50cyA9IDYsIGFyYyA9IE1hdGguUEkgKiAyKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLnR5cGUgPSAnVG9ydXNHZW9tZXRyeSc7XG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHR0dWJlOiB0dWJlLFxuXHRcdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuXHRcdFx0dHVidWxhclNlZ21lbnRzOiB0dWJ1bGFyU2VnbWVudHMsXG5cdFx0XHRhcmM6IGFyY1xuXHRcdH07XG5cdFx0cmFkaWFsU2VnbWVudHMgPSBNYXRoLmZsb29yKHJhZGlhbFNlZ21lbnRzKTtcblx0XHR0dWJ1bGFyU2VnbWVudHMgPSBNYXRoLmZsb29yKHR1YnVsYXJTZWdtZW50cyk7XG5cblx0XHQvLyBidWZmZXJzXG5cblx0XHRjb25zdCBpbmRpY2VzID0gW107XG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblx0XHRjb25zdCBub3JtYWxzID0gW107XG5cdFx0Y29uc3QgdXZzID0gW107XG5cblx0XHQvLyBoZWxwZXIgdmFyaWFibGVzXG5cblx0XHRjb25zdCBjZW50ZXIgPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3Qgbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdC8vIGdlbmVyYXRlIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcblxuXHRcdGZvciAobGV0IGogPSAwOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyBqKyspIHtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDw9IHR1YnVsYXJTZWdtZW50czsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IHUgPSBpIC8gdHVidWxhclNlZ21lbnRzICogYXJjO1xuXHRcdFx0XHRjb25zdCB2ID0gaiAvIHJhZGlhbFNlZ21lbnRzICogTWF0aC5QSSAqIDI7XG5cblx0XHRcdFx0Ly8gdmVydGV4XG5cblx0XHRcdFx0dmVydGV4LnggPSAocmFkaXVzICsgdHViZSAqIE1hdGguY29zKHYpKSAqIE1hdGguY29zKHUpO1xuXHRcdFx0XHR2ZXJ0ZXgueSA9IChyYWRpdXMgKyB0dWJlICogTWF0aC5jb3ModikpICogTWF0aC5zaW4odSk7XG5cdFx0XHRcdHZlcnRleC56ID0gdHViZSAqIE1hdGguc2luKHYpO1xuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnopO1xuXG5cdFx0XHRcdC8vIG5vcm1hbFxuXG5cdFx0XHRcdGNlbnRlci54ID0gcmFkaXVzICogTWF0aC5jb3ModSk7XG5cdFx0XHRcdGNlbnRlci55ID0gcmFkaXVzICogTWF0aC5zaW4odSk7XG5cdFx0XHRcdG5vcm1hbC5zdWJWZWN0b3JzKHZlcnRleCwgY2VudGVyKS5ub3JtYWxpemUoKTtcblx0XHRcdFx0bm9ybWFscy5wdXNoKG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnopO1xuXG5cdFx0XHRcdC8vIHV2XG5cblx0XHRcdFx0dXZzLnB1c2goaSAvIHR1YnVsYXJTZWdtZW50cyk7XG5cdFx0XHRcdHV2cy5wdXNoKGogLyByYWRpYWxTZWdtZW50cyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gZ2VuZXJhdGUgaW5kaWNlc1xuXG5cdFx0Zm9yIChsZXQgaiA9IDE7IGogPD0gcmFkaWFsU2VnbWVudHM7IGorKykge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDE7IGkgPD0gdHVidWxhclNlZ21lbnRzOyBpKyspIHtcblx0XHRcdFx0Ly8gaW5kaWNlc1xuXG5cdFx0XHRcdGNvbnN0IGEgPSAodHVidWxhclNlZ21lbnRzICsgMSkgKiBqICsgaSAtIDE7XG5cdFx0XHRcdGNvbnN0IGIgPSAodHVidWxhclNlZ21lbnRzICsgMSkgKiAoaiAtIDEpICsgaSAtIDE7XG5cdFx0XHRcdGNvbnN0IGMgPSAodHVidWxhclNlZ21lbnRzICsgMSkgKiAoaiAtIDEpICsgaTtcblx0XHRcdFx0Y29uc3QgZCA9ICh0dWJ1bGFyU2VnbWVudHMgKyAxKSAqIGogKyBpO1xuXG5cdFx0XHRcdC8vIGZhY2VzXG5cblx0XHRcdFx0aW5kaWNlcy5wdXNoKGEsIGIsIGQpO1xuXHRcdFx0XHRpbmRpY2VzLnB1c2goYiwgYywgZCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gYnVpbGQgZ2VvbWV0cnlcblxuXHRcdHRoaXMuc2V0SW5kZXgoaW5kaWNlcyk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodmVydGljZXMsIDMpKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSgnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUobm9ybWFscywgMykpO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHV2cywgMikpO1xuXHR9XG5cdHN0YXRpYyBmcm9tSlNPTihkYXRhKSB7XG5cdFx0cmV0dXJuIG5ldyBUb3J1c0dlb21ldHJ5KGRhdGEucmFkaXVzLCBkYXRhLnR1YmUsIGRhdGEucmFkaWFsU2VnbWVudHMsIGRhdGEudHVidWxhclNlZ21lbnRzLCBkYXRhLmFyYyk7XG5cdH1cbn1cblxuY2xhc3MgVG9ydXNLbm90R2VvbWV0cnkgZXh0ZW5kcyBCdWZmZXJHZW9tZXRyeSB7XG5cdGNvbnN0cnVjdG9yKHJhZGl1cyA9IDEsIHR1YmUgPSAwLjQsIHR1YnVsYXJTZWdtZW50cyA9IDY0LCByYWRpYWxTZWdtZW50cyA9IDgsIHAgPSAyLCBxID0gMykge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy50eXBlID0gJ1RvcnVzS25vdEdlb21ldHJ5Jztcblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRcdHR1YmU6IHR1YmUsXG5cdFx0XHR0dWJ1bGFyU2VnbWVudHM6IHR1YnVsYXJTZWdtZW50cyxcblx0XHRcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcblx0XHRcdHA6IHAsXG5cdFx0XHRxOiBxXG5cdFx0fTtcblx0XHR0dWJ1bGFyU2VnbWVudHMgPSBNYXRoLmZsb29yKHR1YnVsYXJTZWdtZW50cyk7XG5cdFx0cmFkaWFsU2VnbWVudHMgPSBNYXRoLmZsb29yKHJhZGlhbFNlZ21lbnRzKTtcblxuXHRcdC8vIGJ1ZmZlcnNcblxuXHRcdGNvbnN0IGluZGljZXMgPSBbXTtcblx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcblx0XHRjb25zdCB1dnMgPSBbXTtcblxuXHRcdC8vIGhlbHBlciB2YXJpYWJsZXNcblxuXHRcdGNvbnN0IHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3Qgbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcblx0XHRjb25zdCBQMSA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgUDIgPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IEIgPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IFQgPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IE4gPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0Ly8gZ2VuZXJhdGUgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPD0gdHVidWxhclNlZ21lbnRzOyArK2kpIHtcblx0XHRcdC8vIHRoZSByYWRpYW4gXCJ1XCIgaXMgdXNlZCB0byBjYWxjdWxhdGUgdGhlIHBvc2l0aW9uIG9uIHRoZSB0b3J1cyBjdXJ2ZSBvZiB0aGUgY3VycmVudCB0dWJ1bGFyIHNlZ21lbnRcblxuXHRcdFx0Y29uc3QgdSA9IGkgLyB0dWJ1bGFyU2VnbWVudHMgKiBwICogTWF0aC5QSSAqIDI7XG5cblx0XHRcdC8vIG5vdyB3ZSBjYWxjdWxhdGUgdHdvIHBvaW50cy4gUDEgaXMgb3VyIGN1cnJlbnQgcG9zaXRpb24gb24gdGhlIGN1cnZlLCBQMiBpcyBhIGxpdHRsZSBmYXJ0aGVyIGFoZWFkLlxuXHRcdFx0Ly8gdGhlc2UgcG9pbnRzIGFyZSB1c2VkIHRvIGNyZWF0ZSBhIHNwZWNpYWwgXCJjb29yZGluYXRlIHNwYWNlXCIsIHdoaWNoIGlzIG5lY2Vzc2FyeSB0byBjYWxjdWxhdGUgdGhlIGNvcnJlY3QgdmVydGV4IHBvc2l0aW9uc1xuXG5cdFx0XHRjYWxjdWxhdGVQb3NpdGlvbk9uQ3VydmUodSwgcCwgcSwgcmFkaXVzLCBQMSk7XG5cdFx0XHRjYWxjdWxhdGVQb3NpdGlvbk9uQ3VydmUodSArIDAuMDEsIHAsIHEsIHJhZGl1cywgUDIpO1xuXG5cdFx0XHQvLyBjYWxjdWxhdGUgb3J0aG9ub3JtYWwgYmFzaXNcblxuXHRcdFx0VC5zdWJWZWN0b3JzKFAyLCBQMSk7XG5cdFx0XHROLmFkZFZlY3RvcnMoUDIsIFAxKTtcblx0XHRcdEIuY3Jvc3NWZWN0b3JzKFQsIE4pO1xuXHRcdFx0Ti5jcm9zc1ZlY3RvcnMoQiwgVCk7XG5cblx0XHRcdC8vIG5vcm1hbGl6ZSBCLCBOLiBUIGNhbiBiZSBpZ25vcmVkLCB3ZSBkb24ndCB1c2UgaXRcblxuXHRcdFx0Qi5ub3JtYWxpemUoKTtcblx0XHRcdE4ubm9ybWFsaXplKCk7XG5cdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8PSByYWRpYWxTZWdtZW50czsgKytqKSB7XG5cdFx0XHRcdC8vIG5vdyBjYWxjdWxhdGUgdGhlIHZlcnRpY2VzLiB0aGV5IGFyZSBub3RoaW5nIG1vcmUgdGhhbiBhbiBleHRydXNpb24gb2YgdGhlIHRvcnVzIGN1cnZlLlxuXHRcdFx0XHQvLyBiZWNhdXNlIHdlIGV4dHJ1ZGUgYSBzaGFwZSBpbiB0aGUgeHktcGxhbmUsIHRoZXJlIGlzIG5vIG5lZWQgdG8gY2FsY3VsYXRlIGEgei12YWx1ZS5cblxuXHRcdFx0XHRjb25zdCB2ID0gaiAvIHJhZGlhbFNlZ21lbnRzICogTWF0aC5QSSAqIDI7XG5cdFx0XHRcdGNvbnN0IGN4ID0gLXR1YmUgKiBNYXRoLmNvcyh2KTtcblx0XHRcdFx0Y29uc3QgY3kgPSB0dWJlICogTWF0aC5zaW4odik7XG5cblx0XHRcdFx0Ly8gbm93IGNhbGN1bGF0ZSB0aGUgZmluYWwgdmVydGV4IHBvc2l0aW9uLlxuXHRcdFx0XHQvLyBmaXJzdCB3ZSBvcmllbnQgdGhlIGV4dHJ1c2lvbiB3aXRoIG91ciBiYXNpcyB2ZWN0b3JzLCB0aGVuIHdlIGFkZCBpdCB0byB0aGUgY3VycmVudCBwb3NpdGlvbiBvbiB0aGUgY3VydmVcblxuXHRcdFx0XHR2ZXJ0ZXgueCA9IFAxLnggKyAoY3ggKiBOLnggKyBjeSAqIEIueCk7XG5cdFx0XHRcdHZlcnRleC55ID0gUDEueSArIChjeCAqIE4ueSArIGN5ICogQi55KTtcblx0XHRcdFx0dmVydGV4LnogPSBQMS56ICsgKGN4ICogTi56ICsgY3kgKiBCLnopO1xuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnopO1xuXG5cdFx0XHRcdC8vIG5vcm1hbCAoUDEgaXMgYWx3YXlzIHRoZSBjZW50ZXIvb3JpZ2luIG9mIHRoZSBleHRydXNpb24sIHRodXMgd2UgY2FuIHVzZSBpdCB0byBjYWxjdWxhdGUgdGhlIG5vcm1hbClcblxuXHRcdFx0XHRub3JtYWwuc3ViVmVjdG9ycyh2ZXJ0ZXgsIFAxKS5ub3JtYWxpemUoKTtcblx0XHRcdFx0bm9ybWFscy5wdXNoKG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnopO1xuXG5cdFx0XHRcdC8vIHV2XG5cblx0XHRcdFx0dXZzLnB1c2goaSAvIHR1YnVsYXJTZWdtZW50cyk7XG5cdFx0XHRcdHV2cy5wdXNoKGogLyByYWRpYWxTZWdtZW50cyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gZ2VuZXJhdGUgaW5kaWNlc1xuXG5cdFx0Zm9yIChsZXQgaiA9IDE7IGogPD0gdHVidWxhclNlZ21lbnRzOyBqKyspIHtcblx0XHRcdGZvciAobGV0IGkgPSAxOyBpIDw9IHJhZGlhbFNlZ21lbnRzOyBpKyspIHtcblx0XHRcdFx0Ly8gaW5kaWNlc1xuXG5cdFx0XHRcdGNvbnN0IGEgPSAocmFkaWFsU2VnbWVudHMgKyAxKSAqIChqIC0gMSkgKyAoaSAtIDEpO1xuXHRcdFx0XHRjb25zdCBiID0gKHJhZGlhbFNlZ21lbnRzICsgMSkgKiBqICsgKGkgLSAxKTtcblx0XHRcdFx0Y29uc3QgYyA9IChyYWRpYWxTZWdtZW50cyArIDEpICogaiArIGk7XG5cdFx0XHRcdGNvbnN0IGQgPSAocmFkaWFsU2VnbWVudHMgKyAxKSAqIChqIC0gMSkgKyBpO1xuXG5cdFx0XHRcdC8vIGZhY2VzXG5cblx0XHRcdFx0aW5kaWNlcy5wdXNoKGEsIGIsIGQpO1xuXHRcdFx0XHRpbmRpY2VzLnB1c2goYiwgYywgZCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gYnVpbGQgZ2VvbWV0cnlcblxuXHRcdHRoaXMuc2V0SW5kZXgoaW5kaWNlcyk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodmVydGljZXMsIDMpKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSgnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUobm9ybWFscywgMykpO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHV2cywgMikpO1xuXG5cdFx0Ly8gdGhpcyBmdW5jdGlvbiBjYWxjdWxhdGVzIHRoZSBjdXJyZW50IHBvc2l0aW9uIG9uIHRoZSB0b3J1cyBjdXJ2ZVxuXG5cdFx0ZnVuY3Rpb24gY2FsY3VsYXRlUG9zaXRpb25PbkN1cnZlKHUsIHAsIHEsIHJhZGl1cywgcG9zaXRpb24pIHtcblx0XHRcdGNvbnN0IGN1ID0gTWF0aC5jb3ModSk7XG5cdFx0XHRjb25zdCBzdSA9IE1hdGguc2luKHUpO1xuXHRcdFx0Y29uc3QgcXVPdmVyUCA9IHEgLyBwICogdTtcblx0XHRcdGNvbnN0IGNzID0gTWF0aC5jb3MocXVPdmVyUCk7XG5cdFx0XHRwb3NpdGlvbi54ID0gcmFkaXVzICogKDIgKyBjcykgKiAwLjUgKiBjdTtcblx0XHRcdHBvc2l0aW9uLnkgPSByYWRpdXMgKiAoMiArIGNzKSAqIHN1ICogMC41O1xuXHRcdFx0cG9zaXRpb24ueiA9IHJhZGl1cyAqIE1hdGguc2luKHF1T3ZlclApICogMC41O1xuXHRcdH1cblx0fVxuXHRzdGF0aWMgZnJvbUpTT04oZGF0YSkge1xuXHRcdHJldHVybiBuZXcgVG9ydXNLbm90R2VvbWV0cnkoZGF0YS5yYWRpdXMsIGRhdGEudHViZSwgZGF0YS50dWJ1bGFyU2VnbWVudHMsIGRhdGEucmFkaWFsU2VnbWVudHMsIGRhdGEucCwgZGF0YS5xKTtcblx0fVxufVxuXG5jbGFzcyBUdWJlR2VvbWV0cnkgZXh0ZW5kcyBCdWZmZXJHZW9tZXRyeSB7XG5cdGNvbnN0cnVjdG9yKHBhdGggPSBuZXcgUXVhZHJhdGljQmV6aWVyQ3VydmUzKG5ldyBWZWN0b3IzKC0xLCAtMSwgMCksIG5ldyBWZWN0b3IzKC0xLCAxLCAwKSwgbmV3IFZlY3RvcjMoMSwgMSwgMCkpLCB0dWJ1bGFyU2VnbWVudHMgPSA2NCwgcmFkaXVzID0gMSwgcmFkaWFsU2VnbWVudHMgPSA4LCBjbG9zZWQgPSBmYWxzZSkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy50eXBlID0gJ1R1YmVHZW9tZXRyeSc7XG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0cGF0aDogcGF0aCxcblx0XHRcdHR1YnVsYXJTZWdtZW50czogdHVidWxhclNlZ21lbnRzLFxuXHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRyYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXG5cdFx0XHRjbG9zZWQ6IGNsb3NlZFxuXHRcdH07XG5cdFx0Y29uc3QgZnJhbWVzID0gcGF0aC5jb21wdXRlRnJlbmV0RnJhbWVzKHR1YnVsYXJTZWdtZW50cywgY2xvc2VkKTtcblxuXHRcdC8vIGV4cG9zZSBpbnRlcm5hbHNcblxuXHRcdHRoaXMudGFuZ2VudHMgPSBmcmFtZXMudGFuZ2VudHM7XG5cdFx0dGhpcy5ub3JtYWxzID0gZnJhbWVzLm5vcm1hbHM7XG5cdFx0dGhpcy5iaW5vcm1hbHMgPSBmcmFtZXMuYmlub3JtYWxzO1xuXG5cdFx0Ly8gaGVscGVyIHZhcmlhYmxlc1xuXG5cdFx0Y29uc3QgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcblx0XHRjb25zdCBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IHV2ID0gbmV3IFZlY3RvcjIoKTtcblx0XHRsZXQgUCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHQvLyBidWZmZXJcblxuXHRcdGNvbnN0IHZlcnRpY2VzID0gW107XG5cdFx0Y29uc3Qgbm9ybWFscyA9IFtdO1xuXHRcdGNvbnN0IHV2cyA9IFtdO1xuXHRcdGNvbnN0IGluZGljZXMgPSBbXTtcblxuXHRcdC8vIGNyZWF0ZSBidWZmZXIgZGF0YVxuXG5cdFx0Z2VuZXJhdGVCdWZmZXJEYXRhKCk7XG5cblx0XHQvLyBidWlsZCBnZW9tZXRyeVxuXG5cdFx0dGhpcy5zZXRJbmRleChpbmRpY2VzKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh2ZXJ0aWNlcywgMykpO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShub3JtYWxzLCAzKSk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodXZzLCAyKSk7XG5cblx0XHQvLyBmdW5jdGlvbnNcblxuXHRcdGZ1bmN0aW9uIGdlbmVyYXRlQnVmZmVyRGF0YSgpIHtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdHVidWxhclNlZ21lbnRzOyBpKyspIHtcblx0XHRcdFx0Z2VuZXJhdGVTZWdtZW50KGkpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBpZiB0aGUgZ2VvbWV0cnkgaXMgbm90IGNsb3NlZCwgZ2VuZXJhdGUgdGhlIGxhc3Qgcm93IG9mIHZlcnRpY2VzIGFuZCBub3JtYWxzXG5cdFx0XHQvLyBhdCB0aGUgcmVndWxhciBwb3NpdGlvbiBvbiB0aGUgZ2l2ZW4gcGF0aFxuXHRcdFx0Ly9cblx0XHRcdC8vIGlmIHRoZSBnZW9tZXRyeSBpcyBjbG9zZWQsIGR1cGxpY2F0ZSB0aGUgZmlyc3Qgcm93IG9mIHZlcnRpY2VzIGFuZCBub3JtYWxzICh1dnMgd2lsbCBkaWZmZXIpXG5cblx0XHRcdGdlbmVyYXRlU2VnbWVudChjbG9zZWQgPT09IGZhbHNlID8gdHVidWxhclNlZ21lbnRzIDogMCk7XG5cblx0XHRcdC8vIHV2cyBhcmUgZ2VuZXJhdGVkIGluIGEgc2VwYXJhdGUgZnVuY3Rpb24uXG5cdFx0XHQvLyB0aGlzIG1ha2VzIGl0IGVhc3kgY29tcHV0ZSBjb3JyZWN0IHZhbHVlcyBmb3IgY2xvc2VkIGdlb21ldHJpZXNcblxuXHRcdFx0Z2VuZXJhdGVVVnMoKTtcblxuXHRcdFx0Ly8gZmluYWxseSBjcmVhdGUgZmFjZXNcblxuXHRcdFx0Z2VuZXJhdGVJbmRpY2VzKCk7XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIGdlbmVyYXRlU2VnbWVudChpKSB7XG5cdFx0XHQvLyB3ZSB1c2UgZ2V0UG9pbnRBdCB0byBzYW1wbGUgZXZlbmx5IGRpc3RyaWJ1dGVkIHBvaW50cyBmcm9tIHRoZSBnaXZlbiBwYXRoXG5cblx0XHRcdFAgPSBwYXRoLmdldFBvaW50QXQoaSAvIHR1YnVsYXJTZWdtZW50cywgUCk7XG5cblx0XHRcdC8vIHJldHJpZXZlIGNvcnJlc3BvbmRpbmcgbm9ybWFsIGFuZCBiaW5vcm1hbFxuXG5cdFx0XHRjb25zdCBOID0gZnJhbWVzLm5vcm1hbHNbaV07XG5cdFx0XHRjb25zdCBCID0gZnJhbWVzLmJpbm9ybWFsc1tpXTtcblxuXHRcdFx0Ly8gZ2VuZXJhdGUgbm9ybWFscyBhbmQgdmVydGljZXMgZm9yIHRoZSBjdXJyZW50IHNlZ21lbnRcblxuXHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPD0gcmFkaWFsU2VnbWVudHM7IGorKykge1xuXHRcdFx0XHRjb25zdCB2ID0gaiAvIHJhZGlhbFNlZ21lbnRzICogTWF0aC5QSSAqIDI7XG5cdFx0XHRcdGNvbnN0IHNpbiA9IE1hdGguc2luKHYpO1xuXHRcdFx0XHRjb25zdCBjb3MgPSAtTWF0aC5jb3Modik7XG5cblx0XHRcdFx0Ly8gbm9ybWFsXG5cblx0XHRcdFx0bm9ybWFsLnggPSBjb3MgKiBOLnggKyBzaW4gKiBCLng7XG5cdFx0XHRcdG5vcm1hbC55ID0gY29zICogTi55ICsgc2luICogQi55O1xuXHRcdFx0XHRub3JtYWwueiA9IGNvcyAqIE4ueiArIHNpbiAqIEIuejtcblx0XHRcdFx0bm9ybWFsLm5vcm1hbGl6ZSgpO1xuXHRcdFx0XHRub3JtYWxzLnB1c2gobm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueik7XG5cblx0XHRcdFx0Ly8gdmVydGV4XG5cblx0XHRcdFx0dmVydGV4LnggPSBQLnggKyByYWRpdXMgKiBub3JtYWwueDtcblx0XHRcdFx0dmVydGV4LnkgPSBQLnkgKyByYWRpdXMgKiBub3JtYWwueTtcblx0XHRcdFx0dmVydGV4LnogPSBQLnogKyByYWRpdXMgKiBub3JtYWwuejtcblx0XHRcdFx0dmVydGljZXMucHVzaCh2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZnVuY3Rpb24gZ2VuZXJhdGVJbmRpY2VzKCkge1xuXHRcdFx0Zm9yIChsZXQgaiA9IDE7IGogPD0gdHVidWxhclNlZ21lbnRzOyBqKyspIHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDE7IGkgPD0gcmFkaWFsU2VnbWVudHM7IGkrKykge1xuXHRcdFx0XHRcdGNvbnN0IGEgPSAocmFkaWFsU2VnbWVudHMgKyAxKSAqIChqIC0gMSkgKyAoaSAtIDEpO1xuXHRcdFx0XHRcdGNvbnN0IGIgPSAocmFkaWFsU2VnbWVudHMgKyAxKSAqIGogKyAoaSAtIDEpO1xuXHRcdFx0XHRcdGNvbnN0IGMgPSAocmFkaWFsU2VnbWVudHMgKyAxKSAqIGogKyBpO1xuXHRcdFx0XHRcdGNvbnN0IGQgPSAocmFkaWFsU2VnbWVudHMgKyAxKSAqIChqIC0gMSkgKyBpO1xuXG5cdFx0XHRcdFx0Ly8gZmFjZXNcblxuXHRcdFx0XHRcdGluZGljZXMucHVzaChhLCBiLCBkKTtcblx0XHRcdFx0XHRpbmRpY2VzLnB1c2goYiwgYywgZCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZnVuY3Rpb24gZ2VuZXJhdGVVVnMoKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8PSB0dWJ1bGFyU2VnbWVudHM7IGkrKykge1xuXHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8PSByYWRpYWxTZWdtZW50czsgaisrKSB7XG5cdFx0XHRcdFx0dXYueCA9IGkgLyB0dWJ1bGFyU2VnbWVudHM7XG5cdFx0XHRcdFx0dXYueSA9IGogLyByYWRpYWxTZWdtZW50cztcblx0XHRcdFx0XHR1dnMucHVzaCh1di54LCB1di55KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHR0b0pTT04oKSB7XG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTigpO1xuXHRcdGRhdGEucGF0aCA9IHRoaXMucGFyYW1ldGVycy5wYXRoLnRvSlNPTigpO1xuXHRcdHJldHVybiBkYXRhO1xuXHR9XG5cdHN0YXRpYyBmcm9tSlNPTihkYXRhKSB7XG5cdFx0Ly8gVGhpcyBvbmx5IHdvcmtzIGZvciBidWlsdC1pbiBjdXJ2ZXMgKGUuZy4gQ2F0bXVsbFJvbUN1cnZlMykuXG5cdFx0Ly8gVXNlciBkZWZpbmVkIGN1cnZlcyBvciBpbnN0YW5jZXMgb2YgQ3VydmVQYXRoIHdpbGwgbm90IGJlIGRlc2VyaWFsaXplZC5cblx0XHRyZXR1cm4gbmV3IFR1YmVHZW9tZXRyeShuZXcgQ3VydmVzW2RhdGEucGF0aC50eXBlXSgpLmZyb21KU09OKGRhdGEucGF0aCksIGRhdGEudHVidWxhclNlZ21lbnRzLCBkYXRhLnJhZGl1cywgZGF0YS5yYWRpYWxTZWdtZW50cywgZGF0YS5jbG9zZWQpO1xuXHR9XG59XG5cbmNsYXNzIFdpcmVmcmFtZUdlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXHRjb25zdHJ1Y3RvcihnZW9tZXRyeSA9IG51bGwpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMudHlwZSA9ICdXaXJlZnJhbWVHZW9tZXRyeSc7XG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0Z2VvbWV0cnk6IGdlb21ldHJ5XG5cdFx0fTtcblx0XHRpZiAoZ2VvbWV0cnkgIT09IG51bGwpIHtcblx0XHRcdC8vIGJ1ZmZlclxuXG5cdFx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXHRcdFx0Y29uc3QgZWRnZXMgPSBuZXcgU2V0KCk7XG5cblx0XHRcdC8vIGhlbHBlciB2YXJpYWJsZXNcblxuXHRcdFx0Y29uc3Qgc3RhcnQgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0Y29uc3QgZW5kID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdGlmIChnZW9tZXRyeS5pbmRleCAhPT0gbnVsbCkge1xuXHRcdFx0XHQvLyBpbmRleGVkIEJ1ZmZlckdlb21ldHJ5XG5cblx0XHRcdFx0Y29uc3QgcG9zaXRpb24gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdFx0XHRjb25zdCBpbmRpY2VzID0gZ2VvbWV0cnkuaW5kZXg7XG5cdFx0XHRcdGxldCBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XG5cdFx0XHRcdGlmIChncm91cHMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdFx0Z3JvdXBzID0gW3tcblx0XHRcdFx0XHRcdHN0YXJ0OiAwLFxuXHRcdFx0XHRcdFx0Y291bnQ6IGluZGljZXMuY291bnQsXG5cdFx0XHRcdFx0XHRtYXRlcmlhbEluZGV4OiAwXG5cdFx0XHRcdFx0fV07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBjcmVhdGUgYSBkYXRhIHN0cnVjdHVyZSB0aGF0IGNvbnRhaW5zIGFsbCBlZGdlcyB3aXRob3V0IGR1cGxpY2F0ZXNcblxuXHRcdFx0XHRmb3IgKGxldCBvID0gMCwgb2wgPSBncm91cHMubGVuZ3RoOyBvIDwgb2w7ICsrbykge1xuXHRcdFx0XHRcdGNvbnN0IGdyb3VwID0gZ3JvdXBzW29dO1xuXHRcdFx0XHRcdGNvbnN0IGdyb3VwU3RhcnQgPSBncm91cC5zdGFydDtcblx0XHRcdFx0XHRjb25zdCBncm91cENvdW50ID0gZ3JvdXAuY291bnQ7XG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IGdyb3VwU3RhcnQsIGwgPSBncm91cFN0YXJ0ICsgZ3JvdXBDb3VudDsgaSA8IGw7IGkgKz0gMykge1xuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCAzOyBqKyspIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgaW5kZXgxID0gaW5kaWNlcy5nZXRYKGkgKyBqKTtcblx0XHRcdFx0XHRcdFx0Y29uc3QgaW5kZXgyID0gaW5kaWNlcy5nZXRYKGkgKyAoaiArIDEpICUgMyk7XG5cdFx0XHRcdFx0XHRcdHN0YXJ0LmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb24sIGluZGV4MSk7XG5cdFx0XHRcdFx0XHRcdGVuZC5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uLCBpbmRleDIpO1xuXHRcdFx0XHRcdFx0XHRpZiAoaXNVbmlxdWVFZGdlKHN0YXJ0LCBlbmQsIGVkZ2VzKSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0XHRcdHZlcnRpY2VzLnB1c2goc3RhcnQueCwgc3RhcnQueSwgc3RhcnQueik7XG5cdFx0XHRcdFx0XHRcdFx0dmVydGljZXMucHVzaChlbmQueCwgZW5kLnksIGVuZC56KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gbm9uLWluZGV4ZWQgQnVmZmVyR2VvbWV0cnlcblxuXHRcdFx0XHRjb25zdCBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gcG9zaXRpb24uY291bnQgLyAzOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCAzOyBqKyspIHtcblx0XHRcdFx0XHRcdC8vIHRocmVlIGVkZ2VzIHBlciB0cmlhbmdsZSwgYW4gZWRnZSBpcyByZXByZXNlbnRlZCBhcyAoaW5kZXgxLCBpbmRleDIpXG5cdFx0XHRcdFx0XHQvLyBlLmcuIHRoZSBmaXJzdCB0cmlhbmdsZSBoYXMgdGhlIGZvbGxvd2luZyBlZGdlczogKDAsMSksKDEsMiksKDIsMClcblxuXHRcdFx0XHRcdFx0Y29uc3QgaW5kZXgxID0gMyAqIGkgKyBqO1xuXHRcdFx0XHRcdFx0Y29uc3QgaW5kZXgyID0gMyAqIGkgKyAoaiArIDEpICUgMztcblx0XHRcdFx0XHRcdHN0YXJ0LmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb24sIGluZGV4MSk7XG5cdFx0XHRcdFx0XHRlbmQuZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbiwgaW5kZXgyKTtcblx0XHRcdFx0XHRcdGlmIChpc1VuaXF1ZUVkZ2Uoc3RhcnQsIGVuZCwgZWRnZXMpID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRcdHZlcnRpY2VzLnB1c2goc3RhcnQueCwgc3RhcnQueSwgc3RhcnQueik7XG5cdFx0XHRcdFx0XHRcdHZlcnRpY2VzLnB1c2goZW5kLngsIGVuZC55LCBlbmQueik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGJ1aWxkIGdlb21ldHJ5XG5cblx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHZlcnRpY2VzLCAzKSk7XG5cdFx0fVxuXHR9XG59XG5mdW5jdGlvbiBpc1VuaXF1ZUVkZ2Uoc3RhcnQsIGVuZCwgZWRnZXMpIHtcblx0Y29uc3QgaGFzaDEgPSBgJHtzdGFydC54fSwke3N0YXJ0Lnl9LCR7c3RhcnQuen0tJHtlbmQueH0sJHtlbmQueX0sJHtlbmQuen1gO1xuXHRjb25zdCBoYXNoMiA9IGAke2VuZC54fSwke2VuZC55fSwke2VuZC56fS0ke3N0YXJ0Lnh9LCR7c3RhcnQueX0sJHtzdGFydC56fWA7IC8vIGNvaW5jaWRlbnQgZWRnZVxuXG5cdGlmIChlZGdlcy5oYXMoaGFzaDEpID09PSB0cnVlIHx8IGVkZ2VzLmhhcyhoYXNoMikgPT09IHRydWUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0gZWxzZSB7XG5cdFx0ZWRnZXMuYWRkKGhhc2gxKTtcblx0XHRlZGdlcy5hZGQoaGFzaDIpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59XG5cbnZhciBHZW9tZXRyaWVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdEJveEdlb21ldHJ5OiBCb3hHZW9tZXRyeSxcblx0Q2Fwc3VsZUdlb21ldHJ5OiBDYXBzdWxlR2VvbWV0cnksXG5cdENpcmNsZUdlb21ldHJ5OiBDaXJjbGVHZW9tZXRyeSxcblx0Q29uZUdlb21ldHJ5OiBDb25lR2VvbWV0cnksXG5cdEN5bGluZGVyR2VvbWV0cnk6IEN5bGluZGVyR2VvbWV0cnksXG5cdERvZGVjYWhlZHJvbkdlb21ldHJ5OiBEb2RlY2FoZWRyb25HZW9tZXRyeSxcblx0RWRnZXNHZW9tZXRyeTogRWRnZXNHZW9tZXRyeSxcblx0RXh0cnVkZUdlb21ldHJ5OiBFeHRydWRlR2VvbWV0cnksXG5cdEljb3NhaGVkcm9uR2VvbWV0cnk6IEljb3NhaGVkcm9uR2VvbWV0cnksXG5cdExhdGhlR2VvbWV0cnk6IExhdGhlR2VvbWV0cnksXG5cdE9jdGFoZWRyb25HZW9tZXRyeTogT2N0YWhlZHJvbkdlb21ldHJ5LFxuXHRQbGFuZUdlb21ldHJ5OiBQbGFuZUdlb21ldHJ5LFxuXHRQb2x5aGVkcm9uR2VvbWV0cnk6IFBvbHloZWRyb25HZW9tZXRyeSxcblx0UmluZ0dlb21ldHJ5OiBSaW5nR2VvbWV0cnksXG5cdFNoYXBlR2VvbWV0cnk6IFNoYXBlR2VvbWV0cnksXG5cdFNwaGVyZUdlb21ldHJ5OiBTcGhlcmVHZW9tZXRyeSxcblx0VGV0cmFoZWRyb25HZW9tZXRyeTogVGV0cmFoZWRyb25HZW9tZXRyeSxcblx0VG9ydXNHZW9tZXRyeTogVG9ydXNHZW9tZXRyeSxcblx0VG9ydXNLbm90R2VvbWV0cnk6IFRvcnVzS25vdEdlb21ldHJ5LFxuXHRUdWJlR2VvbWV0cnk6IFR1YmVHZW9tZXRyeSxcblx0V2lyZWZyYW1lR2VvbWV0cnk6IFdpcmVmcmFtZUdlb21ldHJ5XG59KTtcblxuY2xhc3MgU2hhZG93TWF0ZXJpYWwgZXh0ZW5kcyBNYXRlcmlhbCB7XG5cdGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuaXNTaGFkb3dNYXRlcmlhbCA9IHRydWU7XG5cdFx0dGhpcy50eXBlID0gJ1NoYWRvd01hdGVyaWFsJztcblx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKDB4MDAwMDAwKTtcblx0XHR0aGlzLnRyYW5zcGFyZW50ID0gdHJ1ZTtcblx0XHR0aGlzLmZvZyA9IHRydWU7XG5cdFx0dGhpcy5zZXRWYWx1ZXMocGFyYW1ldGVycyk7XG5cdH1cblx0Y29weShzb3VyY2UpIHtcblx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0dGhpcy5jb2xvci5jb3B5KHNvdXJjZS5jb2xvcik7XG5cdFx0dGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59XG5cbmNsYXNzIFJhd1NoYWRlck1hdGVyaWFsIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWwge1xuXHRjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG5cdFx0c3VwZXIocGFyYW1ldGVycyk7XG5cdFx0dGhpcy5pc1Jhd1NoYWRlck1hdGVyaWFsID0gdHJ1ZTtcblx0XHR0aGlzLnR5cGUgPSAnUmF3U2hhZGVyTWF0ZXJpYWwnO1xuXHR9XG59XG5cbmNsYXNzIE1lc2hTdGFuZGFyZE1hdGVyaWFsIGV4dGVuZHMgTWF0ZXJpYWwge1xuXHRjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgPSB0cnVlO1xuXHRcdHRoaXMuZGVmaW5lcyA9IHtcblx0XHRcdCdTVEFOREFSRCc6ICcnXG5cdFx0fTtcblx0XHR0aGlzLnR5cGUgPSAnTWVzaFN0YW5kYXJkTWF0ZXJpYWwnO1xuXHRcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoMHhmZmZmZmYpOyAvLyBkaWZmdXNlXG5cdFx0dGhpcy5yb3VnaG5lc3MgPSAxLjA7XG5cdFx0dGhpcy5tZXRhbG5lc3MgPSAwLjA7XG5cdFx0dGhpcy5tYXAgPSBudWxsO1xuXHRcdHRoaXMubGlnaHRNYXAgPSBudWxsO1xuXHRcdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSAxLjA7XG5cdFx0dGhpcy5hb01hcCA9IG51bGw7XG5cdFx0dGhpcy5hb01hcEludGVuc2l0eSA9IDEuMDtcblx0XHR0aGlzLmVtaXNzaXZlID0gbmV3IENvbG9yKDB4MDAwMDAwKTtcblx0XHR0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ID0gMS4wO1xuXHRcdHRoaXMuZW1pc3NpdmVNYXAgPSBudWxsO1xuXHRcdHRoaXMuYnVtcE1hcCA9IG51bGw7XG5cdFx0dGhpcy5idW1wU2NhbGUgPSAxO1xuXHRcdHRoaXMubm9ybWFsTWFwID0gbnVsbDtcblx0XHR0aGlzLm5vcm1hbE1hcFR5cGUgPSBUYW5nZW50U3BhY2VOb3JtYWxNYXA7XG5cdFx0dGhpcy5ub3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKDEsIDEpO1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gbnVsbDtcblx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcblx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSAwO1xuXHRcdHRoaXMucm91Z2huZXNzTWFwID0gbnVsbDtcblx0XHR0aGlzLm1ldGFsbmVzc01hcCA9IG51bGw7XG5cdFx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XG5cdFx0dGhpcy5lbnZNYXAgPSBudWxsO1xuXHRcdHRoaXMuZW52TWFwSW50ZW5zaXR5ID0gMS4wO1xuXHRcdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9ICdyb3VuZCc7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9ICdyb3VuZCc7XG5cdFx0dGhpcy5mbGF0U2hhZGluZyA9IGZhbHNlO1xuXHRcdHRoaXMuZm9nID0gdHJ1ZTtcblx0XHR0aGlzLnNldFZhbHVlcyhwYXJhbWV0ZXJzKTtcblx0fVxuXHRjb3B5KHNvdXJjZSkge1xuXHRcdHN1cGVyLmNvcHkoc291cmNlKTtcblx0XHR0aGlzLmRlZmluZXMgPSB7XG5cdFx0XHQnU1RBTkRBUkQnOiAnJ1xuXHRcdH07XG5cdFx0dGhpcy5jb2xvci5jb3B5KHNvdXJjZS5jb2xvcik7XG5cdFx0dGhpcy5yb3VnaG5lc3MgPSBzb3VyY2Uucm91Z2huZXNzO1xuXHRcdHRoaXMubWV0YWxuZXNzID0gc291cmNlLm1ldGFsbmVzcztcblx0XHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XG5cdFx0dGhpcy5saWdodE1hcCA9IHNvdXJjZS5saWdodE1hcDtcblx0XHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gc291cmNlLmxpZ2h0TWFwSW50ZW5zaXR5O1xuXHRcdHRoaXMuYW9NYXAgPSBzb3VyY2UuYW9NYXA7XG5cdFx0dGhpcy5hb01hcEludGVuc2l0eSA9IHNvdXJjZS5hb01hcEludGVuc2l0eTtcblx0XHR0aGlzLmVtaXNzaXZlLmNvcHkoc291cmNlLmVtaXNzaXZlKTtcblx0XHR0aGlzLmVtaXNzaXZlTWFwID0gc291cmNlLmVtaXNzaXZlTWFwO1xuXHRcdHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSBzb3VyY2UuZW1pc3NpdmVJbnRlbnNpdHk7XG5cdFx0dGhpcy5idW1wTWFwID0gc291cmNlLmJ1bXBNYXA7XG5cdFx0dGhpcy5idW1wU2NhbGUgPSBzb3VyY2UuYnVtcFNjYWxlO1xuXHRcdHRoaXMubm9ybWFsTWFwID0gc291cmNlLm5vcm1hbE1hcDtcblx0XHR0aGlzLm5vcm1hbE1hcFR5cGUgPSBzb3VyY2Uubm9ybWFsTWFwVHlwZTtcblx0XHR0aGlzLm5vcm1hbFNjYWxlLmNvcHkoc291cmNlLm5vcm1hbFNjYWxlKTtcblx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IHNvdXJjZS5kaXNwbGFjZW1lbnRNYXA7XG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IHNvdXJjZS5kaXNwbGFjZW1lbnRTY2FsZTtcblx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSBzb3VyY2UuZGlzcGxhY2VtZW50Qmlhcztcblx0XHR0aGlzLnJvdWdobmVzc01hcCA9IHNvdXJjZS5yb3VnaG5lc3NNYXA7XG5cdFx0dGhpcy5tZXRhbG5lc3NNYXAgPSBzb3VyY2UubWV0YWxuZXNzTWFwO1xuXHRcdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XG5cdFx0dGhpcy5lbnZNYXAgPSBzb3VyY2UuZW52TWFwO1xuXHRcdHRoaXMuZW52TWFwSW50ZW5zaXR5ID0gc291cmNlLmVudk1hcEludGVuc2l0eTtcblx0XHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IHNvdXJjZS53aXJlZnJhbWVMaW5lY2FwO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBzb3VyY2Uud2lyZWZyYW1lTGluZWpvaW47XG5cdFx0dGhpcy5mbGF0U2hhZGluZyA9IHNvdXJjZS5mbGF0U2hhZGluZztcblx0XHR0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn1cblxuY2xhc3MgTWVzaFBoeXNpY2FsTWF0ZXJpYWwgZXh0ZW5kcyBNZXNoU3RhbmRhcmRNYXRlcmlhbCB7XG5cdGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuaXNNZXNoUGh5c2ljYWxNYXRlcmlhbCA9IHRydWU7XG5cdFx0dGhpcy5kZWZpbmVzID0ge1xuXHRcdFx0J1NUQU5EQVJEJzogJycsXG5cdFx0XHQnUEhZU0lDQUwnOiAnJ1xuXHRcdH07XG5cdFx0dGhpcy50eXBlID0gJ01lc2hQaHlzaWNhbE1hdGVyaWFsJztcblx0XHR0aGlzLmNsZWFyY29hdE1hcCA9IG51bGw7XG5cdFx0dGhpcy5jbGVhcmNvYXRSb3VnaG5lc3MgPSAwLjA7XG5cdFx0dGhpcy5jbGVhcmNvYXRSb3VnaG5lc3NNYXAgPSBudWxsO1xuXHRcdHRoaXMuY2xlYXJjb2F0Tm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMigxLCAxKTtcblx0XHR0aGlzLmNsZWFyY29hdE5vcm1hbE1hcCA9IG51bGw7XG5cdFx0dGhpcy5pb3IgPSAxLjU7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdyZWZsZWN0aXZpdHknLCB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIGNsYW1wKDIuNSAqICh0aGlzLmlvciAtIDEpIC8gKHRoaXMuaW9yICsgMSksIDAsIDEpO1xuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24gKHJlZmxlY3Rpdml0eSkge1xuXHRcdFx0XHR0aGlzLmlvciA9ICgxICsgMC40ICogcmVmbGVjdGl2aXR5KSAvICgxIC0gMC40ICogcmVmbGVjdGl2aXR5KTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHR0aGlzLmlyaWRlc2NlbmNlTWFwID0gbnVsbDtcblx0XHR0aGlzLmlyaWRlc2NlbmNlSU9SID0gMS4zO1xuXHRcdHRoaXMuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZSA9IFsxMDAsIDQwMF07XG5cdFx0dGhpcy5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcCA9IG51bGw7XG5cdFx0dGhpcy5zaGVlbkNvbG9yID0gbmV3IENvbG9yKDB4MDAwMDAwKTtcblx0XHR0aGlzLnNoZWVuQ29sb3JNYXAgPSBudWxsO1xuXHRcdHRoaXMuc2hlZW5Sb3VnaG5lc3MgPSAxLjA7XG5cdFx0dGhpcy5zaGVlblJvdWdobmVzc01hcCA9IG51bGw7XG5cdFx0dGhpcy50cmFuc21pc3Npb25NYXAgPSBudWxsO1xuXHRcdHRoaXMudGhpY2tuZXNzID0gMDtcblx0XHR0aGlzLnRoaWNrbmVzc01hcCA9IG51bGw7XG5cdFx0dGhpcy5hdHRlbnVhdGlvbkRpc3RhbmNlID0gSW5maW5pdHk7XG5cdFx0dGhpcy5hdHRlbnVhdGlvbkNvbG9yID0gbmV3IENvbG9yKDEsIDEsIDEpO1xuXHRcdHRoaXMuc3BlY3VsYXJJbnRlbnNpdHkgPSAxLjA7XG5cdFx0dGhpcy5zcGVjdWxhckludGVuc2l0eU1hcCA9IG51bGw7XG5cdFx0dGhpcy5zcGVjdWxhckNvbG9yID0gbmV3IENvbG9yKDEsIDEsIDEpO1xuXHRcdHRoaXMuc3BlY3VsYXJDb2xvck1hcCA9IG51bGw7XG5cdFx0dGhpcy5fc2hlZW4gPSAwLjA7XG5cdFx0dGhpcy5fY2xlYXJjb2F0ID0gMDtcblx0XHR0aGlzLl9pcmlkZXNjZW5jZSA9IDA7XG5cdFx0dGhpcy5fdHJhbnNtaXNzaW9uID0gMDtcblx0XHR0aGlzLnNldFZhbHVlcyhwYXJhbWV0ZXJzKTtcblx0fVxuXHRnZXQgc2hlZW4oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NoZWVuO1xuXHR9XG5cdHNldCBzaGVlbih2YWx1ZSkge1xuXHRcdGlmICh0aGlzLl9zaGVlbiA+IDAgIT09IHZhbHVlID4gMCkge1xuXHRcdFx0dGhpcy52ZXJzaW9uKys7XG5cdFx0fVxuXHRcdHRoaXMuX3NoZWVuID0gdmFsdWU7XG5cdH1cblx0Z2V0IGNsZWFyY29hdCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2xlYXJjb2F0O1xuXHR9XG5cdHNldCBjbGVhcmNvYXQodmFsdWUpIHtcblx0XHRpZiAodGhpcy5fY2xlYXJjb2F0ID4gMCAhPT0gdmFsdWUgPiAwKSB7XG5cdFx0XHR0aGlzLnZlcnNpb24rKztcblx0XHR9XG5cdFx0dGhpcy5fY2xlYXJjb2F0ID0gdmFsdWU7XG5cdH1cblx0Z2V0IGlyaWRlc2NlbmNlKCkge1xuXHRcdHJldHVybiB0aGlzLl9pcmlkZXNjZW5jZTtcblx0fVxuXHRzZXQgaXJpZGVzY2VuY2UodmFsdWUpIHtcblx0XHRpZiAodGhpcy5faXJpZGVzY2VuY2UgPiAwICE9PSB2YWx1ZSA+IDApIHtcblx0XHRcdHRoaXMudmVyc2lvbisrO1xuXHRcdH1cblx0XHR0aGlzLl9pcmlkZXNjZW5jZSA9IHZhbHVlO1xuXHR9XG5cdGdldCB0cmFuc21pc3Npb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3RyYW5zbWlzc2lvbjtcblx0fVxuXHRzZXQgdHJhbnNtaXNzaW9uKHZhbHVlKSB7XG5cdFx0aWYgKHRoaXMuX3RyYW5zbWlzc2lvbiA+IDAgIT09IHZhbHVlID4gMCkge1xuXHRcdFx0dGhpcy52ZXJzaW9uKys7XG5cdFx0fVxuXHRcdHRoaXMuX3RyYW5zbWlzc2lvbiA9IHZhbHVlO1xuXHR9XG5cdGNvcHkoc291cmNlKSB7XG5cdFx0c3VwZXIuY29weShzb3VyY2UpO1xuXHRcdHRoaXMuZGVmaW5lcyA9IHtcblx0XHRcdCdTVEFOREFSRCc6ICcnLFxuXHRcdFx0J1BIWVNJQ0FMJzogJydcblx0XHR9O1xuXHRcdHRoaXMuY2xlYXJjb2F0ID0gc291cmNlLmNsZWFyY29hdDtcblx0XHR0aGlzLmNsZWFyY29hdE1hcCA9IHNvdXJjZS5jbGVhcmNvYXRNYXA7XG5cdFx0dGhpcy5jbGVhcmNvYXRSb3VnaG5lc3MgPSBzb3VyY2UuY2xlYXJjb2F0Um91Z2huZXNzO1xuXHRcdHRoaXMuY2xlYXJjb2F0Um91Z2huZXNzTWFwID0gc291cmNlLmNsZWFyY29hdFJvdWdobmVzc01hcDtcblx0XHR0aGlzLmNsZWFyY29hdE5vcm1hbE1hcCA9IHNvdXJjZS5jbGVhcmNvYXROb3JtYWxNYXA7XG5cdFx0dGhpcy5jbGVhcmNvYXROb3JtYWxTY2FsZS5jb3B5KHNvdXJjZS5jbGVhcmNvYXROb3JtYWxTY2FsZSk7XG5cdFx0dGhpcy5pb3IgPSBzb3VyY2UuaW9yO1xuXHRcdHRoaXMuaXJpZGVzY2VuY2UgPSBzb3VyY2UuaXJpZGVzY2VuY2U7XG5cdFx0dGhpcy5pcmlkZXNjZW5jZU1hcCA9IHNvdXJjZS5pcmlkZXNjZW5jZU1hcDtcblx0XHR0aGlzLmlyaWRlc2NlbmNlSU9SID0gc291cmNlLmlyaWRlc2NlbmNlSU9SO1xuXHRcdHRoaXMuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZSA9IFsuLi5zb3VyY2UuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZV07XG5cdFx0dGhpcy5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcCA9IHNvdXJjZS5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcDtcblx0XHR0aGlzLnNoZWVuID0gc291cmNlLnNoZWVuO1xuXHRcdHRoaXMuc2hlZW5Db2xvci5jb3B5KHNvdXJjZS5zaGVlbkNvbG9yKTtcblx0XHR0aGlzLnNoZWVuQ29sb3JNYXAgPSBzb3VyY2Uuc2hlZW5Db2xvck1hcDtcblx0XHR0aGlzLnNoZWVuUm91Z2huZXNzID0gc291cmNlLnNoZWVuUm91Z2huZXNzO1xuXHRcdHRoaXMuc2hlZW5Sb3VnaG5lc3NNYXAgPSBzb3VyY2Uuc2hlZW5Sb3VnaG5lc3NNYXA7XG5cdFx0dGhpcy50cmFuc21pc3Npb24gPSBzb3VyY2UudHJhbnNtaXNzaW9uO1xuXHRcdHRoaXMudHJhbnNtaXNzaW9uTWFwID0gc291cmNlLnRyYW5zbWlzc2lvbk1hcDtcblx0XHR0aGlzLnRoaWNrbmVzcyA9IHNvdXJjZS50aGlja25lc3M7XG5cdFx0dGhpcy50aGlja25lc3NNYXAgPSBzb3VyY2UudGhpY2tuZXNzTWFwO1xuXHRcdHRoaXMuYXR0ZW51YXRpb25EaXN0YW5jZSA9IHNvdXJjZS5hdHRlbnVhdGlvbkRpc3RhbmNlO1xuXHRcdHRoaXMuYXR0ZW51YXRpb25Db2xvci5jb3B5KHNvdXJjZS5hdHRlbnVhdGlvbkNvbG9yKTtcblx0XHR0aGlzLnNwZWN1bGFySW50ZW5zaXR5ID0gc291cmNlLnNwZWN1bGFySW50ZW5zaXR5O1xuXHRcdHRoaXMuc3BlY3VsYXJJbnRlbnNpdHlNYXAgPSBzb3VyY2Uuc3BlY3VsYXJJbnRlbnNpdHlNYXA7XG5cdFx0dGhpcy5zcGVjdWxhckNvbG9yLmNvcHkoc291cmNlLnNwZWN1bGFyQ29sb3IpO1xuXHRcdHRoaXMuc3BlY3VsYXJDb2xvck1hcCA9IHNvdXJjZS5zcGVjdWxhckNvbG9yTWFwO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59XG5cbmNsYXNzIE1lc2hQaG9uZ01hdGVyaWFsIGV4dGVuZHMgTWF0ZXJpYWwge1xuXHRjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLmlzTWVzaFBob25nTWF0ZXJpYWwgPSB0cnVlO1xuXHRcdHRoaXMudHlwZSA9ICdNZXNoUGhvbmdNYXRlcmlhbCc7XG5cdFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvcigweGZmZmZmZik7IC8vIGRpZmZ1c2Vcblx0XHR0aGlzLnNwZWN1bGFyID0gbmV3IENvbG9yKDB4MTExMTExKTtcblx0XHR0aGlzLnNoaW5pbmVzcyA9IDMwO1xuXHRcdHRoaXMubWFwID0gbnVsbDtcblx0XHR0aGlzLmxpZ2h0TWFwID0gbnVsbDtcblx0XHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gMS4wO1xuXHRcdHRoaXMuYW9NYXAgPSBudWxsO1xuXHRcdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSAxLjA7XG5cdFx0dGhpcy5lbWlzc2l2ZSA9IG5ldyBDb2xvcigweDAwMDAwMCk7XG5cdFx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IDEuMDtcblx0XHR0aGlzLmVtaXNzaXZlTWFwID0gbnVsbDtcblx0XHR0aGlzLmJ1bXBNYXAgPSBudWxsO1xuXHRcdHRoaXMuYnVtcFNjYWxlID0gMTtcblx0XHR0aGlzLm5vcm1hbE1hcCA9IG51bGw7XG5cdFx0dGhpcy5ub3JtYWxNYXBUeXBlID0gVGFuZ2VudFNwYWNlTm9ybWFsTWFwO1xuXHRcdHRoaXMubm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMigxLCAxKTtcblx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IG51bGw7XG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IDE7XG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gMDtcblx0XHR0aGlzLnNwZWN1bGFyTWFwID0gbnVsbDtcblx0XHR0aGlzLmFscGhhTWFwID0gbnVsbDtcblx0XHR0aGlzLmVudk1hcCA9IG51bGw7XG5cdFx0dGhpcy5jb21iaW5lID0gTXVsdGlwbHlPcGVyYXRpb247XG5cdFx0dGhpcy5yZWZsZWN0aXZpdHkgPSAxO1xuXHRcdHRoaXMucmVmcmFjdGlvblJhdGlvID0gMC45ODtcblx0XHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xuXHRcdHRoaXMuZmxhdFNoYWRpbmcgPSBmYWxzZTtcblx0XHR0aGlzLmZvZyA9IHRydWU7XG5cdFx0dGhpcy5zZXRWYWx1ZXMocGFyYW1ldGVycyk7XG5cdH1cblx0Y29weShzb3VyY2UpIHtcblx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0dGhpcy5jb2xvci5jb3B5KHNvdXJjZS5jb2xvcik7XG5cdFx0dGhpcy5zcGVjdWxhci5jb3B5KHNvdXJjZS5zcGVjdWxhcik7XG5cdFx0dGhpcy5zaGluaW5lc3MgPSBzb3VyY2Uuc2hpbmluZXNzO1xuXHRcdHRoaXMubWFwID0gc291cmNlLm1hcDtcblx0XHR0aGlzLmxpZ2h0TWFwID0gc291cmNlLmxpZ2h0TWFwO1xuXHRcdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSBzb3VyY2UubGlnaHRNYXBJbnRlbnNpdHk7XG5cdFx0dGhpcy5hb01hcCA9IHNvdXJjZS5hb01hcDtcblx0XHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gc291cmNlLmFvTWFwSW50ZW5zaXR5O1xuXHRcdHRoaXMuZW1pc3NpdmUuY29weShzb3VyY2UuZW1pc3NpdmUpO1xuXHRcdHRoaXMuZW1pc3NpdmVNYXAgPSBzb3VyY2UuZW1pc3NpdmVNYXA7XG5cdFx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IHNvdXJjZS5lbWlzc2l2ZUludGVuc2l0eTtcblx0XHR0aGlzLmJ1bXBNYXAgPSBzb3VyY2UuYnVtcE1hcDtcblx0XHR0aGlzLmJ1bXBTY2FsZSA9IHNvdXJjZS5idW1wU2NhbGU7XG5cdFx0dGhpcy5ub3JtYWxNYXAgPSBzb3VyY2Uubm9ybWFsTWFwO1xuXHRcdHRoaXMubm9ybWFsTWFwVHlwZSA9IHNvdXJjZS5ub3JtYWxNYXBUeXBlO1xuXHRcdHRoaXMubm9ybWFsU2NhbGUuY29weShzb3VyY2Uubm9ybWFsU2NhbGUpO1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gc291cmNlLmRpc3BsYWNlbWVudE1hcDtcblx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gc291cmNlLmRpc3BsYWNlbWVudFNjYWxlO1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IHNvdXJjZS5kaXNwbGFjZW1lbnRCaWFzO1xuXHRcdHRoaXMuc3BlY3VsYXJNYXAgPSBzb3VyY2Uuc3BlY3VsYXJNYXA7XG5cdFx0dGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcblx0XHR0aGlzLmVudk1hcCA9IHNvdXJjZS5lbnZNYXA7XG5cdFx0dGhpcy5jb21iaW5lID0gc291cmNlLmNvbWJpbmU7XG5cdFx0dGhpcy5yZWZsZWN0aXZpdHkgPSBzb3VyY2UucmVmbGVjdGl2aXR5O1xuXHRcdHRoaXMucmVmcmFjdGlvblJhdGlvID0gc291cmNlLnJlZnJhY3Rpb25SYXRpbztcblx0XHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IHNvdXJjZS53aXJlZnJhbWVMaW5lY2FwO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBzb3VyY2Uud2lyZWZyYW1lTGluZWpvaW47XG5cdFx0dGhpcy5mbGF0U2hhZGluZyA9IHNvdXJjZS5mbGF0U2hhZGluZztcblx0XHR0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn1cblxuY2xhc3MgTWVzaFRvb25NYXRlcmlhbCBleHRlbmRzIE1hdGVyaWFsIHtcblx0Y29uc3RydWN0b3IocGFyYW1ldGVycykge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5pc01lc2hUb29uTWF0ZXJpYWwgPSB0cnVlO1xuXHRcdHRoaXMuZGVmaW5lcyA9IHtcblx0XHRcdCdUT09OJzogJydcblx0XHR9O1xuXHRcdHRoaXMudHlwZSA9ICdNZXNoVG9vbk1hdGVyaWFsJztcblx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKDB4ZmZmZmZmKTtcblx0XHR0aGlzLm1hcCA9IG51bGw7XG5cdFx0dGhpcy5ncmFkaWVudE1hcCA9IG51bGw7XG5cdFx0dGhpcy5saWdodE1hcCA9IG51bGw7XG5cdFx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IDEuMDtcblx0XHR0aGlzLmFvTWFwID0gbnVsbDtcblx0XHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gMS4wO1xuXHRcdHRoaXMuZW1pc3NpdmUgPSBuZXcgQ29sb3IoMHgwMDAwMDApO1xuXHRcdHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSAxLjA7XG5cdFx0dGhpcy5lbWlzc2l2ZU1hcCA9IG51bGw7XG5cdFx0dGhpcy5idW1wTWFwID0gbnVsbDtcblx0XHR0aGlzLmJ1bXBTY2FsZSA9IDE7XG5cdFx0dGhpcy5ub3JtYWxNYXAgPSBudWxsO1xuXHRcdHRoaXMubm9ybWFsTWFwVHlwZSA9IFRhbmdlbnRTcGFjZU5vcm1hbE1hcDtcblx0XHR0aGlzLm5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoMSwgMSk7XG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBudWxsO1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSAxO1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IDA7XG5cdFx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XG5cdFx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gJ3JvdW5kJztcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gJ3JvdW5kJztcblx0XHR0aGlzLmZvZyA9IHRydWU7XG5cdFx0dGhpcy5zZXRWYWx1ZXMocGFyYW1ldGVycyk7XG5cdH1cblx0Y29weShzb3VyY2UpIHtcblx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0dGhpcy5jb2xvci5jb3B5KHNvdXJjZS5jb2xvcik7XG5cdFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXHRcdHRoaXMuZ3JhZGllbnRNYXAgPSBzb3VyY2UuZ3JhZGllbnRNYXA7XG5cdFx0dGhpcy5saWdodE1hcCA9IHNvdXJjZS5saWdodE1hcDtcblx0XHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gc291cmNlLmxpZ2h0TWFwSW50ZW5zaXR5O1xuXHRcdHRoaXMuYW9NYXAgPSBzb3VyY2UuYW9NYXA7XG5cdFx0dGhpcy5hb01hcEludGVuc2l0eSA9IHNvdXJjZS5hb01hcEludGVuc2l0eTtcblx0XHR0aGlzLmVtaXNzaXZlLmNvcHkoc291cmNlLmVtaXNzaXZlKTtcblx0XHR0aGlzLmVtaXNzaXZlTWFwID0gc291cmNlLmVtaXNzaXZlTWFwO1xuXHRcdHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSBzb3VyY2UuZW1pc3NpdmVJbnRlbnNpdHk7XG5cdFx0dGhpcy5idW1wTWFwID0gc291cmNlLmJ1bXBNYXA7XG5cdFx0dGhpcy5idW1wU2NhbGUgPSBzb3VyY2UuYnVtcFNjYWxlO1xuXHRcdHRoaXMubm9ybWFsTWFwID0gc291cmNlLm5vcm1hbE1hcDtcblx0XHR0aGlzLm5vcm1hbE1hcFR5cGUgPSBzb3VyY2Uubm9ybWFsTWFwVHlwZTtcblx0XHR0aGlzLm5vcm1hbFNjYWxlLmNvcHkoc291cmNlLm5vcm1hbFNjYWxlKTtcblx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IHNvdXJjZS5kaXNwbGFjZW1lbnRNYXA7XG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IHNvdXJjZS5kaXNwbGFjZW1lbnRTY2FsZTtcblx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSBzb3VyY2UuZGlzcGxhY2VtZW50Qmlhcztcblx0XHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xuXHRcdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gc291cmNlLndpcmVmcmFtZUxpbmVjYXA7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9IHNvdXJjZS53aXJlZnJhbWVMaW5lam9pbjtcblx0XHR0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn1cblxuY2xhc3MgTWVzaE5vcm1hbE1hdGVyaWFsIGV4dGVuZHMgTWF0ZXJpYWwge1xuXHRjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLmlzTWVzaE5vcm1hbE1hdGVyaWFsID0gdHJ1ZTtcblx0XHR0aGlzLnR5cGUgPSAnTWVzaE5vcm1hbE1hdGVyaWFsJztcblx0XHR0aGlzLmJ1bXBNYXAgPSBudWxsO1xuXHRcdHRoaXMuYnVtcFNjYWxlID0gMTtcblx0XHR0aGlzLm5vcm1hbE1hcCA9IG51bGw7XG5cdFx0dGhpcy5ub3JtYWxNYXBUeXBlID0gVGFuZ2VudFNwYWNlTm9ybWFsTWFwO1xuXHRcdHRoaXMubm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMigxLCAxKTtcblx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IG51bGw7XG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IDE7XG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gMDtcblx0XHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcblx0XHR0aGlzLmZsYXRTaGFkaW5nID0gZmFsc2U7XG5cdFx0dGhpcy5zZXRWYWx1ZXMocGFyYW1ldGVycyk7XG5cdH1cblx0Y29weShzb3VyY2UpIHtcblx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0dGhpcy5idW1wTWFwID0gc291cmNlLmJ1bXBNYXA7XG5cdFx0dGhpcy5idW1wU2NhbGUgPSBzb3VyY2UuYnVtcFNjYWxlO1xuXHRcdHRoaXMubm9ybWFsTWFwID0gc291cmNlLm5vcm1hbE1hcDtcblx0XHR0aGlzLm5vcm1hbE1hcFR5cGUgPSBzb3VyY2Uubm9ybWFsTWFwVHlwZTtcblx0XHR0aGlzLm5vcm1hbFNjYWxlLmNvcHkoc291cmNlLm5vcm1hbFNjYWxlKTtcblx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IHNvdXJjZS5kaXNwbGFjZW1lbnRNYXA7XG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IHNvdXJjZS5kaXNwbGFjZW1lbnRTY2FsZTtcblx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSBzb3VyY2UuZGlzcGxhY2VtZW50Qmlhcztcblx0XHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xuXHRcdHRoaXMuZmxhdFNoYWRpbmcgPSBzb3VyY2UuZmxhdFNoYWRpbmc7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn1cblxuY2xhc3MgTWVzaExhbWJlcnRNYXRlcmlhbCBleHRlbmRzIE1hdGVyaWFsIHtcblx0Y29uc3RydWN0b3IocGFyYW1ldGVycykge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5pc01lc2hMYW1iZXJ0TWF0ZXJpYWwgPSB0cnVlO1xuXHRcdHRoaXMudHlwZSA9ICdNZXNoTGFtYmVydE1hdGVyaWFsJztcblx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKDB4ZmZmZmZmKTsgLy8gZGlmZnVzZVxuXG5cdFx0dGhpcy5tYXAgPSBudWxsO1xuXHRcdHRoaXMubGlnaHRNYXAgPSBudWxsO1xuXHRcdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSAxLjA7XG5cdFx0dGhpcy5hb01hcCA9IG51bGw7XG5cdFx0dGhpcy5hb01hcEludGVuc2l0eSA9IDEuMDtcblx0XHR0aGlzLmVtaXNzaXZlID0gbmV3IENvbG9yKDB4MDAwMDAwKTtcblx0XHR0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ID0gMS4wO1xuXHRcdHRoaXMuZW1pc3NpdmVNYXAgPSBudWxsO1xuXHRcdHRoaXMuYnVtcE1hcCA9IG51bGw7XG5cdFx0dGhpcy5idW1wU2NhbGUgPSAxO1xuXHRcdHRoaXMubm9ybWFsTWFwID0gbnVsbDtcblx0XHR0aGlzLm5vcm1hbE1hcFR5cGUgPSBUYW5nZW50U3BhY2VOb3JtYWxNYXA7XG5cdFx0dGhpcy5ub3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKDEsIDEpO1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gbnVsbDtcblx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcblx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSAwO1xuXHRcdHRoaXMuc3BlY3VsYXJNYXAgPSBudWxsO1xuXHRcdHRoaXMuYWxwaGFNYXAgPSBudWxsO1xuXHRcdHRoaXMuZW52TWFwID0gbnVsbDtcblx0XHR0aGlzLmNvbWJpbmUgPSBNdWx0aXBseU9wZXJhdGlvbjtcblx0XHR0aGlzLnJlZmxlY3Rpdml0eSA9IDE7XG5cdFx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSAwLjk4O1xuXHRcdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9ICdyb3VuZCc7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9ICdyb3VuZCc7XG5cdFx0dGhpcy5mbGF0U2hhZGluZyA9IGZhbHNlO1xuXHRcdHRoaXMuZm9nID0gdHJ1ZTtcblx0XHR0aGlzLnNldFZhbHVlcyhwYXJhbWV0ZXJzKTtcblx0fVxuXHRjb3B5KHNvdXJjZSkge1xuXHRcdHN1cGVyLmNvcHkoc291cmNlKTtcblx0XHR0aGlzLmNvbG9yLmNvcHkoc291cmNlLmNvbG9yKTtcblx0XHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XG5cdFx0dGhpcy5saWdodE1hcCA9IHNvdXJjZS5saWdodE1hcDtcblx0XHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gc291cmNlLmxpZ2h0TWFwSW50ZW5zaXR5O1xuXHRcdHRoaXMuYW9NYXAgPSBzb3VyY2UuYW9NYXA7XG5cdFx0dGhpcy5hb01hcEludGVuc2l0eSA9IHNvdXJjZS5hb01hcEludGVuc2l0eTtcblx0XHR0aGlzLmVtaXNzaXZlLmNvcHkoc291cmNlLmVtaXNzaXZlKTtcblx0XHR0aGlzLmVtaXNzaXZlTWFwID0gc291cmNlLmVtaXNzaXZlTWFwO1xuXHRcdHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSBzb3VyY2UuZW1pc3NpdmVJbnRlbnNpdHk7XG5cdFx0dGhpcy5idW1wTWFwID0gc291cmNlLmJ1bXBNYXA7XG5cdFx0dGhpcy5idW1wU2NhbGUgPSBzb3VyY2UuYnVtcFNjYWxlO1xuXHRcdHRoaXMubm9ybWFsTWFwID0gc291cmNlLm5vcm1hbE1hcDtcblx0XHR0aGlzLm5vcm1hbE1hcFR5cGUgPSBzb3VyY2Uubm9ybWFsTWFwVHlwZTtcblx0XHR0aGlzLm5vcm1hbFNjYWxlLmNvcHkoc291cmNlLm5vcm1hbFNjYWxlKTtcblx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IHNvdXJjZS5kaXNwbGFjZW1lbnRNYXA7XG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IHNvdXJjZS5kaXNwbGFjZW1lbnRTY2FsZTtcblx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSBzb3VyY2UuZGlzcGxhY2VtZW50Qmlhcztcblx0XHR0aGlzLnNwZWN1bGFyTWFwID0gc291cmNlLnNwZWN1bGFyTWFwO1xuXHRcdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XG5cdFx0dGhpcy5lbnZNYXAgPSBzb3VyY2UuZW52TWFwO1xuXHRcdHRoaXMuY29tYmluZSA9IHNvdXJjZS5jb21iaW5lO1xuXHRcdHRoaXMucmVmbGVjdGl2aXR5ID0gc291cmNlLnJlZmxlY3Rpdml0eTtcblx0XHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IHNvdXJjZS5yZWZyYWN0aW9uUmF0aW87XG5cdFx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSBzb3VyY2Uud2lyZWZyYW1lTGluZWNhcDtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gc291cmNlLndpcmVmcmFtZUxpbmVqb2luO1xuXHRcdHRoaXMuZmxhdFNoYWRpbmcgPSBzb3VyY2UuZmxhdFNoYWRpbmc7XG5cdFx0dGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59XG5cbmNsYXNzIE1lc2hNYXRjYXBNYXRlcmlhbCBleHRlbmRzIE1hdGVyaWFsIHtcblx0Y29uc3RydWN0b3IocGFyYW1ldGVycykge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5pc01lc2hNYXRjYXBNYXRlcmlhbCA9IHRydWU7XG5cdFx0dGhpcy5kZWZpbmVzID0ge1xuXHRcdFx0J01BVENBUCc6ICcnXG5cdFx0fTtcblx0XHR0aGlzLnR5cGUgPSAnTWVzaE1hdGNhcE1hdGVyaWFsJztcblx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKDB4ZmZmZmZmKTsgLy8gZGlmZnVzZVxuXG5cdFx0dGhpcy5tYXRjYXAgPSBudWxsO1xuXHRcdHRoaXMubWFwID0gbnVsbDtcblx0XHR0aGlzLmJ1bXBNYXAgPSBudWxsO1xuXHRcdHRoaXMuYnVtcFNjYWxlID0gMTtcblx0XHR0aGlzLm5vcm1hbE1hcCA9IG51bGw7XG5cdFx0dGhpcy5ub3JtYWxNYXBUeXBlID0gVGFuZ2VudFNwYWNlTm9ybWFsTWFwO1xuXHRcdHRoaXMubm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMigxLCAxKTtcblx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IG51bGw7XG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IDE7XG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gMDtcblx0XHR0aGlzLmFscGhhTWFwID0gbnVsbDtcblx0XHR0aGlzLmZsYXRTaGFkaW5nID0gZmFsc2U7XG5cdFx0dGhpcy5mb2cgPSB0cnVlO1xuXHRcdHRoaXMuc2V0VmFsdWVzKHBhcmFtZXRlcnMpO1xuXHR9XG5cdGNvcHkoc291cmNlKSB7XG5cdFx0c3VwZXIuY29weShzb3VyY2UpO1xuXHRcdHRoaXMuZGVmaW5lcyA9IHtcblx0XHRcdCdNQVRDQVAnOiAnJ1xuXHRcdH07XG5cdFx0dGhpcy5jb2xvci5jb3B5KHNvdXJjZS5jb2xvcik7XG5cdFx0dGhpcy5tYXRjYXAgPSBzb3VyY2UubWF0Y2FwO1xuXHRcdHRoaXMubWFwID0gc291cmNlLm1hcDtcblx0XHR0aGlzLmJ1bXBNYXAgPSBzb3VyY2UuYnVtcE1hcDtcblx0XHR0aGlzLmJ1bXBTY2FsZSA9IHNvdXJjZS5idW1wU2NhbGU7XG5cdFx0dGhpcy5ub3JtYWxNYXAgPSBzb3VyY2Uubm9ybWFsTWFwO1xuXHRcdHRoaXMubm9ybWFsTWFwVHlwZSA9IHNvdXJjZS5ub3JtYWxNYXBUeXBlO1xuXHRcdHRoaXMubm9ybWFsU2NhbGUuY29weShzb3VyY2Uubm9ybWFsU2NhbGUpO1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gc291cmNlLmRpc3BsYWNlbWVudE1hcDtcblx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gc291cmNlLmRpc3BsYWNlbWVudFNjYWxlO1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IHNvdXJjZS5kaXNwbGFjZW1lbnRCaWFzO1xuXHRcdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XG5cdFx0dGhpcy5mbGF0U2hhZGluZyA9IHNvdXJjZS5mbGF0U2hhZGluZztcblx0XHR0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn1cblxuY2xhc3MgTGluZURhc2hlZE1hdGVyaWFsIGV4dGVuZHMgTGluZUJhc2ljTWF0ZXJpYWwge1xuXHRjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLmlzTGluZURhc2hlZE1hdGVyaWFsID0gdHJ1ZTtcblx0XHR0aGlzLnR5cGUgPSAnTGluZURhc2hlZE1hdGVyaWFsJztcblx0XHR0aGlzLnNjYWxlID0gMTtcblx0XHR0aGlzLmRhc2hTaXplID0gMztcblx0XHR0aGlzLmdhcFNpemUgPSAxO1xuXHRcdHRoaXMuc2V0VmFsdWVzKHBhcmFtZXRlcnMpO1xuXHR9XG5cdGNvcHkoc291cmNlKSB7XG5cdFx0c3VwZXIuY29weShzb3VyY2UpO1xuXHRcdHRoaXMuc2NhbGUgPSBzb3VyY2Uuc2NhbGU7XG5cdFx0dGhpcy5kYXNoU2l6ZSA9IHNvdXJjZS5kYXNoU2l6ZTtcblx0XHR0aGlzLmdhcFNpemUgPSBzb3VyY2UuZ2FwU2l6ZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufVxuXG4vLyBzYW1lIGFzIEFycmF5LnByb3RvdHlwZS5zbGljZSwgYnV0IGFsc28gd29ya3Mgb24gdHlwZWQgYXJyYXlzXG5mdW5jdGlvbiBhcnJheVNsaWNlKGFycmF5LCBmcm9tLCB0bykge1xuXHRpZiAoaXNUeXBlZEFycmF5KGFycmF5KSkge1xuXHRcdC8vIGluIGlvczkgYXJyYXkuc3ViYXJyYXkoZnJvbSwgdW5kZWZpbmVkKSB3aWxsIHJldHVybiBlbXB0eSBhcnJheVxuXHRcdC8vIGJ1dCBhcnJheS5zdWJhcnJheShmcm9tKSBvciBhcnJheS5zdWJhcnJheShmcm9tLCBsZW4pIGlzIGNvcnJlY3Rcblx0XHRyZXR1cm4gbmV3IGFycmF5LmNvbnN0cnVjdG9yKGFycmF5LnN1YmFycmF5KGZyb20sIHRvICE9PSB1bmRlZmluZWQgPyB0byA6IGFycmF5Lmxlbmd0aCkpO1xuXHR9XG5cdHJldHVybiBhcnJheS5zbGljZShmcm9tLCB0byk7XG59XG5cbi8vIGNvbnZlcnRzIGFuIGFycmF5IHRvIGEgc3BlY2lmaWMgdHlwZVxuZnVuY3Rpb24gY29udmVydEFycmF5KGFycmF5LCB0eXBlLCBmb3JjZUNsb25lKSB7XG5cdGlmICghYXJyYXkgfHxcblx0Ly8gbGV0ICd1bmRlZmluZWQnIGFuZCAnbnVsbCcgcGFzc1xuXHQhZm9yY2VDbG9uZSAmJiBhcnJheS5jb25zdHJ1Y3RvciA9PT0gdHlwZSkgcmV0dXJuIGFycmF5O1xuXHRpZiAodHlwZW9mIHR5cGUuQllURVNfUEVSX0VMRU1FTlQgPT09ICdudW1iZXInKSB7XG5cdFx0cmV0dXJuIG5ldyB0eXBlKGFycmF5KTsgLy8gY3JlYXRlIHR5cGVkIGFycmF5XG5cdH1cblxuXHRyZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyYXkpOyAvLyBjcmVhdGUgQXJyYXlcbn1cblxuZnVuY3Rpb24gaXNUeXBlZEFycmF5KG9iamVjdCkge1xuXHRyZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KG9iamVjdCkgJiYgIShvYmplY3QgaW5zdGFuY2VvZiBEYXRhVmlldyk7XG59XG5cbi8vIHJldHVybnMgYW4gYXJyYXkgYnkgd2hpY2ggdGltZXMgYW5kIHZhbHVlcyBjYW4gYmUgc29ydGVkXG5mdW5jdGlvbiBnZXRLZXlmcmFtZU9yZGVyKHRpbWVzKSB7XG5cdGZ1bmN0aW9uIGNvbXBhcmVUaW1lKGksIGopIHtcblx0XHRyZXR1cm4gdGltZXNbaV0gLSB0aW1lc1tqXTtcblx0fVxuXHRjb25zdCBuID0gdGltZXMubGVuZ3RoO1xuXHRjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkobik7XG5cdGZvciAobGV0IGkgPSAwOyBpICE9PSBuOyArK2kpIHJlc3VsdFtpXSA9IGk7XG5cdHJlc3VsdC5zb3J0KGNvbXBhcmVUaW1lKTtcblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gdXNlcyB0aGUgYXJyYXkgcHJldmlvdXNseSByZXR1cm5lZCBieSAnZ2V0S2V5ZnJhbWVPcmRlcicgdG8gc29ydCBkYXRhXG5mdW5jdGlvbiBzb3J0ZWRBcnJheSh2YWx1ZXMsIHN0cmlkZSwgb3JkZXIpIHtcblx0Y29uc3QgblZhbHVlcyA9IHZhbHVlcy5sZW5ndGg7XG5cdGNvbnN0IHJlc3VsdCA9IG5ldyB2YWx1ZXMuY29uc3RydWN0b3IoblZhbHVlcyk7XG5cdGZvciAobGV0IGkgPSAwLCBkc3RPZmZzZXQgPSAwOyBkc3RPZmZzZXQgIT09IG5WYWx1ZXM7ICsraSkge1xuXHRcdGNvbnN0IHNyY09mZnNldCA9IG9yZGVyW2ldICogc3RyaWRlO1xuXHRcdGZvciAobGV0IGogPSAwOyBqICE9PSBzdHJpZGU7ICsraikge1xuXHRcdFx0cmVzdWx0W2RzdE9mZnNldCsrXSA9IHZhbHVlc1tzcmNPZmZzZXQgKyBqXTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gZnVuY3Rpb24gZm9yIHBhcnNpbmcgQU9TIGtleWZyYW1lIGZvcm1hdHNcbmZ1bmN0aW9uIGZsYXR0ZW5KU09OKGpzb25LZXlzLCB0aW1lcywgdmFsdWVzLCB2YWx1ZVByb3BlcnR5TmFtZSkge1xuXHRsZXQgaSA9IDEsXG5cdFx0a2V5ID0ganNvbktleXNbMF07XG5cdHdoaWxlIChrZXkgIT09IHVuZGVmaW5lZCAmJiBrZXlbdmFsdWVQcm9wZXJ0eU5hbWVdID09PSB1bmRlZmluZWQpIHtcblx0XHRrZXkgPSBqc29uS2V5c1tpKytdO1xuXHR9XG5cdGlmIChrZXkgPT09IHVuZGVmaW5lZCkgcmV0dXJuOyAvLyBubyBkYXRhXG5cblx0bGV0IHZhbHVlID0ga2V5W3ZhbHVlUHJvcGVydHlOYW1lXTtcblx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybjsgLy8gbm8gZGF0YVxuXG5cdGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdGRvIHtcblx0XHRcdHZhbHVlID0ga2V5W3ZhbHVlUHJvcGVydHlOYW1lXTtcblx0XHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRpbWVzLnB1c2goa2V5LnRpbWUpO1xuXHRcdFx0XHR2YWx1ZXMucHVzaC5hcHBseSh2YWx1ZXMsIHZhbHVlKTsgLy8gcHVzaCBhbGwgZWxlbWVudHNcblx0XHRcdH1cblxuXHRcdFx0a2V5ID0ganNvbktleXNbaSsrXTtcblx0XHR9IHdoaWxlIChrZXkgIT09IHVuZGVmaW5lZCk7XG5cdH0gZWxzZSBpZiAodmFsdWUudG9BcnJheSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0Ly8gLi4uYXNzdW1lIFRIUkVFLk1hdGgtaXNoXG5cblx0XHRkbyB7XG5cdFx0XHR2YWx1ZSA9IGtleVt2YWx1ZVByb3BlcnR5TmFtZV07XG5cdFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aW1lcy5wdXNoKGtleS50aW1lKTtcblx0XHRcdFx0dmFsdWUudG9BcnJheSh2YWx1ZXMsIHZhbHVlcy5sZW5ndGgpO1xuXHRcdFx0fVxuXHRcdFx0a2V5ID0ganNvbktleXNbaSsrXTtcblx0XHR9IHdoaWxlIChrZXkgIT09IHVuZGVmaW5lZCk7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gb3RoZXJ3aXNlIHB1c2ggYXMtaXNcblxuXHRcdGRvIHtcblx0XHRcdHZhbHVlID0ga2V5W3ZhbHVlUHJvcGVydHlOYW1lXTtcblx0XHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRpbWVzLnB1c2goa2V5LnRpbWUpO1xuXHRcdFx0XHR2YWx1ZXMucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRrZXkgPSBqc29uS2V5c1tpKytdO1xuXHRcdH0gd2hpbGUgKGtleSAhPT0gdW5kZWZpbmVkKTtcblx0fVxufVxuZnVuY3Rpb24gc3ViY2xpcChzb3VyY2VDbGlwLCBuYW1lLCBzdGFydEZyYW1lLCBlbmRGcmFtZSwgZnBzID0gMzApIHtcblx0Y29uc3QgY2xpcCA9IHNvdXJjZUNsaXAuY2xvbmUoKTtcblx0Y2xpcC5uYW1lID0gbmFtZTtcblx0Y29uc3QgdHJhY2tzID0gW107XG5cdGZvciAobGV0IGkgPSAwOyBpIDwgY2xpcC50cmFja3MubGVuZ3RoOyArK2kpIHtcblx0XHRjb25zdCB0cmFjayA9IGNsaXAudHJhY2tzW2ldO1xuXHRcdGNvbnN0IHZhbHVlU2l6ZSA9IHRyYWNrLmdldFZhbHVlU2l6ZSgpO1xuXHRcdGNvbnN0IHRpbWVzID0gW107XG5cdFx0Y29uc3QgdmFsdWVzID0gW107XG5cdFx0Zm9yIChsZXQgaiA9IDA7IGogPCB0cmFjay50aW1lcy5sZW5ndGg7ICsraikge1xuXHRcdFx0Y29uc3QgZnJhbWUgPSB0cmFjay50aW1lc1tqXSAqIGZwcztcblx0XHRcdGlmIChmcmFtZSA8IHN0YXJ0RnJhbWUgfHwgZnJhbWUgPj0gZW5kRnJhbWUpIGNvbnRpbnVlO1xuXHRcdFx0dGltZXMucHVzaCh0cmFjay50aW1lc1tqXSk7XG5cdFx0XHRmb3IgKGxldCBrID0gMDsgayA8IHZhbHVlU2l6ZTsgKytrKSB7XG5cdFx0XHRcdHZhbHVlcy5wdXNoKHRyYWNrLnZhbHVlc1tqICogdmFsdWVTaXplICsga10pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAodGltZXMubGVuZ3RoID09PSAwKSBjb250aW51ZTtcblx0XHR0cmFjay50aW1lcyA9IGNvbnZlcnRBcnJheSh0aW1lcywgdHJhY2sudGltZXMuY29uc3RydWN0b3IpO1xuXHRcdHRyYWNrLnZhbHVlcyA9IGNvbnZlcnRBcnJheSh2YWx1ZXMsIHRyYWNrLnZhbHVlcy5jb25zdHJ1Y3Rvcik7XG5cdFx0dHJhY2tzLnB1c2godHJhY2spO1xuXHR9XG5cdGNsaXAudHJhY2tzID0gdHJhY2tzO1xuXG5cdC8vIGZpbmQgbWluaW11bSAudGltZXMgdmFsdWUgYWNyb3NzIGFsbCB0cmFja3MgaW4gdGhlIHRyaW1tZWQgY2xpcFxuXG5cdGxldCBtaW5TdGFydFRpbWUgPSBJbmZpbml0eTtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjbGlwLnRyYWNrcy5sZW5ndGg7ICsraSkge1xuXHRcdGlmIChtaW5TdGFydFRpbWUgPiBjbGlwLnRyYWNrc1tpXS50aW1lc1swXSkge1xuXHRcdFx0bWluU3RhcnRUaW1lID0gY2xpcC50cmFja3NbaV0udGltZXNbMF07XG5cdFx0fVxuXHR9XG5cblx0Ly8gc2hpZnQgYWxsIHRyYWNrcyBzdWNoIHRoYXQgY2xpcCBiZWdpbnMgYXQgdD0wXG5cblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjbGlwLnRyYWNrcy5sZW5ndGg7ICsraSkge1xuXHRcdGNsaXAudHJhY2tzW2ldLnNoaWZ0KC0xICogbWluU3RhcnRUaW1lKTtcblx0fVxuXHRjbGlwLnJlc2V0RHVyYXRpb24oKTtcblx0cmV0dXJuIGNsaXA7XG59XG5mdW5jdGlvbiBtYWtlQ2xpcEFkZGl0aXZlKHRhcmdldENsaXAsIHJlZmVyZW5jZUZyYW1lID0gMCwgcmVmZXJlbmNlQ2xpcCA9IHRhcmdldENsaXAsIGZwcyA9IDMwKSB7XG5cdGlmIChmcHMgPD0gMCkgZnBzID0gMzA7XG5cdGNvbnN0IG51bVRyYWNrcyA9IHJlZmVyZW5jZUNsaXAudHJhY2tzLmxlbmd0aDtcblx0Y29uc3QgcmVmZXJlbmNlVGltZSA9IHJlZmVyZW5jZUZyYW1lIC8gZnBzO1xuXG5cdC8vIE1ha2UgZWFjaCB0cmFjaydzIHZhbHVlcyByZWxhdGl2ZSB0byB0aGUgdmFsdWVzIGF0IHRoZSByZWZlcmVuY2UgZnJhbWVcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBudW1UcmFja3M7ICsraSkge1xuXHRcdGNvbnN0IHJlZmVyZW5jZVRyYWNrID0gcmVmZXJlbmNlQ2xpcC50cmFja3NbaV07XG5cdFx0Y29uc3QgcmVmZXJlbmNlVHJhY2tUeXBlID0gcmVmZXJlbmNlVHJhY2suVmFsdWVUeXBlTmFtZTtcblxuXHRcdC8vIFNraXAgdGhpcyB0cmFjayBpZiBpdCdzIG5vbi1udW1lcmljXG5cdFx0aWYgKHJlZmVyZW5jZVRyYWNrVHlwZSA9PT0gJ2Jvb2wnIHx8IHJlZmVyZW5jZVRyYWNrVHlwZSA9PT0gJ3N0cmluZycpIGNvbnRpbnVlO1xuXG5cdFx0Ly8gRmluZCB0aGUgdHJhY2sgaW4gdGhlIHRhcmdldCBjbGlwIHdob3NlIG5hbWUgYW5kIHR5cGUgbWF0Y2hlcyB0aGUgcmVmZXJlbmNlIHRyYWNrXG5cdFx0Y29uc3QgdGFyZ2V0VHJhY2sgPSB0YXJnZXRDbGlwLnRyYWNrcy5maW5kKGZ1bmN0aW9uICh0cmFjaykge1xuXHRcdFx0cmV0dXJuIHRyYWNrLm5hbWUgPT09IHJlZmVyZW5jZVRyYWNrLm5hbWUgJiYgdHJhY2suVmFsdWVUeXBlTmFtZSA9PT0gcmVmZXJlbmNlVHJhY2tUeXBlO1xuXHRcdH0pO1xuXHRcdGlmICh0YXJnZXRUcmFjayA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcblx0XHRsZXQgcmVmZXJlbmNlT2Zmc2V0ID0gMDtcblx0XHRjb25zdCByZWZlcmVuY2VWYWx1ZVNpemUgPSByZWZlcmVuY2VUcmFjay5nZXRWYWx1ZVNpemUoKTtcblx0XHRpZiAocmVmZXJlbmNlVHJhY2suY3JlYXRlSW50ZXJwb2xhbnQuaXNJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RHTFRGQ3ViaWNTcGxpbmUpIHtcblx0XHRcdHJlZmVyZW5jZU9mZnNldCA9IHJlZmVyZW5jZVZhbHVlU2l6ZSAvIDM7XG5cdFx0fVxuXHRcdGxldCB0YXJnZXRPZmZzZXQgPSAwO1xuXHRcdGNvbnN0IHRhcmdldFZhbHVlU2l6ZSA9IHRhcmdldFRyYWNrLmdldFZhbHVlU2l6ZSgpO1xuXHRcdGlmICh0YXJnZXRUcmFjay5jcmVhdGVJbnRlcnBvbGFudC5pc0ludGVycG9sYW50RmFjdG9yeU1ldGhvZEdMVEZDdWJpY1NwbGluZSkge1xuXHRcdFx0dGFyZ2V0T2Zmc2V0ID0gdGFyZ2V0VmFsdWVTaXplIC8gMztcblx0XHR9XG5cdFx0Y29uc3QgbGFzdEluZGV4ID0gcmVmZXJlbmNlVHJhY2sudGltZXMubGVuZ3RoIC0gMTtcblx0XHRsZXQgcmVmZXJlbmNlVmFsdWU7XG5cblx0XHQvLyBGaW5kIHRoZSB2YWx1ZSB0byBzdWJ0cmFjdCBvdXQgb2YgdGhlIHRyYWNrXG5cdFx0aWYgKHJlZmVyZW5jZVRpbWUgPD0gcmVmZXJlbmNlVHJhY2sudGltZXNbMF0pIHtcblx0XHRcdC8vIFJlZmVyZW5jZSBmcmFtZSBpcyBlYXJsaWVyIHRoYW4gdGhlIGZpcnN0IGtleWZyYW1lLCBzbyBqdXN0IHVzZSB0aGUgZmlyc3Qga2V5ZnJhbWVcblx0XHRcdGNvbnN0IHN0YXJ0SW5kZXggPSByZWZlcmVuY2VPZmZzZXQ7XG5cdFx0XHRjb25zdCBlbmRJbmRleCA9IHJlZmVyZW5jZVZhbHVlU2l6ZSAtIHJlZmVyZW5jZU9mZnNldDtcblx0XHRcdHJlZmVyZW5jZVZhbHVlID0gYXJyYXlTbGljZShyZWZlcmVuY2VUcmFjay52YWx1ZXMsIHN0YXJ0SW5kZXgsIGVuZEluZGV4KTtcblx0XHR9IGVsc2UgaWYgKHJlZmVyZW5jZVRpbWUgPj0gcmVmZXJlbmNlVHJhY2sudGltZXNbbGFzdEluZGV4XSkge1xuXHRcdFx0Ly8gUmVmZXJlbmNlIGZyYW1lIGlzIGFmdGVyIHRoZSBsYXN0IGtleWZyYW1lLCBzbyBqdXN0IHVzZSB0aGUgbGFzdCBrZXlmcmFtZVxuXHRcdFx0Y29uc3Qgc3RhcnRJbmRleCA9IGxhc3RJbmRleCAqIHJlZmVyZW5jZVZhbHVlU2l6ZSArIHJlZmVyZW5jZU9mZnNldDtcblx0XHRcdGNvbnN0IGVuZEluZGV4ID0gc3RhcnRJbmRleCArIHJlZmVyZW5jZVZhbHVlU2l6ZSAtIHJlZmVyZW5jZU9mZnNldDtcblx0XHRcdHJlZmVyZW5jZVZhbHVlID0gYXJyYXlTbGljZShyZWZlcmVuY2VUcmFjay52YWx1ZXMsIHN0YXJ0SW5kZXgsIGVuZEluZGV4KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gSW50ZXJwb2xhdGUgdG8gdGhlIHJlZmVyZW5jZSB2YWx1ZVxuXHRcdFx0Y29uc3QgaW50ZXJwb2xhbnQgPSByZWZlcmVuY2VUcmFjay5jcmVhdGVJbnRlcnBvbGFudCgpO1xuXHRcdFx0Y29uc3Qgc3RhcnRJbmRleCA9IHJlZmVyZW5jZU9mZnNldDtcblx0XHRcdGNvbnN0IGVuZEluZGV4ID0gcmVmZXJlbmNlVmFsdWVTaXplIC0gcmVmZXJlbmNlT2Zmc2V0O1xuXHRcdFx0aW50ZXJwb2xhbnQuZXZhbHVhdGUocmVmZXJlbmNlVGltZSk7XG5cdFx0XHRyZWZlcmVuY2VWYWx1ZSA9IGFycmF5U2xpY2UoaW50ZXJwb2xhbnQucmVzdWx0QnVmZmVyLCBzdGFydEluZGV4LCBlbmRJbmRleCk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29uanVnYXRlIHRoZSBxdWF0ZXJuaW9uXG5cdFx0aWYgKHJlZmVyZW5jZVRyYWNrVHlwZSA9PT0gJ3F1YXRlcm5pb24nKSB7XG5cdFx0XHRjb25zdCByZWZlcmVuY2VRdWF0ID0gbmV3IFF1YXRlcm5pb24oKS5mcm9tQXJyYXkocmVmZXJlbmNlVmFsdWUpLm5vcm1hbGl6ZSgpLmNvbmp1Z2F0ZSgpO1xuXHRcdFx0cmVmZXJlbmNlUXVhdC50b0FycmF5KHJlZmVyZW5jZVZhbHVlKTtcblx0XHR9XG5cblx0XHQvLyBTdWJ0cmFjdCB0aGUgcmVmZXJlbmNlIHZhbHVlIGZyb20gYWxsIG9mIHRoZSB0cmFjayB2YWx1ZXNcblxuXHRcdGNvbnN0IG51bVRpbWVzID0gdGFyZ2V0VHJhY2sudGltZXMubGVuZ3RoO1xuXHRcdGZvciAobGV0IGogPSAwOyBqIDwgbnVtVGltZXM7ICsraikge1xuXHRcdFx0Y29uc3QgdmFsdWVTdGFydCA9IGogKiB0YXJnZXRWYWx1ZVNpemUgKyB0YXJnZXRPZmZzZXQ7XG5cdFx0XHRpZiAocmVmZXJlbmNlVHJhY2tUeXBlID09PSAncXVhdGVybmlvbicpIHtcblx0XHRcdFx0Ly8gTXVsdGlwbHkgdGhlIGNvbmp1Z2F0ZSBmb3IgcXVhdGVybmlvbiB0cmFjayB0eXBlc1xuXHRcdFx0XHRRdWF0ZXJuaW9uLm11bHRpcGx5UXVhdGVybmlvbnNGbGF0KHRhcmdldFRyYWNrLnZhbHVlcywgdmFsdWVTdGFydCwgcmVmZXJlbmNlVmFsdWUsIDAsIHRhcmdldFRyYWNrLnZhbHVlcywgdmFsdWVTdGFydCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zdCB2YWx1ZUVuZCA9IHRhcmdldFZhbHVlU2l6ZSAtIHRhcmdldE9mZnNldCAqIDI7XG5cblx0XHRcdFx0Ly8gU3VidHJhY3QgZWFjaCB2YWx1ZSBmb3IgYWxsIG90aGVyIG51bWVyaWMgdHJhY2sgdHlwZXNcblx0XHRcdFx0Zm9yIChsZXQgayA9IDA7IGsgPCB2YWx1ZUVuZDsgKytrKSB7XG5cdFx0XHRcdFx0dGFyZ2V0VHJhY2sudmFsdWVzW3ZhbHVlU3RhcnQgKyBrXSAtPSByZWZlcmVuY2VWYWx1ZVtrXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHR0YXJnZXRDbGlwLmJsZW5kTW9kZSA9IEFkZGl0aXZlQW5pbWF0aW9uQmxlbmRNb2RlO1xuXHRyZXR1cm4gdGFyZ2V0Q2xpcDtcbn1cblxudmFyIEFuaW1hdGlvblV0aWxzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdGFycmF5U2xpY2U6IGFycmF5U2xpY2UsXG5cdGNvbnZlcnRBcnJheTogY29udmVydEFycmF5LFxuXHRpc1R5cGVkQXJyYXk6IGlzVHlwZWRBcnJheSxcblx0Z2V0S2V5ZnJhbWVPcmRlcjogZ2V0S2V5ZnJhbWVPcmRlcixcblx0c29ydGVkQXJyYXk6IHNvcnRlZEFycmF5LFxuXHRmbGF0dGVuSlNPTjogZmxhdHRlbkpTT04sXG5cdHN1YmNsaXA6IHN1YmNsaXAsXG5cdG1ha2VDbGlwQWRkaXRpdmU6IG1ha2VDbGlwQWRkaXRpdmVcbn0pO1xuXG4vKipcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3Mgb2YgaW50ZXJwb2xhbnRzIG92ZXIgcGFyYW1ldHJpYyBzYW1wbGVzLlxuICpcbiAqIFRoZSBwYXJhbWV0ZXIgZG9tYWluIGlzIG9uZSBkaW1lbnNpb25hbCwgdHlwaWNhbGx5IHRoZSB0aW1lIG9yIGEgcGF0aFxuICogYWxvbmcgYSBjdXJ2ZSBkZWZpbmVkIGJ5IHRoZSBkYXRhLlxuICpcbiAqIFRoZSBzYW1wbGUgdmFsdWVzIGNhbiBoYXZlIGFueSBkaW1lbnNpb25hbGl0eSBhbmQgZGVyaXZlZCBjbGFzc2VzIG1heVxuICogYXBwbHkgc3BlY2lhbCBpbnRlcnByZXRhdGlvbnMgdG8gdGhlIGRhdGEuXG4gKlxuICogVGhpcyBjbGFzcyBwcm92aWRlcyB0aGUgaW50ZXJ2YWwgc2VlayBpbiBhIFRlbXBsYXRlIE1ldGhvZCwgZGVmZXJyaW5nXG4gKiB0aGUgYWN0dWFsIGludGVycG9sYXRpb24gdG8gZGVyaXZlZCBjbGFzc2VzLlxuICpcbiAqIFRpbWUgY29tcGxleGl0eSBpcyBPKDEpIGZvciBsaW5lYXIgYWNjZXNzIGNyb3NzaW5nIGF0IG1vc3QgdHdvIHBvaW50c1xuICogYW5kIE8obG9nIE4pIGZvciByYW5kb20gYWNjZXNzLCB3aGVyZSBOIGlzIHRoZSBudW1iZXIgb2YgcG9zaXRpb25zLlxuICpcbiAqIFJlZmVyZW5jZXM6XG4gKlxuICogXHRcdGh0dHA6Ly93d3cub29kZXNpZ24uY29tL3RlbXBsYXRlLW1ldGhvZC1wYXR0ZXJuLmh0bWxcbiAqXG4gKi9cblxuY2xhc3MgSW50ZXJwb2xhbnQge1xuXHRjb25zdHJ1Y3RvcihwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyKSB7XG5cdFx0dGhpcy5wYXJhbWV0ZXJQb3NpdGlvbnMgPSBwYXJhbWV0ZXJQb3NpdGlvbnM7XG5cdFx0dGhpcy5fY2FjaGVkSW5kZXggPSAwO1xuXHRcdHRoaXMucmVzdWx0QnVmZmVyID0gcmVzdWx0QnVmZmVyICE9PSB1bmRlZmluZWQgPyByZXN1bHRCdWZmZXIgOiBuZXcgc2FtcGxlVmFsdWVzLmNvbnN0cnVjdG9yKHNhbXBsZVNpemUpO1xuXHRcdHRoaXMuc2FtcGxlVmFsdWVzID0gc2FtcGxlVmFsdWVzO1xuXHRcdHRoaXMudmFsdWVTaXplID0gc2FtcGxlU2l6ZTtcblx0XHR0aGlzLnNldHRpbmdzID0gbnVsbDtcblx0XHR0aGlzLkRlZmF1bHRTZXR0aW5nc18gPSB7fTtcblx0fVxuXHRldmFsdWF0ZSh0KSB7XG5cdFx0Y29uc3QgcHAgPSB0aGlzLnBhcmFtZXRlclBvc2l0aW9ucztcblx0XHRsZXQgaTEgPSB0aGlzLl9jYWNoZWRJbmRleCxcblx0XHRcdHQxID0gcHBbaTFdLFxuXHRcdFx0dDAgPSBwcFtpMSAtIDFdO1xuXHRcdHZhbGlkYXRlX2ludGVydmFsOiB7XG5cdFx0XHRzZWVrOiB7XG5cdFx0XHRcdGxldCByaWdodDtcblx0XHRcdFx0bGluZWFyX3NjYW46IHtcblx0XHRcdFx0XHQvLy0gU2VlIGh0dHA6Ly9qc3BlcmYuY29tL2NvbXBhcmlzb24tdG8tdW5kZWZpbmVkLzNcblx0XHRcdFx0XHQvLy0gc2xvd2VyIGNvZGU6XG5cdFx0XHRcdFx0Ly8tXG5cdFx0XHRcdFx0Ly8tIFx0XHRcdFx0aWYgKCB0ID49IHQxIHx8IHQxID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0Zm9yd2FyZF9zY2FuOiBpZiAoISh0IDwgdDEpKSB7XG5cdFx0XHRcdFx0XHRmb3IgKGxldCBnaXZlVXBBdCA9IGkxICsgMjs7KSB7XG5cdFx0XHRcdFx0XHRcdGlmICh0MSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHQgPCB0MCkgYnJlYWsgZm9yd2FyZF9zY2FuO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gYWZ0ZXIgZW5kXG5cblx0XHRcdFx0XHRcdFx0XHRpMSA9IHBwLmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9jYWNoZWRJbmRleCA9IGkxO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmNvcHlTYW1wbGVWYWx1ZV8oaTEgLSAxKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAoaTEgPT09IGdpdmVVcEF0KSBicmVhazsgLy8gdGhpcyBsb29wXG5cblx0XHRcdFx0XHRcdFx0dDAgPSB0MTtcblx0XHRcdFx0XHRcdFx0dDEgPSBwcFsrK2kxXTtcblx0XHRcdFx0XHRcdFx0aWYgKHQgPCB0MSkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIHdlIGhhdmUgYXJyaXZlZCBhdCB0aGUgc291Z2h0IGludGVydmFsXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWsgc2Vlaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBwcmVwYXJlIGJpbmFyeSBzZWFyY2ggb24gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGluZGV4XG5cdFx0XHRcdFx0XHRyaWdodCA9IHBwLmxlbmd0aDtcblx0XHRcdFx0XHRcdGJyZWFrIGxpbmVhcl9zY2FuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vLSBzbG93ZXIgY29kZTpcblx0XHRcdFx0XHQvLy1cdFx0XHRcdFx0aWYgKCB0IDwgdDAgfHwgdDAgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRpZiAoISh0ID49IHQwKSkge1xuXHRcdFx0XHRcdFx0Ly8gbG9vcGluZz9cblxuXHRcdFx0XHRcdFx0Y29uc3QgdDFnbG9iYWwgPSBwcFsxXTtcblx0XHRcdFx0XHRcdGlmICh0IDwgdDFnbG9iYWwpIHtcblx0XHRcdFx0XHRcdFx0aTEgPSAyOyAvLyArIDEsIHVzaW5nIHRoZSBzY2FuIGZvciB0aGUgZGV0YWlsc1xuXHRcdFx0XHRcdFx0XHR0MCA9IHQxZ2xvYmFsO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBsaW5lYXIgcmV2ZXJzZSBzY2FuXG5cblx0XHRcdFx0XHRcdGZvciAobGV0IGdpdmVVcEF0ID0gaTEgLSAyOzspIHtcblx0XHRcdFx0XHRcdFx0aWYgKHQwID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBiZWZvcmUgc3RhcnRcblxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2NhY2hlZEluZGV4ID0gMDtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5jb3B5U2FtcGxlVmFsdWVfKDApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmIChpMSA9PT0gZ2l2ZVVwQXQpIGJyZWFrOyAvLyB0aGlzIGxvb3BcblxuXHRcdFx0XHRcdFx0XHR0MSA9IHQwO1xuXHRcdFx0XHRcdFx0XHR0MCA9IHBwWy0taTEgLSAxXTtcblx0XHRcdFx0XHRcdFx0aWYgKHQgPj0gdDApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyB3ZSBoYXZlIGFycml2ZWQgYXQgdGhlIHNvdWdodCBpbnRlcnZhbFxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrIHNlZWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gcHJlcGFyZSBiaW5hcnkgc2VhcmNoIG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIGluZGV4XG5cdFx0XHRcdFx0XHRyaWdodCA9IGkxO1xuXHRcdFx0XHRcdFx0aTEgPSAwO1xuXHRcdFx0XHRcdFx0YnJlYWsgbGluZWFyX3NjYW47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gdGhlIGludGVydmFsIGlzIHZhbGlkXG5cblx0XHRcdFx0XHRicmVhayB2YWxpZGF0ZV9pbnRlcnZhbDtcblx0XHRcdFx0fSAvLyBsaW5lYXIgc2NhblxuXG5cdFx0XHRcdC8vIGJpbmFyeSBzZWFyY2hcblxuXHRcdFx0XHR3aGlsZSAoaTEgPCByaWdodCkge1xuXHRcdFx0XHRcdGNvbnN0IG1pZCA9IGkxICsgcmlnaHQgPj4+IDE7XG5cdFx0XHRcdFx0aWYgKHQgPCBwcFttaWRdKSB7XG5cdFx0XHRcdFx0XHRyaWdodCA9IG1pZDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aTEgPSBtaWQgKyAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0MSA9IHBwW2kxXTtcblx0XHRcdFx0dDAgPSBwcFtpMSAtIDFdO1xuXG5cdFx0XHRcdC8vIGNoZWNrIGJvdW5kYXJ5IGNhc2VzLCBhZ2FpblxuXG5cdFx0XHRcdGlmICh0MCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0dGhpcy5fY2FjaGVkSW5kZXggPSAwO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLmNvcHlTYW1wbGVWYWx1ZV8oMCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHQxID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRpMSA9IHBwLmxlbmd0aDtcblx0XHRcdFx0XHR0aGlzLl9jYWNoZWRJbmRleCA9IGkxO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLmNvcHlTYW1wbGVWYWx1ZV8oaTEgLSAxKTtcblx0XHRcdFx0fVxuXHRcdFx0fSAvLyBzZWVrXG5cblx0XHRcdHRoaXMuX2NhY2hlZEluZGV4ID0gaTE7XG5cdFx0XHR0aGlzLmludGVydmFsQ2hhbmdlZF8oaTEsIHQwLCB0MSk7XG5cdFx0fSAvLyB2YWxpZGF0ZV9pbnRlcnZhbFxuXG5cdFx0cmV0dXJuIHRoaXMuaW50ZXJwb2xhdGVfKGkxLCB0MCwgdCwgdDEpO1xuXHR9XG5cdGdldFNldHRpbmdzXygpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXR0aW5ncyB8fCB0aGlzLkRlZmF1bHRTZXR0aW5nc187XG5cdH1cblx0Y29weVNhbXBsZVZhbHVlXyhpbmRleCkge1xuXHRcdC8vIGNvcGllcyBhIHNhbXBsZSB2YWx1ZSB0byB0aGUgcmVzdWx0IGJ1ZmZlclxuXG5cdFx0Y29uc3QgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXIsXG5cdFx0XHR2YWx1ZXMgPSB0aGlzLnNhbXBsZVZhbHVlcyxcblx0XHRcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxuXHRcdFx0b2Zmc2V0ID0gaW5kZXggKiBzdHJpZGU7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgIT09IHN0cmlkZTsgKytpKSB7XG5cdFx0XHRyZXN1bHRbaV0gPSB2YWx1ZXNbb2Zmc2V0ICsgaV07XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvLyBUZW1wbGF0ZSBtZXRob2RzIGZvciBkZXJpdmVkIGNsYXNzZXM6XG5cblx0aW50ZXJwb2xhdGVfKCkge1xuXHRcdHRocm93IG5ldyBFcnJvcignY2FsbCB0byBhYnN0cmFjdCBtZXRob2QnKTtcblx0XHQvLyBpbXBsZW1lbnRhdGlvbnMgc2hhbGwgcmV0dXJuIHRoaXMucmVzdWx0QnVmZmVyXG5cdH1cblxuXHRpbnRlcnZhbENoYW5nZWRfKCkge1xuXG5cdFx0Ly8gZW1wdHlcblx0fVxufVxuXG4vKipcbiAqIEZhc3QgYW5kIHNpbXBsZSBjdWJpYyBzcGxpbmUgaW50ZXJwb2xhbnQuXG4gKlxuICogSXQgd2FzIGRlcml2ZWQgZnJvbSBhIEhlcm1pdGlhbiBjb25zdHJ1Y3Rpb24gc2V0dGluZyB0aGUgZmlyc3QgZGVyaXZhdGl2ZVxuICogYXQgZWFjaCBzYW1wbGUgcG9zaXRpb24gdG8gdGhlIGxpbmVhciBzbG9wZSBiZXR3ZWVuIG5laWdoYm9yaW5nIHBvc2l0aW9uc1xuICogb3ZlciB0aGVpciBwYXJhbWV0ZXIgaW50ZXJ2YWwuXG4gKi9cblxuY2xhc3MgQ3ViaWNJbnRlcnBvbGFudCBleHRlbmRzIEludGVycG9sYW50IHtcblx0Y29uc3RydWN0b3IocGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlcikge1xuXHRcdHN1cGVyKHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIpO1xuXHRcdHRoaXMuX3dlaWdodFByZXYgPSAtMDtcblx0XHR0aGlzLl9vZmZzZXRQcmV2ID0gLTA7XG5cdFx0dGhpcy5fd2VpZ2h0TmV4dCA9IC0wO1xuXHRcdHRoaXMuX29mZnNldE5leHQgPSAtMDtcblx0XHR0aGlzLkRlZmF1bHRTZXR0aW5nc18gPSB7XG5cdFx0XHRlbmRpbmdTdGFydDogWmVyb0N1cnZhdHVyZUVuZGluZyxcblx0XHRcdGVuZGluZ0VuZDogWmVyb0N1cnZhdHVyZUVuZGluZ1xuXHRcdH07XG5cdH1cblx0aW50ZXJ2YWxDaGFuZ2VkXyhpMSwgdDAsIHQxKSB7XG5cdFx0Y29uc3QgcHAgPSB0aGlzLnBhcmFtZXRlclBvc2l0aW9ucztcblx0XHRsZXQgaVByZXYgPSBpMSAtIDIsXG5cdFx0XHRpTmV4dCA9IGkxICsgMSxcblx0XHRcdHRQcmV2ID0gcHBbaVByZXZdLFxuXHRcdFx0dE5leHQgPSBwcFtpTmV4dF07XG5cdFx0aWYgKHRQcmV2ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHN3aXRjaCAodGhpcy5nZXRTZXR0aW5nc18oKS5lbmRpbmdTdGFydCkge1xuXHRcdFx0XHRjYXNlIFplcm9TbG9wZUVuZGluZzpcblx0XHRcdFx0XHQvLyBmJyh0MCkgPSAwXG5cdFx0XHRcdFx0aVByZXYgPSBpMTtcblx0XHRcdFx0XHR0UHJldiA9IDIgKiB0MCAtIHQxO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFdyYXBBcm91bmRFbmRpbmc6XG5cdFx0XHRcdFx0Ly8gdXNlIHRoZSBvdGhlciBlbmQgb2YgdGhlIGN1cnZlXG5cdFx0XHRcdFx0aVByZXYgPSBwcC5sZW5ndGggLSAyO1xuXHRcdFx0XHRcdHRQcmV2ID0gdDAgKyBwcFtpUHJldl0gLSBwcFtpUHJldiArIDFdO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdC8vIFplcm9DdXJ2YXR1cmVFbmRpbmdcblxuXHRcdFx0XHRcdC8vIGYnJyh0MCkgPSAwIGEuay5hLiBOYXR1cmFsIFNwbGluZVxuXHRcdFx0XHRcdGlQcmV2ID0gaTE7XG5cdFx0XHRcdFx0dFByZXYgPSB0MTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHROZXh0ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHN3aXRjaCAodGhpcy5nZXRTZXR0aW5nc18oKS5lbmRpbmdFbmQpIHtcblx0XHRcdFx0Y2FzZSBaZXJvU2xvcGVFbmRpbmc6XG5cdFx0XHRcdFx0Ly8gZicodE4pID0gMFxuXHRcdFx0XHRcdGlOZXh0ID0gaTE7XG5cdFx0XHRcdFx0dE5leHQgPSAyICogdDEgLSB0MDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBXcmFwQXJvdW5kRW5kaW5nOlxuXHRcdFx0XHRcdC8vIHVzZSB0aGUgb3RoZXIgZW5kIG9mIHRoZSBjdXJ2ZVxuXHRcdFx0XHRcdGlOZXh0ID0gMTtcblx0XHRcdFx0XHR0TmV4dCA9IHQxICsgcHBbMV0gLSBwcFswXTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHQvLyBaZXJvQ3VydmF0dXJlRW5kaW5nXG5cblx0XHRcdFx0XHQvLyBmJycodE4pID0gMCwgYS5rLmEuIE5hdHVyYWwgU3BsaW5lXG5cdFx0XHRcdFx0aU5leHQgPSBpMSAtIDE7XG5cdFx0XHRcdFx0dE5leHQgPSB0MDtcblx0XHRcdH1cblx0XHR9XG5cdFx0Y29uc3QgaGFsZkR0ID0gKHQxIC0gdDApICogMC41LFxuXHRcdFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemU7XG5cdFx0dGhpcy5fd2VpZ2h0UHJldiA9IGhhbGZEdCAvICh0MCAtIHRQcmV2KTtcblx0XHR0aGlzLl93ZWlnaHROZXh0ID0gaGFsZkR0IC8gKHROZXh0IC0gdDEpO1xuXHRcdHRoaXMuX29mZnNldFByZXYgPSBpUHJldiAqIHN0cmlkZTtcblx0XHR0aGlzLl9vZmZzZXROZXh0ID0gaU5leHQgKiBzdHJpZGU7XG5cdH1cblx0aW50ZXJwb2xhdGVfKGkxLCB0MCwgdCwgdDEpIHtcblx0XHRjb25zdCByZXN1bHQgPSB0aGlzLnJlc3VsdEJ1ZmZlcixcblx0XHRcdHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzLFxuXHRcdFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXG5cdFx0XHRvMSA9IGkxICogc3RyaWRlLFxuXHRcdFx0bzAgPSBvMSAtIHN0cmlkZSxcblx0XHRcdG9QID0gdGhpcy5fb2Zmc2V0UHJldixcblx0XHRcdG9OID0gdGhpcy5fb2Zmc2V0TmV4dCxcblx0XHRcdHdQID0gdGhpcy5fd2VpZ2h0UHJldixcblx0XHRcdHdOID0gdGhpcy5fd2VpZ2h0TmV4dCxcblx0XHRcdHAgPSAodCAtIHQwKSAvICh0MSAtIHQwKSxcblx0XHRcdHBwID0gcCAqIHAsXG5cdFx0XHRwcHAgPSBwcCAqIHA7XG5cblx0XHQvLyBldmFsdWF0ZSBwb2x5bm9taWFsc1xuXG5cdFx0Y29uc3Qgc1AgPSAtd1AgKiBwcHAgKyAyICogd1AgKiBwcCAtIHdQICogcDtcblx0XHRjb25zdCBzMCA9ICgxICsgd1ApICogcHBwICsgKC0xLjUgLSAyICogd1ApICogcHAgKyAoLTAuNSArIHdQKSAqIHAgKyAxO1xuXHRcdGNvbnN0IHMxID0gKC0xIC0gd04pICogcHBwICsgKDEuNSArIHdOKSAqIHBwICsgMC41ICogcDtcblx0XHRjb25zdCBzTiA9IHdOICogcHBwIC0gd04gKiBwcDtcblxuXHRcdC8vIGNvbWJpbmUgZGF0YSBsaW5lYXJseVxuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgIT09IHN0cmlkZTsgKytpKSB7XG5cdFx0XHRyZXN1bHRbaV0gPSBzUCAqIHZhbHVlc1tvUCArIGldICsgczAgKiB2YWx1ZXNbbzAgKyBpXSArIHMxICogdmFsdWVzW28xICsgaV0gKyBzTiAqIHZhbHVlc1tvTiArIGldO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG59XG5cbmNsYXNzIExpbmVhckludGVycG9sYW50IGV4dGVuZHMgSW50ZXJwb2xhbnQge1xuXHRjb25zdHJ1Y3RvcihwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyKSB7XG5cdFx0c3VwZXIocGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlcik7XG5cdH1cblx0aW50ZXJwb2xhdGVfKGkxLCB0MCwgdCwgdDEpIHtcblx0XHRjb25zdCByZXN1bHQgPSB0aGlzLnJlc3VsdEJ1ZmZlcixcblx0XHRcdHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzLFxuXHRcdFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXG5cdFx0XHRvZmZzZXQxID0gaTEgKiBzdHJpZGUsXG5cdFx0XHRvZmZzZXQwID0gb2Zmc2V0MSAtIHN0cmlkZSxcblx0XHRcdHdlaWdodDEgPSAodCAtIHQwKSAvICh0MSAtIHQwKSxcblx0XHRcdHdlaWdodDAgPSAxIC0gd2VpZ2h0MTtcblx0XHRmb3IgKGxldCBpID0gMDsgaSAhPT0gc3RyaWRlOyArK2kpIHtcblx0XHRcdHJlc3VsdFtpXSA9IHZhbHVlc1tvZmZzZXQwICsgaV0gKiB3ZWlnaHQwICsgdmFsdWVzW29mZnNldDEgKyBpXSAqIHdlaWdodDE7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cbn1cblxuLyoqXG4gKlxuICogSW50ZXJwb2xhbnQgdGhhdCBldmFsdWF0ZXMgdG8gdGhlIHNhbXBsZSB2YWx1ZSBhdCB0aGUgcG9zaXRpb24gcHJlY2VkaW5nXG4gKiB0aGUgcGFyYW1ldGVyLlxuICovXG5cbmNsYXNzIERpc2NyZXRlSW50ZXJwb2xhbnQgZXh0ZW5kcyBJbnRlcnBvbGFudCB7XG5cdGNvbnN0cnVjdG9yKHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIpIHtcblx0XHRzdXBlcihwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyKTtcblx0fVxuXHRpbnRlcnBvbGF0ZV8oaTEgLyosIHQwLCB0LCB0MSAqLykge1xuXHRcdHJldHVybiB0aGlzLmNvcHlTYW1wbGVWYWx1ZV8oaTEgLSAxKTtcblx0fVxufVxuXG5jbGFzcyBLZXlmcmFtZVRyYWNrIHtcblx0Y29uc3RydWN0b3IobmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbikge1xuXHRcdGlmIChuYW1lID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcignVEhSRUUuS2V5ZnJhbWVUcmFjazogdHJhY2sgbmFtZSBpcyB1bmRlZmluZWQnKTtcblx0XHRpZiAodGltZXMgPT09IHVuZGVmaW5lZCB8fCB0aW1lcy5sZW5ndGggPT09IDApIHRocm93IG5ldyBFcnJvcignVEhSRUUuS2V5ZnJhbWVUcmFjazogbm8ga2V5ZnJhbWVzIGluIHRyYWNrIG5hbWVkICcgKyBuYW1lKTtcblx0XHR0aGlzLm5hbWUgPSBuYW1lO1xuXHRcdHRoaXMudGltZXMgPSBjb252ZXJ0QXJyYXkodGltZXMsIHRoaXMuVGltZUJ1ZmZlclR5cGUpO1xuXHRcdHRoaXMudmFsdWVzID0gY29udmVydEFycmF5KHZhbHVlcywgdGhpcy5WYWx1ZUJ1ZmZlclR5cGUpO1xuXHRcdHRoaXMuc2V0SW50ZXJwb2xhdGlvbihpbnRlcnBvbGF0aW9uIHx8IHRoaXMuRGVmYXVsdEludGVycG9sYXRpb24pO1xuXHR9XG5cblx0Ly8gU2VyaWFsaXphdGlvbiAoaW4gc3RhdGljIGNvbnRleHQsIGJlY2F1c2Ugb2YgY29uc3RydWN0b3IgaW52b2NhdGlvblxuXHQvLyBhbmQgYXV0b21hdGljIGludm9jYXRpb24gb2YgLnRvSlNPTik6XG5cblx0c3RhdGljIHRvSlNPTih0cmFjaykge1xuXHRcdGNvbnN0IHRyYWNrVHlwZSA9IHRyYWNrLmNvbnN0cnVjdG9yO1xuXHRcdGxldCBqc29uO1xuXG5cdFx0Ly8gZGVyaXZlZCBjbGFzc2VzIGNhbiBkZWZpbmUgYSBzdGF0aWMgdG9KU09OIG1ldGhvZFxuXHRcdGlmICh0cmFja1R5cGUudG9KU09OICE9PSB0aGlzLnRvSlNPTikge1xuXHRcdFx0anNvbiA9IHRyYWNrVHlwZS50b0pTT04odHJhY2spO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBieSBkZWZhdWx0LCB3ZSBhc3N1bWUgdGhlIGRhdGEgY2FuIGJlIHNlcmlhbGl6ZWQgYXMtaXNcblx0XHRcdGpzb24gPSB7XG5cdFx0XHRcdCduYW1lJzogdHJhY2submFtZSxcblx0XHRcdFx0J3RpbWVzJzogY29udmVydEFycmF5KHRyYWNrLnRpbWVzLCBBcnJheSksXG5cdFx0XHRcdCd2YWx1ZXMnOiBjb252ZXJ0QXJyYXkodHJhY2sudmFsdWVzLCBBcnJheSlcblx0XHRcdH07XG5cdFx0XHRjb25zdCBpbnRlcnBvbGF0aW9uID0gdHJhY2suZ2V0SW50ZXJwb2xhdGlvbigpO1xuXHRcdFx0aWYgKGludGVycG9sYXRpb24gIT09IHRyYWNrLkRlZmF1bHRJbnRlcnBvbGF0aW9uKSB7XG5cdFx0XHRcdGpzb24uaW50ZXJwb2xhdGlvbiA9IGludGVycG9sYXRpb247XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGpzb24udHlwZSA9IHRyYWNrLlZhbHVlVHlwZU5hbWU7IC8vIG1hbmRhdG9yeVxuXG5cdFx0cmV0dXJuIGpzb247XG5cdH1cblx0SW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kRGlzY3JldGUocmVzdWx0KSB7XG5cdFx0cmV0dXJuIG5ldyBEaXNjcmV0ZUludGVycG9sYW50KHRoaXMudGltZXMsIHRoaXMudmFsdWVzLCB0aGlzLmdldFZhbHVlU2l6ZSgpLCByZXN1bHQpO1xuXHR9XG5cdEludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcihyZXN1bHQpIHtcblx0XHRyZXR1cm4gbmV3IExpbmVhckludGVycG9sYW50KHRoaXMudGltZXMsIHRoaXMudmFsdWVzLCB0aGlzLmdldFZhbHVlU2l6ZSgpLCByZXN1bHQpO1xuXHR9XG5cdEludGVycG9sYW50RmFjdG9yeU1ldGhvZFNtb290aChyZXN1bHQpIHtcblx0XHRyZXR1cm4gbmV3IEN1YmljSW50ZXJwb2xhbnQodGhpcy50aW1lcywgdGhpcy52YWx1ZXMsIHRoaXMuZ2V0VmFsdWVTaXplKCksIHJlc3VsdCk7XG5cdH1cblx0c2V0SW50ZXJwb2xhdGlvbihpbnRlcnBvbGF0aW9uKSB7XG5cdFx0bGV0IGZhY3RvcnlNZXRob2Q7XG5cdFx0c3dpdGNoIChpbnRlcnBvbGF0aW9uKSB7XG5cdFx0XHRjYXNlIEludGVycG9sYXRlRGlzY3JldGU6XG5cdFx0XHRcdGZhY3RvcnlNZXRob2QgPSB0aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZERpc2NyZXRlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgSW50ZXJwb2xhdGVMaW5lYXI6XG5cdFx0XHRcdGZhY3RvcnlNZXRob2QgPSB0aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIEludGVycG9sYXRlU21vb3RoOlxuXHRcdFx0XHRmYWN0b3J5TWV0aG9kID0gdGhpcy5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGg7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHRpZiAoZmFjdG9yeU1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjb25zdCBtZXNzYWdlID0gJ3Vuc3VwcG9ydGVkIGludGVycG9sYXRpb24gZm9yICcgKyB0aGlzLlZhbHVlVHlwZU5hbWUgKyAnIGtleWZyYW1lIHRyYWNrIG5hbWVkICcgKyB0aGlzLm5hbWU7XG5cdFx0XHRpZiAodGhpcy5jcmVhdGVJbnRlcnBvbGFudCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdC8vIGZhbGwgYmFjayB0byBkZWZhdWx0LCB1bmxlc3MgdGhlIGRlZmF1bHQgaXRzZWxmIGlzIG1lc3NlZCB1cFxuXHRcdFx0XHRpZiAoaW50ZXJwb2xhdGlvbiAhPT0gdGhpcy5EZWZhdWx0SW50ZXJwb2xhdGlvbikge1xuXHRcdFx0XHRcdHRoaXMuc2V0SW50ZXJwb2xhdGlvbih0aGlzLkRlZmF1bHRJbnRlcnBvbGF0aW9uKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7IC8vIGZhdGFsLCBpbiB0aGlzIGNhc2Vcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLktleWZyYW1lVHJhY2s6JywgbWVzc2FnZSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0dGhpcy5jcmVhdGVJbnRlcnBvbGFudCA9IGZhY3RvcnlNZXRob2Q7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0Z2V0SW50ZXJwb2xhdGlvbigpIHtcblx0XHRzd2l0Y2ggKHRoaXMuY3JlYXRlSW50ZXJwb2xhbnQpIHtcblx0XHRcdGNhc2UgdGhpcy5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2REaXNjcmV0ZTpcblx0XHRcdFx0cmV0dXJuIEludGVycG9sYXRlRGlzY3JldGU7XG5cdFx0XHRjYXNlIHRoaXMuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kTGluZWFyOlxuXHRcdFx0XHRyZXR1cm4gSW50ZXJwb2xhdGVMaW5lYXI7XG5cdFx0XHRjYXNlIHRoaXMuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kU21vb3RoOlxuXHRcdFx0XHRyZXR1cm4gSW50ZXJwb2xhdGVTbW9vdGg7XG5cdFx0fVxuXHR9XG5cdGdldFZhbHVlU2l6ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy52YWx1ZXMubGVuZ3RoIC8gdGhpcy50aW1lcy5sZW5ndGg7XG5cdH1cblxuXHQvLyBtb3ZlIGFsbCBrZXlmcmFtZXMgZWl0aGVyIGZvcndhcmRzIG9yIGJhY2t3YXJkcyBpbiB0aW1lXG5cdHNoaWZ0KHRpbWVPZmZzZXQpIHtcblx0XHRpZiAodGltZU9mZnNldCAhPT0gMC4wKSB7XG5cdFx0XHRjb25zdCB0aW1lcyA9IHRoaXMudGltZXM7XG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbiA9IHRpbWVzLmxlbmd0aDsgaSAhPT0gbjsgKytpKSB7XG5cdFx0XHRcdHRpbWVzW2ldICs9IHRpbWVPZmZzZXQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0Ly8gc2NhbGUgYWxsIGtleWZyYW1lIHRpbWVzIGJ5IGEgZmFjdG9yICh1c2VmdWwgZm9yIGZyYW1lIDwtPiBzZWNvbmRzIGNvbnZlcnNpb25zKVxuXHRzY2FsZSh0aW1lU2NhbGUpIHtcblx0XHRpZiAodGltZVNjYWxlICE9PSAxLjApIHtcblx0XHRcdGNvbnN0IHRpbWVzID0gdGhpcy50aW1lcztcblx0XHRcdGZvciAobGV0IGkgPSAwLCBuID0gdGltZXMubGVuZ3RoOyBpICE9PSBuOyArK2kpIHtcblx0XHRcdFx0dGltZXNbaV0gKj0gdGltZVNjYWxlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8vIHJlbW92ZXMga2V5ZnJhbWVzIGJlZm9yZSBhbmQgYWZ0ZXIgYW5pbWF0aW9uIHdpdGhvdXQgY2hhbmdpbmcgYW55IHZhbHVlcyB3aXRoaW4gdGhlIHJhbmdlIFtzdGFydFRpbWUsIGVuZFRpbWVdLlxuXHQvLyBJTVBPUlRBTlQ6IFdlIGRvIG5vdCBzaGlmdCBhcm91bmQga2V5cyB0byB0aGUgc3RhcnQgb2YgdGhlIHRyYWNrIHRpbWUsIGJlY2F1c2UgZm9yIGludGVycG9sYXRlZCBrZXlzIHRoaXMgd2lsbCBjaGFuZ2UgdGhlaXIgdmFsdWVzXG5cdHRyaW0oc3RhcnRUaW1lLCBlbmRUaW1lKSB7XG5cdFx0Y29uc3QgdGltZXMgPSB0aGlzLnRpbWVzLFxuXHRcdFx0bktleXMgPSB0aW1lcy5sZW5ndGg7XG5cdFx0bGV0IGZyb20gPSAwLFxuXHRcdFx0dG8gPSBuS2V5cyAtIDE7XG5cdFx0d2hpbGUgKGZyb20gIT09IG5LZXlzICYmIHRpbWVzW2Zyb21dIDwgc3RhcnRUaW1lKSB7XG5cdFx0XHQrK2Zyb207XG5cdFx0fVxuXHRcdHdoaWxlICh0byAhPT0gLTEgJiYgdGltZXNbdG9dID4gZW5kVGltZSkge1xuXHRcdFx0LS10bztcblx0XHR9XG5cdFx0Kyt0bzsgLy8gaW5jbHVzaXZlIC0+IGV4Y2x1c2l2ZSBib3VuZFxuXG5cdFx0aWYgKGZyb20gIT09IDAgfHwgdG8gIT09IG5LZXlzKSB7XG5cdFx0XHQvLyBlbXB0eSB0cmFja3MgYXJlIGZvcmJpZGRlbiwgc28ga2VlcCBhdCBsZWFzdCBvbmUga2V5ZnJhbWVcblx0XHRcdGlmIChmcm9tID49IHRvKSB7XG5cdFx0XHRcdHRvID0gTWF0aC5tYXgodG8sIDEpO1xuXHRcdFx0XHRmcm9tID0gdG8gLSAxO1xuXHRcdFx0fVxuXHRcdFx0Y29uc3Qgc3RyaWRlID0gdGhpcy5nZXRWYWx1ZVNpemUoKTtcblx0XHRcdHRoaXMudGltZXMgPSBhcnJheVNsaWNlKHRpbWVzLCBmcm9tLCB0byk7XG5cdFx0XHR0aGlzLnZhbHVlcyA9IGFycmF5U2xpY2UodGhpcy52YWx1ZXMsIGZyb20gKiBzdHJpZGUsIHRvICogc3RyaWRlKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvLyBlbnN1cmUgd2UgZG8gbm90IGdldCBhIEdhcmJhZ2VJbkdhcmJhZ2VPdXQgc2l0dWF0aW9uLCBtYWtlIHN1cmUgdHJhY2tzIGFyZSBhdCBsZWFzdCBtaW5pbWFsbHkgdmlhYmxlXG5cdHZhbGlkYXRlKCkge1xuXHRcdGxldCB2YWxpZCA9IHRydWU7XG5cdFx0Y29uc3QgdmFsdWVTaXplID0gdGhpcy5nZXRWYWx1ZVNpemUoKTtcblx0XHRpZiAodmFsdWVTaXplIC0gTWF0aC5mbG9vcih2YWx1ZVNpemUpICE9PSAwKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5LZXlmcmFtZVRyYWNrOiBJbnZhbGlkIHZhbHVlIHNpemUgaW4gdHJhY2suJywgdGhpcyk7XG5cdFx0XHR2YWxpZCA9IGZhbHNlO1xuXHRcdH1cblx0XHRjb25zdCB0aW1lcyA9IHRoaXMudGltZXMsXG5cdFx0XHR2YWx1ZXMgPSB0aGlzLnZhbHVlcyxcblx0XHRcdG5LZXlzID0gdGltZXMubGVuZ3RoO1xuXHRcdGlmIChuS2V5cyA9PT0gMCkge1xuXHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuS2V5ZnJhbWVUcmFjazogVHJhY2sgaXMgZW1wdHkuJywgdGhpcyk7XG5cdFx0XHR2YWxpZCA9IGZhbHNlO1xuXHRcdH1cblx0XHRsZXQgcHJldlRpbWUgPSBudWxsO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpICE9PSBuS2V5czsgaSsrKSB7XG5cdFx0XHRjb25zdCBjdXJyVGltZSA9IHRpbWVzW2ldO1xuXHRcdFx0aWYgKHR5cGVvZiBjdXJyVGltZSA9PT0gJ251bWJlcicgJiYgaXNOYU4oY3VyclRpbWUpKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLktleWZyYW1lVHJhY2s6IFRpbWUgaXMgbm90IGEgdmFsaWQgbnVtYmVyLicsIHRoaXMsIGksIGN1cnJUaW1lKTtcblx0XHRcdFx0dmFsaWQgPSBmYWxzZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAocHJldlRpbWUgIT09IG51bGwgJiYgcHJldlRpbWUgPiBjdXJyVGltZSkge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5LZXlmcmFtZVRyYWNrOiBPdXQgb2Ygb3JkZXIga2V5cy4nLCB0aGlzLCBpLCBjdXJyVGltZSwgcHJldlRpbWUpO1xuXHRcdFx0XHR2YWxpZCA9IGZhbHNlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdHByZXZUaW1lID0gY3VyclRpbWU7XG5cdFx0fVxuXHRcdGlmICh2YWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aWYgKGlzVHlwZWRBcnJheSh2YWx1ZXMpKSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCBuID0gdmFsdWVzLmxlbmd0aDsgaSAhPT0gbjsgKytpKSB7XG5cdFx0XHRcdFx0Y29uc3QgdmFsdWUgPSB2YWx1ZXNbaV07XG5cdFx0XHRcdFx0aWYgKGlzTmFOKHZhbHVlKSkge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuS2V5ZnJhbWVUcmFjazogVmFsdWUgaXMgbm90IGEgdmFsaWQgbnVtYmVyLicsIHRoaXMsIGksIHZhbHVlKTtcblx0XHRcdFx0XHRcdHZhbGlkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHZhbGlkO1xuXHR9XG5cblx0Ly8gcmVtb3ZlcyBlcXVpdmFsZW50IHNlcXVlbnRpYWwga2V5cyBhcyBjb21tb24gaW4gbW9ycGggdGFyZ2V0IHNlcXVlbmNlc1xuXHQvLyAoMCwwLDAsMCwxLDEsMSwwLDAsMCwwLDAsMCwwKSAtLT4gKDAsMCwxLDEsMCwwKVxuXHRvcHRpbWl6ZSgpIHtcblx0XHQvLyB0aW1lcyBvciB2YWx1ZXMgbWF5IGJlIHNoYXJlZCB3aXRoIG90aGVyIHRyYWNrcywgc28gb3ZlcndyaXRpbmcgaXMgdW5zYWZlXG5cdFx0Y29uc3QgdGltZXMgPSBhcnJheVNsaWNlKHRoaXMudGltZXMpLFxuXHRcdFx0dmFsdWVzID0gYXJyYXlTbGljZSh0aGlzLnZhbHVlcyksXG5cdFx0XHRzdHJpZGUgPSB0aGlzLmdldFZhbHVlU2l6ZSgpLFxuXHRcdFx0c21vb3RoSW50ZXJwb2xhdGlvbiA9IHRoaXMuZ2V0SW50ZXJwb2xhdGlvbigpID09PSBJbnRlcnBvbGF0ZVNtb290aCxcblx0XHRcdGxhc3RJbmRleCA9IHRpbWVzLmxlbmd0aCAtIDE7XG5cdFx0bGV0IHdyaXRlSW5kZXggPSAxO1xuXHRcdGZvciAobGV0IGkgPSAxOyBpIDwgbGFzdEluZGV4OyArK2kpIHtcblx0XHRcdGxldCBrZWVwID0gZmFsc2U7XG5cdFx0XHRjb25zdCB0aW1lID0gdGltZXNbaV07XG5cdFx0XHRjb25zdCB0aW1lTmV4dCA9IHRpbWVzW2kgKyAxXTtcblxuXHRcdFx0Ly8gcmVtb3ZlIGFkamFjZW50IGtleWZyYW1lcyBzY2hlZHVsZWQgYXQgdGhlIHNhbWUgdGltZVxuXG5cdFx0XHRpZiAodGltZSAhPT0gdGltZU5leHQgJiYgKGkgIT09IDEgfHwgdGltZSAhPT0gdGltZXNbMF0pKSB7XG5cdFx0XHRcdGlmICghc21vb3RoSW50ZXJwb2xhdGlvbikge1xuXHRcdFx0XHRcdC8vIHJlbW92ZSB1bm5lY2Vzc2FyeSBrZXlmcmFtZXMgc2FtZSBhcyB0aGVpciBuZWlnaGJvcnNcblxuXHRcdFx0XHRcdGNvbnN0IG9mZnNldCA9IGkgKiBzdHJpZGUsXG5cdFx0XHRcdFx0XHRvZmZzZXRQID0gb2Zmc2V0IC0gc3RyaWRlLFxuXHRcdFx0XHRcdFx0b2Zmc2V0TiA9IG9mZnNldCArIHN0cmlkZTtcblx0XHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiAhPT0gc3RyaWRlOyArK2opIHtcblx0XHRcdFx0XHRcdGNvbnN0IHZhbHVlID0gdmFsdWVzW29mZnNldCArIGpdO1xuXHRcdFx0XHRcdFx0aWYgKHZhbHVlICE9PSB2YWx1ZXNbb2Zmc2V0UCArIGpdIHx8IHZhbHVlICE9PSB2YWx1ZXNbb2Zmc2V0TiArIGpdKSB7XG5cdFx0XHRcdFx0XHRcdGtlZXAgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0a2VlcCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gaW4tcGxhY2UgY29tcGFjdGlvblxuXG5cdFx0XHRpZiAoa2VlcCkge1xuXHRcdFx0XHRpZiAoaSAhPT0gd3JpdGVJbmRleCkge1xuXHRcdFx0XHRcdHRpbWVzW3dyaXRlSW5kZXhdID0gdGltZXNbaV07XG5cdFx0XHRcdFx0Y29uc3QgcmVhZE9mZnNldCA9IGkgKiBzdHJpZGUsXG5cdFx0XHRcdFx0XHR3cml0ZU9mZnNldCA9IHdyaXRlSW5kZXggKiBzdHJpZGU7XG5cdFx0XHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogIT09IHN0cmlkZTsgKytqKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZXNbd3JpdGVPZmZzZXQgKyBqXSA9IHZhbHVlc1tyZWFkT2Zmc2V0ICsgal07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdCsrd3JpdGVJbmRleDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBmbHVzaCBsYXN0IGtleWZyYW1lIChjb21wYWN0aW9uIGxvb2tzIGFoZWFkKVxuXG5cdFx0aWYgKGxhc3RJbmRleCA+IDApIHtcblx0XHRcdHRpbWVzW3dyaXRlSW5kZXhdID0gdGltZXNbbGFzdEluZGV4XTtcblx0XHRcdGZvciAobGV0IHJlYWRPZmZzZXQgPSBsYXN0SW5kZXggKiBzdHJpZGUsIHdyaXRlT2Zmc2V0ID0gd3JpdGVJbmRleCAqIHN0cmlkZSwgaiA9IDA7IGogIT09IHN0cmlkZTsgKytqKSB7XG5cdFx0XHRcdHZhbHVlc1t3cml0ZU9mZnNldCArIGpdID0gdmFsdWVzW3JlYWRPZmZzZXQgKyBqXTtcblx0XHRcdH1cblx0XHRcdCsrd3JpdGVJbmRleDtcblx0XHR9XG5cdFx0aWYgKHdyaXRlSW5kZXggIT09IHRpbWVzLmxlbmd0aCkge1xuXHRcdFx0dGhpcy50aW1lcyA9IGFycmF5U2xpY2UodGltZXMsIDAsIHdyaXRlSW5kZXgpO1xuXHRcdFx0dGhpcy52YWx1ZXMgPSBhcnJheVNsaWNlKHZhbHVlcywgMCwgd3JpdGVJbmRleCAqIHN0cmlkZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMudGltZXMgPSB0aW1lcztcblx0XHRcdHRoaXMudmFsdWVzID0gdmFsdWVzO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRjbG9uZSgpIHtcblx0XHRjb25zdCB0aW1lcyA9IGFycmF5U2xpY2UodGhpcy50aW1lcywgMCk7XG5cdFx0Y29uc3QgdmFsdWVzID0gYXJyYXlTbGljZSh0aGlzLnZhbHVlcywgMCk7XG5cdFx0Y29uc3QgVHlwZWRLZXlmcmFtZVRyYWNrID0gdGhpcy5jb25zdHJ1Y3Rvcjtcblx0XHRjb25zdCB0cmFjayA9IG5ldyBUeXBlZEtleWZyYW1lVHJhY2sodGhpcy5uYW1lLCB0aW1lcywgdmFsdWVzKTtcblxuXHRcdC8vIEludGVycG9sYW50IGFyZ3VtZW50IHRvIGNvbnN0cnVjdG9yIGlzIG5vdCBzYXZlZCwgc28gY29weSB0aGUgZmFjdG9yeSBtZXRob2QgZGlyZWN0bHkuXG5cdFx0dHJhY2suY3JlYXRlSW50ZXJwb2xhbnQgPSB0aGlzLmNyZWF0ZUludGVycG9sYW50O1xuXHRcdHJldHVybiB0cmFjaztcblx0fVxufVxuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuVGltZUJ1ZmZlclR5cGUgPSBGbG9hdDMyQXJyYXk7XG5LZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5WYWx1ZUJ1ZmZlclR5cGUgPSBGbG9hdDMyQXJyYXk7XG5LZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5EZWZhdWx0SW50ZXJwb2xhdGlvbiA9IEludGVycG9sYXRlTGluZWFyO1xuXG4vKipcbiAqIEEgVHJhY2sgb2YgQm9vbGVhbiBrZXlmcmFtZSB2YWx1ZXMuXG4gKi9cbmNsYXNzIEJvb2xlYW5LZXlmcmFtZVRyYWNrIGV4dGVuZHMgS2V5ZnJhbWVUcmFjayB7fVxuQm9vbGVhbktleWZyYW1lVHJhY2sucHJvdG90eXBlLlZhbHVlVHlwZU5hbWUgPSAnYm9vbCc7XG5Cb29sZWFuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuVmFsdWVCdWZmZXJUeXBlID0gQXJyYXk7XG5Cb29sZWFuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuRGVmYXVsdEludGVycG9sYXRpb24gPSBJbnRlcnBvbGF0ZURpc2NyZXRlO1xuQm9vbGVhbktleWZyYW1lVHJhY2sucHJvdG90eXBlLkludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhciA9IHVuZGVmaW5lZDtcbkJvb2xlYW5LZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGggPSB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBUcmFjayBvZiBrZXlmcmFtZSB2YWx1ZXMgdGhhdCByZXByZXNlbnQgY29sb3IuXG4gKi9cbmNsYXNzIENvbG9yS2V5ZnJhbWVUcmFjayBleHRlbmRzIEtleWZyYW1lVHJhY2sge31cbkNvbG9yS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuVmFsdWVUeXBlTmFtZSA9ICdjb2xvcic7XG5cbi8qKlxuICogQSBUcmFjayBvZiBudW1lcmljIGtleWZyYW1lIHZhbHVlcy5cbiAqL1xuY2xhc3MgTnVtYmVyS2V5ZnJhbWVUcmFjayBleHRlbmRzIEtleWZyYW1lVHJhY2sge31cbk51bWJlcktleWZyYW1lVHJhY2sucHJvdG90eXBlLlZhbHVlVHlwZU5hbWUgPSAnbnVtYmVyJztcblxuLyoqXG4gKiBTcGhlcmljYWwgbGluZWFyIHVuaXQgcXVhdGVybmlvbiBpbnRlcnBvbGFudC5cbiAqL1xuXG5jbGFzcyBRdWF0ZXJuaW9uTGluZWFySW50ZXJwb2xhbnQgZXh0ZW5kcyBJbnRlcnBvbGFudCB7XG5cdGNvbnN0cnVjdG9yKHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIpIHtcblx0XHRzdXBlcihwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyKTtcblx0fVxuXHRpbnRlcnBvbGF0ZV8oaTEsIHQwLCB0LCB0MSkge1xuXHRcdGNvbnN0IHJlc3VsdCA9IHRoaXMucmVzdWx0QnVmZmVyLFxuXHRcdFx0dmFsdWVzID0gdGhpcy5zYW1wbGVWYWx1ZXMsXG5cdFx0XHRzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZSxcblx0XHRcdGFscGhhID0gKHQgLSB0MCkgLyAodDEgLSB0MCk7XG5cdFx0bGV0IG9mZnNldCA9IGkxICogc3RyaWRlO1xuXHRcdGZvciAobGV0IGVuZCA9IG9mZnNldCArIHN0cmlkZTsgb2Zmc2V0ICE9PSBlbmQ7IG9mZnNldCArPSA0KSB7XG5cdFx0XHRRdWF0ZXJuaW9uLnNsZXJwRmxhdChyZXN1bHQsIDAsIHZhbHVlcywgb2Zmc2V0IC0gc3RyaWRlLCB2YWx1ZXMsIG9mZnNldCwgYWxwaGEpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG59XG5cbi8qKlxuICogQSBUcmFjayBvZiBxdWF0ZXJuaW9uIGtleWZyYW1lIHZhbHVlcy5cbiAqL1xuY2xhc3MgUXVhdGVybmlvbktleWZyYW1lVHJhY2sgZXh0ZW5kcyBLZXlmcmFtZVRyYWNrIHtcblx0SW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kTGluZWFyKHJlc3VsdCkge1xuXHRcdHJldHVybiBuZXcgUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50KHRoaXMudGltZXMsIHRoaXMudmFsdWVzLCB0aGlzLmdldFZhbHVlU2l6ZSgpLCByZXN1bHQpO1xuXHR9XG59XG5RdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuVmFsdWVUeXBlTmFtZSA9ICdxdWF0ZXJuaW9uJztcbi8vIFZhbHVlQnVmZmVyVHlwZSBpcyBpbmhlcml0ZWRcblF1YXRlcm5pb25LZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5EZWZhdWx0SW50ZXJwb2xhdGlvbiA9IEludGVycG9sYXRlTGluZWFyO1xuUXVhdGVybmlvbktleWZyYW1lVHJhY2sucHJvdG90eXBlLkludGVycG9sYW50RmFjdG9yeU1ldGhvZFNtb290aCA9IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIFRyYWNrIHRoYXQgaW50ZXJwb2xhdGVzIFN0cmluZ3NcbiAqL1xuY2xhc3MgU3RyaW5nS2V5ZnJhbWVUcmFjayBleHRlbmRzIEtleWZyYW1lVHJhY2sge31cblN0cmluZ0tleWZyYW1lVHJhY2sucHJvdG90eXBlLlZhbHVlVHlwZU5hbWUgPSAnc3RyaW5nJztcblN0cmluZ0tleWZyYW1lVHJhY2sucHJvdG90eXBlLlZhbHVlQnVmZmVyVHlwZSA9IEFycmF5O1xuU3RyaW5nS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuRGVmYXVsdEludGVycG9sYXRpb24gPSBJbnRlcnBvbGF0ZURpc2NyZXRlO1xuU3RyaW5nS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kTGluZWFyID0gdW5kZWZpbmVkO1xuU3RyaW5nS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kU21vb3RoID0gdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgVHJhY2sgb2YgdmVjdG9yZWQga2V5ZnJhbWUgdmFsdWVzLlxuICovXG5jbGFzcyBWZWN0b3JLZXlmcmFtZVRyYWNrIGV4dGVuZHMgS2V5ZnJhbWVUcmFjayB7fVxuVmVjdG9yS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuVmFsdWVUeXBlTmFtZSA9ICd2ZWN0b3InO1xuXG5jbGFzcyBBbmltYXRpb25DbGlwIHtcblx0Y29uc3RydWN0b3IobmFtZSwgZHVyYXRpb24gPSAtMSwgdHJhY2tzLCBibGVuZE1vZGUgPSBOb3JtYWxBbmltYXRpb25CbGVuZE1vZGUpIHtcblx0XHR0aGlzLm5hbWUgPSBuYW1lO1xuXHRcdHRoaXMudHJhY2tzID0gdHJhY2tzO1xuXHRcdHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcblx0XHR0aGlzLmJsZW5kTW9kZSA9IGJsZW5kTW9kZTtcblx0XHR0aGlzLnV1aWQgPSBnZW5lcmF0ZVVVSUQoKTtcblxuXHRcdC8vIHRoaXMgbWVhbnMgaXQgc2hvdWxkIGZpZ3VyZSBvdXQgaXRzIGR1cmF0aW9uIGJ5IHNjYW5uaW5nIHRoZSB0cmFja3Ncblx0XHRpZiAodGhpcy5kdXJhdGlvbiA8IDApIHtcblx0XHRcdHRoaXMucmVzZXREdXJhdGlvbigpO1xuXHRcdH1cblx0fVxuXHRzdGF0aWMgcGFyc2UoanNvbikge1xuXHRcdGNvbnN0IHRyYWNrcyA9IFtdLFxuXHRcdFx0anNvblRyYWNrcyA9IGpzb24udHJhY2tzLFxuXHRcdFx0ZnJhbWVUaW1lID0gMS4wIC8gKGpzb24uZnBzIHx8IDEuMCk7XG5cdFx0Zm9yIChsZXQgaSA9IDAsIG4gPSBqc29uVHJhY2tzLmxlbmd0aDsgaSAhPT0gbjsgKytpKSB7XG5cdFx0XHR0cmFja3MucHVzaChwYXJzZUtleWZyYW1lVHJhY2soanNvblRyYWNrc1tpXSkuc2NhbGUoZnJhbWVUaW1lKSk7XG5cdFx0fVxuXHRcdGNvbnN0IGNsaXAgPSBuZXcgdGhpcyhqc29uLm5hbWUsIGpzb24uZHVyYXRpb24sIHRyYWNrcywganNvbi5ibGVuZE1vZGUpO1xuXHRcdGNsaXAudXVpZCA9IGpzb24udXVpZDtcblx0XHRyZXR1cm4gY2xpcDtcblx0fVxuXHRzdGF0aWMgdG9KU09OKGNsaXApIHtcblx0XHRjb25zdCB0cmFja3MgPSBbXSxcblx0XHRcdGNsaXBUcmFja3MgPSBjbGlwLnRyYWNrcztcblx0XHRjb25zdCBqc29uID0ge1xuXHRcdFx0J25hbWUnOiBjbGlwLm5hbWUsXG5cdFx0XHQnZHVyYXRpb24nOiBjbGlwLmR1cmF0aW9uLFxuXHRcdFx0J3RyYWNrcyc6IHRyYWNrcyxcblx0XHRcdCd1dWlkJzogY2xpcC51dWlkLFxuXHRcdFx0J2JsZW5kTW9kZSc6IGNsaXAuYmxlbmRNb2RlXG5cdFx0fTtcblx0XHRmb3IgKGxldCBpID0gMCwgbiA9IGNsaXBUcmFja3MubGVuZ3RoOyBpICE9PSBuOyArK2kpIHtcblx0XHRcdHRyYWNrcy5wdXNoKEtleWZyYW1lVHJhY2sudG9KU09OKGNsaXBUcmFja3NbaV0pKTtcblx0XHR9XG5cdFx0cmV0dXJuIGpzb247XG5cdH1cblx0c3RhdGljIENyZWF0ZUZyb21Nb3JwaFRhcmdldFNlcXVlbmNlKG5hbWUsIG1vcnBoVGFyZ2V0U2VxdWVuY2UsIGZwcywgbm9Mb29wKSB7XG5cdFx0Y29uc3QgbnVtTW9ycGhUYXJnZXRzID0gbW9ycGhUYXJnZXRTZXF1ZW5jZS5sZW5ndGg7XG5cdFx0Y29uc3QgdHJhY2tzID0gW107XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBudW1Nb3JwaFRhcmdldHM7IGkrKykge1xuXHRcdFx0bGV0IHRpbWVzID0gW107XG5cdFx0XHRsZXQgdmFsdWVzID0gW107XG5cdFx0XHR0aW1lcy5wdXNoKChpICsgbnVtTW9ycGhUYXJnZXRzIC0gMSkgJSBudW1Nb3JwaFRhcmdldHMsIGksIChpICsgMSkgJSBudW1Nb3JwaFRhcmdldHMpO1xuXHRcdFx0dmFsdWVzLnB1c2goMCwgMSwgMCk7XG5cdFx0XHRjb25zdCBvcmRlciA9IGdldEtleWZyYW1lT3JkZXIodGltZXMpO1xuXHRcdFx0dGltZXMgPSBzb3J0ZWRBcnJheSh0aW1lcywgMSwgb3JkZXIpO1xuXHRcdFx0dmFsdWVzID0gc29ydGVkQXJyYXkodmFsdWVzLCAxLCBvcmRlcik7XG5cblx0XHRcdC8vIGlmIHRoZXJlIGlzIGEga2V5IGF0IHRoZSBmaXJzdCBmcmFtZSwgZHVwbGljYXRlIGl0IGFzIHRoZVxuXHRcdFx0Ly8gbGFzdCBmcmFtZSBhcyB3ZWxsIGZvciBwZXJmZWN0IGxvb3AuXG5cdFx0XHRpZiAoIW5vTG9vcCAmJiB0aW1lc1swXSA9PT0gMCkge1xuXHRcdFx0XHR0aW1lcy5wdXNoKG51bU1vcnBoVGFyZ2V0cyk7XG5cdFx0XHRcdHZhbHVlcy5wdXNoKHZhbHVlc1swXSk7XG5cdFx0XHR9XG5cdFx0XHR0cmFja3MucHVzaChuZXcgTnVtYmVyS2V5ZnJhbWVUcmFjaygnLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1snICsgbW9ycGhUYXJnZXRTZXF1ZW5jZVtpXS5uYW1lICsgJ10nLCB0aW1lcywgdmFsdWVzKS5zY2FsZSgxLjAgLyBmcHMpKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5ldyB0aGlzKG5hbWUsIC0xLCB0cmFja3MpO1xuXHR9XG5cdHN0YXRpYyBmaW5kQnlOYW1lKG9iamVjdE9yQ2xpcEFycmF5LCBuYW1lKSB7XG5cdFx0bGV0IGNsaXBBcnJheSA9IG9iamVjdE9yQ2xpcEFycmF5O1xuXHRcdGlmICghQXJyYXkuaXNBcnJheShvYmplY3RPckNsaXBBcnJheSkpIHtcblx0XHRcdGNvbnN0IG8gPSBvYmplY3RPckNsaXBBcnJheTtcblx0XHRcdGNsaXBBcnJheSA9IG8uZ2VvbWV0cnkgJiYgby5nZW9tZXRyeS5hbmltYXRpb25zIHx8IG8uYW5pbWF0aW9ucztcblx0XHR9XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjbGlwQXJyYXkubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChjbGlwQXJyYXlbaV0ubmFtZSA9PT0gbmFtZSkge1xuXHRcdFx0XHRyZXR1cm4gY2xpcEFycmF5W2ldO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHRzdGF0aWMgQ3JlYXRlQ2xpcHNGcm9tTW9ycGhUYXJnZXRTZXF1ZW5jZXMobW9ycGhUYXJnZXRzLCBmcHMsIG5vTG9vcCkge1xuXHRcdGNvbnN0IGFuaW1hdGlvblRvTW9ycGhUYXJnZXRzID0ge307XG5cblx0XHQvLyB0ZXN0ZWQgd2l0aCBodHRwczovL3JlZ2V4MTAxLmNvbS8gb24gdHJpY2sgc2VxdWVuY2VzXG5cdFx0Ly8gc3VjaCBmbGFtaW5nb19mbHlBXzAwMywgZmxhbWluZ29fcnVuMV8wMDMsIGNyZGVhdGgwMDU5XG5cdFx0Y29uc3QgcGF0dGVybiA9IC9eKFtcXHctXSo/KShbXFxkXSspJC87XG5cblx0XHQvLyBzb3J0IG1vcnBoIHRhcmdldCBuYW1lcyBpbnRvIGFuaW1hdGlvbiBncm91cHMgYmFzZWRcblx0XHQvLyBwYXR0ZXJucyBsaWtlIFdhbGtfMDAxLCBXYWxrXzAwMiwgUnVuXzAwMSwgUnVuXzAwMlxuXHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRjb25zdCBtb3JwaFRhcmdldCA9IG1vcnBoVGFyZ2V0c1tpXTtcblx0XHRcdGNvbnN0IHBhcnRzID0gbW9ycGhUYXJnZXQubmFtZS5tYXRjaChwYXR0ZXJuKTtcblx0XHRcdGlmIChwYXJ0cyAmJiBwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdGNvbnN0IG5hbWUgPSBwYXJ0c1sxXTtcblx0XHRcdFx0bGV0IGFuaW1hdGlvbk1vcnBoVGFyZ2V0cyA9IGFuaW1hdGlvblRvTW9ycGhUYXJnZXRzW25hbWVdO1xuXHRcdFx0XHRpZiAoIWFuaW1hdGlvbk1vcnBoVGFyZ2V0cykge1xuXHRcdFx0XHRcdGFuaW1hdGlvblRvTW9ycGhUYXJnZXRzW25hbWVdID0gYW5pbWF0aW9uTW9ycGhUYXJnZXRzID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0YW5pbWF0aW9uTW9ycGhUYXJnZXRzLnB1c2gobW9ycGhUYXJnZXQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRjb25zdCBjbGlwcyA9IFtdO1xuXHRcdGZvciAoY29uc3QgbmFtZSBpbiBhbmltYXRpb25Ub01vcnBoVGFyZ2V0cykge1xuXHRcdFx0Y2xpcHMucHVzaCh0aGlzLkNyZWF0ZUZyb21Nb3JwaFRhcmdldFNlcXVlbmNlKG5hbWUsIGFuaW1hdGlvblRvTW9ycGhUYXJnZXRzW25hbWVdLCBmcHMsIG5vTG9vcCkpO1xuXHRcdH1cblx0XHRyZXR1cm4gY2xpcHM7XG5cdH1cblxuXHQvLyBwYXJzZSB0aGUgYW5pbWF0aW9uLmhpZXJhcmNoeSBmb3JtYXRcblx0c3RhdGljIHBhcnNlQW5pbWF0aW9uKGFuaW1hdGlvbiwgYm9uZXMpIHtcblx0XHRpZiAoIWFuaW1hdGlvbikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuQW5pbWF0aW9uQ2xpcDogTm8gYW5pbWF0aW9uIGluIEpTT05Mb2FkZXIgZGF0YS4nKTtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHRjb25zdCBhZGROb25lbXB0eVRyYWNrID0gZnVuY3Rpb24gKHRyYWNrVHlwZSwgdHJhY2tOYW1lLCBhbmltYXRpb25LZXlzLCBwcm9wZXJ0eU5hbWUsIGRlc3RUcmFja3MpIHtcblx0XHRcdC8vIG9ubHkgcmV0dXJuIHRyYWNrIGlmIHRoZXJlIGFyZSBhY3R1YWxseSBrZXlzLlxuXHRcdFx0aWYgKGFuaW1hdGlvbktleXMubGVuZ3RoICE9PSAwKSB7XG5cdFx0XHRcdGNvbnN0IHRpbWVzID0gW107XG5cdFx0XHRcdGNvbnN0IHZhbHVlcyA9IFtdO1xuXHRcdFx0XHRmbGF0dGVuSlNPTihhbmltYXRpb25LZXlzLCB0aW1lcywgdmFsdWVzLCBwcm9wZXJ0eU5hbWUpO1xuXG5cdFx0XHRcdC8vIGVtcHR5IGtleXMgYXJlIGZpbHRlcmVkIG91dCwgc28gY2hlY2sgYWdhaW5cblx0XHRcdFx0aWYgKHRpbWVzLmxlbmd0aCAhPT0gMCkge1xuXHRcdFx0XHRcdGRlc3RUcmFja3MucHVzaChuZXcgdHJhY2tUeXBlKHRyYWNrTmFtZSwgdGltZXMsIHZhbHVlcykpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRjb25zdCB0cmFja3MgPSBbXTtcblx0XHRjb25zdCBjbGlwTmFtZSA9IGFuaW1hdGlvbi5uYW1lIHx8ICdkZWZhdWx0Jztcblx0XHRjb25zdCBmcHMgPSBhbmltYXRpb24uZnBzIHx8IDMwO1xuXHRcdGNvbnN0IGJsZW5kTW9kZSA9IGFuaW1hdGlvbi5ibGVuZE1vZGU7XG5cblx0XHQvLyBhdXRvbWF0aWMgbGVuZ3RoIGRldGVybWluYXRpb24gaW4gQW5pbWF0aW9uQ2xpcC5cblx0XHRsZXQgZHVyYXRpb24gPSBhbmltYXRpb24ubGVuZ3RoIHx8IC0xO1xuXHRcdGNvbnN0IGhpZXJhcmNoeVRyYWNrcyA9IGFuaW1hdGlvbi5oaWVyYXJjaHkgfHwgW107XG5cdFx0Zm9yIChsZXQgaCA9IDA7IGggPCBoaWVyYXJjaHlUcmFja3MubGVuZ3RoOyBoKyspIHtcblx0XHRcdGNvbnN0IGFuaW1hdGlvbktleXMgPSBoaWVyYXJjaHlUcmFja3NbaF0ua2V5cztcblxuXHRcdFx0Ly8gc2tpcCBlbXB0eSB0cmFja3Ncblx0XHRcdGlmICghYW5pbWF0aW9uS2V5cyB8fCBhbmltYXRpb25LZXlzLmxlbmd0aCA9PT0gMCkgY29udGludWU7XG5cblx0XHRcdC8vIHByb2Nlc3MgbW9ycGggdGFyZ2V0c1xuXHRcdFx0aWYgKGFuaW1hdGlvbktleXNbMF0ubW9ycGhUYXJnZXRzKSB7XG5cdFx0XHRcdC8vIGZpZ3VyZSBvdXQgYWxsIG1vcnBoIHRhcmdldHMgdXNlZCBpbiB0aGlzIHRyYWNrXG5cdFx0XHRcdGNvbnN0IG1vcnBoVGFyZ2V0TmFtZXMgPSB7fTtcblx0XHRcdFx0bGV0IGs7XG5cdFx0XHRcdGZvciAoayA9IDA7IGsgPCBhbmltYXRpb25LZXlzLmxlbmd0aDsgaysrKSB7XG5cdFx0XHRcdFx0aWYgKGFuaW1hdGlvbktleXNba10ubW9ycGhUYXJnZXRzKSB7XG5cdFx0XHRcdFx0XHRmb3IgKGxldCBtID0gMDsgbSA8IGFuaW1hdGlvbktleXNba10ubW9ycGhUYXJnZXRzLmxlbmd0aDsgbSsrKSB7XG5cdFx0XHRcdFx0XHRcdG1vcnBoVGFyZ2V0TmFtZXNbYW5pbWF0aW9uS2V5c1trXS5tb3JwaFRhcmdldHNbbV1dID0gLTE7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gY3JlYXRlIGEgdHJhY2sgZm9yIGVhY2ggbW9ycGggdGFyZ2V0IHdpdGggYWxsIHplcm9cblx0XHRcdFx0Ly8gbW9ycGhUYXJnZXRJbmZsdWVuY2VzIGV4Y2VwdCBmb3IgdGhlIGtleXMgaW4gd2hpY2hcblx0XHRcdFx0Ly8gdGhlIG1vcnBoVGFyZ2V0IGlzIG5hbWVkLlxuXHRcdFx0XHRmb3IgKGNvbnN0IG1vcnBoVGFyZ2V0TmFtZSBpbiBtb3JwaFRhcmdldE5hbWVzKSB7XG5cdFx0XHRcdFx0Y29uc3QgdGltZXMgPSBbXTtcblx0XHRcdFx0XHRjb25zdCB2YWx1ZXMgPSBbXTtcblx0XHRcdFx0XHRmb3IgKGxldCBtID0gMDsgbSAhPT0gYW5pbWF0aW9uS2V5c1trXS5tb3JwaFRhcmdldHMubGVuZ3RoOyArK20pIHtcblx0XHRcdFx0XHRcdGNvbnN0IGFuaW1hdGlvbktleSA9IGFuaW1hdGlvbktleXNba107XG5cdFx0XHRcdFx0XHR0aW1lcy5wdXNoKGFuaW1hdGlvbktleS50aW1lKTtcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKGFuaW1hdGlvbktleS5tb3JwaFRhcmdldCA9PT0gbW9ycGhUYXJnZXROYW1lID8gMSA6IDApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0cmFja3MucHVzaChuZXcgTnVtYmVyS2V5ZnJhbWVUcmFjaygnLm1vcnBoVGFyZ2V0SW5mbHVlbmNlWycgKyBtb3JwaFRhcmdldE5hbWUgKyAnXScsIHRpbWVzLCB2YWx1ZXMpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkdXJhdGlvbiA9IG1vcnBoVGFyZ2V0TmFtZXMubGVuZ3RoICogZnBzO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gLi4uYXNzdW1lIHNrZWxldGFsIGFuaW1hdGlvblxuXG5cdFx0XHRcdGNvbnN0IGJvbmVOYW1lID0gJy5ib25lc1snICsgYm9uZXNbaF0ubmFtZSArICddJztcblx0XHRcdFx0YWRkTm9uZW1wdHlUcmFjayhWZWN0b3JLZXlmcmFtZVRyYWNrLCBib25lTmFtZSArICcucG9zaXRpb24nLCBhbmltYXRpb25LZXlzLCAncG9zJywgdHJhY2tzKTtcblx0XHRcdFx0YWRkTm9uZW1wdHlUcmFjayhRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjaywgYm9uZU5hbWUgKyAnLnF1YXRlcm5pb24nLCBhbmltYXRpb25LZXlzLCAncm90JywgdHJhY2tzKTtcblx0XHRcdFx0YWRkTm9uZW1wdHlUcmFjayhWZWN0b3JLZXlmcmFtZVRyYWNrLCBib25lTmFtZSArICcuc2NhbGUnLCBhbmltYXRpb25LZXlzLCAnc2NsJywgdHJhY2tzKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHRyYWNrcy5sZW5ndGggPT09IDApIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHRjb25zdCBjbGlwID0gbmV3IHRoaXMoY2xpcE5hbWUsIGR1cmF0aW9uLCB0cmFja3MsIGJsZW5kTW9kZSk7XG5cdFx0cmV0dXJuIGNsaXA7XG5cdH1cblx0cmVzZXREdXJhdGlvbigpIHtcblx0XHRjb25zdCB0cmFja3MgPSB0aGlzLnRyYWNrcztcblx0XHRsZXQgZHVyYXRpb24gPSAwO1xuXHRcdGZvciAobGV0IGkgPSAwLCBuID0gdHJhY2tzLmxlbmd0aDsgaSAhPT0gbjsgKytpKSB7XG5cdFx0XHRjb25zdCB0cmFjayA9IHRoaXMudHJhY2tzW2ldO1xuXHRcdFx0ZHVyYXRpb24gPSBNYXRoLm1heChkdXJhdGlvbiwgdHJhY2sudGltZXNbdHJhY2sudGltZXMubGVuZ3RoIC0gMV0pO1xuXHRcdH1cblx0XHR0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0dHJpbSgpIHtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudHJhY2tzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0aGlzLnRyYWNrc1tpXS50cmltKDAsIHRoaXMuZHVyYXRpb24pO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHR2YWxpZGF0ZSgpIHtcblx0XHRsZXQgdmFsaWQgPSB0cnVlO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy50cmFja3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhbGlkID0gdmFsaWQgJiYgdGhpcy50cmFja3NbaV0udmFsaWRhdGUoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbGlkO1xuXHR9XG5cdG9wdGltaXplKCkge1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy50cmFja3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdHRoaXMudHJhY2tzW2ldLm9wdGltaXplKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGNsb25lKCkge1xuXHRcdGNvbnN0IHRyYWNrcyA9IFtdO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy50cmFja3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdHRyYWNrcy5wdXNoKHRoaXMudHJhY2tzW2ldLmNsb25lKCkpO1xuXHRcdH1cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5uYW1lLCB0aGlzLmR1cmF0aW9uLCB0cmFja3MsIHRoaXMuYmxlbmRNb2RlKTtcblx0fVxuXHR0b0pTT04oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9KU09OKHRoaXMpO1xuXHR9XG59XG5mdW5jdGlvbiBnZXRUcmFja1R5cGVGb3JWYWx1ZVR5cGVOYW1lKHR5cGVOYW1lKSB7XG5cdHN3aXRjaCAodHlwZU5hbWUudG9Mb3dlckNhc2UoKSkge1xuXHRcdGNhc2UgJ3NjYWxhcic6XG5cdFx0Y2FzZSAnZG91YmxlJzpcblx0XHRjYXNlICdmbG9hdCc6XG5cdFx0Y2FzZSAnbnVtYmVyJzpcblx0XHRjYXNlICdpbnRlZ2VyJzpcblx0XHRcdHJldHVybiBOdW1iZXJLZXlmcmFtZVRyYWNrO1xuXHRcdGNhc2UgJ3ZlY3Rvcic6XG5cdFx0Y2FzZSAndmVjdG9yMic6XG5cdFx0Y2FzZSAndmVjdG9yMyc6XG5cdFx0Y2FzZSAndmVjdG9yNCc6XG5cdFx0XHRyZXR1cm4gVmVjdG9yS2V5ZnJhbWVUcmFjaztcblx0XHRjYXNlICdjb2xvcic6XG5cdFx0XHRyZXR1cm4gQ29sb3JLZXlmcmFtZVRyYWNrO1xuXHRcdGNhc2UgJ3F1YXRlcm5pb24nOlxuXHRcdFx0cmV0dXJuIFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrO1xuXHRcdGNhc2UgJ2Jvb2wnOlxuXHRcdGNhc2UgJ2Jvb2xlYW4nOlxuXHRcdFx0cmV0dXJuIEJvb2xlYW5LZXlmcmFtZVRyYWNrO1xuXHRcdGNhc2UgJ3N0cmluZyc6XG5cdFx0XHRyZXR1cm4gU3RyaW5nS2V5ZnJhbWVUcmFjaztcblx0fVxuXHR0aHJvdyBuZXcgRXJyb3IoJ1RIUkVFLktleWZyYW1lVHJhY2s6IFVuc3VwcG9ydGVkIHR5cGVOYW1lOiAnICsgdHlwZU5hbWUpO1xufVxuZnVuY3Rpb24gcGFyc2VLZXlmcmFtZVRyYWNrKGpzb24pIHtcblx0aWYgKGpzb24udHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdUSFJFRS5LZXlmcmFtZVRyYWNrOiB0cmFjayB0eXBlIHVuZGVmaW5lZCwgY2FuIG5vdCBwYXJzZScpO1xuXHR9XG5cdGNvbnN0IHRyYWNrVHlwZSA9IGdldFRyYWNrVHlwZUZvclZhbHVlVHlwZU5hbWUoanNvbi50eXBlKTtcblx0aWYgKGpzb24udGltZXMgPT09IHVuZGVmaW5lZCkge1xuXHRcdGNvbnN0IHRpbWVzID0gW10sXG5cdFx0XHR2YWx1ZXMgPSBbXTtcblx0XHRmbGF0dGVuSlNPTihqc29uLmtleXMsIHRpbWVzLCB2YWx1ZXMsICd2YWx1ZScpO1xuXHRcdGpzb24udGltZXMgPSB0aW1lcztcblx0XHRqc29uLnZhbHVlcyA9IHZhbHVlcztcblx0fVxuXG5cdC8vIGRlcml2ZWQgY2xhc3NlcyBjYW4gZGVmaW5lIGEgc3RhdGljIHBhcnNlIG1ldGhvZFxuXHRpZiAodHJhY2tUeXBlLnBhcnNlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gdHJhY2tUeXBlLnBhcnNlKGpzb24pO1xuXHR9IGVsc2Uge1xuXHRcdC8vIGJ5IGRlZmF1bHQsIHdlIGFzc3VtZSBhIGNvbnN0cnVjdG9yIGNvbXBhdGlibGUgd2l0aCB0aGUgYmFzZVxuXHRcdHJldHVybiBuZXcgdHJhY2tUeXBlKGpzb24ubmFtZSwganNvbi50aW1lcywganNvbi52YWx1ZXMsIGpzb24uaW50ZXJwb2xhdGlvbik7XG5cdH1cbn1cblxuY29uc3QgQ2FjaGUgPSB7XG5cdGVuYWJsZWQ6IGZhbHNlLFxuXHRmaWxlczoge30sXG5cdGFkZDogZnVuY3Rpb24gKGtleSwgZmlsZSkge1xuXHRcdGlmICh0aGlzLmVuYWJsZWQgPT09IGZhbHNlKSByZXR1cm47XG5cblx0XHQvLyBjb25zb2xlLmxvZyggJ1RIUkVFLkNhY2hlJywgJ0FkZGluZyBrZXk6Jywga2V5ICk7XG5cblx0XHR0aGlzLmZpbGVzW2tleV0gPSBmaWxlO1xuXHR9LFxuXHRnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHRpZiAodGhpcy5lbmFibGVkID09PSBmYWxzZSkgcmV0dXJuO1xuXG5cdFx0Ly8gY29uc29sZS5sb2coICdUSFJFRS5DYWNoZScsICdDaGVja2luZyBrZXk6Jywga2V5ICk7XG5cblx0XHRyZXR1cm4gdGhpcy5maWxlc1trZXldO1xuXHR9LFxuXHRyZW1vdmU6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHRkZWxldGUgdGhpcy5maWxlc1trZXldO1xuXHR9LFxuXHRjbGVhcjogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuZmlsZXMgPSB7fTtcblx0fVxufTtcblxuY2xhc3MgTG9hZGluZ01hbmFnZXIge1xuXHRjb25zdHJ1Y3RvcihvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpIHtcblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cdFx0bGV0IGlzTG9hZGluZyA9IGZhbHNlO1xuXHRcdGxldCBpdGVtc0xvYWRlZCA9IDA7XG5cdFx0bGV0IGl0ZW1zVG90YWwgPSAwO1xuXHRcdGxldCB1cmxNb2RpZmllciA9IHVuZGVmaW5lZDtcblx0XHRjb25zdCBoYW5kbGVycyA9IFtdO1xuXG5cdFx0Ly8gUmVmZXIgdG8gIzU2ODkgZm9yIHRoZSByZWFzb24gd2h5IHdlIGRvbid0IHNldCAub25TdGFydFxuXHRcdC8vIGluIHRoZSBjb25zdHJ1Y3RvclxuXG5cdFx0dGhpcy5vblN0YXJ0ID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMub25Mb2FkID0gb25Mb2FkO1xuXHRcdHRoaXMub25Qcm9ncmVzcyA9IG9uUHJvZ3Jlc3M7XG5cdFx0dGhpcy5vbkVycm9yID0gb25FcnJvcjtcblx0XHR0aGlzLml0ZW1TdGFydCA9IGZ1bmN0aW9uICh1cmwpIHtcblx0XHRcdGl0ZW1zVG90YWwrKztcblx0XHRcdGlmIChpc0xvYWRpbmcgPT09IGZhbHNlKSB7XG5cdFx0XHRcdGlmIChzY29wZS5vblN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRzY29wZS5vblN0YXJ0KHVybCwgaXRlbXNMb2FkZWQsIGl0ZW1zVG90YWwpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpc0xvYWRpbmcgPSB0cnVlO1xuXHRcdH07XG5cdFx0dGhpcy5pdGVtRW5kID0gZnVuY3Rpb24gKHVybCkge1xuXHRcdFx0aXRlbXNMb2FkZWQrKztcblx0XHRcdGlmIChzY29wZS5vblByb2dyZXNzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0c2NvcGUub25Qcm9ncmVzcyh1cmwsIGl0ZW1zTG9hZGVkLCBpdGVtc1RvdGFsKTtcblx0XHRcdH1cblx0XHRcdGlmIChpdGVtc0xvYWRlZCA9PT0gaXRlbXNUb3RhbCkge1xuXHRcdFx0XHRpc0xvYWRpbmcgPSBmYWxzZTtcblx0XHRcdFx0aWYgKHNjb3BlLm9uTG9hZCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0c2NvcGUub25Mb2FkKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdHRoaXMuaXRlbUVycm9yID0gZnVuY3Rpb24gKHVybCkge1xuXHRcdFx0aWYgKHNjb3BlLm9uRXJyb3IgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRzY29wZS5vbkVycm9yKHVybCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHR0aGlzLnJlc29sdmVVUkwgPSBmdW5jdGlvbiAodXJsKSB7XG5cdFx0XHRpZiAodXJsTW9kaWZpZXIpIHtcblx0XHRcdFx0cmV0dXJuIHVybE1vZGlmaWVyKHVybCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdXJsO1xuXHRcdH07XG5cdFx0dGhpcy5zZXRVUkxNb2RpZmllciA9IGZ1bmN0aW9uICh0cmFuc2Zvcm0pIHtcblx0XHRcdHVybE1vZGlmaWVyID0gdHJhbnNmb3JtO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHR0aGlzLmFkZEhhbmRsZXIgPSBmdW5jdGlvbiAocmVnZXgsIGxvYWRlcikge1xuXHRcdFx0aGFuZGxlcnMucHVzaChyZWdleCwgbG9hZGVyKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0dGhpcy5yZW1vdmVIYW5kbGVyID0gZnVuY3Rpb24gKHJlZ2V4KSB7XG5cdFx0XHRjb25zdCBpbmRleCA9IGhhbmRsZXJzLmluZGV4T2YocmVnZXgpO1xuXHRcdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoaW5kZXgsIDIpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHR0aGlzLmdldEhhbmRsZXIgPSBmdW5jdGlvbiAoZmlsZSkge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBsOyBpICs9IDIpIHtcblx0XHRcdFx0Y29uc3QgcmVnZXggPSBoYW5kbGVyc1tpXTtcblx0XHRcdFx0Y29uc3QgbG9hZGVyID0gaGFuZGxlcnNbaSArIDFdO1xuXHRcdFx0XHRpZiAocmVnZXguZ2xvYmFsKSByZWdleC5sYXN0SW5kZXggPSAwOyAvLyBzZWUgIzE3OTIwXG5cblx0XHRcdFx0aWYgKHJlZ2V4LnRlc3QoZmlsZSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gbG9hZGVyO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXHR9XG59XG5jb25zdCBEZWZhdWx0TG9hZGluZ01hbmFnZXIgPSAvKkBfX1BVUkVfXyovbmV3IExvYWRpbmdNYW5hZ2VyKCk7XG5cbmNsYXNzIExvYWRlciB7XG5cdGNvbnN0cnVjdG9yKG1hbmFnZXIpIHtcblx0XHR0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyICE9PSB1bmRlZmluZWQgPyBtYW5hZ2VyIDogRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xuXHRcdHRoaXMuY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJztcblx0XHR0aGlzLndpdGhDcmVkZW50aWFscyA9IGZhbHNlO1xuXHRcdHRoaXMucGF0aCA9ICcnO1xuXHRcdHRoaXMucmVzb3VyY2VQYXRoID0gJyc7XG5cdFx0dGhpcy5yZXF1ZXN0SGVhZGVyID0ge307XG5cdH1cblx0bG9hZCgpIHt9XG5cdGxvYWRBc3luYyh1cmwsIG9uUHJvZ3Jlc3MpIHtcblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdHNjb3BlLmxvYWQodXJsLCByZXNvbHZlLCBvblByb2dyZXNzLCByZWplY3QpO1xuXHRcdH0pO1xuXHR9XG5cdHBhcnNlKCkge31cblx0c2V0Q3Jvc3NPcmlnaW4oY3Jvc3NPcmlnaW4pIHtcblx0XHR0aGlzLmNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW47XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0c2V0V2l0aENyZWRlbnRpYWxzKHZhbHVlKSB7XG5cdFx0dGhpcy53aXRoQ3JlZGVudGlhbHMgPSB2YWx1ZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRzZXRQYXRoKHBhdGgpIHtcblx0XHR0aGlzLnBhdGggPSBwYXRoO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHNldFJlc291cmNlUGF0aChyZXNvdXJjZVBhdGgpIHtcblx0XHR0aGlzLnJlc291cmNlUGF0aCA9IHJlc291cmNlUGF0aDtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRzZXRSZXF1ZXN0SGVhZGVyKHJlcXVlc3RIZWFkZXIpIHtcblx0XHR0aGlzLnJlcXVlc3RIZWFkZXIgPSByZXF1ZXN0SGVhZGVyO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59XG5cbmNvbnN0IGxvYWRpbmcgPSB7fTtcbmNsYXNzIEh0dHBFcnJvciBleHRlbmRzIEVycm9yIHtcblx0Y29uc3RydWN0b3IobWVzc2FnZSwgcmVzcG9uc2UpIHtcblx0XHRzdXBlcihtZXNzYWdlKTtcblx0XHR0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG5cdH1cbn1cbmNsYXNzIEZpbGVMb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuXHRjb25zdHJ1Y3RvcihtYW5hZ2VyKSB7XG5cdFx0c3VwZXIobWFuYWdlcik7XG5cdH1cblx0bG9hZCh1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvcikge1xuXHRcdGlmICh1cmwgPT09IHVuZGVmaW5lZCkgdXJsID0gJyc7XG5cdFx0aWYgKHRoaXMucGF0aCAhPT0gdW5kZWZpbmVkKSB1cmwgPSB0aGlzLnBhdGggKyB1cmw7XG5cdFx0dXJsID0gdGhpcy5tYW5hZ2VyLnJlc29sdmVVUkwodXJsKTtcblx0XHRjb25zdCBjYWNoZWQgPSBDYWNoZS5nZXQodXJsKTtcblx0XHRpZiAoY2FjaGVkICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMubWFuYWdlci5pdGVtU3RhcnQodXJsKTtcblx0XHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0XHRpZiAob25Mb2FkKSBvbkxvYWQoY2FjaGVkKTtcblx0XHRcdFx0dGhpcy5tYW5hZ2VyLml0ZW1FbmQodXJsKTtcblx0XHRcdH0sIDApO1xuXHRcdFx0cmV0dXJuIGNhY2hlZDtcblx0XHR9XG5cblx0XHQvLyBDaGVjayBpZiByZXF1ZXN0IGlzIGR1cGxpY2F0ZVxuXG5cdFx0aWYgKGxvYWRpbmdbdXJsXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRsb2FkaW5nW3VybF0ucHVzaCh7XG5cdFx0XHRcdG9uTG9hZDogb25Mb2FkLFxuXHRcdFx0XHRvblByb2dyZXNzOiBvblByb2dyZXNzLFxuXHRcdFx0XHRvbkVycm9yOiBvbkVycm9yXG5cdFx0XHR9KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJbml0aWFsaXNlIGFycmF5IGZvciBkdXBsaWNhdGUgcmVxdWVzdHNcblx0XHRsb2FkaW5nW3VybF0gPSBbXTtcblx0XHRsb2FkaW5nW3VybF0ucHVzaCh7XG5cdFx0XHRvbkxvYWQ6IG9uTG9hZCxcblx0XHRcdG9uUHJvZ3Jlc3M6IG9uUHJvZ3Jlc3MsXG5cdFx0XHRvbkVycm9yOiBvbkVycm9yXG5cdFx0fSk7XG5cblx0XHQvLyBjcmVhdGUgcmVxdWVzdFxuXHRcdGNvbnN0IHJlcSA9IG5ldyBSZXF1ZXN0KHVybCwge1xuXHRcdFx0aGVhZGVyczogbmV3IEhlYWRlcnModGhpcy5yZXF1ZXN0SGVhZGVyKSxcblx0XHRcdGNyZWRlbnRpYWxzOiB0aGlzLndpdGhDcmVkZW50aWFscyA/ICdpbmNsdWRlJyA6ICdzYW1lLW9yaWdpbidcblx0XHRcdC8vIEFuIGFib3J0IGNvbnRyb2xsZXIgY291bGQgYmUgYWRkZWQgd2l0aGluIGEgZnV0dXJlIFBSXG5cdFx0fSk7XG5cblx0XHQvLyByZWNvcmQgc3RhdGVzICggYXZvaWQgZGF0YSByYWNlIClcblx0XHRjb25zdCBtaW1lVHlwZSA9IHRoaXMubWltZVR5cGU7XG5cdFx0Y29uc3QgcmVzcG9uc2VUeXBlID0gdGhpcy5yZXNwb25zZVR5cGU7XG5cblx0XHQvLyBzdGFydCB0aGUgZmV0Y2hcblx0XHRmZXRjaChyZXEpLnRoZW4ocmVzcG9uc2UgPT4ge1xuXHRcdFx0aWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwIHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gMCkge1xuXHRcdFx0XHQvLyBTb21lIGJyb3dzZXJzIHJldHVybiBIVFRQIFN0YXR1cyAwIHdoZW4gdXNpbmcgbm9uLWh0dHAgcHJvdG9jb2xcblx0XHRcdFx0Ly8gZS5nLiAnZmlsZTovLycgb3IgJ2RhdGE6Ly8nLiBIYW5kbGUgYXMgc3VjY2Vzcy5cblxuXHRcdFx0XHRpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAwKSB7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5GaWxlTG9hZGVyOiBIVFRQIFN0YXR1cyAwIHJlY2VpdmVkLicpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gV29ya2Fyb3VuZDogQ2hlY2tpbmcgaWYgcmVzcG9uc2UuYm9keSA9PT0gdW5kZWZpbmVkIGZvciBBbGlwYXkgYnJvd3NlciAjMjM1NDhcblxuXHRcdFx0XHRpZiAodHlwZW9mIFJlYWRhYmxlU3RyZWFtID09PSAndW5kZWZpbmVkJyB8fCByZXNwb25zZS5ib2R5ID09PSB1bmRlZmluZWQgfHwgcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHJldHVybiByZXNwb25zZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb25zdCBjYWxsYmFja3MgPSBsb2FkaW5nW3VybF07XG5cdFx0XHRcdGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG5cdFx0XHRcdGNvbnN0IGNvbnRlbnRMZW5ndGggPSByZXNwb25zZS5oZWFkZXJzLmdldCgnQ29udGVudC1MZW5ndGgnKTtcblx0XHRcdFx0Y29uc3QgdG90YWwgPSBjb250ZW50TGVuZ3RoID8gcGFyc2VJbnQoY29udGVudExlbmd0aCkgOiAwO1xuXHRcdFx0XHRjb25zdCBsZW5ndGhDb21wdXRhYmxlID0gdG90YWwgIT09IDA7XG5cdFx0XHRcdGxldCBsb2FkZWQgPSAwO1xuXG5cdFx0XHRcdC8vIHBlcmlvZGljYWxseSByZWFkIGRhdGEgaW50byB0aGUgbmV3IHN0cmVhbSB0cmFja2luZyB3aGlsZSBkb3dubG9hZCBwcm9ncmVzc1xuXHRcdFx0XHRjb25zdCBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuXHRcdFx0XHRcdHN0YXJ0KGNvbnRyb2xsZXIpIHtcblx0XHRcdFx0XHRcdHJlYWREYXRhKCk7XG5cdFx0XHRcdFx0XHRmdW5jdGlvbiByZWFkRGF0YSgpIHtcblx0XHRcdFx0XHRcdFx0cmVhZGVyLnJlYWQoKS50aGVuKCh7XG5cdFx0XHRcdFx0XHRcdFx0ZG9uZSxcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZVxuXHRcdFx0XHRcdFx0XHR9KSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGRvbmUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnRyb2xsZXIuY2xvc2UoKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0bG9hZGVkICs9IHZhbHVlLmJ5dGVMZW5ndGg7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zdCBldmVudCA9IG5ldyBQcm9ncmVzc0V2ZW50KCdwcm9ncmVzcycsIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0bGVuZ3RoQ29tcHV0YWJsZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0bG9hZGVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0b3RhbFxuXHRcdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRjb25zdCBjYWxsYmFjayA9IGNhbGxiYWNrc1tpXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKGNhbGxiYWNrLm9uUHJvZ3Jlc3MpIGNhbGxiYWNrLm9uUHJvZ3Jlc3MoZXZlbnQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0Y29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcblx0XHRcdFx0XHRcdFx0XHRcdHJlYWREYXRhKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm4gbmV3IFJlc3BvbnNlKHN0cmVhbSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBuZXcgSHR0cEVycm9yKGBmZXRjaCBmb3IgXCIke3Jlc3BvbnNlLnVybH1cIiByZXNwb25kZWQgd2l0aCAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gLCByZXNwb25zZSk7XG5cdFx0XHR9XG5cdFx0fSkudGhlbihyZXNwb25zZSA9PiB7XG5cdFx0XHRzd2l0Y2ggKHJlc3BvbnNlVHlwZSkge1xuXHRcdFx0XHRjYXNlICdhcnJheWJ1ZmZlcic6XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG5cdFx0XHRcdGNhc2UgJ2Jsb2InOlxuXHRcdFx0XHRcdHJldHVybiByZXNwb25zZS5ibG9iKCk7XG5cdFx0XHRcdGNhc2UgJ2RvY3VtZW50Jzpcblx0XHRcdFx0XHRyZXR1cm4gcmVzcG9uc2UudGV4dCgpLnRoZW4odGV4dCA9PiB7XG5cdFx0XHRcdFx0XHRjb25zdCBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyh0ZXh0LCBtaW1lVHlwZSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdGNhc2UgJ2pzb24nOlxuXHRcdFx0XHRcdHJldHVybiByZXNwb25zZS5qc29uKCk7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0aWYgKG1pbWVUeXBlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdHJldHVybiByZXNwb25zZS50ZXh0KCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIHNuaWZmIGVuY29kaW5nXG5cdFx0XHRcdFx0XHRjb25zdCByZSA9IC9jaGFyc2V0PVwiPyhbXjtcIlxcc10qKVwiPy9pO1xuXHRcdFx0XHRcdFx0Y29uc3QgZXhlYyA9IHJlLmV4ZWMobWltZVR5cGUpO1xuXHRcdFx0XHRcdFx0Y29uc3QgbGFiZWwgPSBleGVjICYmIGV4ZWNbMV0gPyBleGVjWzFdLnRvTG93ZXJDYXNlKCkgOiB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKGxhYmVsKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXNwb25zZS5hcnJheUJ1ZmZlcigpLnRoZW4oYWIgPT4gZGVjb2Rlci5kZWNvZGUoYWIpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSkudGhlbihkYXRhID0+IHtcblx0XHRcdC8vIEFkZCB0byBjYWNoZSBvbmx5IG9uIEhUVFAgc3VjY2Vzcywgc28gdGhhdCB3ZSBkbyBub3QgY2FjaGVcblx0XHRcdC8vIGVycm9yIHJlc3BvbnNlIGJvZGllcyBhcyBwcm9wZXIgcmVzcG9uc2VzIHRvIHJlcXVlc3RzLlxuXHRcdFx0Q2FjaGUuYWRkKHVybCwgZGF0YSk7XG5cdFx0XHRjb25zdCBjYWxsYmFja3MgPSBsb2FkaW5nW3VybF07XG5cdFx0XHRkZWxldGUgbG9hZGluZ1t1cmxdO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgY2FsbGJhY2sgPSBjYWxsYmFja3NbaV07XG5cdFx0XHRcdGlmIChjYWxsYmFjay5vbkxvYWQpIGNhbGxiYWNrLm9uTG9hZChkYXRhKTtcblx0XHRcdH1cblx0XHR9KS5jYXRjaChlcnIgPT4ge1xuXHRcdFx0Ly8gQWJvcnQgZXJyb3JzIGFuZCBvdGhlciBlcnJvcnMgYXJlIGhhbmRsZWQgdGhlIHNhbWVcblxuXHRcdFx0Y29uc3QgY2FsbGJhY2tzID0gbG9hZGluZ1t1cmxdO1xuXHRcdFx0aWYgKGNhbGxiYWNrcyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdC8vIFdoZW4gb25Mb2FkIHdhcyBjYWxsZWQgYW5kIHVybCB3YXMgZGVsZXRlZCBpbiBgbG9hZGluZ2Bcblx0XHRcdFx0dGhpcy5tYW5hZ2VyLml0ZW1FcnJvcih1cmwpO1xuXHRcdFx0XHR0aHJvdyBlcnI7XG5cdFx0XHR9XG5cdFx0XHRkZWxldGUgbG9hZGluZ1t1cmxdO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgY2FsbGJhY2sgPSBjYWxsYmFja3NbaV07XG5cdFx0XHRcdGlmIChjYWxsYmFjay5vbkVycm9yKSBjYWxsYmFjay5vbkVycm9yKGVycik7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLm1hbmFnZXIuaXRlbUVycm9yKHVybCk7XG5cdFx0fSkuZmluYWxseSgoKSA9PiB7XG5cdFx0XHR0aGlzLm1hbmFnZXIuaXRlbUVuZCh1cmwpO1xuXHRcdH0pO1xuXHRcdHRoaXMubWFuYWdlci5pdGVtU3RhcnQodXJsKTtcblx0fVxuXHRzZXRSZXNwb25zZVR5cGUodmFsdWUpIHtcblx0XHR0aGlzLnJlc3BvbnNlVHlwZSA9IHZhbHVlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHNldE1pbWVUeXBlKHZhbHVlKSB7XG5cdFx0dGhpcy5taW1lVHlwZSA9IHZhbHVlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59XG5cbmNsYXNzIEFuaW1hdGlvbkxvYWRlciBleHRlbmRzIExvYWRlciB7XG5cdGNvbnN0cnVjdG9yKG1hbmFnZXIpIHtcblx0XHRzdXBlcihtYW5hZ2VyKTtcblx0fVxuXHRsb2FkKHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yKSB7XG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXHRcdGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKHRoaXMubWFuYWdlcik7XG5cdFx0bG9hZGVyLnNldFBhdGgodGhpcy5wYXRoKTtcblx0XHRsb2FkZXIuc2V0UmVxdWVzdEhlYWRlcih0aGlzLnJlcXVlc3RIZWFkZXIpO1xuXHRcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHModGhpcy53aXRoQ3JlZGVudGlhbHMpO1xuXHRcdGxvYWRlci5sb2FkKHVybCwgZnVuY3Rpb24gKHRleHQpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdG9uTG9hZChzY29wZS5wYXJzZShKU09OLnBhcnNlKHRleHQpKSk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdGlmIChvbkVycm9yKSB7XG5cdFx0XHRcdFx0b25FcnJvcihlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKHVybCk7XG5cdFx0XHR9XG5cdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvcik7XG5cdH1cblx0cGFyc2UoanNvbikge1xuXHRcdGNvbnN0IGFuaW1hdGlvbnMgPSBbXTtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGpzb24ubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IGNsaXAgPSBBbmltYXRpb25DbGlwLnBhcnNlKGpzb25baV0pO1xuXHRcdFx0YW5pbWF0aW9ucy5wdXNoKGNsaXApO1xuXHRcdH1cblx0XHRyZXR1cm4gYW5pbWF0aW9ucztcblx0fVxufVxuXG4vKipcbiAqIEFic3RyYWN0IEJhc2UgY2xhc3MgdG8gYmxvY2sgYmFzZWQgdGV4dHVyZXMgbG9hZGVyIChkZHMsIHB2ciwgLi4uKVxuICpcbiAqIFN1YiBjbGFzc2VzIGhhdmUgdG8gaW1wbGVtZW50IHRoZSBwYXJzZSgpIG1ldGhvZCB3aGljaCB3aWxsIGJlIHVzZWQgaW4gbG9hZCgpLlxuICovXG5cbmNsYXNzIENvbXByZXNzZWRUZXh0dXJlTG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcblx0Y29uc3RydWN0b3IobWFuYWdlcikge1xuXHRcdHN1cGVyKG1hbmFnZXIpO1xuXHR9XG5cdGxvYWQodXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpIHtcblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cdFx0Y29uc3QgaW1hZ2VzID0gW107XG5cdFx0Y29uc3QgdGV4dHVyZSA9IG5ldyBDb21wcmVzc2VkVGV4dHVyZSgpO1xuXHRcdGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKHRoaXMubWFuYWdlcik7XG5cdFx0bG9hZGVyLnNldFBhdGgodGhpcy5wYXRoKTtcblx0XHRsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCdhcnJheWJ1ZmZlcicpO1xuXHRcdGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKHRoaXMucmVxdWVzdEhlYWRlcik7XG5cdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyhzY29wZS53aXRoQ3JlZGVudGlhbHMpO1xuXHRcdGxldCBsb2FkZWQgPSAwO1xuXHRcdGZ1bmN0aW9uIGxvYWRUZXh0dXJlKGkpIHtcblx0XHRcdGxvYWRlci5sb2FkKHVybFtpXSwgZnVuY3Rpb24gKGJ1ZmZlcikge1xuXHRcdFx0XHRjb25zdCB0ZXhEYXRhcyA9IHNjb3BlLnBhcnNlKGJ1ZmZlciwgdHJ1ZSk7XG5cdFx0XHRcdGltYWdlc1tpXSA9IHtcblx0XHRcdFx0XHR3aWR0aDogdGV4RGF0YXMud2lkdGgsXG5cdFx0XHRcdFx0aGVpZ2h0OiB0ZXhEYXRhcy5oZWlnaHQsXG5cdFx0XHRcdFx0Zm9ybWF0OiB0ZXhEYXRhcy5mb3JtYXQsXG5cdFx0XHRcdFx0bWlwbWFwczogdGV4RGF0YXMubWlwbWFwc1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRsb2FkZWQgKz0gMTtcblx0XHRcdFx0aWYgKGxvYWRlZCA9PT0gNikge1xuXHRcdFx0XHRcdGlmICh0ZXhEYXRhcy5taXBtYXBDb3VudCA9PT0gMSkgdGV4dHVyZS5taW5GaWx0ZXIgPSBMaW5lYXJGaWx0ZXI7XG5cdFx0XHRcdFx0dGV4dHVyZS5pbWFnZSA9IGltYWdlcztcblx0XHRcdFx0XHR0ZXh0dXJlLmZvcm1hdCA9IHRleERhdGFzLmZvcm1hdDtcblx0XHRcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRpZiAob25Mb2FkKSBvbkxvYWQodGV4dHVyZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpO1xuXHRcdH1cblx0XHRpZiAoQXJyYXkuaXNBcnJheSh1cmwpKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSB1cmwubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuXHRcdFx0XHRsb2FkVGV4dHVyZShpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gY29tcHJlc3NlZCBjdWJlbWFwIHRleHR1cmUgc3RvcmVkIGluIGEgc2luZ2xlIEREUyBmaWxlXG5cblx0XHRcdGxvYWRlci5sb2FkKHVybCwgZnVuY3Rpb24gKGJ1ZmZlcikge1xuXHRcdFx0XHRjb25zdCB0ZXhEYXRhcyA9IHNjb3BlLnBhcnNlKGJ1ZmZlciwgdHJ1ZSk7XG5cdFx0XHRcdGlmICh0ZXhEYXRhcy5pc0N1YmVtYXApIHtcblx0XHRcdFx0XHRjb25zdCBmYWNlcyA9IHRleERhdGFzLm1pcG1hcHMubGVuZ3RoIC8gdGV4RGF0YXMubWlwbWFwQ291bnQ7XG5cdFx0XHRcdFx0Zm9yIChsZXQgZiA9IDA7IGYgPCBmYWNlczsgZisrKSB7XG5cdFx0XHRcdFx0XHRpbWFnZXNbZl0gPSB7XG5cdFx0XHRcdFx0XHRcdG1pcG1hcHM6IFtdXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0ZXhEYXRhcy5taXBtYXBDb3VudDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdGltYWdlc1tmXS5taXBtYXBzLnB1c2godGV4RGF0YXMubWlwbWFwc1tmICogdGV4RGF0YXMubWlwbWFwQ291bnQgKyBpXSk7XG5cdFx0XHRcdFx0XHRcdGltYWdlc1tmXS5mb3JtYXQgPSB0ZXhEYXRhcy5mb3JtYXQ7XG5cdFx0XHRcdFx0XHRcdGltYWdlc1tmXS53aWR0aCA9IHRleERhdGFzLndpZHRoO1xuXHRcdFx0XHRcdFx0XHRpbWFnZXNbZl0uaGVpZ2h0ID0gdGV4RGF0YXMuaGVpZ2h0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0ZXh0dXJlLmltYWdlID0gaW1hZ2VzO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRleHR1cmUuaW1hZ2Uud2lkdGggPSB0ZXhEYXRhcy53aWR0aDtcblx0XHRcdFx0XHR0ZXh0dXJlLmltYWdlLmhlaWdodCA9IHRleERhdGFzLmhlaWdodDtcblx0XHRcdFx0XHR0ZXh0dXJlLm1pcG1hcHMgPSB0ZXhEYXRhcy5taXBtYXBzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0ZXhEYXRhcy5taXBtYXBDb3VudCA9PT0gMSkge1xuXHRcdFx0XHRcdHRleHR1cmUubWluRmlsdGVyID0gTGluZWFyRmlsdGVyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRleHR1cmUuZm9ybWF0ID0gdGV4RGF0YXMuZm9ybWF0O1xuXHRcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0aWYgKG9uTG9hZCkgb25Mb2FkKHRleHR1cmUpO1xuXHRcdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvcik7XG5cdFx0fVxuXHRcdHJldHVybiB0ZXh0dXJlO1xuXHR9XG59XG5cbmNsYXNzIEltYWdlTG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcblx0Y29uc3RydWN0b3IobWFuYWdlcikge1xuXHRcdHN1cGVyKG1hbmFnZXIpO1xuXHR9XG5cdGxvYWQodXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpIHtcblx0XHRpZiAodGhpcy5wYXRoICE9PSB1bmRlZmluZWQpIHVybCA9IHRoaXMucGF0aCArIHVybDtcblx0XHR1cmwgPSB0aGlzLm1hbmFnZXIucmVzb2x2ZVVSTCh1cmwpO1xuXHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblx0XHRjb25zdCBjYWNoZWQgPSBDYWNoZS5nZXQodXJsKTtcblx0XHRpZiAoY2FjaGVkICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KHVybCk7XG5cdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYgKG9uTG9hZCkgb25Mb2FkKGNhY2hlZCk7XG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCh1cmwpO1xuXHRcdFx0fSwgMCk7XG5cdFx0XHRyZXR1cm4gY2FjaGVkO1xuXHRcdH1cblx0XHRjb25zdCBpbWFnZSA9IGNyZWF0ZUVsZW1lbnROUygnaW1nJyk7XG5cdFx0ZnVuY3Rpb24gb25JbWFnZUxvYWQoKSB7XG5cdFx0XHRyZW1vdmVFdmVudExpc3RlbmVycygpO1xuXHRcdFx0Q2FjaGUuYWRkKHVybCwgdGhpcyk7XG5cdFx0XHRpZiAob25Mb2FkKSBvbkxvYWQodGhpcyk7XG5cdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQodXJsKTtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gb25JbWFnZUVycm9yKGV2ZW50KSB7XG5cdFx0XHRyZW1vdmVFdmVudExpc3RlbmVycygpO1xuXHRcdFx0aWYgKG9uRXJyb3IpIG9uRXJyb3IoZXZlbnQpO1xuXHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IodXJsKTtcblx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCh1cmwpO1xuXHRcdH1cblx0XHRmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycygpIHtcblx0XHRcdGltYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBvbkltYWdlTG9hZCwgZmFsc2UpO1xuXHRcdFx0aW1hZ2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkltYWdlRXJyb3IsIGZhbHNlKTtcblx0XHR9XG5cdFx0aW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9uSW1hZ2VMb2FkLCBmYWxzZSk7XG5cdFx0aW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkltYWdlRXJyb3IsIGZhbHNlKTtcblx0XHRpZiAodXJsLnNsaWNlKDAsIDUpICE9PSAnZGF0YTonKSB7XG5cdFx0XHRpZiAodGhpcy5jcm9zc09yaWdpbiAhPT0gdW5kZWZpbmVkKSBpbWFnZS5jcm9zc09yaWdpbiA9IHRoaXMuY3Jvc3NPcmlnaW47XG5cdFx0fVxuXHRcdHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KHVybCk7XG5cdFx0aW1hZ2Uuc3JjID0gdXJsO1xuXHRcdHJldHVybiBpbWFnZTtcblx0fVxufVxuXG5jbGFzcyBDdWJlVGV4dHVyZUxvYWRlciBleHRlbmRzIExvYWRlciB7XG5cdGNvbnN0cnVjdG9yKG1hbmFnZXIpIHtcblx0XHRzdXBlcihtYW5hZ2VyKTtcblx0fVxuXHRsb2FkKHVybHMsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvcikge1xuXHRcdGNvbnN0IHRleHR1cmUgPSBuZXcgQ3ViZVRleHR1cmUoKTtcblx0XHRjb25zdCBsb2FkZXIgPSBuZXcgSW1hZ2VMb2FkZXIodGhpcy5tYW5hZ2VyKTtcblx0XHRsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4odGhpcy5jcm9zc09yaWdpbik7XG5cdFx0bG9hZGVyLnNldFBhdGgodGhpcy5wYXRoKTtcblx0XHRsZXQgbG9hZGVkID0gMDtcblx0XHRmdW5jdGlvbiBsb2FkVGV4dHVyZShpKSB7XG5cdFx0XHRsb2FkZXIubG9hZCh1cmxzW2ldLCBmdW5jdGlvbiAoaW1hZ2UpIHtcblx0XHRcdFx0dGV4dHVyZS5pbWFnZXNbaV0gPSBpbWFnZTtcblx0XHRcdFx0bG9hZGVkKys7XG5cdFx0XHRcdGlmIChsb2FkZWQgPT09IDYpIHtcblx0XHRcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRpZiAob25Mb2FkKSBvbkxvYWQodGV4dHVyZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIHVuZGVmaW5lZCwgb25FcnJvcik7XG5cdFx0fVxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdXJscy5sZW5ndGg7ICsraSkge1xuXHRcdFx0bG9hZFRleHR1cmUoaSk7XG5cdFx0fVxuXHRcdHJldHVybiB0ZXh0dXJlO1xuXHR9XG59XG5cbi8qKlxuICogQWJzdHJhY3QgQmFzZSBjbGFzcyB0byBsb2FkIGdlbmVyaWMgYmluYXJ5IHRleHR1cmVzIGZvcm1hdHMgKHJnYmUsIGhkciwgLi4uKVxuICpcbiAqIFN1YiBjbGFzc2VzIGhhdmUgdG8gaW1wbGVtZW50IHRoZSBwYXJzZSgpIG1ldGhvZCB3aGljaCB3aWxsIGJlIHVzZWQgaW4gbG9hZCgpLlxuICovXG5cbmNsYXNzIERhdGFUZXh0dXJlTG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcblx0Y29uc3RydWN0b3IobWFuYWdlcikge1xuXHRcdHN1cGVyKG1hbmFnZXIpO1xuXHR9XG5cdGxvYWQodXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpIHtcblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cdFx0Y29uc3QgdGV4dHVyZSA9IG5ldyBEYXRhVGV4dHVyZSgpO1xuXHRcdGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKHRoaXMubWFuYWdlcik7XG5cdFx0bG9hZGVyLnNldFJlc3BvbnNlVHlwZSgnYXJyYXlidWZmZXInKTtcblx0XHRsb2FkZXIuc2V0UmVxdWVzdEhlYWRlcih0aGlzLnJlcXVlc3RIZWFkZXIpO1xuXHRcdGxvYWRlci5zZXRQYXRoKHRoaXMucGF0aCk7XG5cdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyhzY29wZS53aXRoQ3JlZGVudGlhbHMpO1xuXHRcdGxvYWRlci5sb2FkKHVybCwgZnVuY3Rpb24gKGJ1ZmZlcikge1xuXHRcdFx0Y29uc3QgdGV4RGF0YSA9IHNjb3BlLnBhcnNlKGJ1ZmZlcik7XG5cdFx0XHRpZiAoIXRleERhdGEpIHJldHVybjtcblx0XHRcdGlmICh0ZXhEYXRhLmltYWdlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGV4dHVyZS5pbWFnZSA9IHRleERhdGEuaW1hZ2U7XG5cdFx0XHR9IGVsc2UgaWYgKHRleERhdGEuZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRleHR1cmUuaW1hZ2Uud2lkdGggPSB0ZXhEYXRhLndpZHRoO1xuXHRcdFx0XHR0ZXh0dXJlLmltYWdlLmhlaWdodCA9IHRleERhdGEuaGVpZ2h0O1xuXHRcdFx0XHR0ZXh0dXJlLmltYWdlLmRhdGEgPSB0ZXhEYXRhLmRhdGE7XG5cdFx0XHR9XG5cdFx0XHR0ZXh0dXJlLndyYXBTID0gdGV4RGF0YS53cmFwUyAhPT0gdW5kZWZpbmVkID8gdGV4RGF0YS53cmFwUyA6IENsYW1wVG9FZGdlV3JhcHBpbmc7XG5cdFx0XHR0ZXh0dXJlLndyYXBUID0gdGV4RGF0YS53cmFwVCAhPT0gdW5kZWZpbmVkID8gdGV4RGF0YS53cmFwVCA6IENsYW1wVG9FZGdlV3JhcHBpbmc7XG5cdFx0XHR0ZXh0dXJlLm1hZ0ZpbHRlciA9IHRleERhdGEubWFnRmlsdGVyICE9PSB1bmRlZmluZWQgPyB0ZXhEYXRhLm1hZ0ZpbHRlciA6IExpbmVhckZpbHRlcjtcblx0XHRcdHRleHR1cmUubWluRmlsdGVyID0gdGV4RGF0YS5taW5GaWx0ZXIgIT09IHVuZGVmaW5lZCA/IHRleERhdGEubWluRmlsdGVyIDogTGluZWFyRmlsdGVyO1xuXHRcdFx0dGV4dHVyZS5hbmlzb3Ryb3B5ID0gdGV4RGF0YS5hbmlzb3Ryb3B5ICE9PSB1bmRlZmluZWQgPyB0ZXhEYXRhLmFuaXNvdHJvcHkgOiAxO1xuXHRcdFx0aWYgKHRleERhdGEuZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0ZXh0dXJlLmVuY29kaW5nID0gdGV4RGF0YS5lbmNvZGluZztcblx0XHRcdH1cblx0XHRcdGlmICh0ZXhEYXRhLmZsaXBZICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGV4dHVyZS5mbGlwWSA9IHRleERhdGEuZmxpcFk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGV4RGF0YS5mb3JtYXQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0ZXh0dXJlLmZvcm1hdCA9IHRleERhdGEuZm9ybWF0O1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRleERhdGEudHlwZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRleHR1cmUudHlwZSA9IHRleERhdGEudHlwZTtcblx0XHRcdH1cblx0XHRcdGlmICh0ZXhEYXRhLm1pcG1hcHMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0ZXh0dXJlLm1pcG1hcHMgPSB0ZXhEYXRhLm1pcG1hcHM7XG5cdFx0XHRcdHRleHR1cmUubWluRmlsdGVyID0gTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyOyAvLyBwcmVzdW1hYmx5Li4uXG5cdFx0XHR9XG5cblx0XHRcdGlmICh0ZXhEYXRhLm1pcG1hcENvdW50ID09PSAxKSB7XG5cdFx0XHRcdHRleHR1cmUubWluRmlsdGVyID0gTGluZWFyRmlsdGVyO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRleERhdGEuZ2VuZXJhdGVNaXBtYXBzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSB0ZXhEYXRhLmdlbmVyYXRlTWlwbWFwcztcblx0XHRcdH1cblx0XHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0aWYgKG9uTG9hZCkgb25Mb2FkKHRleHR1cmUsIHRleERhdGEpO1xuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpO1xuXHRcdHJldHVybiB0ZXh0dXJlO1xuXHR9XG59XG5cbmNsYXNzIFRleHR1cmVMb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuXHRjb25zdHJ1Y3RvcihtYW5hZ2VyKSB7XG5cdFx0c3VwZXIobWFuYWdlcik7XG5cdH1cblx0bG9hZCh1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvcikge1xuXHRcdGNvbnN0IHRleHR1cmUgPSBuZXcgVGV4dHVyZSgpO1xuXHRcdGNvbnN0IGxvYWRlciA9IG5ldyBJbWFnZUxvYWRlcih0aGlzLm1hbmFnZXIpO1xuXHRcdGxvYWRlci5zZXRDcm9zc09yaWdpbih0aGlzLmNyb3NzT3JpZ2luKTtcblx0XHRsb2FkZXIuc2V0UGF0aCh0aGlzLnBhdGgpO1xuXHRcdGxvYWRlci5sb2FkKHVybCwgZnVuY3Rpb24gKGltYWdlKSB7XG5cdFx0XHR0ZXh0dXJlLmltYWdlID0gaW1hZ2U7XG5cdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdGlmIChvbkxvYWQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRvbkxvYWQodGV4dHVyZSk7XG5cdFx0XHR9XG5cdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvcik7XG5cdFx0cmV0dXJuIHRleHR1cmU7XG5cdH1cbn1cblxuY2xhc3MgTGlnaHQgZXh0ZW5kcyBPYmplY3QzRCB7XG5cdGNvbnN0cnVjdG9yKGNvbG9yLCBpbnRlbnNpdHkgPSAxKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLmlzTGlnaHQgPSB0cnVlO1xuXHRcdHRoaXMudHlwZSA9ICdMaWdodCc7XG5cdFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvcihjb2xvcik7XG5cdFx0dGhpcy5pbnRlbnNpdHkgPSBpbnRlbnNpdHk7XG5cdH1cblx0ZGlzcG9zZSgpIHtcblxuXHRcdC8vIEVtcHR5IGhlcmUgaW4gYmFzZSBjbGFzczsgc29tZSBzdWJjbGFzc2VzIG92ZXJyaWRlLlxuXHR9XG5cdGNvcHkoc291cmNlLCByZWN1cnNpdmUpIHtcblx0XHRzdXBlci5jb3B5KHNvdXJjZSwgcmVjdXJzaXZlKTtcblx0XHR0aGlzLmNvbG9yLmNvcHkoc291cmNlLmNvbG9yKTtcblx0XHR0aGlzLmludGVuc2l0eSA9IHNvdXJjZS5pbnRlbnNpdHk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0dG9KU09OKG1ldGEpIHtcblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKG1ldGEpO1xuXHRcdGRhdGEub2JqZWN0LmNvbG9yID0gdGhpcy5jb2xvci5nZXRIZXgoKTtcblx0XHRkYXRhLm9iamVjdC5pbnRlbnNpdHkgPSB0aGlzLmludGVuc2l0eTtcblx0XHRpZiAodGhpcy5ncm91bmRDb2xvciAhPT0gdW5kZWZpbmVkKSBkYXRhLm9iamVjdC5ncm91bmRDb2xvciA9IHRoaXMuZ3JvdW5kQ29sb3IuZ2V0SGV4KCk7XG5cdFx0aWYgKHRoaXMuZGlzdGFuY2UgIT09IHVuZGVmaW5lZCkgZGF0YS5vYmplY3QuZGlzdGFuY2UgPSB0aGlzLmRpc3RhbmNlO1xuXHRcdGlmICh0aGlzLmFuZ2xlICE9PSB1bmRlZmluZWQpIGRhdGEub2JqZWN0LmFuZ2xlID0gdGhpcy5hbmdsZTtcblx0XHRpZiAodGhpcy5kZWNheSAhPT0gdW5kZWZpbmVkKSBkYXRhLm9iamVjdC5kZWNheSA9IHRoaXMuZGVjYXk7XG5cdFx0aWYgKHRoaXMucGVudW1icmEgIT09IHVuZGVmaW5lZCkgZGF0YS5vYmplY3QucGVudW1icmEgPSB0aGlzLnBlbnVtYnJhO1xuXHRcdGlmICh0aGlzLnNoYWRvdyAhPT0gdW5kZWZpbmVkKSBkYXRhLm9iamVjdC5zaGFkb3cgPSB0aGlzLnNoYWRvdy50b0pTT04oKTtcblx0XHRyZXR1cm4gZGF0YTtcblx0fVxufVxuXG5jbGFzcyBIZW1pc3BoZXJlTGlnaHQgZXh0ZW5kcyBMaWdodCB7XG5cdGNvbnN0cnVjdG9yKHNreUNvbG9yLCBncm91bmRDb2xvciwgaW50ZW5zaXR5KSB7XG5cdFx0c3VwZXIoc2t5Q29sb3IsIGludGVuc2l0eSk7XG5cdFx0dGhpcy5pc0hlbWlzcGhlcmVMaWdodCA9IHRydWU7XG5cdFx0dGhpcy50eXBlID0gJ0hlbWlzcGhlcmVMaWdodCc7XG5cdFx0dGhpcy5wb3NpdGlvbi5jb3B5KE9iamVjdDNELkRlZmF1bHRVcCk7XG5cdFx0dGhpcy51cGRhdGVNYXRyaXgoKTtcblx0XHR0aGlzLmdyb3VuZENvbG9yID0gbmV3IENvbG9yKGdyb3VuZENvbG9yKTtcblx0fVxuXHRjb3B5KHNvdXJjZSwgcmVjdXJzaXZlKSB7XG5cdFx0c3VwZXIuY29weShzb3VyY2UsIHJlY3Vyc2l2ZSk7XG5cdFx0dGhpcy5ncm91bmRDb2xvci5jb3B5KHNvdXJjZS5ncm91bmRDb2xvcik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn1cblxuY29uc3QgX3Byb2pTY3JlZW5NYXRyaXgkMSA9IC8qQF9fUFVSRV9fKi9uZXcgTWF0cml4NCgpO1xuY29uc3QgX2xpZ2h0UG9zaXRpb25Xb3JsZCQxID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5jb25zdCBfbG9va1RhcmdldCQxID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5jbGFzcyBMaWdodFNoYWRvdyB7XG5cdGNvbnN0cnVjdG9yKGNhbWVyYSkge1xuXHRcdHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuXHRcdHRoaXMuYmlhcyA9IDA7XG5cdFx0dGhpcy5ub3JtYWxCaWFzID0gMDtcblx0XHR0aGlzLnJhZGl1cyA9IDE7XG5cdFx0dGhpcy5ibHVyU2FtcGxlcyA9IDg7XG5cdFx0dGhpcy5tYXBTaXplID0gbmV3IFZlY3RvcjIoNTEyLCA1MTIpO1xuXHRcdHRoaXMubWFwID0gbnVsbDtcblx0XHR0aGlzLm1hcFBhc3MgPSBudWxsO1xuXHRcdHRoaXMubWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblx0XHR0aGlzLmF1dG9VcGRhdGUgPSB0cnVlO1xuXHRcdHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcblx0XHR0aGlzLl9mcnVzdHVtID0gbmV3IEZydXN0dW0oKTtcblx0XHR0aGlzLl9mcmFtZUV4dGVudHMgPSBuZXcgVmVjdG9yMigxLCAxKTtcblx0XHR0aGlzLl92aWV3cG9ydENvdW50ID0gMTtcblx0XHR0aGlzLl92aWV3cG9ydHMgPSBbbmV3IFZlY3RvcjQoMCwgMCwgMSwgMSldO1xuXHR9XG5cdGdldFZpZXdwb3J0Q291bnQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3ZpZXdwb3J0Q291bnQ7XG5cdH1cblx0Z2V0RnJ1c3R1bSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZnJ1c3R1bTtcblx0fVxuXHR1cGRhdGVNYXRyaWNlcyhsaWdodCkge1xuXHRcdGNvbnN0IHNoYWRvd0NhbWVyYSA9IHRoaXMuY2FtZXJhO1xuXHRcdGNvbnN0IHNoYWRvd01hdHJpeCA9IHRoaXMubWF0cml4O1xuXHRcdF9saWdodFBvc2l0aW9uV29ybGQkMS5zZXRGcm9tTWF0cml4UG9zaXRpb24obGlnaHQubWF0cml4V29ybGQpO1xuXHRcdHNoYWRvd0NhbWVyYS5wb3NpdGlvbi5jb3B5KF9saWdodFBvc2l0aW9uV29ybGQkMSk7XG5cdFx0X2xvb2tUYXJnZXQkMS5zZXRGcm9tTWF0cml4UG9zaXRpb24obGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkKTtcblx0XHRzaGFkb3dDYW1lcmEubG9va0F0KF9sb29rVGFyZ2V0JDEpO1xuXHRcdHNoYWRvd0NhbWVyYS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXHRcdF9wcm9qU2NyZWVuTWF0cml4JDEubXVsdGlwbHlNYXRyaWNlcyhzaGFkb3dDYW1lcmEucHJvamVjdGlvbk1hdHJpeCwgc2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSk7XG5cdFx0dGhpcy5fZnJ1c3R1bS5zZXRGcm9tUHJvamVjdGlvbk1hdHJpeChfcHJvalNjcmVlbk1hdHJpeCQxKTtcblx0XHRzaGFkb3dNYXRyaXguc2V0KDAuNSwgMC4wLCAwLjAsIDAuNSwgMC4wLCAwLjUsIDAuMCwgMC41LCAwLjAsIDAuMCwgMC41LCAwLjUsIDAuMCwgMC4wLCAwLjAsIDEuMCk7XG5cdFx0c2hhZG93TWF0cml4Lm11bHRpcGx5KF9wcm9qU2NyZWVuTWF0cml4JDEpO1xuXHR9XG5cdGdldFZpZXdwb3J0KHZpZXdwb3J0SW5kZXgpIHtcblx0XHRyZXR1cm4gdGhpcy5fdmlld3BvcnRzW3ZpZXdwb3J0SW5kZXhdO1xuXHR9XG5cdGdldEZyYW1lRXh0ZW50cygpIHtcblx0XHRyZXR1cm4gdGhpcy5fZnJhbWVFeHRlbnRzO1xuXHR9XG5cdGRpc3Bvc2UoKSB7XG5cdFx0aWYgKHRoaXMubWFwKSB7XG5cdFx0XHR0aGlzLm1hcC5kaXNwb3NlKCk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLm1hcFBhc3MpIHtcblx0XHRcdHRoaXMubWFwUGFzcy5kaXNwb3NlKCk7XG5cdFx0fVxuXHR9XG5cdGNvcHkoc291cmNlKSB7XG5cdFx0dGhpcy5jYW1lcmEgPSBzb3VyY2UuY2FtZXJhLmNsb25lKCk7XG5cdFx0dGhpcy5iaWFzID0gc291cmNlLmJpYXM7XG5cdFx0dGhpcy5yYWRpdXMgPSBzb3VyY2UucmFkaXVzO1xuXHRcdHRoaXMubWFwU2l6ZS5jb3B5KHNvdXJjZS5tYXBTaXplKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRjbG9uZSgpIHtcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpO1xuXHR9XG5cdHRvSlNPTigpIHtcblx0XHRjb25zdCBvYmplY3QgPSB7fTtcblx0XHRpZiAodGhpcy5iaWFzICE9PSAwKSBvYmplY3QuYmlhcyA9IHRoaXMuYmlhcztcblx0XHRpZiAodGhpcy5ub3JtYWxCaWFzICE9PSAwKSBvYmplY3Qubm9ybWFsQmlhcyA9IHRoaXMubm9ybWFsQmlhcztcblx0XHRpZiAodGhpcy5yYWRpdXMgIT09IDEpIG9iamVjdC5yYWRpdXMgPSB0aGlzLnJhZGl1cztcblx0XHRpZiAodGhpcy5tYXBTaXplLnggIT09IDUxMiB8fCB0aGlzLm1hcFNpemUueSAhPT0gNTEyKSBvYmplY3QubWFwU2l6ZSA9IHRoaXMubWFwU2l6ZS50b0FycmF5KCk7XG5cdFx0b2JqZWN0LmNhbWVyYSA9IHRoaXMuY2FtZXJhLnRvSlNPTihmYWxzZSkub2JqZWN0O1xuXHRcdGRlbGV0ZSBvYmplY3QuY2FtZXJhLm1hdHJpeDtcblx0XHRyZXR1cm4gb2JqZWN0O1xuXHR9XG59XG5cbmNsYXNzIFNwb3RMaWdodFNoYWRvdyBleHRlbmRzIExpZ2h0U2hhZG93IHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIobmV3IFBlcnNwZWN0aXZlQ2FtZXJhKDUwLCAxLCAwLjUsIDUwMCkpO1xuXHRcdHRoaXMuaXNTcG90TGlnaHRTaGFkb3cgPSB0cnVlO1xuXHRcdHRoaXMuZm9jdXMgPSAxO1xuXHR9XG5cdHVwZGF0ZU1hdHJpY2VzKGxpZ2h0KSB7XG5cdFx0Y29uc3QgY2FtZXJhID0gdGhpcy5jYW1lcmE7XG5cdFx0Y29uc3QgZm92ID0gUkFEMkRFRyAqIDIgKiBsaWdodC5hbmdsZSAqIHRoaXMuZm9jdXM7XG5cdFx0Y29uc3QgYXNwZWN0ID0gdGhpcy5tYXBTaXplLndpZHRoIC8gdGhpcy5tYXBTaXplLmhlaWdodDtcblx0XHRjb25zdCBmYXIgPSBsaWdodC5kaXN0YW5jZSB8fCBjYW1lcmEuZmFyO1xuXHRcdGlmIChmb3YgIT09IGNhbWVyYS5mb3YgfHwgYXNwZWN0ICE9PSBjYW1lcmEuYXNwZWN0IHx8IGZhciAhPT0gY2FtZXJhLmZhcikge1xuXHRcdFx0Y2FtZXJhLmZvdiA9IGZvdjtcblx0XHRcdGNhbWVyYS5hc3BlY3QgPSBhc3BlY3Q7XG5cdFx0XHRjYW1lcmEuZmFyID0gZmFyO1xuXHRcdFx0Y2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblx0XHR9XG5cdFx0c3VwZXIudXBkYXRlTWF0cmljZXMobGlnaHQpO1xuXHR9XG5cdGNvcHkoc291cmNlKSB7XG5cdFx0c3VwZXIuY29weShzb3VyY2UpO1xuXHRcdHRoaXMuZm9jdXMgPSBzb3VyY2UuZm9jdXM7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn1cblxuY2xhc3MgU3BvdExpZ2h0IGV4dGVuZHMgTGlnaHQge1xuXHRjb25zdHJ1Y3Rvcihjb2xvciwgaW50ZW5zaXR5LCBkaXN0YW5jZSA9IDAsIGFuZ2xlID0gTWF0aC5QSSAvIDMsIHBlbnVtYnJhID0gMCwgZGVjYXkgPSAxKSB7XG5cdFx0c3VwZXIoY29sb3IsIGludGVuc2l0eSk7XG5cdFx0dGhpcy5pc1Nwb3RMaWdodCA9IHRydWU7XG5cdFx0dGhpcy50eXBlID0gJ1Nwb3RMaWdodCc7XG5cdFx0dGhpcy5wb3NpdGlvbi5jb3B5KE9iamVjdDNELkRlZmF1bHRVcCk7XG5cdFx0dGhpcy51cGRhdGVNYXRyaXgoKTtcblx0XHR0aGlzLnRhcmdldCA9IG5ldyBPYmplY3QzRCgpO1xuXHRcdHRoaXMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcblx0XHR0aGlzLmFuZ2xlID0gYW5nbGU7XG5cdFx0dGhpcy5wZW51bWJyYSA9IHBlbnVtYnJhO1xuXHRcdHRoaXMuZGVjYXkgPSBkZWNheTsgLy8gZm9yIHBoeXNpY2FsbHkgY29ycmVjdCBsaWdodHMsIHNob3VsZCBiZSAyLlxuXG5cdFx0dGhpcy5tYXAgPSBudWxsO1xuXHRcdHRoaXMuc2hhZG93ID0gbmV3IFNwb3RMaWdodFNoYWRvdygpO1xuXHR9XG5cdGdldCBwb3dlcigpIHtcblx0XHQvLyBjb21wdXRlIHRoZSBsaWdodCdzIGx1bWlub3VzIHBvd2VyIChpbiBsdW1lbnMpIGZyb20gaXRzIGludGVuc2l0eSAoaW4gY2FuZGVsYSlcblx0XHQvLyBieSBjb252ZW50aW9uIGZvciBhIHNwb3RsaWdodCwgbHVtaW5vdXMgcG93ZXIgKGxtKSA9IM+AICogbHVtaW5vdXMgaW50ZW5zaXR5IChjZClcblx0XHRyZXR1cm4gdGhpcy5pbnRlbnNpdHkgKiBNYXRoLlBJO1xuXHR9XG5cdHNldCBwb3dlcihwb3dlcikge1xuXHRcdC8vIHNldCB0aGUgbGlnaHQncyBpbnRlbnNpdHkgKGluIGNhbmRlbGEpIGZyb20gdGhlIGRlc2lyZWQgbHVtaW5vdXMgcG93ZXIgKGluIGx1bWVucylcblx0XHR0aGlzLmludGVuc2l0eSA9IHBvd2VyIC8gTWF0aC5QSTtcblx0fVxuXHRkaXNwb3NlKCkge1xuXHRcdHRoaXMuc2hhZG93LmRpc3Bvc2UoKTtcblx0fVxuXHRjb3B5KHNvdXJjZSwgcmVjdXJzaXZlKSB7XG5cdFx0c3VwZXIuY29weShzb3VyY2UsIHJlY3Vyc2l2ZSk7XG5cdFx0dGhpcy5kaXN0YW5jZSA9IHNvdXJjZS5kaXN0YW5jZTtcblx0XHR0aGlzLmFuZ2xlID0gc291cmNlLmFuZ2xlO1xuXHRcdHRoaXMucGVudW1icmEgPSBzb3VyY2UucGVudW1icmE7XG5cdFx0dGhpcy5kZWNheSA9IHNvdXJjZS5kZWNheTtcblx0XHR0aGlzLnRhcmdldCA9IHNvdXJjZS50YXJnZXQuY2xvbmUoKTtcblx0XHR0aGlzLnNoYWRvdyA9IHNvdXJjZS5zaGFkb3cuY2xvbmUoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufVxuXG5jb25zdCBfcHJvalNjcmVlbk1hdHJpeCA9IC8qQF9fUFVSRV9fKi9uZXcgTWF0cml4NCgpO1xuY29uc3QgX2xpZ2h0UG9zaXRpb25Xb3JsZCA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuY29uc3QgX2xvb2tUYXJnZXQgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcbmNsYXNzIFBvaW50TGlnaHRTaGFkb3cgZXh0ZW5kcyBMaWdodFNoYWRvdyB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSg5MCwgMSwgMC41LCA1MDApKTtcblx0XHR0aGlzLmlzUG9pbnRMaWdodFNoYWRvdyA9IHRydWU7XG5cdFx0dGhpcy5fZnJhbWVFeHRlbnRzID0gbmV3IFZlY3RvcjIoNCwgMik7XG5cdFx0dGhpcy5fdmlld3BvcnRDb3VudCA9IDY7XG5cdFx0dGhpcy5fdmlld3BvcnRzID0gW1xuXHRcdC8vIFRoZXNlIHZpZXdwb3J0cyBtYXAgYSBjdWJlLW1hcCBvbnRvIGEgMkQgdGV4dHVyZSB3aXRoIHRoZVxuXHRcdC8vIGZvbGxvd2luZyBvcmllbnRhdGlvbjpcblx0XHQvL1xuXHRcdC8vXHR4elhaXG5cdFx0Ly9cdCB5IFlcblx0XHQvL1xuXHRcdC8vIFggLSBQb3NpdGl2ZSB4IGRpcmVjdGlvblxuXHRcdC8vIHggLSBOZWdhdGl2ZSB4IGRpcmVjdGlvblxuXHRcdC8vIFkgLSBQb3NpdGl2ZSB5IGRpcmVjdGlvblxuXHRcdC8vIHkgLSBOZWdhdGl2ZSB5IGRpcmVjdGlvblxuXHRcdC8vIFogLSBQb3NpdGl2ZSB6IGRpcmVjdGlvblxuXHRcdC8vIHogLSBOZWdhdGl2ZSB6IGRpcmVjdGlvblxuXG5cdFx0Ly8gcG9zaXRpdmUgWFxuXHRcdG5ldyBWZWN0b3I0KDIsIDEsIDEsIDEpLFxuXHRcdC8vIG5lZ2F0aXZlIFhcblx0XHRuZXcgVmVjdG9yNCgwLCAxLCAxLCAxKSxcblx0XHQvLyBwb3NpdGl2ZSBaXG5cdFx0bmV3IFZlY3RvcjQoMywgMSwgMSwgMSksXG5cdFx0Ly8gbmVnYXRpdmUgWlxuXHRcdG5ldyBWZWN0b3I0KDEsIDEsIDEsIDEpLFxuXHRcdC8vIHBvc2l0aXZlIFlcblx0XHRuZXcgVmVjdG9yNCgzLCAwLCAxLCAxKSxcblx0XHQvLyBuZWdhdGl2ZSBZXG5cdFx0bmV3IFZlY3RvcjQoMSwgMCwgMSwgMSldO1xuXHRcdHRoaXMuX2N1YmVEaXJlY3Rpb25zID0gW25ldyBWZWN0b3IzKDEsIDAsIDApLCBuZXcgVmVjdG9yMygtMSwgMCwgMCksIG5ldyBWZWN0b3IzKDAsIDAsIDEpLCBuZXcgVmVjdG9yMygwLCAwLCAtMSksIG5ldyBWZWN0b3IzKDAsIDEsIDApLCBuZXcgVmVjdG9yMygwLCAtMSwgMCldO1xuXHRcdHRoaXMuX2N1YmVVcHMgPSBbbmV3IFZlY3RvcjMoMCwgMSwgMCksIG5ldyBWZWN0b3IzKDAsIDEsIDApLCBuZXcgVmVjdG9yMygwLCAxLCAwKSwgbmV3IFZlY3RvcjMoMCwgMSwgMCksIG5ldyBWZWN0b3IzKDAsIDAsIDEpLCBuZXcgVmVjdG9yMygwLCAwLCAtMSldO1xuXHR9XG5cdHVwZGF0ZU1hdHJpY2VzKGxpZ2h0LCB2aWV3cG9ydEluZGV4ID0gMCkge1xuXHRcdGNvbnN0IGNhbWVyYSA9IHRoaXMuY2FtZXJhO1xuXHRcdGNvbnN0IHNoYWRvd01hdHJpeCA9IHRoaXMubWF0cml4O1xuXHRcdGNvbnN0IGZhciA9IGxpZ2h0LmRpc3RhbmNlIHx8IGNhbWVyYS5mYXI7XG5cdFx0aWYgKGZhciAhPT0gY2FtZXJhLmZhcikge1xuXHRcdFx0Y2FtZXJhLmZhciA9IGZhcjtcblx0XHRcdGNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cdFx0fVxuXHRcdF9saWdodFBvc2l0aW9uV29ybGQuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGxpZ2h0Lm1hdHJpeFdvcmxkKTtcblx0XHRjYW1lcmEucG9zaXRpb24uY29weShfbGlnaHRQb3NpdGlvbldvcmxkKTtcblx0XHRfbG9va1RhcmdldC5jb3B5KGNhbWVyYS5wb3NpdGlvbik7XG5cdFx0X2xvb2tUYXJnZXQuYWRkKHRoaXMuX2N1YmVEaXJlY3Rpb25zW3ZpZXdwb3J0SW5kZXhdKTtcblx0XHRjYW1lcmEudXAuY29weSh0aGlzLl9jdWJlVXBzW3ZpZXdwb3J0SW5kZXhdKTtcblx0XHRjYW1lcmEubG9va0F0KF9sb29rVGFyZ2V0KTtcblx0XHRjYW1lcmEudXBkYXRlTWF0cml4V29ybGQoKTtcblx0XHRzaGFkb3dNYXRyaXgubWFrZVRyYW5zbGF0aW9uKC1fbGlnaHRQb3NpdGlvbldvcmxkLngsIC1fbGlnaHRQb3NpdGlvbldvcmxkLnksIC1fbGlnaHRQb3NpdGlvbldvcmxkLnopO1xuXHRcdF9wcm9qU2NyZWVuTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoY2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UpO1xuXHRcdHRoaXMuX2ZydXN0dW0uc2V0RnJvbVByb2plY3Rpb25NYXRyaXgoX3Byb2pTY3JlZW5NYXRyaXgpO1xuXHR9XG59XG5cbmNsYXNzIFBvaW50TGlnaHQgZXh0ZW5kcyBMaWdodCB7XG5cdGNvbnN0cnVjdG9yKGNvbG9yLCBpbnRlbnNpdHksIGRpc3RhbmNlID0gMCwgZGVjYXkgPSAxKSB7XG5cdFx0c3VwZXIoY29sb3IsIGludGVuc2l0eSk7XG5cdFx0dGhpcy5pc1BvaW50TGlnaHQgPSB0cnVlO1xuXHRcdHRoaXMudHlwZSA9ICdQb2ludExpZ2h0Jztcblx0XHR0aGlzLmRpc3RhbmNlID0gZGlzdGFuY2U7XG5cdFx0dGhpcy5kZWNheSA9IGRlY2F5OyAvLyBmb3IgcGh5c2ljYWxseSBjb3JyZWN0IGxpZ2h0cywgc2hvdWxkIGJlIDIuXG5cblx0XHR0aGlzLnNoYWRvdyA9IG5ldyBQb2ludExpZ2h0U2hhZG93KCk7XG5cdH1cblx0Z2V0IHBvd2VyKCkge1xuXHRcdC8vIGNvbXB1dGUgdGhlIGxpZ2h0J3MgbHVtaW5vdXMgcG93ZXIgKGluIGx1bWVucykgZnJvbSBpdHMgaW50ZW5zaXR5IChpbiBjYW5kZWxhKVxuXHRcdC8vIGZvciBhbiBpc290cm9waWMgbGlnaHQgc291cmNlLCBsdW1pbm91cyBwb3dlciAobG0pID0gNCDPgCBsdW1pbm91cyBpbnRlbnNpdHkgKGNkKVxuXHRcdHJldHVybiB0aGlzLmludGVuc2l0eSAqIDQgKiBNYXRoLlBJO1xuXHR9XG5cdHNldCBwb3dlcihwb3dlcikge1xuXHRcdC8vIHNldCB0aGUgbGlnaHQncyBpbnRlbnNpdHkgKGluIGNhbmRlbGEpIGZyb20gdGhlIGRlc2lyZWQgbHVtaW5vdXMgcG93ZXIgKGluIGx1bWVucylcblx0XHR0aGlzLmludGVuc2l0eSA9IHBvd2VyIC8gKDQgKiBNYXRoLlBJKTtcblx0fVxuXHRkaXNwb3NlKCkge1xuXHRcdHRoaXMuc2hhZG93LmRpc3Bvc2UoKTtcblx0fVxuXHRjb3B5KHNvdXJjZSwgcmVjdXJzaXZlKSB7XG5cdFx0c3VwZXIuY29weShzb3VyY2UsIHJlY3Vyc2l2ZSk7XG5cdFx0dGhpcy5kaXN0YW5jZSA9IHNvdXJjZS5kaXN0YW5jZTtcblx0XHR0aGlzLmRlY2F5ID0gc291cmNlLmRlY2F5O1xuXHRcdHRoaXMuc2hhZG93ID0gc291cmNlLnNoYWRvdy5jbG9uZSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59XG5cbmNsYXNzIERpcmVjdGlvbmFsTGlnaHRTaGFkb3cgZXh0ZW5kcyBMaWdodFNoYWRvdyB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKG5ldyBPcnRob2dyYXBoaWNDYW1lcmEoLTUsIDUsIDUsIC01LCAwLjUsIDUwMCkpO1xuXHRcdHRoaXMuaXNEaXJlY3Rpb25hbExpZ2h0U2hhZG93ID0gdHJ1ZTtcblx0fVxufVxuXG5jbGFzcyBEaXJlY3Rpb25hbExpZ2h0IGV4dGVuZHMgTGlnaHQge1xuXHRjb25zdHJ1Y3Rvcihjb2xvciwgaW50ZW5zaXR5KSB7XG5cdFx0c3VwZXIoY29sb3IsIGludGVuc2l0eSk7XG5cdFx0dGhpcy5pc0RpcmVjdGlvbmFsTGlnaHQgPSB0cnVlO1xuXHRcdHRoaXMudHlwZSA9ICdEaXJlY3Rpb25hbExpZ2h0Jztcblx0XHR0aGlzLnBvc2l0aW9uLmNvcHkoT2JqZWN0M0QuRGVmYXVsdFVwKTtcblx0XHR0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXHRcdHRoaXMudGFyZ2V0ID0gbmV3IE9iamVjdDNEKCk7XG5cdFx0dGhpcy5zaGFkb3cgPSBuZXcgRGlyZWN0aW9uYWxMaWdodFNoYWRvdygpO1xuXHR9XG5cdGRpc3Bvc2UoKSB7XG5cdFx0dGhpcy5zaGFkb3cuZGlzcG9zZSgpO1xuXHR9XG5cdGNvcHkoc291cmNlKSB7XG5cdFx0c3VwZXIuY29weShzb3VyY2UpO1xuXHRcdHRoaXMudGFyZ2V0ID0gc291cmNlLnRhcmdldC5jbG9uZSgpO1xuXHRcdHRoaXMuc2hhZG93ID0gc291cmNlLnNoYWRvdy5jbG9uZSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59XG5cbmNsYXNzIEFtYmllbnRMaWdodCBleHRlbmRzIExpZ2h0IHtcblx0Y29uc3RydWN0b3IoY29sb3IsIGludGVuc2l0eSkge1xuXHRcdHN1cGVyKGNvbG9yLCBpbnRlbnNpdHkpO1xuXHRcdHRoaXMuaXNBbWJpZW50TGlnaHQgPSB0cnVlO1xuXHRcdHRoaXMudHlwZSA9ICdBbWJpZW50TGlnaHQnO1xuXHR9XG59XG5cbmNsYXNzIFJlY3RBcmVhTGlnaHQgZXh0ZW5kcyBMaWdodCB7XG5cdGNvbnN0cnVjdG9yKGNvbG9yLCBpbnRlbnNpdHksIHdpZHRoID0gMTAsIGhlaWdodCA9IDEwKSB7XG5cdFx0c3VwZXIoY29sb3IsIGludGVuc2l0eSk7XG5cdFx0dGhpcy5pc1JlY3RBcmVhTGlnaHQgPSB0cnVlO1xuXHRcdHRoaXMudHlwZSA9ICdSZWN0QXJlYUxpZ2h0Jztcblx0XHR0aGlzLndpZHRoID0gd2lkdGg7XG5cdFx0dGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cdH1cblx0Z2V0IHBvd2VyKCkge1xuXHRcdC8vIGNvbXB1dGUgdGhlIGxpZ2h0J3MgbHVtaW5vdXMgcG93ZXIgKGluIGx1bWVucykgZnJvbSBpdHMgaW50ZW5zaXR5IChpbiBuaXRzKVxuXHRcdHJldHVybiB0aGlzLmludGVuc2l0eSAqIHRoaXMud2lkdGggKiB0aGlzLmhlaWdodCAqIE1hdGguUEk7XG5cdH1cblx0c2V0IHBvd2VyKHBvd2VyKSB7XG5cdFx0Ly8gc2V0IHRoZSBsaWdodCdzIGludGVuc2l0eSAoaW4gbml0cykgZnJvbSB0aGUgZGVzaXJlZCBsdW1pbm91cyBwb3dlciAoaW4gbHVtZW5zKVxuXHRcdHRoaXMuaW50ZW5zaXR5ID0gcG93ZXIgLyAodGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0ICogTWF0aC5QSSk7XG5cdH1cblx0Y29weShzb3VyY2UpIHtcblx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0dGhpcy53aWR0aCA9IHNvdXJjZS53aWR0aDtcblx0XHR0aGlzLmhlaWdodCA9IHNvdXJjZS5oZWlnaHQ7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0dG9KU09OKG1ldGEpIHtcblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKG1ldGEpO1xuXHRcdGRhdGEub2JqZWN0LndpZHRoID0gdGhpcy53aWR0aDtcblx0XHRkYXRhLm9iamVjdC5oZWlnaHQgPSB0aGlzLmhlaWdodDtcblx0XHRyZXR1cm4gZGF0YTtcblx0fVxufVxuXG4vKipcbiAqIFByaW1hcnkgcmVmZXJlbmNlOlxuICpcdCBodHRwczovL2dyYXBoaWNzLnN0YW5mb3JkLmVkdS9wYXBlcnMvZW52bWFwL2Vudm1hcC5wZGZcbiAqXG4gKiBTZWNvbmRhcnkgcmVmZXJlbmNlOlxuICpcdCBodHRwczovL3d3dy5wcHNsb2FuLm9yZy9wdWJsaWNhdGlvbnMvU3R1cGlkU0gzNi5wZGZcbiAqL1xuXG4vLyAzLWJhbmQgU0ggZGVmaW5lZCBieSA5IGNvZWZmaWNpZW50c1xuXG5jbGFzcyBTcGhlcmljYWxIYXJtb25pY3MzIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0dGhpcy5pc1NwaGVyaWNhbEhhcm1vbmljczMgPSB0cnVlO1xuXHRcdHRoaXMuY29lZmZpY2llbnRzID0gW107XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCA5OyBpKyspIHtcblx0XHRcdHRoaXMuY29lZmZpY2llbnRzLnB1c2gobmV3IFZlY3RvcjMoKSk7XG5cdFx0fVxuXHR9XG5cdHNldChjb2VmZmljaWVudHMpIHtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDk7IGkrKykge1xuXHRcdFx0dGhpcy5jb2VmZmljaWVudHNbaV0uY29weShjb2VmZmljaWVudHNbaV0pO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHR6ZXJvKCkge1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgOTsgaSsrKSB7XG5cdFx0XHR0aGlzLmNvZWZmaWNpZW50c1tpXS5zZXQoMCwgMCwgMCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0Ly8gZ2V0IHRoZSByYWRpYW5jZSBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBub3JtYWxcblx0Ly8gdGFyZ2V0IGlzIGEgVmVjdG9yM1xuXHRnZXRBdChub3JtYWwsIHRhcmdldCkge1xuXHRcdC8vIG5vcm1hbCBpcyBhc3N1bWVkIHRvIGJlIHVuaXQgbGVuZ3RoXG5cblx0XHRjb25zdCB4ID0gbm9ybWFsLngsXG5cdFx0XHR5ID0gbm9ybWFsLnksXG5cdFx0XHR6ID0gbm9ybWFsLno7XG5cdFx0Y29uc3QgY29lZmYgPSB0aGlzLmNvZWZmaWNpZW50cztcblxuXHRcdC8vIGJhbmQgMFxuXHRcdHRhcmdldC5jb3B5KGNvZWZmWzBdKS5tdWx0aXBseVNjYWxhcigwLjI4MjA5NSk7XG5cblx0XHQvLyBiYW5kIDFcblx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKGNvZWZmWzFdLCAwLjQ4ODYwMyAqIHkpO1xuXHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoY29lZmZbMl0sIDAuNDg4NjAzICogeik7XG5cdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3Rvcihjb2VmZlszXSwgMC40ODg2MDMgKiB4KTtcblxuXHRcdC8vIGJhbmQgMlxuXHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoY29lZmZbNF0sIDEuMDkyNTQ4ICogKHggKiB5KSk7XG5cdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3Rvcihjb2VmZls1XSwgMS4wOTI1NDggKiAoeSAqIHopKTtcblx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKGNvZWZmWzZdLCAwLjMxNTM5MiAqICgzLjAgKiB6ICogeiAtIDEuMCkpO1xuXHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoY29lZmZbN10sIDEuMDkyNTQ4ICogKHggKiB6KSk7XG5cdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3Rvcihjb2VmZls4XSwgMC41NDYyNzQgKiAoeCAqIHggLSB5ICogeSkpO1xuXHRcdHJldHVybiB0YXJnZXQ7XG5cdH1cblxuXHQvLyBnZXQgdGhlIGlycmFkaWFuY2UgKHJhZGlhbmNlIGNvbnZvbHZlZCB3aXRoIGNvc2luZSBsb2JlKSBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBub3JtYWxcblx0Ly8gdGFyZ2V0IGlzIGEgVmVjdG9yM1xuXHQvLyBodHRwczovL2dyYXBoaWNzLnN0YW5mb3JkLmVkdS9wYXBlcnMvZW52bWFwL2Vudm1hcC5wZGZcblx0Z2V0SXJyYWRpYW5jZUF0KG5vcm1hbCwgdGFyZ2V0KSB7XG5cdFx0Ly8gbm9ybWFsIGlzIGFzc3VtZWQgdG8gYmUgdW5pdCBsZW5ndGhcblxuXHRcdGNvbnN0IHggPSBub3JtYWwueCxcblx0XHRcdHkgPSBub3JtYWwueSxcblx0XHRcdHogPSBub3JtYWwuejtcblx0XHRjb25zdCBjb2VmZiA9IHRoaXMuY29lZmZpY2llbnRzO1xuXG5cdFx0Ly8gYmFuZCAwXG5cdFx0dGFyZ2V0LmNvcHkoY29lZmZbMF0pLm11bHRpcGx5U2NhbGFyKDAuODg2MjI3KTsgLy8gz4AgKiAwLjI4MjA5NVxuXG5cdFx0Ly8gYmFuZCAxXG5cdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3Rvcihjb2VmZlsxXSwgMi4wICogMC41MTE2NjQgKiB5KTsgLy8gKCAyICogz4AgLyAzICkgKiAwLjQ4ODYwM1xuXHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoY29lZmZbMl0sIDIuMCAqIDAuNTExNjY0ICogeik7XG5cdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3Rvcihjb2VmZlszXSwgMi4wICogMC41MTE2NjQgKiB4KTtcblxuXHRcdC8vIGJhbmQgMlxuXHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoY29lZmZbNF0sIDIuMCAqIDAuNDI5MDQzICogeCAqIHkpOyAvLyAoIM+AIC8gNCApICogMS4wOTI1NDhcblx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKGNvZWZmWzVdLCAyLjAgKiAwLjQyOTA0MyAqIHkgKiB6KTtcblx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKGNvZWZmWzZdLCAwLjc0MzEyNSAqIHogKiB6IC0gMC4yNDc3MDgpOyAvLyAoIM+AIC8gNCApICogMC4zMTUzOTIgKiAzXG5cdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3Rvcihjb2VmZls3XSwgMi4wICogMC40MjkwNDMgKiB4ICogeik7XG5cdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3Rvcihjb2VmZls4XSwgMC40MjkwNDMgKiAoeCAqIHggLSB5ICogeSkpOyAvLyAoIM+AIC8gNCApICogMC41NDYyNzRcblxuXHRcdHJldHVybiB0YXJnZXQ7XG5cdH1cblx0YWRkKHNoKSB7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCA5OyBpKyspIHtcblx0XHRcdHRoaXMuY29lZmZpY2llbnRzW2ldLmFkZChzaC5jb2VmZmljaWVudHNbaV0pO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRhZGRTY2FsZWRTSChzaCwgcykge1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgOTsgaSsrKSB7XG5cdFx0XHR0aGlzLmNvZWZmaWNpZW50c1tpXS5hZGRTY2FsZWRWZWN0b3Ioc2guY29lZmZpY2llbnRzW2ldLCBzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0c2NhbGUocykge1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgOTsgaSsrKSB7XG5cdFx0XHR0aGlzLmNvZWZmaWNpZW50c1tpXS5tdWx0aXBseVNjYWxhcihzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0bGVycChzaCwgYWxwaGEpIHtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDk7IGkrKykge1xuXHRcdFx0dGhpcy5jb2VmZmljaWVudHNbaV0ubGVycChzaC5jb2VmZmljaWVudHNbaV0sIGFscGhhKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0ZXF1YWxzKHNoKSB7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCA5OyBpKyspIHtcblx0XHRcdGlmICghdGhpcy5jb2VmZmljaWVudHNbaV0uZXF1YWxzKHNoLmNvZWZmaWNpZW50c1tpXSkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRjb3B5KHNoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0KHNoLmNvZWZmaWNpZW50cyk7XG5cdH1cblx0Y2xvbmUoKSB7XG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKTtcblx0fVxuXHRmcm9tQXJyYXkoYXJyYXksIG9mZnNldCA9IDApIHtcblx0XHRjb25zdCBjb2VmZmljaWVudHMgPSB0aGlzLmNvZWZmaWNpZW50cztcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDk7IGkrKykge1xuXHRcdFx0Y29lZmZpY2llbnRzW2ldLmZyb21BcnJheShhcnJheSwgb2Zmc2V0ICsgaSAqIDMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHR0b0FycmF5KGFycmF5ID0gW10sIG9mZnNldCA9IDApIHtcblx0XHRjb25zdCBjb2VmZmljaWVudHMgPSB0aGlzLmNvZWZmaWNpZW50cztcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDk7IGkrKykge1xuXHRcdFx0Y29lZmZpY2llbnRzW2ldLnRvQXJyYXkoYXJyYXksIG9mZnNldCArIGkgKiAzKTtcblx0XHR9XG5cdFx0cmV0dXJuIGFycmF5O1xuXHR9XG5cblx0Ly8gZXZhbHVhdGUgdGhlIGJhc2lzIGZ1bmN0aW9uc1xuXHQvLyBzaEJhc2lzIGlzIGFuIEFycmF5WyA5IF1cblx0c3RhdGljIGdldEJhc2lzQXQobm9ybWFsLCBzaEJhc2lzKSB7XG5cdFx0Ly8gbm9ybWFsIGlzIGFzc3VtZWQgdG8gYmUgdW5pdCBsZW5ndGhcblxuXHRcdGNvbnN0IHggPSBub3JtYWwueCxcblx0XHRcdHkgPSBub3JtYWwueSxcblx0XHRcdHogPSBub3JtYWwuejtcblxuXHRcdC8vIGJhbmQgMFxuXHRcdHNoQmFzaXNbMF0gPSAwLjI4MjA5NTtcblxuXHRcdC8vIGJhbmQgMVxuXHRcdHNoQmFzaXNbMV0gPSAwLjQ4ODYwMyAqIHk7XG5cdFx0c2hCYXNpc1syXSA9IDAuNDg4NjAzICogejtcblx0XHRzaEJhc2lzWzNdID0gMC40ODg2MDMgKiB4O1xuXG5cdFx0Ly8gYmFuZCAyXG5cdFx0c2hCYXNpc1s0XSA9IDEuMDkyNTQ4ICogeCAqIHk7XG5cdFx0c2hCYXNpc1s1XSA9IDEuMDkyNTQ4ICogeSAqIHo7XG5cdFx0c2hCYXNpc1s2XSA9IDAuMzE1MzkyICogKDMgKiB6ICogeiAtIDEpO1xuXHRcdHNoQmFzaXNbN10gPSAxLjA5MjU0OCAqIHggKiB6O1xuXHRcdHNoQmFzaXNbOF0gPSAwLjU0NjI3NCAqICh4ICogeCAtIHkgKiB5KTtcblx0fVxufVxuXG5jbGFzcyBMaWdodFByb2JlIGV4dGVuZHMgTGlnaHQge1xuXHRjb25zdHJ1Y3RvcihzaCA9IG5ldyBTcGhlcmljYWxIYXJtb25pY3MzKCksIGludGVuc2l0eSA9IDEpIHtcblx0XHRzdXBlcih1bmRlZmluZWQsIGludGVuc2l0eSk7XG5cdFx0dGhpcy5pc0xpZ2h0UHJvYmUgPSB0cnVlO1xuXHRcdHRoaXMuc2ggPSBzaDtcblx0fVxuXHRjb3B5KHNvdXJjZSkge1xuXHRcdHN1cGVyLmNvcHkoc291cmNlKTtcblx0XHR0aGlzLnNoLmNvcHkoc291cmNlLnNoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRmcm9tSlNPTihqc29uKSB7XG5cdFx0dGhpcy5pbnRlbnNpdHkgPSBqc29uLmludGVuc2l0eTsgLy8gVE9ETzogTW92ZSB0aGlzIGJpdCB0byBMaWdodC5mcm9tSlNPTigpO1xuXHRcdHRoaXMuc2guZnJvbUFycmF5KGpzb24uc2gpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHRvSlNPTihtZXRhKSB7XG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTihtZXRhKTtcblx0XHRkYXRhLm9iamVjdC5zaCA9IHRoaXMuc2gudG9BcnJheSgpO1xuXHRcdHJldHVybiBkYXRhO1xuXHR9XG59XG5cbmNsYXNzIE1hdGVyaWFsTG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcblx0Y29uc3RydWN0b3IobWFuYWdlcikge1xuXHRcdHN1cGVyKG1hbmFnZXIpO1xuXHRcdHRoaXMudGV4dHVyZXMgPSB7fTtcblx0fVxuXHRsb2FkKHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yKSB7XG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXHRcdGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKHNjb3BlLm1hbmFnZXIpO1xuXHRcdGxvYWRlci5zZXRQYXRoKHNjb3BlLnBhdGgpO1xuXHRcdGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKHNjb3BlLnJlcXVlc3RIZWFkZXIpO1xuXHRcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoc2NvcGUud2l0aENyZWRlbnRpYWxzKTtcblx0XHRsb2FkZXIubG9hZCh1cmwsIGZ1bmN0aW9uICh0ZXh0KSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRvbkxvYWQoc2NvcGUucGFyc2UoSlNPTi5wYXJzZSh0ZXh0KSkpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRpZiAob25FcnJvcikge1xuXHRcdFx0XHRcdG9uRXJyb3IoZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcihlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvcih1cmwpO1xuXHRcdFx0fVxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpO1xuXHR9XG5cdHBhcnNlKGpzb24pIHtcblx0XHRjb25zdCB0ZXh0dXJlcyA9IHRoaXMudGV4dHVyZXM7XG5cdFx0ZnVuY3Rpb24gZ2V0VGV4dHVyZShuYW1lKSB7XG5cdFx0XHRpZiAodGV4dHVyZXNbbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLk1hdGVyaWFsTG9hZGVyOiBVbmRlZmluZWQgdGV4dHVyZScsIG5hbWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRleHR1cmVzW25hbWVdO1xuXHRcdH1cblx0XHRjb25zdCBtYXRlcmlhbCA9IE1hdGVyaWFsTG9hZGVyLmNyZWF0ZU1hdGVyaWFsRnJvbVR5cGUoanNvbi50eXBlKTtcblx0XHRpZiAoanNvbi51dWlkICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnV1aWQgPSBqc29uLnV1aWQ7XG5cdFx0aWYgKGpzb24ubmFtZSAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5uYW1lID0ganNvbi5uYW1lO1xuXHRcdGlmIChqc29uLmNvbG9yICE9PSB1bmRlZmluZWQgJiYgbWF0ZXJpYWwuY29sb3IgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuY29sb3Iuc2V0SGV4KGpzb24uY29sb3IpO1xuXHRcdGlmIChqc29uLnJvdWdobmVzcyAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5yb3VnaG5lc3MgPSBqc29uLnJvdWdobmVzcztcblx0XHRpZiAoanNvbi5tZXRhbG5lc3MgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwubWV0YWxuZXNzID0ganNvbi5tZXRhbG5lc3M7XG5cdFx0aWYgKGpzb24uc2hlZW4gIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuc2hlZW4gPSBqc29uLnNoZWVuO1xuXHRcdGlmIChqc29uLnNoZWVuQ29sb3IgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuc2hlZW5Db2xvciA9IG5ldyBDb2xvcigpLnNldEhleChqc29uLnNoZWVuQ29sb3IpO1xuXHRcdGlmIChqc29uLnNoZWVuUm91Z2huZXNzICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnNoZWVuUm91Z2huZXNzID0ganNvbi5zaGVlblJvdWdobmVzcztcblx0XHRpZiAoanNvbi5lbWlzc2l2ZSAhPT0gdW5kZWZpbmVkICYmIG1hdGVyaWFsLmVtaXNzaXZlICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmVtaXNzaXZlLnNldEhleChqc29uLmVtaXNzaXZlKTtcblx0XHRpZiAoanNvbi5zcGVjdWxhciAhPT0gdW5kZWZpbmVkICYmIG1hdGVyaWFsLnNwZWN1bGFyICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnNwZWN1bGFyLnNldEhleChqc29uLnNwZWN1bGFyKTtcblx0XHRpZiAoanNvbi5zcGVjdWxhckludGVuc2l0eSAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5zcGVjdWxhckludGVuc2l0eSA9IGpzb24uc3BlY3VsYXJJbnRlbnNpdHk7XG5cdFx0aWYgKGpzb24uc3BlY3VsYXJDb2xvciAhPT0gdW5kZWZpbmVkICYmIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvci5zZXRIZXgoanNvbi5zcGVjdWxhckNvbG9yKTtcblx0XHRpZiAoanNvbi5zaGluaW5lc3MgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuc2hpbmluZXNzID0ganNvbi5zaGluaW5lc3M7XG5cdFx0aWYgKGpzb24uY2xlYXJjb2F0ICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmNsZWFyY29hdCA9IGpzb24uY2xlYXJjb2F0O1xuXHRcdGlmIChqc29uLmNsZWFyY29hdFJvdWdobmVzcyAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MgPSBqc29uLmNsZWFyY29hdFJvdWdobmVzcztcblx0XHRpZiAoanNvbi5pcmlkZXNjZW5jZSAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5pcmlkZXNjZW5jZSA9IGpzb24uaXJpZGVzY2VuY2U7XG5cdFx0aWYgKGpzb24uaXJpZGVzY2VuY2VJT1IgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuaXJpZGVzY2VuY2VJT1IgPSBqc29uLmlyaWRlc2NlbmNlSU9SO1xuXHRcdGlmIChqc29uLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2UgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZSA9IGpzb24uaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZTtcblx0XHRpZiAoanNvbi50cmFuc21pc3Npb24gIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwudHJhbnNtaXNzaW9uID0ganNvbi50cmFuc21pc3Npb247XG5cdFx0aWYgKGpzb24udGhpY2tuZXNzICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnRoaWNrbmVzcyA9IGpzb24udGhpY2tuZXNzO1xuXHRcdGlmIChqc29uLmF0dGVudWF0aW9uRGlzdGFuY2UgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuYXR0ZW51YXRpb25EaXN0YW5jZSA9IGpzb24uYXR0ZW51YXRpb25EaXN0YW5jZTtcblx0XHRpZiAoanNvbi5hdHRlbnVhdGlvbkNvbG9yICE9PSB1bmRlZmluZWQgJiYgbWF0ZXJpYWwuYXR0ZW51YXRpb25Db2xvciAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5hdHRlbnVhdGlvbkNvbG9yLnNldEhleChqc29uLmF0dGVudWF0aW9uQ29sb3IpO1xuXHRcdGlmIChqc29uLmZvZyAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5mb2cgPSBqc29uLmZvZztcblx0XHRpZiAoanNvbi5mbGF0U2hhZGluZyAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5mbGF0U2hhZGluZyA9IGpzb24uZmxhdFNoYWRpbmc7XG5cdFx0aWYgKGpzb24uYmxlbmRpbmcgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuYmxlbmRpbmcgPSBqc29uLmJsZW5kaW5nO1xuXHRcdGlmIChqc29uLmNvbWJpbmUgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuY29tYmluZSA9IGpzb24uY29tYmluZTtcblx0XHRpZiAoanNvbi5zaWRlICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnNpZGUgPSBqc29uLnNpZGU7XG5cdFx0aWYgKGpzb24uc2hhZG93U2lkZSAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5zaGFkb3dTaWRlID0ganNvbi5zaGFkb3dTaWRlO1xuXHRcdGlmIChqc29uLm9wYWNpdHkgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwub3BhY2l0eSA9IGpzb24ub3BhY2l0eTtcblx0XHRpZiAoanNvbi50cmFuc3BhcmVudCAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC50cmFuc3BhcmVudCA9IGpzb24udHJhbnNwYXJlbnQ7XG5cdFx0aWYgKGpzb24uYWxwaGFUZXN0ICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmFscGhhVGVzdCA9IGpzb24uYWxwaGFUZXN0O1xuXHRcdGlmIChqc29uLmRlcHRoVGVzdCAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5kZXB0aFRlc3QgPSBqc29uLmRlcHRoVGVzdDtcblx0XHRpZiAoanNvbi5kZXB0aFdyaXRlICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmRlcHRoV3JpdGUgPSBqc29uLmRlcHRoV3JpdGU7XG5cdFx0aWYgKGpzb24uY29sb3JXcml0ZSAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5jb2xvcldyaXRlID0ganNvbi5jb2xvcldyaXRlO1xuXHRcdGlmIChqc29uLnN0ZW5jaWxXcml0ZSAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5zdGVuY2lsV3JpdGUgPSBqc29uLnN0ZW5jaWxXcml0ZTtcblx0XHRpZiAoanNvbi5zdGVuY2lsV3JpdGVNYXNrICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnN0ZW5jaWxXcml0ZU1hc2sgPSBqc29uLnN0ZW5jaWxXcml0ZU1hc2s7XG5cdFx0aWYgKGpzb24uc3RlbmNpbEZ1bmMgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuc3RlbmNpbEZ1bmMgPSBqc29uLnN0ZW5jaWxGdW5jO1xuXHRcdGlmIChqc29uLnN0ZW5jaWxSZWYgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuc3RlbmNpbFJlZiA9IGpzb24uc3RlbmNpbFJlZjtcblx0XHRpZiAoanNvbi5zdGVuY2lsRnVuY01hc2sgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuc3RlbmNpbEZ1bmNNYXNrID0ganNvbi5zdGVuY2lsRnVuY01hc2s7XG5cdFx0aWYgKGpzb24uc3RlbmNpbEZhaWwgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuc3RlbmNpbEZhaWwgPSBqc29uLnN0ZW5jaWxGYWlsO1xuXHRcdGlmIChqc29uLnN0ZW5jaWxaRmFpbCAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5zdGVuY2lsWkZhaWwgPSBqc29uLnN0ZW5jaWxaRmFpbDtcblx0XHRpZiAoanNvbi5zdGVuY2lsWlBhc3MgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuc3RlbmNpbFpQYXNzID0ganNvbi5zdGVuY2lsWlBhc3M7XG5cdFx0aWYgKGpzb24ud2lyZWZyYW1lICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLndpcmVmcmFtZSA9IGpzb24ud2lyZWZyYW1lO1xuXHRcdGlmIChqc29uLndpcmVmcmFtZUxpbmV3aWR0aCAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGggPSBqc29uLndpcmVmcmFtZUxpbmV3aWR0aDtcblx0XHRpZiAoanNvbi53aXJlZnJhbWVMaW5lY2FwICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLndpcmVmcmFtZUxpbmVjYXAgPSBqc29uLndpcmVmcmFtZUxpbmVjYXA7XG5cdFx0aWYgKGpzb24ud2lyZWZyYW1lTGluZWpvaW4gIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwud2lyZWZyYW1lTGluZWpvaW4gPSBqc29uLndpcmVmcmFtZUxpbmVqb2luO1xuXHRcdGlmIChqc29uLnJvdGF0aW9uICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnJvdGF0aW9uID0ganNvbi5yb3RhdGlvbjtcblx0XHRpZiAoanNvbi5saW5ld2lkdGggIT09IDEpIG1hdGVyaWFsLmxpbmV3aWR0aCA9IGpzb24ubGluZXdpZHRoO1xuXHRcdGlmIChqc29uLmRhc2hTaXplICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmRhc2hTaXplID0ganNvbi5kYXNoU2l6ZTtcblx0XHRpZiAoanNvbi5nYXBTaXplICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmdhcFNpemUgPSBqc29uLmdhcFNpemU7XG5cdFx0aWYgKGpzb24uc2NhbGUgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuc2NhbGUgPSBqc29uLnNjYWxlO1xuXHRcdGlmIChqc29uLnBvbHlnb25PZmZzZXQgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwucG9seWdvbk9mZnNldCA9IGpzb24ucG9seWdvbk9mZnNldDtcblx0XHRpZiAoanNvbi5wb2x5Z29uT2Zmc2V0RmFjdG9yICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnBvbHlnb25PZmZzZXRGYWN0b3IgPSBqc29uLnBvbHlnb25PZmZzZXRGYWN0b3I7XG5cdFx0aWYgKGpzb24ucG9seWdvbk9mZnNldFVuaXRzICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnBvbHlnb25PZmZzZXRVbml0cyA9IGpzb24ucG9seWdvbk9mZnNldFVuaXRzO1xuXHRcdGlmIChqc29uLmRpdGhlcmluZyAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5kaXRoZXJpbmcgPSBqc29uLmRpdGhlcmluZztcblx0XHRpZiAoanNvbi5hbHBoYVRvQ292ZXJhZ2UgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuYWxwaGFUb0NvdmVyYWdlID0ganNvbi5hbHBoYVRvQ292ZXJhZ2U7XG5cdFx0aWYgKGpzb24ucHJlbXVsdGlwbGllZEFscGhhICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnByZW11bHRpcGxpZWRBbHBoYSA9IGpzb24ucHJlbXVsdGlwbGllZEFscGhhO1xuXHRcdGlmIChqc29uLnZpc2libGUgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwudmlzaWJsZSA9IGpzb24udmlzaWJsZTtcblx0XHRpZiAoanNvbi50b25lTWFwcGVkICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnRvbmVNYXBwZWQgPSBqc29uLnRvbmVNYXBwZWQ7XG5cdFx0aWYgKGpzb24udXNlckRhdGEgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwudXNlckRhdGEgPSBqc29uLnVzZXJEYXRhO1xuXHRcdGlmIChqc29uLnZlcnRleENvbG9ycyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRpZiAodHlwZW9mIGpzb24udmVydGV4Q29sb3JzID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSBqc29uLnZlcnRleENvbG9ycyA+IDAgPyB0cnVlIDogZmFsc2U7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSBqc29uLnZlcnRleENvbG9ycztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTaGFkZXIgTWF0ZXJpYWxcblxuXHRcdGlmIChqc29uLnVuaWZvcm1zICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGZvciAoY29uc3QgbmFtZSBpbiBqc29uLnVuaWZvcm1zKSB7XG5cdFx0XHRcdGNvbnN0IHVuaWZvcm0gPSBqc29uLnVuaWZvcm1zW25hbWVdO1xuXHRcdFx0XHRtYXRlcmlhbC51bmlmb3Jtc1tuYW1lXSA9IHt9O1xuXHRcdFx0XHRzd2l0Y2ggKHVuaWZvcm0udHlwZSkge1xuXHRcdFx0XHRcdGNhc2UgJ3QnOlxuXHRcdFx0XHRcdFx0bWF0ZXJpYWwudW5pZm9ybXNbbmFtZV0udmFsdWUgPSBnZXRUZXh0dXJlKHVuaWZvcm0udmFsdWUpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnYyc6XG5cdFx0XHRcdFx0XHRtYXRlcmlhbC51bmlmb3Jtc1tuYW1lXS52YWx1ZSA9IG5ldyBDb2xvcigpLnNldEhleCh1bmlmb3JtLnZhbHVlKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ3YyJzpcblx0XHRcdFx0XHRcdG1hdGVyaWFsLnVuaWZvcm1zW25hbWVdLnZhbHVlID0gbmV3IFZlY3RvcjIoKS5mcm9tQXJyYXkodW5pZm9ybS52YWx1ZSk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICd2Myc6XG5cdFx0XHRcdFx0XHRtYXRlcmlhbC51bmlmb3Jtc1tuYW1lXS52YWx1ZSA9IG5ldyBWZWN0b3IzKCkuZnJvbUFycmF5KHVuaWZvcm0udmFsdWUpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAndjQnOlxuXHRcdFx0XHRcdFx0bWF0ZXJpYWwudW5pZm9ybXNbbmFtZV0udmFsdWUgPSBuZXcgVmVjdG9yNCgpLmZyb21BcnJheSh1bmlmb3JtLnZhbHVlKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ20zJzpcblx0XHRcdFx0XHRcdG1hdGVyaWFsLnVuaWZvcm1zW25hbWVdLnZhbHVlID0gbmV3IE1hdHJpeDMoKS5mcm9tQXJyYXkodW5pZm9ybS52YWx1ZSk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdtNCc6XG5cdFx0XHRcdFx0XHRtYXRlcmlhbC51bmlmb3Jtc1tuYW1lXS52YWx1ZSA9IG5ldyBNYXRyaXg0KCkuZnJvbUFycmF5KHVuaWZvcm0udmFsdWUpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdG1hdGVyaWFsLnVuaWZvcm1zW25hbWVdLnZhbHVlID0gdW5pZm9ybS52YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoanNvbi5kZWZpbmVzICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmRlZmluZXMgPSBqc29uLmRlZmluZXM7XG5cdFx0aWYgKGpzb24udmVydGV4U2hhZGVyICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnZlcnRleFNoYWRlciA9IGpzb24udmVydGV4U2hhZGVyO1xuXHRcdGlmIChqc29uLmZyYWdtZW50U2hhZGVyICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmZyYWdtZW50U2hhZGVyID0ganNvbi5mcmFnbWVudFNoYWRlcjtcblx0XHRpZiAoanNvbi5nbHNsVmVyc2lvbiAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5nbHNsVmVyc2lvbiA9IGpzb24uZ2xzbFZlcnNpb247XG5cdFx0aWYgKGpzb24uZXh0ZW5zaW9ucyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRmb3IgKGNvbnN0IGtleSBpbiBqc29uLmV4dGVuc2lvbnMpIHtcblx0XHRcdFx0bWF0ZXJpYWwuZXh0ZW5zaW9uc1trZXldID0ganNvbi5leHRlbnNpb25zW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gZm9yIFBvaW50c01hdGVyaWFsXG5cblx0XHRpZiAoanNvbi5zaXplICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnNpemUgPSBqc29uLnNpemU7XG5cdFx0aWYgKGpzb24uc2l6ZUF0dGVudWF0aW9uICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnNpemVBdHRlbnVhdGlvbiA9IGpzb24uc2l6ZUF0dGVudWF0aW9uO1xuXG5cdFx0Ly8gbWFwc1xuXG5cdFx0aWYgKGpzb24ubWFwICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLm1hcCA9IGdldFRleHR1cmUoanNvbi5tYXApO1xuXHRcdGlmIChqc29uLm1hdGNhcCAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5tYXRjYXAgPSBnZXRUZXh0dXJlKGpzb24ubWF0Y2FwKTtcblx0XHRpZiAoanNvbi5hbHBoYU1hcCAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5hbHBoYU1hcCA9IGdldFRleHR1cmUoanNvbi5hbHBoYU1hcCk7XG5cdFx0aWYgKGpzb24uYnVtcE1hcCAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5idW1wTWFwID0gZ2V0VGV4dHVyZShqc29uLmJ1bXBNYXApO1xuXHRcdGlmIChqc29uLmJ1bXBTY2FsZSAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5idW1wU2NhbGUgPSBqc29uLmJ1bXBTY2FsZTtcblx0XHRpZiAoanNvbi5ub3JtYWxNYXAgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwubm9ybWFsTWFwID0gZ2V0VGV4dHVyZShqc29uLm5vcm1hbE1hcCk7XG5cdFx0aWYgKGpzb24ubm9ybWFsTWFwVHlwZSAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5ub3JtYWxNYXBUeXBlID0ganNvbi5ub3JtYWxNYXBUeXBlO1xuXHRcdGlmIChqc29uLm5vcm1hbFNjYWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGxldCBub3JtYWxTY2FsZSA9IGpzb24ubm9ybWFsU2NhbGU7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShub3JtYWxTY2FsZSkgPT09IGZhbHNlKSB7XG5cdFx0XHRcdC8vIEJsZW5kZXIgZXhwb3J0ZXIgdXNlZCB0byBleHBvcnQgYSBzY2FsYXIuIFNlZSAjNzQ1OVxuXG5cdFx0XHRcdG5vcm1hbFNjYWxlID0gW25vcm1hbFNjYWxlLCBub3JtYWxTY2FsZV07XG5cdFx0XHR9XG5cdFx0XHRtYXRlcmlhbC5ub3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKCkuZnJvbUFycmF5KG5vcm1hbFNjYWxlKTtcblx0XHR9XG5cdFx0aWYgKGpzb24uZGlzcGxhY2VtZW50TWFwICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCA9IGdldFRleHR1cmUoanNvbi5kaXNwbGFjZW1lbnRNYXApO1xuXHRcdGlmIChqc29uLmRpc3BsYWNlbWVudFNjYWxlICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmRpc3BsYWNlbWVudFNjYWxlID0ganNvbi5kaXNwbGFjZW1lbnRTY2FsZTtcblx0XHRpZiAoanNvbi5kaXNwbGFjZW1lbnRCaWFzICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmRpc3BsYWNlbWVudEJpYXMgPSBqc29uLmRpc3BsYWNlbWVudEJpYXM7XG5cdFx0aWYgKGpzb24ucm91Z2huZXNzTWFwICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnJvdWdobmVzc01hcCA9IGdldFRleHR1cmUoanNvbi5yb3VnaG5lc3NNYXApO1xuXHRcdGlmIChqc29uLm1ldGFsbmVzc01hcCAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5tZXRhbG5lc3NNYXAgPSBnZXRUZXh0dXJlKGpzb24ubWV0YWxuZXNzTWFwKTtcblx0XHRpZiAoanNvbi5lbWlzc2l2ZU1hcCAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5lbWlzc2l2ZU1hcCA9IGdldFRleHR1cmUoanNvbi5lbWlzc2l2ZU1hcCk7XG5cdFx0aWYgKGpzb24uZW1pc3NpdmVJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuZW1pc3NpdmVJbnRlbnNpdHkgPSBqc29uLmVtaXNzaXZlSW50ZW5zaXR5O1xuXHRcdGlmIChqc29uLnNwZWN1bGFyTWFwICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnNwZWN1bGFyTWFwID0gZ2V0VGV4dHVyZShqc29uLnNwZWN1bGFyTWFwKTtcblx0XHRpZiAoanNvbi5zcGVjdWxhckludGVuc2l0eU1hcCAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5zcGVjdWxhckludGVuc2l0eU1hcCA9IGdldFRleHR1cmUoanNvbi5zcGVjdWxhckludGVuc2l0eU1hcCk7XG5cdFx0aWYgKGpzb24uc3BlY3VsYXJDb2xvck1hcCAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5zcGVjdWxhckNvbG9yTWFwID0gZ2V0VGV4dHVyZShqc29uLnNwZWN1bGFyQ29sb3JNYXApO1xuXHRcdGlmIChqc29uLmVudk1hcCAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5lbnZNYXAgPSBnZXRUZXh0dXJlKGpzb24uZW52TWFwKTtcblx0XHRpZiAoanNvbi5lbnZNYXBJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuZW52TWFwSW50ZW5zaXR5ID0ganNvbi5lbnZNYXBJbnRlbnNpdHk7XG5cdFx0aWYgKGpzb24ucmVmbGVjdGl2aXR5ICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnJlZmxlY3Rpdml0eSA9IGpzb24ucmVmbGVjdGl2aXR5O1xuXHRcdGlmIChqc29uLnJlZnJhY3Rpb25SYXRpbyAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5yZWZyYWN0aW9uUmF0aW8gPSBqc29uLnJlZnJhY3Rpb25SYXRpbztcblx0XHRpZiAoanNvbi5saWdodE1hcCAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5saWdodE1hcCA9IGdldFRleHR1cmUoanNvbi5saWdodE1hcCk7XG5cdFx0aWYgKGpzb24ubGlnaHRNYXBJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwubGlnaHRNYXBJbnRlbnNpdHkgPSBqc29uLmxpZ2h0TWFwSW50ZW5zaXR5O1xuXHRcdGlmIChqc29uLmFvTWFwICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmFvTWFwID0gZ2V0VGV4dHVyZShqc29uLmFvTWFwKTtcblx0XHRpZiAoanNvbi5hb01hcEludGVuc2l0eSAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5hb01hcEludGVuc2l0eSA9IGpzb24uYW9NYXBJbnRlbnNpdHk7XG5cdFx0aWYgKGpzb24uZ3JhZGllbnRNYXAgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuZ3JhZGllbnRNYXAgPSBnZXRUZXh0dXJlKGpzb24uZ3JhZGllbnRNYXApO1xuXHRcdGlmIChqc29uLmNsZWFyY29hdE1hcCAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5jbGVhcmNvYXRNYXAgPSBnZXRUZXh0dXJlKGpzb24uY2xlYXJjb2F0TWFwKTtcblx0XHRpZiAoanNvbi5jbGVhcmNvYXRSb3VnaG5lc3NNYXAgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzTWFwID0gZ2V0VGV4dHVyZShqc29uLmNsZWFyY29hdFJvdWdobmVzc01hcCk7XG5cdFx0aWYgKGpzb24uY2xlYXJjb2F0Tm9ybWFsTWFwICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmNsZWFyY29hdE5vcm1hbE1hcCA9IGdldFRleHR1cmUoanNvbi5jbGVhcmNvYXROb3JtYWxNYXApO1xuXHRcdGlmIChqc29uLmNsZWFyY29hdE5vcm1hbFNjYWxlICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmNsZWFyY29hdE5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoKS5mcm9tQXJyYXkoanNvbi5jbGVhcmNvYXROb3JtYWxTY2FsZSk7XG5cdFx0aWYgKGpzb24uaXJpZGVzY2VuY2VNYXAgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuaXJpZGVzY2VuY2VNYXAgPSBnZXRUZXh0dXJlKGpzb24uaXJpZGVzY2VuY2VNYXApO1xuXHRcdGlmIChqc29uLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwID0gZ2V0VGV4dHVyZShqc29uLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwKTtcblx0XHRpZiAoanNvbi50cmFuc21pc3Npb25NYXAgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwudHJhbnNtaXNzaW9uTWFwID0gZ2V0VGV4dHVyZShqc29uLnRyYW5zbWlzc2lvbk1hcCk7XG5cdFx0aWYgKGpzb24udGhpY2tuZXNzTWFwICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnRoaWNrbmVzc01hcCA9IGdldFRleHR1cmUoanNvbi50aGlja25lc3NNYXApO1xuXHRcdGlmIChqc29uLnNoZWVuQ29sb3JNYXAgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuc2hlZW5Db2xvck1hcCA9IGdldFRleHR1cmUoanNvbi5zaGVlbkNvbG9yTWFwKTtcblx0XHRpZiAoanNvbi5zaGVlblJvdWdobmVzc01hcCAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5zaGVlblJvdWdobmVzc01hcCA9IGdldFRleHR1cmUoanNvbi5zaGVlblJvdWdobmVzc01hcCk7XG5cdFx0cmV0dXJuIG1hdGVyaWFsO1xuXHR9XG5cdHNldFRleHR1cmVzKHZhbHVlKSB7XG5cdFx0dGhpcy50ZXh0dXJlcyA9IHZhbHVlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHN0YXRpYyBjcmVhdGVNYXRlcmlhbEZyb21UeXBlKHR5cGUpIHtcblx0XHRjb25zdCBtYXRlcmlhbExpYiA9IHtcblx0XHRcdFNoYWRvd01hdGVyaWFsLFxuXHRcdFx0U3ByaXRlTWF0ZXJpYWwsXG5cdFx0XHRSYXdTaGFkZXJNYXRlcmlhbCxcblx0XHRcdFNoYWRlck1hdGVyaWFsLFxuXHRcdFx0UG9pbnRzTWF0ZXJpYWwsXG5cdFx0XHRNZXNoUGh5c2ljYWxNYXRlcmlhbCxcblx0XHRcdE1lc2hTdGFuZGFyZE1hdGVyaWFsLFxuXHRcdFx0TWVzaFBob25nTWF0ZXJpYWwsXG5cdFx0XHRNZXNoVG9vbk1hdGVyaWFsLFxuXHRcdFx0TWVzaE5vcm1hbE1hdGVyaWFsLFxuXHRcdFx0TWVzaExhbWJlcnRNYXRlcmlhbCxcblx0XHRcdE1lc2hEZXB0aE1hdGVyaWFsLFxuXHRcdFx0TWVzaERpc3RhbmNlTWF0ZXJpYWwsXG5cdFx0XHRNZXNoQmFzaWNNYXRlcmlhbCxcblx0XHRcdE1lc2hNYXRjYXBNYXRlcmlhbCxcblx0XHRcdExpbmVEYXNoZWRNYXRlcmlhbCxcblx0XHRcdExpbmVCYXNpY01hdGVyaWFsLFxuXHRcdFx0TWF0ZXJpYWxcblx0XHR9O1xuXHRcdHJldHVybiBuZXcgbWF0ZXJpYWxMaWJbdHlwZV0oKTtcblx0fVxufVxuXG5jbGFzcyBMb2FkZXJVdGlscyB7XG5cdHN0YXRpYyBkZWNvZGVUZXh0KGFycmF5KSB7XG5cdFx0aWYgKHR5cGVvZiBUZXh0RGVjb2RlciAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYXJyYXkpO1xuXHRcdH1cblxuXHRcdC8vIEF2b2lkIHRoZSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGFycmF5KSBzaG9ydGN1dCwgd2hpY2hcblx0XHQvLyB0aHJvd3MgYSBcIm1heGltdW0gY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIgZXJyb3IgZm9yIGxhcmdlIGFycmF5cy5cblxuXHRcdGxldCBzID0gJyc7XG5cdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gYXJyYXkubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0Ly8gSW1wbGljaXRseSBhc3N1bWVzIGxpdHRsZS1lbmRpYW4uXG5cdFx0XHRzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYXJyYXlbaV0pO1xuXHRcdH1cblx0XHR0cnkge1xuXHRcdFx0Ly8gbWVyZ2VzIG11bHRpLWJ5dGUgdXRmLTggY2hhcmFjdGVycy5cblxuXHRcdFx0cmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUocykpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdC8vIHNlZSAjMTYzNThcblxuXHRcdFx0cmV0dXJuIHM7XG5cdFx0fVxuXHR9XG5cdHN0YXRpYyBleHRyYWN0VXJsQmFzZSh1cmwpIHtcblx0XHRjb25zdCBpbmRleCA9IHVybC5sYXN0SW5kZXhPZignLycpO1xuXHRcdGlmIChpbmRleCA9PT0gLTEpIHJldHVybiAnLi8nO1xuXHRcdHJldHVybiB1cmwuc2xpY2UoMCwgaW5kZXggKyAxKTtcblx0fVxuXHRzdGF0aWMgcmVzb2x2ZVVSTCh1cmwsIHBhdGgpIHtcblx0XHQvLyBJbnZhbGlkIFVSTFxuXHRcdGlmICh0eXBlb2YgdXJsICE9PSAnc3RyaW5nJyB8fCB1cmwgPT09ICcnKSByZXR1cm4gJyc7XG5cblx0XHQvLyBIb3N0IFJlbGF0aXZlIFVSTFxuXHRcdGlmICgvXmh0dHBzPzpcXC9cXC8vaS50ZXN0KHBhdGgpICYmIC9eXFwvLy50ZXN0KHVybCkpIHtcblx0XHRcdHBhdGggPSBwYXRoLnJlcGxhY2UoLyheaHR0cHM/OlxcL1xcL1teXFwvXSspLiovaSwgJyQxJyk7XG5cdFx0fVxuXG5cdFx0Ly8gQWJzb2x1dGUgVVJMIGh0dHA6Ly8saHR0cHM6Ly8sLy9cblx0XHRpZiAoL14oaHR0cHM/Oik/XFwvXFwvL2kudGVzdCh1cmwpKSByZXR1cm4gdXJsO1xuXG5cdFx0Ly8gRGF0YSBVUklcblx0XHRpZiAoL15kYXRhOi4qLC4qJC9pLnRlc3QodXJsKSkgcmV0dXJuIHVybDtcblxuXHRcdC8vIEJsb2IgVVJMXG5cdFx0aWYgKC9eYmxvYjouKiQvaS50ZXN0KHVybCkpIHJldHVybiB1cmw7XG5cblx0XHQvLyBSZWxhdGl2ZSBVUkxcblx0XHRyZXR1cm4gcGF0aCArIHVybDtcblx0fVxufVxuXG5jbGFzcyBJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLmlzSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgPSB0cnVlO1xuXHRcdHRoaXMudHlwZSA9ICdJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSc7XG5cdFx0dGhpcy5pbnN0YW5jZUNvdW50ID0gSW5maW5pdHk7XG5cdH1cblx0Y29weShzb3VyY2UpIHtcblx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0dGhpcy5pbnN0YW5jZUNvdW50ID0gc291cmNlLmluc3RhbmNlQ291bnQ7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0Y2xvbmUoKSB7XG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKTtcblx0fVxuXHR0b0pTT04oKSB7XG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTih0aGlzKTtcblx0XHRkYXRhLmluc3RhbmNlQ291bnQgPSB0aGlzLmluc3RhbmNlQ291bnQ7XG5cdFx0ZGF0YS5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5ID0gdHJ1ZTtcblx0XHRyZXR1cm4gZGF0YTtcblx0fVxufVxuXG5jbGFzcyBCdWZmZXJHZW9tZXRyeUxvYWRlciBleHRlbmRzIExvYWRlciB7XG5cdGNvbnN0cnVjdG9yKG1hbmFnZXIpIHtcblx0XHRzdXBlcihtYW5hZ2VyKTtcblx0fVxuXHRsb2FkKHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yKSB7XG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXHRcdGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKHNjb3BlLm1hbmFnZXIpO1xuXHRcdGxvYWRlci5zZXRQYXRoKHNjb3BlLnBhdGgpO1xuXHRcdGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKHNjb3BlLnJlcXVlc3RIZWFkZXIpO1xuXHRcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoc2NvcGUud2l0aENyZWRlbnRpYWxzKTtcblx0XHRsb2FkZXIubG9hZCh1cmwsIGZ1bmN0aW9uICh0ZXh0KSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRvbkxvYWQoc2NvcGUucGFyc2UoSlNPTi5wYXJzZSh0ZXh0KSkpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRpZiAob25FcnJvcikge1xuXHRcdFx0XHRcdG9uRXJyb3IoZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcihlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvcih1cmwpO1xuXHRcdFx0fVxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpO1xuXHR9XG5cdHBhcnNlKGpzb24pIHtcblx0XHRjb25zdCBpbnRlcmxlYXZlZEJ1ZmZlck1hcCA9IHt9O1xuXHRcdGNvbnN0IGFycmF5QnVmZmVyTWFwID0ge307XG5cdFx0ZnVuY3Rpb24gZ2V0SW50ZXJsZWF2ZWRCdWZmZXIoanNvbiwgdXVpZCkge1xuXHRcdFx0aWYgKGludGVybGVhdmVkQnVmZmVyTWFwW3V1aWRdICE9PSB1bmRlZmluZWQpIHJldHVybiBpbnRlcmxlYXZlZEJ1ZmZlck1hcFt1dWlkXTtcblx0XHRcdGNvbnN0IGludGVybGVhdmVkQnVmZmVycyA9IGpzb24uaW50ZXJsZWF2ZWRCdWZmZXJzO1xuXHRcdFx0Y29uc3QgaW50ZXJsZWF2ZWRCdWZmZXIgPSBpbnRlcmxlYXZlZEJ1ZmZlcnNbdXVpZF07XG5cdFx0XHRjb25zdCBidWZmZXIgPSBnZXRBcnJheUJ1ZmZlcihqc29uLCBpbnRlcmxlYXZlZEJ1ZmZlci5idWZmZXIpO1xuXHRcdFx0Y29uc3QgYXJyYXkgPSBnZXRUeXBlZEFycmF5KGludGVybGVhdmVkQnVmZmVyLnR5cGUsIGJ1ZmZlcik7XG5cdFx0XHRjb25zdCBpYiA9IG5ldyBJbnRlcmxlYXZlZEJ1ZmZlcihhcnJheSwgaW50ZXJsZWF2ZWRCdWZmZXIuc3RyaWRlKTtcblx0XHRcdGliLnV1aWQgPSBpbnRlcmxlYXZlZEJ1ZmZlci51dWlkO1xuXHRcdFx0aW50ZXJsZWF2ZWRCdWZmZXJNYXBbdXVpZF0gPSBpYjtcblx0XHRcdHJldHVybiBpYjtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gZ2V0QXJyYXlCdWZmZXIoanNvbiwgdXVpZCkge1xuXHRcdFx0aWYgKGFycmF5QnVmZmVyTWFwW3V1aWRdICE9PSB1bmRlZmluZWQpIHJldHVybiBhcnJheUJ1ZmZlck1hcFt1dWlkXTtcblx0XHRcdGNvbnN0IGFycmF5QnVmZmVycyA9IGpzb24uYXJyYXlCdWZmZXJzO1xuXHRcdFx0Y29uc3QgYXJyYXlCdWZmZXIgPSBhcnJheUJ1ZmZlcnNbdXVpZF07XG5cdFx0XHRjb25zdCBhYiA9IG5ldyBVaW50MzJBcnJheShhcnJheUJ1ZmZlcikuYnVmZmVyO1xuXHRcdFx0YXJyYXlCdWZmZXJNYXBbdXVpZF0gPSBhYjtcblx0XHRcdHJldHVybiBhYjtcblx0XHR9XG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSBqc29uLmlzSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgPyBuZXcgSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkoKSA6IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdGNvbnN0IGluZGV4ID0ganNvbi5kYXRhLmluZGV4O1xuXHRcdGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjb25zdCB0eXBlZEFycmF5ID0gZ2V0VHlwZWRBcnJheShpbmRleC50eXBlLCBpbmRleC5hcnJheSk7XG5cdFx0XHRnZW9tZXRyeS5zZXRJbmRleChuZXcgQnVmZmVyQXR0cmlidXRlKHR5cGVkQXJyYXksIDEpKTtcblx0XHR9XG5cdFx0Y29uc3QgYXR0cmlidXRlcyA9IGpzb24uZGF0YS5hdHRyaWJ1dGVzO1xuXHRcdGZvciAoY29uc3Qga2V5IGluIGF0dHJpYnV0ZXMpIHtcblx0XHRcdGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNba2V5XTtcblx0XHRcdGxldCBidWZmZXJBdHRyaWJ1dGU7XG5cdFx0XHRpZiAoYXR0cmlidXRlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUpIHtcblx0XHRcdFx0Y29uc3QgaW50ZXJsZWF2ZWRCdWZmZXIgPSBnZXRJbnRlcmxlYXZlZEJ1ZmZlcihqc29uLmRhdGEsIGF0dHJpYnV0ZS5kYXRhKTtcblx0XHRcdFx0YnVmZmVyQXR0cmlidXRlID0gbmV3IEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKGludGVybGVhdmVkQnVmZmVyLCBhdHRyaWJ1dGUuaXRlbVNpemUsIGF0dHJpYnV0ZS5vZmZzZXQsIGF0dHJpYnV0ZS5ub3JtYWxpemVkKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnN0IHR5cGVkQXJyYXkgPSBnZXRUeXBlZEFycmF5KGF0dHJpYnV0ZS50eXBlLCBhdHRyaWJ1dGUuYXJyYXkpO1xuXHRcdFx0XHRjb25zdCBidWZmZXJBdHRyaWJ1dGVDb25zdHIgPSBhdHRyaWJ1dGUuaXNJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgPyBJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgOiBCdWZmZXJBdHRyaWJ1dGU7XG5cdFx0XHRcdGJ1ZmZlckF0dHJpYnV0ZSA9IG5ldyBidWZmZXJBdHRyaWJ1dGVDb25zdHIodHlwZWRBcnJheSwgYXR0cmlidXRlLml0ZW1TaXplLCBhdHRyaWJ1dGUubm9ybWFsaXplZCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoYXR0cmlidXRlLm5hbWUgIT09IHVuZGVmaW5lZCkgYnVmZmVyQXR0cmlidXRlLm5hbWUgPSBhdHRyaWJ1dGUubmFtZTtcblx0XHRcdGlmIChhdHRyaWJ1dGUudXNhZ2UgIT09IHVuZGVmaW5lZCkgYnVmZmVyQXR0cmlidXRlLnNldFVzYWdlKGF0dHJpYnV0ZS51c2FnZSk7XG5cdFx0XHRpZiAoYXR0cmlidXRlLnVwZGF0ZVJhbmdlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0YnVmZmVyQXR0cmlidXRlLnVwZGF0ZVJhbmdlLm9mZnNldCA9IGF0dHJpYnV0ZS51cGRhdGVSYW5nZS5vZmZzZXQ7XG5cdFx0XHRcdGJ1ZmZlckF0dHJpYnV0ZS51cGRhdGVSYW5nZS5jb3VudCA9IGF0dHJpYnV0ZS51cGRhdGVSYW5nZS5jb3VudDtcblx0XHRcdH1cblx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZShrZXksIGJ1ZmZlckF0dHJpYnV0ZSk7XG5cdFx0fVxuXHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlcyA9IGpzb24uZGF0YS5tb3JwaEF0dHJpYnV0ZXM7XG5cdFx0aWYgKG1vcnBoQXR0cmlidXRlcykge1xuXHRcdFx0Zm9yIChjb25zdCBrZXkgaW4gbW9ycGhBdHRyaWJ1dGVzKSB7XG5cdFx0XHRcdGNvbnN0IGF0dHJpYnV0ZUFycmF5ID0gbW9ycGhBdHRyaWJ1dGVzW2tleV07XG5cdFx0XHRcdGNvbnN0IGFycmF5ID0gW107XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IGF0dHJpYnV0ZUFycmF5Lmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVBcnJheVtpXTtcblx0XHRcdFx0XHRsZXQgYnVmZmVyQXR0cmlidXRlO1xuXHRcdFx0XHRcdGlmIChhdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSkge1xuXHRcdFx0XHRcdFx0Y29uc3QgaW50ZXJsZWF2ZWRCdWZmZXIgPSBnZXRJbnRlcmxlYXZlZEJ1ZmZlcihqc29uLmRhdGEsIGF0dHJpYnV0ZS5kYXRhKTtcblx0XHRcdFx0XHRcdGJ1ZmZlckF0dHJpYnV0ZSA9IG5ldyBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZShpbnRlcmxlYXZlZEJ1ZmZlciwgYXR0cmlidXRlLml0ZW1TaXplLCBhdHRyaWJ1dGUub2Zmc2V0LCBhdHRyaWJ1dGUubm9ybWFsaXplZCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnN0IHR5cGVkQXJyYXkgPSBnZXRUeXBlZEFycmF5KGF0dHJpYnV0ZS50eXBlLCBhdHRyaWJ1dGUuYXJyYXkpO1xuXHRcdFx0XHRcdFx0YnVmZmVyQXR0cmlidXRlID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZSh0eXBlZEFycmF5LCBhdHRyaWJ1dGUuaXRlbVNpemUsIGF0dHJpYnV0ZS5ub3JtYWxpemVkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGF0dHJpYnV0ZS5uYW1lICE9PSB1bmRlZmluZWQpIGJ1ZmZlckF0dHJpYnV0ZS5uYW1lID0gYXR0cmlidXRlLm5hbWU7XG5cdFx0XHRcdFx0YXJyYXkucHVzaChidWZmZXJBdHRyaWJ1dGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlc1trZXldID0gYXJyYXk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNvbnN0IG1vcnBoVGFyZ2V0c1JlbGF0aXZlID0ganNvbi5kYXRhLm1vcnBoVGFyZ2V0c1JlbGF0aXZlO1xuXHRcdGlmIChtb3JwaFRhcmdldHNSZWxhdGl2ZSkge1xuXHRcdFx0Z2VvbWV0cnkubW9ycGhUYXJnZXRzUmVsYXRpdmUgPSB0cnVlO1xuXHRcdH1cblx0XHRjb25zdCBncm91cHMgPSBqc29uLmRhdGEuZ3JvdXBzIHx8IGpzb24uZGF0YS5kcmF3Y2FsbHMgfHwganNvbi5kYXRhLm9mZnNldHM7XG5cdFx0aWYgKGdyb3VwcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbiA9IGdyb3Vwcy5sZW5ndGg7IGkgIT09IG47ICsraSkge1xuXHRcdFx0XHRjb25zdCBncm91cCA9IGdyb3Vwc1tpXTtcblx0XHRcdFx0Z2VvbWV0cnkuYWRkR3JvdXAoZ3JvdXAuc3RhcnQsIGdyb3VwLmNvdW50LCBncm91cC5tYXRlcmlhbEluZGV4KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Y29uc3QgYm91bmRpbmdTcGhlcmUgPSBqc29uLmRhdGEuYm91bmRpbmdTcGhlcmU7XG5cdFx0aWYgKGJvdW5kaW5nU3BoZXJlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGNvbnN0IGNlbnRlciA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRpZiAoYm91bmRpbmdTcGhlcmUuY2VudGVyICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y2VudGVyLmZyb21BcnJheShib3VuZGluZ1NwaGVyZS5jZW50ZXIpO1xuXHRcdFx0fVxuXHRcdFx0Z2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPSBuZXcgU3BoZXJlKGNlbnRlciwgYm91bmRpbmdTcGhlcmUucmFkaXVzKTtcblx0XHR9XG5cdFx0aWYgKGpzb24ubmFtZSkgZ2VvbWV0cnkubmFtZSA9IGpzb24ubmFtZTtcblx0XHRpZiAoanNvbi51c2VyRGF0YSkgZ2VvbWV0cnkudXNlckRhdGEgPSBqc29uLnVzZXJEYXRhO1xuXHRcdHJldHVybiBnZW9tZXRyeTtcblx0fVxufVxuXG5jbGFzcyBPYmplY3RMb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuXHRjb25zdHJ1Y3RvcihtYW5hZ2VyKSB7XG5cdFx0c3VwZXIobWFuYWdlcik7XG5cdH1cblx0bG9hZCh1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvcikge1xuXHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblx0XHRjb25zdCBwYXRoID0gdGhpcy5wYXRoID09PSAnJyA/IExvYWRlclV0aWxzLmV4dHJhY3RVcmxCYXNlKHVybCkgOiB0aGlzLnBhdGg7XG5cdFx0dGhpcy5yZXNvdXJjZVBhdGggPSB0aGlzLnJlc291cmNlUGF0aCB8fCBwYXRoO1xuXHRcdGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKHRoaXMubWFuYWdlcik7XG5cdFx0bG9hZGVyLnNldFBhdGgodGhpcy5wYXRoKTtcblx0XHRsb2FkZXIuc2V0UmVxdWVzdEhlYWRlcih0aGlzLnJlcXVlc3RIZWFkZXIpO1xuXHRcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHModGhpcy53aXRoQ3JlZGVudGlhbHMpO1xuXHRcdGxvYWRlci5sb2FkKHVybCwgZnVuY3Rpb24gKHRleHQpIHtcblx0XHRcdGxldCBqc29uID0gbnVsbDtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGpzb24gPSBKU09OLnBhcnNlKHRleHQpO1xuXHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0aWYgKG9uRXJyb3IgIT09IHVuZGVmaW5lZCkgb25FcnJvcihlcnJvcik7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFOk9iamVjdExvYWRlcjogQ2FuXFwndCBwYXJzZSAnICsgdXJsICsgJy4nLCBlcnJvci5tZXNzYWdlKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Y29uc3QgbWV0YWRhdGEgPSBqc29uLm1ldGFkYXRhO1xuXHRcdFx0aWYgKG1ldGFkYXRhID09PSB1bmRlZmluZWQgfHwgbWV0YWRhdGEudHlwZSA9PT0gdW5kZWZpbmVkIHx8IG1ldGFkYXRhLnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ2dlb21ldHJ5Jykge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5PYmplY3RMb2FkZXI6IENhblxcJ3QgbG9hZCAnICsgdXJsKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0c2NvcGUucGFyc2UoanNvbiwgb25Mb2FkKTtcblx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yKTtcblx0fVxuXHRhc3luYyBsb2FkQXN5bmModXJsLCBvblByb2dyZXNzKSB7XG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXHRcdGNvbnN0IHBhdGggPSB0aGlzLnBhdGggPT09ICcnID8gTG9hZGVyVXRpbHMuZXh0cmFjdFVybEJhc2UodXJsKSA6IHRoaXMucGF0aDtcblx0XHR0aGlzLnJlc291cmNlUGF0aCA9IHRoaXMucmVzb3VyY2VQYXRoIHx8IHBhdGg7XG5cdFx0Y29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIodGhpcy5tYW5hZ2VyKTtcblx0XHRsb2FkZXIuc2V0UGF0aCh0aGlzLnBhdGgpO1xuXHRcdGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKHRoaXMucmVxdWVzdEhlYWRlcik7XG5cdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyh0aGlzLndpdGhDcmVkZW50aWFscyk7XG5cdFx0Y29uc3QgdGV4dCA9IGF3YWl0IGxvYWRlci5sb2FkQXN5bmModXJsLCBvblByb2dyZXNzKTtcblx0XHRjb25zdCBqc29uID0gSlNPTi5wYXJzZSh0ZXh0KTtcblx0XHRjb25zdCBtZXRhZGF0YSA9IGpzb24ubWV0YWRhdGE7XG5cdFx0aWYgKG1ldGFkYXRhID09PSB1bmRlZmluZWQgfHwgbWV0YWRhdGEudHlwZSA9PT0gdW5kZWZpbmVkIHx8IG1ldGFkYXRhLnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ2dlb21ldHJ5Jykge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdUSFJFRS5PYmplY3RMb2FkZXI6IENhblxcJ3QgbG9hZCAnICsgdXJsKTtcblx0XHR9XG5cdFx0cmV0dXJuIGF3YWl0IHNjb3BlLnBhcnNlQXN5bmMoanNvbik7XG5cdH1cblx0cGFyc2UoanNvbiwgb25Mb2FkKSB7XG5cdFx0Y29uc3QgYW5pbWF0aW9ucyA9IHRoaXMucGFyc2VBbmltYXRpb25zKGpzb24uYW5pbWF0aW9ucyk7XG5cdFx0Y29uc3Qgc2hhcGVzID0gdGhpcy5wYXJzZVNoYXBlcyhqc29uLnNoYXBlcyk7XG5cdFx0Y29uc3QgZ2VvbWV0cmllcyA9IHRoaXMucGFyc2VHZW9tZXRyaWVzKGpzb24uZ2VvbWV0cmllcywgc2hhcGVzKTtcblx0XHRjb25zdCBpbWFnZXMgPSB0aGlzLnBhcnNlSW1hZ2VzKGpzb24uaW1hZ2VzLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAob25Mb2FkICE9PSB1bmRlZmluZWQpIG9uTG9hZChvYmplY3QpO1xuXHRcdH0pO1xuXHRcdGNvbnN0IHRleHR1cmVzID0gdGhpcy5wYXJzZVRleHR1cmVzKGpzb24udGV4dHVyZXMsIGltYWdlcyk7XG5cdFx0Y29uc3QgbWF0ZXJpYWxzID0gdGhpcy5wYXJzZU1hdGVyaWFscyhqc29uLm1hdGVyaWFscywgdGV4dHVyZXMpO1xuXHRcdGNvbnN0IG9iamVjdCA9IHRoaXMucGFyc2VPYmplY3QoanNvbi5vYmplY3QsIGdlb21ldHJpZXMsIG1hdGVyaWFscywgdGV4dHVyZXMsIGFuaW1hdGlvbnMpO1xuXHRcdGNvbnN0IHNrZWxldG9ucyA9IHRoaXMucGFyc2VTa2VsZXRvbnMoanNvbi5za2VsZXRvbnMsIG9iamVjdCk7XG5cdFx0dGhpcy5iaW5kU2tlbGV0b25zKG9iamVjdCwgc2tlbGV0b25zKTtcblxuXHRcdC8vXG5cblx0XHRpZiAob25Mb2FkICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGxldCBoYXNJbWFnZXMgPSBmYWxzZTtcblx0XHRcdGZvciAoY29uc3QgdXVpZCBpbiBpbWFnZXMpIHtcblx0XHRcdFx0aWYgKGltYWdlc1t1dWlkXS5kYXRhIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkge1xuXHRcdFx0XHRcdGhhc0ltYWdlcyA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChoYXNJbWFnZXMgPT09IGZhbHNlKSBvbkxvYWQob2JqZWN0KTtcblx0XHR9XG5cdFx0cmV0dXJuIG9iamVjdDtcblx0fVxuXHRhc3luYyBwYXJzZUFzeW5jKGpzb24pIHtcblx0XHRjb25zdCBhbmltYXRpb25zID0gdGhpcy5wYXJzZUFuaW1hdGlvbnMoanNvbi5hbmltYXRpb25zKTtcblx0XHRjb25zdCBzaGFwZXMgPSB0aGlzLnBhcnNlU2hhcGVzKGpzb24uc2hhcGVzKTtcblx0XHRjb25zdCBnZW9tZXRyaWVzID0gdGhpcy5wYXJzZUdlb21ldHJpZXMoanNvbi5nZW9tZXRyaWVzLCBzaGFwZXMpO1xuXHRcdGNvbnN0IGltYWdlcyA9IGF3YWl0IHRoaXMucGFyc2VJbWFnZXNBc3luYyhqc29uLmltYWdlcyk7XG5cdFx0Y29uc3QgdGV4dHVyZXMgPSB0aGlzLnBhcnNlVGV4dHVyZXMoanNvbi50ZXh0dXJlcywgaW1hZ2VzKTtcblx0XHRjb25zdCBtYXRlcmlhbHMgPSB0aGlzLnBhcnNlTWF0ZXJpYWxzKGpzb24ubWF0ZXJpYWxzLCB0ZXh0dXJlcyk7XG5cdFx0Y29uc3Qgb2JqZWN0ID0gdGhpcy5wYXJzZU9iamVjdChqc29uLm9iamVjdCwgZ2VvbWV0cmllcywgbWF0ZXJpYWxzLCB0ZXh0dXJlcywgYW5pbWF0aW9ucyk7XG5cdFx0Y29uc3Qgc2tlbGV0b25zID0gdGhpcy5wYXJzZVNrZWxldG9ucyhqc29uLnNrZWxldG9ucywgb2JqZWN0KTtcblx0XHR0aGlzLmJpbmRTa2VsZXRvbnMob2JqZWN0LCBza2VsZXRvbnMpO1xuXHRcdHJldHVybiBvYmplY3Q7XG5cdH1cblx0cGFyc2VTaGFwZXMoanNvbikge1xuXHRcdGNvbnN0IHNoYXBlcyA9IHt9O1xuXHRcdGlmIChqc29uICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0Y29uc3Qgc2hhcGUgPSBuZXcgU2hhcGUoKS5mcm9tSlNPTihqc29uW2ldKTtcblx0XHRcdFx0c2hhcGVzW3NoYXBlLnV1aWRdID0gc2hhcGU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBzaGFwZXM7XG5cdH1cblx0cGFyc2VTa2VsZXRvbnMoanNvbiwgb2JqZWN0KSB7XG5cdFx0Y29uc3Qgc2tlbGV0b25zID0ge307XG5cdFx0Y29uc3QgYm9uZXMgPSB7fTtcblxuXHRcdC8vIGdlbmVyYXRlIGJvbmUgbG9va3VwIHRhYmxlXG5cblx0XHRvYmplY3QudHJhdmVyc2UoZnVuY3Rpb24gKGNoaWxkKSB7XG5cdFx0XHRpZiAoY2hpbGQuaXNCb25lKSBib25lc1tjaGlsZC51dWlkXSA9IGNoaWxkO1xuXHRcdH0pO1xuXG5cdFx0Ly8gY3JlYXRlIHNrZWxldG9uc1xuXG5cdFx0aWYgKGpzb24gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRjb25zdCBza2VsZXRvbiA9IG5ldyBTa2VsZXRvbigpLmZyb21KU09OKGpzb25baV0sIGJvbmVzKTtcblx0XHRcdFx0c2tlbGV0b25zW3NrZWxldG9uLnV1aWRdID0gc2tlbGV0b247XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBza2VsZXRvbnM7XG5cdH1cblx0cGFyc2VHZW9tZXRyaWVzKGpzb24sIHNoYXBlcykge1xuXHRcdGNvbnN0IGdlb21ldHJpZXMgPSB7fTtcblx0XHRpZiAoanNvbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjb25zdCBidWZmZXJHZW9tZXRyeUxvYWRlciA9IG5ldyBCdWZmZXJHZW9tZXRyeUxvYWRlcigpO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRsZXQgZ2VvbWV0cnk7XG5cdFx0XHRcdGNvbnN0IGRhdGEgPSBqc29uW2ldO1xuXHRcdFx0XHRzd2l0Y2ggKGRhdGEudHlwZSkge1xuXHRcdFx0XHRcdGNhc2UgJ0J1ZmZlckdlb21ldHJ5Jzpcblx0XHRcdFx0XHRjYXNlICdJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSc6XG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IGJ1ZmZlckdlb21ldHJ5TG9hZGVyLnBhcnNlKGRhdGEpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGlmIChkYXRhLnR5cGUgaW4gR2VvbWV0cmllcykge1xuXHRcdFx0XHRcdFx0XHRnZW9tZXRyeSA9IEdlb21ldHJpZXNbZGF0YS50eXBlXS5mcm9tSlNPTihkYXRhLCBzaGFwZXMpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKGBUSFJFRS5PYmplY3RMb2FkZXI6IFVuc3VwcG9ydGVkIGdlb21ldHJ5IHR5cGUgXCIke2RhdGEudHlwZX1cImApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGdlb21ldHJ5LnV1aWQgPSBkYXRhLnV1aWQ7XG5cdFx0XHRcdGlmIChkYXRhLm5hbWUgIT09IHVuZGVmaW5lZCkgZ2VvbWV0cnkubmFtZSA9IGRhdGEubmFtZTtcblx0XHRcdFx0aWYgKGdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkgPT09IHRydWUgJiYgZGF0YS51c2VyRGF0YSAhPT0gdW5kZWZpbmVkKSBnZW9tZXRyeS51c2VyRGF0YSA9IGRhdGEudXNlckRhdGE7XG5cdFx0XHRcdGdlb21ldHJpZXNbZGF0YS51dWlkXSA9IGdlb21ldHJ5O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZ2VvbWV0cmllcztcblx0fVxuXHRwYXJzZU1hdGVyaWFscyhqc29uLCB0ZXh0dXJlcykge1xuXHRcdGNvbnN0IGNhY2hlID0ge307IC8vIE11bHRpTWF0ZXJpYWxcblx0XHRjb25zdCBtYXRlcmlhbHMgPSB7fTtcblx0XHRpZiAoanNvbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjb25zdCBsb2FkZXIgPSBuZXcgTWF0ZXJpYWxMb2FkZXIoKTtcblx0XHRcdGxvYWRlci5zZXRUZXh0dXJlcyh0ZXh0dXJlcyk7XG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGpzb24ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGRhdGEgPSBqc29uW2ldO1xuXHRcdFx0XHRpZiAoY2FjaGVbZGF0YS51dWlkXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0Y2FjaGVbZGF0YS51dWlkXSA9IGxvYWRlci5wYXJzZShkYXRhKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRtYXRlcmlhbHNbZGF0YS51dWlkXSA9IGNhY2hlW2RhdGEudXVpZF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBtYXRlcmlhbHM7XG5cdH1cblx0cGFyc2VBbmltYXRpb25zKGpzb24pIHtcblx0XHRjb25zdCBhbmltYXRpb25zID0ge307XG5cdFx0aWYgKGpzb24gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBqc29uLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGRhdGEgPSBqc29uW2ldO1xuXHRcdFx0XHRjb25zdCBjbGlwID0gQW5pbWF0aW9uQ2xpcC5wYXJzZShkYXRhKTtcblx0XHRcdFx0YW5pbWF0aW9uc1tjbGlwLnV1aWRdID0gY2xpcDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGFuaW1hdGlvbnM7XG5cdH1cblx0cGFyc2VJbWFnZXMoanNvbiwgb25Mb2FkKSB7XG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXHRcdGNvbnN0IGltYWdlcyA9IHt9O1xuXHRcdGxldCBsb2FkZXI7XG5cdFx0ZnVuY3Rpb24gbG9hZEltYWdlKHVybCkge1xuXHRcdFx0c2NvcGUubWFuYWdlci5pdGVtU3RhcnQodXJsKTtcblx0XHRcdHJldHVybiBsb2FkZXIubG9hZCh1cmwsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKHVybCk7XG5cdFx0XHR9LCB1bmRlZmluZWQsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IodXJsKTtcblx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKHVybCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gZGVzZXJpYWxpemVJbWFnZShpbWFnZSkge1xuXHRcdFx0aWYgKHR5cGVvZiBpbWFnZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0Y29uc3QgdXJsID0gaW1hZ2U7XG5cdFx0XHRcdGNvbnN0IHBhdGggPSAvXihcXC9cXC8pfChbYS16XSs6KFxcL1xcLyk/KS9pLnRlc3QodXJsKSA/IHVybCA6IHNjb3BlLnJlc291cmNlUGF0aCArIHVybDtcblx0XHRcdFx0cmV0dXJuIGxvYWRJbWFnZShwYXRoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChpbWFnZS5kYXRhKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdGRhdGE6IGdldFR5cGVkQXJyYXkoaW1hZ2UudHlwZSwgaW1hZ2UuZGF0YSksXG5cdFx0XHRcdFx0XHR3aWR0aDogaW1hZ2Uud2lkdGgsXG5cdFx0XHRcdFx0XHRoZWlnaHQ6IGltYWdlLmhlaWdodFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGpzb24gIT09IHVuZGVmaW5lZCAmJiBqc29uLmxlbmd0aCA+IDApIHtcblx0XHRcdGNvbnN0IG1hbmFnZXIgPSBuZXcgTG9hZGluZ01hbmFnZXIob25Mb2FkKTtcblx0XHRcdGxvYWRlciA9IG5ldyBJbWFnZUxvYWRlcihtYW5hZ2VyKTtcblx0XHRcdGxvYWRlci5zZXRDcm9zc09yaWdpbih0aGlzLmNyb3NzT3JpZ2luKTtcblx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IGpzb24ubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHRjb25zdCBpbWFnZSA9IGpzb25baV07XG5cdFx0XHRcdGNvbnN0IHVybCA9IGltYWdlLnVybDtcblx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkodXJsKSkge1xuXHRcdFx0XHRcdC8vIGxvYWQgYXJyYXkgb2YgaW1hZ2VzIGUuZyBDdWJlVGV4dHVyZVxuXG5cdFx0XHRcdFx0Y29uc3QgaW1hZ2VBcnJheSA9IFtdO1xuXHRcdFx0XHRcdGZvciAobGV0IGogPSAwLCBqbCA9IHVybC5sZW5ndGg7IGogPCBqbDsgaisrKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBjdXJyZW50VXJsID0gdXJsW2pdO1xuXHRcdFx0XHRcdFx0Y29uc3QgZGVzZXJpYWxpemVkSW1hZ2UgPSBkZXNlcmlhbGl6ZUltYWdlKGN1cnJlbnRVcmwpO1xuXHRcdFx0XHRcdFx0aWYgKGRlc2VyaWFsaXplZEltYWdlICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChkZXNlcmlhbGl6ZWRJbWFnZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdFx0XHRpbWFnZUFycmF5LnB1c2goZGVzZXJpYWxpemVkSW1hZ2UpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdC8vIHNwZWNpYWwgY2FzZTogaGFuZGxlIGFycmF5IG9mIGRhdGEgdGV4dHVyZXMgZm9yIGN1YmUgdGV4dHVyZXNcblxuXHRcdFx0XHRcdFx0XHRcdGltYWdlQXJyYXkucHVzaChuZXcgRGF0YVRleHR1cmUoZGVzZXJpYWxpemVkSW1hZ2UuZGF0YSwgZGVzZXJpYWxpemVkSW1hZ2Uud2lkdGgsIGRlc2VyaWFsaXplZEltYWdlLmhlaWdodCkpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGltYWdlc1tpbWFnZS51dWlkXSA9IG5ldyBTb3VyY2UoaW1hZ2VBcnJheSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gbG9hZCBzaW5nbGUgaW1hZ2VcblxuXHRcdFx0XHRcdGNvbnN0IGRlc2VyaWFsaXplZEltYWdlID0gZGVzZXJpYWxpemVJbWFnZShpbWFnZS51cmwpO1xuXHRcdFx0XHRcdGltYWdlc1tpbWFnZS51dWlkXSA9IG5ldyBTb3VyY2UoZGVzZXJpYWxpemVkSW1hZ2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBpbWFnZXM7XG5cdH1cblx0YXN5bmMgcGFyc2VJbWFnZXNBc3luYyhqc29uKSB7XG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXHRcdGNvbnN0IGltYWdlcyA9IHt9O1xuXHRcdGxldCBsb2FkZXI7XG5cdFx0YXN5bmMgZnVuY3Rpb24gZGVzZXJpYWxpemVJbWFnZShpbWFnZSkge1xuXHRcdFx0aWYgKHR5cGVvZiBpbWFnZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0Y29uc3QgdXJsID0gaW1hZ2U7XG5cdFx0XHRcdGNvbnN0IHBhdGggPSAvXihcXC9cXC8pfChbYS16XSs6KFxcL1xcLyk/KS9pLnRlc3QodXJsKSA/IHVybCA6IHNjb3BlLnJlc291cmNlUGF0aCArIHVybDtcblx0XHRcdFx0cmV0dXJuIGF3YWl0IGxvYWRlci5sb2FkQXN5bmMocGF0aCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoaW1hZ2UuZGF0YSkge1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRkYXRhOiBnZXRUeXBlZEFycmF5KGltYWdlLnR5cGUsIGltYWdlLmRhdGEpLFxuXHRcdFx0XHRcdFx0d2lkdGg6IGltYWdlLndpZHRoLFxuXHRcdFx0XHRcdFx0aGVpZ2h0OiBpbWFnZS5oZWlnaHRcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChqc29uICE9PSB1bmRlZmluZWQgJiYganNvbi5sZW5ndGggPiAwKSB7XG5cdFx0XHRsb2FkZXIgPSBuZXcgSW1hZ2VMb2FkZXIodGhpcy5tYW5hZ2VyKTtcblx0XHRcdGxvYWRlci5zZXRDcm9zc09yaWdpbih0aGlzLmNyb3NzT3JpZ2luKTtcblx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IGpzb24ubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHRjb25zdCBpbWFnZSA9IGpzb25baV07XG5cdFx0XHRcdGNvbnN0IHVybCA9IGltYWdlLnVybDtcblx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkodXJsKSkge1xuXHRcdFx0XHRcdC8vIGxvYWQgYXJyYXkgb2YgaW1hZ2VzIGUuZyBDdWJlVGV4dHVyZVxuXG5cdFx0XHRcdFx0Y29uc3QgaW1hZ2VBcnJheSA9IFtdO1xuXHRcdFx0XHRcdGZvciAobGV0IGogPSAwLCBqbCA9IHVybC5sZW5ndGg7IGogPCBqbDsgaisrKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBjdXJyZW50VXJsID0gdXJsW2pdO1xuXHRcdFx0XHRcdFx0Y29uc3QgZGVzZXJpYWxpemVkSW1hZ2UgPSBhd2FpdCBkZXNlcmlhbGl6ZUltYWdlKGN1cnJlbnRVcmwpO1xuXHRcdFx0XHRcdFx0aWYgKGRlc2VyaWFsaXplZEltYWdlICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChkZXNlcmlhbGl6ZWRJbWFnZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdFx0XHRpbWFnZUFycmF5LnB1c2goZGVzZXJpYWxpemVkSW1hZ2UpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdC8vIHNwZWNpYWwgY2FzZTogaGFuZGxlIGFycmF5IG9mIGRhdGEgdGV4dHVyZXMgZm9yIGN1YmUgdGV4dHVyZXNcblxuXHRcdFx0XHRcdFx0XHRcdGltYWdlQXJyYXkucHVzaChuZXcgRGF0YVRleHR1cmUoZGVzZXJpYWxpemVkSW1hZ2UuZGF0YSwgZGVzZXJpYWxpemVkSW1hZ2Uud2lkdGgsIGRlc2VyaWFsaXplZEltYWdlLmhlaWdodCkpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGltYWdlc1tpbWFnZS51dWlkXSA9IG5ldyBTb3VyY2UoaW1hZ2VBcnJheSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gbG9hZCBzaW5nbGUgaW1hZ2VcblxuXHRcdFx0XHRcdGNvbnN0IGRlc2VyaWFsaXplZEltYWdlID0gYXdhaXQgZGVzZXJpYWxpemVJbWFnZShpbWFnZS51cmwpO1xuXHRcdFx0XHRcdGltYWdlc1tpbWFnZS51dWlkXSA9IG5ldyBTb3VyY2UoZGVzZXJpYWxpemVkSW1hZ2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBpbWFnZXM7XG5cdH1cblx0cGFyc2VUZXh0dXJlcyhqc29uLCBpbWFnZXMpIHtcblx0XHRmdW5jdGlvbiBwYXJzZUNvbnN0YW50KHZhbHVlLCB0eXBlKSB7XG5cdFx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykgcmV0dXJuIHZhbHVlO1xuXHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5PYmplY3RMb2FkZXIucGFyc2VUZXh0dXJlOiBDb25zdGFudCBzaG91bGQgYmUgaW4gbnVtZXJpYyBmb3JtLicsIHZhbHVlKTtcblx0XHRcdHJldHVybiB0eXBlW3ZhbHVlXTtcblx0XHR9XG5cdFx0Y29uc3QgdGV4dHVyZXMgPSB7fTtcblx0XHRpZiAoanNvbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGpzb24ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGRhdGEgPSBqc29uW2ldO1xuXHRcdFx0XHRpZiAoZGF0YS5pbWFnZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5PYmplY3RMb2FkZXI6IE5vIFwiaW1hZ2VcIiBzcGVjaWZpZWQgZm9yJywgZGF0YS51dWlkKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaW1hZ2VzW2RhdGEuaW1hZ2VdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLk9iamVjdExvYWRlcjogVW5kZWZpbmVkIGltYWdlJywgZGF0YS5pbWFnZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29uc3Qgc291cmNlID0gaW1hZ2VzW2RhdGEuaW1hZ2VdO1xuXHRcdFx0XHRjb25zdCBpbWFnZSA9IHNvdXJjZS5kYXRhO1xuXHRcdFx0XHRsZXQgdGV4dHVyZTtcblx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoaW1hZ2UpKSB7XG5cdFx0XHRcdFx0dGV4dHVyZSA9IG5ldyBDdWJlVGV4dHVyZSgpO1xuXHRcdFx0XHRcdGlmIChpbWFnZS5sZW5ndGggPT09IDYpIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmIChpbWFnZSAmJiBpbWFnZS5kYXRhKSB7XG5cdFx0XHRcdFx0XHR0ZXh0dXJlID0gbmV3IERhdGFUZXh0dXJlKCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRleHR1cmUgPSBuZXcgVGV4dHVyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoaW1hZ2UpIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlOyAvLyB0ZXh0dXJlcyBjYW4gaGF2ZSB1bmRlZmluZWQgaW1hZ2UgZGF0YVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGV4dHVyZS5zb3VyY2UgPSBzb3VyY2U7XG5cdFx0XHRcdHRleHR1cmUudXVpZCA9IGRhdGEudXVpZDtcblx0XHRcdFx0aWYgKGRhdGEubmFtZSAhPT0gdW5kZWZpbmVkKSB0ZXh0dXJlLm5hbWUgPSBkYXRhLm5hbWU7XG5cdFx0XHRcdGlmIChkYXRhLm1hcHBpbmcgIT09IHVuZGVmaW5lZCkgdGV4dHVyZS5tYXBwaW5nID0gcGFyc2VDb25zdGFudChkYXRhLm1hcHBpbmcsIFRFWFRVUkVfTUFQUElORyk7XG5cdFx0XHRcdGlmIChkYXRhLm9mZnNldCAhPT0gdW5kZWZpbmVkKSB0ZXh0dXJlLm9mZnNldC5mcm9tQXJyYXkoZGF0YS5vZmZzZXQpO1xuXHRcdFx0XHRpZiAoZGF0YS5yZXBlYXQgIT09IHVuZGVmaW5lZCkgdGV4dHVyZS5yZXBlYXQuZnJvbUFycmF5KGRhdGEucmVwZWF0KTtcblx0XHRcdFx0aWYgKGRhdGEuY2VudGVyICE9PSB1bmRlZmluZWQpIHRleHR1cmUuY2VudGVyLmZyb21BcnJheShkYXRhLmNlbnRlcik7XG5cdFx0XHRcdGlmIChkYXRhLnJvdGF0aW9uICE9PSB1bmRlZmluZWQpIHRleHR1cmUucm90YXRpb24gPSBkYXRhLnJvdGF0aW9uO1xuXHRcdFx0XHRpZiAoZGF0YS53cmFwICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHR0ZXh0dXJlLndyYXBTID0gcGFyc2VDb25zdGFudChkYXRhLndyYXBbMF0sIFRFWFRVUkVfV1JBUFBJTkcpO1xuXHRcdFx0XHRcdHRleHR1cmUud3JhcFQgPSBwYXJzZUNvbnN0YW50KGRhdGEud3JhcFsxXSwgVEVYVFVSRV9XUkFQUElORyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGRhdGEuZm9ybWF0ICE9PSB1bmRlZmluZWQpIHRleHR1cmUuZm9ybWF0ID0gZGF0YS5mb3JtYXQ7XG5cdFx0XHRcdGlmIChkYXRhLnR5cGUgIT09IHVuZGVmaW5lZCkgdGV4dHVyZS50eXBlID0gZGF0YS50eXBlO1xuXHRcdFx0XHRpZiAoZGF0YS5lbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB0ZXh0dXJlLmVuY29kaW5nID0gZGF0YS5lbmNvZGluZztcblx0XHRcdFx0aWYgKGRhdGEubWluRmlsdGVyICE9PSB1bmRlZmluZWQpIHRleHR1cmUubWluRmlsdGVyID0gcGFyc2VDb25zdGFudChkYXRhLm1pbkZpbHRlciwgVEVYVFVSRV9GSUxURVIpO1xuXHRcdFx0XHRpZiAoZGF0YS5tYWdGaWx0ZXIgIT09IHVuZGVmaW5lZCkgdGV4dHVyZS5tYWdGaWx0ZXIgPSBwYXJzZUNvbnN0YW50KGRhdGEubWFnRmlsdGVyLCBURVhUVVJFX0ZJTFRFUik7XG5cdFx0XHRcdGlmIChkYXRhLmFuaXNvdHJvcHkgIT09IHVuZGVmaW5lZCkgdGV4dHVyZS5hbmlzb3Ryb3B5ID0gZGF0YS5hbmlzb3Ryb3B5O1xuXHRcdFx0XHRpZiAoZGF0YS5mbGlwWSAhPT0gdW5kZWZpbmVkKSB0ZXh0dXJlLmZsaXBZID0gZGF0YS5mbGlwWTtcblx0XHRcdFx0aWYgKGRhdGEucHJlbXVsdGlwbHlBbHBoYSAhPT0gdW5kZWZpbmVkKSB0ZXh0dXJlLnByZW11bHRpcGx5QWxwaGEgPSBkYXRhLnByZW11bHRpcGx5QWxwaGE7XG5cdFx0XHRcdGlmIChkYXRhLnVucGFja0FsaWdubWVudCAhPT0gdW5kZWZpbmVkKSB0ZXh0dXJlLnVucGFja0FsaWdubWVudCA9IGRhdGEudW5wYWNrQWxpZ25tZW50O1xuXHRcdFx0XHRpZiAoZGF0YS51c2VyRGF0YSAhPT0gdW5kZWZpbmVkKSB0ZXh0dXJlLnVzZXJEYXRhID0gZGF0YS51c2VyRGF0YTtcblx0XHRcdFx0dGV4dHVyZXNbZGF0YS51dWlkXSA9IHRleHR1cmU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0ZXh0dXJlcztcblx0fVxuXHRwYXJzZU9iamVjdChkYXRhLCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMsIHRleHR1cmVzLCBhbmltYXRpb25zKSB7XG5cdFx0bGV0IG9iamVjdDtcblx0XHRmdW5jdGlvbiBnZXRHZW9tZXRyeShuYW1lKSB7XG5cdFx0XHRpZiAoZ2VvbWV0cmllc1tuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgZ2VvbWV0cnknLCBuYW1lKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBnZW9tZXRyaWVzW25hbWVdO1xuXHRcdH1cblx0XHRmdW5jdGlvbiBnZXRNYXRlcmlhbChuYW1lKSB7XG5cdFx0XHRpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdW5kZWZpbmVkO1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkobmFtZSkpIHtcblx0XHRcdFx0Y29uc3QgYXJyYXkgPSBbXTtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBuYW1lLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdGNvbnN0IHV1aWQgPSBuYW1lW2ldO1xuXHRcdFx0XHRcdGlmIChtYXRlcmlhbHNbdXVpZF0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5PYmplY3RMb2FkZXI6IFVuZGVmaW5lZCBtYXRlcmlhbCcsIHV1aWQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRhcnJheS5wdXNoKG1hdGVyaWFsc1t1dWlkXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGFycmF5O1xuXHRcdFx0fVxuXHRcdFx0aWYgKG1hdGVyaWFsc1tuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgbWF0ZXJpYWwnLCBuYW1lKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRlcmlhbHNbbmFtZV07XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIGdldFRleHR1cmUodXVpZCkge1xuXHRcdFx0aWYgKHRleHR1cmVzW3V1aWRdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5PYmplY3RMb2FkZXI6IFVuZGVmaW5lZCB0ZXh0dXJlJywgdXVpZCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGV4dHVyZXNbdXVpZF07XG5cdFx0fVxuXHRcdGxldCBnZW9tZXRyeSwgbWF0ZXJpYWw7XG5cdFx0c3dpdGNoIChkYXRhLnR5cGUpIHtcblx0XHRcdGNhc2UgJ1NjZW5lJzpcblx0XHRcdFx0b2JqZWN0ID0gbmV3IFNjZW5lKCk7XG5cdFx0XHRcdGlmIChkYXRhLmJhY2tncm91bmQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGlmIChOdW1iZXIuaXNJbnRlZ2VyKGRhdGEuYmFja2dyb3VuZCkpIHtcblx0XHRcdFx0XHRcdG9iamVjdC5iYWNrZ3JvdW5kID0gbmV3IENvbG9yKGRhdGEuYmFja2dyb3VuZCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG9iamVjdC5iYWNrZ3JvdW5kID0gZ2V0VGV4dHVyZShkYXRhLmJhY2tncm91bmQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZGF0YS5lbnZpcm9ubWVudCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0b2JqZWN0LmVudmlyb25tZW50ID0gZ2V0VGV4dHVyZShkYXRhLmVudmlyb25tZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZGF0YS5mb2cgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGlmIChkYXRhLmZvZy50eXBlID09PSAnRm9nJykge1xuXHRcdFx0XHRcdFx0b2JqZWN0LmZvZyA9IG5ldyBGb2coZGF0YS5mb2cuY29sb3IsIGRhdGEuZm9nLm5lYXIsIGRhdGEuZm9nLmZhcik7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChkYXRhLmZvZy50eXBlID09PSAnRm9nRXhwMicpIHtcblx0XHRcdFx0XHRcdG9iamVjdC5mb2cgPSBuZXcgRm9nRXhwMihkYXRhLmZvZy5jb2xvciwgZGF0YS5mb2cuZGVuc2l0eSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChkYXRhLmJhY2tncm91bmRCbHVycmluZXNzICE9PSB1bmRlZmluZWQpIG9iamVjdC5iYWNrZ3JvdW5kQmx1cnJpbmVzcyA9IGRhdGEuYmFja2dyb3VuZEJsdXJyaW5lc3M7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnUGVyc3BlY3RpdmVDYW1lcmEnOlxuXHRcdFx0XHRvYmplY3QgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoZGF0YS5mb3YsIGRhdGEuYXNwZWN0LCBkYXRhLm5lYXIsIGRhdGEuZmFyKTtcblx0XHRcdFx0aWYgKGRhdGEuZm9jdXMgIT09IHVuZGVmaW5lZCkgb2JqZWN0LmZvY3VzID0gZGF0YS5mb2N1cztcblx0XHRcdFx0aWYgKGRhdGEuem9vbSAhPT0gdW5kZWZpbmVkKSBvYmplY3Quem9vbSA9IGRhdGEuem9vbTtcblx0XHRcdFx0aWYgKGRhdGEuZmlsbUdhdWdlICE9PSB1bmRlZmluZWQpIG9iamVjdC5maWxtR2F1Z2UgPSBkYXRhLmZpbG1HYXVnZTtcblx0XHRcdFx0aWYgKGRhdGEuZmlsbU9mZnNldCAhPT0gdW5kZWZpbmVkKSBvYmplY3QuZmlsbU9mZnNldCA9IGRhdGEuZmlsbU9mZnNldDtcblx0XHRcdFx0aWYgKGRhdGEudmlldyAhPT0gdW5kZWZpbmVkKSBvYmplY3QudmlldyA9IE9iamVjdC5hc3NpZ24oe30sIGRhdGEudmlldyk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnT3J0aG9ncmFwaGljQ2FtZXJhJzpcblx0XHRcdFx0b2JqZWN0ID0gbmV3IE9ydGhvZ3JhcGhpY0NhbWVyYShkYXRhLmxlZnQsIGRhdGEucmlnaHQsIGRhdGEudG9wLCBkYXRhLmJvdHRvbSwgZGF0YS5uZWFyLCBkYXRhLmZhcik7XG5cdFx0XHRcdGlmIChkYXRhLnpvb20gIT09IHVuZGVmaW5lZCkgb2JqZWN0Lnpvb20gPSBkYXRhLnpvb207XG5cdFx0XHRcdGlmIChkYXRhLnZpZXcgIT09IHVuZGVmaW5lZCkgb2JqZWN0LnZpZXcgPSBPYmplY3QuYXNzaWduKHt9LCBkYXRhLnZpZXcpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ0FtYmllbnRMaWdodCc6XG5cdFx0XHRcdG9iamVjdCA9IG5ldyBBbWJpZW50TGlnaHQoZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHkpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ0RpcmVjdGlvbmFsTGlnaHQnOlxuXHRcdFx0XHRvYmplY3QgPSBuZXcgRGlyZWN0aW9uYWxMaWdodChkYXRhLmNvbG9yLCBkYXRhLmludGVuc2l0eSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnUG9pbnRMaWdodCc6XG5cdFx0XHRcdG9iamVjdCA9IG5ldyBQb2ludExpZ2h0KGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5LCBkYXRhLmRpc3RhbmNlLCBkYXRhLmRlY2F5KTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdSZWN0QXJlYUxpZ2h0Jzpcblx0XHRcdFx0b2JqZWN0ID0gbmV3IFJlY3RBcmVhTGlnaHQoZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHksIGRhdGEud2lkdGgsIGRhdGEuaGVpZ2h0KTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdTcG90TGlnaHQnOlxuXHRcdFx0XHRvYmplY3QgPSBuZXcgU3BvdExpZ2h0KGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5LCBkYXRhLmRpc3RhbmNlLCBkYXRhLmFuZ2xlLCBkYXRhLnBlbnVtYnJhLCBkYXRhLmRlY2F5KTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdIZW1pc3BoZXJlTGlnaHQnOlxuXHRcdFx0XHRvYmplY3QgPSBuZXcgSGVtaXNwaGVyZUxpZ2h0KGRhdGEuY29sb3IsIGRhdGEuZ3JvdW5kQ29sb3IsIGRhdGEuaW50ZW5zaXR5KTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdMaWdodFByb2JlJzpcblx0XHRcdFx0b2JqZWN0ID0gbmV3IExpZ2h0UHJvYmUoKS5mcm9tSlNPTihkYXRhKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdTa2lubmVkTWVzaCc6XG5cdFx0XHRcdGdlb21ldHJ5ID0gZ2V0R2VvbWV0cnkoZGF0YS5nZW9tZXRyeSk7XG5cdFx0XHRcdG1hdGVyaWFsID0gZ2V0TWF0ZXJpYWwoZGF0YS5tYXRlcmlhbCk7XG5cdFx0XHRcdG9iamVjdCA9IG5ldyBTa2lubmVkTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuXHRcdFx0XHRpZiAoZGF0YS5iaW5kTW9kZSAhPT0gdW5kZWZpbmVkKSBvYmplY3QuYmluZE1vZGUgPSBkYXRhLmJpbmRNb2RlO1xuXHRcdFx0XHRpZiAoZGF0YS5iaW5kTWF0cml4ICE9PSB1bmRlZmluZWQpIG9iamVjdC5iaW5kTWF0cml4LmZyb21BcnJheShkYXRhLmJpbmRNYXRyaXgpO1xuXHRcdFx0XHRpZiAoZGF0YS5za2VsZXRvbiAhPT0gdW5kZWZpbmVkKSBvYmplY3Quc2tlbGV0b24gPSBkYXRhLnNrZWxldG9uO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ01lc2gnOlxuXHRcdFx0XHRnZW9tZXRyeSA9IGdldEdlb21ldHJ5KGRhdGEuZ2VvbWV0cnkpO1xuXHRcdFx0XHRtYXRlcmlhbCA9IGdldE1hdGVyaWFsKGRhdGEubWF0ZXJpYWwpO1xuXHRcdFx0XHRvYmplY3QgPSBuZXcgTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ0luc3RhbmNlZE1lc2gnOlxuXHRcdFx0XHRnZW9tZXRyeSA9IGdldEdlb21ldHJ5KGRhdGEuZ2VvbWV0cnkpO1xuXHRcdFx0XHRtYXRlcmlhbCA9IGdldE1hdGVyaWFsKGRhdGEubWF0ZXJpYWwpO1xuXHRcdFx0XHRjb25zdCBjb3VudCA9IGRhdGEuY291bnQ7XG5cdFx0XHRcdGNvbnN0IGluc3RhbmNlTWF0cml4ID0gZGF0YS5pbnN0YW5jZU1hdHJpeDtcblx0XHRcdFx0Y29uc3QgaW5zdGFuY2VDb2xvciA9IGRhdGEuaW5zdGFuY2VDb2xvcjtcblx0XHRcdFx0b2JqZWN0ID0gbmV3IEluc3RhbmNlZE1lc2goZ2VvbWV0cnksIG1hdGVyaWFsLCBjb3VudCk7XG5cdFx0XHRcdG9iamVjdC5pbnN0YW5jZU1hdHJpeCA9IG5ldyBJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUobmV3IEZsb2F0MzJBcnJheShpbnN0YW5jZU1hdHJpeC5hcnJheSksIDE2KTtcblx0XHRcdFx0aWYgKGluc3RhbmNlQ29sb3IgIT09IHVuZGVmaW5lZCkgb2JqZWN0Lmluc3RhbmNlQ29sb3IgPSBuZXcgSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlKG5ldyBGbG9hdDMyQXJyYXkoaW5zdGFuY2VDb2xvci5hcnJheSksIGluc3RhbmNlQ29sb3IuaXRlbVNpemUpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ0xPRCc6XG5cdFx0XHRcdG9iamVjdCA9IG5ldyBMT0QoKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdMaW5lJzpcblx0XHRcdFx0b2JqZWN0ID0gbmV3IExpbmUoZ2V0R2VvbWV0cnkoZGF0YS5nZW9tZXRyeSksIGdldE1hdGVyaWFsKGRhdGEubWF0ZXJpYWwpKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdMaW5lTG9vcCc6XG5cdFx0XHRcdG9iamVjdCA9IG5ldyBMaW5lTG9vcChnZXRHZW9tZXRyeShkYXRhLmdlb21ldHJ5KSwgZ2V0TWF0ZXJpYWwoZGF0YS5tYXRlcmlhbCkpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ0xpbmVTZWdtZW50cyc6XG5cdFx0XHRcdG9iamVjdCA9IG5ldyBMaW5lU2VnbWVudHMoZ2V0R2VvbWV0cnkoZGF0YS5nZW9tZXRyeSksIGdldE1hdGVyaWFsKGRhdGEubWF0ZXJpYWwpKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdQb2ludENsb3VkJzpcblx0XHRcdGNhc2UgJ1BvaW50cyc6XG5cdFx0XHRcdG9iamVjdCA9IG5ldyBQb2ludHMoZ2V0R2VvbWV0cnkoZGF0YS5nZW9tZXRyeSksIGdldE1hdGVyaWFsKGRhdGEubWF0ZXJpYWwpKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdTcHJpdGUnOlxuXHRcdFx0XHRvYmplY3QgPSBuZXcgU3ByaXRlKGdldE1hdGVyaWFsKGRhdGEubWF0ZXJpYWwpKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdHcm91cCc6XG5cdFx0XHRcdG9iamVjdCA9IG5ldyBHcm91cCgpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ0JvbmUnOlxuXHRcdFx0XHRvYmplY3QgPSBuZXcgQm9uZSgpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdG9iamVjdCA9IG5ldyBPYmplY3QzRCgpO1xuXHRcdH1cblx0XHRvYmplY3QudXVpZCA9IGRhdGEudXVpZDtcblx0XHRpZiAoZGF0YS5uYW1lICE9PSB1bmRlZmluZWQpIG9iamVjdC5uYW1lID0gZGF0YS5uYW1lO1xuXHRcdGlmIChkYXRhLm1hdHJpeCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRvYmplY3QubWF0cml4LmZyb21BcnJheShkYXRhLm1hdHJpeCk7XG5cdFx0XHRpZiAoZGF0YS5tYXRyaXhBdXRvVXBkYXRlICE9PSB1bmRlZmluZWQpIG9iamVjdC5tYXRyaXhBdXRvVXBkYXRlID0gZGF0YS5tYXRyaXhBdXRvVXBkYXRlO1xuXHRcdFx0aWYgKG9iamVjdC5tYXRyaXhBdXRvVXBkYXRlKSBvYmplY3QubWF0cml4LmRlY29tcG9zZShvYmplY3QucG9zaXRpb24sIG9iamVjdC5xdWF0ZXJuaW9uLCBvYmplY3Quc2NhbGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoZGF0YS5wb3NpdGlvbiAhPT0gdW5kZWZpbmVkKSBvYmplY3QucG9zaXRpb24uZnJvbUFycmF5KGRhdGEucG9zaXRpb24pO1xuXHRcdFx0aWYgKGRhdGEucm90YXRpb24gIT09IHVuZGVmaW5lZCkgb2JqZWN0LnJvdGF0aW9uLmZyb21BcnJheShkYXRhLnJvdGF0aW9uKTtcblx0XHRcdGlmIChkYXRhLnF1YXRlcm5pb24gIT09IHVuZGVmaW5lZCkgb2JqZWN0LnF1YXRlcm5pb24uZnJvbUFycmF5KGRhdGEucXVhdGVybmlvbik7XG5cdFx0XHRpZiAoZGF0YS5zY2FsZSAhPT0gdW5kZWZpbmVkKSBvYmplY3Quc2NhbGUuZnJvbUFycmF5KGRhdGEuc2NhbGUpO1xuXHRcdH1cblx0XHRpZiAoZGF0YS5jYXN0U2hhZG93ICE9PSB1bmRlZmluZWQpIG9iamVjdC5jYXN0U2hhZG93ID0gZGF0YS5jYXN0U2hhZG93O1xuXHRcdGlmIChkYXRhLnJlY2VpdmVTaGFkb3cgIT09IHVuZGVmaW5lZCkgb2JqZWN0LnJlY2VpdmVTaGFkb3cgPSBkYXRhLnJlY2VpdmVTaGFkb3c7XG5cdFx0aWYgKGRhdGEuc2hhZG93KSB7XG5cdFx0XHRpZiAoZGF0YS5zaGFkb3cuYmlhcyAhPT0gdW5kZWZpbmVkKSBvYmplY3Quc2hhZG93LmJpYXMgPSBkYXRhLnNoYWRvdy5iaWFzO1xuXHRcdFx0aWYgKGRhdGEuc2hhZG93Lm5vcm1hbEJpYXMgIT09IHVuZGVmaW5lZCkgb2JqZWN0LnNoYWRvdy5ub3JtYWxCaWFzID0gZGF0YS5zaGFkb3cubm9ybWFsQmlhcztcblx0XHRcdGlmIChkYXRhLnNoYWRvdy5yYWRpdXMgIT09IHVuZGVmaW5lZCkgb2JqZWN0LnNoYWRvdy5yYWRpdXMgPSBkYXRhLnNoYWRvdy5yYWRpdXM7XG5cdFx0XHRpZiAoZGF0YS5zaGFkb3cubWFwU2l6ZSAhPT0gdW5kZWZpbmVkKSBvYmplY3Quc2hhZG93Lm1hcFNpemUuZnJvbUFycmF5KGRhdGEuc2hhZG93Lm1hcFNpemUpO1xuXHRcdFx0aWYgKGRhdGEuc2hhZG93LmNhbWVyYSAhPT0gdW5kZWZpbmVkKSBvYmplY3Quc2hhZG93LmNhbWVyYSA9IHRoaXMucGFyc2VPYmplY3QoZGF0YS5zaGFkb3cuY2FtZXJhKTtcblx0XHR9XG5cdFx0aWYgKGRhdGEudmlzaWJsZSAhPT0gdW5kZWZpbmVkKSBvYmplY3QudmlzaWJsZSA9IGRhdGEudmlzaWJsZTtcblx0XHRpZiAoZGF0YS5mcnVzdHVtQ3VsbGVkICE9PSB1bmRlZmluZWQpIG9iamVjdC5mcnVzdHVtQ3VsbGVkID0gZGF0YS5mcnVzdHVtQ3VsbGVkO1xuXHRcdGlmIChkYXRhLnJlbmRlck9yZGVyICE9PSB1bmRlZmluZWQpIG9iamVjdC5yZW5kZXJPcmRlciA9IGRhdGEucmVuZGVyT3JkZXI7XG5cdFx0aWYgKGRhdGEudXNlckRhdGEgIT09IHVuZGVmaW5lZCkgb2JqZWN0LnVzZXJEYXRhID0gZGF0YS51c2VyRGF0YTtcblx0XHRpZiAoZGF0YS5sYXllcnMgIT09IHVuZGVmaW5lZCkgb2JqZWN0LmxheWVycy5tYXNrID0gZGF0YS5sYXllcnM7XG5cdFx0aWYgKGRhdGEuY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Y29uc3QgY2hpbGRyZW4gPSBkYXRhLmNoaWxkcmVuO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRvYmplY3QuYWRkKHRoaXMucGFyc2VPYmplY3QoY2hpbGRyZW5baV0sIGdlb21ldHJpZXMsIG1hdGVyaWFscywgdGV4dHVyZXMsIGFuaW1hdGlvbnMpKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGRhdGEuYW5pbWF0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjb25zdCBvYmplY3RBbmltYXRpb25zID0gZGF0YS5hbmltYXRpb25zO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBvYmplY3RBbmltYXRpb25zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IHV1aWQgPSBvYmplY3RBbmltYXRpb25zW2ldO1xuXHRcdFx0XHRvYmplY3QuYW5pbWF0aW9ucy5wdXNoKGFuaW1hdGlvbnNbdXVpZF0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoZGF0YS50eXBlID09PSAnTE9EJykge1xuXHRcdFx0aWYgKGRhdGEuYXV0b1VwZGF0ZSAhPT0gdW5kZWZpbmVkKSBvYmplY3QuYXV0b1VwZGF0ZSA9IGRhdGEuYXV0b1VwZGF0ZTtcblx0XHRcdGNvbnN0IGxldmVscyA9IGRhdGEubGV2ZWxzO1xuXHRcdFx0Zm9yIChsZXQgbCA9IDA7IGwgPCBsZXZlbHMubGVuZ3RoOyBsKyspIHtcblx0XHRcdFx0Y29uc3QgbGV2ZWwgPSBsZXZlbHNbbF07XG5cdFx0XHRcdGNvbnN0IGNoaWxkID0gb2JqZWN0LmdldE9iamVjdEJ5UHJvcGVydHkoJ3V1aWQnLCBsZXZlbC5vYmplY3QpO1xuXHRcdFx0XHRpZiAoY2hpbGQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdG9iamVjdC5hZGRMZXZlbChjaGlsZCwgbGV2ZWwuZGlzdGFuY2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvYmplY3Q7XG5cdH1cblx0YmluZFNrZWxldG9ucyhvYmplY3QsIHNrZWxldG9ucykge1xuXHRcdGlmIChPYmplY3Qua2V5cyhza2VsZXRvbnMpLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXHRcdG9iamVjdC50cmF2ZXJzZShmdW5jdGlvbiAoY2hpbGQpIHtcblx0XHRcdGlmIChjaGlsZC5pc1NraW5uZWRNZXNoID09PSB0cnVlICYmIGNoaWxkLnNrZWxldG9uICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y29uc3Qgc2tlbGV0b24gPSBza2VsZXRvbnNbY2hpbGQuc2tlbGV0b25dO1xuXHRcdFx0XHRpZiAoc2tlbGV0b24gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuT2JqZWN0TG9hZGVyOiBObyBza2VsZXRvbiBmb3VuZCB3aXRoIFVVSUQ6JywgY2hpbGQuc2tlbGV0b24pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNoaWxkLmJpbmQoc2tlbGV0b24sIGNoaWxkLmJpbmRNYXRyaXgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn1cbmNvbnN0IFRFWFRVUkVfTUFQUElORyA9IHtcblx0VVZNYXBwaW5nOiBVVk1hcHBpbmcsXG5cdEN1YmVSZWZsZWN0aW9uTWFwcGluZzogQ3ViZVJlZmxlY3Rpb25NYXBwaW5nLFxuXHRDdWJlUmVmcmFjdGlvbk1hcHBpbmc6IEN1YmVSZWZyYWN0aW9uTWFwcGluZyxcblx0RXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmc6IEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nLFxuXHRFcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZzogRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmcsXG5cdEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nOiBDdWJlVVZSZWZsZWN0aW9uTWFwcGluZ1xufTtcbmNvbnN0IFRFWFRVUkVfV1JBUFBJTkcgPSB7XG5cdFJlcGVhdFdyYXBwaW5nOiBSZXBlYXRXcmFwcGluZyxcblx0Q2xhbXBUb0VkZ2VXcmFwcGluZzogQ2xhbXBUb0VkZ2VXcmFwcGluZyxcblx0TWlycm9yZWRSZXBlYXRXcmFwcGluZzogTWlycm9yZWRSZXBlYXRXcmFwcGluZ1xufTtcbmNvbnN0IFRFWFRVUkVfRklMVEVSID0ge1xuXHROZWFyZXN0RmlsdGVyOiBOZWFyZXN0RmlsdGVyLFxuXHROZWFyZXN0TWlwbWFwTmVhcmVzdEZpbHRlcjogTmVhcmVzdE1pcG1hcE5lYXJlc3RGaWx0ZXIsXG5cdE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXI6IE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIsXG5cdExpbmVhckZpbHRlcjogTGluZWFyRmlsdGVyLFxuXHRMaW5lYXJNaXBtYXBOZWFyZXN0RmlsdGVyOiBMaW5lYXJNaXBtYXBOZWFyZXN0RmlsdGVyLFxuXHRMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXI6IExpbmVhck1pcG1hcExpbmVhckZpbHRlclxufTtcblxuY2xhc3MgSW1hZ2VCaXRtYXBMb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuXHRjb25zdHJ1Y3RvcihtYW5hZ2VyKSB7XG5cdFx0c3VwZXIobWFuYWdlcik7XG5cdFx0dGhpcy5pc0ltYWdlQml0bWFwTG9hZGVyID0gdHJ1ZTtcblx0XHRpZiAodHlwZW9mIGNyZWF0ZUltYWdlQml0bWFwID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5JbWFnZUJpdG1hcExvYWRlcjogY3JlYXRlSW1hZ2VCaXRtYXAoKSBub3Qgc3VwcG9ydGVkLicpO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIGZldGNoID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5JbWFnZUJpdG1hcExvYWRlcjogZmV0Y2goKSBub3Qgc3VwcG9ydGVkLicpO1xuXHRcdH1cblx0XHR0aGlzLm9wdGlvbnMgPSB7XG5cdFx0XHRwcmVtdWx0aXBseUFscGhhOiAnbm9uZSdcblx0XHR9O1xuXHR9XG5cdHNldE9wdGlvbnMob3B0aW9ucykge1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0bG9hZCh1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvcikge1xuXHRcdGlmICh1cmwgPT09IHVuZGVmaW5lZCkgdXJsID0gJyc7XG5cdFx0aWYgKHRoaXMucGF0aCAhPT0gdW5kZWZpbmVkKSB1cmwgPSB0aGlzLnBhdGggKyB1cmw7XG5cdFx0dXJsID0gdGhpcy5tYW5hZ2VyLnJlc29sdmVVUkwodXJsKTtcblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cdFx0Y29uc3QgY2FjaGVkID0gQ2FjaGUuZ2V0KHVybCk7XG5cdFx0aWYgKGNhY2hlZCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1TdGFydCh1cmwpO1xuXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGlmIChvbkxvYWQpIG9uTG9hZChjYWNoZWQpO1xuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQodXJsKTtcblx0XHRcdH0sIDApO1xuXHRcdFx0cmV0dXJuIGNhY2hlZDtcblx0XHR9XG5cdFx0Y29uc3QgZmV0Y2hPcHRpb25zID0ge307XG5cdFx0ZmV0Y2hPcHRpb25zLmNyZWRlbnRpYWxzID0gdGhpcy5jcm9zc09yaWdpbiA9PT0gJ2Fub255bW91cycgPyAnc2FtZS1vcmlnaW4nIDogJ2luY2x1ZGUnO1xuXHRcdGZldGNoT3B0aW9ucy5oZWFkZXJzID0gdGhpcy5yZXF1ZXN0SGVhZGVyO1xuXHRcdGZldGNoKHVybCwgZmV0Y2hPcHRpb25zKS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcblx0XHRcdHJldHVybiByZXMuYmxvYigpO1xuXHRcdH0pLnRoZW4oZnVuY3Rpb24gKGJsb2IpIHtcblx0XHRcdHJldHVybiBjcmVhdGVJbWFnZUJpdG1hcChibG9iLCBPYmplY3QuYXNzaWduKHNjb3BlLm9wdGlvbnMsIHtcblx0XHRcdFx0Y29sb3JTcGFjZUNvbnZlcnNpb246ICdub25lJ1xuXHRcdFx0fSkpO1xuXHRcdH0pLnRoZW4oZnVuY3Rpb24gKGltYWdlQml0bWFwKSB7XG5cdFx0XHRDYWNoZS5hZGQodXJsLCBpbWFnZUJpdG1hcCk7XG5cdFx0XHRpZiAob25Mb2FkKSBvbkxvYWQoaW1hZ2VCaXRtYXApO1xuXHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKHVybCk7XG5cdFx0fSkuY2F0Y2goZnVuY3Rpb24gKGUpIHtcblx0XHRcdGlmIChvbkVycm9yKSBvbkVycm9yKGUpO1xuXHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IodXJsKTtcblx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCh1cmwpO1xuXHRcdH0pO1xuXHRcdHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KHVybCk7XG5cdH1cbn1cblxubGV0IF9jb250ZXh0O1xuY2xhc3MgQXVkaW9Db250ZXh0IHtcblx0c3RhdGljIGdldENvbnRleHQoKSB7XG5cdFx0aWYgKF9jb250ZXh0ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdF9jb250ZXh0ID0gbmV3ICh3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQpKCk7XG5cdFx0fVxuXHRcdHJldHVybiBfY29udGV4dDtcblx0fVxuXHRzdGF0aWMgc2V0Q29udGV4dCh2YWx1ZSkge1xuXHRcdF9jb250ZXh0ID0gdmFsdWU7XG5cdH1cbn1cblxuY2xhc3MgQXVkaW9Mb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuXHRjb25zdHJ1Y3RvcihtYW5hZ2VyKSB7XG5cdFx0c3VwZXIobWFuYWdlcik7XG5cdH1cblx0bG9hZCh1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvcikge1xuXHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblx0XHRjb25zdCBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlcih0aGlzLm1hbmFnZXIpO1xuXHRcdGxvYWRlci5zZXRSZXNwb25zZVR5cGUoJ2FycmF5YnVmZmVyJyk7XG5cdFx0bG9hZGVyLnNldFBhdGgodGhpcy5wYXRoKTtcblx0XHRsb2FkZXIuc2V0UmVxdWVzdEhlYWRlcih0aGlzLnJlcXVlc3RIZWFkZXIpO1xuXHRcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHModGhpcy53aXRoQ3JlZGVudGlhbHMpO1xuXHRcdGxvYWRlci5sb2FkKHVybCwgZnVuY3Rpb24gKGJ1ZmZlcikge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Ly8gQ3JlYXRlIGEgY29weSBvZiB0aGUgYnVmZmVyLiBUaGUgYGRlY29kZUF1ZGlvRGF0YWAgbWV0aG9kXG5cdFx0XHRcdC8vIGRldGFjaGVzIHRoZSBidWZmZXIgd2hlbiBjb21wbGV0ZSwgcHJldmVudGluZyByZXVzZS5cblx0XHRcdFx0Y29uc3QgYnVmZmVyQ29weSA9IGJ1ZmZlci5zbGljZSgwKTtcblx0XHRcdFx0Y29uc3QgY29udGV4dCA9IEF1ZGlvQ29udGV4dC5nZXRDb250ZXh0KCk7XG5cdFx0XHRcdGNvbnRleHQuZGVjb2RlQXVkaW9EYXRhKGJ1ZmZlckNvcHksIGZ1bmN0aW9uIChhdWRpb0J1ZmZlcikge1xuXHRcdFx0XHRcdG9uTG9hZChhdWRpb0J1ZmZlcik7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRpZiAob25FcnJvcikge1xuXHRcdFx0XHRcdG9uRXJyb3IoZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcihlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvcih1cmwpO1xuXHRcdFx0fVxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpO1xuXHR9XG59XG5cbmNsYXNzIEhlbWlzcGhlcmVMaWdodFByb2JlIGV4dGVuZHMgTGlnaHRQcm9iZSB7XG5cdGNvbnN0cnVjdG9yKHNreUNvbG9yLCBncm91bmRDb2xvciwgaW50ZW5zaXR5ID0gMSkge1xuXHRcdHN1cGVyKHVuZGVmaW5lZCwgaW50ZW5zaXR5KTtcblx0XHR0aGlzLmlzSGVtaXNwaGVyZUxpZ2h0UHJvYmUgPSB0cnVlO1xuXHRcdGNvbnN0IGNvbG9yMSA9IG5ldyBDb2xvcigpLnNldChza3lDb2xvcik7XG5cdFx0Y29uc3QgY29sb3IyID0gbmV3IENvbG9yKCkuc2V0KGdyb3VuZENvbG9yKTtcblx0XHRjb25zdCBza3kgPSBuZXcgVmVjdG9yMyhjb2xvcjEuciwgY29sb3IxLmcsIGNvbG9yMS5iKTtcblx0XHRjb25zdCBncm91bmQgPSBuZXcgVmVjdG9yMyhjb2xvcjIuciwgY29sb3IyLmcsIGNvbG9yMi5iKTtcblxuXHRcdC8vIHdpdGhvdXQgZXh0cmEgZmFjdG9yIG9mIFBJIGluIHRoZSBzaGFkZXIsIHNob3VsZCA9IDEgLyBNYXRoLnNxcnQoIE1hdGguUEkgKTtcblx0XHRjb25zdCBjMCA9IE1hdGguc3FydChNYXRoLlBJKTtcblx0XHRjb25zdCBjMSA9IGMwICogTWF0aC5zcXJ0KDAuNzUpO1xuXHRcdHRoaXMuc2guY29lZmZpY2llbnRzWzBdLmNvcHkoc2t5KS5hZGQoZ3JvdW5kKS5tdWx0aXBseVNjYWxhcihjMCk7XG5cdFx0dGhpcy5zaC5jb2VmZmljaWVudHNbMV0uY29weShza3kpLnN1Yihncm91bmQpLm11bHRpcGx5U2NhbGFyKGMxKTtcblx0fVxufVxuXG5jbGFzcyBBbWJpZW50TGlnaHRQcm9iZSBleHRlbmRzIExpZ2h0UHJvYmUge1xuXHRjb25zdHJ1Y3Rvcihjb2xvciwgaW50ZW5zaXR5ID0gMSkge1xuXHRcdHN1cGVyKHVuZGVmaW5lZCwgaW50ZW5zaXR5KTtcblx0XHR0aGlzLmlzQW1iaWVudExpZ2h0UHJvYmUgPSB0cnVlO1xuXHRcdGNvbnN0IGNvbG9yMSA9IG5ldyBDb2xvcigpLnNldChjb2xvcik7XG5cblx0XHQvLyB3aXRob3V0IGV4dHJhIGZhY3RvciBvZiBQSSBpbiB0aGUgc2hhZGVyLCB3b3VsZCBiZSAyIC8gTWF0aC5zcXJ0KCBNYXRoLlBJICk7XG5cdFx0dGhpcy5zaC5jb2VmZmljaWVudHNbMF0uc2V0KGNvbG9yMS5yLCBjb2xvcjEuZywgY29sb3IxLmIpLm11bHRpcGx5U2NhbGFyKDIgKiBNYXRoLnNxcnQoTWF0aC5QSSkpO1xuXHR9XG59XG5cbmNvbnN0IF9leWVSaWdodCA9IC8qQF9fUFVSRV9fKi9uZXcgTWF0cml4NCgpO1xuY29uc3QgX2V5ZUxlZnQgPSAvKkBfX1BVUkVfXyovbmV3IE1hdHJpeDQoKTtcbmNvbnN0IF9wcm9qZWN0aW9uTWF0cml4ID0gLypAX19QVVJFX18qL25ldyBNYXRyaXg0KCk7XG5jbGFzcyBTdGVyZW9DYW1lcmEge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzLnR5cGUgPSAnU3RlcmVvQ2FtZXJhJztcblx0XHR0aGlzLmFzcGVjdCA9IDE7XG5cdFx0dGhpcy5leWVTZXAgPSAwLjA2NDtcblx0XHR0aGlzLmNhbWVyYUwgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoKTtcblx0XHR0aGlzLmNhbWVyYUwubGF5ZXJzLmVuYWJsZSgxKTtcblx0XHR0aGlzLmNhbWVyYUwubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXHRcdHRoaXMuY2FtZXJhUiA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSgpO1xuXHRcdHRoaXMuY2FtZXJhUi5sYXllcnMuZW5hYmxlKDIpO1xuXHRcdHRoaXMuY2FtZXJhUi5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cdFx0dGhpcy5fY2FjaGUgPSB7XG5cdFx0XHRmb2N1czogbnVsbCxcblx0XHRcdGZvdjogbnVsbCxcblx0XHRcdGFzcGVjdDogbnVsbCxcblx0XHRcdG5lYXI6IG51bGwsXG5cdFx0XHRmYXI6IG51bGwsXG5cdFx0XHR6b29tOiBudWxsLFxuXHRcdFx0ZXllU2VwOiBudWxsXG5cdFx0fTtcblx0fVxuXHR1cGRhdGUoY2FtZXJhKSB7XG5cdFx0Y29uc3QgY2FjaGUgPSB0aGlzLl9jYWNoZTtcblx0XHRjb25zdCBuZWVkc1VwZGF0ZSA9IGNhY2hlLmZvY3VzICE9PSBjYW1lcmEuZm9jdXMgfHwgY2FjaGUuZm92ICE9PSBjYW1lcmEuZm92IHx8IGNhY2hlLmFzcGVjdCAhPT0gY2FtZXJhLmFzcGVjdCAqIHRoaXMuYXNwZWN0IHx8IGNhY2hlLm5lYXIgIT09IGNhbWVyYS5uZWFyIHx8IGNhY2hlLmZhciAhPT0gY2FtZXJhLmZhciB8fCBjYWNoZS56b29tICE9PSBjYW1lcmEuem9vbSB8fCBjYWNoZS5leWVTZXAgIT09IHRoaXMuZXllU2VwO1xuXHRcdGlmIChuZWVkc1VwZGF0ZSkge1xuXHRcdFx0Y2FjaGUuZm9jdXMgPSBjYW1lcmEuZm9jdXM7XG5cdFx0XHRjYWNoZS5mb3YgPSBjYW1lcmEuZm92O1xuXHRcdFx0Y2FjaGUuYXNwZWN0ID0gY2FtZXJhLmFzcGVjdCAqIHRoaXMuYXNwZWN0O1xuXHRcdFx0Y2FjaGUubmVhciA9IGNhbWVyYS5uZWFyO1xuXHRcdFx0Y2FjaGUuZmFyID0gY2FtZXJhLmZhcjtcblx0XHRcdGNhY2hlLnpvb20gPSBjYW1lcmEuem9vbTtcblx0XHRcdGNhY2hlLmV5ZVNlcCA9IHRoaXMuZXllU2VwO1xuXG5cdFx0XHQvLyBPZmYtYXhpcyBzdGVyZW9zY29waWMgZWZmZWN0IGJhc2VkIG9uXG5cdFx0XHQvLyBodHRwOi8vcGF1bGJvdXJrZS5uZXQvc3RlcmVvZ3JhcGhpY3Mvc3RlcmVvcmVuZGVyL1xuXG5cdFx0XHRfcHJvamVjdGlvbk1hdHJpeC5jb3B5KGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4KTtcblx0XHRcdGNvbnN0IGV5ZVNlcEhhbGYgPSBjYWNoZS5leWVTZXAgLyAyO1xuXHRcdFx0Y29uc3QgZXllU2VwT25Qcm9qZWN0aW9uID0gZXllU2VwSGFsZiAqIGNhY2hlLm5lYXIgLyBjYWNoZS5mb2N1cztcblx0XHRcdGNvbnN0IHltYXggPSBjYWNoZS5uZWFyICogTWF0aC50YW4oREVHMlJBRCAqIGNhY2hlLmZvdiAqIDAuNSkgLyBjYWNoZS56b29tO1xuXHRcdFx0bGV0IHhtaW4sIHhtYXg7XG5cblx0XHRcdC8vIHRyYW5zbGF0ZSB4T2Zmc2V0XG5cblx0XHRcdF9leWVMZWZ0LmVsZW1lbnRzWzEyXSA9IC1leWVTZXBIYWxmO1xuXHRcdFx0X2V5ZVJpZ2h0LmVsZW1lbnRzWzEyXSA9IGV5ZVNlcEhhbGY7XG5cblx0XHRcdC8vIGZvciBsZWZ0IGV5ZVxuXG5cdFx0XHR4bWluID0gLXltYXggKiBjYWNoZS5hc3BlY3QgKyBleWVTZXBPblByb2plY3Rpb247XG5cdFx0XHR4bWF4ID0geW1heCAqIGNhY2hlLmFzcGVjdCArIGV5ZVNlcE9uUHJvamVjdGlvbjtcblx0XHRcdF9wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzWzBdID0gMiAqIGNhY2hlLm5lYXIgLyAoeG1heCAtIHhtaW4pO1xuXHRcdFx0X3Byb2plY3Rpb25NYXRyaXguZWxlbWVudHNbOF0gPSAoeG1heCArIHhtaW4pIC8gKHhtYXggLSB4bWluKTtcblx0XHRcdHRoaXMuY2FtZXJhTC5wcm9qZWN0aW9uTWF0cml4LmNvcHkoX3Byb2plY3Rpb25NYXRyaXgpO1xuXG5cdFx0XHQvLyBmb3IgcmlnaHQgZXllXG5cblx0XHRcdHhtaW4gPSAteW1heCAqIGNhY2hlLmFzcGVjdCAtIGV5ZVNlcE9uUHJvamVjdGlvbjtcblx0XHRcdHhtYXggPSB5bWF4ICogY2FjaGUuYXNwZWN0IC0gZXllU2VwT25Qcm9qZWN0aW9uO1xuXHRcdFx0X3Byb2plY3Rpb25NYXRyaXguZWxlbWVudHNbMF0gPSAyICogY2FjaGUubmVhciAvICh4bWF4IC0geG1pbik7XG5cdFx0XHRfcHJvamVjdGlvbk1hdHJpeC5lbGVtZW50c1s4XSA9ICh4bWF4ICsgeG1pbikgLyAoeG1heCAtIHhtaW4pO1xuXHRcdFx0dGhpcy5jYW1lcmFSLnByb2plY3Rpb25NYXRyaXguY29weShfcHJvamVjdGlvbk1hdHJpeCk7XG5cdFx0fVxuXHRcdHRoaXMuY2FtZXJhTC5tYXRyaXhXb3JsZC5jb3B5KGNhbWVyYS5tYXRyaXhXb3JsZCkubXVsdGlwbHkoX2V5ZUxlZnQpO1xuXHRcdHRoaXMuY2FtZXJhUi5tYXRyaXhXb3JsZC5jb3B5KGNhbWVyYS5tYXRyaXhXb3JsZCkubXVsdGlwbHkoX2V5ZVJpZ2h0KTtcblx0fVxufVxuXG5jbGFzcyBDbG9jayB7XG5cdGNvbnN0cnVjdG9yKGF1dG9TdGFydCA9IHRydWUpIHtcblx0XHR0aGlzLmF1dG9TdGFydCA9IGF1dG9TdGFydDtcblx0XHR0aGlzLnN0YXJ0VGltZSA9IDA7XG5cdFx0dGhpcy5vbGRUaW1lID0gMDtcblx0XHR0aGlzLmVsYXBzZWRUaW1lID0gMDtcblx0XHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcblx0fVxuXHRzdGFydCgpIHtcblx0XHR0aGlzLnN0YXJ0VGltZSA9IG5vdygpO1xuXHRcdHRoaXMub2xkVGltZSA9IHRoaXMuc3RhcnRUaW1lO1xuXHRcdHRoaXMuZWxhcHNlZFRpbWUgPSAwO1xuXHRcdHRoaXMucnVubmluZyA9IHRydWU7XG5cdH1cblx0c3RvcCgpIHtcblx0XHR0aGlzLmdldEVsYXBzZWRUaW1lKCk7XG5cdFx0dGhpcy5ydW5uaW5nID0gZmFsc2U7XG5cdFx0dGhpcy5hdXRvU3RhcnQgPSBmYWxzZTtcblx0fVxuXHRnZXRFbGFwc2VkVGltZSgpIHtcblx0XHR0aGlzLmdldERlbHRhKCk7XG5cdFx0cmV0dXJuIHRoaXMuZWxhcHNlZFRpbWU7XG5cdH1cblx0Z2V0RGVsdGEoKSB7XG5cdFx0bGV0IGRpZmYgPSAwO1xuXHRcdGlmICh0aGlzLmF1dG9TdGFydCAmJiAhdGhpcy5ydW5uaW5nKSB7XG5cdFx0XHR0aGlzLnN0YXJ0KCk7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cdFx0aWYgKHRoaXMucnVubmluZykge1xuXHRcdFx0Y29uc3QgbmV3VGltZSA9IG5vdygpO1xuXHRcdFx0ZGlmZiA9IChuZXdUaW1lIC0gdGhpcy5vbGRUaW1lKSAvIDEwMDA7XG5cdFx0XHR0aGlzLm9sZFRpbWUgPSBuZXdUaW1lO1xuXHRcdFx0dGhpcy5lbGFwc2VkVGltZSArPSBkaWZmO1xuXHRcdH1cblx0XHRyZXR1cm4gZGlmZjtcblx0fVxufVxuZnVuY3Rpb24gbm93KCkge1xuXHRyZXR1cm4gKHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ3VuZGVmaW5lZCcgPyBEYXRlIDogcGVyZm9ybWFuY2UpLm5vdygpOyAvLyBzZWUgIzEwNzMyXG59XG5cbmNvbnN0IF9wb3NpdGlvbiQxID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5jb25zdCBfcXVhdGVybmlvbiQxID0gLypAX19QVVJFX18qL25ldyBRdWF0ZXJuaW9uKCk7XG5jb25zdCBfc2NhbGUkMSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuY29uc3QgX29yaWVudGF0aW9uJDEgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcbmNsYXNzIEF1ZGlvTGlzdGVuZXIgZXh0ZW5kcyBPYmplY3QzRCB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy50eXBlID0gJ0F1ZGlvTGlzdGVuZXInO1xuXHRcdHRoaXMuY29udGV4dCA9IEF1ZGlvQ29udGV4dC5nZXRDb250ZXh0KCk7XG5cdFx0dGhpcy5nYWluID0gdGhpcy5jb250ZXh0LmNyZWF0ZUdhaW4oKTtcblx0XHR0aGlzLmdhaW4uY29ubmVjdCh0aGlzLmNvbnRleHQuZGVzdGluYXRpb24pO1xuXHRcdHRoaXMuZmlsdGVyID0gbnVsbDtcblx0XHR0aGlzLnRpbWVEZWx0YSA9IDA7XG5cblx0XHQvLyBwcml2YXRlXG5cblx0XHR0aGlzLl9jbG9jayA9IG5ldyBDbG9jaygpO1xuXHR9XG5cdGdldElucHV0KCkge1xuXHRcdHJldHVybiB0aGlzLmdhaW47XG5cdH1cblx0cmVtb3ZlRmlsdGVyKCkge1xuXHRcdGlmICh0aGlzLmZpbHRlciAhPT0gbnVsbCkge1xuXHRcdFx0dGhpcy5nYWluLmRpc2Nvbm5lY3QodGhpcy5maWx0ZXIpO1xuXHRcdFx0dGhpcy5maWx0ZXIuZGlzY29ubmVjdCh0aGlzLmNvbnRleHQuZGVzdGluYXRpb24pO1xuXHRcdFx0dGhpcy5nYWluLmNvbm5lY3QodGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uKTtcblx0XHRcdHRoaXMuZmlsdGVyID0gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0Z2V0RmlsdGVyKCkge1xuXHRcdHJldHVybiB0aGlzLmZpbHRlcjtcblx0fVxuXHRzZXRGaWx0ZXIodmFsdWUpIHtcblx0XHRpZiAodGhpcy5maWx0ZXIgIT09IG51bGwpIHtcblx0XHRcdHRoaXMuZ2Fpbi5kaXNjb25uZWN0KHRoaXMuZmlsdGVyKTtcblx0XHRcdHRoaXMuZmlsdGVyLmRpc2Nvbm5lY3QodGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5nYWluLmRpc2Nvbm5lY3QodGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uKTtcblx0XHR9XG5cdFx0dGhpcy5maWx0ZXIgPSB2YWx1ZTtcblx0XHR0aGlzLmdhaW4uY29ubmVjdCh0aGlzLmZpbHRlcik7XG5cdFx0dGhpcy5maWx0ZXIuY29ubmVjdCh0aGlzLmNvbnRleHQuZGVzdGluYXRpb24pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGdldE1hc3RlclZvbHVtZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5nYWluLmdhaW4udmFsdWU7XG5cdH1cblx0c2V0TWFzdGVyVm9sdW1lKHZhbHVlKSB7XG5cdFx0dGhpcy5nYWluLmdhaW4uc2V0VGFyZ2V0QXRUaW1lKHZhbHVlLCB0aGlzLmNvbnRleHQuY3VycmVudFRpbWUsIDAuMDEpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHVwZGF0ZU1hdHJpeFdvcmxkKGZvcmNlKSB7XG5cdFx0c3VwZXIudXBkYXRlTWF0cml4V29ybGQoZm9yY2UpO1xuXHRcdGNvbnN0IGxpc3RlbmVyID0gdGhpcy5jb250ZXh0Lmxpc3RlbmVyO1xuXHRcdGNvbnN0IHVwID0gdGhpcy51cDtcblx0XHR0aGlzLnRpbWVEZWx0YSA9IHRoaXMuX2Nsb2NrLmdldERlbHRhKCk7XG5cdFx0dGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoX3Bvc2l0aW9uJDEsIF9xdWF0ZXJuaW9uJDEsIF9zY2FsZSQxKTtcblx0XHRfb3JpZW50YXRpb24kMS5zZXQoMCwgMCwgLTEpLmFwcGx5UXVhdGVybmlvbihfcXVhdGVybmlvbiQxKTtcblx0XHRpZiAobGlzdGVuZXIucG9zaXRpb25YKSB7XG5cdFx0XHQvLyBjb2RlIHBhdGggZm9yIENocm9tZSAoc2VlICMxNDM5MylcblxuXHRcdFx0Y29uc3QgZW5kVGltZSA9IHRoaXMuY29udGV4dC5jdXJyZW50VGltZSArIHRoaXMudGltZURlbHRhO1xuXHRcdFx0bGlzdGVuZXIucG9zaXRpb25YLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKF9wb3NpdGlvbiQxLngsIGVuZFRpbWUpO1xuXHRcdFx0bGlzdGVuZXIucG9zaXRpb25ZLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKF9wb3NpdGlvbiQxLnksIGVuZFRpbWUpO1xuXHRcdFx0bGlzdGVuZXIucG9zaXRpb25aLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKF9wb3NpdGlvbiQxLnosIGVuZFRpbWUpO1xuXHRcdFx0bGlzdGVuZXIuZm9yd2FyZFgubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoX29yaWVudGF0aW9uJDEueCwgZW5kVGltZSk7XG5cdFx0XHRsaXN0ZW5lci5mb3J3YXJkWS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShfb3JpZW50YXRpb24kMS55LCBlbmRUaW1lKTtcblx0XHRcdGxpc3RlbmVyLmZvcndhcmRaLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKF9vcmllbnRhdGlvbiQxLnosIGVuZFRpbWUpO1xuXHRcdFx0bGlzdGVuZXIudXBYLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHVwLngsIGVuZFRpbWUpO1xuXHRcdFx0bGlzdGVuZXIudXBZLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHVwLnksIGVuZFRpbWUpO1xuXHRcdFx0bGlzdGVuZXIudXBaLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHVwLnosIGVuZFRpbWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsaXN0ZW5lci5zZXRQb3NpdGlvbihfcG9zaXRpb24kMS54LCBfcG9zaXRpb24kMS55LCBfcG9zaXRpb24kMS56KTtcblx0XHRcdGxpc3RlbmVyLnNldE9yaWVudGF0aW9uKF9vcmllbnRhdGlvbiQxLngsIF9vcmllbnRhdGlvbiQxLnksIF9vcmllbnRhdGlvbiQxLnosIHVwLngsIHVwLnksIHVwLnopO1xuXHRcdH1cblx0fVxufVxuXG5jbGFzcyBBdWRpbyBleHRlbmRzIE9iamVjdDNEIHtcblx0Y29uc3RydWN0b3IobGlzdGVuZXIpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMudHlwZSA9ICdBdWRpbyc7XG5cdFx0dGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuXHRcdHRoaXMuY29udGV4dCA9IGxpc3RlbmVyLmNvbnRleHQ7XG5cdFx0dGhpcy5nYWluID0gdGhpcy5jb250ZXh0LmNyZWF0ZUdhaW4oKTtcblx0XHR0aGlzLmdhaW4uY29ubmVjdChsaXN0ZW5lci5nZXRJbnB1dCgpKTtcblx0XHR0aGlzLmF1dG9wbGF5ID0gZmFsc2U7XG5cdFx0dGhpcy5idWZmZXIgPSBudWxsO1xuXHRcdHRoaXMuZGV0dW5lID0gMDtcblx0XHR0aGlzLmxvb3AgPSBmYWxzZTtcblx0XHR0aGlzLmxvb3BTdGFydCA9IDA7XG5cdFx0dGhpcy5sb29wRW5kID0gMDtcblx0XHR0aGlzLm9mZnNldCA9IDA7XG5cdFx0dGhpcy5kdXJhdGlvbiA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLnBsYXliYWNrUmF0ZSA9IDE7XG5cdFx0dGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcblx0XHR0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9IHRydWU7XG5cdFx0dGhpcy5zb3VyY2UgPSBudWxsO1xuXHRcdHRoaXMuc291cmNlVHlwZSA9ICdlbXB0eSc7XG5cdFx0dGhpcy5fc3RhcnRlZEF0ID0gMDtcblx0XHR0aGlzLl9wcm9ncmVzcyA9IDA7XG5cdFx0dGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG5cdFx0dGhpcy5maWx0ZXJzID0gW107XG5cdH1cblx0Z2V0T3V0cHV0KCkge1xuXHRcdHJldHVybiB0aGlzLmdhaW47XG5cdH1cblx0c2V0Tm9kZVNvdXJjZShhdWRpb05vZGUpIHtcblx0XHR0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9IGZhbHNlO1xuXHRcdHRoaXMuc291cmNlVHlwZSA9ICdhdWRpb05vZGUnO1xuXHRcdHRoaXMuc291cmNlID0gYXVkaW9Ob2RlO1xuXHRcdHRoaXMuY29ubmVjdCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHNldE1lZGlhRWxlbWVudFNvdXJjZShtZWRpYUVsZW1lbnQpIHtcblx0XHR0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9IGZhbHNlO1xuXHRcdHRoaXMuc291cmNlVHlwZSA9ICdtZWRpYU5vZGUnO1xuXHRcdHRoaXMuc291cmNlID0gdGhpcy5jb250ZXh0LmNyZWF0ZU1lZGlhRWxlbWVudFNvdXJjZShtZWRpYUVsZW1lbnQpO1xuXHRcdHRoaXMuY29ubmVjdCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHNldE1lZGlhU3RyZWFtU291cmNlKG1lZGlhU3RyZWFtKSB7XG5cdFx0dGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPSBmYWxzZTtcblx0XHR0aGlzLnNvdXJjZVR5cGUgPSAnbWVkaWFTdHJlYW1Ob2RlJztcblx0XHR0aGlzLnNvdXJjZSA9IHRoaXMuY29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShtZWRpYVN0cmVhbSk7XG5cdFx0dGhpcy5jb25uZWN0KCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0c2V0QnVmZmVyKGF1ZGlvQnVmZmVyKSB7XG5cdFx0dGhpcy5idWZmZXIgPSBhdWRpb0J1ZmZlcjtcblx0XHR0aGlzLnNvdXJjZVR5cGUgPSAnYnVmZmVyJztcblx0XHRpZiAodGhpcy5hdXRvcGxheSkgdGhpcy5wbGF5KCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0cGxheShkZWxheSA9IDApIHtcblx0XHRpZiAodGhpcy5pc1BsYXlpbmcgPT09IHRydWUpIHtcblx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuQXVkaW86IEF1ZGlvIGlzIGFscmVhZHkgcGxheWluZy4nKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKHRoaXMuaGFzUGxheWJhY2tDb250cm9sID09PSBmYWxzZSkge1xuXHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5BdWRpbzogdGhpcyBBdWRpbyBoYXMgbm8gcGxheWJhY2sgY29udHJvbC4nKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5fc3RhcnRlZEF0ID0gdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lICsgZGVsYXk7XG5cdFx0Y29uc3Qgc291cmNlID0gdGhpcy5jb250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuXHRcdHNvdXJjZS5idWZmZXIgPSB0aGlzLmJ1ZmZlcjtcblx0XHRzb3VyY2UubG9vcCA9IHRoaXMubG9vcDtcblx0XHRzb3VyY2UubG9vcFN0YXJ0ID0gdGhpcy5sb29wU3RhcnQ7XG5cdFx0c291cmNlLmxvb3BFbmQgPSB0aGlzLmxvb3BFbmQ7XG5cdFx0c291cmNlLm9uZW5kZWQgPSB0aGlzLm9uRW5kZWQuYmluZCh0aGlzKTtcblx0XHRzb3VyY2Uuc3RhcnQodGhpcy5fc3RhcnRlZEF0LCB0aGlzLl9wcm9ncmVzcyArIHRoaXMub2Zmc2V0LCB0aGlzLmR1cmF0aW9uKTtcblx0XHR0aGlzLmlzUGxheWluZyA9IHRydWU7XG5cdFx0dGhpcy5zb3VyY2UgPSBzb3VyY2U7XG5cdFx0dGhpcy5zZXREZXR1bmUodGhpcy5kZXR1bmUpO1xuXHRcdHRoaXMuc2V0UGxheWJhY2tSYXRlKHRoaXMucGxheWJhY2tSYXRlKTtcblx0XHRyZXR1cm4gdGhpcy5jb25uZWN0KCk7XG5cdH1cblx0cGF1c2UoKSB7XG5cdFx0aWYgKHRoaXMuaGFzUGxheWJhY2tDb250cm9sID09PSBmYWxzZSkge1xuXHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5BdWRpbzogdGhpcyBBdWRpbyBoYXMgbm8gcGxheWJhY2sgY29udHJvbC4nKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKHRoaXMuaXNQbGF5aW5nID09PSB0cnVlKSB7XG5cdFx0XHQvLyB1cGRhdGUgY3VycmVudCBwcm9ncmVzc1xuXG5cdFx0XHR0aGlzLl9wcm9ncmVzcyArPSBNYXRoLm1heCh0aGlzLmNvbnRleHQuY3VycmVudFRpbWUgLSB0aGlzLl9zdGFydGVkQXQsIDApICogdGhpcy5wbGF5YmFja1JhdGU7XG5cdFx0XHRpZiAodGhpcy5sb29wID09PSB0cnVlKSB7XG5cdFx0XHRcdC8vIGVuc3VyZSBfcHJvZ3Jlc3MgZG9lcyBub3QgZXhjZWVkIGR1cmF0aW9uIHdpdGggbG9vcGVkIGF1ZGlvc1xuXG5cdFx0XHRcdHRoaXMuX3Byb2dyZXNzID0gdGhpcy5fcHJvZ3Jlc3MgJSAodGhpcy5kdXJhdGlvbiB8fCB0aGlzLmJ1ZmZlci5kdXJhdGlvbik7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnNvdXJjZS5zdG9wKCk7XG5cdFx0XHR0aGlzLnNvdXJjZS5vbmVuZGVkID0gbnVsbDtcblx0XHRcdHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHN0b3AoKSB7XG5cdFx0aWYgKHRoaXMuaGFzUGxheWJhY2tDb250cm9sID09PSBmYWxzZSkge1xuXHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5BdWRpbzogdGhpcyBBdWRpbyBoYXMgbm8gcGxheWJhY2sgY29udHJvbC4nKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5fcHJvZ3Jlc3MgPSAwO1xuXHRcdHRoaXMuc291cmNlLnN0b3AoKTtcblx0XHR0aGlzLnNvdXJjZS5vbmVuZGVkID0gbnVsbDtcblx0XHR0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGNvbm5lY3QoKSB7XG5cdFx0aWYgKHRoaXMuZmlsdGVycy5sZW5ndGggPiAwKSB7XG5cdFx0XHR0aGlzLnNvdXJjZS5jb25uZWN0KHRoaXMuZmlsdGVyc1swXSk7XG5cdFx0XHRmb3IgKGxldCBpID0gMSwgbCA9IHRoaXMuZmlsdGVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dGhpcy5maWx0ZXJzW2kgLSAxXS5jb25uZWN0KHRoaXMuZmlsdGVyc1tpXSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmZpbHRlcnNbdGhpcy5maWx0ZXJzLmxlbmd0aCAtIDFdLmNvbm5lY3QodGhpcy5nZXRPdXRwdXQoKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuc291cmNlLmNvbm5lY3QodGhpcy5nZXRPdXRwdXQoKSk7XG5cdFx0fVxuXHRcdHRoaXMuX2Nvbm5lY3RlZCA9IHRydWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0ZGlzY29ubmVjdCgpIHtcblx0XHRpZiAodGhpcy5maWx0ZXJzLmxlbmd0aCA+IDApIHtcblx0XHRcdHRoaXMuc291cmNlLmRpc2Nvbm5lY3QodGhpcy5maWx0ZXJzWzBdKTtcblx0XHRcdGZvciAobGV0IGkgPSAxLCBsID0gdGhpcy5maWx0ZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR0aGlzLmZpbHRlcnNbaSAtIDFdLmRpc2Nvbm5lY3QodGhpcy5maWx0ZXJzW2ldKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuZmlsdGVyc1t0aGlzLmZpbHRlcnMubGVuZ3RoIC0gMV0uZGlzY29ubmVjdCh0aGlzLmdldE91dHB1dCgpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5zb3VyY2UuZGlzY29ubmVjdCh0aGlzLmdldE91dHB1dCgpKTtcblx0XHR9XG5cdFx0dGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0Z2V0RmlsdGVycygpIHtcblx0XHRyZXR1cm4gdGhpcy5maWx0ZXJzO1xuXHR9XG5cdHNldEZpbHRlcnModmFsdWUpIHtcblx0XHRpZiAoIXZhbHVlKSB2YWx1ZSA9IFtdO1xuXHRcdGlmICh0aGlzLl9jb25uZWN0ZWQgPT09IHRydWUpIHtcblx0XHRcdHRoaXMuZGlzY29ubmVjdCgpO1xuXHRcdFx0dGhpcy5maWx0ZXJzID0gdmFsdWUuc2xpY2UoKTtcblx0XHRcdHRoaXMuY29ubmVjdCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmZpbHRlcnMgPSB2YWx1ZS5zbGljZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRzZXREZXR1bmUodmFsdWUpIHtcblx0XHR0aGlzLmRldHVuZSA9IHZhbHVlO1xuXHRcdGlmICh0aGlzLnNvdXJjZS5kZXR1bmUgPT09IHVuZGVmaW5lZCkgcmV0dXJuOyAvLyBvbmx5IHNldCBkZXR1bmUgd2hlbiBhdmFpbGFibGVcblxuXHRcdGlmICh0aGlzLmlzUGxheWluZyA9PT0gdHJ1ZSkge1xuXHRcdFx0dGhpcy5zb3VyY2UuZGV0dW5lLnNldFRhcmdldEF0VGltZSh0aGlzLmRldHVuZSwgdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lLCAwLjAxKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0Z2V0RGV0dW5lKCkge1xuXHRcdHJldHVybiB0aGlzLmRldHVuZTtcblx0fVxuXHRnZXRGaWx0ZXIoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0RmlsdGVycygpWzBdO1xuXHR9XG5cdHNldEZpbHRlcihmaWx0ZXIpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRGaWx0ZXJzKGZpbHRlciA/IFtmaWx0ZXJdIDogW10pO1xuXHR9XG5cdHNldFBsYXliYWNrUmF0ZSh2YWx1ZSkge1xuXHRcdGlmICh0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9PT0gZmFsc2UpIHtcblx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuJyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMucGxheWJhY2tSYXRlID0gdmFsdWU7XG5cdFx0aWYgKHRoaXMuaXNQbGF5aW5nID09PSB0cnVlKSB7XG5cdFx0XHR0aGlzLnNvdXJjZS5wbGF5YmFja1JhdGUuc2V0VGFyZ2V0QXRUaW1lKHRoaXMucGxheWJhY2tSYXRlLCB0aGlzLmNvbnRleHQuY3VycmVudFRpbWUsIDAuMDEpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRnZXRQbGF5YmFja1JhdGUoKSB7XG5cdFx0cmV0dXJuIHRoaXMucGxheWJhY2tSYXRlO1xuXHR9XG5cdG9uRW5kZWQoKSB7XG5cdFx0dGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcblx0fVxuXHRnZXRMb29wKCkge1xuXHRcdGlmICh0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9PT0gZmFsc2UpIHtcblx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuJyk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmxvb3A7XG5cdH1cblx0c2V0TG9vcCh2YWx1ZSkge1xuXHRcdGlmICh0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9PT0gZmFsc2UpIHtcblx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuJyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMubG9vcCA9IHZhbHVlO1xuXHRcdGlmICh0aGlzLmlzUGxheWluZyA9PT0gdHJ1ZSkge1xuXHRcdFx0dGhpcy5zb3VyY2UubG9vcCA9IHRoaXMubG9vcDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0c2V0TG9vcFN0YXJ0KHZhbHVlKSB7XG5cdFx0dGhpcy5sb29wU3RhcnQgPSB2YWx1ZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRzZXRMb29wRW5kKHZhbHVlKSB7XG5cdFx0dGhpcy5sb29wRW5kID0gdmFsdWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0Z2V0Vm9sdW1lKCkge1xuXHRcdHJldHVybiB0aGlzLmdhaW4uZ2Fpbi52YWx1ZTtcblx0fVxuXHRzZXRWb2x1bWUodmFsdWUpIHtcblx0XHR0aGlzLmdhaW4uZ2Fpbi5zZXRUYXJnZXRBdFRpbWUodmFsdWUsIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSwgMC4wMSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn1cblxuY29uc3QgX3Bvc2l0aW9uID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5jb25zdCBfcXVhdGVybmlvbiA9IC8qQF9fUFVSRV9fKi9uZXcgUXVhdGVybmlvbigpO1xuY29uc3QgX3NjYWxlID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5jb25zdCBfb3JpZW50YXRpb24gPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcbmNsYXNzIFBvc2l0aW9uYWxBdWRpbyBleHRlbmRzIEF1ZGlvIHtcblx0Y29uc3RydWN0b3IobGlzdGVuZXIpIHtcblx0XHRzdXBlcihsaXN0ZW5lcik7XG5cdFx0dGhpcy5wYW5uZXIgPSB0aGlzLmNvbnRleHQuY3JlYXRlUGFubmVyKCk7XG5cdFx0dGhpcy5wYW5uZXIucGFubmluZ01vZGVsID0gJ0hSVEYnO1xuXHRcdHRoaXMucGFubmVyLmNvbm5lY3QodGhpcy5nYWluKTtcblx0fVxuXHRkaXNjb25uZWN0KCkge1xuXHRcdHN1cGVyLmRpc2Nvbm5lY3QoKTtcblx0XHR0aGlzLnBhbm5lci5kaXNjb25uZWN0KHRoaXMuZ2Fpbik7XG5cdH1cblx0Z2V0T3V0cHV0KCkge1xuXHRcdHJldHVybiB0aGlzLnBhbm5lcjtcblx0fVxuXHRnZXRSZWZEaXN0YW5jZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5wYW5uZXIucmVmRGlzdGFuY2U7XG5cdH1cblx0c2V0UmVmRGlzdGFuY2UodmFsdWUpIHtcblx0XHR0aGlzLnBhbm5lci5yZWZEaXN0YW5jZSA9IHZhbHVlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGdldFJvbGxvZmZGYWN0b3IoKSB7XG5cdFx0cmV0dXJuIHRoaXMucGFubmVyLnJvbGxvZmZGYWN0b3I7XG5cdH1cblx0c2V0Um9sbG9mZkZhY3Rvcih2YWx1ZSkge1xuXHRcdHRoaXMucGFubmVyLnJvbGxvZmZGYWN0b3IgPSB2YWx1ZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRnZXREaXN0YW5jZU1vZGVsKCkge1xuXHRcdHJldHVybiB0aGlzLnBhbm5lci5kaXN0YW5jZU1vZGVsO1xuXHR9XG5cdHNldERpc3RhbmNlTW9kZWwodmFsdWUpIHtcblx0XHR0aGlzLnBhbm5lci5kaXN0YW5jZU1vZGVsID0gdmFsdWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0Z2V0TWF4RGlzdGFuY2UoKSB7XG5cdFx0cmV0dXJuIHRoaXMucGFubmVyLm1heERpc3RhbmNlO1xuXHR9XG5cdHNldE1heERpc3RhbmNlKHZhbHVlKSB7XG5cdFx0dGhpcy5wYW5uZXIubWF4RGlzdGFuY2UgPSB2YWx1ZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRzZXREaXJlY3Rpb25hbENvbmUoY29uZUlubmVyQW5nbGUsIGNvbmVPdXRlckFuZ2xlLCBjb25lT3V0ZXJHYWluKSB7XG5cdFx0dGhpcy5wYW5uZXIuY29uZUlubmVyQW5nbGUgPSBjb25lSW5uZXJBbmdsZTtcblx0XHR0aGlzLnBhbm5lci5jb25lT3V0ZXJBbmdsZSA9IGNvbmVPdXRlckFuZ2xlO1xuXHRcdHRoaXMucGFubmVyLmNvbmVPdXRlckdhaW4gPSBjb25lT3V0ZXJHYWluO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHVwZGF0ZU1hdHJpeFdvcmxkKGZvcmNlKSB7XG5cdFx0c3VwZXIudXBkYXRlTWF0cml4V29ybGQoZm9yY2UpO1xuXHRcdGlmICh0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9PT0gdHJ1ZSAmJiB0aGlzLmlzUGxheWluZyA9PT0gZmFsc2UpIHJldHVybjtcblx0XHR0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZShfcG9zaXRpb24sIF9xdWF0ZXJuaW9uLCBfc2NhbGUpO1xuXHRcdF9vcmllbnRhdGlvbi5zZXQoMCwgMCwgMSkuYXBwbHlRdWF0ZXJuaW9uKF9xdWF0ZXJuaW9uKTtcblx0XHRjb25zdCBwYW5uZXIgPSB0aGlzLnBhbm5lcjtcblx0XHRpZiAocGFubmVyLnBvc2l0aW9uWCkge1xuXHRcdFx0Ly8gY29kZSBwYXRoIGZvciBDaHJvbWUgYW5kIEZpcmVmb3ggKHNlZSAjMTQzOTMpXG5cblx0XHRcdGNvbnN0IGVuZFRpbWUgPSB0aGlzLmNvbnRleHQuY3VycmVudFRpbWUgKyB0aGlzLmxpc3RlbmVyLnRpbWVEZWx0YTtcblx0XHRcdHBhbm5lci5wb3NpdGlvblgubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoX3Bvc2l0aW9uLngsIGVuZFRpbWUpO1xuXHRcdFx0cGFubmVyLnBvc2l0aW9uWS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShfcG9zaXRpb24ueSwgZW5kVGltZSk7XG5cdFx0XHRwYW5uZXIucG9zaXRpb25aLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKF9wb3NpdGlvbi56LCBlbmRUaW1lKTtcblx0XHRcdHBhbm5lci5vcmllbnRhdGlvblgubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoX29yaWVudGF0aW9uLngsIGVuZFRpbWUpO1xuXHRcdFx0cGFubmVyLm9yaWVudGF0aW9uWS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShfb3JpZW50YXRpb24ueSwgZW5kVGltZSk7XG5cdFx0XHRwYW5uZXIub3JpZW50YXRpb25aLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKF9vcmllbnRhdGlvbi56LCBlbmRUaW1lKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGFubmVyLnNldFBvc2l0aW9uKF9wb3NpdGlvbi54LCBfcG9zaXRpb24ueSwgX3Bvc2l0aW9uLnopO1xuXHRcdFx0cGFubmVyLnNldE9yaWVudGF0aW9uKF9vcmllbnRhdGlvbi54LCBfb3JpZW50YXRpb24ueSwgX29yaWVudGF0aW9uLnopO1xuXHRcdH1cblx0fVxufVxuXG5jbGFzcyBBdWRpb0FuYWx5c2VyIHtcblx0Y29uc3RydWN0b3IoYXVkaW8sIGZmdFNpemUgPSAyMDQ4KSB7XG5cdFx0dGhpcy5hbmFseXNlciA9IGF1ZGlvLmNvbnRleHQuY3JlYXRlQW5hbHlzZXIoKTtcblx0XHR0aGlzLmFuYWx5c2VyLmZmdFNpemUgPSBmZnRTaXplO1xuXHRcdHRoaXMuZGF0YSA9IG5ldyBVaW50OEFycmF5KHRoaXMuYW5hbHlzZXIuZnJlcXVlbmN5QmluQ291bnQpO1xuXHRcdGF1ZGlvLmdldE91dHB1dCgpLmNvbm5lY3QodGhpcy5hbmFseXNlcik7XG5cdH1cblx0Z2V0RnJlcXVlbmN5RGF0YSgpIHtcblx0XHR0aGlzLmFuYWx5c2VyLmdldEJ5dGVGcmVxdWVuY3lEYXRhKHRoaXMuZGF0YSk7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YTtcblx0fVxuXHRnZXRBdmVyYWdlRnJlcXVlbmN5KCkge1xuXHRcdGxldCB2YWx1ZSA9IDA7XG5cdFx0Y29uc3QgZGF0YSA9IHRoaXMuZ2V0RnJlcXVlbmN5RGF0YSgpO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFsdWUgKz0gZGF0YVtpXTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbHVlIC8gZGF0YS5sZW5ndGg7XG5cdH1cbn1cblxuY2xhc3MgUHJvcGVydHlNaXhlciB7XG5cdGNvbnN0cnVjdG9yKGJpbmRpbmcsIHR5cGVOYW1lLCB2YWx1ZVNpemUpIHtcblx0XHR0aGlzLmJpbmRpbmcgPSBiaW5kaW5nO1xuXHRcdHRoaXMudmFsdWVTaXplID0gdmFsdWVTaXplO1xuXHRcdGxldCBtaXhGdW5jdGlvbiwgbWl4RnVuY3Rpb25BZGRpdGl2ZSwgc2V0SWRlbnRpdHk7XG5cblx0XHQvLyBidWZmZXIgbGF5b3V0OiBbIGluY29taW5nIHwgYWNjdTAgfCBhY2N1MSB8IG9yaWcgfCBhZGRBY2N1IHwgKG9wdGlvbmFsIHdvcmspIF1cblx0XHQvL1xuXHRcdC8vIGludGVycG9sYXRvcnMgY2FuIHVzZSAuYnVmZmVyIGFzIHRoZWlyIC5yZXN1bHRcblx0XHQvLyB0aGUgZGF0YSB0aGVuIGdvZXMgdG8gJ2luY29taW5nJ1xuXHRcdC8vXG5cdFx0Ly8gJ2FjY3UwJyBhbmQgJ2FjY3UxJyBhcmUgdXNlZCBmcmFtZS1pbnRlcmxlYXZlZCBmb3Jcblx0XHQvLyB0aGUgY3VtdWxhdGl2ZSByZXN1bHQgYW5kIGFyZSBjb21wYXJlZCB0byBkZXRlY3Rcblx0XHQvLyBjaGFuZ2VzXG5cdFx0Ly9cblx0XHQvLyAnb3JpZycgc3RvcmVzIHRoZSBvcmlnaW5hbCBzdGF0ZSBvZiB0aGUgcHJvcGVydHlcblx0XHQvL1xuXHRcdC8vICdhZGQnIGlzIHVzZWQgZm9yIGFkZGl0aXZlIGN1bXVsYXRpdmUgcmVzdWx0c1xuXHRcdC8vXG5cdFx0Ly8gJ3dvcmsnIGlzIG9wdGlvbmFsIGFuZCBpcyBvbmx5IHByZXNlbnQgZm9yIHF1YXRlcm5pb24gdHlwZXMuIEl0IGlzIHVzZWRcblx0XHQvLyB0byBzdG9yZSBpbnRlcm1lZGlhdGUgcXVhdGVybmlvbiBtdWx0aXBsaWNhdGlvbiByZXN1bHRzXG5cblx0XHRzd2l0Y2ggKHR5cGVOYW1lKSB7XG5cdFx0XHRjYXNlICdxdWF0ZXJuaW9uJzpcblx0XHRcdFx0bWl4RnVuY3Rpb24gPSB0aGlzLl9zbGVycDtcblx0XHRcdFx0bWl4RnVuY3Rpb25BZGRpdGl2ZSA9IHRoaXMuX3NsZXJwQWRkaXRpdmU7XG5cdFx0XHRcdHNldElkZW50aXR5ID0gdGhpcy5fc2V0QWRkaXRpdmVJZGVudGl0eVF1YXRlcm5pb247XG5cdFx0XHRcdHRoaXMuYnVmZmVyID0gbmV3IEZsb2F0NjRBcnJheSh2YWx1ZVNpemUgKiA2KTtcblx0XHRcdFx0dGhpcy5fd29ya0luZGV4ID0gNTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdzdHJpbmcnOlxuXHRcdFx0Y2FzZSAnYm9vbCc6XG5cdFx0XHRcdG1peEZ1bmN0aW9uID0gdGhpcy5fc2VsZWN0O1xuXG5cdFx0XHRcdC8vIFVzZSB0aGUgcmVndWxhciBtaXggZnVuY3Rpb24gYW5kIGZvciBhZGRpdGl2ZSBvbiB0aGVzZSB0eXBlcyxcblx0XHRcdFx0Ly8gYWRkaXRpdmUgaXMgbm90IHJlbGV2YW50IGZvciBub24tbnVtZXJpYyB0eXBlc1xuXHRcdFx0XHRtaXhGdW5jdGlvbkFkZGl0aXZlID0gdGhpcy5fc2VsZWN0O1xuXHRcdFx0XHRzZXRJZGVudGl0eSA9IHRoaXMuX3NldEFkZGl0aXZlSWRlbnRpdHlPdGhlcjtcblx0XHRcdFx0dGhpcy5idWZmZXIgPSBuZXcgQXJyYXkodmFsdWVTaXplICogNSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0bWl4RnVuY3Rpb24gPSB0aGlzLl9sZXJwO1xuXHRcdFx0XHRtaXhGdW5jdGlvbkFkZGl0aXZlID0gdGhpcy5fbGVycEFkZGl0aXZlO1xuXHRcdFx0XHRzZXRJZGVudGl0eSA9IHRoaXMuX3NldEFkZGl0aXZlSWRlbnRpdHlOdW1lcmljO1xuXHRcdFx0XHR0aGlzLmJ1ZmZlciA9IG5ldyBGbG9hdDY0QXJyYXkodmFsdWVTaXplICogNSk7XG5cdFx0fVxuXHRcdHRoaXMuX21peEJ1ZmZlclJlZ2lvbiA9IG1peEZ1bmN0aW9uO1xuXHRcdHRoaXMuX21peEJ1ZmZlclJlZ2lvbkFkZGl0aXZlID0gbWl4RnVuY3Rpb25BZGRpdGl2ZTtcblx0XHR0aGlzLl9zZXRJZGVudGl0eSA9IHNldElkZW50aXR5O1xuXHRcdHRoaXMuX29yaWdJbmRleCA9IDM7XG5cdFx0dGhpcy5fYWRkSW5kZXggPSA0O1xuXHRcdHRoaXMuY3VtdWxhdGl2ZVdlaWdodCA9IDA7XG5cdFx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0QWRkaXRpdmUgPSAwO1xuXHRcdHRoaXMudXNlQ291bnQgPSAwO1xuXHRcdHRoaXMucmVmZXJlbmNlQ291bnQgPSAwO1xuXHR9XG5cblx0Ly8gYWNjdW11bGF0ZSBkYXRhIGluIHRoZSAnaW5jb21pbmcnIHJlZ2lvbiBpbnRvICdhY2N1PGk+J1xuXHRhY2N1bXVsYXRlKGFjY3VJbmRleCwgd2VpZ2h0KSB7XG5cdFx0Ly8gbm90ZTogaGFwcGlseSBhY2N1bXVsYXRpbmcgbm90aGluZyB3aGVuIHdlaWdodCA9IDAsIHRoZSBjYWxsZXIga25vd3Ncblx0XHQvLyB0aGUgd2VpZ2h0IGFuZCBzaG91bGRuJ3QgaGF2ZSBtYWRlIHRoZSBjYWxsIGluIHRoZSBmaXJzdCBwbGFjZVxuXG5cdFx0Y29uc3QgYnVmZmVyID0gdGhpcy5idWZmZXIsXG5cdFx0XHRzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZSxcblx0XHRcdG9mZnNldCA9IGFjY3VJbmRleCAqIHN0cmlkZSArIHN0cmlkZTtcblx0XHRsZXQgY3VycmVudFdlaWdodCA9IHRoaXMuY3VtdWxhdGl2ZVdlaWdodDtcblx0XHRpZiAoY3VycmVudFdlaWdodCA9PT0gMCkge1xuXHRcdFx0Ly8gYWNjdU4gOj0gaW5jb21pbmcgKiB3ZWlnaHRcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgIT09IHN0cmlkZTsgKytpKSB7XG5cdFx0XHRcdGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGJ1ZmZlcltpXTtcblx0XHRcdH1cblx0XHRcdGN1cnJlbnRXZWlnaHQgPSB3ZWlnaHQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGFjY3VOIDo9IGFjY3VOICsgaW5jb21pbmcgKiB3ZWlnaHRcblxuXHRcdFx0Y3VycmVudFdlaWdodCArPSB3ZWlnaHQ7XG5cdFx0XHRjb25zdCBtaXggPSB3ZWlnaHQgLyBjdXJyZW50V2VpZ2h0O1xuXHRcdFx0dGhpcy5fbWl4QnVmZmVyUmVnaW9uKGJ1ZmZlciwgb2Zmc2V0LCAwLCBtaXgsIHN0cmlkZSk7XG5cdFx0fVxuXHRcdHRoaXMuY3VtdWxhdGl2ZVdlaWdodCA9IGN1cnJlbnRXZWlnaHQ7XG5cdH1cblxuXHQvLyBhY2N1bXVsYXRlIGRhdGEgaW4gdGhlICdpbmNvbWluZycgcmVnaW9uIGludG8gJ2FkZCdcblx0YWNjdW11bGF0ZUFkZGl0aXZlKHdlaWdodCkge1xuXHRcdGNvbnN0IGJ1ZmZlciA9IHRoaXMuYnVmZmVyLFxuXHRcdFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXG5cdFx0XHRvZmZzZXQgPSBzdHJpZGUgKiB0aGlzLl9hZGRJbmRleDtcblx0XHRpZiAodGhpcy5jdW11bGF0aXZlV2VpZ2h0QWRkaXRpdmUgPT09IDApIHtcblx0XHRcdC8vIGFkZCA9IGlkZW50aXR5XG5cblx0XHRcdHRoaXMuX3NldElkZW50aXR5KCk7XG5cdFx0fVxuXG5cdFx0Ly8gYWRkIDo9IGFkZCArIGluY29taW5nICogd2VpZ2h0XG5cblx0XHR0aGlzLl9taXhCdWZmZXJSZWdpb25BZGRpdGl2ZShidWZmZXIsIG9mZnNldCwgMCwgd2VpZ2h0LCBzdHJpZGUpO1xuXHRcdHRoaXMuY3VtdWxhdGl2ZVdlaWdodEFkZGl0aXZlICs9IHdlaWdodDtcblx0fVxuXG5cdC8vIGFwcGx5IHRoZSBzdGF0ZSBvZiAnYWNjdTxpPicgdG8gdGhlIGJpbmRpbmcgd2hlbiBhY2N1cyBkaWZmZXJcblx0YXBwbHkoYWNjdUluZGV4KSB7XG5cdFx0Y29uc3Qgc3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXG5cdFx0XHRidWZmZXIgPSB0aGlzLmJ1ZmZlcixcblx0XHRcdG9mZnNldCA9IGFjY3VJbmRleCAqIHN0cmlkZSArIHN0cmlkZSxcblx0XHRcdHdlaWdodCA9IHRoaXMuY3VtdWxhdGl2ZVdlaWdodCxcblx0XHRcdHdlaWdodEFkZGl0aXZlID0gdGhpcy5jdW11bGF0aXZlV2VpZ2h0QWRkaXRpdmUsXG5cdFx0XHRiaW5kaW5nID0gdGhpcy5iaW5kaW5nO1xuXHRcdHRoaXMuY3VtdWxhdGl2ZVdlaWdodCA9IDA7XG5cdFx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0QWRkaXRpdmUgPSAwO1xuXHRcdGlmICh3ZWlnaHQgPCAxKSB7XG5cdFx0XHQvLyBhY2N1TiA6PSBhY2N1TiArIG9yaWdpbmFsICogKCAxIC0gY3VtdWxhdGl2ZVdlaWdodCApXG5cblx0XHRcdGNvbnN0IG9yaWdpbmFsVmFsdWVPZmZzZXQgPSBzdHJpZGUgKiB0aGlzLl9vcmlnSW5kZXg7XG5cdFx0XHR0aGlzLl9taXhCdWZmZXJSZWdpb24oYnVmZmVyLCBvZmZzZXQsIG9yaWdpbmFsVmFsdWVPZmZzZXQsIDEgLSB3ZWlnaHQsIHN0cmlkZSk7XG5cdFx0fVxuXHRcdGlmICh3ZWlnaHRBZGRpdGl2ZSA+IDApIHtcblx0XHRcdC8vIGFjY3VOIDo9IGFjY3VOICsgYWRkaXRpdmUgYWNjdU5cblxuXHRcdFx0dGhpcy5fbWl4QnVmZmVyUmVnaW9uQWRkaXRpdmUoYnVmZmVyLCBvZmZzZXQsIHRoaXMuX2FkZEluZGV4ICogc3RyaWRlLCAxLCBzdHJpZGUpO1xuXHRcdH1cblx0XHRmb3IgKGxldCBpID0gc3RyaWRlLCBlID0gc3RyaWRlICsgc3RyaWRlOyBpICE9PSBlOyArK2kpIHtcblx0XHRcdGlmIChidWZmZXJbaV0gIT09IGJ1ZmZlcltpICsgc3RyaWRlXSkge1xuXHRcdFx0XHQvLyB2YWx1ZSBoYXMgY2hhbmdlZCAtPiB1cGRhdGUgc2NlbmUgZ3JhcGhcblxuXHRcdFx0XHRiaW5kaW5nLnNldFZhbHVlKGJ1ZmZlciwgb2Zmc2V0KTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gcmVtZW1iZXIgdGhlIHN0YXRlIG9mIHRoZSBib3VuZCBwcm9wZXJ0eSBhbmQgY29weSBpdCB0byBib3RoIGFjY3VzXG5cdHNhdmVPcmlnaW5hbFN0YXRlKCkge1xuXHRcdGNvbnN0IGJpbmRpbmcgPSB0aGlzLmJpbmRpbmc7XG5cdFx0Y29uc3QgYnVmZmVyID0gdGhpcy5idWZmZXIsXG5cdFx0XHRzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZSxcblx0XHRcdG9yaWdpbmFsVmFsdWVPZmZzZXQgPSBzdHJpZGUgKiB0aGlzLl9vcmlnSW5kZXg7XG5cdFx0YmluZGluZy5nZXRWYWx1ZShidWZmZXIsIG9yaWdpbmFsVmFsdWVPZmZzZXQpO1xuXG5cdFx0Ly8gYWNjdVswLi4xXSA6PSBvcmlnIC0tIGluaXRpYWxseSBkZXRlY3QgY2hhbmdlcyBhZ2FpbnN0IHRoZSBvcmlnaW5hbFxuXHRcdGZvciAobGV0IGkgPSBzdHJpZGUsIGUgPSBvcmlnaW5hbFZhbHVlT2Zmc2V0OyBpICE9PSBlOyArK2kpIHtcblx0XHRcdGJ1ZmZlcltpXSA9IGJ1ZmZlcltvcmlnaW5hbFZhbHVlT2Zmc2V0ICsgaSAlIHN0cmlkZV07XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHRvIGlkZW50aXR5IGZvciBhZGRpdGl2ZVxuXHRcdHRoaXMuX3NldElkZW50aXR5KCk7XG5cdFx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0ID0gMDtcblx0XHR0aGlzLmN1bXVsYXRpdmVXZWlnaHRBZGRpdGl2ZSA9IDA7XG5cdH1cblxuXHQvLyBhcHBseSB0aGUgc3RhdGUgcHJldmlvdXNseSB0YWtlbiB2aWEgJ3NhdmVPcmlnaW5hbFN0YXRlJyB0byB0aGUgYmluZGluZ1xuXHRyZXN0b3JlT3JpZ2luYWxTdGF0ZSgpIHtcblx0XHRjb25zdCBvcmlnaW5hbFZhbHVlT2Zmc2V0ID0gdGhpcy52YWx1ZVNpemUgKiAzO1xuXHRcdHRoaXMuYmluZGluZy5zZXRWYWx1ZSh0aGlzLmJ1ZmZlciwgb3JpZ2luYWxWYWx1ZU9mZnNldCk7XG5cdH1cblx0X3NldEFkZGl0aXZlSWRlbnRpdHlOdW1lcmljKCkge1xuXHRcdGNvbnN0IHN0YXJ0SW5kZXggPSB0aGlzLl9hZGRJbmRleCAqIHRoaXMudmFsdWVTaXplO1xuXHRcdGNvbnN0IGVuZEluZGV4ID0gc3RhcnRJbmRleCArIHRoaXMudmFsdWVTaXplO1xuXHRcdGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXg7IGkrKykge1xuXHRcdFx0dGhpcy5idWZmZXJbaV0gPSAwO1xuXHRcdH1cblx0fVxuXHRfc2V0QWRkaXRpdmVJZGVudGl0eVF1YXRlcm5pb24oKSB7XG5cdFx0dGhpcy5fc2V0QWRkaXRpdmVJZGVudGl0eU51bWVyaWMoKTtcblx0XHR0aGlzLmJ1ZmZlclt0aGlzLl9hZGRJbmRleCAqIHRoaXMudmFsdWVTaXplICsgM10gPSAxO1xuXHR9XG5cdF9zZXRBZGRpdGl2ZUlkZW50aXR5T3RoZXIoKSB7XG5cdFx0Y29uc3Qgc3RhcnRJbmRleCA9IHRoaXMuX29yaWdJbmRleCAqIHRoaXMudmFsdWVTaXplO1xuXHRcdGNvbnN0IHRhcmdldEluZGV4ID0gdGhpcy5fYWRkSW5kZXggKiB0aGlzLnZhbHVlU2l6ZTtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmFsdWVTaXplOyBpKyspIHtcblx0XHRcdHRoaXMuYnVmZmVyW3RhcmdldEluZGV4ICsgaV0gPSB0aGlzLmJ1ZmZlcltzdGFydEluZGV4ICsgaV07XG5cdFx0fVxuXHR9XG5cblx0Ly8gbWl4IGZ1bmN0aW9uc1xuXG5cdF9zZWxlY3QoYnVmZmVyLCBkc3RPZmZzZXQsIHNyY09mZnNldCwgdCwgc3RyaWRlKSB7XG5cdFx0aWYgKHQgPj0gMC41KSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSAhPT0gc3RyaWRlOyArK2kpIHtcblx0XHRcdFx0YnVmZmVyW2RzdE9mZnNldCArIGldID0gYnVmZmVyW3NyY09mZnNldCArIGldO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRfc2xlcnAoYnVmZmVyLCBkc3RPZmZzZXQsIHNyY09mZnNldCwgdCkge1xuXHRcdFF1YXRlcm5pb24uc2xlcnBGbGF0KGJ1ZmZlciwgZHN0T2Zmc2V0LCBidWZmZXIsIGRzdE9mZnNldCwgYnVmZmVyLCBzcmNPZmZzZXQsIHQpO1xuXHR9XG5cdF9zbGVycEFkZGl0aXZlKGJ1ZmZlciwgZHN0T2Zmc2V0LCBzcmNPZmZzZXQsIHQsIHN0cmlkZSkge1xuXHRcdGNvbnN0IHdvcmtPZmZzZXQgPSB0aGlzLl93b3JrSW5kZXggKiBzdHJpZGU7XG5cblx0XHQvLyBTdG9yZSByZXN1bHQgaW4gaW50ZXJtZWRpYXRlIGJ1ZmZlciBvZmZzZXRcblx0XHRRdWF0ZXJuaW9uLm11bHRpcGx5UXVhdGVybmlvbnNGbGF0KGJ1ZmZlciwgd29ya09mZnNldCwgYnVmZmVyLCBkc3RPZmZzZXQsIGJ1ZmZlciwgc3JjT2Zmc2V0KTtcblxuXHRcdC8vIFNsZXJwIHRvIHRoZSBpbnRlcm1lZGlhdGUgcmVzdWx0XG5cdFx0UXVhdGVybmlvbi5zbGVycEZsYXQoYnVmZmVyLCBkc3RPZmZzZXQsIGJ1ZmZlciwgZHN0T2Zmc2V0LCBidWZmZXIsIHdvcmtPZmZzZXQsIHQpO1xuXHR9XG5cdF9sZXJwKGJ1ZmZlciwgZHN0T2Zmc2V0LCBzcmNPZmZzZXQsIHQsIHN0cmlkZSkge1xuXHRcdGNvbnN0IHMgPSAxIC0gdDtcblx0XHRmb3IgKGxldCBpID0gMDsgaSAhPT0gc3RyaWRlOyArK2kpIHtcblx0XHRcdGNvbnN0IGogPSBkc3RPZmZzZXQgKyBpO1xuXHRcdFx0YnVmZmVyW2pdID0gYnVmZmVyW2pdICogcyArIGJ1ZmZlcltzcmNPZmZzZXQgKyBpXSAqIHQ7XG5cdFx0fVxuXHR9XG5cdF9sZXJwQWRkaXRpdmUoYnVmZmVyLCBkc3RPZmZzZXQsIHNyY09mZnNldCwgdCwgc3RyaWRlKSB7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgIT09IHN0cmlkZTsgKytpKSB7XG5cdFx0XHRjb25zdCBqID0gZHN0T2Zmc2V0ICsgaTtcblx0XHRcdGJ1ZmZlcltqXSA9IGJ1ZmZlcltqXSArIGJ1ZmZlcltzcmNPZmZzZXQgKyBpXSAqIHQ7XG5cdFx0fVxuXHR9XG59XG5cbi8vIENoYXJhY3RlcnMgW10uOi8gYXJlIHJlc2VydmVkIGZvciB0cmFjayBiaW5kaW5nIHN5bnRheC5cbmNvbnN0IF9SRVNFUlZFRF9DSEFSU19SRSA9ICdcXFxcW1xcXFxdXFxcXC46XFxcXC8nO1xuY29uc3QgX3Jlc2VydmVkUmUgPSBuZXcgUmVnRXhwKCdbJyArIF9SRVNFUlZFRF9DSEFSU19SRSArICddJywgJ2cnKTtcblxuLy8gQXR0ZW1wdHMgdG8gYWxsb3cgbm9kZSBuYW1lcyBmcm9tIGFueSBsYW5ndWFnZS4gRVM1J3MgYFxcd2AgcmVnZXhwIG1hdGNoZXNcbi8vIG9ubHkgbGF0aW4gY2hhcmFjdGVycywgYW5kIHRoZSB1bmljb2RlIFxccHtMfSBpcyBub3QgeWV0IHN1cHBvcnRlZC4gU29cbi8vIGluc3RlYWQsIHdlIGV4Y2x1ZGUgcmVzZXJ2ZWQgY2hhcmFjdGVycyBhbmQgbWF0Y2ggZXZlcnl0aGluZyBlbHNlLlxuY29uc3QgX3dvcmRDaGFyID0gJ1teJyArIF9SRVNFUlZFRF9DSEFSU19SRSArICddJztcbmNvbnN0IF93b3JkQ2hhck9yRG90ID0gJ1teJyArIF9SRVNFUlZFRF9DSEFSU19SRS5yZXBsYWNlKCdcXFxcLicsICcnKSArICddJztcblxuLy8gUGFyZW50IGRpcmVjdG9yaWVzLCBkZWxpbWl0ZWQgYnkgJy8nIG9yICc6Jy4gQ3VycmVudGx5IHVudXNlZCwgYnV0IG11c3Rcbi8vIGJlIG1hdGNoZWQgdG8gcGFyc2UgdGhlIHJlc3Qgb2YgdGhlIHRyYWNrIG5hbWUuXG5jb25zdCBfZGlyZWN0b3J5UmUgPSAvKkBfX1BVUkVfXyovIC8oKD86V0MrW1xcLzpdKSopLy5zb3VyY2UucmVwbGFjZSgnV0MnLCBfd29yZENoYXIpO1xuXG4vLyBUYXJnZXQgbm9kZS4gTWF5IGNvbnRhaW4gd29yZCBjaGFyYWN0ZXJzIChhLXpBLVowLTlfKSBhbmQgJy4nIG9yICctJy5cbmNvbnN0IF9ub2RlUmUgPSAvKkBfX1BVUkVfXyovIC8oV0NPRCspPy8uc291cmNlLnJlcGxhY2UoJ1dDT0QnLCBfd29yZENoYXJPckRvdCk7XG5cbi8vIE9iamVjdCBvbiB0YXJnZXQgbm9kZSwgYW5kIGFjY2Vzc29yLiBNYXkgbm90IGNvbnRhaW4gcmVzZXJ2ZWRcbi8vIGNoYXJhY3RlcnMuIEFjY2Vzc29yIG1heSBjb250YWluIGFueSBjaGFyYWN0ZXIgZXhjZXB0IGNsb3NpbmcgYnJhY2tldC5cbmNvbnN0IF9vYmplY3RSZSA9IC8qQF9fUFVSRV9fKi8gLyg/OlxcLihXQyspKD86XFxbKC4rKVxcXSk/KT8vLnNvdXJjZS5yZXBsYWNlKCdXQycsIF93b3JkQ2hhcik7XG5cbi8vIFByb3BlcnR5IGFuZCBhY2Nlc3Nvci4gTWF5IG5vdCBjb250YWluIHJlc2VydmVkIGNoYXJhY3RlcnMuIEFjY2Vzc29yIG1heVxuLy8gY29udGFpbiBhbnkgbm9uLWJyYWNrZXQgY2hhcmFjdGVycy5cbmNvbnN0IF9wcm9wZXJ0eVJlID0gLypAX19QVVJFX18qLyAvXFwuKFdDKykoPzpcXFsoLispXFxdKT8vLnNvdXJjZS5yZXBsYWNlKCdXQycsIF93b3JkQ2hhcik7XG5jb25zdCBfdHJhY2tSZSA9IG5ldyBSZWdFeHAoJycgKyAnXicgKyBfZGlyZWN0b3J5UmUgKyBfbm9kZVJlICsgX29iamVjdFJlICsgX3Byb3BlcnR5UmUgKyAnJCcpO1xuY29uc3QgX3N1cHBvcnRlZE9iamVjdE5hbWVzID0gWydtYXRlcmlhbCcsICdtYXRlcmlhbHMnLCAnYm9uZXMnLCAnbWFwJ107XG5jbGFzcyBDb21wb3NpdGUge1xuXHRjb25zdHJ1Y3Rvcih0YXJnZXRHcm91cCwgcGF0aCwgb3B0aW9uYWxQYXJzZWRQYXRoKSB7XG5cdFx0Y29uc3QgcGFyc2VkUGF0aCA9IG9wdGlvbmFsUGFyc2VkUGF0aCB8fCBQcm9wZXJ0eUJpbmRpbmcucGFyc2VUcmFja05hbWUocGF0aCk7XG5cdFx0dGhpcy5fdGFyZ2V0R3JvdXAgPSB0YXJnZXRHcm91cDtcblx0XHR0aGlzLl9iaW5kaW5ncyA9IHRhcmdldEdyb3VwLnN1YnNjcmliZV8ocGF0aCwgcGFyc2VkUGF0aCk7XG5cdH1cblx0Z2V0VmFsdWUoYXJyYXksIG9mZnNldCkge1xuXHRcdHRoaXMuYmluZCgpOyAvLyBiaW5kIGFsbCBiaW5kaW5nXG5cblx0XHRjb25zdCBmaXJzdFZhbGlkSW5kZXggPSB0aGlzLl90YXJnZXRHcm91cC5uQ2FjaGVkT2JqZWN0c18sXG5cdFx0XHRiaW5kaW5nID0gdGhpcy5fYmluZGluZ3NbZmlyc3RWYWxpZEluZGV4XTtcblxuXHRcdC8vIGFuZCBvbmx5IGNhbGwgLmdldFZhbHVlIG9uIHRoZSBmaXJzdFxuXHRcdGlmIChiaW5kaW5nICE9PSB1bmRlZmluZWQpIGJpbmRpbmcuZ2V0VmFsdWUoYXJyYXksIG9mZnNldCk7XG5cdH1cblx0c2V0VmFsdWUoYXJyYXksIG9mZnNldCkge1xuXHRcdGNvbnN0IGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3M7XG5cdFx0Zm9yIChsZXQgaSA9IHRoaXMuX3RhcmdldEdyb3VwLm5DYWNoZWRPYmplY3RzXywgbiA9IGJpbmRpbmdzLmxlbmd0aDsgaSAhPT0gbjsgKytpKSB7XG5cdFx0XHRiaW5kaW5nc1tpXS5zZXRWYWx1ZShhcnJheSwgb2Zmc2V0KTtcblx0XHR9XG5cdH1cblx0YmluZCgpIHtcblx0XHRjb25zdCBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzO1xuXHRcdGZvciAobGV0IGkgPSB0aGlzLl90YXJnZXRHcm91cC5uQ2FjaGVkT2JqZWN0c18sIG4gPSBiaW5kaW5ncy5sZW5ndGg7IGkgIT09IG47ICsraSkge1xuXHRcdFx0YmluZGluZ3NbaV0uYmluZCgpO1xuXHRcdH1cblx0fVxuXHR1bmJpbmQoKSB7XG5cdFx0Y29uc3QgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncztcblx0XHRmb3IgKGxldCBpID0gdGhpcy5fdGFyZ2V0R3JvdXAubkNhY2hlZE9iamVjdHNfLCBuID0gYmluZGluZ3MubGVuZ3RoOyBpICE9PSBuOyArK2kpIHtcblx0XHRcdGJpbmRpbmdzW2ldLnVuYmluZCgpO1xuXHRcdH1cblx0fVxufVxuXG4vLyBOb3RlOiBUaGlzIGNsYXNzIHVzZXMgYSBTdGF0ZSBwYXR0ZXJuIG9uIGEgcGVyLW1ldGhvZCBiYXNpczpcbi8vICdiaW5kJyBzZXRzICd0aGlzLmdldFZhbHVlJyAvICdzZXRWYWx1ZScgYW5kIHNoYWRvd3MgdGhlXG4vLyBwcm90b3R5cGUgdmVyc2lvbiBvZiB0aGVzZSBtZXRob2RzIHdpdGggb25lIHRoYXQgcmVwcmVzZW50c1xuLy8gdGhlIGJvdW5kIHN0YXRlLiBXaGVuIHRoZSBwcm9wZXJ0eSBpcyBub3QgZm91bmQsIHRoZSBtZXRob2RzXG4vLyBiZWNvbWUgbm8tb3BzLlxuY2xhc3MgUHJvcGVydHlCaW5kaW5nIHtcblx0Y29uc3RydWN0b3Iocm9vdE5vZGUsIHBhdGgsIHBhcnNlZFBhdGgpIHtcblx0XHR0aGlzLnBhdGggPSBwYXRoO1xuXHRcdHRoaXMucGFyc2VkUGF0aCA9IHBhcnNlZFBhdGggfHwgUHJvcGVydHlCaW5kaW5nLnBhcnNlVHJhY2tOYW1lKHBhdGgpO1xuXHRcdHRoaXMubm9kZSA9IFByb3BlcnR5QmluZGluZy5maW5kTm9kZShyb290Tm9kZSwgdGhpcy5wYXJzZWRQYXRoLm5vZGVOYW1lKSB8fCByb290Tm9kZTtcblx0XHR0aGlzLnJvb3ROb2RlID0gcm9vdE5vZGU7XG5cblx0XHQvLyBpbml0aWFsIHN0YXRlIG9mIHRoZXNlIG1ldGhvZHMgdGhhdCBjYWxscyAnYmluZCdcblx0XHR0aGlzLmdldFZhbHVlID0gdGhpcy5fZ2V0VmFsdWVfdW5ib3VuZDtcblx0XHR0aGlzLnNldFZhbHVlID0gdGhpcy5fc2V0VmFsdWVfdW5ib3VuZDtcblx0fVxuXHRzdGF0aWMgY3JlYXRlKHJvb3QsIHBhdGgsIHBhcnNlZFBhdGgpIHtcblx0XHRpZiAoIShyb290ICYmIHJvb3QuaXNBbmltYXRpb25PYmplY3RHcm91cCkpIHtcblx0XHRcdHJldHVybiBuZXcgUHJvcGVydHlCaW5kaW5nKHJvb3QsIHBhdGgsIHBhcnNlZFBhdGgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gbmV3IFByb3BlcnR5QmluZGluZy5Db21wb3NpdGUocm9vdCwgcGF0aCwgcGFyc2VkUGF0aCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJlcGxhY2VzIHNwYWNlcyB3aXRoIHVuZGVyc2NvcmVzIGFuZCByZW1vdmVzIHVuc3VwcG9ydGVkIGNoYXJhY3RlcnMgZnJvbVxuXHQgKiBub2RlIG5hbWVzLCB0byBlbnN1cmUgY29tcGF0aWJpbGl0eSB3aXRoIHBhcnNlVHJhY2tOYW1lKCkuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5vZGUgbmFtZSB0byBiZSBzYW5pdGl6ZWQuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdHN0YXRpYyBzYW5pdGl6ZU5vZGVOYW1lKG5hbWUpIHtcblx0XHRyZXR1cm4gbmFtZS5yZXBsYWNlKC9cXHMvZywgJ18nKS5yZXBsYWNlKF9yZXNlcnZlZFJlLCAnJyk7XG5cdH1cblx0c3RhdGljIHBhcnNlVHJhY2tOYW1lKHRyYWNrTmFtZSkge1xuXHRcdGNvbnN0IG1hdGNoZXMgPSBfdHJhY2tSZS5leGVjKHRyYWNrTmFtZSk7XG5cdFx0aWYgKG1hdGNoZXMgPT09IG51bGwpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignUHJvcGVydHlCaW5kaW5nOiBDYW5ub3QgcGFyc2UgdHJhY2tOYW1lOiAnICsgdHJhY2tOYW1lKTtcblx0XHR9XG5cdFx0Y29uc3QgcmVzdWx0cyA9IHtcblx0XHRcdC8vIGRpcmVjdG9yeU5hbWU6IG1hdGNoZXNbIDEgXSwgLy8gKHRzY2h3KSBjdXJyZW50bHkgdW51c2VkXG5cdFx0XHRub2RlTmFtZTogbWF0Y2hlc1syXSxcblx0XHRcdG9iamVjdE5hbWU6IG1hdGNoZXNbM10sXG5cdFx0XHRvYmplY3RJbmRleDogbWF0Y2hlc1s0XSxcblx0XHRcdHByb3BlcnR5TmFtZTogbWF0Y2hlc1s1XSxcblx0XHRcdC8vIHJlcXVpcmVkXG5cdFx0XHRwcm9wZXJ0eUluZGV4OiBtYXRjaGVzWzZdXG5cdFx0fTtcblx0XHRjb25zdCBsYXN0RG90ID0gcmVzdWx0cy5ub2RlTmFtZSAmJiByZXN1bHRzLm5vZGVOYW1lLmxhc3RJbmRleE9mKCcuJyk7XG5cdFx0aWYgKGxhc3REb3QgIT09IHVuZGVmaW5lZCAmJiBsYXN0RG90ICE9PSAtMSkge1xuXHRcdFx0Y29uc3Qgb2JqZWN0TmFtZSA9IHJlc3VsdHMubm9kZU5hbWUuc3Vic3RyaW5nKGxhc3REb3QgKyAxKTtcblxuXHRcdFx0Ly8gT2JqZWN0IG5hbWVzIG11c3QgYmUgY2hlY2tlZCBhZ2FpbnN0IGFuIGFsbG93bGlzdC4gT3RoZXJ3aXNlLCB0aGVyZVxuXHRcdFx0Ly8gaXMgbm8gd2F5IHRvIHBhcnNlICdmb28uYmFyLmJheic6ICdiYXonIG11c3QgYmUgYSBwcm9wZXJ0eSwgYnV0XG5cdFx0XHQvLyAnYmFyJyBjb3VsZCBiZSB0aGUgb2JqZWN0TmFtZSwgb3IgcGFydCBvZiBhIG5vZGVOYW1lICh3aGljaCBjYW5cblx0XHRcdC8vIGluY2x1ZGUgJy4nIGNoYXJhY3RlcnMpLlxuXHRcdFx0aWYgKF9zdXBwb3J0ZWRPYmplY3ROYW1lcy5pbmRleE9mKG9iamVjdE5hbWUpICE9PSAtMSkge1xuXHRcdFx0XHRyZXN1bHRzLm5vZGVOYW1lID0gcmVzdWx0cy5ub2RlTmFtZS5zdWJzdHJpbmcoMCwgbGFzdERvdCk7XG5cdFx0XHRcdHJlc3VsdHMub2JqZWN0TmFtZSA9IG9iamVjdE5hbWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChyZXN1bHRzLnByb3BlcnR5TmFtZSA9PT0gbnVsbCB8fCByZXN1bHRzLnByb3BlcnR5TmFtZS5sZW5ndGggPT09IDApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignUHJvcGVydHlCaW5kaW5nOiBjYW4gbm90IHBhcnNlIHByb3BlcnR5TmFtZSBmcm9tIHRyYWNrTmFtZTogJyArIHRyYWNrTmFtZSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHRzO1xuXHR9XG5cdHN0YXRpYyBmaW5kTm9kZShyb290LCBub2RlTmFtZSkge1xuXHRcdGlmIChub2RlTmFtZSA9PT0gdW5kZWZpbmVkIHx8IG5vZGVOYW1lID09PSAnJyB8fCBub2RlTmFtZSA9PT0gJy4nIHx8IG5vZGVOYW1lID09PSAtMSB8fCBub2RlTmFtZSA9PT0gcm9vdC5uYW1lIHx8IG5vZGVOYW1lID09PSByb290LnV1aWQpIHtcblx0XHRcdHJldHVybiByb290O1xuXHRcdH1cblxuXHRcdC8vIHNlYXJjaCBpbnRvIHNrZWxldG9uIGJvbmVzLlxuXHRcdGlmIChyb290LnNrZWxldG9uKSB7XG5cdFx0XHRjb25zdCBib25lID0gcm9vdC5za2VsZXRvbi5nZXRCb25lQnlOYW1lKG5vZGVOYW1lKTtcblx0XHRcdGlmIChib25lICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cmV0dXJuIGJvbmU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gc2VhcmNoIGludG8gbm9kZSBzdWJ0cmVlLlxuXHRcdGlmIChyb290LmNoaWxkcmVuKSB7XG5cdFx0XHRjb25zdCBzZWFyY2hOb2RlU3VidHJlZSA9IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0Y29uc3QgY2hpbGROb2RlID0gY2hpbGRyZW5baV07XG5cdFx0XHRcdFx0aWYgKGNoaWxkTm9kZS5uYW1lID09PSBub2RlTmFtZSB8fCBjaGlsZE5vZGUudXVpZCA9PT0gbm9kZU5hbWUpIHtcblx0XHRcdFx0XHRcdHJldHVybiBjaGlsZE5vZGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvbnN0IHJlc3VsdCA9IHNlYXJjaE5vZGVTdWJ0cmVlKGNoaWxkTm9kZS5jaGlsZHJlbik7XG5cdFx0XHRcdFx0aWYgKHJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH07XG5cdFx0XHRjb25zdCBzdWJUcmVlTm9kZSA9IHNlYXJjaE5vZGVTdWJ0cmVlKHJvb3QuY2hpbGRyZW4pO1xuXHRcdFx0aWYgKHN1YlRyZWVOb2RlKSB7XG5cdFx0XHRcdHJldHVybiBzdWJUcmVlTm9kZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyB0aGVzZSBhcmUgdXNlZCB0byBcImJpbmRcIiBhIG5vbmV4aXN0ZW50IHByb3BlcnR5XG5cdF9nZXRWYWx1ZV91bmF2YWlsYWJsZSgpIHt9XG5cdF9zZXRWYWx1ZV91bmF2YWlsYWJsZSgpIHt9XG5cblx0Ly8gR2V0dGVyc1xuXG5cdF9nZXRWYWx1ZV9kaXJlY3QoYnVmZmVyLCBvZmZzZXQpIHtcblx0XHRidWZmZXJbb2Zmc2V0XSA9IHRoaXMudGFyZ2V0T2JqZWN0W3RoaXMucHJvcGVydHlOYW1lXTtcblx0fVxuXHRfZ2V0VmFsdWVfYXJyYXkoYnVmZmVyLCBvZmZzZXQpIHtcblx0XHRjb25zdCBzb3VyY2UgPSB0aGlzLnJlc29sdmVkUHJvcGVydHk7XG5cdFx0Zm9yIChsZXQgaSA9IDAsIG4gPSBzb3VyY2UubGVuZ3RoOyBpICE9PSBuOyArK2kpIHtcblx0XHRcdGJ1ZmZlcltvZmZzZXQrK10gPSBzb3VyY2VbaV07XG5cdFx0fVxuXHR9XG5cdF9nZXRWYWx1ZV9hcnJheUVsZW1lbnQoYnVmZmVyLCBvZmZzZXQpIHtcblx0XHRidWZmZXJbb2Zmc2V0XSA9IHRoaXMucmVzb2x2ZWRQcm9wZXJ0eVt0aGlzLnByb3BlcnR5SW5kZXhdO1xuXHR9XG5cdF9nZXRWYWx1ZV90b0FycmF5KGJ1ZmZlciwgb2Zmc2V0KSB7XG5cdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5LnRvQXJyYXkoYnVmZmVyLCBvZmZzZXQpO1xuXHR9XG5cblx0Ly8gRGlyZWN0XG5cblx0X3NldFZhbHVlX2RpcmVjdChidWZmZXIsIG9mZnNldCkge1xuXHRcdHRoaXMudGFyZ2V0T2JqZWN0W3RoaXMucHJvcGVydHlOYW1lXSA9IGJ1ZmZlcltvZmZzZXRdO1xuXHR9XG5cdF9zZXRWYWx1ZV9kaXJlY3Rfc2V0TmVlZHNVcGRhdGUoYnVmZmVyLCBvZmZzZXQpIHtcblx0XHR0aGlzLnRhcmdldE9iamVjdFt0aGlzLnByb3BlcnR5TmFtZV0gPSBidWZmZXJbb2Zmc2V0XTtcblx0XHR0aGlzLnRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdH1cblx0X3NldFZhbHVlX2RpcmVjdF9zZXRNYXRyaXhXb3JsZE5lZWRzVXBkYXRlKGJ1ZmZlciwgb2Zmc2V0KSB7XG5cdFx0dGhpcy50YXJnZXRPYmplY3RbdGhpcy5wcm9wZXJ0eU5hbWVdID0gYnVmZmVyW29mZnNldF07XG5cdFx0dGhpcy50YXJnZXRPYmplY3QubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XG5cdH1cblxuXHQvLyBFbnRpcmVBcnJheVxuXG5cdF9zZXRWYWx1ZV9hcnJheShidWZmZXIsIG9mZnNldCkge1xuXHRcdGNvbnN0IGRlc3QgPSB0aGlzLnJlc29sdmVkUHJvcGVydHk7XG5cdFx0Zm9yIChsZXQgaSA9IDAsIG4gPSBkZXN0Lmxlbmd0aDsgaSAhPT0gbjsgKytpKSB7XG5cdFx0XHRkZXN0W2ldID0gYnVmZmVyW29mZnNldCsrXTtcblx0XHR9XG5cdH1cblx0X3NldFZhbHVlX2FycmF5X3NldE5lZWRzVXBkYXRlKGJ1ZmZlciwgb2Zmc2V0KSB7XG5cdFx0Y29uc3QgZGVzdCA9IHRoaXMucmVzb2x2ZWRQcm9wZXJ0eTtcblx0XHRmb3IgKGxldCBpID0gMCwgbiA9IGRlc3QubGVuZ3RoOyBpICE9PSBuOyArK2kpIHtcblx0XHRcdGRlc3RbaV0gPSBidWZmZXJbb2Zmc2V0KytdO1xuXHRcdH1cblx0XHR0aGlzLnRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdH1cblx0X3NldFZhbHVlX2FycmF5X3NldE1hdHJpeFdvcmxkTmVlZHNVcGRhdGUoYnVmZmVyLCBvZmZzZXQpIHtcblx0XHRjb25zdCBkZXN0ID0gdGhpcy5yZXNvbHZlZFByb3BlcnR5O1xuXHRcdGZvciAobGV0IGkgPSAwLCBuID0gZGVzdC5sZW5ndGg7IGkgIT09IG47ICsraSkge1xuXHRcdFx0ZGVzdFtpXSA9IGJ1ZmZlcltvZmZzZXQrK107XG5cdFx0fVxuXHRcdHRoaXMudGFyZ2V0T2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xuXHR9XG5cblx0Ly8gQXJyYXlFbGVtZW50XG5cblx0X3NldFZhbHVlX2FycmF5RWxlbWVudChidWZmZXIsIG9mZnNldCkge1xuXHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eVt0aGlzLnByb3BlcnR5SW5kZXhdID0gYnVmZmVyW29mZnNldF07XG5cdH1cblx0X3NldFZhbHVlX2FycmF5RWxlbWVudF9zZXROZWVkc1VwZGF0ZShidWZmZXIsIG9mZnNldCkge1xuXHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eVt0aGlzLnByb3BlcnR5SW5kZXhdID0gYnVmZmVyW29mZnNldF07XG5cdFx0dGhpcy50YXJnZXRPYmplY3QubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHR9XG5cdF9zZXRWYWx1ZV9hcnJheUVsZW1lbnRfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZShidWZmZXIsIG9mZnNldCkge1xuXHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eVt0aGlzLnByb3BlcnR5SW5kZXhdID0gYnVmZmVyW29mZnNldF07XG5cdFx0dGhpcy50YXJnZXRPYmplY3QubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XG5cdH1cblxuXHQvLyBIYXNUb0Zyb21BcnJheVxuXG5cdF9zZXRWYWx1ZV9mcm9tQXJyYXkoYnVmZmVyLCBvZmZzZXQpIHtcblx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHkuZnJvbUFycmF5KGJ1ZmZlciwgb2Zmc2V0KTtcblx0fVxuXHRfc2V0VmFsdWVfZnJvbUFycmF5X3NldE5lZWRzVXBkYXRlKGJ1ZmZlciwgb2Zmc2V0KSB7XG5cdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5LmZyb21BcnJheShidWZmZXIsIG9mZnNldCk7XG5cdFx0dGhpcy50YXJnZXRPYmplY3QubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHR9XG5cdF9zZXRWYWx1ZV9mcm9tQXJyYXlfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZShidWZmZXIsIG9mZnNldCkge1xuXHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eS5mcm9tQXJyYXkoYnVmZmVyLCBvZmZzZXQpO1xuXHRcdHRoaXMudGFyZ2V0T2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xuXHR9XG5cdF9nZXRWYWx1ZV91bmJvdW5kKHRhcmdldEFycmF5LCBvZmZzZXQpIHtcblx0XHR0aGlzLmJpbmQoKTtcblx0XHR0aGlzLmdldFZhbHVlKHRhcmdldEFycmF5LCBvZmZzZXQpO1xuXHR9XG5cdF9zZXRWYWx1ZV91bmJvdW5kKHNvdXJjZUFycmF5LCBvZmZzZXQpIHtcblx0XHR0aGlzLmJpbmQoKTtcblx0XHR0aGlzLnNldFZhbHVlKHNvdXJjZUFycmF5LCBvZmZzZXQpO1xuXHR9XG5cblx0Ly8gY3JlYXRlIGdldHRlciAvIHNldHRlciBwYWlyIGZvciBhIHByb3BlcnR5IGluIHRoZSBzY2VuZSBncmFwaFxuXHRiaW5kKCkge1xuXHRcdGxldCB0YXJnZXRPYmplY3QgPSB0aGlzLm5vZGU7XG5cdFx0Y29uc3QgcGFyc2VkUGF0aCA9IHRoaXMucGFyc2VkUGF0aDtcblx0XHRjb25zdCBvYmplY3ROYW1lID0gcGFyc2VkUGF0aC5vYmplY3ROYW1lO1xuXHRcdGNvbnN0IHByb3BlcnR5TmFtZSA9IHBhcnNlZFBhdGgucHJvcGVydHlOYW1lO1xuXHRcdGxldCBwcm9wZXJ0eUluZGV4ID0gcGFyc2VkUGF0aC5wcm9wZXJ0eUluZGV4O1xuXHRcdGlmICghdGFyZ2V0T2JqZWN0KSB7XG5cdFx0XHR0YXJnZXRPYmplY3QgPSBQcm9wZXJ0eUJpbmRpbmcuZmluZE5vZGUodGhpcy5yb290Tm9kZSwgcGFyc2VkUGF0aC5ub2RlTmFtZSkgfHwgdGhpcy5yb290Tm9kZTtcblx0XHRcdHRoaXMubm9kZSA9IHRhcmdldE9iamVjdDtcblx0XHR9XG5cblx0XHQvLyBzZXQgZmFpbCBzdGF0ZSBzbyB3ZSBjYW4ganVzdCAncmV0dXJuJyBvbiBlcnJvclxuXHRcdHRoaXMuZ2V0VmFsdWUgPSB0aGlzLl9nZXRWYWx1ZV91bmF2YWlsYWJsZTtcblx0XHR0aGlzLnNldFZhbHVlID0gdGhpcy5fc2V0VmFsdWVfdW5hdmFpbGFibGU7XG5cblx0XHQvLyBlbnN1cmUgdGhlcmUgaXMgYSB2YWx1ZSBub2RlXG5cdFx0aWYgKCF0YXJnZXRPYmplY3QpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLlByb3BlcnR5QmluZGluZzogVHJ5aW5nIHRvIHVwZGF0ZSBub2RlIGZvciB0cmFjazogJyArIHRoaXMucGF0aCArICcgYnV0IGl0IHdhc25cXCd0IGZvdW5kLicpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAob2JqZWN0TmFtZSkge1xuXHRcdFx0bGV0IG9iamVjdEluZGV4ID0gcGFyc2VkUGF0aC5vYmplY3RJbmRleDtcblxuXHRcdFx0Ly8gc3BlY2lhbCBjYXNlcyB3ZXJlIHdlIG5lZWQgdG8gcmVhY2ggZGVlcGVyIGludG8gdGhlIGhpZXJhcmNoeSB0byBnZXQgdGhlIGZhY2UgbWF0ZXJpYWxzLi4uLlxuXHRcdFx0c3dpdGNoIChvYmplY3ROYW1lKSB7XG5cdFx0XHRcdGNhc2UgJ21hdGVyaWFscyc6XG5cdFx0XHRcdFx0aWYgKCF0YXJnZXRPYmplY3QubWF0ZXJpYWwpIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLlByb3BlcnR5QmluZGluZzogQ2FuIG5vdCBiaW5kIHRvIG1hdGVyaWFsIGFzIG5vZGUgZG9lcyBub3QgaGF2ZSBhIG1hdGVyaWFsLicsIHRoaXMpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIXRhcmdldE9iamVjdC5tYXRlcmlhbC5tYXRlcmlhbHMpIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLlByb3BlcnR5QmluZGluZzogQ2FuIG5vdCBiaW5kIHRvIG1hdGVyaWFsLm1hdGVyaWFscyBhcyBub2RlLm1hdGVyaWFsIGRvZXMgbm90IGhhdmUgYSBtYXRlcmlhbHMgYXJyYXkuJywgdGhpcyk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRhcmdldE9iamVjdCA9IHRhcmdldE9iamVjdC5tYXRlcmlhbC5tYXRlcmlhbHM7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ2JvbmVzJzpcblx0XHRcdFx0XHRpZiAoIXRhcmdldE9iamVjdC5za2VsZXRvbikge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBDYW4gbm90IGJpbmQgdG8gYm9uZXMgYXMgbm9kZSBkb2VzIG5vdCBoYXZlIGEgc2tlbGV0b24uJywgdGhpcyk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gcG90ZW50aWFsIGZ1dHVyZSBvcHRpbWl6YXRpb246IHNraXAgdGhpcyBpZiBwcm9wZXJ0eUluZGV4IGlzIGFscmVhZHkgYW4gaW50ZWdlclxuXHRcdFx0XHRcdC8vIGFuZCBjb252ZXJ0IHRoZSBpbnRlZ2VyIHN0cmluZyB0byBhIHRydWUgaW50ZWdlci5cblxuXHRcdFx0XHRcdHRhcmdldE9iamVjdCA9IHRhcmdldE9iamVjdC5za2VsZXRvbi5ib25lcztcblxuXHRcdFx0XHRcdC8vIHN1cHBvcnQgcmVzb2x2aW5nIG1vcnBoVGFyZ2V0IG5hbWVzIGludG8gaW5kaWNlcy5cblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldE9iamVjdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0aWYgKHRhcmdldE9iamVjdFtpXS5uYW1lID09PSBvYmplY3RJbmRleCkge1xuXHRcdFx0XHRcdFx0XHRvYmplY3RJbmRleCA9IGk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnbWFwJzpcblx0XHRcdFx0XHRpZiAoJ21hcCcgaW4gdGFyZ2V0T2JqZWN0KSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3QubWFwO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICghdGFyZ2V0T2JqZWN0Lm1hdGVyaWFsKSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IENhbiBub3QgYmluZCB0byBtYXRlcmlhbCBhcyBub2RlIGRvZXMgbm90IGhhdmUgYSBtYXRlcmlhbC4nLCB0aGlzKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCF0YXJnZXRPYmplY3QubWF0ZXJpYWwubWFwKSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IENhbiBub3QgYmluZCB0byBtYXRlcmlhbC5tYXAgYXMgbm9kZS5tYXRlcmlhbCBkb2VzIG5vdCBoYXZlIGEgbWFwLicsIHRoaXMpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3QubWF0ZXJpYWwubWFwO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGlmICh0YXJnZXRPYmplY3Rbb2JqZWN0TmFtZV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBDYW4gbm90IGJpbmQgdG8gb2JqZWN0TmFtZSBvZiBub2RlIHVuZGVmaW5lZC4nLCB0aGlzKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGFyZ2V0T2JqZWN0ID0gdGFyZ2V0T2JqZWN0W29iamVjdE5hbWVdO1xuXHRcdFx0fVxuXHRcdFx0aWYgKG9iamVjdEluZGV4ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0aWYgKHRhcmdldE9iamVjdFtvYmplY3RJbmRleF0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLlByb3BlcnR5QmluZGluZzogVHJ5aW5nIHRvIGJpbmQgdG8gb2JqZWN0SW5kZXggb2Ygb2JqZWN0TmFtZSwgYnV0IGlzIHVuZGVmaW5lZC4nLCB0aGlzLCB0YXJnZXRPYmplY3QpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3Rbb2JqZWN0SW5kZXhdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHJlc29sdmUgcHJvcGVydHlcblx0XHRjb25zdCBub2RlUHJvcGVydHkgPSB0YXJnZXRPYmplY3RbcHJvcGVydHlOYW1lXTtcblx0XHRpZiAobm9kZVByb3BlcnR5ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGNvbnN0IG5vZGVOYW1lID0gcGFyc2VkUGF0aC5ub2RlTmFtZTtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLlByb3BlcnR5QmluZGluZzogVHJ5aW5nIHRvIHVwZGF0ZSBwcm9wZXJ0eSBmb3IgdHJhY2s6ICcgKyBub2RlTmFtZSArICcuJyArIHByb3BlcnR5TmFtZSArICcgYnV0IGl0IHdhc25cXCd0IGZvdW5kLicsIHRhcmdldE9iamVjdCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gZGV0ZXJtaW5lIHZlcnNpb25pbmcgc2NoZW1lXG5cdFx0bGV0IHZlcnNpb25pbmcgPSB0aGlzLlZlcnNpb25pbmcuTm9uZTtcblx0XHR0aGlzLnRhcmdldE9iamVjdCA9IHRhcmdldE9iamVjdDtcblx0XHRpZiAodGFyZ2V0T2JqZWN0Lm5lZWRzVXBkYXRlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdC8vIG1hdGVyaWFsXG5cblx0XHRcdHZlcnNpb25pbmcgPSB0aGlzLlZlcnNpb25pbmcuTmVlZHNVcGRhdGU7XG5cdFx0fSBlbHNlIGlmICh0YXJnZXRPYmplY3QubWF0cml4V29ybGROZWVkc1VwZGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHQvLyBub2RlIHRyYW5zZm9ybVxuXG5cdFx0XHR2ZXJzaW9uaW5nID0gdGhpcy5WZXJzaW9uaW5nLk1hdHJpeFdvcmxkTmVlZHNVcGRhdGU7XG5cdFx0fVxuXG5cdFx0Ly8gZGV0ZXJtaW5lIGhvdyB0aGUgcHJvcGVydHkgZ2V0cyBib3VuZFxuXHRcdGxldCBiaW5kaW5nVHlwZSA9IHRoaXMuQmluZGluZ1R5cGUuRGlyZWN0O1xuXHRcdGlmIChwcm9wZXJ0eUluZGV4ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdC8vIGFjY2VzcyBhIHN1YiBlbGVtZW50IG9mIHRoZSBwcm9wZXJ0eSBhcnJheSAob25seSBwcmltaXRpdmVzIGFyZSBzdXBwb3J0ZWQgcmlnaHQgbm93KVxuXG5cdFx0XHRpZiAocHJvcGVydHlOYW1lID09PSAnbW9ycGhUYXJnZXRJbmZsdWVuY2VzJykge1xuXHRcdFx0XHQvLyBwb3RlbnRpYWwgb3B0aW1pemF0aW9uLCBza2lwIHRoaXMgaWYgcHJvcGVydHlJbmRleCBpcyBhbHJlYWR5IGFuIGludGVnZXIsIGFuZCBjb252ZXJ0IHRoZSBpbnRlZ2VyIHN0cmluZyB0byBhIHRydWUgaW50ZWdlci5cblxuXHRcdFx0XHQvLyBzdXBwb3J0IHJlc29sdmluZyBtb3JwaFRhcmdldCBuYW1lcyBpbnRvIGluZGljZXMuXG5cdFx0XHRcdGlmICghdGFyZ2V0T2JqZWN0Lmdlb21ldHJ5KSB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBDYW4gbm90IGJpbmQgdG8gbW9ycGhUYXJnZXRJbmZsdWVuY2VzIGJlY2F1c2Ugbm9kZSBkb2VzIG5vdCBoYXZlIGEgZ2VvbWV0cnkuJywgdGhpcyk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghdGFyZ2V0T2JqZWN0Lmdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcykge1xuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLlByb3BlcnR5QmluZGluZzogQ2FuIG5vdCBiaW5kIHRvIG1vcnBoVGFyZ2V0SW5mbHVlbmNlcyBiZWNhdXNlIG5vZGUgZG9lcyBub3QgaGF2ZSBhIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy4nLCB0aGlzKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRhcmdldE9iamVjdC5tb3JwaFRhcmdldERpY3Rpb25hcnlbcHJvcGVydHlJbmRleF0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHByb3BlcnR5SW5kZXggPSB0YXJnZXRPYmplY3QubW9ycGhUYXJnZXREaWN0aW9uYXJ5W3Byb3BlcnR5SW5kZXhdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRiaW5kaW5nVHlwZSA9IHRoaXMuQmluZGluZ1R5cGUuQXJyYXlFbGVtZW50O1xuXHRcdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5ID0gbm9kZVByb3BlcnR5O1xuXHRcdFx0dGhpcy5wcm9wZXJ0eUluZGV4ID0gcHJvcGVydHlJbmRleDtcblx0XHR9IGVsc2UgaWYgKG5vZGVQcm9wZXJ0eS5mcm9tQXJyYXkgIT09IHVuZGVmaW5lZCAmJiBub2RlUHJvcGVydHkudG9BcnJheSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHQvLyBtdXN0IHVzZSBjb3B5IGZvciBPYmplY3QzRC5FdWxlci9RdWF0ZXJuaW9uXG5cblx0XHRcdGJpbmRpbmdUeXBlID0gdGhpcy5CaW5kaW5nVHlwZS5IYXNGcm9tVG9BcnJheTtcblx0XHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eSA9IG5vZGVQcm9wZXJ0eTtcblx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobm9kZVByb3BlcnR5KSkge1xuXHRcdFx0YmluZGluZ1R5cGUgPSB0aGlzLkJpbmRpbmdUeXBlLkVudGlyZUFycmF5O1xuXHRcdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5ID0gbm9kZVByb3BlcnR5O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZTtcblx0XHR9XG5cblx0XHQvLyBzZWxlY3QgZ2V0dGVyIC8gc2V0dGVyXG5cdFx0dGhpcy5nZXRWYWx1ZSA9IHRoaXMuR2V0dGVyQnlCaW5kaW5nVHlwZVtiaW5kaW5nVHlwZV07XG5cdFx0dGhpcy5zZXRWYWx1ZSA9IHRoaXMuU2V0dGVyQnlCaW5kaW5nVHlwZUFuZFZlcnNpb25pbmdbYmluZGluZ1R5cGVdW3ZlcnNpb25pbmddO1xuXHR9XG5cdHVuYmluZCgpIHtcblx0XHR0aGlzLm5vZGUgPSBudWxsO1xuXG5cdFx0Ly8gYmFjayB0byB0aGUgcHJvdG90eXBlIHZlcnNpb24gb2YgZ2V0VmFsdWUgLyBzZXRWYWx1ZVxuXHRcdC8vIG5vdGU6IGF2b2lkaW5nIHRvIG11dGF0ZSB0aGUgc2hhcGUgb2YgJ3RoaXMnIHZpYSAnZGVsZXRlJ1xuXHRcdHRoaXMuZ2V0VmFsdWUgPSB0aGlzLl9nZXRWYWx1ZV91bmJvdW5kO1xuXHRcdHRoaXMuc2V0VmFsdWUgPSB0aGlzLl9zZXRWYWx1ZV91bmJvdW5kO1xuXHR9XG59XG5Qcm9wZXJ0eUJpbmRpbmcuQ29tcG9zaXRlID0gQ29tcG9zaXRlO1xuUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5CaW5kaW5nVHlwZSA9IHtcblx0RGlyZWN0OiAwLFxuXHRFbnRpcmVBcnJheTogMSxcblx0QXJyYXlFbGVtZW50OiAyLFxuXHRIYXNGcm9tVG9BcnJheTogM1xufTtcblByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuVmVyc2lvbmluZyA9IHtcblx0Tm9uZTogMCxcblx0TmVlZHNVcGRhdGU6IDEsXG5cdE1hdHJpeFdvcmxkTmVlZHNVcGRhdGU6IDJcbn07XG5Qcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLkdldHRlckJ5QmluZGluZ1R5cGUgPSBbUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5fZ2V0VmFsdWVfZGlyZWN0LCBQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLl9nZXRWYWx1ZV9hcnJheSwgUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5fZ2V0VmFsdWVfYXJyYXlFbGVtZW50LCBQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLl9nZXRWYWx1ZV90b0FycmF5XTtcblByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuU2V0dGVyQnlCaW5kaW5nVHlwZUFuZFZlcnNpb25pbmcgPSBbW1xuLy8gRGlyZWN0XG5Qcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLl9zZXRWYWx1ZV9kaXJlY3QsIFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX3NldFZhbHVlX2RpcmVjdF9zZXROZWVkc1VwZGF0ZSwgUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5fc2V0VmFsdWVfZGlyZWN0X3NldE1hdHJpeFdvcmxkTmVlZHNVcGRhdGVdLCBbXG4vLyBFbnRpcmVBcnJheVxuXG5Qcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLl9zZXRWYWx1ZV9hcnJheSwgUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5fc2V0VmFsdWVfYXJyYXlfc2V0TmVlZHNVcGRhdGUsIFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX3NldFZhbHVlX2FycmF5X3NldE1hdHJpeFdvcmxkTmVlZHNVcGRhdGVdLCBbXG4vLyBBcnJheUVsZW1lbnRcblByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX3NldFZhbHVlX2FycmF5RWxlbWVudCwgUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5fc2V0VmFsdWVfYXJyYXlFbGVtZW50X3NldE5lZWRzVXBkYXRlLCBQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLl9zZXRWYWx1ZV9hcnJheUVsZW1lbnRfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZV0sIFtcbi8vIEhhc1RvRnJvbUFycmF5XG5Qcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLl9zZXRWYWx1ZV9mcm9tQXJyYXksIFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX3NldFZhbHVlX2Zyb21BcnJheV9zZXROZWVkc1VwZGF0ZSwgUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5fc2V0VmFsdWVfZnJvbUFycmF5X3NldE1hdHJpeFdvcmxkTmVlZHNVcGRhdGVdXTtcblxuLyoqXG4gKlxuICogQSBncm91cCBvZiBvYmplY3RzIHRoYXQgcmVjZWl2ZXMgYSBzaGFyZWQgYW5pbWF0aW9uIHN0YXRlLlxuICpcbiAqIFVzYWdlOlxuICpcbiAqXHQtIEFkZCBvYmplY3RzIHlvdSB3b3VsZCBvdGhlcndpc2UgcGFzcyBhcyAncm9vdCcgdG8gdGhlXG4gKlx0XHRjb25zdHJ1Y3RvciBvciB0aGUgLmNsaXBBY3Rpb24gbWV0aG9kIG9mIEFuaW1hdGlvbk1peGVyLlxuICpcbiAqXHQtIEluc3RlYWQgcGFzcyB0aGlzIG9iamVjdCBhcyAncm9vdCcuXG4gKlxuICpcdC0gWW91IGNhbiBhbHNvIGFkZCBhbmQgcmVtb3ZlIG9iamVjdHMgbGF0ZXIgd2hlbiB0aGUgbWl4ZXJcbiAqXHRcdGlzIHJ1bm5pbmcuXG4gKlxuICogTm90ZTpcbiAqXG4gKlx0XHRPYmplY3RzIG9mIHRoaXMgY2xhc3MgYXBwZWFyIGFzIG9uZSBvYmplY3QgdG8gdGhlIG1peGVyLFxuICpcdFx0c28gY2FjaGUgY29udHJvbCBvZiB0aGUgaW5kaXZpZHVhbCBvYmplY3RzIG11c3QgYmUgZG9uZVxuICpcdFx0b24gdGhlIGdyb3VwLlxuICpcbiAqIExpbWl0YXRpb246XG4gKlxuICpcdC0gVGhlIGFuaW1hdGVkIHByb3BlcnRpZXMgbXVzdCBiZSBjb21wYXRpYmxlIGFtb25nIHRoZVxuICpcdFx0YWxsIG9iamVjdHMgaW4gdGhlIGdyb3VwLlxuICpcbiAqXHQtIEEgc2luZ2xlIHByb3BlcnR5IGNhbiBlaXRoZXIgYmUgY29udHJvbGxlZCB0aHJvdWdoIGFcbiAqXHRcdHRhcmdldCBncm91cCBvciBkaXJlY3RseSwgYnV0IG5vdCBib3RoLlxuICovXG5cbmNsYXNzIEFuaW1hdGlvbk9iamVjdEdyb3VwIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0dGhpcy5pc0FuaW1hdGlvbk9iamVjdEdyb3VwID0gdHJ1ZTtcblx0XHR0aGlzLnV1aWQgPSBnZW5lcmF0ZVVVSUQoKTtcblxuXHRcdC8vIGNhY2hlZCBvYmplY3RzIGZvbGxvd2VkIGJ5IHRoZSBhY3RpdmUgb25lc1xuXHRcdHRoaXMuX29iamVjdHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHRcdHRoaXMubkNhY2hlZE9iamVjdHNfID0gMDsgLy8gdGhyZXNob2xkXG5cdFx0Ly8gbm90ZTogcmVhZCBieSBQcm9wZXJ0eUJpbmRpbmcuQ29tcG9zaXRlXG5cblx0XHRjb25zdCBpbmRpY2VzID0ge307XG5cdFx0dGhpcy5faW5kaWNlc0J5VVVJRCA9IGluZGljZXM7IC8vIGZvciBib29ra2VlcGluZ1xuXG5cdFx0Zm9yIChsZXQgaSA9IDAsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpICE9PSBuOyArK2kpIHtcblx0XHRcdGluZGljZXNbYXJndW1lbnRzW2ldLnV1aWRdID0gaTtcblx0XHR9XG5cdFx0dGhpcy5fcGF0aHMgPSBbXTsgLy8gaW5zaWRlOiBzdHJpbmdcblx0XHR0aGlzLl9wYXJzZWRQYXRocyA9IFtdOyAvLyBpbnNpZGU6IHsgd2UgZG9uJ3QgY2FyZSwgaGVyZSB9XG5cdFx0dGhpcy5fYmluZGluZ3MgPSBbXTsgLy8gaW5zaWRlOiBBcnJheTwgUHJvcGVydHlCaW5kaW5nID5cblx0XHR0aGlzLl9iaW5kaW5nc0luZGljZXNCeVBhdGggPSB7fTsgLy8gaW5zaWRlOiBpbmRpY2VzIGluIHRoZXNlIGFycmF5c1xuXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXHRcdHRoaXMuc3RhdHMgPSB7XG5cdFx0XHRvYmplY3RzOiB7XG5cdFx0XHRcdGdldCB0b3RhbCgpIHtcblx0XHRcdFx0XHRyZXR1cm4gc2NvcGUuX29iamVjdHMubGVuZ3RoO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRnZXQgaW5Vc2UoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMudG90YWwgLSBzY29wZS5uQ2FjaGVkT2JqZWN0c187XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRnZXQgYmluZGluZ3NQZXJPYmplY3QoKSB7XG5cdFx0XHRcdHJldHVybiBzY29wZS5fYmluZGluZ3MubGVuZ3RoO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblx0YWRkKCkge1xuXHRcdGNvbnN0IG9iamVjdHMgPSB0aGlzLl9vYmplY3RzLFxuXHRcdFx0aW5kaWNlc0J5VVVJRCA9IHRoaXMuX2luZGljZXNCeVVVSUQsXG5cdFx0XHRwYXRocyA9IHRoaXMuX3BhdGhzLFxuXHRcdFx0cGFyc2VkUGF0aHMgPSB0aGlzLl9wYXJzZWRQYXRocyxcblx0XHRcdGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXG5cdFx0XHRuQmluZGluZ3MgPSBiaW5kaW5ncy5sZW5ndGg7XG5cdFx0bGV0IGtub3duT2JqZWN0ID0gdW5kZWZpbmVkLFxuXHRcdFx0bk9iamVjdHMgPSBvYmplY3RzLmxlbmd0aCxcblx0XHRcdG5DYWNoZWRPYmplY3RzID0gdGhpcy5uQ2FjaGVkT2JqZWN0c187XG5cdFx0Zm9yIChsZXQgaSA9IDAsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpICE9PSBuOyArK2kpIHtcblx0XHRcdGNvbnN0IG9iamVjdCA9IGFyZ3VtZW50c1tpXSxcblx0XHRcdFx0dXVpZCA9IG9iamVjdC51dWlkO1xuXHRcdFx0bGV0IGluZGV4ID0gaW5kaWNlc0J5VVVJRFt1dWlkXTtcblx0XHRcdGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdC8vIHVua25vd24gb2JqZWN0IC0+IGFkZCBpdCB0byB0aGUgQUNUSVZFIHJlZ2lvblxuXG5cdFx0XHRcdGluZGV4ID0gbk9iamVjdHMrKztcblx0XHRcdFx0aW5kaWNlc0J5VVVJRFt1dWlkXSA9IGluZGV4O1xuXHRcdFx0XHRvYmplY3RzLnB1c2gob2JqZWN0KTtcblxuXHRcdFx0XHQvLyBhY2NvdW50aW5nIGlzIGRvbmUsIG5vdyBkbyB0aGUgc2FtZSBmb3IgYWxsIGJpbmRpbmdzXG5cblx0XHRcdFx0Zm9yIChsZXQgaiA9IDAsIG0gPSBuQmluZGluZ3M7IGogIT09IG07ICsraikge1xuXHRcdFx0XHRcdGJpbmRpbmdzW2pdLnB1c2gobmV3IFByb3BlcnR5QmluZGluZyhvYmplY3QsIHBhdGhzW2pdLCBwYXJzZWRQYXRoc1tqXSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGluZGV4IDwgbkNhY2hlZE9iamVjdHMpIHtcblx0XHRcdFx0a25vd25PYmplY3QgPSBvYmplY3RzW2luZGV4XTtcblxuXHRcdFx0XHQvLyBtb3ZlIGV4aXN0aW5nIG9iamVjdCB0byB0aGUgQUNUSVZFIHJlZ2lvblxuXG5cdFx0XHRcdGNvbnN0IGZpcnN0QWN0aXZlSW5kZXggPSAtLW5DYWNoZWRPYmplY3RzLFxuXHRcdFx0XHRcdGxhc3RDYWNoZWRPYmplY3QgPSBvYmplY3RzW2ZpcnN0QWN0aXZlSW5kZXhdO1xuXHRcdFx0XHRpbmRpY2VzQnlVVUlEW2xhc3RDYWNoZWRPYmplY3QudXVpZF0gPSBpbmRleDtcblx0XHRcdFx0b2JqZWN0c1tpbmRleF0gPSBsYXN0Q2FjaGVkT2JqZWN0O1xuXHRcdFx0XHRpbmRpY2VzQnlVVUlEW3V1aWRdID0gZmlyc3RBY3RpdmVJbmRleDtcblx0XHRcdFx0b2JqZWN0c1tmaXJzdEFjdGl2ZUluZGV4XSA9IG9iamVjdDtcblxuXHRcdFx0XHQvLyBhY2NvdW50aW5nIGlzIGRvbmUsIG5vdyBkbyB0aGUgc2FtZSBmb3IgYWxsIGJpbmRpbmdzXG5cblx0XHRcdFx0Zm9yIChsZXQgaiA9IDAsIG0gPSBuQmluZGluZ3M7IGogIT09IG07ICsraikge1xuXHRcdFx0XHRcdGNvbnN0IGJpbmRpbmdzRm9yUGF0aCA9IGJpbmRpbmdzW2pdLFxuXHRcdFx0XHRcdFx0bGFzdENhY2hlZCA9IGJpbmRpbmdzRm9yUGF0aFtmaXJzdEFjdGl2ZUluZGV4XTtcblx0XHRcdFx0XHRsZXQgYmluZGluZyA9IGJpbmRpbmdzRm9yUGF0aFtpbmRleF07XG5cdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoW2luZGV4XSA9IGxhc3RDYWNoZWQ7XG5cdFx0XHRcdFx0aWYgKGJpbmRpbmcgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0Ly8gc2luY2Ugd2UgZG8gbm90IGJvdGhlciB0byBjcmVhdGUgbmV3IGJpbmRpbmdzXG5cdFx0XHRcdFx0XHQvLyBmb3Igb2JqZWN0cyB0aGF0IGFyZSBjYWNoZWQsIHRoZSBiaW5kaW5nIG1heVxuXHRcdFx0XHRcdFx0Ly8gb3IgbWF5IG5vdCBleGlzdFxuXG5cdFx0XHRcdFx0XHRiaW5kaW5nID0gbmV3IFByb3BlcnR5QmluZGluZyhvYmplY3QsIHBhdGhzW2pdLCBwYXJzZWRQYXRoc1tqXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aFtmaXJzdEFjdGl2ZUluZGV4XSA9IGJpbmRpbmc7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAob2JqZWN0c1tpbmRleF0gIT09IGtub3duT2JqZWN0KSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLkFuaW1hdGlvbk9iamVjdEdyb3VwOiBEaWZmZXJlbnQgb2JqZWN0cyB3aXRoIHRoZSBzYW1lIFVVSUQgJyArICdkZXRlY3RlZC4gQ2xlYW4gdGhlIGNhY2hlcyBvciByZWNyZWF0ZSB5b3VyIGluZnJhc3RydWN0dXJlIHdoZW4gcmVsb2FkaW5nIHNjZW5lcy4nKTtcblx0XHRcdH0gLy8gZWxzZSB0aGUgb2JqZWN0IGlzIGFscmVhZHkgd2hlcmUgd2Ugd2FudCBpdCB0byBiZVxuXHRcdH0gLy8gZm9yIGFyZ3VtZW50c1xuXG5cdFx0dGhpcy5uQ2FjaGVkT2JqZWN0c18gPSBuQ2FjaGVkT2JqZWN0cztcblx0fVxuXHRyZW1vdmUoKSB7XG5cdFx0Y29uc3Qgb2JqZWN0cyA9IHRoaXMuX29iamVjdHMsXG5cdFx0XHRpbmRpY2VzQnlVVUlEID0gdGhpcy5faW5kaWNlc0J5VVVJRCxcblx0XHRcdGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXG5cdFx0XHRuQmluZGluZ3MgPSBiaW5kaW5ncy5sZW5ndGg7XG5cdFx0bGV0IG5DYWNoZWRPYmplY3RzID0gdGhpcy5uQ2FjaGVkT2JqZWN0c187XG5cdFx0Zm9yIChsZXQgaSA9IDAsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpICE9PSBuOyArK2kpIHtcblx0XHRcdGNvbnN0IG9iamVjdCA9IGFyZ3VtZW50c1tpXSxcblx0XHRcdFx0dXVpZCA9IG9iamVjdC51dWlkLFxuXHRcdFx0XHRpbmRleCA9IGluZGljZXNCeVVVSURbdXVpZF07XG5cdFx0XHRpZiAoaW5kZXggIT09IHVuZGVmaW5lZCAmJiBpbmRleCA+PSBuQ2FjaGVkT2JqZWN0cykge1xuXHRcdFx0XHQvLyBtb3ZlIGV4aXN0aW5nIG9iamVjdCBpbnRvIHRoZSBDQUNIRUQgcmVnaW9uXG5cblx0XHRcdFx0Y29uc3QgbGFzdENhY2hlZEluZGV4ID0gbkNhY2hlZE9iamVjdHMrKyxcblx0XHRcdFx0XHRmaXJzdEFjdGl2ZU9iamVjdCA9IG9iamVjdHNbbGFzdENhY2hlZEluZGV4XTtcblx0XHRcdFx0aW5kaWNlc0J5VVVJRFtmaXJzdEFjdGl2ZU9iamVjdC51dWlkXSA9IGluZGV4O1xuXHRcdFx0XHRvYmplY3RzW2luZGV4XSA9IGZpcnN0QWN0aXZlT2JqZWN0O1xuXHRcdFx0XHRpbmRpY2VzQnlVVUlEW3V1aWRdID0gbGFzdENhY2hlZEluZGV4O1xuXHRcdFx0XHRvYmplY3RzW2xhc3RDYWNoZWRJbmRleF0gPSBvYmplY3Q7XG5cblx0XHRcdFx0Ly8gYWNjb3VudGluZyBpcyBkb25lLCBub3cgZG8gdGhlIHNhbWUgZm9yIGFsbCBiaW5kaW5nc1xuXG5cdFx0XHRcdGZvciAobGV0IGogPSAwLCBtID0gbkJpbmRpbmdzOyBqICE9PSBtOyArK2opIHtcblx0XHRcdFx0XHRjb25zdCBiaW5kaW5nc0ZvclBhdGggPSBiaW5kaW5nc1tqXSxcblx0XHRcdFx0XHRcdGZpcnN0QWN0aXZlID0gYmluZGluZ3NGb3JQYXRoW2xhc3RDYWNoZWRJbmRleF0sXG5cdFx0XHRcdFx0XHRiaW5kaW5nID0gYmluZGluZ3NGb3JQYXRoW2luZGV4XTtcblx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGhbaW5kZXhdID0gZmlyc3RBY3RpdmU7XG5cdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoW2xhc3RDYWNoZWRJbmRleF0gPSBiaW5kaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSAvLyBmb3IgYXJndW1lbnRzXG5cblx0XHR0aGlzLm5DYWNoZWRPYmplY3RzXyA9IG5DYWNoZWRPYmplY3RzO1xuXHR9XG5cblx0Ly8gcmVtb3ZlICYgZm9yZ2V0XG5cdHVuY2FjaGUoKSB7XG5cdFx0Y29uc3Qgb2JqZWN0cyA9IHRoaXMuX29iamVjdHMsXG5cdFx0XHRpbmRpY2VzQnlVVUlEID0gdGhpcy5faW5kaWNlc0J5VVVJRCxcblx0XHRcdGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXG5cdFx0XHRuQmluZGluZ3MgPSBiaW5kaW5ncy5sZW5ndGg7XG5cdFx0bGV0IG5DYWNoZWRPYmplY3RzID0gdGhpcy5uQ2FjaGVkT2JqZWN0c18sXG5cdFx0XHRuT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoO1xuXHRcdGZvciAobGV0IGkgPSAwLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSAhPT0gbjsgKytpKSB7XG5cdFx0XHRjb25zdCBvYmplY3QgPSBhcmd1bWVudHNbaV0sXG5cdFx0XHRcdHV1aWQgPSBvYmplY3QudXVpZCxcblx0XHRcdFx0aW5kZXggPSBpbmRpY2VzQnlVVUlEW3V1aWRdO1xuXHRcdFx0aWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0ZGVsZXRlIGluZGljZXNCeVVVSURbdXVpZF07XG5cdFx0XHRcdGlmIChpbmRleCA8IG5DYWNoZWRPYmplY3RzKSB7XG5cdFx0XHRcdFx0Ly8gb2JqZWN0IGlzIGNhY2hlZCwgc2hyaW5rIHRoZSBDQUNIRUQgcmVnaW9uXG5cblx0XHRcdFx0XHRjb25zdCBmaXJzdEFjdGl2ZUluZGV4ID0gLS1uQ2FjaGVkT2JqZWN0cyxcblx0XHRcdFx0XHRcdGxhc3RDYWNoZWRPYmplY3QgPSBvYmplY3RzW2ZpcnN0QWN0aXZlSW5kZXhdLFxuXHRcdFx0XHRcdFx0bGFzdEluZGV4ID0gLS1uT2JqZWN0cyxcblx0XHRcdFx0XHRcdGxhc3RPYmplY3QgPSBvYmplY3RzW2xhc3RJbmRleF07XG5cblx0XHRcdFx0XHQvLyBsYXN0IGNhY2hlZCBvYmplY3QgdGFrZXMgdGhpcyBvYmplY3QncyBwbGFjZVxuXHRcdFx0XHRcdGluZGljZXNCeVVVSURbbGFzdENhY2hlZE9iamVjdC51dWlkXSA9IGluZGV4O1xuXHRcdFx0XHRcdG9iamVjdHNbaW5kZXhdID0gbGFzdENhY2hlZE9iamVjdDtcblxuXHRcdFx0XHRcdC8vIGxhc3Qgb2JqZWN0IGdvZXMgdG8gdGhlIGFjdGl2YXRlZCBzbG90IGFuZCBwb3Bcblx0XHRcdFx0XHRpbmRpY2VzQnlVVUlEW2xhc3RPYmplY3QudXVpZF0gPSBmaXJzdEFjdGl2ZUluZGV4O1xuXHRcdFx0XHRcdG9iamVjdHNbZmlyc3RBY3RpdmVJbmRleF0gPSBsYXN0T2JqZWN0O1xuXHRcdFx0XHRcdG9iamVjdHMucG9wKCk7XG5cblx0XHRcdFx0XHQvLyBhY2NvdW50aW5nIGlzIGRvbmUsIG5vdyBkbyB0aGUgc2FtZSBmb3IgYWxsIGJpbmRpbmdzXG5cblx0XHRcdFx0XHRmb3IgKGxldCBqID0gMCwgbSA9IG5CaW5kaW5nczsgaiAhPT0gbTsgKytqKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBiaW5kaW5nc0ZvclBhdGggPSBiaW5kaW5nc1tqXSxcblx0XHRcdFx0XHRcdFx0bGFzdENhY2hlZCA9IGJpbmRpbmdzRm9yUGF0aFtmaXJzdEFjdGl2ZUluZGV4XSxcblx0XHRcdFx0XHRcdFx0bGFzdCA9IGJpbmRpbmdzRm9yUGF0aFtsYXN0SW5kZXhdO1xuXHRcdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoW2luZGV4XSA9IGxhc3RDYWNoZWQ7XG5cdFx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGhbZmlyc3RBY3RpdmVJbmRleF0gPSBsYXN0O1xuXHRcdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoLnBvcCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBvYmplY3QgaXMgYWN0aXZlLCBqdXN0IHN3YXAgd2l0aCB0aGUgbGFzdCBhbmQgcG9wXG5cblx0XHRcdFx0XHRjb25zdCBsYXN0SW5kZXggPSAtLW5PYmplY3RzLFxuXHRcdFx0XHRcdFx0bGFzdE9iamVjdCA9IG9iamVjdHNbbGFzdEluZGV4XTtcblx0XHRcdFx0XHRpZiAobGFzdEluZGV4ID4gMCkge1xuXHRcdFx0XHRcdFx0aW5kaWNlc0J5VVVJRFtsYXN0T2JqZWN0LnV1aWRdID0gaW5kZXg7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG9iamVjdHNbaW5kZXhdID0gbGFzdE9iamVjdDtcblx0XHRcdFx0XHRvYmplY3RzLnBvcCgpO1xuXG5cdFx0XHRcdFx0Ly8gYWNjb3VudGluZyBpcyBkb25lLCBub3cgZG8gdGhlIHNhbWUgZm9yIGFsbCBiaW5kaW5nc1xuXG5cdFx0XHRcdFx0Zm9yIChsZXQgaiA9IDAsIG0gPSBuQmluZGluZ3M7IGogIT09IG07ICsraikge1xuXHRcdFx0XHRcdFx0Y29uc3QgYmluZGluZ3NGb3JQYXRoID0gYmluZGluZ3Nbal07XG5cdFx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGhbaW5kZXhdID0gYmluZGluZ3NGb3JQYXRoW2xhc3RJbmRleF07XG5cdFx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGgucG9wKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IC8vIGNhY2hlZCBvciBhY3RpdmVcblx0XHRcdH0gLy8gaWYgb2JqZWN0IGlzIGtub3duXG5cdFx0fSAvLyBmb3IgYXJndW1lbnRzXG5cblx0XHR0aGlzLm5DYWNoZWRPYmplY3RzXyA9IG5DYWNoZWRPYmplY3RzO1xuXHR9XG5cblx0Ly8gSW50ZXJuYWwgaW50ZXJmYWNlIHVzZWQgYnkgYmVmcmllbmRlZCBQcm9wZXJ0eUJpbmRpbmcuQ29tcG9zaXRlOlxuXG5cdHN1YnNjcmliZV8ocGF0aCwgcGFyc2VkUGF0aCkge1xuXHRcdC8vIHJldHVybnMgYW4gYXJyYXkgb2YgYmluZGluZ3MgZm9yIHRoZSBnaXZlbiBwYXRoIHRoYXQgaXMgY2hhbmdlZFxuXHRcdC8vIGFjY29yZGluZyB0byB0aGUgY29udGFpbmVkIG9iamVjdHMgaW4gdGhlIGdyb3VwXG5cblx0XHRjb25zdCBpbmRpY2VzQnlQYXRoID0gdGhpcy5fYmluZGluZ3NJbmRpY2VzQnlQYXRoO1xuXHRcdGxldCBpbmRleCA9IGluZGljZXNCeVBhdGhbcGF0aF07XG5cdFx0Y29uc3QgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncztcblx0XHRpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkgcmV0dXJuIGJpbmRpbmdzW2luZGV4XTtcblx0XHRjb25zdCBwYXRocyA9IHRoaXMuX3BhdGhzLFxuXHRcdFx0cGFyc2VkUGF0aHMgPSB0aGlzLl9wYXJzZWRQYXRocyxcblx0XHRcdG9iamVjdHMgPSB0aGlzLl9vYmplY3RzLFxuXHRcdFx0bk9iamVjdHMgPSBvYmplY3RzLmxlbmd0aCxcblx0XHRcdG5DYWNoZWRPYmplY3RzID0gdGhpcy5uQ2FjaGVkT2JqZWN0c18sXG5cdFx0XHRiaW5kaW5nc0ZvclBhdGggPSBuZXcgQXJyYXkobk9iamVjdHMpO1xuXHRcdGluZGV4ID0gYmluZGluZ3MubGVuZ3RoO1xuXHRcdGluZGljZXNCeVBhdGhbcGF0aF0gPSBpbmRleDtcblx0XHRwYXRocy5wdXNoKHBhdGgpO1xuXHRcdHBhcnNlZFBhdGhzLnB1c2gocGFyc2VkUGF0aCk7XG5cdFx0YmluZGluZ3MucHVzaChiaW5kaW5nc0ZvclBhdGgpO1xuXHRcdGZvciAobGV0IGkgPSBuQ2FjaGVkT2JqZWN0cywgbiA9IG9iamVjdHMubGVuZ3RoOyBpICE9PSBuOyArK2kpIHtcblx0XHRcdGNvbnN0IG9iamVjdCA9IG9iamVjdHNbaV07XG5cdFx0XHRiaW5kaW5nc0ZvclBhdGhbaV0gPSBuZXcgUHJvcGVydHlCaW5kaW5nKG9iamVjdCwgcGF0aCwgcGFyc2VkUGF0aCk7XG5cdFx0fVxuXHRcdHJldHVybiBiaW5kaW5nc0ZvclBhdGg7XG5cdH1cblx0dW5zdWJzY3JpYmVfKHBhdGgpIHtcblx0XHQvLyB0ZWxscyB0aGUgZ3JvdXAgdG8gZm9yZ2V0IGFib3V0IGEgcHJvcGVydHkgcGF0aCBhbmQgbm8gbG9uZ2VyXG5cdFx0Ly8gdXBkYXRlIHRoZSBhcnJheSBwcmV2aW91c2x5IG9idGFpbmVkIHdpdGggJ3N1YnNjcmliZV8nXG5cblx0XHRjb25zdCBpbmRpY2VzQnlQYXRoID0gdGhpcy5fYmluZGluZ3NJbmRpY2VzQnlQYXRoLFxuXHRcdFx0aW5kZXggPSBpbmRpY2VzQnlQYXRoW3BhdGhdO1xuXHRcdGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjb25zdCBwYXRocyA9IHRoaXMuX3BhdGhzLFxuXHRcdFx0XHRwYXJzZWRQYXRocyA9IHRoaXMuX3BhcnNlZFBhdGhzLFxuXHRcdFx0XHRiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxuXHRcdFx0XHRsYXN0QmluZGluZ3NJbmRleCA9IGJpbmRpbmdzLmxlbmd0aCAtIDEsXG5cdFx0XHRcdGxhc3RCaW5kaW5ncyA9IGJpbmRpbmdzW2xhc3RCaW5kaW5nc0luZGV4XSxcblx0XHRcdFx0bGFzdEJpbmRpbmdzUGF0aCA9IHBhdGhbbGFzdEJpbmRpbmdzSW5kZXhdO1xuXHRcdFx0aW5kaWNlc0J5UGF0aFtsYXN0QmluZGluZ3NQYXRoXSA9IGluZGV4O1xuXHRcdFx0YmluZGluZ3NbaW5kZXhdID0gbGFzdEJpbmRpbmdzO1xuXHRcdFx0YmluZGluZ3MucG9wKCk7XG5cdFx0XHRwYXJzZWRQYXRoc1tpbmRleF0gPSBwYXJzZWRQYXRoc1tsYXN0QmluZGluZ3NJbmRleF07XG5cdFx0XHRwYXJzZWRQYXRocy5wb3AoKTtcblx0XHRcdHBhdGhzW2luZGV4XSA9IHBhdGhzW2xhc3RCaW5kaW5nc0luZGV4XTtcblx0XHRcdHBhdGhzLnBvcCgpO1xuXHRcdH1cblx0fVxufVxuXG5jbGFzcyBBbmltYXRpb25BY3Rpb24ge1xuXHRjb25zdHJ1Y3RvcihtaXhlciwgY2xpcCwgbG9jYWxSb290ID0gbnVsbCwgYmxlbmRNb2RlID0gY2xpcC5ibGVuZE1vZGUpIHtcblx0XHR0aGlzLl9taXhlciA9IG1peGVyO1xuXHRcdHRoaXMuX2NsaXAgPSBjbGlwO1xuXHRcdHRoaXMuX2xvY2FsUm9vdCA9IGxvY2FsUm9vdDtcblx0XHR0aGlzLmJsZW5kTW9kZSA9IGJsZW5kTW9kZTtcblx0XHRjb25zdCB0cmFja3MgPSBjbGlwLnRyYWNrcyxcblx0XHRcdG5UcmFja3MgPSB0cmFja3MubGVuZ3RoLFxuXHRcdFx0aW50ZXJwb2xhbnRzID0gbmV3IEFycmF5KG5UcmFja3MpO1xuXHRcdGNvbnN0IGludGVycG9sYW50U2V0dGluZ3MgPSB7XG5cdFx0XHRlbmRpbmdTdGFydDogWmVyb0N1cnZhdHVyZUVuZGluZyxcblx0XHRcdGVuZGluZ0VuZDogWmVyb0N1cnZhdHVyZUVuZGluZ1xuXHRcdH07XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgIT09IG5UcmFja3M7ICsraSkge1xuXHRcdFx0Y29uc3QgaW50ZXJwb2xhbnQgPSB0cmFja3NbaV0uY3JlYXRlSW50ZXJwb2xhbnQobnVsbCk7XG5cdFx0XHRpbnRlcnBvbGFudHNbaV0gPSBpbnRlcnBvbGFudDtcblx0XHRcdGludGVycG9sYW50LnNldHRpbmdzID0gaW50ZXJwb2xhbnRTZXR0aW5ncztcblx0XHR9XG5cdFx0dGhpcy5faW50ZXJwb2xhbnRTZXR0aW5ncyA9IGludGVycG9sYW50U2V0dGluZ3M7XG5cdFx0dGhpcy5faW50ZXJwb2xhbnRzID0gaW50ZXJwb2xhbnRzOyAvLyBib3VuZCBieSB0aGUgbWl4ZXJcblxuXHRcdC8vIGluc2lkZTogUHJvcGVydHlNaXhlciAobWFuYWdlZCBieSB0aGUgbWl4ZXIpXG5cdFx0dGhpcy5fcHJvcGVydHlCaW5kaW5ncyA9IG5ldyBBcnJheShuVHJhY2tzKTtcblx0XHR0aGlzLl9jYWNoZUluZGV4ID0gbnVsbDsgLy8gZm9yIHRoZSBtZW1vcnkgbWFuYWdlclxuXHRcdHRoaXMuX2J5Q2xpcENhY2hlSW5kZXggPSBudWxsOyAvLyBmb3IgdGhlIG1lbW9yeSBtYW5hZ2VyXG5cblx0XHR0aGlzLl90aW1lU2NhbGVJbnRlcnBvbGFudCA9IG51bGw7XG5cdFx0dGhpcy5fd2VpZ2h0SW50ZXJwb2xhbnQgPSBudWxsO1xuXHRcdHRoaXMubG9vcCA9IExvb3BSZXBlYXQ7XG5cdFx0dGhpcy5fbG9vcENvdW50ID0gLTE7XG5cblx0XHQvLyBnbG9iYWwgbWl4ZXIgdGltZSB3aGVuIHRoZSBhY3Rpb24gaXMgdG8gYmUgc3RhcnRlZFxuXHRcdC8vIGl0J3Mgc2V0IGJhY2sgdG8gJ251bGwnIHVwb24gc3RhcnQgb2YgdGhlIGFjdGlvblxuXHRcdHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7XG5cblx0XHQvLyBzY2FsZWQgbG9jYWwgdGltZSBvZiB0aGUgYWN0aW9uXG5cdFx0Ly8gZ2V0cyBjbGFtcGVkIG9yIHdyYXBwZWQgdG8gMC4uY2xpcC5kdXJhdGlvbiBhY2NvcmRpbmcgdG8gbG9vcFxuXHRcdHRoaXMudGltZSA9IDA7XG5cdFx0dGhpcy50aW1lU2NhbGUgPSAxO1xuXHRcdHRoaXMuX2VmZmVjdGl2ZVRpbWVTY2FsZSA9IDE7XG5cdFx0dGhpcy53ZWlnaHQgPSAxO1xuXHRcdHRoaXMuX2VmZmVjdGl2ZVdlaWdodCA9IDE7XG5cdFx0dGhpcy5yZXBldGl0aW9ucyA9IEluZmluaXR5OyAvLyBuby4gb2YgcmVwZXRpdGlvbnMgd2hlbiBsb29waW5nXG5cblx0XHR0aGlzLnBhdXNlZCA9IGZhbHNlOyAvLyB0cnVlIC0+IHplcm8gZWZmZWN0aXZlIHRpbWUgc2NhbGVcblx0XHR0aGlzLmVuYWJsZWQgPSB0cnVlOyAvLyBmYWxzZSAtPiB6ZXJvIGVmZmVjdGl2ZSB3ZWlnaHRcblxuXHRcdHRoaXMuY2xhbXBXaGVuRmluaXNoZWQgPSBmYWxzZTsgLy8ga2VlcCBmZWVkaW5nIHRoZSBsYXN0IGZyYW1lP1xuXG5cdFx0dGhpcy56ZXJvU2xvcGVBdFN0YXJ0ID0gdHJ1ZTsgLy8gZm9yIHNtb290aCBpbnRlcnBvbGF0aW9uIHcvbyBzZXBhcmF0ZVxuXHRcdHRoaXMuemVyb1Nsb3BlQXRFbmQgPSB0cnVlOyAvLyBjbGlwcyBmb3Igc3RhcnQsIGxvb3AgYW5kIGVuZFxuXHR9XG5cblx0Ly8gU3RhdGUgJiBTY2hlZHVsaW5nXG5cblx0cGxheSgpIHtcblx0XHR0aGlzLl9taXhlci5fYWN0aXZhdGVBY3Rpb24odGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0c3RvcCgpIHtcblx0XHR0aGlzLl9taXhlci5fZGVhY3RpdmF0ZUFjdGlvbih0aGlzKTtcblx0XHRyZXR1cm4gdGhpcy5yZXNldCgpO1xuXHR9XG5cdHJlc2V0KCkge1xuXHRcdHRoaXMucGF1c2VkID0gZmFsc2U7XG5cdFx0dGhpcy5lbmFibGVkID0gdHJ1ZTtcblx0XHR0aGlzLnRpbWUgPSAwOyAvLyByZXN0YXJ0IGNsaXBcblx0XHR0aGlzLl9sb29wQ291bnQgPSAtMTsgLy8gZm9yZ2V0IHByZXZpb3VzIGxvb3BzXG5cdFx0dGhpcy5fc3RhcnRUaW1lID0gbnVsbDsgLy8gZm9yZ2V0IHNjaGVkdWxpbmdcblxuXHRcdHJldHVybiB0aGlzLnN0b3BGYWRpbmcoKS5zdG9wV2FycGluZygpO1xuXHR9XG5cdGlzUnVubmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5lbmFibGVkICYmICF0aGlzLnBhdXNlZCAmJiB0aGlzLnRpbWVTY2FsZSAhPT0gMCAmJiB0aGlzLl9zdGFydFRpbWUgPT09IG51bGwgJiYgdGhpcy5fbWl4ZXIuX2lzQWN0aXZlQWN0aW9uKHRoaXMpO1xuXHR9XG5cblx0Ly8gcmV0dXJuIHRydWUgd2hlbiBwbGF5IGhhcyBiZWVuIGNhbGxlZFxuXHRpc1NjaGVkdWxlZCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWl4ZXIuX2lzQWN0aXZlQWN0aW9uKHRoaXMpO1xuXHR9XG5cdHN0YXJ0QXQodGltZSkge1xuXHRcdHRoaXMuX3N0YXJ0VGltZSA9IHRpbWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0c2V0TG9vcChtb2RlLCByZXBldGl0aW9ucykge1xuXHRcdHRoaXMubG9vcCA9IG1vZGU7XG5cdFx0dGhpcy5yZXBldGl0aW9ucyA9IHJlcGV0aXRpb25zO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0Ly8gV2VpZ2h0XG5cblx0Ly8gc2V0IHRoZSB3ZWlnaHQgc3RvcHBpbmcgYW55IHNjaGVkdWxlZCBmYWRpbmdcblx0Ly8gYWx0aG91Z2ggLmVuYWJsZWQgPSBmYWxzZSB5aWVsZHMgYW4gZWZmZWN0aXZlIHdlaWdodCBvZiB6ZXJvLCB0aGlzXG5cdC8vIG1ldGhvZCBkb2VzICpub3QqIGNoYW5nZSAuZW5hYmxlZCwgYmVjYXVzZSBpdCB3b3VsZCBiZSBjb25mdXNpbmdcblx0c2V0RWZmZWN0aXZlV2VpZ2h0KHdlaWdodCkge1xuXHRcdHRoaXMud2VpZ2h0ID0gd2VpZ2h0O1xuXG5cdFx0Ly8gbm90ZTogc2FtZSBsb2dpYyBhcyB3aGVuIHVwZGF0ZWQgYXQgcnVudGltZVxuXHRcdHRoaXMuX2VmZmVjdGl2ZVdlaWdodCA9IHRoaXMuZW5hYmxlZCA/IHdlaWdodCA6IDA7XG5cdFx0cmV0dXJuIHRoaXMuc3RvcEZhZGluZygpO1xuXHR9XG5cblx0Ly8gcmV0dXJuIHRoZSB3ZWlnaHQgY29uc2lkZXJpbmcgZmFkaW5nIGFuZCAuZW5hYmxlZFxuXHRnZXRFZmZlY3RpdmVXZWlnaHQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2VmZmVjdGl2ZVdlaWdodDtcblx0fVxuXHRmYWRlSW4oZHVyYXRpb24pIHtcblx0XHRyZXR1cm4gdGhpcy5fc2NoZWR1bGVGYWRpbmcoZHVyYXRpb24sIDAsIDEpO1xuXHR9XG5cdGZhZGVPdXQoZHVyYXRpb24pIHtcblx0XHRyZXR1cm4gdGhpcy5fc2NoZWR1bGVGYWRpbmcoZHVyYXRpb24sIDEsIDApO1xuXHR9XG5cdGNyb3NzRmFkZUZyb20oZmFkZU91dEFjdGlvbiwgZHVyYXRpb24sIHdhcnApIHtcblx0XHRmYWRlT3V0QWN0aW9uLmZhZGVPdXQoZHVyYXRpb24pO1xuXHRcdHRoaXMuZmFkZUluKGR1cmF0aW9uKTtcblx0XHRpZiAod2FycCkge1xuXHRcdFx0Y29uc3QgZmFkZUluRHVyYXRpb24gPSB0aGlzLl9jbGlwLmR1cmF0aW9uLFxuXHRcdFx0XHRmYWRlT3V0RHVyYXRpb24gPSBmYWRlT3V0QWN0aW9uLl9jbGlwLmR1cmF0aW9uLFxuXHRcdFx0XHRzdGFydEVuZFJhdGlvID0gZmFkZU91dER1cmF0aW9uIC8gZmFkZUluRHVyYXRpb24sXG5cdFx0XHRcdGVuZFN0YXJ0UmF0aW8gPSBmYWRlSW5EdXJhdGlvbiAvIGZhZGVPdXREdXJhdGlvbjtcblx0XHRcdGZhZGVPdXRBY3Rpb24ud2FycCgxLjAsIHN0YXJ0RW5kUmF0aW8sIGR1cmF0aW9uKTtcblx0XHRcdHRoaXMud2FycChlbmRTdGFydFJhdGlvLCAxLjAsIGR1cmF0aW9uKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0Y3Jvc3NGYWRlVG8oZmFkZUluQWN0aW9uLCBkdXJhdGlvbiwgd2FycCkge1xuXHRcdHJldHVybiBmYWRlSW5BY3Rpb24uY3Jvc3NGYWRlRnJvbSh0aGlzLCBkdXJhdGlvbiwgd2FycCk7XG5cdH1cblx0c3RvcEZhZGluZygpIHtcblx0XHRjb25zdCB3ZWlnaHRJbnRlcnBvbGFudCA9IHRoaXMuX3dlaWdodEludGVycG9sYW50O1xuXHRcdGlmICh3ZWlnaHRJbnRlcnBvbGFudCAhPT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fd2VpZ2h0SW50ZXJwb2xhbnQgPSBudWxsO1xuXHRcdFx0dGhpcy5fbWl4ZXIuX3Rha2VCYWNrQ29udHJvbEludGVycG9sYW50KHdlaWdodEludGVycG9sYW50KTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvLyBUaW1lIFNjYWxlIENvbnRyb2xcblxuXHQvLyBzZXQgdGhlIHRpbWUgc2NhbGUgc3RvcHBpbmcgYW55IHNjaGVkdWxlZCB3YXJwaW5nXG5cdC8vIGFsdGhvdWdoIC5wYXVzZWQgPSB0cnVlIHlpZWxkcyBhbiBlZmZlY3RpdmUgdGltZSBzY2FsZSBvZiB6ZXJvLCB0aGlzXG5cdC8vIG1ldGhvZCBkb2VzICpub3QqIGNoYW5nZSAucGF1c2VkLCBiZWNhdXNlIGl0IHdvdWxkIGJlIGNvbmZ1c2luZ1xuXHRzZXRFZmZlY3RpdmVUaW1lU2NhbGUodGltZVNjYWxlKSB7XG5cdFx0dGhpcy50aW1lU2NhbGUgPSB0aW1lU2NhbGU7XG5cdFx0dGhpcy5fZWZmZWN0aXZlVGltZVNjYWxlID0gdGhpcy5wYXVzZWQgPyAwIDogdGltZVNjYWxlO1xuXHRcdHJldHVybiB0aGlzLnN0b3BXYXJwaW5nKCk7XG5cdH1cblxuXHQvLyByZXR1cm4gdGhlIHRpbWUgc2NhbGUgY29uc2lkZXJpbmcgd2FycGluZyBhbmQgLnBhdXNlZFxuXHRnZXRFZmZlY3RpdmVUaW1lU2NhbGUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2VmZmVjdGl2ZVRpbWVTY2FsZTtcblx0fVxuXHRzZXREdXJhdGlvbihkdXJhdGlvbikge1xuXHRcdHRoaXMudGltZVNjYWxlID0gdGhpcy5fY2xpcC5kdXJhdGlvbiAvIGR1cmF0aW9uO1xuXHRcdHJldHVybiB0aGlzLnN0b3BXYXJwaW5nKCk7XG5cdH1cblx0c3luY1dpdGgoYWN0aW9uKSB7XG5cdFx0dGhpcy50aW1lID0gYWN0aW9uLnRpbWU7XG5cdFx0dGhpcy50aW1lU2NhbGUgPSBhY3Rpb24udGltZVNjYWxlO1xuXHRcdHJldHVybiB0aGlzLnN0b3BXYXJwaW5nKCk7XG5cdH1cblx0aGFsdChkdXJhdGlvbikge1xuXHRcdHJldHVybiB0aGlzLndhcnAodGhpcy5fZWZmZWN0aXZlVGltZVNjYWxlLCAwLCBkdXJhdGlvbik7XG5cdH1cblx0d2FycChzdGFydFRpbWVTY2FsZSwgZW5kVGltZVNjYWxlLCBkdXJhdGlvbikge1xuXHRcdGNvbnN0IG1peGVyID0gdGhpcy5fbWl4ZXIsXG5cdFx0XHRub3cgPSBtaXhlci50aW1lLFxuXHRcdFx0dGltZVNjYWxlID0gdGhpcy50aW1lU2NhbGU7XG5cdFx0bGV0IGludGVycG9sYW50ID0gdGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQ7XG5cdFx0aWYgKGludGVycG9sYW50ID09PSBudWxsKSB7XG5cdFx0XHRpbnRlcnBvbGFudCA9IG1peGVyLl9sZW5kQ29udHJvbEludGVycG9sYW50KCk7XG5cdFx0XHR0aGlzLl90aW1lU2NhbGVJbnRlcnBvbGFudCA9IGludGVycG9sYW50O1xuXHRcdH1cblx0XHRjb25zdCB0aW1lcyA9IGludGVycG9sYW50LnBhcmFtZXRlclBvc2l0aW9ucyxcblx0XHRcdHZhbHVlcyA9IGludGVycG9sYW50LnNhbXBsZVZhbHVlcztcblx0XHR0aW1lc1swXSA9IG5vdztcblx0XHR0aW1lc1sxXSA9IG5vdyArIGR1cmF0aW9uO1xuXHRcdHZhbHVlc1swXSA9IHN0YXJ0VGltZVNjYWxlIC8gdGltZVNjYWxlO1xuXHRcdHZhbHVlc1sxXSA9IGVuZFRpbWVTY2FsZSAvIHRpbWVTY2FsZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRzdG9wV2FycGluZygpIHtcblx0XHRjb25zdCB0aW1lU2NhbGVJbnRlcnBvbGFudCA9IHRoaXMuX3RpbWVTY2FsZUludGVycG9sYW50O1xuXHRcdGlmICh0aW1lU2NhbGVJbnRlcnBvbGFudCAhPT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQgPSBudWxsO1xuXHRcdFx0dGhpcy5fbWl4ZXIuX3Rha2VCYWNrQ29udHJvbEludGVycG9sYW50KHRpbWVTY2FsZUludGVycG9sYW50KTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvLyBPYmplY3QgQWNjZXNzb3JzXG5cblx0Z2V0TWl4ZXIoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21peGVyO1xuXHR9XG5cdGdldENsaXAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NsaXA7XG5cdH1cblx0Z2V0Um9vdCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbG9jYWxSb290IHx8IHRoaXMuX21peGVyLl9yb290O1xuXHR9XG5cblx0Ly8gSW50ZXJuYVxuXG5cdF91cGRhdGUodGltZSwgZGVsdGFUaW1lLCB0aW1lRGlyZWN0aW9uLCBhY2N1SW5kZXgpIHtcblx0XHQvLyBjYWxsZWQgYnkgdGhlIG1peGVyXG5cblx0XHRpZiAoIXRoaXMuZW5hYmxlZCkge1xuXHRcdFx0Ly8gY2FsbCAuX3VwZGF0ZVdlaWdodCgpIHRvIHVwZGF0ZSAuX2VmZmVjdGl2ZVdlaWdodFxuXG5cdFx0XHR0aGlzLl91cGRhdGVXZWlnaHQodGltZSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGNvbnN0IHN0YXJ0VGltZSA9IHRoaXMuX3N0YXJ0VGltZTtcblx0XHRpZiAoc3RhcnRUaW1lICE9PSBudWxsKSB7XG5cdFx0XHQvLyBjaGVjayBmb3Igc2NoZWR1bGVkIHN0YXJ0IG9mIGFjdGlvblxuXG5cdFx0XHRjb25zdCB0aW1lUnVubmluZyA9ICh0aW1lIC0gc3RhcnRUaW1lKSAqIHRpbWVEaXJlY3Rpb247XG5cdFx0XHRpZiAodGltZVJ1bm5pbmcgPCAwIHx8IHRpbWVEaXJlY3Rpb24gPT09IDApIHtcblx0XHRcdFx0ZGVsdGFUaW1lID0gMDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7IC8vIHVuc2NoZWR1bGVcblx0XHRcdFx0ZGVsdGFUaW1lID0gdGltZURpcmVjdGlvbiAqIHRpbWVSdW5uaW5nO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGFwcGx5IHRpbWUgc2NhbGUgYW5kIGFkdmFuY2UgdGltZVxuXG5cdFx0ZGVsdGFUaW1lICo9IHRoaXMuX3VwZGF0ZVRpbWVTY2FsZSh0aW1lKTtcblx0XHRjb25zdCBjbGlwVGltZSA9IHRoaXMuX3VwZGF0ZVRpbWUoZGVsdGFUaW1lKTtcblxuXHRcdC8vIG5vdGU6IF91cGRhdGVUaW1lIG1heSBkaXNhYmxlIHRoZSBhY3Rpb24gcmVzdWx0aW5nIGluXG5cdFx0Ly8gYW4gZWZmZWN0aXZlIHdlaWdodCBvZiAwXG5cblx0XHRjb25zdCB3ZWlnaHQgPSB0aGlzLl91cGRhdGVXZWlnaHQodGltZSk7XG5cdFx0aWYgKHdlaWdodCA+IDApIHtcblx0XHRcdGNvbnN0IGludGVycG9sYW50cyA9IHRoaXMuX2ludGVycG9sYW50cztcblx0XHRcdGNvbnN0IHByb3BlcnR5TWl4ZXJzID0gdGhpcy5fcHJvcGVydHlCaW5kaW5ncztcblx0XHRcdHN3aXRjaCAodGhpcy5ibGVuZE1vZGUpIHtcblx0XHRcdFx0Y2FzZSBBZGRpdGl2ZUFuaW1hdGlvbkJsZW5kTW9kZTpcblx0XHRcdFx0XHRmb3IgKGxldCBqID0gMCwgbSA9IGludGVycG9sYW50cy5sZW5ndGg7IGogIT09IG07ICsraikge1xuXHRcdFx0XHRcdFx0aW50ZXJwb2xhbnRzW2pdLmV2YWx1YXRlKGNsaXBUaW1lKTtcblx0XHRcdFx0XHRcdHByb3BlcnR5TWl4ZXJzW2pdLmFjY3VtdWxhdGVBZGRpdGl2ZSh3ZWlnaHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBOb3JtYWxBbmltYXRpb25CbGVuZE1vZGU6XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0Zm9yIChsZXQgaiA9IDAsIG0gPSBpbnRlcnBvbGFudHMubGVuZ3RoOyBqICE9PSBtOyArK2opIHtcblx0XHRcdFx0XHRcdGludGVycG9sYW50c1tqXS5ldmFsdWF0ZShjbGlwVGltZSk7XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eU1peGVyc1tqXS5hY2N1bXVsYXRlKGFjY3VJbmRleCwgd2VpZ2h0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdF91cGRhdGVXZWlnaHQodGltZSkge1xuXHRcdGxldCB3ZWlnaHQgPSAwO1xuXHRcdGlmICh0aGlzLmVuYWJsZWQpIHtcblx0XHRcdHdlaWdodCA9IHRoaXMud2VpZ2h0O1xuXHRcdFx0Y29uc3QgaW50ZXJwb2xhbnQgPSB0aGlzLl93ZWlnaHRJbnRlcnBvbGFudDtcblx0XHRcdGlmIChpbnRlcnBvbGFudCAhPT0gbnVsbCkge1xuXHRcdFx0XHRjb25zdCBpbnRlcnBvbGFudFZhbHVlID0gaW50ZXJwb2xhbnQuZXZhbHVhdGUodGltZSlbMF07XG5cdFx0XHRcdHdlaWdodCAqPSBpbnRlcnBvbGFudFZhbHVlO1xuXHRcdFx0XHRpZiAodGltZSA+IGludGVycG9sYW50LnBhcmFtZXRlclBvc2l0aW9uc1sxXSkge1xuXHRcdFx0XHRcdHRoaXMuc3RvcEZhZGluZygpO1xuXHRcdFx0XHRcdGlmIChpbnRlcnBvbGFudFZhbHVlID09PSAwKSB7XG5cdFx0XHRcdFx0XHQvLyBmYWRlZCBvdXQsIGRpc2FibGVcblx0XHRcdFx0XHRcdHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl9lZmZlY3RpdmVXZWlnaHQgPSB3ZWlnaHQ7XG5cdFx0cmV0dXJuIHdlaWdodDtcblx0fVxuXHRfdXBkYXRlVGltZVNjYWxlKHRpbWUpIHtcblx0XHRsZXQgdGltZVNjYWxlID0gMDtcblx0XHRpZiAoIXRoaXMucGF1c2VkKSB7XG5cdFx0XHR0aW1lU2NhbGUgPSB0aGlzLnRpbWVTY2FsZTtcblx0XHRcdGNvbnN0IGludGVycG9sYW50ID0gdGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQ7XG5cdFx0XHRpZiAoaW50ZXJwb2xhbnQgIT09IG51bGwpIHtcblx0XHRcdFx0Y29uc3QgaW50ZXJwb2xhbnRWYWx1ZSA9IGludGVycG9sYW50LmV2YWx1YXRlKHRpbWUpWzBdO1xuXHRcdFx0XHR0aW1lU2NhbGUgKj0gaW50ZXJwb2xhbnRWYWx1ZTtcblx0XHRcdFx0aWYgKHRpbWUgPiBpbnRlcnBvbGFudC5wYXJhbWV0ZXJQb3NpdGlvbnNbMV0pIHtcblx0XHRcdFx0XHR0aGlzLnN0b3BXYXJwaW5nKCk7XG5cdFx0XHRcdFx0aWYgKHRpbWVTY2FsZSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0Ly8gbW90aW9uIGhhcyBoYWx0ZWQsIHBhdXNlXG5cdFx0XHRcdFx0XHR0aGlzLnBhdXNlZCA9IHRydWU7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIHdhcnAgZG9uZSAtIGFwcGx5IGZpbmFsIHRpbWUgc2NhbGVcblx0XHRcdFx0XHRcdHRoaXMudGltZVNjYWxlID0gdGltZVNjYWxlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl9lZmZlY3RpdmVUaW1lU2NhbGUgPSB0aW1lU2NhbGU7XG5cdFx0cmV0dXJuIHRpbWVTY2FsZTtcblx0fVxuXHRfdXBkYXRlVGltZShkZWx0YVRpbWUpIHtcblx0XHRjb25zdCBkdXJhdGlvbiA9IHRoaXMuX2NsaXAuZHVyYXRpb247XG5cdFx0Y29uc3QgbG9vcCA9IHRoaXMubG9vcDtcblx0XHRsZXQgdGltZSA9IHRoaXMudGltZSArIGRlbHRhVGltZTtcblx0XHRsZXQgbG9vcENvdW50ID0gdGhpcy5fbG9vcENvdW50O1xuXHRcdGNvbnN0IHBpbmdQb25nID0gbG9vcCA9PT0gTG9vcFBpbmdQb25nO1xuXHRcdGlmIChkZWx0YVRpbWUgPT09IDApIHtcblx0XHRcdGlmIChsb29wQ291bnQgPT09IC0xKSByZXR1cm4gdGltZTtcblx0XHRcdHJldHVybiBwaW5nUG9uZyAmJiAobG9vcENvdW50ICYgMSkgPT09IDEgPyBkdXJhdGlvbiAtIHRpbWUgOiB0aW1lO1xuXHRcdH1cblx0XHRpZiAobG9vcCA9PT0gTG9vcE9uY2UpIHtcblx0XHRcdGlmIChsb29wQ291bnQgPT09IC0xKSB7XG5cdFx0XHRcdC8vIGp1c3Qgc3RhcnRlZFxuXG5cdFx0XHRcdHRoaXMuX2xvb3BDb3VudCA9IDA7XG5cdFx0XHRcdHRoaXMuX3NldEVuZGluZ3ModHJ1ZSwgdHJ1ZSwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0aGFuZGxlX3N0b3A6IHtcblx0XHRcdFx0aWYgKHRpbWUgPj0gZHVyYXRpb24pIHtcblx0XHRcdFx0XHR0aW1lID0gZHVyYXRpb247XG5cdFx0XHRcdH0gZWxzZSBpZiAodGltZSA8IDApIHtcblx0XHRcdFx0XHR0aW1lID0gMDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLnRpbWUgPSB0aW1lO1xuXHRcdFx0XHRcdGJyZWFrIGhhbmRsZV9zdG9wO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLmNsYW1wV2hlbkZpbmlzaGVkKSB0aGlzLnBhdXNlZCA9IHRydWU7ZWxzZSB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy50aW1lID0gdGltZTtcblx0XHRcdFx0dGhpcy5fbWl4ZXIuZGlzcGF0Y2hFdmVudCh7XG5cdFx0XHRcdFx0dHlwZTogJ2ZpbmlzaGVkJyxcblx0XHRcdFx0XHRhY3Rpb246IHRoaXMsXG5cdFx0XHRcdFx0ZGlyZWN0aW9uOiBkZWx0YVRpbWUgPCAwID8gLTEgOiAxXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyByZXBldGl0aXZlIFJlcGVhdCBvciBQaW5nUG9uZ1xuXG5cdFx0XHRpZiAobG9vcENvdW50ID09PSAtMSkge1xuXHRcdFx0XHQvLyBqdXN0IHN0YXJ0ZWRcblxuXHRcdFx0XHRpZiAoZGVsdGFUaW1lID49IDApIHtcblx0XHRcdFx0XHRsb29wQ291bnQgPSAwO1xuXHRcdFx0XHRcdHRoaXMuX3NldEVuZGluZ3ModHJ1ZSwgdGhpcy5yZXBldGl0aW9ucyA9PT0gMCwgcGluZ1BvbmcpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHdoZW4gbG9vcGluZyBpbiByZXZlcnNlIGRpcmVjdGlvbiwgdGhlIGluaXRpYWxcblx0XHRcdFx0XHQvLyB0cmFuc2l0aW9uIHRocm91Z2ggemVybyBjb3VudHMgYXMgYSByZXBldGl0aW9uLFxuXHRcdFx0XHRcdC8vIHNvIGxlYXZlIGxvb3BDb3VudCBhdCAtMVxuXG5cdFx0XHRcdFx0dGhpcy5fc2V0RW5kaW5ncyh0aGlzLnJlcGV0aXRpb25zID09PSAwLCB0cnVlLCBwaW5nUG9uZyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh0aW1lID49IGR1cmF0aW9uIHx8IHRpbWUgPCAwKSB7XG5cdFx0XHRcdC8vIHdyYXAgYXJvdW5kXG5cblx0XHRcdFx0Y29uc3QgbG9vcERlbHRhID0gTWF0aC5mbG9vcih0aW1lIC8gZHVyYXRpb24pOyAvLyBzaWduZWRcblx0XHRcdFx0dGltZSAtPSBkdXJhdGlvbiAqIGxvb3BEZWx0YTtcblx0XHRcdFx0bG9vcENvdW50ICs9IE1hdGguYWJzKGxvb3BEZWx0YSk7XG5cdFx0XHRcdGNvbnN0IHBlbmRpbmcgPSB0aGlzLnJlcGV0aXRpb25zIC0gbG9vcENvdW50O1xuXHRcdFx0XHRpZiAocGVuZGluZyA8PSAwKSB7XG5cdFx0XHRcdFx0Ly8gaGF2ZSB0byBzdG9wIChzd2l0Y2ggc3RhdGUsIGNsYW1wIHRpbWUsIGZpcmUgZXZlbnQpXG5cblx0XHRcdFx0XHRpZiAodGhpcy5jbGFtcFdoZW5GaW5pc2hlZCkgdGhpcy5wYXVzZWQgPSB0cnVlO2Vsc2UgdGhpcy5lbmFibGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0dGltZSA9IGRlbHRhVGltZSA+IDAgPyBkdXJhdGlvbiA6IDA7XG5cdFx0XHRcdFx0dGhpcy50aW1lID0gdGltZTtcblx0XHRcdFx0XHR0aGlzLl9taXhlci5kaXNwYXRjaEV2ZW50KHtcblx0XHRcdFx0XHRcdHR5cGU6ICdmaW5pc2hlZCcsXG5cdFx0XHRcdFx0XHRhY3Rpb246IHRoaXMsXG5cdFx0XHRcdFx0XHRkaXJlY3Rpb246IGRlbHRhVGltZSA+IDAgPyAxIDogLTFcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBrZWVwIHJ1bm5pbmdcblxuXHRcdFx0XHRcdGlmIChwZW5kaW5nID09PSAxKSB7XG5cdFx0XHRcdFx0XHQvLyBlbnRlcmluZyB0aGUgbGFzdCByb3VuZFxuXG5cdFx0XHRcdFx0XHRjb25zdCBhdFN0YXJ0ID0gZGVsdGFUaW1lIDwgMDtcblx0XHRcdFx0XHRcdHRoaXMuX3NldEVuZGluZ3MoYXRTdGFydCwgIWF0U3RhcnQsIHBpbmdQb25nKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5fc2V0RW5kaW5ncyhmYWxzZSwgZmFsc2UsIHBpbmdQb25nKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fbG9vcENvdW50ID0gbG9vcENvdW50O1xuXHRcdFx0XHRcdHRoaXMudGltZSA9IHRpbWU7XG5cdFx0XHRcdFx0dGhpcy5fbWl4ZXIuZGlzcGF0Y2hFdmVudCh7XG5cdFx0XHRcdFx0XHR0eXBlOiAnbG9vcCcsXG5cdFx0XHRcdFx0XHRhY3Rpb246IHRoaXMsXG5cdFx0XHRcdFx0XHRsb29wRGVsdGE6IGxvb3BEZWx0YVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnRpbWUgPSB0aW1lO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHBpbmdQb25nICYmIChsb29wQ291bnQgJiAxKSA9PT0gMSkge1xuXHRcdFx0XHQvLyBpbnZlcnQgdGltZSBmb3IgdGhlIFwicG9uZyByb3VuZFwiXG5cblx0XHRcdFx0cmV0dXJuIGR1cmF0aW9uIC0gdGltZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRpbWU7XG5cdH1cblx0X3NldEVuZGluZ3MoYXRTdGFydCwgYXRFbmQsIHBpbmdQb25nKSB7XG5cdFx0Y29uc3Qgc2V0dGluZ3MgPSB0aGlzLl9pbnRlcnBvbGFudFNldHRpbmdzO1xuXHRcdGlmIChwaW5nUG9uZykge1xuXHRcdFx0c2V0dGluZ3MuZW5kaW5nU3RhcnQgPSBaZXJvU2xvcGVFbmRpbmc7XG5cdFx0XHRzZXR0aW5ncy5lbmRpbmdFbmQgPSBaZXJvU2xvcGVFbmRpbmc7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGFzc3VtaW5nIGZvciBMb29wT25jZSBhdFN0YXJ0ID09IGF0RW5kID09IHRydWVcblxuXHRcdFx0aWYgKGF0U3RhcnQpIHtcblx0XHRcdFx0c2V0dGluZ3MuZW5kaW5nU3RhcnQgPSB0aGlzLnplcm9TbG9wZUF0U3RhcnQgPyBaZXJvU2xvcGVFbmRpbmcgOiBaZXJvQ3VydmF0dXJlRW5kaW5nO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2V0dGluZ3MuZW5kaW5nU3RhcnQgPSBXcmFwQXJvdW5kRW5kaW5nO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGF0RW5kKSB7XG5cdFx0XHRcdHNldHRpbmdzLmVuZGluZ0VuZCA9IHRoaXMuemVyb1Nsb3BlQXRFbmQgPyBaZXJvU2xvcGVFbmRpbmcgOiBaZXJvQ3VydmF0dXJlRW5kaW5nO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2V0dGluZ3MuZW5kaW5nRW5kID0gV3JhcEFyb3VuZEVuZGluZztcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0X3NjaGVkdWxlRmFkaW5nKGR1cmF0aW9uLCB3ZWlnaHROb3csIHdlaWdodFRoZW4pIHtcblx0XHRjb25zdCBtaXhlciA9IHRoaXMuX21peGVyLFxuXHRcdFx0bm93ID0gbWl4ZXIudGltZTtcblx0XHRsZXQgaW50ZXJwb2xhbnQgPSB0aGlzLl93ZWlnaHRJbnRlcnBvbGFudDtcblx0XHRpZiAoaW50ZXJwb2xhbnQgPT09IG51bGwpIHtcblx0XHRcdGludGVycG9sYW50ID0gbWl4ZXIuX2xlbmRDb250cm9sSW50ZXJwb2xhbnQoKTtcblx0XHRcdHRoaXMuX3dlaWdodEludGVycG9sYW50ID0gaW50ZXJwb2xhbnQ7XG5cdFx0fVxuXHRcdGNvbnN0IHRpbWVzID0gaW50ZXJwb2xhbnQucGFyYW1ldGVyUG9zaXRpb25zLFxuXHRcdFx0dmFsdWVzID0gaW50ZXJwb2xhbnQuc2FtcGxlVmFsdWVzO1xuXHRcdHRpbWVzWzBdID0gbm93O1xuXHRcdHZhbHVlc1swXSA9IHdlaWdodE5vdztcblx0XHR0aW1lc1sxXSA9IG5vdyArIGR1cmF0aW9uO1xuXHRcdHZhbHVlc1sxXSA9IHdlaWdodFRoZW47XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn1cblxuY29uc3QgX2NvbnRyb2xJbnRlcnBvbGFudHNSZXN1bHRCdWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KDEpO1xuY2xhc3MgQW5pbWF0aW9uTWl4ZXIgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXIge1xuXHRjb25zdHJ1Y3Rvcihyb290KSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLl9yb290ID0gcm9vdDtcblx0XHR0aGlzLl9pbml0TWVtb3J5TWFuYWdlcigpO1xuXHRcdHRoaXMuX2FjY3VJbmRleCA9IDA7XG5cdFx0dGhpcy50aW1lID0gMDtcblx0XHR0aGlzLnRpbWVTY2FsZSA9IDEuMDtcblx0fVxuXHRfYmluZEFjdGlvbihhY3Rpb24sIHByb3RvdHlwZUFjdGlvbikge1xuXHRcdGNvbnN0IHJvb3QgPSBhY3Rpb24uX2xvY2FsUm9vdCB8fCB0aGlzLl9yb290LFxuXHRcdFx0dHJhY2tzID0gYWN0aW9uLl9jbGlwLnRyYWNrcyxcblx0XHRcdG5UcmFja3MgPSB0cmFja3MubGVuZ3RoLFxuXHRcdFx0YmluZGluZ3MgPSBhY3Rpb24uX3Byb3BlcnR5QmluZGluZ3MsXG5cdFx0XHRpbnRlcnBvbGFudHMgPSBhY3Rpb24uX2ludGVycG9sYW50cyxcblx0XHRcdHJvb3RVdWlkID0gcm9vdC51dWlkLFxuXHRcdFx0YmluZGluZ3NCeVJvb3QgPSB0aGlzLl9iaW5kaW5nc0J5Um9vdEFuZE5hbWU7XG5cdFx0bGV0IGJpbmRpbmdzQnlOYW1lID0gYmluZGluZ3NCeVJvb3Rbcm9vdFV1aWRdO1xuXHRcdGlmIChiaW5kaW5nc0J5TmFtZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRiaW5kaW5nc0J5TmFtZSA9IHt9O1xuXHRcdFx0YmluZGluZ3NCeVJvb3Rbcm9vdFV1aWRdID0gYmluZGluZ3NCeU5hbWU7XG5cdFx0fVxuXHRcdGZvciAobGV0IGkgPSAwOyBpICE9PSBuVHJhY2tzOyArK2kpIHtcblx0XHRcdGNvbnN0IHRyYWNrID0gdHJhY2tzW2ldLFxuXHRcdFx0XHR0cmFja05hbWUgPSB0cmFjay5uYW1lO1xuXHRcdFx0bGV0IGJpbmRpbmcgPSBiaW5kaW5nc0J5TmFtZVt0cmFja05hbWVdO1xuXHRcdFx0aWYgKGJpbmRpbmcgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHQrK2JpbmRpbmcucmVmZXJlbmNlQ291bnQ7XG5cdFx0XHRcdGJpbmRpbmdzW2ldID0gYmluZGluZztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJpbmRpbmcgPSBiaW5kaW5nc1tpXTtcblx0XHRcdFx0aWYgKGJpbmRpbmcgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdC8vIGV4aXN0aW5nIGJpbmRpbmcsIG1ha2Ugc3VyZSB0aGUgY2FjaGUga25vd3NcblxuXHRcdFx0XHRcdGlmIChiaW5kaW5nLl9jYWNoZUluZGV4ID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHQrK2JpbmRpbmcucmVmZXJlbmNlQ291bnQ7XG5cdFx0XHRcdFx0XHR0aGlzLl9hZGRJbmFjdGl2ZUJpbmRpbmcoYmluZGluZywgcm9vdFV1aWQsIHRyYWNrTmFtZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnN0IHBhdGggPSBwcm90b3R5cGVBY3Rpb24gJiYgcHJvdG90eXBlQWN0aW9uLl9wcm9wZXJ0eUJpbmRpbmdzW2ldLmJpbmRpbmcucGFyc2VkUGF0aDtcblx0XHRcdFx0YmluZGluZyA9IG5ldyBQcm9wZXJ0eU1peGVyKFByb3BlcnR5QmluZGluZy5jcmVhdGUocm9vdCwgdHJhY2tOYW1lLCBwYXRoKSwgdHJhY2suVmFsdWVUeXBlTmFtZSwgdHJhY2suZ2V0VmFsdWVTaXplKCkpO1xuXHRcdFx0XHQrK2JpbmRpbmcucmVmZXJlbmNlQ291bnQ7XG5cdFx0XHRcdHRoaXMuX2FkZEluYWN0aXZlQmluZGluZyhiaW5kaW5nLCByb290VXVpZCwgdHJhY2tOYW1lKTtcblx0XHRcdFx0YmluZGluZ3NbaV0gPSBiaW5kaW5nO1xuXHRcdFx0fVxuXHRcdFx0aW50ZXJwb2xhbnRzW2ldLnJlc3VsdEJ1ZmZlciA9IGJpbmRpbmcuYnVmZmVyO1xuXHRcdH1cblx0fVxuXHRfYWN0aXZhdGVBY3Rpb24oYWN0aW9uKSB7XG5cdFx0aWYgKCF0aGlzLl9pc0FjdGl2ZUFjdGlvbihhY3Rpb24pKSB7XG5cdFx0XHRpZiAoYWN0aW9uLl9jYWNoZUluZGV4ID09PSBudWxsKSB7XG5cdFx0XHRcdC8vIHRoaXMgYWN0aW9uIGhhcyBiZWVuIGZvcmdvdHRlbiBieSB0aGUgY2FjaGUsIGJ1dCB0aGUgdXNlclxuXHRcdFx0XHQvLyBhcHBlYXJzIHRvIGJlIHN0aWxsIHVzaW5nIGl0IC0+IHJlYmluZFxuXG5cdFx0XHRcdGNvbnN0IHJvb3RVdWlkID0gKGFjdGlvbi5fbG9jYWxSb290IHx8IHRoaXMuX3Jvb3QpLnV1aWQsXG5cdFx0XHRcdFx0Y2xpcFV1aWQgPSBhY3Rpb24uX2NsaXAudXVpZCxcblx0XHRcdFx0XHRhY3Rpb25zRm9yQ2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXBbY2xpcFV1aWRdO1xuXHRcdFx0XHR0aGlzLl9iaW5kQWN0aW9uKGFjdGlvbiwgYWN0aW9uc0ZvckNsaXAgJiYgYWN0aW9uc0ZvckNsaXAua25vd25BY3Rpb25zWzBdKTtcblx0XHRcdFx0dGhpcy5fYWRkSW5hY3RpdmVBY3Rpb24oYWN0aW9uLCBjbGlwVXVpZCwgcm9vdFV1aWQpO1xuXHRcdFx0fVxuXHRcdFx0Y29uc3QgYmluZGluZ3MgPSBhY3Rpb24uX3Byb3BlcnR5QmluZGluZ3M7XG5cblx0XHRcdC8vIGluY3JlbWVudCByZWZlcmVuY2UgY291bnRzIC8gc29ydCBvdXQgc3RhdGVcblx0XHRcdGZvciAobGV0IGkgPSAwLCBuID0gYmluZGluZ3MubGVuZ3RoOyBpICE9PSBuOyArK2kpIHtcblx0XHRcdFx0Y29uc3QgYmluZGluZyA9IGJpbmRpbmdzW2ldO1xuXHRcdFx0XHRpZiAoYmluZGluZy51c2VDb3VudCsrID09PSAwKSB7XG5cdFx0XHRcdFx0dGhpcy5fbGVuZEJpbmRpbmcoYmluZGluZyk7XG5cdFx0XHRcdFx0YmluZGluZy5zYXZlT3JpZ2luYWxTdGF0ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9sZW5kQWN0aW9uKGFjdGlvbik7XG5cdFx0fVxuXHR9XG5cdF9kZWFjdGl2YXRlQWN0aW9uKGFjdGlvbikge1xuXHRcdGlmICh0aGlzLl9pc0FjdGl2ZUFjdGlvbihhY3Rpb24pKSB7XG5cdFx0XHRjb25zdCBiaW5kaW5ncyA9IGFjdGlvbi5fcHJvcGVydHlCaW5kaW5ncztcblxuXHRcdFx0Ly8gZGVjcmVtZW50IHJlZmVyZW5jZSBjb3VudHMgLyBzb3J0IG91dCBzdGF0ZVxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIG4gPSBiaW5kaW5ncy5sZW5ndGg7IGkgIT09IG47ICsraSkge1xuXHRcdFx0XHRjb25zdCBiaW5kaW5nID0gYmluZGluZ3NbaV07XG5cdFx0XHRcdGlmICgtLWJpbmRpbmcudXNlQ291bnQgPT09IDApIHtcblx0XHRcdFx0XHRiaW5kaW5nLnJlc3RvcmVPcmlnaW5hbFN0YXRlKCk7XG5cdFx0XHRcdFx0dGhpcy5fdGFrZUJhY2tCaW5kaW5nKGJpbmRpbmcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl90YWtlQmFja0FjdGlvbihhY3Rpb24pO1xuXHRcdH1cblx0fVxuXG5cdC8vIE1lbW9yeSBtYW5hZ2VyXG5cblx0X2luaXRNZW1vcnlNYW5hZ2VyKCkge1xuXHRcdHRoaXMuX2FjdGlvbnMgPSBbXTsgLy8gJ25BY3RpdmVBY3Rpb25zJyBmb2xsb3dlZCBieSBpbmFjdGl2ZSBvbmVzXG5cdFx0dGhpcy5fbkFjdGl2ZUFjdGlvbnMgPSAwO1xuXHRcdHRoaXMuX2FjdGlvbnNCeUNsaXAgPSB7fTtcblx0XHQvLyBpbnNpZGU6XG5cdFx0Ly8ge1xuXHRcdC8vIFx0a25vd25BY3Rpb25zOiBBcnJheTwgQW5pbWF0aW9uQWN0aW9uID4gLSB1c2VkIGFzIHByb3RvdHlwZXNcblx0XHQvLyBcdGFjdGlvbkJ5Um9vdDogQW5pbWF0aW9uQWN0aW9uIC0gbG9va3VwXG5cdFx0Ly8gfVxuXG5cdFx0dGhpcy5fYmluZGluZ3MgPSBbXTsgLy8gJ25BY3RpdmVCaW5kaW5ncycgZm9sbG93ZWQgYnkgaW5hY3RpdmUgb25lc1xuXHRcdHRoaXMuX25BY3RpdmVCaW5kaW5ncyA9IDA7XG5cdFx0dGhpcy5fYmluZGluZ3NCeVJvb3RBbmROYW1lID0ge307IC8vIGluc2lkZTogTWFwPCBuYW1lLCBQcm9wZXJ0eU1peGVyID5cblxuXHRcdHRoaXMuX2NvbnRyb2xJbnRlcnBvbGFudHMgPSBbXTsgLy8gc2FtZSBnYW1lIGFzIGFib3ZlXG5cdFx0dGhpcy5fbkFjdGl2ZUNvbnRyb2xJbnRlcnBvbGFudHMgPSAwO1xuXHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblx0XHR0aGlzLnN0YXRzID0ge1xuXHRcdFx0YWN0aW9uczoge1xuXHRcdFx0XHRnZXQgdG90YWwoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHNjb3BlLl9hY3Rpb25zLmxlbmd0aDtcblx0XHRcdFx0fSxcblx0XHRcdFx0Z2V0IGluVXNlKCkge1xuXHRcdFx0XHRcdHJldHVybiBzY29wZS5fbkFjdGl2ZUFjdGlvbnM7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRiaW5kaW5nczoge1xuXHRcdFx0XHRnZXQgdG90YWwoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHNjb3BlLl9iaW5kaW5ncy5sZW5ndGg7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGdldCBpblVzZSgpIHtcblx0XHRcdFx0XHRyZXR1cm4gc2NvcGUuX25BY3RpdmVCaW5kaW5ncztcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGNvbnRyb2xJbnRlcnBvbGFudHM6IHtcblx0XHRcdFx0Z2V0IHRvdGFsKCkge1xuXHRcdFx0XHRcdHJldHVybiBzY29wZS5fY29udHJvbEludGVycG9sYW50cy5sZW5ndGg7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGdldCBpblVzZSgpIHtcblx0XHRcdFx0XHRyZXR1cm4gc2NvcGUuX25BY3RpdmVDb250cm9sSW50ZXJwb2xhbnRzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG5cdC8vIE1lbW9yeSBtYW5hZ2VtZW50IGZvciBBbmltYXRpb25BY3Rpb24gb2JqZWN0c1xuXG5cdF9pc0FjdGl2ZUFjdGlvbihhY3Rpb24pIHtcblx0XHRjb25zdCBpbmRleCA9IGFjdGlvbi5fY2FjaGVJbmRleDtcblx0XHRyZXR1cm4gaW5kZXggIT09IG51bGwgJiYgaW5kZXggPCB0aGlzLl9uQWN0aXZlQWN0aW9ucztcblx0fVxuXHRfYWRkSW5hY3RpdmVBY3Rpb24oYWN0aW9uLCBjbGlwVXVpZCwgcm9vdFV1aWQpIHtcblx0XHRjb25zdCBhY3Rpb25zID0gdGhpcy5fYWN0aW9ucyxcblx0XHRcdGFjdGlvbnNCeUNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwO1xuXHRcdGxldCBhY3Rpb25zRm9yQ2xpcCA9IGFjdGlvbnNCeUNsaXBbY2xpcFV1aWRdO1xuXHRcdGlmIChhY3Rpb25zRm9yQ2xpcCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRhY3Rpb25zRm9yQ2xpcCA9IHtcblx0XHRcdFx0a25vd25BY3Rpb25zOiBbYWN0aW9uXSxcblx0XHRcdFx0YWN0aW9uQnlSb290OiB7fVxuXHRcdFx0fTtcblx0XHRcdGFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleCA9IDA7XG5cdFx0XHRhY3Rpb25zQnlDbGlwW2NsaXBVdWlkXSA9IGFjdGlvbnNGb3JDbGlwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCBrbm93bkFjdGlvbnMgPSBhY3Rpb25zRm9yQ2xpcC5rbm93bkFjdGlvbnM7XG5cdFx0XHRhY3Rpb24uX2J5Q2xpcENhY2hlSW5kZXggPSBrbm93bkFjdGlvbnMubGVuZ3RoO1xuXHRcdFx0a25vd25BY3Rpb25zLnB1c2goYWN0aW9uKTtcblx0XHR9XG5cdFx0YWN0aW9uLl9jYWNoZUluZGV4ID0gYWN0aW9ucy5sZW5ndGg7XG5cdFx0YWN0aW9ucy5wdXNoKGFjdGlvbik7XG5cdFx0YWN0aW9uc0ZvckNsaXAuYWN0aW9uQnlSb290W3Jvb3RVdWlkXSA9IGFjdGlvbjtcblx0fVxuXHRfcmVtb3ZlSW5hY3RpdmVBY3Rpb24oYWN0aW9uKSB7XG5cdFx0Y29uc3QgYWN0aW9ucyA9IHRoaXMuX2FjdGlvbnMsXG5cdFx0XHRsYXN0SW5hY3RpdmVBY3Rpb24gPSBhY3Rpb25zW2FjdGlvbnMubGVuZ3RoIC0gMV0sXG5cdFx0XHRjYWNoZUluZGV4ID0gYWN0aW9uLl9jYWNoZUluZGV4O1xuXHRcdGxhc3RJbmFjdGl2ZUFjdGlvbi5fY2FjaGVJbmRleCA9IGNhY2hlSW5kZXg7XG5cdFx0YWN0aW9uc1tjYWNoZUluZGV4XSA9IGxhc3RJbmFjdGl2ZUFjdGlvbjtcblx0XHRhY3Rpb25zLnBvcCgpO1xuXHRcdGFjdGlvbi5fY2FjaGVJbmRleCA9IG51bGw7XG5cdFx0Y29uc3QgY2xpcFV1aWQgPSBhY3Rpb24uX2NsaXAudXVpZCxcblx0XHRcdGFjdGlvbnNCeUNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwLFxuXHRcdFx0YWN0aW9uc0ZvckNsaXAgPSBhY3Rpb25zQnlDbGlwW2NsaXBVdWlkXSxcblx0XHRcdGtub3duQWN0aW9uc0ZvckNsaXAgPSBhY3Rpb25zRm9yQ2xpcC5rbm93bkFjdGlvbnMsXG5cdFx0XHRsYXN0S25vd25BY3Rpb24gPSBrbm93bkFjdGlvbnNGb3JDbGlwW2tub3duQWN0aW9uc0ZvckNsaXAubGVuZ3RoIC0gMV0sXG5cdFx0XHRieUNsaXBDYWNoZUluZGV4ID0gYWN0aW9uLl9ieUNsaXBDYWNoZUluZGV4O1xuXHRcdGxhc3RLbm93bkFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleCA9IGJ5Q2xpcENhY2hlSW5kZXg7XG5cdFx0a25vd25BY3Rpb25zRm9yQ2xpcFtieUNsaXBDYWNoZUluZGV4XSA9IGxhc3RLbm93bkFjdGlvbjtcblx0XHRrbm93bkFjdGlvbnNGb3JDbGlwLnBvcCgpO1xuXHRcdGFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleCA9IG51bGw7XG5cdFx0Y29uc3QgYWN0aW9uQnlSb290ID0gYWN0aW9uc0ZvckNsaXAuYWN0aW9uQnlSb290LFxuXHRcdFx0cm9vdFV1aWQgPSAoYWN0aW9uLl9sb2NhbFJvb3QgfHwgdGhpcy5fcm9vdCkudXVpZDtcblx0XHRkZWxldGUgYWN0aW9uQnlSb290W3Jvb3RVdWlkXTtcblx0XHRpZiAoa25vd25BY3Rpb25zRm9yQ2xpcC5sZW5ndGggPT09IDApIHtcblx0XHRcdGRlbGV0ZSBhY3Rpb25zQnlDbGlwW2NsaXBVdWlkXTtcblx0XHR9XG5cdFx0dGhpcy5fcmVtb3ZlSW5hY3RpdmVCaW5kaW5nc0ZvckFjdGlvbihhY3Rpb24pO1xuXHR9XG5cdF9yZW1vdmVJbmFjdGl2ZUJpbmRpbmdzRm9yQWN0aW9uKGFjdGlvbikge1xuXHRcdGNvbnN0IGJpbmRpbmdzID0gYWN0aW9uLl9wcm9wZXJ0eUJpbmRpbmdzO1xuXHRcdGZvciAobGV0IGkgPSAwLCBuID0gYmluZGluZ3MubGVuZ3RoOyBpICE9PSBuOyArK2kpIHtcblx0XHRcdGNvbnN0IGJpbmRpbmcgPSBiaW5kaW5nc1tpXTtcblx0XHRcdGlmICgtLWJpbmRpbmcucmVmZXJlbmNlQ291bnQgPT09IDApIHtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlSW5hY3RpdmVCaW5kaW5nKGJpbmRpbmcpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRfbGVuZEFjdGlvbihhY3Rpb24pIHtcblx0XHQvLyBbIGFjdGl2ZSBhY3Rpb25zIHxcdGluYWN0aXZlIGFjdGlvbnNcdF1cblx0XHQvLyBbXHRhY3RpdmUgYWN0aW9ucyA+fCBpbmFjdGl2ZSBhY3Rpb25zIF1cblx0XHQvL1x0XHRcdFx0XHRcdFx0XHQgc1x0XHRcdFx0YVxuXHRcdC8vXHRcdFx0XHRcdFx0XHRcdFx0PC1zd2FwLT5cblx0XHQvL1x0XHRcdFx0XHRcdFx0XHQgYVx0XHRcdFx0c1xuXG5cdFx0Y29uc3QgYWN0aW9ucyA9IHRoaXMuX2FjdGlvbnMsXG5cdFx0XHRwcmV2SW5kZXggPSBhY3Rpb24uX2NhY2hlSW5kZXgsXG5cdFx0XHRsYXN0QWN0aXZlSW5kZXggPSB0aGlzLl9uQWN0aXZlQWN0aW9ucysrLFxuXHRcdFx0Zmlyc3RJbmFjdGl2ZUFjdGlvbiA9IGFjdGlvbnNbbGFzdEFjdGl2ZUluZGV4XTtcblx0XHRhY3Rpb24uX2NhY2hlSW5kZXggPSBsYXN0QWN0aXZlSW5kZXg7XG5cdFx0YWN0aW9uc1tsYXN0QWN0aXZlSW5kZXhdID0gYWN0aW9uO1xuXHRcdGZpcnN0SW5hY3RpdmVBY3Rpb24uX2NhY2hlSW5kZXggPSBwcmV2SW5kZXg7XG5cdFx0YWN0aW9uc1twcmV2SW5kZXhdID0gZmlyc3RJbmFjdGl2ZUFjdGlvbjtcblx0fVxuXHRfdGFrZUJhY2tBY3Rpb24oYWN0aW9uKSB7XG5cdFx0Ly8gW1x0YWN0aXZlIGFjdGlvbnNcdHwgaW5hY3RpdmUgYWN0aW9ucyBdXG5cdFx0Ly8gWyBhY3RpdmUgYWN0aW9ucyB8PCBpbmFjdGl2ZSBhY3Rpb25zXHRdXG5cdFx0Ly9cdFx0XHRcdGFcdFx0XHRcdHNcblx0XHQvL1x0XHRcdFx0IDwtc3dhcC0+XG5cdFx0Ly9cdFx0XHRcdHNcdFx0XHRcdGFcblxuXHRcdGNvbnN0IGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxuXHRcdFx0cHJldkluZGV4ID0gYWN0aW9uLl9jYWNoZUluZGV4LFxuXHRcdFx0Zmlyc3RJbmFjdGl2ZUluZGV4ID0gLS10aGlzLl9uQWN0aXZlQWN0aW9ucyxcblx0XHRcdGxhc3RBY3RpdmVBY3Rpb24gPSBhY3Rpb25zW2ZpcnN0SW5hY3RpdmVJbmRleF07XG5cdFx0YWN0aW9uLl9jYWNoZUluZGV4ID0gZmlyc3RJbmFjdGl2ZUluZGV4O1xuXHRcdGFjdGlvbnNbZmlyc3RJbmFjdGl2ZUluZGV4XSA9IGFjdGlvbjtcblx0XHRsYXN0QWN0aXZlQWN0aW9uLl9jYWNoZUluZGV4ID0gcHJldkluZGV4O1xuXHRcdGFjdGlvbnNbcHJldkluZGV4XSA9IGxhc3RBY3RpdmVBY3Rpb247XG5cdH1cblxuXHQvLyBNZW1vcnkgbWFuYWdlbWVudCBmb3IgUHJvcGVydHlNaXhlciBvYmplY3RzXG5cblx0X2FkZEluYWN0aXZlQmluZGluZyhiaW5kaW5nLCByb290VXVpZCwgdHJhY2tOYW1lKSB7XG5cdFx0Y29uc3QgYmluZGluZ3NCeVJvb3QgPSB0aGlzLl9iaW5kaW5nc0J5Um9vdEFuZE5hbWUsXG5cdFx0XHRiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzO1xuXHRcdGxldCBiaW5kaW5nQnlOYW1lID0gYmluZGluZ3NCeVJvb3Rbcm9vdFV1aWRdO1xuXHRcdGlmIChiaW5kaW5nQnlOYW1lID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGJpbmRpbmdCeU5hbWUgPSB7fTtcblx0XHRcdGJpbmRpbmdzQnlSb290W3Jvb3RVdWlkXSA9IGJpbmRpbmdCeU5hbWU7XG5cdFx0fVxuXHRcdGJpbmRpbmdCeU5hbWVbdHJhY2tOYW1lXSA9IGJpbmRpbmc7XG5cdFx0YmluZGluZy5fY2FjaGVJbmRleCA9IGJpbmRpbmdzLmxlbmd0aDtcblx0XHRiaW5kaW5ncy5wdXNoKGJpbmRpbmcpO1xuXHR9XG5cdF9yZW1vdmVJbmFjdGl2ZUJpbmRpbmcoYmluZGluZykge1xuXHRcdGNvbnN0IGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXG5cdFx0XHRwcm9wQmluZGluZyA9IGJpbmRpbmcuYmluZGluZyxcblx0XHRcdHJvb3RVdWlkID0gcHJvcEJpbmRpbmcucm9vdE5vZGUudXVpZCxcblx0XHRcdHRyYWNrTmFtZSA9IHByb3BCaW5kaW5nLnBhdGgsXG5cdFx0XHRiaW5kaW5nc0J5Um9vdCA9IHRoaXMuX2JpbmRpbmdzQnlSb290QW5kTmFtZSxcblx0XHRcdGJpbmRpbmdCeU5hbWUgPSBiaW5kaW5nc0J5Um9vdFtyb290VXVpZF0sXG5cdFx0XHRsYXN0SW5hY3RpdmVCaW5kaW5nID0gYmluZGluZ3NbYmluZGluZ3MubGVuZ3RoIC0gMV0sXG5cdFx0XHRjYWNoZUluZGV4ID0gYmluZGluZy5fY2FjaGVJbmRleDtcblx0XHRsYXN0SW5hY3RpdmVCaW5kaW5nLl9jYWNoZUluZGV4ID0gY2FjaGVJbmRleDtcblx0XHRiaW5kaW5nc1tjYWNoZUluZGV4XSA9IGxhc3RJbmFjdGl2ZUJpbmRpbmc7XG5cdFx0YmluZGluZ3MucG9wKCk7XG5cdFx0ZGVsZXRlIGJpbmRpbmdCeU5hbWVbdHJhY2tOYW1lXTtcblx0XHRpZiAoT2JqZWN0LmtleXMoYmluZGluZ0J5TmFtZSkubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRkZWxldGUgYmluZGluZ3NCeVJvb3Rbcm9vdFV1aWRdO1xuXHRcdH1cblx0fVxuXHRfbGVuZEJpbmRpbmcoYmluZGluZykge1xuXHRcdGNvbnN0IGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXG5cdFx0XHRwcmV2SW5kZXggPSBiaW5kaW5nLl9jYWNoZUluZGV4LFxuXHRcdFx0bGFzdEFjdGl2ZUluZGV4ID0gdGhpcy5fbkFjdGl2ZUJpbmRpbmdzKyssXG5cdFx0XHRmaXJzdEluYWN0aXZlQmluZGluZyA9IGJpbmRpbmdzW2xhc3RBY3RpdmVJbmRleF07XG5cdFx0YmluZGluZy5fY2FjaGVJbmRleCA9IGxhc3RBY3RpdmVJbmRleDtcblx0XHRiaW5kaW5nc1tsYXN0QWN0aXZlSW5kZXhdID0gYmluZGluZztcblx0XHRmaXJzdEluYWN0aXZlQmluZGluZy5fY2FjaGVJbmRleCA9IHByZXZJbmRleDtcblx0XHRiaW5kaW5nc1twcmV2SW5kZXhdID0gZmlyc3RJbmFjdGl2ZUJpbmRpbmc7XG5cdH1cblx0X3Rha2VCYWNrQmluZGluZyhiaW5kaW5nKSB7XG5cdFx0Y29uc3QgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncyxcblx0XHRcdHByZXZJbmRleCA9IGJpbmRpbmcuX2NhY2hlSW5kZXgsXG5cdFx0XHRmaXJzdEluYWN0aXZlSW5kZXggPSAtLXRoaXMuX25BY3RpdmVCaW5kaW5ncyxcblx0XHRcdGxhc3RBY3RpdmVCaW5kaW5nID0gYmluZGluZ3NbZmlyc3RJbmFjdGl2ZUluZGV4XTtcblx0XHRiaW5kaW5nLl9jYWNoZUluZGV4ID0gZmlyc3RJbmFjdGl2ZUluZGV4O1xuXHRcdGJpbmRpbmdzW2ZpcnN0SW5hY3RpdmVJbmRleF0gPSBiaW5kaW5nO1xuXHRcdGxhc3RBY3RpdmVCaW5kaW5nLl9jYWNoZUluZGV4ID0gcHJldkluZGV4O1xuXHRcdGJpbmRpbmdzW3ByZXZJbmRleF0gPSBsYXN0QWN0aXZlQmluZGluZztcblx0fVxuXG5cdC8vIE1lbW9yeSBtYW5hZ2VtZW50IG9mIEludGVycG9sYW50cyBmb3Igd2VpZ2h0IGFuZCB0aW1lIHNjYWxlXG5cblx0X2xlbmRDb250cm9sSW50ZXJwb2xhbnQoKSB7XG5cdFx0Y29uc3QgaW50ZXJwb2xhbnRzID0gdGhpcy5fY29udHJvbEludGVycG9sYW50cyxcblx0XHRcdGxhc3RBY3RpdmVJbmRleCA9IHRoaXMuX25BY3RpdmVDb250cm9sSW50ZXJwb2xhbnRzKys7XG5cdFx0bGV0IGludGVycG9sYW50ID0gaW50ZXJwb2xhbnRzW2xhc3RBY3RpdmVJbmRleF07XG5cdFx0aWYgKGludGVycG9sYW50ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGludGVycG9sYW50ID0gbmV3IExpbmVhckludGVycG9sYW50KG5ldyBGbG9hdDMyQXJyYXkoMiksIG5ldyBGbG9hdDMyQXJyYXkoMiksIDEsIF9jb250cm9sSW50ZXJwb2xhbnRzUmVzdWx0QnVmZmVyKTtcblx0XHRcdGludGVycG9sYW50Ll9fY2FjaGVJbmRleCA9IGxhc3RBY3RpdmVJbmRleDtcblx0XHRcdGludGVycG9sYW50c1tsYXN0QWN0aXZlSW5kZXhdID0gaW50ZXJwb2xhbnQ7XG5cdFx0fVxuXHRcdHJldHVybiBpbnRlcnBvbGFudDtcblx0fVxuXHRfdGFrZUJhY2tDb250cm9sSW50ZXJwb2xhbnQoaW50ZXJwb2xhbnQpIHtcblx0XHRjb25zdCBpbnRlcnBvbGFudHMgPSB0aGlzLl9jb250cm9sSW50ZXJwb2xhbnRzLFxuXHRcdFx0cHJldkluZGV4ID0gaW50ZXJwb2xhbnQuX19jYWNoZUluZGV4LFxuXHRcdFx0Zmlyc3RJbmFjdGl2ZUluZGV4ID0gLS10aGlzLl9uQWN0aXZlQ29udHJvbEludGVycG9sYW50cyxcblx0XHRcdGxhc3RBY3RpdmVJbnRlcnBvbGFudCA9IGludGVycG9sYW50c1tmaXJzdEluYWN0aXZlSW5kZXhdO1xuXHRcdGludGVycG9sYW50Ll9fY2FjaGVJbmRleCA9IGZpcnN0SW5hY3RpdmVJbmRleDtcblx0XHRpbnRlcnBvbGFudHNbZmlyc3RJbmFjdGl2ZUluZGV4XSA9IGludGVycG9sYW50O1xuXHRcdGxhc3RBY3RpdmVJbnRlcnBvbGFudC5fX2NhY2hlSW5kZXggPSBwcmV2SW5kZXg7XG5cdFx0aW50ZXJwb2xhbnRzW3ByZXZJbmRleF0gPSBsYXN0QWN0aXZlSW50ZXJwb2xhbnQ7XG5cdH1cblxuXHQvLyByZXR1cm4gYW4gYWN0aW9uIGZvciBhIGNsaXAgb3B0aW9uYWxseSB1c2luZyBhIGN1c3RvbSByb290IHRhcmdldFxuXHQvLyBvYmplY3QgKHRoaXMgbWV0aG9kIGFsbG9jYXRlcyBhIGxvdCBvZiBkeW5hbWljIG1lbW9yeSBpbiBjYXNlIGFcblx0Ly8gcHJldmlvdXNseSB1bmtub3duIGNsaXAvcm9vdCBjb21iaW5hdGlvbiBpcyBzcGVjaWZpZWQpXG5cdGNsaXBBY3Rpb24oY2xpcCwgb3B0aW9uYWxSb290LCBibGVuZE1vZGUpIHtcblx0XHRjb25zdCByb290ID0gb3B0aW9uYWxSb290IHx8IHRoaXMuX3Jvb3QsXG5cdFx0XHRyb290VXVpZCA9IHJvb3QudXVpZDtcblx0XHRsZXQgY2xpcE9iamVjdCA9IHR5cGVvZiBjbGlwID09PSAnc3RyaW5nJyA/IEFuaW1hdGlvbkNsaXAuZmluZEJ5TmFtZShyb290LCBjbGlwKSA6IGNsaXA7XG5cdFx0Y29uc3QgY2xpcFV1aWQgPSBjbGlwT2JqZWN0ICE9PSBudWxsID8gY2xpcE9iamVjdC51dWlkIDogY2xpcDtcblx0XHRjb25zdCBhY3Rpb25zRm9yQ2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXBbY2xpcFV1aWRdO1xuXHRcdGxldCBwcm90b3R5cGVBY3Rpb24gPSBudWxsO1xuXHRcdGlmIChibGVuZE1vZGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aWYgKGNsaXBPYmplY3QgIT09IG51bGwpIHtcblx0XHRcdFx0YmxlbmRNb2RlID0gY2xpcE9iamVjdC5ibGVuZE1vZGU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRibGVuZE1vZGUgPSBOb3JtYWxBbmltYXRpb25CbGVuZE1vZGU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChhY3Rpb25zRm9yQ2xpcCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjb25zdCBleGlzdGluZ0FjdGlvbiA9IGFjdGlvbnNGb3JDbGlwLmFjdGlvbkJ5Um9vdFtyb290VXVpZF07XG5cdFx0XHRpZiAoZXhpc3RpbmdBY3Rpb24gIT09IHVuZGVmaW5lZCAmJiBleGlzdGluZ0FjdGlvbi5ibGVuZE1vZGUgPT09IGJsZW5kTW9kZSkge1xuXHRcdFx0XHRyZXR1cm4gZXhpc3RpbmdBY3Rpb247XG5cdFx0XHR9XG5cblx0XHRcdC8vIHdlIGtub3cgdGhlIGNsaXAsIHNvIHdlIGRvbid0IGhhdmUgdG8gcGFyc2UgYWxsXG5cdFx0XHQvLyB0aGUgYmluZGluZ3MgYWdhaW4gYnV0IGNhbiBqdXN0IGNvcHlcblx0XHRcdHByb3RvdHlwZUFjdGlvbiA9IGFjdGlvbnNGb3JDbGlwLmtub3duQWN0aW9uc1swXTtcblxuXHRcdFx0Ly8gYWxzbywgdGFrZSB0aGUgY2xpcCBmcm9tIHRoZSBwcm90b3R5cGUgYWN0aW9uXG5cdFx0XHRpZiAoY2xpcE9iamVjdCA9PT0gbnVsbCkgY2xpcE9iamVjdCA9IHByb3RvdHlwZUFjdGlvbi5fY2xpcDtcblx0XHR9XG5cblx0XHQvLyBjbGlwIG11c3QgYmUga25vd24gd2hlbiBzcGVjaWZpZWQgdmlhIHN0cmluZ1xuXHRcdGlmIChjbGlwT2JqZWN0ID09PSBudWxsKSByZXR1cm4gbnVsbDtcblxuXHRcdC8vIGFsbG9jYXRlIGFsbCByZXNvdXJjZXMgcmVxdWlyZWQgdG8gcnVuIGl0XG5cdFx0Y29uc3QgbmV3QWN0aW9uID0gbmV3IEFuaW1hdGlvbkFjdGlvbih0aGlzLCBjbGlwT2JqZWN0LCBvcHRpb25hbFJvb3QsIGJsZW5kTW9kZSk7XG5cdFx0dGhpcy5fYmluZEFjdGlvbihuZXdBY3Rpb24sIHByb3RvdHlwZUFjdGlvbik7XG5cblx0XHQvLyBhbmQgbWFrZSB0aGUgYWN0aW9uIGtub3duIHRvIHRoZSBtZW1vcnkgbWFuYWdlclxuXHRcdHRoaXMuX2FkZEluYWN0aXZlQWN0aW9uKG5ld0FjdGlvbiwgY2xpcFV1aWQsIHJvb3RVdWlkKTtcblx0XHRyZXR1cm4gbmV3QWN0aW9uO1xuXHR9XG5cblx0Ly8gZ2V0IGFuIGV4aXN0aW5nIGFjdGlvblxuXHRleGlzdGluZ0FjdGlvbihjbGlwLCBvcHRpb25hbFJvb3QpIHtcblx0XHRjb25zdCByb290ID0gb3B0aW9uYWxSb290IHx8IHRoaXMuX3Jvb3QsXG5cdFx0XHRyb290VXVpZCA9IHJvb3QudXVpZCxcblx0XHRcdGNsaXBPYmplY3QgPSB0eXBlb2YgY2xpcCA9PT0gJ3N0cmluZycgPyBBbmltYXRpb25DbGlwLmZpbmRCeU5hbWUocm9vdCwgY2xpcCkgOiBjbGlwLFxuXHRcdFx0Y2xpcFV1aWQgPSBjbGlwT2JqZWN0ID8gY2xpcE9iamVjdC51dWlkIDogY2xpcCxcblx0XHRcdGFjdGlvbnNGb3JDbGlwID0gdGhpcy5fYWN0aW9uc0J5Q2xpcFtjbGlwVXVpZF07XG5cdFx0aWYgKGFjdGlvbnNGb3JDbGlwICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiBhY3Rpb25zRm9yQ2xpcC5hY3Rpb25CeVJvb3Rbcm9vdFV1aWRdIHx8IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gZGVhY3RpdmF0ZXMgYWxsIHByZXZpb3VzbHkgc2NoZWR1bGVkIGFjdGlvbnNcblx0c3RvcEFsbEFjdGlvbigpIHtcblx0XHRjb25zdCBhY3Rpb25zID0gdGhpcy5fYWN0aW9ucyxcblx0XHRcdG5BY3Rpb25zID0gdGhpcy5fbkFjdGl2ZUFjdGlvbnM7XG5cdFx0Zm9yIChsZXQgaSA9IG5BY3Rpb25zIC0gMTsgaSA+PSAwOyAtLWkpIHtcblx0XHRcdGFjdGlvbnNbaV0uc3RvcCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8vIGFkdmFuY2UgdGhlIHRpbWUgYW5kIHVwZGF0ZSBhcHBseSB0aGUgYW5pbWF0aW9uXG5cdHVwZGF0ZShkZWx0YVRpbWUpIHtcblx0XHRkZWx0YVRpbWUgKj0gdGhpcy50aW1lU2NhbGU7XG5cdFx0Y29uc3QgYWN0aW9ucyA9IHRoaXMuX2FjdGlvbnMsXG5cdFx0XHRuQWN0aW9ucyA9IHRoaXMuX25BY3RpdmVBY3Rpb25zLFxuXHRcdFx0dGltZSA9IHRoaXMudGltZSArPSBkZWx0YVRpbWUsXG5cdFx0XHR0aW1lRGlyZWN0aW9uID0gTWF0aC5zaWduKGRlbHRhVGltZSksXG5cdFx0XHRhY2N1SW5kZXggPSB0aGlzLl9hY2N1SW5kZXggXj0gMTtcblxuXHRcdC8vIHJ1biBhY3RpdmUgYWN0aW9uc1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgIT09IG5BY3Rpb25zOyArK2kpIHtcblx0XHRcdGNvbnN0IGFjdGlvbiA9IGFjdGlvbnNbaV07XG5cdFx0XHRhY3Rpb24uX3VwZGF0ZSh0aW1lLCBkZWx0YVRpbWUsIHRpbWVEaXJlY3Rpb24sIGFjY3VJbmRleCk7XG5cdFx0fVxuXG5cdFx0Ly8gdXBkYXRlIHNjZW5lIGdyYXBoXG5cblx0XHRjb25zdCBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxuXHRcdFx0bkJpbmRpbmdzID0gdGhpcy5fbkFjdGl2ZUJpbmRpbmdzO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpICE9PSBuQmluZGluZ3M7ICsraSkge1xuXHRcdFx0YmluZGluZ3NbaV0uYXBwbHkoYWNjdUluZGV4KTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvLyBBbGxvd3MgeW91IHRvIHNlZWsgdG8gYSBzcGVjaWZpYyB0aW1lIGluIGFuIGFuaW1hdGlvbi5cblx0c2V0VGltZSh0aW1lSW5TZWNvbmRzKSB7XG5cdFx0dGhpcy50aW1lID0gMDsgLy8gWmVybyBvdXQgdGltZSBhdHRyaWJ1dGUgZm9yIEFuaW1hdGlvbk1peGVyIG9iamVjdDtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2FjdGlvbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHRoaXMuX2FjdGlvbnNbaV0udGltZSA9IDA7IC8vIFplcm8gb3V0IHRpbWUgYXR0cmlidXRlIGZvciBhbGwgYXNzb2NpYXRlZCBBbmltYXRpb25BY3Rpb24gb2JqZWN0cy5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy51cGRhdGUodGltZUluU2Vjb25kcyk7IC8vIFVwZGF0ZSB1c2VkIHRvIHNldCBleGFjdCB0aW1lLiBSZXR1cm5zIFwidGhpc1wiIEFuaW1hdGlvbk1peGVyIG9iamVjdC5cblx0fVxuXG5cdC8vIHJldHVybiB0aGlzIG1peGVyJ3Mgcm9vdCB0YXJnZXQgb2JqZWN0XG5cdGdldFJvb3QoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Jvb3Q7XG5cdH1cblxuXHQvLyBmcmVlIGFsbCByZXNvdXJjZXMgc3BlY2lmaWMgdG8gYSBwYXJ0aWN1bGFyIGNsaXBcblx0dW5jYWNoZUNsaXAoY2xpcCkge1xuXHRcdGNvbnN0IGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxuXHRcdFx0Y2xpcFV1aWQgPSBjbGlwLnV1aWQsXG5cdFx0XHRhY3Rpb25zQnlDbGlwID0gdGhpcy5fYWN0aW9uc0J5Q2xpcCxcblx0XHRcdGFjdGlvbnNGb3JDbGlwID0gYWN0aW9uc0J5Q2xpcFtjbGlwVXVpZF07XG5cdFx0aWYgKGFjdGlvbnNGb3JDbGlwICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdC8vIG5vdGU6IGp1c3QgY2FsbGluZyBfcmVtb3ZlSW5hY3RpdmVBY3Rpb24gd291bGQgbWVzcyB1cCB0aGVcblx0XHRcdC8vIGl0ZXJhdGlvbiBzdGF0ZSBhbmQgYWxzbyByZXF1aXJlIHVwZGF0aW5nIHRoZSBzdGF0ZSB3ZSBjYW5cblx0XHRcdC8vIGp1c3QgdGhyb3cgYXdheVxuXG5cdFx0XHRjb25zdCBhY3Rpb25zVG9SZW1vdmUgPSBhY3Rpb25zRm9yQ2xpcC5rbm93bkFjdGlvbnM7XG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbiA9IGFjdGlvbnNUb1JlbW92ZS5sZW5ndGg7IGkgIT09IG47ICsraSkge1xuXHRcdFx0XHRjb25zdCBhY3Rpb24gPSBhY3Rpb25zVG9SZW1vdmVbaV07XG5cdFx0XHRcdHRoaXMuX2RlYWN0aXZhdGVBY3Rpb24oYWN0aW9uKTtcblx0XHRcdFx0Y29uc3QgY2FjaGVJbmRleCA9IGFjdGlvbi5fY2FjaGVJbmRleCxcblx0XHRcdFx0XHRsYXN0SW5hY3RpdmVBY3Rpb24gPSBhY3Rpb25zW2FjdGlvbnMubGVuZ3RoIC0gMV07XG5cdFx0XHRcdGFjdGlvbi5fY2FjaGVJbmRleCA9IG51bGw7XG5cdFx0XHRcdGFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleCA9IG51bGw7XG5cdFx0XHRcdGxhc3RJbmFjdGl2ZUFjdGlvbi5fY2FjaGVJbmRleCA9IGNhY2hlSW5kZXg7XG5cdFx0XHRcdGFjdGlvbnNbY2FjaGVJbmRleF0gPSBsYXN0SW5hY3RpdmVBY3Rpb247XG5cdFx0XHRcdGFjdGlvbnMucG9wKCk7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZUluYWN0aXZlQmluZGluZ3NGb3JBY3Rpb24oYWN0aW9uKTtcblx0XHRcdH1cblx0XHRcdGRlbGV0ZSBhY3Rpb25zQnlDbGlwW2NsaXBVdWlkXTtcblx0XHR9XG5cdH1cblxuXHQvLyBmcmVlIGFsbCByZXNvdXJjZXMgc3BlY2lmaWMgdG8gYSBwYXJ0aWN1bGFyIHJvb3QgdGFyZ2V0IG9iamVjdFxuXHR1bmNhY2hlUm9vdChyb290KSB7XG5cdFx0Y29uc3Qgcm9vdFV1aWQgPSByb290LnV1aWQsXG5cdFx0XHRhY3Rpb25zQnlDbGlwID0gdGhpcy5fYWN0aW9uc0J5Q2xpcDtcblx0XHRmb3IgKGNvbnN0IGNsaXBVdWlkIGluIGFjdGlvbnNCeUNsaXApIHtcblx0XHRcdGNvbnN0IGFjdGlvbkJ5Um9vdCA9IGFjdGlvbnNCeUNsaXBbY2xpcFV1aWRdLmFjdGlvbkJ5Um9vdCxcblx0XHRcdFx0YWN0aW9uID0gYWN0aW9uQnlSb290W3Jvb3RVdWlkXTtcblx0XHRcdGlmIChhY3Rpb24gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLl9kZWFjdGl2YXRlQWN0aW9uKGFjdGlvbik7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZUluYWN0aXZlQWN0aW9uKGFjdGlvbik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNvbnN0IGJpbmRpbmdzQnlSb290ID0gdGhpcy5fYmluZGluZ3NCeVJvb3RBbmROYW1lLFxuXHRcdFx0YmluZGluZ0J5TmFtZSA9IGJpbmRpbmdzQnlSb290W3Jvb3RVdWlkXTtcblx0XHRpZiAoYmluZGluZ0J5TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRmb3IgKGNvbnN0IHRyYWNrTmFtZSBpbiBiaW5kaW5nQnlOYW1lKSB7XG5cdFx0XHRcdGNvbnN0IGJpbmRpbmcgPSBiaW5kaW5nQnlOYW1lW3RyYWNrTmFtZV07XG5cdFx0XHRcdGJpbmRpbmcucmVzdG9yZU9yaWdpbmFsU3RhdGUoKTtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlSW5hY3RpdmVCaW5kaW5nKGJpbmRpbmcpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIHJlbW92ZSBhIHRhcmdldGVkIGNsaXAgZnJvbSB0aGUgY2FjaGVcblx0dW5jYWNoZUFjdGlvbihjbGlwLCBvcHRpb25hbFJvb3QpIHtcblx0XHRjb25zdCBhY3Rpb24gPSB0aGlzLmV4aXN0aW5nQWN0aW9uKGNsaXAsIG9wdGlvbmFsUm9vdCk7XG5cdFx0aWYgKGFjdGlvbiAhPT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fZGVhY3RpdmF0ZUFjdGlvbihhY3Rpb24pO1xuXHRcdFx0dGhpcy5fcmVtb3ZlSW5hY3RpdmVBY3Rpb24oYWN0aW9uKTtcblx0XHR9XG5cdH1cbn1cblxuY2xhc3MgVW5pZm9ybSB7XG5cdGNvbnN0cnVjdG9yKHZhbHVlKSB7XG5cdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXHR9XG5cdGNsb25lKCkge1xuXHRcdHJldHVybiBuZXcgVW5pZm9ybSh0aGlzLnZhbHVlLmNsb25lID09PSB1bmRlZmluZWQgPyB0aGlzLnZhbHVlIDogdGhpcy52YWx1ZS5jbG9uZSgpKTtcblx0fVxufVxuXG5sZXQgaWQgPSAwO1xuY2xhc3MgVW5pZm9ybXNHcm91cCBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlciB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5pc1VuaWZvcm1zR3JvdXAgPSB0cnVlO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaWQnLCB7XG5cdFx0XHR2YWx1ZTogaWQrK1xuXHRcdH0pO1xuXHRcdHRoaXMubmFtZSA9ICcnO1xuXHRcdHRoaXMudXNhZ2UgPSBTdGF0aWNEcmF3VXNhZ2U7XG5cdFx0dGhpcy51bmlmb3JtcyA9IFtdO1xuXHR9XG5cdGFkZCh1bmlmb3JtKSB7XG5cdFx0dGhpcy51bmlmb3Jtcy5wdXNoKHVuaWZvcm0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHJlbW92ZSh1bmlmb3JtKSB7XG5cdFx0Y29uc3QgaW5kZXggPSB0aGlzLnVuaWZvcm1zLmluZGV4T2YodW5pZm9ybSk7XG5cdFx0aWYgKGluZGV4ICE9PSAtMSkgdGhpcy51bmlmb3Jtcy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHNldE5hbWUobmFtZSkge1xuXHRcdHRoaXMubmFtZSA9IG5hbWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0c2V0VXNhZ2UodmFsdWUpIHtcblx0XHR0aGlzLnVzYWdlID0gdmFsdWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0ZGlzcG9zZSgpIHtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoe1xuXHRcdFx0dHlwZTogJ2Rpc3Bvc2UnXG5cdFx0fSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0Y29weShzb3VyY2UpIHtcblx0XHR0aGlzLm5hbWUgPSBzb3VyY2UubmFtZTtcblx0XHR0aGlzLnVzYWdlID0gc291cmNlLnVzYWdlO1xuXHRcdGNvbnN0IHVuaWZvcm1zU291cmNlID0gc291cmNlLnVuaWZvcm1zO1xuXHRcdHRoaXMudW5pZm9ybXMubGVuZ3RoID0gMDtcblx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHVuaWZvcm1zU291cmNlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dGhpcy51bmlmb3Jtcy5wdXNoKHVuaWZvcm1zU291cmNlW2ldLmNsb25lKCkpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRjbG9uZSgpIHtcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpO1xuXHR9XG59XG5cbmNsYXNzIEluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyIGV4dGVuZHMgSW50ZXJsZWF2ZWRCdWZmZXIge1xuXHRjb25zdHJ1Y3RvcihhcnJheSwgc3RyaWRlLCBtZXNoUGVyQXR0cmlidXRlID0gMSkge1xuXHRcdHN1cGVyKGFycmF5LCBzdHJpZGUpO1xuXHRcdHRoaXMuaXNJbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlciA9IHRydWU7XG5cdFx0dGhpcy5tZXNoUGVyQXR0cmlidXRlID0gbWVzaFBlckF0dHJpYnV0ZTtcblx0fVxuXHRjb3B5KHNvdXJjZSkge1xuXHRcdHN1cGVyLmNvcHkoc291cmNlKTtcblx0XHR0aGlzLm1lc2hQZXJBdHRyaWJ1dGUgPSBzb3VyY2UubWVzaFBlckF0dHJpYnV0ZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRjbG9uZShkYXRhKSB7XG5cdFx0Y29uc3QgaWIgPSBzdXBlci5jbG9uZShkYXRhKTtcblx0XHRpYi5tZXNoUGVyQXR0cmlidXRlID0gdGhpcy5tZXNoUGVyQXR0cmlidXRlO1xuXHRcdHJldHVybiBpYjtcblx0fVxuXHR0b0pTT04oZGF0YSkge1xuXHRcdGNvbnN0IGpzb24gPSBzdXBlci50b0pTT04oZGF0YSk7XG5cdFx0anNvbi5pc0luc3RhbmNlZEludGVybGVhdmVkQnVmZmVyID0gdHJ1ZTtcblx0XHRqc29uLm1lc2hQZXJBdHRyaWJ1dGUgPSB0aGlzLm1lc2hQZXJBdHRyaWJ1dGU7XG5cdFx0cmV0dXJuIGpzb247XG5cdH1cbn1cblxuY2xhc3MgR0xCdWZmZXJBdHRyaWJ1dGUge1xuXHRjb25zdHJ1Y3RvcihidWZmZXIsIHR5cGUsIGl0ZW1TaXplLCBlbGVtZW50U2l6ZSwgY291bnQpIHtcblx0XHR0aGlzLmlzR0xCdWZmZXJBdHRyaWJ1dGUgPSB0cnVlO1xuXHRcdHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuXHRcdHRoaXMudHlwZSA9IHR5cGU7XG5cdFx0dGhpcy5pdGVtU2l6ZSA9IGl0ZW1TaXplO1xuXHRcdHRoaXMuZWxlbWVudFNpemUgPSBlbGVtZW50U2l6ZTtcblx0XHR0aGlzLmNvdW50ID0gY291bnQ7XG5cdFx0dGhpcy52ZXJzaW9uID0gMDtcblx0fVxuXHRzZXQgbmVlZHNVcGRhdGUodmFsdWUpIHtcblx0XHRpZiAodmFsdWUgPT09IHRydWUpIHRoaXMudmVyc2lvbisrO1xuXHR9XG5cdHNldEJ1ZmZlcihidWZmZXIpIHtcblx0XHR0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRzZXRUeXBlKHR5cGUsIGVsZW1lbnRTaXplKSB7XG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblx0XHR0aGlzLmVsZW1lbnRTaXplID0gZWxlbWVudFNpemU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0c2V0SXRlbVNpemUoaXRlbVNpemUpIHtcblx0XHR0aGlzLml0ZW1TaXplID0gaXRlbVNpemU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0c2V0Q291bnQoY291bnQpIHtcblx0XHR0aGlzLmNvdW50ID0gY291bnQ7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn1cblxuY2xhc3MgUmF5Y2FzdGVyIHtcblx0Y29uc3RydWN0b3Iob3JpZ2luLCBkaXJlY3Rpb24sIG5lYXIgPSAwLCBmYXIgPSBJbmZpbml0eSkge1xuXHRcdHRoaXMucmF5ID0gbmV3IFJheShvcmlnaW4sIGRpcmVjdGlvbik7XG5cdFx0Ly8gZGlyZWN0aW9uIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZCAoZm9yIGFjY3VyYXRlIGRpc3RhbmNlIGNhbGN1bGF0aW9ucylcblxuXHRcdHRoaXMubmVhciA9IG5lYXI7XG5cdFx0dGhpcy5mYXIgPSBmYXI7XG5cdFx0dGhpcy5jYW1lcmEgPSBudWxsO1xuXHRcdHRoaXMubGF5ZXJzID0gbmV3IExheWVycygpO1xuXHRcdHRoaXMucGFyYW1zID0ge1xuXHRcdFx0TWVzaDoge30sXG5cdFx0XHRMaW5lOiB7XG5cdFx0XHRcdHRocmVzaG9sZDogMVxuXHRcdFx0fSxcblx0XHRcdExPRDoge30sXG5cdFx0XHRQb2ludHM6IHtcblx0XHRcdFx0dGhyZXNob2xkOiAxXG5cdFx0XHR9LFxuXHRcdFx0U3ByaXRlOiB7fVxuXHRcdH07XG5cdH1cblx0c2V0KG9yaWdpbiwgZGlyZWN0aW9uKSB7XG5cdFx0Ly8gZGlyZWN0aW9uIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZCAoZm9yIGFjY3VyYXRlIGRpc3RhbmNlIGNhbGN1bGF0aW9ucylcblxuXHRcdHRoaXMucmF5LnNldChvcmlnaW4sIGRpcmVjdGlvbik7XG5cdH1cblx0c2V0RnJvbUNhbWVyYShjb29yZHMsIGNhbWVyYSkge1xuXHRcdGlmIChjYW1lcmEuaXNQZXJzcGVjdGl2ZUNhbWVyYSkge1xuXHRcdFx0dGhpcy5yYXkub3JpZ2luLnNldEZyb21NYXRyaXhQb3NpdGlvbihjYW1lcmEubWF0cml4V29ybGQpO1xuXHRcdFx0dGhpcy5yYXkuZGlyZWN0aW9uLnNldChjb29yZHMueCwgY29vcmRzLnksIDAuNSkudW5wcm9qZWN0KGNhbWVyYSkuc3ViKHRoaXMucmF5Lm9yaWdpbikubm9ybWFsaXplKCk7XG5cdFx0XHR0aGlzLmNhbWVyYSA9IGNhbWVyYTtcblx0XHR9IGVsc2UgaWYgKGNhbWVyYS5pc09ydGhvZ3JhcGhpY0NhbWVyYSkge1xuXHRcdFx0dGhpcy5yYXkub3JpZ2luLnNldChjb29yZHMueCwgY29vcmRzLnksIChjYW1lcmEubmVhciArIGNhbWVyYS5mYXIpIC8gKGNhbWVyYS5uZWFyIC0gY2FtZXJhLmZhcikpLnVucHJvamVjdChjYW1lcmEpOyAvLyBzZXQgb3JpZ2luIGluIHBsYW5lIG9mIGNhbWVyYVxuXHRcdFx0dGhpcy5yYXkuZGlyZWN0aW9uLnNldCgwLCAwLCAtMSkudHJhbnNmb3JtRGlyZWN0aW9uKGNhbWVyYS5tYXRyaXhXb3JsZCk7XG5cdFx0XHR0aGlzLmNhbWVyYSA9IGNhbWVyYTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuUmF5Y2FzdGVyOiBVbnN1cHBvcnRlZCBjYW1lcmEgdHlwZTogJyArIGNhbWVyYS50eXBlKTtcblx0XHR9XG5cdH1cblx0aW50ZXJzZWN0T2JqZWN0KG9iamVjdCwgcmVjdXJzaXZlID0gdHJ1ZSwgaW50ZXJzZWN0cyA9IFtdKSB7XG5cdFx0aW50ZXJzZWN0T2JqZWN0KG9iamVjdCwgdGhpcywgaW50ZXJzZWN0cywgcmVjdXJzaXZlKTtcblx0XHRpbnRlcnNlY3RzLnNvcnQoYXNjU29ydCk7XG5cdFx0cmV0dXJuIGludGVyc2VjdHM7XG5cdH1cblx0aW50ZXJzZWN0T2JqZWN0cyhvYmplY3RzLCByZWN1cnNpdmUgPSB0cnVlLCBpbnRlcnNlY3RzID0gW10pIHtcblx0XHRmb3IgKGxldCBpID0gMCwgbCA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRpbnRlcnNlY3RPYmplY3Qob2JqZWN0c1tpXSwgdGhpcywgaW50ZXJzZWN0cywgcmVjdXJzaXZlKTtcblx0XHR9XG5cdFx0aW50ZXJzZWN0cy5zb3J0KGFzY1NvcnQpO1xuXHRcdHJldHVybiBpbnRlcnNlY3RzO1xuXHR9XG59XG5mdW5jdGlvbiBhc2NTb3J0KGEsIGIpIHtcblx0cmV0dXJuIGEuZGlzdGFuY2UgLSBiLmRpc3RhbmNlO1xufVxuZnVuY3Rpb24gaW50ZXJzZWN0T2JqZWN0KG9iamVjdCwgcmF5Y2FzdGVyLCBpbnRlcnNlY3RzLCByZWN1cnNpdmUpIHtcblx0aWYgKG9iamVjdC5sYXllcnMudGVzdChyYXljYXN0ZXIubGF5ZXJzKSkge1xuXHRcdG9iamVjdC5yYXljYXN0KHJheWNhc3RlciwgaW50ZXJzZWN0cyk7XG5cdH1cblx0aWYgKHJlY3Vyc2l2ZSA9PT0gdHJ1ZSkge1xuXHRcdGNvbnN0IGNoaWxkcmVuID0gb2JqZWN0LmNoaWxkcmVuO1xuXHRcdGZvciAobGV0IGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRpbnRlcnNlY3RPYmplY3QoY2hpbGRyZW5baV0sIHJheWNhc3RlciwgaW50ZXJzZWN0cywgdHJ1ZSk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogUmVmOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TcGhlcmljYWxfY29vcmRpbmF0ZV9zeXN0ZW1cbiAqXG4gKiBUaGUgcG9sYXIgYW5nbGUgKHBoaSkgaXMgbWVhc3VyZWQgZnJvbSB0aGUgcG9zaXRpdmUgeS1heGlzLiBUaGUgcG9zaXRpdmUgeS1heGlzIGlzIHVwLlxuICogVGhlIGF6aW11dGhhbCBhbmdsZSAodGhldGEpIGlzIG1lYXN1cmVkIGZyb20gdGhlIHBvc2l0aXZlIHotYXhpcy5cbiAqL1xuY2xhc3MgU3BoZXJpY2FsIHtcblx0Y29uc3RydWN0b3IocmFkaXVzID0gMSwgcGhpID0gMCwgdGhldGEgPSAwKSB7XG5cdFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XG5cdFx0dGhpcy5waGkgPSBwaGk7IC8vIHBvbGFyIGFuZ2xlXG5cdFx0dGhpcy50aGV0YSA9IHRoZXRhOyAvLyBhemltdXRoYWwgYW5nbGVcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHNldChyYWRpdXMsIHBoaSwgdGhldGEpIHtcblx0XHR0aGlzLnJhZGl1cyA9IHJhZGl1cztcblx0XHR0aGlzLnBoaSA9IHBoaTtcblx0XHR0aGlzLnRoZXRhID0gdGhldGE7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0Y29weShvdGhlcikge1xuXHRcdHRoaXMucmFkaXVzID0gb3RoZXIucmFkaXVzO1xuXHRcdHRoaXMucGhpID0gb3RoZXIucGhpO1xuXHRcdHRoaXMudGhldGEgPSBvdGhlci50aGV0YTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8vIHJlc3RyaWN0IHBoaSB0byBiZSBiZXR3ZWVuIEVQUyBhbmQgUEktRVBTXG5cdG1ha2VTYWZlKCkge1xuXHRcdGNvbnN0IEVQUyA9IDAuMDAwMDAxO1xuXHRcdHRoaXMucGhpID0gTWF0aC5tYXgoRVBTLCBNYXRoLm1pbihNYXRoLlBJIC0gRVBTLCB0aGlzLnBoaSkpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHNldEZyb21WZWN0b3IzKHYpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tQ2FydGVzaWFuQ29vcmRzKHYueCwgdi55LCB2LnopO1xuXHR9XG5cdHNldEZyb21DYXJ0ZXNpYW5Db29yZHMoeCwgeSwgeikge1xuXHRcdHRoaXMucmFkaXVzID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeik7XG5cdFx0aWYgKHRoaXMucmFkaXVzID09PSAwKSB7XG5cdFx0XHR0aGlzLnRoZXRhID0gMDtcblx0XHRcdHRoaXMucGhpID0gMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy50aGV0YSA9IE1hdGguYXRhbjIoeCwgeik7XG5cdFx0XHR0aGlzLnBoaSA9IE1hdGguYWNvcyhjbGFtcCh5IC8gdGhpcy5yYWRpdXMsIC0xLCAxKSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGNsb25lKCkge1xuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyk7XG5cdH1cbn1cblxuLyoqXG4gKiBSZWY6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0N5bGluZHJpY2FsX2Nvb3JkaW5hdGVfc3lzdGVtXG4gKi9cblxuY2xhc3MgQ3lsaW5kcmljYWwge1xuXHRjb25zdHJ1Y3RvcihyYWRpdXMgPSAxLCB0aGV0YSA9IDAsIHkgPSAwKSB7XG5cdFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7IC8vIGRpc3RhbmNlIGZyb20gdGhlIG9yaWdpbiB0byBhIHBvaW50IGluIHRoZSB4LXogcGxhbmVcblx0XHR0aGlzLnRoZXRhID0gdGhldGE7IC8vIGNvdW50ZXJjbG9ja3dpc2UgYW5nbGUgaW4gdGhlIHgteiBwbGFuZSBtZWFzdXJlZCBpbiByYWRpYW5zIGZyb20gdGhlIHBvc2l0aXZlIHotYXhpc1xuXHRcdHRoaXMueSA9IHk7IC8vIGhlaWdodCBhYm92ZSB0aGUgeC16IHBsYW5lXG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRzZXQocmFkaXVzLCB0aGV0YSwgeSkge1xuXHRcdHRoaXMucmFkaXVzID0gcmFkaXVzO1xuXHRcdHRoaXMudGhldGEgPSB0aGV0YTtcblx0XHR0aGlzLnkgPSB5O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGNvcHkob3RoZXIpIHtcblx0XHR0aGlzLnJhZGl1cyA9IG90aGVyLnJhZGl1cztcblx0XHR0aGlzLnRoZXRhID0gb3RoZXIudGhldGE7XG5cdFx0dGhpcy55ID0gb3RoZXIueTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRzZXRGcm9tVmVjdG9yMyh2KSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0RnJvbUNhcnRlc2lhbkNvb3Jkcyh2LngsIHYueSwgdi56KTtcblx0fVxuXHRzZXRGcm9tQ2FydGVzaWFuQ29vcmRzKHgsIHksIHopIHtcblx0XHR0aGlzLnJhZGl1cyA9IE1hdGguc3FydCh4ICogeCArIHogKiB6KTtcblx0XHR0aGlzLnRoZXRhID0gTWF0aC5hdGFuMih4LCB6KTtcblx0XHR0aGlzLnkgPSB5O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGNsb25lKCkge1xuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyk7XG5cdH1cbn1cblxuY29uc3QgX3ZlY3RvciQ0ID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IyKCk7XG5jbGFzcyBCb3gyIHtcblx0Y29uc3RydWN0b3IobWluID0gbmV3IFZlY3RvcjIoK0luZmluaXR5LCArSW5maW5pdHkpLCBtYXggPSBuZXcgVmVjdG9yMigtSW5maW5pdHksIC1JbmZpbml0eSkpIHtcblx0XHR0aGlzLmlzQm94MiA9IHRydWU7XG5cdFx0dGhpcy5taW4gPSBtaW47XG5cdFx0dGhpcy5tYXggPSBtYXg7XG5cdH1cblx0c2V0KG1pbiwgbWF4KSB7XG5cdFx0dGhpcy5taW4uY29weShtaW4pO1xuXHRcdHRoaXMubWF4LmNvcHkobWF4KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRzZXRGcm9tUG9pbnRzKHBvaW50cykge1xuXHRcdHRoaXMubWFrZUVtcHR5KCk7XG5cdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdHRoaXMuZXhwYW5kQnlQb2ludChwb2ludHNbaV0pO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRzZXRGcm9tQ2VudGVyQW5kU2l6ZShjZW50ZXIsIHNpemUpIHtcblx0XHRjb25zdCBoYWxmU2l6ZSA9IF92ZWN0b3IkNC5jb3B5KHNpemUpLm11bHRpcGx5U2NhbGFyKDAuNSk7XG5cdFx0dGhpcy5taW4uY29weShjZW50ZXIpLnN1YihoYWxmU2l6ZSk7XG5cdFx0dGhpcy5tYXguY29weShjZW50ZXIpLmFkZChoYWxmU2l6ZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0Y2xvbmUoKSB7XG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKTtcblx0fVxuXHRjb3B5KGJveCkge1xuXHRcdHRoaXMubWluLmNvcHkoYm94Lm1pbik7XG5cdFx0dGhpcy5tYXguY29weShib3gubWF4KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRtYWtlRW1wdHkoKSB7XG5cdFx0dGhpcy5taW4ueCA9IHRoaXMubWluLnkgPSArSW5maW5pdHk7XG5cdFx0dGhpcy5tYXgueCA9IHRoaXMubWF4LnkgPSAtSW5maW5pdHk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0aXNFbXB0eSgpIHtcblx0XHQvLyB0aGlzIGlzIGEgbW9yZSByb2J1c3QgY2hlY2sgZm9yIGVtcHR5IHRoYW4gKCB2b2x1bWUgPD0gMCApIGJlY2F1c2Ugdm9sdW1lIGNhbiBnZXQgcG9zaXRpdmUgd2l0aCB0d28gbmVnYXRpdmUgYXhlc1xuXG5cdFx0cmV0dXJuIHRoaXMubWF4LnggPCB0aGlzLm1pbi54IHx8IHRoaXMubWF4LnkgPCB0aGlzLm1pbi55O1xuXHR9XG5cdGdldENlbnRlcih0YXJnZXQpIHtcblx0XHRyZXR1cm4gdGhpcy5pc0VtcHR5KCkgPyB0YXJnZXQuc2V0KDAsIDApIDogdGFyZ2V0LmFkZFZlY3RvcnModGhpcy5taW4sIHRoaXMubWF4KS5tdWx0aXBseVNjYWxhcigwLjUpO1xuXHR9XG5cdGdldFNpemUodGFyZ2V0KSB7XG5cdFx0cmV0dXJuIHRoaXMuaXNFbXB0eSgpID8gdGFyZ2V0LnNldCgwLCAwKSA6IHRhcmdldC5zdWJWZWN0b3JzKHRoaXMubWF4LCB0aGlzLm1pbik7XG5cdH1cblx0ZXhwYW5kQnlQb2ludChwb2ludCkge1xuXHRcdHRoaXMubWluLm1pbihwb2ludCk7XG5cdFx0dGhpcy5tYXgubWF4KHBvaW50KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRleHBhbmRCeVZlY3Rvcih2ZWN0b3IpIHtcblx0XHR0aGlzLm1pbi5zdWIodmVjdG9yKTtcblx0XHR0aGlzLm1heC5hZGQodmVjdG9yKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRleHBhbmRCeVNjYWxhcihzY2FsYXIpIHtcblx0XHR0aGlzLm1pbi5hZGRTY2FsYXIoLXNjYWxhcik7XG5cdFx0dGhpcy5tYXguYWRkU2NhbGFyKHNjYWxhcik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0Y29udGFpbnNQb2ludChwb2ludCkge1xuXHRcdHJldHVybiBwb2ludC54IDwgdGhpcy5taW4ueCB8fCBwb2ludC54ID4gdGhpcy5tYXgueCB8fCBwb2ludC55IDwgdGhpcy5taW4ueSB8fCBwb2ludC55ID4gdGhpcy5tYXgueSA/IGZhbHNlIDogdHJ1ZTtcblx0fVxuXHRjb250YWluc0JveChib3gpIHtcblx0XHRyZXR1cm4gdGhpcy5taW4ueCA8PSBib3gubWluLnggJiYgYm94Lm1heC54IDw9IHRoaXMubWF4LnggJiYgdGhpcy5taW4ueSA8PSBib3gubWluLnkgJiYgYm94Lm1heC55IDw9IHRoaXMubWF4Lnk7XG5cdH1cblx0Z2V0UGFyYW1ldGVyKHBvaW50LCB0YXJnZXQpIHtcblx0XHQvLyBUaGlzIGNhbiBwb3RlbnRpYWxseSBoYXZlIGEgZGl2aWRlIGJ5IHplcm8gaWYgdGhlIGJveFxuXHRcdC8vIGhhcyBhIHNpemUgZGltZW5zaW9uIG9mIDAuXG5cblx0XHRyZXR1cm4gdGFyZ2V0LnNldCgocG9pbnQueCAtIHRoaXMubWluLngpIC8gKHRoaXMubWF4LnggLSB0aGlzLm1pbi54KSwgKHBvaW50LnkgLSB0aGlzLm1pbi55KSAvICh0aGlzLm1heC55IC0gdGhpcy5taW4ueSkpO1xuXHR9XG5cdGludGVyc2VjdHNCb3goYm94KSB7XG5cdFx0Ly8gdXNpbmcgNCBzcGxpdHRpbmcgcGxhbmVzIHRvIHJ1bGUgb3V0IGludGVyc2VjdGlvbnNcblxuXHRcdHJldHVybiBib3gubWF4LnggPCB0aGlzLm1pbi54IHx8IGJveC5taW4ueCA+IHRoaXMubWF4LnggfHwgYm94Lm1heC55IDwgdGhpcy5taW4ueSB8fCBib3gubWluLnkgPiB0aGlzLm1heC55ID8gZmFsc2UgOiB0cnVlO1xuXHR9XG5cdGNsYW1wUG9pbnQocG9pbnQsIHRhcmdldCkge1xuXHRcdHJldHVybiB0YXJnZXQuY29weShwb2ludCkuY2xhbXAodGhpcy5taW4sIHRoaXMubWF4KTtcblx0fVxuXHRkaXN0YW5jZVRvUG9pbnQocG9pbnQpIHtcblx0XHRjb25zdCBjbGFtcGVkUG9pbnQgPSBfdmVjdG9yJDQuY29weShwb2ludCkuY2xhbXAodGhpcy5taW4sIHRoaXMubWF4KTtcblx0XHRyZXR1cm4gY2xhbXBlZFBvaW50LnN1Yihwb2ludCkubGVuZ3RoKCk7XG5cdH1cblx0aW50ZXJzZWN0KGJveCkge1xuXHRcdHRoaXMubWluLm1heChib3gubWluKTtcblx0XHR0aGlzLm1heC5taW4oYm94Lm1heCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0dW5pb24oYm94KSB7XG5cdFx0dGhpcy5taW4ubWluKGJveC5taW4pO1xuXHRcdHRoaXMubWF4Lm1heChib3gubWF4KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHR0cmFuc2xhdGUob2Zmc2V0KSB7XG5cdFx0dGhpcy5taW4uYWRkKG9mZnNldCk7XG5cdFx0dGhpcy5tYXguYWRkKG9mZnNldCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0ZXF1YWxzKGJveCkge1xuXHRcdHJldHVybiBib3gubWluLmVxdWFscyh0aGlzLm1pbikgJiYgYm94Lm1heC5lcXVhbHModGhpcy5tYXgpO1xuXHR9XG59XG5cbmNvbnN0IF9zdGFydFAgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9zdGFydEVuZCA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuY2xhc3MgTGluZTMge1xuXHRjb25zdHJ1Y3RvcihzdGFydCA9IG5ldyBWZWN0b3IzKCksIGVuZCA9IG5ldyBWZWN0b3IzKCkpIHtcblx0XHR0aGlzLnN0YXJ0ID0gc3RhcnQ7XG5cdFx0dGhpcy5lbmQgPSBlbmQ7XG5cdH1cblx0c2V0KHN0YXJ0LCBlbmQpIHtcblx0XHR0aGlzLnN0YXJ0LmNvcHkoc3RhcnQpO1xuXHRcdHRoaXMuZW5kLmNvcHkoZW5kKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRjb3B5KGxpbmUpIHtcblx0XHR0aGlzLnN0YXJ0LmNvcHkobGluZS5zdGFydCk7XG5cdFx0dGhpcy5lbmQuY29weShsaW5lLmVuZCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0Z2V0Q2VudGVyKHRhcmdldCkge1xuXHRcdHJldHVybiB0YXJnZXQuYWRkVmVjdG9ycyh0aGlzLnN0YXJ0LCB0aGlzLmVuZCkubXVsdGlwbHlTY2FsYXIoMC41KTtcblx0fVxuXHRkZWx0YSh0YXJnZXQpIHtcblx0XHRyZXR1cm4gdGFyZ2V0LnN1YlZlY3RvcnModGhpcy5lbmQsIHRoaXMuc3RhcnQpO1xuXHR9XG5cdGRpc3RhbmNlU3EoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc3RhcnQuZGlzdGFuY2VUb1NxdWFyZWQodGhpcy5lbmQpO1xuXHR9XG5cdGRpc3RhbmNlKCkge1xuXHRcdHJldHVybiB0aGlzLnN0YXJ0LmRpc3RhbmNlVG8odGhpcy5lbmQpO1xuXHR9XG5cdGF0KHQsIHRhcmdldCkge1xuXHRcdHJldHVybiB0aGlzLmRlbHRhKHRhcmdldCkubXVsdGlwbHlTY2FsYXIodCkuYWRkKHRoaXMuc3RhcnQpO1xuXHR9XG5cdGNsb3Nlc3RQb2ludFRvUG9pbnRQYXJhbWV0ZXIocG9pbnQsIGNsYW1wVG9MaW5lKSB7XG5cdFx0X3N0YXJ0UC5zdWJWZWN0b3JzKHBvaW50LCB0aGlzLnN0YXJ0KTtcblx0XHRfc3RhcnRFbmQuc3ViVmVjdG9ycyh0aGlzLmVuZCwgdGhpcy5zdGFydCk7XG5cdFx0Y29uc3Qgc3RhcnRFbmQyID0gX3N0YXJ0RW5kLmRvdChfc3RhcnRFbmQpO1xuXHRcdGNvbnN0IHN0YXJ0RW5kX3N0YXJ0UCA9IF9zdGFydEVuZC5kb3QoX3N0YXJ0UCk7XG5cdFx0bGV0IHQgPSBzdGFydEVuZF9zdGFydFAgLyBzdGFydEVuZDI7XG5cdFx0aWYgKGNsYW1wVG9MaW5lKSB7XG5cdFx0XHR0ID0gY2xhbXAodCwgMCwgMSk7XG5cdFx0fVxuXHRcdHJldHVybiB0O1xuXHR9XG5cdGNsb3Nlc3RQb2ludFRvUG9pbnQocG9pbnQsIGNsYW1wVG9MaW5lLCB0YXJnZXQpIHtcblx0XHRjb25zdCB0ID0gdGhpcy5jbG9zZXN0UG9pbnRUb1BvaW50UGFyYW1ldGVyKHBvaW50LCBjbGFtcFRvTGluZSk7XG5cdFx0cmV0dXJuIHRoaXMuZGVsdGEodGFyZ2V0KS5tdWx0aXBseVNjYWxhcih0KS5hZGQodGhpcy5zdGFydCk7XG5cdH1cblx0YXBwbHlNYXRyaXg0KG1hdHJpeCkge1xuXHRcdHRoaXMuc3RhcnQuYXBwbHlNYXRyaXg0KG1hdHJpeCk7XG5cdFx0dGhpcy5lbmQuYXBwbHlNYXRyaXg0KG1hdHJpeCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0ZXF1YWxzKGxpbmUpIHtcblx0XHRyZXR1cm4gbGluZS5zdGFydC5lcXVhbHModGhpcy5zdGFydCkgJiYgbGluZS5lbmQuZXF1YWxzKHRoaXMuZW5kKTtcblx0fVxuXHRjbG9uZSgpIHtcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpO1xuXHR9XG59XG5cbmNvbnN0IF92ZWN0b3IkMyA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuY2xhc3MgU3BvdExpZ2h0SGVscGVyIGV4dGVuZHMgT2JqZWN0M0Qge1xuXHRjb25zdHJ1Y3RvcihsaWdodCwgY29sb3IpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMubGlnaHQgPSBsaWdodDtcblx0XHR0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cdFx0dGhpcy5tYXRyaXggPSBsaWdodC5tYXRyaXhXb3JsZDtcblx0XHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblx0XHR0aGlzLmNvbG9yID0gY29sb3I7XG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRjb25zdCBwb3NpdGlvbnMgPSBbMCwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMSwgMCwgMSwgMCwgMCwgMCwgLTEsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDEsIDAsIDAsIDAsIDAsIC0xLCAxXTtcblx0XHRmb3IgKGxldCBpID0gMCwgaiA9IDEsIGwgPSAzMjsgaSA8IGw7IGkrKywgaisrKSB7XG5cdFx0XHRjb25zdCBwMSA9IGkgLyBsICogTWF0aC5QSSAqIDI7XG5cdFx0XHRjb25zdCBwMiA9IGogLyBsICogTWF0aC5QSSAqIDI7XG5cdFx0XHRwb3NpdGlvbnMucHVzaChNYXRoLmNvcyhwMSksIE1hdGguc2luKHAxKSwgMSwgTWF0aC5jb3MocDIpLCBNYXRoLnNpbihwMiksIDEpO1xuXHRcdH1cblx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25zLCAzKSk7XG5cdFx0Y29uc3QgbWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoe1xuXHRcdFx0Zm9nOiBmYWxzZSxcblx0XHRcdHRvbmVNYXBwZWQ6IGZhbHNlXG5cdFx0fSk7XG5cdFx0dGhpcy5jb25lID0gbmV3IExpbmVTZWdtZW50cyhnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuXHRcdHRoaXMuYWRkKHRoaXMuY29uZSk7XG5cdFx0dGhpcy51cGRhdGUoKTtcblx0fVxuXHRkaXNwb3NlKCkge1xuXHRcdHRoaXMuY29uZS5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdFx0dGhpcy5jb25lLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblx0fVxuXHR1cGRhdGUoKSB7XG5cdFx0dGhpcy5saWdodC51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXHRcdGNvbnN0IGNvbmVMZW5ndGggPSB0aGlzLmxpZ2h0LmRpc3RhbmNlID8gdGhpcy5saWdodC5kaXN0YW5jZSA6IDEwMDA7XG5cdFx0Y29uc3QgY29uZVdpZHRoID0gY29uZUxlbmd0aCAqIE1hdGgudGFuKHRoaXMubGlnaHQuYW5nbGUpO1xuXHRcdHRoaXMuY29uZS5zY2FsZS5zZXQoY29uZVdpZHRoLCBjb25lV2lkdGgsIGNvbmVMZW5ndGgpO1xuXHRcdF92ZWN0b3IkMy5zZXRGcm9tTWF0cml4UG9zaXRpb24odGhpcy5saWdodC50YXJnZXQubWF0cml4V29ybGQpO1xuXHRcdHRoaXMuY29uZS5sb29rQXQoX3ZlY3RvciQzKTtcblx0XHRpZiAodGhpcy5jb2xvciAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLmNvbmUubWF0ZXJpYWwuY29sb3Iuc2V0KHRoaXMuY29sb3IpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmNvbmUubWF0ZXJpYWwuY29sb3IuY29weSh0aGlzLmxpZ2h0LmNvbG9yKTtcblx0XHR9XG5cdH1cbn1cblxuY29uc3QgX3ZlY3RvciQyID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5jb25zdCBfYm9uZU1hdHJpeCA9IC8qQF9fUFVSRV9fKi9uZXcgTWF0cml4NCgpO1xuY29uc3QgX21hdHJpeFdvcmxkSW52ID0gLypAX19QVVJFX18qL25ldyBNYXRyaXg0KCk7XG5jbGFzcyBTa2VsZXRvbkhlbHBlciBleHRlbmRzIExpbmVTZWdtZW50cyB7XG5cdGNvbnN0cnVjdG9yKG9iamVjdCkge1xuXHRcdGNvbnN0IGJvbmVzID0gZ2V0Qm9uZUxpc3Qob2JqZWN0KTtcblx0XHRjb25zdCBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdGNvbnN0IHZlcnRpY2VzID0gW107XG5cdFx0Y29uc3QgY29sb3JzID0gW107XG5cdFx0Y29uc3QgY29sb3IxID0gbmV3IENvbG9yKDAsIDAsIDEpO1xuXHRcdGNvbnN0IGNvbG9yMiA9IG5ldyBDb2xvcigwLCAxLCAwKTtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGJvbmVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBib25lID0gYm9uZXNbaV07XG5cdFx0XHRpZiAoYm9uZS5wYXJlbnQgJiYgYm9uZS5wYXJlbnQuaXNCb25lKSB7XG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goMCwgMCwgMCk7XG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goMCwgMCwgMCk7XG5cdFx0XHRcdGNvbG9ycy5wdXNoKGNvbG9yMS5yLCBjb2xvcjEuZywgY29sb3IxLmIpO1xuXHRcdFx0XHRjb2xvcnMucHVzaChjb2xvcjIuciwgY29sb3IyLmcsIGNvbG9yMi5iKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHZlcnRpY2VzLCAzKSk7XG5cdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCdjb2xvcicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKGNvbG9ycywgMykpO1xuXHRcdGNvbnN0IG1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKHtcblx0XHRcdHZlcnRleENvbG9yczogdHJ1ZSxcblx0XHRcdGRlcHRoVGVzdDogZmFsc2UsXG5cdFx0XHRkZXB0aFdyaXRlOiBmYWxzZSxcblx0XHRcdHRvbmVNYXBwZWQ6IGZhbHNlLFxuXHRcdFx0dHJhbnNwYXJlbnQ6IHRydWVcblx0XHR9KTtcblx0XHRzdXBlcihnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuXHRcdHRoaXMuaXNTa2VsZXRvbkhlbHBlciA9IHRydWU7XG5cdFx0dGhpcy50eXBlID0gJ1NrZWxldG9uSGVscGVyJztcblx0XHR0aGlzLnJvb3QgPSBvYmplY3Q7XG5cdFx0dGhpcy5ib25lcyA9IGJvbmVzO1xuXHRcdHRoaXMubWF0cml4ID0gb2JqZWN0Lm1hdHJpeFdvcmxkO1xuXHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXHR9XG5cdHVwZGF0ZU1hdHJpeFdvcmxkKGZvcmNlKSB7XG5cdFx0Y29uc3QgYm9uZXMgPSB0aGlzLmJvbmVzO1xuXHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblx0XHRjb25zdCBwb3NpdGlvbiA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZSgncG9zaXRpb24nKTtcblx0XHRfbWF0cml4V29ybGRJbnYuY29weSh0aGlzLnJvb3QubWF0cml4V29ybGQpLmludmVydCgpO1xuXHRcdGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IGJvbmVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBib25lID0gYm9uZXNbaV07XG5cdFx0XHRpZiAoYm9uZS5wYXJlbnQgJiYgYm9uZS5wYXJlbnQuaXNCb25lKSB7XG5cdFx0XHRcdF9ib25lTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoX21hdHJpeFdvcmxkSW52LCBib25lLm1hdHJpeFdvcmxkKTtcblx0XHRcdFx0X3ZlY3RvciQyLnNldEZyb21NYXRyaXhQb3NpdGlvbihfYm9uZU1hdHJpeCk7XG5cdFx0XHRcdHBvc2l0aW9uLnNldFhZWihqLCBfdmVjdG9yJDIueCwgX3ZlY3RvciQyLnksIF92ZWN0b3IkMi56KTtcblx0XHRcdFx0X2JvbmVNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyhfbWF0cml4V29ybGRJbnYsIGJvbmUucGFyZW50Lm1hdHJpeFdvcmxkKTtcblx0XHRcdFx0X3ZlY3RvciQyLnNldEZyb21NYXRyaXhQb3NpdGlvbihfYm9uZU1hdHJpeCk7XG5cdFx0XHRcdHBvc2l0aW9uLnNldFhZWihqICsgMSwgX3ZlY3RvciQyLngsIF92ZWN0b3IkMi55LCBfdmVjdG9yJDIueik7XG5cdFx0XHRcdGogKz0gMjtcblx0XHRcdH1cblx0XHR9XG5cdFx0Z2VvbWV0cnkuZ2V0QXR0cmlidXRlKCdwb3NpdGlvbicpLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRzdXBlci51cGRhdGVNYXRyaXhXb3JsZChmb3JjZSk7XG5cdH1cblx0ZGlzcG9zZSgpIHtcblx0XHR0aGlzLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0XHR0aGlzLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblx0fVxufVxuZnVuY3Rpb24gZ2V0Qm9uZUxpc3Qob2JqZWN0KSB7XG5cdGNvbnN0IGJvbmVMaXN0ID0gW107XG5cdGlmIChvYmplY3QuaXNCb25lID09PSB0cnVlKSB7XG5cdFx0Ym9uZUxpc3QucHVzaChvYmplY3QpO1xuXHR9XG5cdGZvciAobGV0IGkgPSAwOyBpIDwgb2JqZWN0LmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0Ym9uZUxpc3QucHVzaC5hcHBseShib25lTGlzdCwgZ2V0Qm9uZUxpc3Qob2JqZWN0LmNoaWxkcmVuW2ldKSk7XG5cdH1cblx0cmV0dXJuIGJvbmVMaXN0O1xufVxuXG5jbGFzcyBQb2ludExpZ2h0SGVscGVyIGV4dGVuZHMgTWVzaCB7XG5cdGNvbnN0cnVjdG9yKGxpZ2h0LCBzcGhlcmVTaXplLCBjb2xvcikge1xuXHRcdGNvbnN0IGdlb21ldHJ5ID0gbmV3IFNwaGVyZUdlb21ldHJ5KHNwaGVyZVNpemUsIDQsIDIpO1xuXHRcdGNvbnN0IG1hdGVyaWFsID0gbmV3IE1lc2hCYXNpY01hdGVyaWFsKHtcblx0XHRcdHdpcmVmcmFtZTogdHJ1ZSxcblx0XHRcdGZvZzogZmFsc2UsXG5cdFx0XHR0b25lTWFwcGVkOiBmYWxzZVxuXHRcdH0pO1xuXHRcdHN1cGVyKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG5cdFx0dGhpcy5saWdodCA9IGxpZ2h0O1xuXHRcdHRoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcblx0XHR0aGlzLmNvbG9yID0gY29sb3I7XG5cdFx0dGhpcy50eXBlID0gJ1BvaW50TGlnaHRIZWxwZXInO1xuXHRcdHRoaXMubWF0cml4ID0gdGhpcy5saWdodC5tYXRyaXhXb3JsZDtcblx0XHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdFx0Lypcblx0XHQvLyBUT0RPOiBkZWxldGUgdGhpcyBjb21tZW50P1xuXHRcdGNvbnN0IGRpc3RhbmNlR2VvbWV0cnkgPSBuZXcgVEhSRUUuSWNvc2FoZWRyb25HZW9tZXRyeSggMSwgMiApO1xuXHRcdGNvbnN0IGRpc3RhbmNlTWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGhleENvbG9yLCBmb2c6IGZhbHNlLCB3aXJlZnJhbWU6IHRydWUsIG9wYWNpdHk6IDAuMSwgdHJhbnNwYXJlbnQ6IHRydWUgfSApO1xuXHRcdHRoaXMubGlnaHRTcGhlcmUgPSBuZXcgVEhSRUUuTWVzaCggYnVsYkdlb21ldHJ5LCBidWxiTWF0ZXJpYWwgKTtcblx0XHR0aGlzLmxpZ2h0RGlzdGFuY2UgPSBuZXcgVEhSRUUuTWVzaCggZGlzdGFuY2VHZW9tZXRyeSwgZGlzdGFuY2VNYXRlcmlhbCApO1xuXHRcdGNvbnN0IGQgPSBsaWdodC5kaXN0YW5jZTtcblx0XHRpZiAoIGQgPT09IDAuMCApIHtcblx0XHRcdHRoaXMubGlnaHREaXN0YW5jZS52aXNpYmxlID0gZmFsc2U7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMubGlnaHREaXN0YW5jZS5zY2FsZS5zZXQoIGQsIGQsIGQgKTtcblx0XHR9XG5cdFx0dGhpcy5hZGQoIHRoaXMubGlnaHREaXN0YW5jZSApO1xuXHRcdCovXG5cdH1cblxuXHRkaXNwb3NlKCkge1xuXHRcdHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuXHRcdHRoaXMubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXHR9XG5cdHVwZGF0ZSgpIHtcblx0XHRpZiAodGhpcy5jb2xvciAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLm1hdGVyaWFsLmNvbG9yLnNldCh0aGlzLmNvbG9yKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5tYXRlcmlhbC5jb2xvci5jb3B5KHRoaXMubGlnaHQuY29sb3IpO1xuXHRcdH1cblxuXHRcdC8qXG5cdFx0Y29uc3QgZCA9IHRoaXMubGlnaHQuZGlzdGFuY2U7XG5cdFx0XHRpZiAoIGQgPT09IDAuMCApIHtcblx0XHRcdFx0dGhpcy5saWdodERpc3RhbmNlLnZpc2libGUgPSBmYWxzZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMubGlnaHREaXN0YW5jZS52aXNpYmxlID0gdHJ1ZTtcblx0XHRcdHRoaXMubGlnaHREaXN0YW5jZS5zY2FsZS5zZXQoIGQsIGQsIGQgKTtcblx0XHRcdH1cblx0XHQqL1xuXHR9XG59XG5cbmNvbnN0IF92ZWN0b3IkMSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuY29uc3QgX2NvbG9yMSA9IC8qQF9fUFVSRV9fKi9uZXcgQ29sb3IoKTtcbmNvbnN0IF9jb2xvcjIgPSAvKkBfX1BVUkVfXyovbmV3IENvbG9yKCk7XG5jbGFzcyBIZW1pc3BoZXJlTGlnaHRIZWxwZXIgZXh0ZW5kcyBPYmplY3QzRCB7XG5cdGNvbnN0cnVjdG9yKGxpZ2h0LCBzaXplLCBjb2xvcikge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5saWdodCA9IGxpZ2h0O1xuXHRcdHRoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcblx0XHR0aGlzLm1hdHJpeCA9IGxpZ2h0Lm1hdHJpeFdvcmxkO1xuXHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXHRcdHRoaXMuY29sb3IgPSBjb2xvcjtcblx0XHRjb25zdCBnZW9tZXRyeSA9IG5ldyBPY3RhaGVkcm9uR2VvbWV0cnkoc2l6ZSk7XG5cdFx0Z2VvbWV0cnkucm90YXRlWShNYXRoLlBJICogMC41KTtcblx0XHR0aGlzLm1hdGVyaWFsID0gbmV3IE1lc2hCYXNpY01hdGVyaWFsKHtcblx0XHRcdHdpcmVmcmFtZTogdHJ1ZSxcblx0XHRcdGZvZzogZmFsc2UsXG5cdFx0XHR0b25lTWFwcGVkOiBmYWxzZVxuXHRcdH0pO1xuXHRcdGlmICh0aGlzLmNvbG9yID09PSB1bmRlZmluZWQpIHRoaXMubWF0ZXJpYWwudmVydGV4Q29sb3JzID0gdHJ1ZTtcblx0XHRjb25zdCBwb3NpdGlvbiA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZSgncG9zaXRpb24nKTtcblx0XHRjb25zdCBjb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KHBvc2l0aW9uLmNvdW50ICogMyk7XG5cdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCdjb2xvcicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoY29sb3JzLCAzKSk7XG5cdFx0dGhpcy5hZGQobmV3IE1lc2goZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwpKTtcblx0XHR0aGlzLnVwZGF0ZSgpO1xuXHR9XG5cdGRpc3Bvc2UoKSB7XG5cdFx0dGhpcy5jaGlsZHJlblswXS5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdFx0dGhpcy5jaGlsZHJlblswXS5tYXRlcmlhbC5kaXNwb3NlKCk7XG5cdH1cblx0dXBkYXRlKCkge1xuXHRcdGNvbnN0IG1lc2ggPSB0aGlzLmNoaWxkcmVuWzBdO1xuXHRcdGlmICh0aGlzLmNvbG9yICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMubWF0ZXJpYWwuY29sb3Iuc2V0KHRoaXMuY29sb3IpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCBjb2xvcnMgPSBtZXNoLmdlb21ldHJ5LmdldEF0dHJpYnV0ZSgnY29sb3InKTtcblx0XHRcdF9jb2xvcjEuY29weSh0aGlzLmxpZ2h0LmNvbG9yKTtcblx0XHRcdF9jb2xvcjIuY29weSh0aGlzLmxpZ2h0Lmdyb3VuZENvbG9yKTtcblx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gY29sb3JzLmNvdW50OyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGNvbG9yID0gaSA8IGwgLyAyID8gX2NvbG9yMSA6IF9jb2xvcjI7XG5cdFx0XHRcdGNvbG9ycy5zZXRYWVooaSwgY29sb3IuciwgY29sb3IuZywgY29sb3IuYik7XG5cdFx0XHR9XG5cdFx0XHRjb2xvcnMubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdH1cblx0XHRtZXNoLmxvb2tBdChfdmVjdG9yJDEuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHRoaXMubGlnaHQubWF0cml4V29ybGQpLm5lZ2F0ZSgpKTtcblx0fVxufVxuXG5jbGFzcyBHcmlkSGVscGVyIGV4dGVuZHMgTGluZVNlZ21lbnRzIHtcblx0Y29uc3RydWN0b3Ioc2l6ZSA9IDEwLCBkaXZpc2lvbnMgPSAxMCwgY29sb3IxID0gMHg0NDQ0NDQsIGNvbG9yMiA9IDB4ODg4ODg4KSB7XG5cdFx0Y29sb3IxID0gbmV3IENvbG9yKGNvbG9yMSk7XG5cdFx0Y29sb3IyID0gbmV3IENvbG9yKGNvbG9yMik7XG5cdFx0Y29uc3QgY2VudGVyID0gZGl2aXNpb25zIC8gMjtcblx0XHRjb25zdCBzdGVwID0gc2l6ZSAvIGRpdmlzaW9ucztcblx0XHRjb25zdCBoYWxmU2l6ZSA9IHNpemUgLyAyO1xuXHRcdGNvbnN0IHZlcnRpY2VzID0gW10sXG5cdFx0XHRjb2xvcnMgPSBbXTtcblx0XHRmb3IgKGxldCBpID0gMCwgaiA9IDAsIGsgPSAtaGFsZlNpemU7IGkgPD0gZGl2aXNpb25zOyBpKyssIGsgKz0gc3RlcCkge1xuXHRcdFx0dmVydGljZXMucHVzaCgtaGFsZlNpemUsIDAsIGssIGhhbGZTaXplLCAwLCBrKTtcblx0XHRcdHZlcnRpY2VzLnB1c2goaywgMCwgLWhhbGZTaXplLCBrLCAwLCBoYWxmU2l6ZSk7XG5cdFx0XHRjb25zdCBjb2xvciA9IGkgPT09IGNlbnRlciA/IGNvbG9yMSA6IGNvbG9yMjtcblx0XHRcdGNvbG9yLnRvQXJyYXkoY29sb3JzLCBqKTtcblx0XHRcdGogKz0gMztcblx0XHRcdGNvbG9yLnRvQXJyYXkoY29sb3JzLCBqKTtcblx0XHRcdGogKz0gMztcblx0XHRcdGNvbG9yLnRvQXJyYXkoY29sb3JzLCBqKTtcblx0XHRcdGogKz0gMztcblx0XHRcdGNvbG9yLnRvQXJyYXkoY29sb3JzLCBqKTtcblx0XHRcdGogKz0gMztcblx0XHR9XG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodmVydGljZXMsIDMpKTtcblx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2NvbG9yJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoY29sb3JzLCAzKSk7XG5cdFx0Y29uc3QgbWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoe1xuXHRcdFx0dmVydGV4Q29sb3JzOiB0cnVlLFxuXHRcdFx0dG9uZU1hcHBlZDogZmFsc2Vcblx0XHR9KTtcblx0XHRzdXBlcihnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuXHRcdHRoaXMudHlwZSA9ICdHcmlkSGVscGVyJztcblx0fVxuXHRkaXNwb3NlKCkge1xuXHRcdHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuXHRcdHRoaXMubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXHR9XG59XG5cbmNsYXNzIFBvbGFyR3JpZEhlbHBlciBleHRlbmRzIExpbmVTZWdtZW50cyB7XG5cdGNvbnN0cnVjdG9yKHJhZGl1cyA9IDEwLCBzZWN0b3JzID0gMTYsIHJpbmdzID0gOCwgZGl2aXNpb25zID0gNjQsIGNvbG9yMSA9IDB4NDQ0NDQ0LCBjb2xvcjIgPSAweDg4ODg4OCkge1xuXHRcdGNvbG9yMSA9IG5ldyBDb2xvcihjb2xvcjEpO1xuXHRcdGNvbG9yMiA9IG5ldyBDb2xvcihjb2xvcjIpO1xuXHRcdGNvbnN0IHZlcnRpY2VzID0gW107XG5cdFx0Y29uc3QgY29sb3JzID0gW107XG5cblx0XHQvLyBjcmVhdGUgdGhlIHNlY3RvcnNcblxuXHRcdGlmIChzZWN0b3JzID4gMSkge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzZWN0b3JzOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgdiA9IGkgLyBzZWN0b3JzICogKE1hdGguUEkgKiAyKTtcblx0XHRcdFx0Y29uc3QgeCA9IE1hdGguc2luKHYpICogcmFkaXVzO1xuXHRcdFx0XHRjb25zdCB6ID0gTWF0aC5jb3ModikgKiByYWRpdXM7XG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goMCwgMCwgMCk7XG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goeCwgMCwgeik7XG5cdFx0XHRcdGNvbnN0IGNvbG9yID0gaSAmIDEgPyBjb2xvcjEgOiBjb2xvcjI7XG5cdFx0XHRcdGNvbG9ycy5wdXNoKGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIpO1xuXHRcdFx0XHRjb2xvcnMucHVzaChjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBjcmVhdGUgdGhlIHJpbmdzXG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHJpbmdzOyBpKyspIHtcblx0XHRcdGNvbnN0IGNvbG9yID0gaSAmIDEgPyBjb2xvcjEgOiBjb2xvcjI7XG5cdFx0XHRjb25zdCByID0gcmFkaXVzIC0gcmFkaXVzIC8gcmluZ3MgKiBpO1xuXHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBkaXZpc2lvbnM7IGorKykge1xuXHRcdFx0XHQvLyBmaXJzdCB2ZXJ0ZXhcblxuXHRcdFx0XHRsZXQgdiA9IGogLyBkaXZpc2lvbnMgKiAoTWF0aC5QSSAqIDIpO1xuXHRcdFx0XHRsZXQgeCA9IE1hdGguc2luKHYpICogcjtcblx0XHRcdFx0bGV0IHogPSBNYXRoLmNvcyh2KSAqIHI7XG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goeCwgMCwgeik7XG5cdFx0XHRcdGNvbG9ycy5wdXNoKGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIpO1xuXG5cdFx0XHRcdC8vIHNlY29uZCB2ZXJ0ZXhcblxuXHRcdFx0XHR2ID0gKGogKyAxKSAvIGRpdmlzaW9ucyAqIChNYXRoLlBJICogMik7XG5cdFx0XHRcdHggPSBNYXRoLnNpbih2KSAqIHI7XG5cdFx0XHRcdHogPSBNYXRoLmNvcyh2KSAqIHI7XG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goeCwgMCwgeik7XG5cdFx0XHRcdGNvbG9ycy5wdXNoKGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRjb25zdCBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh2ZXJ0aWNlcywgMykpO1xuXHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnY29sb3InLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShjb2xvcnMsIDMpKTtcblx0XHRjb25zdCBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCh7XG5cdFx0XHR2ZXJ0ZXhDb2xvcnM6IHRydWUsXG5cdFx0XHR0b25lTWFwcGVkOiBmYWxzZVxuXHRcdH0pO1xuXHRcdHN1cGVyKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG5cdFx0dGhpcy50eXBlID0gJ1BvbGFyR3JpZEhlbHBlcic7XG5cdH1cblx0ZGlzcG9zZSgpIHtcblx0XHR0aGlzLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0XHR0aGlzLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblx0fVxufVxuXG5jb25zdCBfdjEgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF92MiA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuY29uc3QgX3YzID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5jbGFzcyBEaXJlY3Rpb25hbExpZ2h0SGVscGVyIGV4dGVuZHMgT2JqZWN0M0Qge1xuXHRjb25zdHJ1Y3RvcihsaWdodCwgc2l6ZSwgY29sb3IpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMubGlnaHQgPSBsaWdodDtcblx0XHR0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cdFx0dGhpcy5tYXRyaXggPSBsaWdodC5tYXRyaXhXb3JsZDtcblx0XHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblx0XHR0aGlzLmNvbG9yID0gY29sb3I7XG5cdFx0aWYgKHNpemUgPT09IHVuZGVmaW5lZCkgc2l6ZSA9IDE7XG5cdFx0bGV0IGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKFstc2l6ZSwgc2l6ZSwgMCwgc2l6ZSwgc2l6ZSwgMCwgc2l6ZSwgLXNpemUsIDAsIC1zaXplLCAtc2l6ZSwgMCwgLXNpemUsIHNpemUsIDBdLCAzKSk7XG5cdFx0Y29uc3QgbWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoe1xuXHRcdFx0Zm9nOiBmYWxzZSxcblx0XHRcdHRvbmVNYXBwZWQ6IGZhbHNlXG5cdFx0fSk7XG5cdFx0dGhpcy5saWdodFBsYW5lID0gbmV3IExpbmUoZ2VvbWV0cnksIG1hdGVyaWFsKTtcblx0XHR0aGlzLmFkZCh0aGlzLmxpZ2h0UGxhbmUpO1xuXHRcdGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKFswLCAwLCAwLCAwLCAwLCAxXSwgMykpO1xuXHRcdHRoaXMudGFyZ2V0TGluZSA9IG5ldyBMaW5lKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG5cdFx0dGhpcy5hZGQodGhpcy50YXJnZXRMaW5lKTtcblx0XHR0aGlzLnVwZGF0ZSgpO1xuXHR9XG5cdGRpc3Bvc2UoKSB7XG5cdFx0dGhpcy5saWdodFBsYW5lLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0XHR0aGlzLmxpZ2h0UGxhbmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXHRcdHRoaXMudGFyZ2V0TGluZS5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdFx0dGhpcy50YXJnZXRMaW5lLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblx0fVxuXHR1cGRhdGUoKSB7XG5cdFx0X3YxLnNldEZyb21NYXRyaXhQb3NpdGlvbih0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkKTtcblx0XHRfdjIuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHRoaXMubGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkKTtcblx0XHRfdjMuc3ViVmVjdG9ycyhfdjIsIF92MSk7XG5cdFx0dGhpcy5saWdodFBsYW5lLmxvb2tBdChfdjIpO1xuXHRcdGlmICh0aGlzLmNvbG9yICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMubGlnaHRQbGFuZS5tYXRlcmlhbC5jb2xvci5zZXQodGhpcy5jb2xvcik7XG5cdFx0XHR0aGlzLnRhcmdldExpbmUubWF0ZXJpYWwuY29sb3Iuc2V0KHRoaXMuY29sb3IpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmxpZ2h0UGxhbmUubWF0ZXJpYWwuY29sb3IuY29weSh0aGlzLmxpZ2h0LmNvbG9yKTtcblx0XHRcdHRoaXMudGFyZ2V0TGluZS5tYXRlcmlhbC5jb2xvci5jb3B5KHRoaXMubGlnaHQuY29sb3IpO1xuXHRcdH1cblx0XHR0aGlzLnRhcmdldExpbmUubG9va0F0KF92Mik7XG5cdFx0dGhpcy50YXJnZXRMaW5lLnNjYWxlLnogPSBfdjMubGVuZ3RoKCk7XG5cdH1cbn1cblxuY29uc3QgX3ZlY3RvciA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuY29uc3QgX2NhbWVyYSA9IC8qQF9fUFVSRV9fKi9uZXcgQ2FtZXJhKCk7XG5cbi8qKlxuICpcdC0gc2hvd3MgZnJ1c3R1bSwgbGluZSBvZiBzaWdodCBhbmQgdXAgb2YgdGhlIGNhbWVyYVxuICpcdC0gc3VpdGFibGUgZm9yIGZhc3QgdXBkYXRlc1xuICogXHQtIGJhc2VkIG9uIGZydXN0dW0gdmlzdWFsaXphdGlvbiBpbiBsaWdodGdsLmpzIHNoYWRvd21hcCBleGFtcGxlXG4gKlx0XHRodHRwczovL2dpdGh1Yi5jb20vZXZhbncvbGlnaHRnbC5qcy9ibG9iL21hc3Rlci90ZXN0cy9zaGFkb3dtYXAuaHRtbFxuICovXG5cbmNsYXNzIENhbWVyYUhlbHBlciBleHRlbmRzIExpbmVTZWdtZW50cyB7XG5cdGNvbnN0cnVjdG9yKGNhbWVyYSkge1xuXHRcdGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdFx0Y29uc3QgbWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoe1xuXHRcdFx0Y29sb3I6IDB4ZmZmZmZmLFxuXHRcdFx0dmVydGV4Q29sb3JzOiB0cnVlLFxuXHRcdFx0dG9uZU1hcHBlZDogZmFsc2Vcblx0XHR9KTtcblx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXHRcdGNvbnN0IGNvbG9ycyA9IFtdO1xuXHRcdGNvbnN0IHBvaW50TWFwID0ge307XG5cblx0XHQvLyBuZWFyXG5cblx0XHRhZGRMaW5lKCduMScsICduMicpO1xuXHRcdGFkZExpbmUoJ24yJywgJ240Jyk7XG5cdFx0YWRkTGluZSgnbjQnLCAnbjMnKTtcblx0XHRhZGRMaW5lKCduMycsICduMScpO1xuXG5cdFx0Ly8gZmFyXG5cblx0XHRhZGRMaW5lKCdmMScsICdmMicpO1xuXHRcdGFkZExpbmUoJ2YyJywgJ2Y0Jyk7XG5cdFx0YWRkTGluZSgnZjQnLCAnZjMnKTtcblx0XHRhZGRMaW5lKCdmMycsICdmMScpO1xuXG5cdFx0Ly8gc2lkZXNcblxuXHRcdGFkZExpbmUoJ24xJywgJ2YxJyk7XG5cdFx0YWRkTGluZSgnbjInLCAnZjInKTtcblx0XHRhZGRMaW5lKCduMycsICdmMycpO1xuXHRcdGFkZExpbmUoJ240JywgJ2Y0Jyk7XG5cblx0XHQvLyBjb25lXG5cblx0XHRhZGRMaW5lKCdwJywgJ24xJyk7XG5cdFx0YWRkTGluZSgncCcsICduMicpO1xuXHRcdGFkZExpbmUoJ3AnLCAnbjMnKTtcblx0XHRhZGRMaW5lKCdwJywgJ240Jyk7XG5cblx0XHQvLyB1cFxuXG5cdFx0YWRkTGluZSgndTEnLCAndTInKTtcblx0XHRhZGRMaW5lKCd1MicsICd1MycpO1xuXHRcdGFkZExpbmUoJ3UzJywgJ3UxJyk7XG5cblx0XHQvLyB0YXJnZXRcblxuXHRcdGFkZExpbmUoJ2MnLCAndCcpO1xuXHRcdGFkZExpbmUoJ3AnLCAnYycpO1xuXG5cdFx0Ly8gY3Jvc3NcblxuXHRcdGFkZExpbmUoJ2NuMScsICdjbjInKTtcblx0XHRhZGRMaW5lKCdjbjMnLCAnY240Jyk7XG5cdFx0YWRkTGluZSgnY2YxJywgJ2NmMicpO1xuXHRcdGFkZExpbmUoJ2NmMycsICdjZjQnKTtcblx0XHRmdW5jdGlvbiBhZGRMaW5lKGEsIGIpIHtcblx0XHRcdGFkZFBvaW50KGEpO1xuXHRcdFx0YWRkUG9pbnQoYik7XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIGFkZFBvaW50KGlkKSB7XG5cdFx0XHR2ZXJ0aWNlcy5wdXNoKDAsIDAsIDApO1xuXHRcdFx0Y29sb3JzLnB1c2goMCwgMCwgMCk7XG5cdFx0XHRpZiAocG9pbnRNYXBbaWRdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cG9pbnRNYXBbaWRdID0gW107XG5cdFx0XHR9XG5cdFx0XHRwb2ludE1hcFtpZF0ucHVzaCh2ZXJ0aWNlcy5sZW5ndGggLyAzIC0gMSk7XG5cdFx0fVxuXHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh2ZXJ0aWNlcywgMykpO1xuXHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnY29sb3InLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShjb2xvcnMsIDMpKTtcblx0XHRzdXBlcihnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuXHRcdHRoaXMudHlwZSA9ICdDYW1lcmFIZWxwZXInO1xuXHRcdHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuXHRcdGlmICh0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KSB0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cdFx0dGhpcy5tYXRyaXggPSBjYW1lcmEubWF0cml4V29ybGQ7XG5cdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cdFx0dGhpcy5wb2ludE1hcCA9IHBvaW50TWFwO1xuXHRcdHRoaXMudXBkYXRlKCk7XG5cblx0XHQvLyBjb2xvcnNcblxuXHRcdGNvbnN0IGNvbG9yRnJ1c3R1bSA9IG5ldyBDb2xvcigweGZmYWEwMCk7XG5cdFx0Y29uc3QgY29sb3JDb25lID0gbmV3IENvbG9yKDB4ZmYwMDAwKTtcblx0XHRjb25zdCBjb2xvclVwID0gbmV3IENvbG9yKDB4MDBhYWZmKTtcblx0XHRjb25zdCBjb2xvclRhcmdldCA9IG5ldyBDb2xvcigweGZmZmZmZik7XG5cdFx0Y29uc3QgY29sb3JDcm9zcyA9IG5ldyBDb2xvcigweDMzMzMzMyk7XG5cdFx0dGhpcy5zZXRDb2xvcnMoY29sb3JGcnVzdHVtLCBjb2xvckNvbmUsIGNvbG9yVXAsIGNvbG9yVGFyZ2V0LCBjb2xvckNyb3NzKTtcblx0fVxuXHRzZXRDb2xvcnMoZnJ1c3R1bSwgY29uZSwgdXAsIHRhcmdldCwgY3Jvc3MpIHtcblx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cdFx0Y29uc3QgY29sb3JBdHRyaWJ1dGUgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoJ2NvbG9yJyk7XG5cblx0XHQvLyBuZWFyXG5cblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooMCwgZnJ1c3R1bS5yLCBmcnVzdHVtLmcsIGZydXN0dW0uYik7XG5cdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKDEsIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIpOyAvLyBuMSwgbjJcblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooMiwgZnJ1c3R1bS5yLCBmcnVzdHVtLmcsIGZydXN0dW0uYik7XG5cdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKDMsIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIpOyAvLyBuMiwgbjRcblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooNCwgZnJ1c3R1bS5yLCBmcnVzdHVtLmcsIGZydXN0dW0uYik7XG5cdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKDUsIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIpOyAvLyBuNCwgbjNcblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooNiwgZnJ1c3R1bS5yLCBmcnVzdHVtLmcsIGZydXN0dW0uYik7XG5cdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKDcsIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIpOyAvLyBuMywgbjFcblxuXHRcdC8vIGZhclxuXG5cdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKDgsIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIpO1xuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWig5LCBmcnVzdHVtLnIsIGZydXN0dW0uZywgZnJ1c3R1bS5iKTsgLy8gZjEsIGYyXG5cdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKDEwLCBmcnVzdHVtLnIsIGZydXN0dW0uZywgZnJ1c3R1bS5iKTtcblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooMTEsIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIpOyAvLyBmMiwgZjRcblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooMTIsIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIpO1xuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWigxMywgZnJ1c3R1bS5yLCBmcnVzdHVtLmcsIGZydXN0dW0uYik7IC8vIGY0LCBmM1xuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWigxNCwgZnJ1c3R1bS5yLCBmcnVzdHVtLmcsIGZydXN0dW0uYik7XG5cdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKDE1LCBmcnVzdHVtLnIsIGZydXN0dW0uZywgZnJ1c3R1bS5iKTsgLy8gZjMsIGYxXG5cblx0XHQvLyBzaWRlc1xuXG5cdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKDE2LCBmcnVzdHVtLnIsIGZydXN0dW0uZywgZnJ1c3R1bS5iKTtcblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooMTcsIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIpOyAvLyBuMSwgZjFcblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooMTgsIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIpO1xuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWigxOSwgZnJ1c3R1bS5yLCBmcnVzdHVtLmcsIGZydXN0dW0uYik7IC8vIG4yLCBmMlxuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWigyMCwgZnJ1c3R1bS5yLCBmcnVzdHVtLmcsIGZydXN0dW0uYik7XG5cdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKDIxLCBmcnVzdHVtLnIsIGZydXN0dW0uZywgZnJ1c3R1bS5iKTsgLy8gbjMsIGYzXG5cdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKDIyLCBmcnVzdHVtLnIsIGZydXN0dW0uZywgZnJ1c3R1bS5iKTtcblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooMjMsIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIpOyAvLyBuNCwgZjRcblxuXHRcdC8vIGNvbmVcblxuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWigyNCwgY29uZS5yLCBjb25lLmcsIGNvbmUuYik7XG5cdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKDI1LCBjb25lLnIsIGNvbmUuZywgY29uZS5iKTsgLy8gcCwgbjFcblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooMjYsIGNvbmUuciwgY29uZS5nLCBjb25lLmIpO1xuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWigyNywgY29uZS5yLCBjb25lLmcsIGNvbmUuYik7IC8vIHAsIG4yXG5cdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKDI4LCBjb25lLnIsIGNvbmUuZywgY29uZS5iKTtcblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooMjksIGNvbmUuciwgY29uZS5nLCBjb25lLmIpOyAvLyBwLCBuM1xuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWigzMCwgY29uZS5yLCBjb25lLmcsIGNvbmUuYik7XG5cdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKDMxLCBjb25lLnIsIGNvbmUuZywgY29uZS5iKTsgLy8gcCwgbjRcblxuXHRcdC8vIHVwXG5cblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooMzIsIHVwLnIsIHVwLmcsIHVwLmIpO1xuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWigzMywgdXAuciwgdXAuZywgdXAuYik7IC8vIHUxLCB1MlxuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWigzNCwgdXAuciwgdXAuZywgdXAuYik7XG5cdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKDM1LCB1cC5yLCB1cC5nLCB1cC5iKTsgLy8gdTIsIHUzXG5cdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKDM2LCB1cC5yLCB1cC5nLCB1cC5iKTtcblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooMzcsIHVwLnIsIHVwLmcsIHVwLmIpOyAvLyB1MywgdTFcblxuXHRcdC8vIHRhcmdldFxuXG5cdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKDM4LCB0YXJnZXQuciwgdGFyZ2V0LmcsIHRhcmdldC5iKTtcblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooMzksIHRhcmdldC5yLCB0YXJnZXQuZywgdGFyZ2V0LmIpOyAvLyBjLCB0XG5cdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKDQwLCBjcm9zcy5yLCBjcm9zcy5nLCBjcm9zcy5iKTtcblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooNDEsIGNyb3NzLnIsIGNyb3NzLmcsIGNyb3NzLmIpOyAvLyBwLCBjXG5cblx0XHQvLyBjcm9zc1xuXG5cdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKDQyLCBjcm9zcy5yLCBjcm9zcy5nLCBjcm9zcy5iKTtcblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooNDMsIGNyb3NzLnIsIGNyb3NzLmcsIGNyb3NzLmIpOyAvLyBjbjEsIGNuMlxuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWig0NCwgY3Jvc3MuciwgY3Jvc3MuZywgY3Jvc3MuYik7XG5cdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKDQ1LCBjcm9zcy5yLCBjcm9zcy5nLCBjcm9zcy5iKTsgLy8gY24zLCBjbjRcblxuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWig0NiwgY3Jvc3MuciwgY3Jvc3MuZywgY3Jvc3MuYik7XG5cdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKDQ3LCBjcm9zcy5yLCBjcm9zcy5nLCBjcm9zcy5iKTsgLy8gY2YxLCBjZjJcblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooNDgsIGNyb3NzLnIsIGNyb3NzLmcsIGNyb3NzLmIpO1xuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWig0OSwgY3Jvc3MuciwgY3Jvc3MuZywgY3Jvc3MuYik7IC8vIGNmMywgY2Y0XG5cblx0XHRjb2xvckF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdH1cblx0dXBkYXRlKCkge1xuXHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblx0XHRjb25zdCBwb2ludE1hcCA9IHRoaXMucG9pbnRNYXA7XG5cdFx0Y29uc3QgdyA9IDEsXG5cdFx0XHRoID0gMTtcblxuXHRcdC8vIHdlIG5lZWQganVzdCBjYW1lcmEgcHJvamVjdGlvbiBtYXRyaXggaW52ZXJzZVxuXHRcdC8vIHdvcmxkIG1hdHJpeCBtdXN0IGJlIGlkZW50aXR5XG5cblx0XHRfY2FtZXJhLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlLmNvcHkodGhpcy5jYW1lcmEucHJvamVjdGlvbk1hdHJpeEludmVyc2UpO1xuXG5cdFx0Ly8gY2VudGVyIC8gdGFyZ2V0XG5cblx0XHRzZXRQb2ludCgnYycsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgMCwgMCwgLTEpO1xuXHRcdHNldFBvaW50KCd0JywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCAwLCAwLCAxKTtcblxuXHRcdC8vIG5lYXJcblxuXHRcdHNldFBvaW50KCduMScsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgLXcsIC1oLCAtMSk7XG5cdFx0c2V0UG9pbnQoJ24yJywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCB3LCAtaCwgLTEpO1xuXHRcdHNldFBvaW50KCduMycsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgLXcsIGgsIC0xKTtcblx0XHRzZXRQb2ludCgnbjQnLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIHcsIGgsIC0xKTtcblxuXHRcdC8vIGZhclxuXG5cdFx0c2V0UG9pbnQoJ2YxJywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCAtdywgLWgsIDEpO1xuXHRcdHNldFBvaW50KCdmMicsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgdywgLWgsIDEpO1xuXHRcdHNldFBvaW50KCdmMycsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgLXcsIGgsIDEpO1xuXHRcdHNldFBvaW50KCdmNCcsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgdywgaCwgMSk7XG5cblx0XHQvLyB1cFxuXG5cdFx0c2V0UG9pbnQoJ3UxJywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCB3ICogMC43LCBoICogMS4xLCAtMSk7XG5cdFx0c2V0UG9pbnQoJ3UyJywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCAtdyAqIDAuNywgaCAqIDEuMSwgLTEpO1xuXHRcdHNldFBvaW50KCd1MycsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgMCwgaCAqIDIsIC0xKTtcblxuXHRcdC8vIGNyb3NzXG5cblx0XHRzZXRQb2ludCgnY2YxJywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCAtdywgMCwgMSk7XG5cdFx0c2V0UG9pbnQoJ2NmMicsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgdywgMCwgMSk7XG5cdFx0c2V0UG9pbnQoJ2NmMycsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgMCwgLWgsIDEpO1xuXHRcdHNldFBvaW50KCdjZjQnLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIDAsIGgsIDEpO1xuXHRcdHNldFBvaW50KCdjbjEnLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIC13LCAwLCAtMSk7XG5cdFx0c2V0UG9pbnQoJ2NuMicsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgdywgMCwgLTEpO1xuXHRcdHNldFBvaW50KCdjbjMnLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIDAsIC1oLCAtMSk7XG5cdFx0c2V0UG9pbnQoJ2NuNCcsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgMCwgaCwgLTEpO1xuXHRcdGdlb21ldHJ5LmdldEF0dHJpYnV0ZSgncG9zaXRpb24nKS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdH1cblx0ZGlzcG9zZSgpIHtcblx0XHR0aGlzLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0XHR0aGlzLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblx0fVxufVxuZnVuY3Rpb24gc2V0UG9pbnQocG9pbnQsIHBvaW50TWFwLCBnZW9tZXRyeSwgY2FtZXJhLCB4LCB5LCB6KSB7XG5cdF92ZWN0b3Iuc2V0KHgsIHksIHopLnVucHJvamVjdChjYW1lcmEpO1xuXHRjb25zdCBwb2ludHMgPSBwb2ludE1hcFtwb2ludF07XG5cdGlmIChwb2ludHMgIT09IHVuZGVmaW5lZCkge1xuXHRcdGNvbnN0IHBvc2l0aW9uID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCdwb3NpdGlvbicpO1xuXHRcdGZvciAobGV0IGkgPSAwLCBsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0cG9zaXRpb24uc2V0WFlaKHBvaW50c1tpXSwgX3ZlY3Rvci54LCBfdmVjdG9yLnksIF92ZWN0b3Iueik7XG5cdFx0fVxuXHR9XG59XG5cbmNvbnN0IF9ib3ggPSAvKkBfX1BVUkVfXyovbmV3IEJveDMoKTtcbmNsYXNzIEJveEhlbHBlciBleHRlbmRzIExpbmVTZWdtZW50cyB7XG5cdGNvbnN0cnVjdG9yKG9iamVjdCwgY29sb3IgPSAweGZmZmYwMCkge1xuXHRcdGNvbnN0IGluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoWzAsIDEsIDEsIDIsIDIsIDMsIDMsIDAsIDQsIDUsIDUsIDYsIDYsIDcsIDcsIDQsIDAsIDQsIDEsIDUsIDIsIDYsIDMsIDddKTtcblx0XHRjb25zdCBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KDggKiAzKTtcblx0XHRjb25zdCBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdGdlb21ldHJ5LnNldEluZGV4KG5ldyBCdWZmZXJBdHRyaWJ1dGUoaW5kaWNlcywgMSkpO1xuXHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9ucywgMykpO1xuXHRcdHN1cGVyKGdlb21ldHJ5LCBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoe1xuXHRcdFx0Y29sb3I6IGNvbG9yLFxuXHRcdFx0dG9uZU1hcHBlZDogZmFsc2Vcblx0XHR9KSk7XG5cdFx0dGhpcy5vYmplY3QgPSBvYmplY3Q7XG5cdFx0dGhpcy50eXBlID0gJ0JveEhlbHBlcic7XG5cdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cdFx0dGhpcy51cGRhdGUoKTtcblx0fVxuXHR1cGRhdGUob2JqZWN0KSB7XG5cdFx0aWYgKG9iamVjdCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkJveEhlbHBlcjogLnVwZGF0ZSgpIGhhcyBubyBsb25nZXIgYXJndW1lbnRzLicpO1xuXHRcdH1cblx0XHRpZiAodGhpcy5vYmplY3QgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0X2JveC5zZXRGcm9tT2JqZWN0KHRoaXMub2JqZWN0KTtcblx0XHR9XG5cdFx0aWYgKF9ib3guaXNFbXB0eSgpKSByZXR1cm47XG5cdFx0Y29uc3QgbWluID0gX2JveC5taW47XG5cdFx0Y29uc3QgbWF4ID0gX2JveC5tYXg7XG5cblx0XHQvKlxuXHRcdFx0NV9fX180XG5cdFx0MS9fX18wL3xcblx0XHR8IDZfX3xfN1xuXHRcdDIvX19fMy9cblx0XHRcdDA6IG1heC54LCBtYXgueSwgbWF4Lnpcblx0XHQxOiBtaW4ueCwgbWF4LnksIG1heC56XG5cdFx0MjogbWluLngsIG1pbi55LCBtYXguelxuXHRcdDM6IG1heC54LCBtaW4ueSwgbWF4Lnpcblx0XHQ0OiBtYXgueCwgbWF4LnksIG1pbi56XG5cdFx0NTogbWluLngsIG1heC55LCBtaW4uelxuXHRcdDY6IG1pbi54LCBtaW4ueSwgbWluLnpcblx0XHQ3OiBtYXgueCwgbWluLnksIG1pbi56XG5cdFx0Ki9cblxuXHRcdGNvbnN0IHBvc2l0aW9uID0gdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdGNvbnN0IGFycmF5ID0gcG9zaXRpb24uYXJyYXk7XG5cdFx0YXJyYXlbMF0gPSBtYXgueDtcblx0XHRhcnJheVsxXSA9IG1heC55O1xuXHRcdGFycmF5WzJdID0gbWF4Lno7XG5cdFx0YXJyYXlbM10gPSBtaW4ueDtcblx0XHRhcnJheVs0XSA9IG1heC55O1xuXHRcdGFycmF5WzVdID0gbWF4Lno7XG5cdFx0YXJyYXlbNl0gPSBtaW4ueDtcblx0XHRhcnJheVs3XSA9IG1pbi55O1xuXHRcdGFycmF5WzhdID0gbWF4Lno7XG5cdFx0YXJyYXlbOV0gPSBtYXgueDtcblx0XHRhcnJheVsxMF0gPSBtaW4ueTtcblx0XHRhcnJheVsxMV0gPSBtYXguejtcblx0XHRhcnJheVsxMl0gPSBtYXgueDtcblx0XHRhcnJheVsxM10gPSBtYXgueTtcblx0XHRhcnJheVsxNF0gPSBtaW4uejtcblx0XHRhcnJheVsxNV0gPSBtaW4ueDtcblx0XHRhcnJheVsxNl0gPSBtYXgueTtcblx0XHRhcnJheVsxN10gPSBtaW4uejtcblx0XHRhcnJheVsxOF0gPSBtaW4ueDtcblx0XHRhcnJheVsxOV0gPSBtaW4ueTtcblx0XHRhcnJheVsyMF0gPSBtaW4uejtcblx0XHRhcnJheVsyMV0gPSBtYXgueDtcblx0XHRhcnJheVsyMl0gPSBtaW4ueTtcblx0XHRhcnJheVsyM10gPSBtaW4uejtcblx0XHRwb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0dGhpcy5nZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblx0fVxuXHRzZXRGcm9tT2JqZWN0KG9iamVjdCkge1xuXHRcdHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuXHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0Y29weShzb3VyY2UsIHJlY3Vyc2l2ZSkge1xuXHRcdHN1cGVyLmNvcHkoc291cmNlLCByZWN1cnNpdmUpO1xuXHRcdHRoaXMub2JqZWN0ID0gc291cmNlLm9iamVjdDtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRkaXNwb3NlKCkge1xuXHRcdHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuXHRcdHRoaXMubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXHR9XG59XG5cbmNsYXNzIEJveDNIZWxwZXIgZXh0ZW5kcyBMaW5lU2VnbWVudHMge1xuXHRjb25zdHJ1Y3Rvcihib3gsIGNvbG9yID0gMHhmZmZmMDApIHtcblx0XHRjb25zdCBpbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KFswLCAxLCAxLCAyLCAyLCAzLCAzLCAwLCA0LCA1LCA1LCA2LCA2LCA3LCA3LCA0LCAwLCA0LCAxLCA1LCAyLCA2LCAzLCA3XSk7XG5cdFx0Y29uc3QgcG9zaXRpb25zID0gWzEsIDEsIDEsIC0xLCAxLCAxLCAtMSwgLTEsIDEsIDEsIC0xLCAxLCAxLCAxLCAtMSwgLTEsIDEsIC0xLCAtMSwgLTEsIC0xLCAxLCAtMSwgLTFdO1xuXHRcdGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdFx0Z2VvbWV0cnkuc2V0SW5kZXgobmV3IEJ1ZmZlckF0dHJpYnV0ZShpbmRpY2VzLCAxKSk7XG5cdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9ucywgMykpO1xuXHRcdHN1cGVyKGdlb21ldHJ5LCBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoe1xuXHRcdFx0Y29sb3I6IGNvbG9yLFxuXHRcdFx0dG9uZU1hcHBlZDogZmFsc2Vcblx0XHR9KSk7XG5cdFx0dGhpcy5ib3ggPSBib3g7XG5cdFx0dGhpcy50eXBlID0gJ0JveDNIZWxwZXInO1xuXHRcdHRoaXMuZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cdH1cblx0dXBkYXRlTWF0cml4V29ybGQoZm9yY2UpIHtcblx0XHRjb25zdCBib3ggPSB0aGlzLmJveDtcblx0XHRpZiAoYm94LmlzRW1wdHkoKSkgcmV0dXJuO1xuXHRcdGJveC5nZXRDZW50ZXIodGhpcy5wb3NpdGlvbik7XG5cdFx0Ym94LmdldFNpemUodGhpcy5zY2FsZSk7XG5cdFx0dGhpcy5zY2FsZS5tdWx0aXBseVNjYWxhcigwLjUpO1xuXHRcdHN1cGVyLnVwZGF0ZU1hdHJpeFdvcmxkKGZvcmNlKTtcblx0fVxuXHRkaXNwb3NlKCkge1xuXHRcdHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuXHRcdHRoaXMubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXHR9XG59XG5cbmNsYXNzIFBsYW5lSGVscGVyIGV4dGVuZHMgTGluZSB7XG5cdGNvbnN0cnVjdG9yKHBsYW5lLCBzaXplID0gMSwgaGV4ID0gMHhmZmZmMDApIHtcblx0XHRjb25zdCBjb2xvciA9IGhleDtcblx0XHRjb25zdCBwb3NpdGlvbnMgPSBbMSwgLTEsIDAsIC0xLCAxLCAwLCAtMSwgLTEsIDAsIDEsIDEsIDAsIC0xLCAxLCAwLCAtMSwgLTEsIDAsIDEsIC0xLCAwLCAxLCAxLCAwXTtcblx0XHRjb25zdCBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbnMsIDMpKTtcblx0XHRnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblx0XHRzdXBlcihnZW9tZXRyeSwgbmV3IExpbmVCYXNpY01hdGVyaWFsKHtcblx0XHRcdGNvbG9yOiBjb2xvcixcblx0XHRcdHRvbmVNYXBwZWQ6IGZhbHNlXG5cdFx0fSkpO1xuXHRcdHRoaXMudHlwZSA9ICdQbGFuZUhlbHBlcic7XG5cdFx0dGhpcy5wbGFuZSA9IHBsYW5lO1xuXHRcdHRoaXMuc2l6ZSA9IHNpemU7XG5cdFx0Y29uc3QgcG9zaXRpb25zMiA9IFsxLCAxLCAwLCAtMSwgMSwgMCwgLTEsIC0xLCAwLCAxLCAxLCAwLCAtMSwgLTEsIDAsIDEsIC0xLCAwXTtcblx0XHRjb25zdCBnZW9tZXRyeTIgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRnZW9tZXRyeTIuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uczIsIDMpKTtcblx0XHRnZW9tZXRyeTIuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cdFx0dGhpcy5hZGQobmV3IE1lc2goZ2VvbWV0cnkyLCBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoe1xuXHRcdFx0Y29sb3I6IGNvbG9yLFxuXHRcdFx0b3BhY2l0eTogMC4yLFxuXHRcdFx0dHJhbnNwYXJlbnQ6IHRydWUsXG5cdFx0XHRkZXB0aFdyaXRlOiBmYWxzZSxcblx0XHRcdHRvbmVNYXBwZWQ6IGZhbHNlXG5cdFx0fSkpKTtcblx0fVxuXHR1cGRhdGVNYXRyaXhXb3JsZChmb3JjZSkge1xuXHRcdHRoaXMucG9zaXRpb24uc2V0KDAsIDAsIDApO1xuXHRcdHRoaXMuc2NhbGUuc2V0KDAuNSAqIHRoaXMuc2l6ZSwgMC41ICogdGhpcy5zaXplLCAxKTtcblx0XHR0aGlzLmxvb2tBdCh0aGlzLnBsYW5lLm5vcm1hbCk7XG5cdFx0dGhpcy50cmFuc2xhdGVaKC10aGlzLnBsYW5lLmNvbnN0YW50KTtcblx0XHRzdXBlci51cGRhdGVNYXRyaXhXb3JsZChmb3JjZSk7XG5cdH1cblx0ZGlzcG9zZSgpIHtcblx0XHR0aGlzLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0XHR0aGlzLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblx0XHR0aGlzLmNoaWxkcmVuWzBdLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0XHR0aGlzLmNoaWxkcmVuWzBdLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblx0fVxufVxuXG5jb25zdCBfYXhpcyA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xubGV0IF9saW5lR2VvbWV0cnksIF9jb25lR2VvbWV0cnk7XG5jbGFzcyBBcnJvd0hlbHBlciBleHRlbmRzIE9iamVjdDNEIHtcblx0Ly8gZGlyIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXG5cdGNvbnN0cnVjdG9yKGRpciA9IG5ldyBWZWN0b3IzKDAsIDAsIDEpLCBvcmlnaW4gPSBuZXcgVmVjdG9yMygwLCAwLCAwKSwgbGVuZ3RoID0gMSwgY29sb3IgPSAweGZmZmYwMCwgaGVhZExlbmd0aCA9IGxlbmd0aCAqIDAuMiwgaGVhZFdpZHRoID0gaGVhZExlbmd0aCAqIDAuMikge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy50eXBlID0gJ0Fycm93SGVscGVyJztcblx0XHRpZiAoX2xpbmVHZW9tZXRyeSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRfbGluZUdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdFx0XHRfbGluZUdlb21ldHJ5LnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShbMCwgMCwgMCwgMCwgMSwgMF0sIDMpKTtcblx0XHRcdF9jb25lR2VvbWV0cnkgPSBuZXcgQ3lsaW5kZXJHZW9tZXRyeSgwLCAwLjUsIDEsIDUsIDEpO1xuXHRcdFx0X2NvbmVHZW9tZXRyeS50cmFuc2xhdGUoMCwgLTAuNSwgMCk7XG5cdFx0fVxuXHRcdHRoaXMucG9zaXRpb24uY29weShvcmlnaW4pO1xuXHRcdHRoaXMubGluZSA9IG5ldyBMaW5lKF9saW5lR2VvbWV0cnksIG5ldyBMaW5lQmFzaWNNYXRlcmlhbCh7XG5cdFx0XHRjb2xvcjogY29sb3IsXG5cdFx0XHR0b25lTWFwcGVkOiBmYWxzZVxuXHRcdH0pKTtcblx0XHR0aGlzLmxpbmUubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXHRcdHRoaXMuYWRkKHRoaXMubGluZSk7XG5cdFx0dGhpcy5jb25lID0gbmV3IE1lc2goX2NvbmVHZW9tZXRyeSwgbmV3IE1lc2hCYXNpY01hdGVyaWFsKHtcblx0XHRcdGNvbG9yOiBjb2xvcixcblx0XHRcdHRvbmVNYXBwZWQ6IGZhbHNlXG5cdFx0fSkpO1xuXHRcdHRoaXMuY29uZS5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cdFx0dGhpcy5hZGQodGhpcy5jb25lKTtcblx0XHR0aGlzLnNldERpcmVjdGlvbihkaXIpO1xuXHRcdHRoaXMuc2V0TGVuZ3RoKGxlbmd0aCwgaGVhZExlbmd0aCwgaGVhZFdpZHRoKTtcblx0fVxuXHRzZXREaXJlY3Rpb24oZGlyKSB7XG5cdFx0Ly8gZGlyIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXG5cdFx0aWYgKGRpci55ID4gMC45OTk5OSkge1xuXHRcdFx0dGhpcy5xdWF0ZXJuaW9uLnNldCgwLCAwLCAwLCAxKTtcblx0XHR9IGVsc2UgaWYgKGRpci55IDwgLTAuOTk5OTkpIHtcblx0XHRcdHRoaXMucXVhdGVybmlvbi5zZXQoMSwgMCwgMCwgMCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdF9heGlzLnNldChkaXIueiwgMCwgLWRpci54KS5ub3JtYWxpemUoKTtcblx0XHRcdGNvbnN0IHJhZGlhbnMgPSBNYXRoLmFjb3MoZGlyLnkpO1xuXHRcdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoX2F4aXMsIHJhZGlhbnMpO1xuXHRcdH1cblx0fVxuXHRzZXRMZW5ndGgobGVuZ3RoLCBoZWFkTGVuZ3RoID0gbGVuZ3RoICogMC4yLCBoZWFkV2lkdGggPSBoZWFkTGVuZ3RoICogMC4yKSB7XG5cdFx0dGhpcy5saW5lLnNjYWxlLnNldCgxLCBNYXRoLm1heCgwLjAwMDEsIGxlbmd0aCAtIGhlYWRMZW5ndGgpLCAxKTsgLy8gc2VlICMxNzQ1OFxuXHRcdHRoaXMubGluZS51cGRhdGVNYXRyaXgoKTtcblx0XHR0aGlzLmNvbmUuc2NhbGUuc2V0KGhlYWRXaWR0aCwgaGVhZExlbmd0aCwgaGVhZFdpZHRoKTtcblx0XHR0aGlzLmNvbmUucG9zaXRpb24ueSA9IGxlbmd0aDtcblx0XHR0aGlzLmNvbmUudXBkYXRlTWF0cml4KCk7XG5cdH1cblx0c2V0Q29sb3IoY29sb3IpIHtcblx0XHR0aGlzLmxpbmUubWF0ZXJpYWwuY29sb3Iuc2V0KGNvbG9yKTtcblx0XHR0aGlzLmNvbmUubWF0ZXJpYWwuY29sb3Iuc2V0KGNvbG9yKTtcblx0fVxuXHRjb3B5KHNvdXJjZSkge1xuXHRcdHN1cGVyLmNvcHkoc291cmNlLCBmYWxzZSk7XG5cdFx0dGhpcy5saW5lLmNvcHkoc291cmNlLmxpbmUpO1xuXHRcdHRoaXMuY29uZS5jb3B5KHNvdXJjZS5jb25lKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRkaXNwb3NlKCkge1xuXHRcdHRoaXMubGluZS5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdFx0dGhpcy5saW5lLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblx0XHR0aGlzLmNvbmUuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuXHRcdHRoaXMuY29uZS5tYXRlcmlhbC5kaXNwb3NlKCk7XG5cdH1cbn1cblxuY2xhc3MgQXhlc0hlbHBlciBleHRlbmRzIExpbmVTZWdtZW50cyB7XG5cdGNvbnN0cnVjdG9yKHNpemUgPSAxKSB7XG5cdFx0Y29uc3QgdmVydGljZXMgPSBbMCwgMCwgMCwgc2l6ZSwgMCwgMCwgMCwgMCwgMCwgMCwgc2l6ZSwgMCwgMCwgMCwgMCwgMCwgMCwgc2l6ZV07XG5cdFx0Y29uc3QgY29sb3JzID0gWzEsIDAsIDAsIDEsIDAuNiwgMCwgMCwgMSwgMCwgMC42LCAxLCAwLCAwLCAwLCAxLCAwLCAwLjYsIDFdO1xuXHRcdGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHZlcnRpY2VzLCAzKSk7XG5cdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCdjb2xvcicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKGNvbG9ycywgMykpO1xuXHRcdGNvbnN0IG1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKHtcblx0XHRcdHZlcnRleENvbG9yczogdHJ1ZSxcblx0XHRcdHRvbmVNYXBwZWQ6IGZhbHNlXG5cdFx0fSk7XG5cdFx0c3VwZXIoZ2VvbWV0cnksIG1hdGVyaWFsKTtcblx0XHR0aGlzLnR5cGUgPSAnQXhlc0hlbHBlcic7XG5cdH1cblx0c2V0Q29sb3JzKHhBeGlzQ29sb3IsIHlBeGlzQ29sb3IsIHpBeGlzQ29sb3IpIHtcblx0XHRjb25zdCBjb2xvciA9IG5ldyBDb2xvcigpO1xuXHRcdGNvbnN0IGFycmF5ID0gdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLmNvbG9yLmFycmF5O1xuXHRcdGNvbG9yLnNldCh4QXhpc0NvbG9yKTtcblx0XHRjb2xvci50b0FycmF5KGFycmF5LCAwKTtcblx0XHRjb2xvci50b0FycmF5KGFycmF5LCAzKTtcblx0XHRjb2xvci5zZXQoeUF4aXNDb2xvcik7XG5cdFx0Y29sb3IudG9BcnJheShhcnJheSwgNik7XG5cdFx0Y29sb3IudG9BcnJheShhcnJheSwgOSk7XG5cdFx0Y29sb3Iuc2V0KHpBeGlzQ29sb3IpO1xuXHRcdGNvbG9yLnRvQXJyYXkoYXJyYXksIDEyKTtcblx0XHRjb2xvci50b0FycmF5KGFycmF5LCAxNSk7XG5cdFx0dGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLmNvbG9yLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRkaXNwb3NlKCkge1xuXHRcdHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuXHRcdHRoaXMubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXHR9XG59XG5cbmNsYXNzIFNoYXBlUGF0aCB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHRoaXMudHlwZSA9ICdTaGFwZVBhdGgnO1xuXHRcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoKTtcblx0XHR0aGlzLnN1YlBhdGhzID0gW107XG5cdFx0dGhpcy5jdXJyZW50UGF0aCA9IG51bGw7XG5cdH1cblx0bW92ZVRvKHgsIHkpIHtcblx0XHR0aGlzLmN1cnJlbnRQYXRoID0gbmV3IFBhdGgoKTtcblx0XHR0aGlzLnN1YlBhdGhzLnB1c2godGhpcy5jdXJyZW50UGF0aCk7XG5cdFx0dGhpcy5jdXJyZW50UGF0aC5tb3ZlVG8oeCwgeSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0bGluZVRvKHgsIHkpIHtcblx0XHR0aGlzLmN1cnJlbnRQYXRoLmxpbmVUbyh4LCB5KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRxdWFkcmF0aWNDdXJ2ZVRvKGFDUHgsIGFDUHksIGFYLCBhWSkge1xuXHRcdHRoaXMuY3VycmVudFBhdGgucXVhZHJhdGljQ3VydmVUbyhhQ1B4LCBhQ1B5LCBhWCwgYVkpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGJlemllckN1cnZlVG8oYUNQMXgsIGFDUDF5LCBhQ1AyeCwgYUNQMnksIGFYLCBhWSkge1xuXHRcdHRoaXMuY3VycmVudFBhdGguYmV6aWVyQ3VydmVUbyhhQ1AxeCwgYUNQMXksIGFDUDJ4LCBhQ1AyeSwgYVgsIGFZKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRzcGxpbmVUaHJ1KHB0cykge1xuXHRcdHRoaXMuY3VycmVudFBhdGguc3BsaW5lVGhydShwdHMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHRvU2hhcGVzKGlzQ0NXKSB7XG5cdFx0ZnVuY3Rpb24gdG9TaGFwZXNOb0hvbGVzKGluU3VicGF0aHMpIHtcblx0XHRcdGNvbnN0IHNoYXBlcyA9IFtdO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBpblN1YnBhdGhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRjb25zdCB0bXBQYXRoID0gaW5TdWJwYXRoc1tpXTtcblx0XHRcdFx0Y29uc3QgdG1wU2hhcGUgPSBuZXcgU2hhcGUoKTtcblx0XHRcdFx0dG1wU2hhcGUuY3VydmVzID0gdG1wUGF0aC5jdXJ2ZXM7XG5cdFx0XHRcdHNoYXBlcy5wdXNoKHRtcFNoYXBlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBzaGFwZXM7XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIGlzUG9pbnRJbnNpZGVQb2x5Z29uKGluUHQsIGluUG9seWdvbikge1xuXHRcdFx0Y29uc3QgcG9seUxlbiA9IGluUG9seWdvbi5sZW5ndGg7XG5cblx0XHRcdC8vIGluUHQgb24gcG9seWdvbiBjb250b3VyID0+IGltbWVkaWF0ZSBzdWNjZXNzXHRcdG9yXG5cdFx0XHQvLyB0b2dnbGluZyBvZiBpbnNpZGUvb3V0c2lkZSBhdCBldmVyeSBzaW5nbGUhIGludGVyc2VjdGlvbiBwb2ludCBvZiBhbiBlZGdlXG5cdFx0XHQvL1x0d2l0aCB0aGUgaG9yaXpvbnRhbCBsaW5lIHRocm91Z2ggaW5QdCwgbGVmdCBvZiBpblB0XG5cdFx0XHQvL1x0bm90IGNvdW50aW5nIGxvd2VyWSBlbmRwb2ludHMgb2YgZWRnZXMgYW5kIHdob2xlIGVkZ2VzIG9uIHRoYXQgbGluZVxuXHRcdFx0bGV0IGluc2lkZSA9IGZhbHNlO1xuXHRcdFx0Zm9yIChsZXQgcCA9IHBvbHlMZW4gLSAxLCBxID0gMDsgcSA8IHBvbHlMZW47IHAgPSBxKyspIHtcblx0XHRcdFx0bGV0IGVkZ2VMb3dQdCA9IGluUG9seWdvbltwXTtcblx0XHRcdFx0bGV0IGVkZ2VIaWdoUHQgPSBpblBvbHlnb25bcV07XG5cdFx0XHRcdGxldCBlZGdlRHggPSBlZGdlSGlnaFB0LnggLSBlZGdlTG93UHQueDtcblx0XHRcdFx0bGV0IGVkZ2VEeSA9IGVkZ2VIaWdoUHQueSAtIGVkZ2VMb3dQdC55O1xuXHRcdFx0XHRpZiAoTWF0aC5hYnMoZWRnZUR5KSA+IE51bWJlci5FUFNJTE9OKSB7XG5cdFx0XHRcdFx0Ly8gbm90IHBhcmFsbGVsXG5cdFx0XHRcdFx0aWYgKGVkZ2VEeSA8IDApIHtcblx0XHRcdFx0XHRcdGVkZ2VMb3dQdCA9IGluUG9seWdvbltxXTtcblx0XHRcdFx0XHRcdGVkZ2VEeCA9IC1lZGdlRHg7XG5cdFx0XHRcdFx0XHRlZGdlSGlnaFB0ID0gaW5Qb2x5Z29uW3BdO1xuXHRcdFx0XHRcdFx0ZWRnZUR5ID0gLWVkZ2VEeTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGluUHQueSA8IGVkZ2VMb3dQdC55IHx8IGluUHQueSA+IGVkZ2VIaWdoUHQueSkgY29udGludWU7XG5cdFx0XHRcdFx0aWYgKGluUHQueSA9PT0gZWRnZUxvd1B0LnkpIHtcblx0XHRcdFx0XHRcdGlmIChpblB0LnggPT09IGVkZ2VMb3dQdC54KSByZXR1cm4gdHJ1ZTsgLy8gaW5QdCBpcyBvbiBjb250b3VyID9cblx0XHRcdFx0XHRcdC8vIGNvbnRpbnVlO1x0XHRcdFx0Ly8gbm8gaW50ZXJzZWN0aW9uIG9yIGVkZ2VMb3dQdCA9PiBkb2Vzbid0IGNvdW50ICEhIVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb25zdCBwZXJwRWRnZSA9IGVkZ2VEeSAqIChpblB0LnggLSBlZGdlTG93UHQueCkgLSBlZGdlRHggKiAoaW5QdC55IC0gZWRnZUxvd1B0LnkpO1xuXHRcdFx0XHRcdFx0aWYgKHBlcnBFZGdlID09PSAwKSByZXR1cm4gdHJ1ZTsgLy8gaW5QdCBpcyBvbiBjb250b3VyID9cblx0XHRcdFx0XHRcdGlmIChwZXJwRWRnZSA8IDApIGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0aW5zaWRlID0gIWluc2lkZTsgLy8gdHJ1ZSBpbnRlcnNlY3Rpb24gbGVmdCBvZiBpblB0XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHBhcmFsbGVsIG9yIGNvbGxpbmVhclxuXHRcdFx0XHRcdGlmIChpblB0LnkgIT09IGVkZ2VMb3dQdC55KSBjb250aW51ZTsgLy8gcGFyYWxsZWxcblx0XHRcdFx0XHQvLyBlZGdlIGxpZXMgb24gdGhlIHNhbWUgaG9yaXpvbnRhbCBsaW5lIGFzIGluUHRcblx0XHRcdFx0XHRpZiAoZWRnZUhpZ2hQdC54IDw9IGluUHQueCAmJiBpblB0LnggPD0gZWRnZUxvd1B0LnggfHwgZWRnZUxvd1B0LnggPD0gaW5QdC54ICYmIGluUHQueCA8PSBlZGdlSGlnaFB0LngpIHJldHVybiB0cnVlOyAvLyBpblB0OiBQb2ludCBvbiBjb250b3VyICFcblx0XHRcdFx0XHQvLyBjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gaW5zaWRlO1xuXHRcdH1cblx0XHRjb25zdCBpc0Nsb2NrV2lzZSA9IFNoYXBlVXRpbHMuaXNDbG9ja1dpc2U7XG5cdFx0Y29uc3Qgc3ViUGF0aHMgPSB0aGlzLnN1YlBhdGhzO1xuXHRcdGlmIChzdWJQYXRocy5sZW5ndGggPT09IDApIHJldHVybiBbXTtcblx0XHRsZXQgc29saWQsIHRtcFBhdGgsIHRtcFNoYXBlO1xuXHRcdGNvbnN0IHNoYXBlcyA9IFtdO1xuXHRcdGlmIChzdWJQYXRocy5sZW5ndGggPT09IDEpIHtcblx0XHRcdHRtcFBhdGggPSBzdWJQYXRoc1swXTtcblx0XHRcdHRtcFNoYXBlID0gbmV3IFNoYXBlKCk7XG5cdFx0XHR0bXBTaGFwZS5jdXJ2ZXMgPSB0bXBQYXRoLmN1cnZlcztcblx0XHRcdHNoYXBlcy5wdXNoKHRtcFNoYXBlKTtcblx0XHRcdHJldHVybiBzaGFwZXM7XG5cdFx0fVxuXHRcdGxldCBob2xlc0ZpcnN0ID0gIWlzQ2xvY2tXaXNlKHN1YlBhdGhzWzBdLmdldFBvaW50cygpKTtcblx0XHRob2xlc0ZpcnN0ID0gaXNDQ1cgPyAhaG9sZXNGaXJzdCA6IGhvbGVzRmlyc3Q7XG5cblx0XHQvLyBjb25zb2xlLmxvZyhcIkhvbGVzIGZpcnN0XCIsIGhvbGVzRmlyc3QpO1xuXG5cdFx0Y29uc3QgYmV0dGVyU2hhcGVIb2xlcyA9IFtdO1xuXHRcdGNvbnN0IG5ld1NoYXBlcyA9IFtdO1xuXHRcdGxldCBuZXdTaGFwZUhvbGVzID0gW107XG5cdFx0bGV0IG1haW5JZHggPSAwO1xuXHRcdGxldCB0bXBQb2ludHM7XG5cdFx0bmV3U2hhcGVzW21haW5JZHhdID0gdW5kZWZpbmVkO1xuXHRcdG5ld1NoYXBlSG9sZXNbbWFpbklkeF0gPSBbXTtcblx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHN1YlBhdGhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dG1wUGF0aCA9IHN1YlBhdGhzW2ldO1xuXHRcdFx0dG1wUG9pbnRzID0gdG1wUGF0aC5nZXRQb2ludHMoKTtcblx0XHRcdHNvbGlkID0gaXNDbG9ja1dpc2UodG1wUG9pbnRzKTtcblx0XHRcdHNvbGlkID0gaXNDQ1cgPyAhc29saWQgOiBzb2xpZDtcblx0XHRcdGlmIChzb2xpZCkge1xuXHRcdFx0XHRpZiAoIWhvbGVzRmlyc3QgJiYgbmV3U2hhcGVzW21haW5JZHhdKSBtYWluSWR4Kys7XG5cdFx0XHRcdG5ld1NoYXBlc1ttYWluSWR4XSA9IHtcblx0XHRcdFx0XHRzOiBuZXcgU2hhcGUoKSxcblx0XHRcdFx0XHRwOiB0bXBQb2ludHNcblx0XHRcdFx0fTtcblx0XHRcdFx0bmV3U2hhcGVzW21haW5JZHhdLnMuY3VydmVzID0gdG1wUGF0aC5jdXJ2ZXM7XG5cdFx0XHRcdGlmIChob2xlc0ZpcnN0KSBtYWluSWR4Kys7XG5cdFx0XHRcdG5ld1NoYXBlSG9sZXNbbWFpbklkeF0gPSBbXTtcblxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdjdycsIGkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bmV3U2hhcGVIb2xlc1ttYWluSWR4XS5wdXNoKHtcblx0XHRcdFx0XHRoOiB0bXBQYXRoLFxuXHRcdFx0XHRcdHA6IHRtcFBvaW50c1swXVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdjY3cnLCBpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBvbmx5IEhvbGVzPyAtPiBwcm9iYWJseSBhbGwgU2hhcGVzIHdpdGggd3Jvbmcgb3JpZW50YXRpb25cblx0XHRpZiAoIW5ld1NoYXBlc1swXSkgcmV0dXJuIHRvU2hhcGVzTm9Ib2xlcyhzdWJQYXRocyk7XG5cdFx0aWYgKG5ld1NoYXBlcy5sZW5ndGggPiAxKSB7XG5cdFx0XHRsZXQgYW1iaWd1b3VzID0gZmFsc2U7XG5cdFx0XHRsZXQgdG9DaGFuZ2UgPSAwO1xuXHRcdFx0Zm9yIChsZXQgc0lkeCA9IDAsIHNMZW4gPSBuZXdTaGFwZXMubGVuZ3RoOyBzSWR4IDwgc0xlbjsgc0lkeCsrKSB7XG5cdFx0XHRcdGJldHRlclNoYXBlSG9sZXNbc0lkeF0gPSBbXTtcblx0XHRcdH1cblx0XHRcdGZvciAobGV0IHNJZHggPSAwLCBzTGVuID0gbmV3U2hhcGVzLmxlbmd0aDsgc0lkeCA8IHNMZW47IHNJZHgrKykge1xuXHRcdFx0XHRjb25zdCBzaG8gPSBuZXdTaGFwZUhvbGVzW3NJZHhdO1xuXHRcdFx0XHRmb3IgKGxldCBoSWR4ID0gMDsgaElkeCA8IHNoby5sZW5ndGg7IGhJZHgrKykge1xuXHRcdFx0XHRcdGNvbnN0IGhvID0gc2hvW2hJZHhdO1xuXHRcdFx0XHRcdGxldCBob2xlX3VuYXNzaWduZWQgPSB0cnVlO1xuXHRcdFx0XHRcdGZvciAobGV0IHMySWR4ID0gMDsgczJJZHggPCBuZXdTaGFwZXMubGVuZ3RoOyBzMklkeCsrKSB7XG5cdFx0XHRcdFx0XHRpZiAoaXNQb2ludEluc2lkZVBvbHlnb24oaG8ucCwgbmV3U2hhcGVzW3MySWR4XS5wKSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoc0lkeCAhPT0gczJJZHgpIHRvQ2hhbmdlKys7XG5cdFx0XHRcdFx0XHRcdGlmIChob2xlX3VuYXNzaWduZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRob2xlX3VuYXNzaWduZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRiZXR0ZXJTaGFwZUhvbGVzW3MySWR4XS5wdXNoKGhvKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRhbWJpZ3VvdXMgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChob2xlX3VuYXNzaWduZWQpIHtcblx0XHRcdFx0XHRcdGJldHRlclNoYXBlSG9sZXNbc0lkeF0ucHVzaChobyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAodG9DaGFuZ2UgPiAwICYmIGFtYmlndW91cyA9PT0gZmFsc2UpIHtcblx0XHRcdFx0bmV3U2hhcGVIb2xlcyA9IGJldHRlclNoYXBlSG9sZXM7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGxldCB0bXBIb2xlcztcblx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSBuZXdTaGFwZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0dG1wU2hhcGUgPSBuZXdTaGFwZXNbaV0ucztcblx0XHRcdHNoYXBlcy5wdXNoKHRtcFNoYXBlKTtcblx0XHRcdHRtcEhvbGVzID0gbmV3U2hhcGVIb2xlc1tpXTtcblx0XHRcdGZvciAobGV0IGogPSAwLCBqbCA9IHRtcEhvbGVzLmxlbmd0aDsgaiA8IGpsOyBqKyspIHtcblx0XHRcdFx0dG1wU2hhcGUuaG9sZXMucHVzaCh0bXBIb2xlc1tqXS5oKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvL2NvbnNvbGUubG9nKFwic2hhcGVcIiwgc2hhcGVzKTtcblxuXHRcdHJldHVybiBzaGFwZXM7XG5cdH1cbn1cblxuLy8gRmFzdCBIYWxmIEZsb2F0IENvbnZlcnNpb25zLCBodHRwOi8vd3d3LmZveC10b29sa2l0Lm9yZy9mdHAvZmFzdGhhbGZmbG9hdGNvbnZlcnNpb24ucGRmXG5cbmNvbnN0IF90YWJsZXMgPSAvKkBfX1BVUkVfXyovX2dlbmVyYXRlVGFibGVzKCk7XG5mdW5jdGlvbiBfZ2VuZXJhdGVUYWJsZXMoKSB7XG5cdC8vIGZsb2F0MzIgdG8gZmxvYXQxNiBoZWxwZXJzXG5cblx0Y29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDQpO1xuXHRjb25zdCBmbG9hdFZpZXcgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlcik7XG5cdGNvbnN0IHVpbnQzMlZpZXcgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyKTtcblx0Y29uc3QgYmFzZVRhYmxlID0gbmV3IFVpbnQzMkFycmF5KDUxMik7XG5cdGNvbnN0IHNoaWZ0VGFibGUgPSBuZXcgVWludDMyQXJyYXkoNTEyKTtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuXHRcdGNvbnN0IGUgPSBpIC0gMTI3O1xuXG5cdFx0Ly8gdmVyeSBzbWFsbCBudW1iZXIgKDAsIC0wKVxuXG5cdFx0aWYgKGUgPCAtMjcpIHtcblx0XHRcdGJhc2VUYWJsZVtpXSA9IDB4MDAwMDtcblx0XHRcdGJhc2VUYWJsZVtpIHwgMHgxMDBdID0gMHg4MDAwO1xuXHRcdFx0c2hpZnRUYWJsZVtpXSA9IDI0O1xuXHRcdFx0c2hpZnRUYWJsZVtpIHwgMHgxMDBdID0gMjQ7XG5cblx0XHRcdC8vIHNtYWxsIG51bWJlciAoZGVub3JtKVxuXHRcdH0gZWxzZSBpZiAoZSA8IC0xNCkge1xuXHRcdFx0YmFzZVRhYmxlW2ldID0gMHgwNDAwID4+IC1lIC0gMTQ7XG5cdFx0XHRiYXNlVGFibGVbaSB8IDB4MTAwXSA9IDB4MDQwMCA+PiAtZSAtIDE0IHwgMHg4MDAwO1xuXHRcdFx0c2hpZnRUYWJsZVtpXSA9IC1lIC0gMTtcblx0XHRcdHNoaWZ0VGFibGVbaSB8IDB4MTAwXSA9IC1lIC0gMTtcblxuXHRcdFx0Ly8gbm9ybWFsIG51bWJlclxuXHRcdH0gZWxzZSBpZiAoZSA8PSAxNSkge1xuXHRcdFx0YmFzZVRhYmxlW2ldID0gZSArIDE1IDw8IDEwO1xuXHRcdFx0YmFzZVRhYmxlW2kgfCAweDEwMF0gPSBlICsgMTUgPDwgMTAgfCAweDgwMDA7XG5cdFx0XHRzaGlmdFRhYmxlW2ldID0gMTM7XG5cdFx0XHRzaGlmdFRhYmxlW2kgfCAweDEwMF0gPSAxMztcblxuXHRcdFx0Ly8gbGFyZ2UgbnVtYmVyIChJbmZpbml0eSwgLUluZmluaXR5KVxuXHRcdH0gZWxzZSBpZiAoZSA8IDEyOCkge1xuXHRcdFx0YmFzZVRhYmxlW2ldID0gMHg3YzAwO1xuXHRcdFx0YmFzZVRhYmxlW2kgfCAweDEwMF0gPSAweGZjMDA7XG5cdFx0XHRzaGlmdFRhYmxlW2ldID0gMjQ7XG5cdFx0XHRzaGlmdFRhYmxlW2kgfCAweDEwMF0gPSAyNDtcblxuXHRcdFx0Ly8gc3RheSAoTmFOLCBJbmZpbml0eSwgLUluZmluaXR5KVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRiYXNlVGFibGVbaV0gPSAweDdjMDA7XG5cdFx0XHRiYXNlVGFibGVbaSB8IDB4MTAwXSA9IDB4ZmMwMDtcblx0XHRcdHNoaWZ0VGFibGVbaV0gPSAxMztcblx0XHRcdHNoaWZ0VGFibGVbaSB8IDB4MTAwXSA9IDEzO1xuXHRcdH1cblx0fVxuXG5cdC8vIGZsb2F0MTYgdG8gZmxvYXQzMiBoZWxwZXJzXG5cblx0Y29uc3QgbWFudGlzc2FUYWJsZSA9IG5ldyBVaW50MzJBcnJheSgyMDQ4KTtcblx0Y29uc3QgZXhwb25lbnRUYWJsZSA9IG5ldyBVaW50MzJBcnJheSg2NCk7XG5cdGNvbnN0IG9mZnNldFRhYmxlID0gbmV3IFVpbnQzMkFycmF5KDY0KTtcblx0Zm9yIChsZXQgaSA9IDE7IGkgPCAxMDI0OyArK2kpIHtcblx0XHRsZXQgbSA9IGkgPDwgMTM7IC8vIHplcm8gcGFkIG1hbnRpc3NhIGJpdHNcblx0XHRsZXQgZSA9IDA7IC8vIHplcm8gZXhwb25lbnRcblxuXHRcdC8vIG5vcm1hbGl6ZWRcblx0XHR3aGlsZSAoKG0gJiAweDAwODAwMDAwKSA9PT0gMCkge1xuXHRcdFx0bSA8PD0gMTtcblx0XHRcdGUgLT0gMHgwMDgwMDAwMDsgLy8gZGVjcmVtZW50IGV4cG9uZW50XG5cdFx0fVxuXG5cdFx0bSAmPSB+MHgwMDgwMDAwMDsgLy8gY2xlYXIgbGVhZGluZyAxIGJpdFxuXHRcdGUgKz0gMHgzODgwMDAwMDsgLy8gYWRqdXN0IGJpYXNcblxuXHRcdG1hbnRpc3NhVGFibGVbaV0gPSBtIHwgZTtcblx0fVxuXHRmb3IgKGxldCBpID0gMTAyNDsgaSA8IDIwNDg7ICsraSkge1xuXHRcdG1hbnRpc3NhVGFibGVbaV0gPSAweDM4MDAwMDAwICsgKGkgLSAxMDI0IDw8IDEzKTtcblx0fVxuXHRmb3IgKGxldCBpID0gMTsgaSA8IDMxOyArK2kpIHtcblx0XHRleHBvbmVudFRhYmxlW2ldID0gaSA8PCAyMztcblx0fVxuXHRleHBvbmVudFRhYmxlWzMxXSA9IDB4NDc4MDAwMDA7XG5cdGV4cG9uZW50VGFibGVbMzJdID0gMHg4MDAwMDAwMDtcblx0Zm9yIChsZXQgaSA9IDMzOyBpIDwgNjM7ICsraSkge1xuXHRcdGV4cG9uZW50VGFibGVbaV0gPSAweDgwMDAwMDAwICsgKGkgLSAzMiA8PCAyMyk7XG5cdH1cblx0ZXhwb25lbnRUYWJsZVs2M10gPSAweGM3ODAwMDAwO1xuXHRmb3IgKGxldCBpID0gMTsgaSA8IDY0OyArK2kpIHtcblx0XHRpZiAoaSAhPT0gMzIpIHtcblx0XHRcdG9mZnNldFRhYmxlW2ldID0gMTAyNDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHtcblx0XHRmbG9hdFZpZXc6IGZsb2F0Vmlldyxcblx0XHR1aW50MzJWaWV3OiB1aW50MzJWaWV3LFxuXHRcdGJhc2VUYWJsZTogYmFzZVRhYmxlLFxuXHRcdHNoaWZ0VGFibGU6IHNoaWZ0VGFibGUsXG5cdFx0bWFudGlzc2FUYWJsZTogbWFudGlzc2FUYWJsZSxcblx0XHRleHBvbmVudFRhYmxlOiBleHBvbmVudFRhYmxlLFxuXHRcdG9mZnNldFRhYmxlOiBvZmZzZXRUYWJsZVxuXHR9O1xufVxuXG4vLyBmbG9hdDMyIHRvIGZsb2F0MTZcblxuZnVuY3Rpb24gdG9IYWxmRmxvYXQodmFsKSB7XG5cdGlmIChNYXRoLmFicyh2YWwpID4gNjU1MDQpIGNvbnNvbGUud2FybignVEhSRUUuRGF0YVV0aWxzLnRvSGFsZkZsb2F0KCk6IFZhbHVlIG91dCBvZiByYW5nZS4nKTtcblx0dmFsID0gY2xhbXAodmFsLCAtNjU1MDQsIDY1NTA0KTtcblx0X3RhYmxlcy5mbG9hdFZpZXdbMF0gPSB2YWw7XG5cdGNvbnN0IGYgPSBfdGFibGVzLnVpbnQzMlZpZXdbMF07XG5cdGNvbnN0IGUgPSBmID4+IDIzICYgMHgxZmY7XG5cdHJldHVybiBfdGFibGVzLmJhc2VUYWJsZVtlXSArICgoZiAmIDB4MDA3ZmZmZmYpID4+IF90YWJsZXMuc2hpZnRUYWJsZVtlXSk7XG59XG5cbi8vIGZsb2F0MTYgdG8gZmxvYXQzMlxuXG5mdW5jdGlvbiBmcm9tSGFsZkZsb2F0KHZhbCkge1xuXHRjb25zdCBtID0gdmFsID4+IDEwO1xuXHRfdGFibGVzLnVpbnQzMlZpZXdbMF0gPSBfdGFibGVzLm1hbnRpc3NhVGFibGVbX3RhYmxlcy5vZmZzZXRUYWJsZVttXSArICh2YWwgJiAweDNmZildICsgX3RhYmxlcy5leHBvbmVudFRhYmxlW21dO1xuXHRyZXR1cm4gX3RhYmxlcy5mbG9hdFZpZXdbMF07XG59XG5cbnZhciBEYXRhVXRpbHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0dG9IYWxmRmxvYXQ6IHRvSGFsZkZsb2F0LFxuXHRmcm9tSGFsZkZsb2F0OiBmcm9tSGFsZkZsb2F0XG59KTtcblxuLy8gcjEzNCwgZDY1ZTBhZjA2NjQ0ZmU1YTg0YTZmYzBlMzcyZjQzMThmOTVhMDRjMFxuXG5mdW5jdGlvbiBJbW1lZGlhdGVSZW5kZXJPYmplY3QoKSB7XG5cdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLkltbWVkaWF0ZVJlbmRlck9iamVjdCBoYXMgYmVlbiByZW1vdmVkLicpO1xufVxuXG4vLyByMTM4LCA0OGIwNWQzNTAwYWNjMDg0ZGY1MGJlOWI0YzkwNzgxYWQ5YjhjYjE3XG5cbmNsYXNzIFdlYkdMTXVsdGlzYW1wbGVSZW5kZXJUYXJnZXQgZXh0ZW5kcyBXZWJHTFJlbmRlclRhcmdldCB7XG5cdGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpIHtcblx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5XZWJHTE11bHRpc2FtcGxlUmVuZGVyVGFyZ2V0IGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBhIG5vcm1hbCByZW5kZXIgdGFyZ2V0IGFuZCBzZXQgdGhlIFwic2FtcGxlc1wiIHByb3BlcnR5IHRvIGdyZWF0ZXIgMCB0byBlbmFibGUgbXVsdGlzYW1wbGluZy4nKTtcblx0XHRzdXBlcih3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKTtcblx0XHR0aGlzLnNhbXBsZXMgPSA0O1xuXHR9XG59XG5cbi8vIHIxMzgsIGY5Y2Q5Y2FiMDNiN2I2NDI0NGUzMDQ5MDBhM2EyZWVhYTNhNTg4Y2VcblxuY2xhc3MgRGF0YVRleHR1cmUyREFycmF5IGV4dGVuZHMgRGF0YUFycmF5VGV4dHVyZSB7XG5cdGNvbnN0cnVjdG9yKGRhdGEsIHdpZHRoLCBoZWlnaHQsIGRlcHRoKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5EYXRhVGV4dHVyZTJEQXJyYXkgaGFzIGJlZW4gcmVuYW1lZCB0byBEYXRhQXJyYXlUZXh0dXJlLicpO1xuXHRcdHN1cGVyKGRhdGEsIHdpZHRoLCBoZWlnaHQsIGRlcHRoKTtcblx0fVxufVxuXG4vLyByMTM4LCBmOWNkOWNhYjAzYjdiNjQyNDRlMzA0OTAwYTNhMmVlYWEzYTU4OGNlXG5cbmNsYXNzIERhdGFUZXh0dXJlM0QgZXh0ZW5kcyBEYXRhM0RUZXh0dXJlIHtcblx0Y29uc3RydWN0b3IoZGF0YSwgd2lkdGgsIGhlaWdodCwgZGVwdGgpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkRhdGFUZXh0dXJlM0QgaGFzIGJlZW4gcmVuYW1lZCB0byBEYXRhM0RUZXh0dXJlLicpO1xuXHRcdHN1cGVyKGRhdGEsIHdpZHRoLCBoZWlnaHQsIGRlcHRoKTtcblx0fVxufVxuXG4vLyByMTQ0XG5cbmNsYXNzIEJveEJ1ZmZlckdlb21ldHJ5IGV4dGVuZHMgQm94R2VvbWV0cnkge1xuXHRjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIGRlcHRoU2VnbWVudHMpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkJveEJ1ZmZlckdlb21ldHJ5IGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuQm94R2VvbWV0cnkuJyk7XG5cdFx0c3VwZXIod2lkdGgsIGhlaWdodCwgZGVwdGgsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBkZXB0aFNlZ21lbnRzKTtcblx0fVxufVxuXG4vLyByMTQ0XG5cbmNsYXNzIENhcHN1bGVCdWZmZXJHZW9tZXRyeSBleHRlbmRzIENhcHN1bGVHZW9tZXRyeSB7XG5cdGNvbnN0cnVjdG9yKHJhZGl1cywgbGVuZ3RoLCBjYXBTZWdtZW50cywgcmFkaWFsU2VnbWVudHMpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkNhcHN1bGVCdWZmZXJHZW9tZXRyeSBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLkNhcHN1bGVHZW9tZXRyeS4nKTtcblx0XHRzdXBlcihyYWRpdXMsIGxlbmd0aCwgY2FwU2VnbWVudHMsIHJhZGlhbFNlZ21lbnRzKTtcblx0fVxufVxuXG4vLyByMTQ0XG5cbmNsYXNzIENpcmNsZUJ1ZmZlckdlb21ldHJ5IGV4dGVuZHMgQ2lyY2xlR2VvbWV0cnkge1xuXHRjb25zdHJ1Y3RvcihyYWRpdXMsIHNlZ21lbnRzLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuQ2lyY2xlQnVmZmVyR2VvbWV0cnkgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5DaXJjbGVHZW9tZXRyeS4nKTtcblx0XHRzdXBlcihyYWRpdXMsIHNlZ21lbnRzLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCk7XG5cdH1cbn1cblxuLy8gcjE0NFxuXG5jbGFzcyBDb25lQnVmZmVyR2VvbWV0cnkgZXh0ZW5kcyBDb25lR2VvbWV0cnkge1xuXHRjb25zdHJ1Y3RvcihyYWRpdXMsIGhlaWdodCwgcmFkaWFsU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBvcGVuRW5kZWQsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5Db25lQnVmZmVyR2VvbWV0cnkgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Db25lR2VvbWV0cnkuJyk7XG5cdFx0c3VwZXIocmFkaXVzLCBoZWlnaHQsIHJhZGlhbFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgb3BlbkVuZGVkLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCk7XG5cdH1cbn1cblxuLy8gcjE0NFxuXG5jbGFzcyBDeWxpbmRlckJ1ZmZlckdlb21ldHJ5IGV4dGVuZHMgQ3lsaW5kZXJHZW9tZXRyeSB7XG5cdGNvbnN0cnVjdG9yKHJhZGl1c1RvcCwgcmFkaXVzQm90dG9tLCBoZWlnaHQsIHJhZGlhbFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgb3BlbkVuZGVkLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuQ3lsaW5kZXJCdWZmZXJHZW9tZXRyeSBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLkN5bGluZGVyR2VvbWV0cnkuJyk7XG5cdFx0c3VwZXIocmFkaXVzVG9wLCByYWRpdXNCb3R0b20sIGhlaWdodCwgcmFkaWFsU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBvcGVuRW5kZWQsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoKTtcblx0fVxufVxuXG4vLyByMTQ0XG5cbmNsYXNzIERvZGVjYWhlZHJvbkJ1ZmZlckdlb21ldHJ5IGV4dGVuZHMgRG9kZWNhaGVkcm9uR2VvbWV0cnkge1xuXHRjb25zdHJ1Y3RvcihyYWRpdXMsIGRldGFpbCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuRG9kZWNhaGVkcm9uQnVmZmVyR2VvbWV0cnkgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Eb2RlY2FoZWRyb25HZW9tZXRyeS4nKTtcblx0XHRzdXBlcihyYWRpdXMsIGRldGFpbCk7XG5cdH1cbn1cblxuLy8gcjE0NFxuXG5jbGFzcyBFeHRydWRlQnVmZmVyR2VvbWV0cnkgZXh0ZW5kcyBFeHRydWRlR2VvbWV0cnkge1xuXHRjb25zdHJ1Y3RvcihzaGFwZXMsIG9wdGlvbnMpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkV4dHJ1ZGVCdWZmZXJHZW9tZXRyeSBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS4nKTtcblx0XHRzdXBlcihzaGFwZXMsIG9wdGlvbnMpO1xuXHR9XG59XG5cbi8vIHIxNDRcblxuY2xhc3MgSWNvc2FoZWRyb25CdWZmZXJHZW9tZXRyeSBleHRlbmRzIEljb3NhaGVkcm9uR2VvbWV0cnkge1xuXHRjb25zdHJ1Y3RvcihyYWRpdXMsIGRldGFpbCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuSWNvc2FoZWRyb25CdWZmZXJHZW9tZXRyeSBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkuJyk7XG5cdFx0c3VwZXIocmFkaXVzLCBkZXRhaWwpO1xuXHR9XG59XG5cbi8vIHIxNDRcblxuY2xhc3MgTGF0aGVCdWZmZXJHZW9tZXRyeSBleHRlbmRzIExhdGhlR2VvbWV0cnkge1xuXHRjb25zdHJ1Y3Rvcihwb2ludHMsIHNlZ21lbnRzLCBwaGlTdGFydCwgcGhpTGVuZ3RoKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5MYXRoZUJ1ZmZlckdlb21ldHJ5IGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuTGF0aGVHZW9tZXRyeS4nKTtcblx0XHRzdXBlcihwb2ludHMsIHNlZ21lbnRzLCBwaGlTdGFydCwgcGhpTGVuZ3RoKTtcblx0fVxufVxuXG4vLyByMTQ0XG5cbmNsYXNzIE9jdGFoZWRyb25CdWZmZXJHZW9tZXRyeSBleHRlbmRzIE9jdGFoZWRyb25HZW9tZXRyeSB7XG5cdGNvbnN0cnVjdG9yKHJhZGl1cywgZGV0YWlsKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5PY3RhaGVkcm9uQnVmZmVyR2VvbWV0cnkgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5PY3RhaGVkcm9uR2VvbWV0cnkuJyk7XG5cdFx0c3VwZXIocmFkaXVzLCBkZXRhaWwpO1xuXHR9XG59XG5cbi8vIHIxNDRcblxuY2xhc3MgUGxhbmVCdWZmZXJHZW9tZXRyeSBleHRlbmRzIFBsYW5lR2VvbWV0cnkge1xuXHRjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0LCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cykge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuUGxhbmVCdWZmZXJHZW9tZXRyeSBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlBsYW5lR2VvbWV0cnkuJyk7XG5cdFx0c3VwZXIod2lkdGgsIGhlaWdodCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMpO1xuXHR9XG59XG5cbi8vIHIxNDRcblxuY2xhc3MgUG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5IGV4dGVuZHMgUG9seWhlZHJvbkdlb21ldHJ5IHtcblx0Y29uc3RydWN0b3IodmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5Qb2x5aGVkcm9uQnVmZmVyR2VvbWV0cnkgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkuJyk7XG5cdFx0c3VwZXIodmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsKTtcblx0fVxufVxuXG4vLyByMTQ0XG5cbmNsYXNzIFJpbmdCdWZmZXJHZW9tZXRyeSBleHRlbmRzIFJpbmdHZW9tZXRyeSB7XG5cdGNvbnN0cnVjdG9yKGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgdGhldGFTZWdtZW50cywgcGhpU2VnbWVudHMsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5SaW5nQnVmZmVyR2VvbWV0cnkgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5SaW5nR2VvbWV0cnkuJyk7XG5cdFx0c3VwZXIoaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCB0aGV0YVNlZ21lbnRzLCBwaGlTZWdtZW50cywgdGhldGFTdGFydCwgdGhldGFMZW5ndGgpO1xuXHR9XG59XG5cbi8vIHIxNDRcblxuY2xhc3MgU2hhcGVCdWZmZXJHZW9tZXRyeSBleHRlbmRzIFNoYXBlR2VvbWV0cnkge1xuXHRjb25zdHJ1Y3RvcihzaGFwZXMsIGN1cnZlU2VnbWVudHMpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlNoYXBlQnVmZmVyR2VvbWV0cnkgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5TaGFwZUdlb21ldHJ5LicpO1xuXHRcdHN1cGVyKHNoYXBlcywgY3VydmVTZWdtZW50cyk7XG5cdH1cbn1cblxuLy8gcjE0NFxuXG5jbGFzcyBTcGhlcmVCdWZmZXJHZW9tZXRyeSBleHRlbmRzIFNwaGVyZUdlb21ldHJ5IHtcblx0Y29uc3RydWN0b3IocmFkaXVzLCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgcGhpU3RhcnQsIHBoaUxlbmd0aCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGgpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlNwaGVyZUJ1ZmZlckdlb21ldHJ5IGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuU3BoZXJlR2VvbWV0cnkuJyk7XG5cdFx0c3VwZXIocmFkaXVzLCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgcGhpU3RhcnQsIHBoaUxlbmd0aCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGgpO1xuXHR9XG59XG5cbi8vIHIxNDRcblxuY2xhc3MgVGV0cmFoZWRyb25CdWZmZXJHZW9tZXRyeSBleHRlbmRzIFRldHJhaGVkcm9uR2VvbWV0cnkge1xuXHRjb25zdHJ1Y3RvcihyYWRpdXMsIGRldGFpbCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuVGV0cmFoZWRyb25CdWZmZXJHZW9tZXRyeSBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlRldHJhaGVkcm9uR2VvbWV0cnkuJyk7XG5cdFx0c3VwZXIocmFkaXVzLCBkZXRhaWwpO1xuXHR9XG59XG5cbi8vIHIxNDRcblxuY2xhc3MgVG9ydXNCdWZmZXJHZW9tZXRyeSBleHRlbmRzIFRvcnVzR2VvbWV0cnkge1xuXHRjb25zdHJ1Y3RvcihyYWRpdXMsIHR1YmUsIHJhZGlhbFNlZ21lbnRzLCB0dWJ1bGFyU2VnbWVudHMsIGFyYykge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuVG9ydXNCdWZmZXJHZW9tZXRyeSBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlRvcnVzR2VvbWV0cnkuJyk7XG5cdFx0c3VwZXIocmFkaXVzLCB0dWJlLCByYWRpYWxTZWdtZW50cywgdHVidWxhclNlZ21lbnRzLCBhcmMpO1xuXHR9XG59XG5cbi8vIHIxNDRcblxuY2xhc3MgVG9ydXNLbm90QnVmZmVyR2VvbWV0cnkgZXh0ZW5kcyBUb3J1c0tub3RHZW9tZXRyeSB7XG5cdGNvbnN0cnVjdG9yKHJhZGl1cywgdHViZSwgdHVidWxhclNlZ21lbnRzLCByYWRpYWxTZWdtZW50cywgcCwgcSkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuVG9ydXNLbm90QnVmZmVyR2VvbWV0cnkgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Ub3J1c0tub3RHZW9tZXRyeS4nKTtcblx0XHRzdXBlcihyYWRpdXMsIHR1YmUsIHR1YnVsYXJTZWdtZW50cywgcmFkaWFsU2VnbWVudHMsIHAsIHEpO1xuXHR9XG59XG5cbi8vIHIxNDRcblxuY2xhc3MgVHViZUJ1ZmZlckdlb21ldHJ5IGV4dGVuZHMgVHViZUdlb21ldHJ5IHtcblx0Y29uc3RydWN0b3IocGF0aCwgdHVidWxhclNlZ21lbnRzLCByYWRpdXMsIHJhZGlhbFNlZ21lbnRzLCBjbG9zZWQpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlR1YmVCdWZmZXJHZW9tZXRyeSBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlR1YmVHZW9tZXRyeS4nKTtcblx0XHRzdXBlcihwYXRoLCB0dWJ1bGFyU2VnbWVudHMsIHJhZGl1cywgcmFkaWFsU2VnbWVudHMsIGNsb3NlZCk7XG5cdH1cbn1cblxuaWYgKHR5cGVvZiBfX1RIUkVFX0RFVlRPT0xTX18gIT09ICd1bmRlZmluZWQnKSB7XG5cdF9fVEhSRUVfREVWVE9PTFNfXy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgncmVnaXN0ZXInLCB7XG5cdFx0ZGV0YWlsOiB7XG5cdFx0XHRyZXZpc2lvbjogUkVWSVNJT05cblx0XHR9XG5cdH0pKTtcbn1cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuXHRpZiAod2luZG93Ll9fVEhSRUVfXykge1xuXHRcdGNvbnNvbGUud2FybignV0FSTklORzogTXVsdGlwbGUgaW5zdGFuY2VzIG9mIFRocmVlLmpzIGJlaW5nIGltcG9ydGVkLicpO1xuXHR9IGVsc2Uge1xuXHRcdHdpbmRvdy5fX1RIUkVFX18gPSBSRVZJU0lPTjtcblx0fVxufVxuXG5leHBvcnRzLkFDRVNGaWxtaWNUb25lTWFwcGluZyA9IEFDRVNGaWxtaWNUb25lTWFwcGluZztcbmV4cG9ydHMuQWRkRXF1YXRpb24gPSBBZGRFcXVhdGlvbjtcbmV4cG9ydHMuQWRkT3BlcmF0aW9uID0gQWRkT3BlcmF0aW9uO1xuZXhwb3J0cy5BZGRpdGl2ZUFuaW1hdGlvbkJsZW5kTW9kZSA9IEFkZGl0aXZlQW5pbWF0aW9uQmxlbmRNb2RlO1xuZXhwb3J0cy5BZGRpdGl2ZUJsZW5kaW5nID0gQWRkaXRpdmVCbGVuZGluZztcbmV4cG9ydHMuQWxwaGFGb3JtYXQgPSBBbHBoYUZvcm1hdDtcbmV4cG9ydHMuQWx3YXlzRGVwdGggPSBBbHdheXNEZXB0aDtcbmV4cG9ydHMuQWx3YXlzU3RlbmNpbEZ1bmMgPSBBbHdheXNTdGVuY2lsRnVuYztcbmV4cG9ydHMuQW1iaWVudExpZ2h0ID0gQW1iaWVudExpZ2h0O1xuZXhwb3J0cy5BbWJpZW50TGlnaHRQcm9iZSA9IEFtYmllbnRMaWdodFByb2JlO1xuZXhwb3J0cy5BbmltYXRpb25DbGlwID0gQW5pbWF0aW9uQ2xpcDtcbmV4cG9ydHMuQW5pbWF0aW9uTG9hZGVyID0gQW5pbWF0aW9uTG9hZGVyO1xuZXhwb3J0cy5BbmltYXRpb25NaXhlciA9IEFuaW1hdGlvbk1peGVyO1xuZXhwb3J0cy5BbmltYXRpb25PYmplY3RHcm91cCA9IEFuaW1hdGlvbk9iamVjdEdyb3VwO1xuZXhwb3J0cy5BbmltYXRpb25VdGlscyA9IEFuaW1hdGlvblV0aWxzO1xuZXhwb3J0cy5BcmNDdXJ2ZSA9IEFyY0N1cnZlO1xuZXhwb3J0cy5BcnJheUNhbWVyYSA9IEFycmF5Q2FtZXJhO1xuZXhwb3J0cy5BcnJvd0hlbHBlciA9IEFycm93SGVscGVyO1xuZXhwb3J0cy5BdWRpbyA9IEF1ZGlvO1xuZXhwb3J0cy5BdWRpb0FuYWx5c2VyID0gQXVkaW9BbmFseXNlcjtcbmV4cG9ydHMuQXVkaW9Db250ZXh0ID0gQXVkaW9Db250ZXh0O1xuZXhwb3J0cy5BdWRpb0xpc3RlbmVyID0gQXVkaW9MaXN0ZW5lcjtcbmV4cG9ydHMuQXVkaW9Mb2FkZXIgPSBBdWRpb0xvYWRlcjtcbmV4cG9ydHMuQXhlc0hlbHBlciA9IEF4ZXNIZWxwZXI7XG5leHBvcnRzLkJhY2tTaWRlID0gQmFja1NpZGU7XG5leHBvcnRzLkJhc2ljRGVwdGhQYWNraW5nID0gQmFzaWNEZXB0aFBhY2tpbmc7XG5leHBvcnRzLkJhc2ljU2hhZG93TWFwID0gQmFzaWNTaGFkb3dNYXA7XG5leHBvcnRzLkJvbmUgPSBCb25lO1xuZXhwb3J0cy5Cb29sZWFuS2V5ZnJhbWVUcmFjayA9IEJvb2xlYW5LZXlmcmFtZVRyYWNrO1xuZXhwb3J0cy5Cb3gyID0gQm94MjtcbmV4cG9ydHMuQm94MyA9IEJveDM7XG5leHBvcnRzLkJveDNIZWxwZXIgPSBCb3gzSGVscGVyO1xuZXhwb3J0cy5Cb3hCdWZmZXJHZW9tZXRyeSA9IEJveEJ1ZmZlckdlb21ldHJ5O1xuZXhwb3J0cy5Cb3hHZW9tZXRyeSA9IEJveEdlb21ldHJ5O1xuZXhwb3J0cy5Cb3hIZWxwZXIgPSBCb3hIZWxwZXI7XG5leHBvcnRzLkJ1ZmZlckF0dHJpYnV0ZSA9IEJ1ZmZlckF0dHJpYnV0ZTtcbmV4cG9ydHMuQnVmZmVyR2VvbWV0cnkgPSBCdWZmZXJHZW9tZXRyeTtcbmV4cG9ydHMuQnVmZmVyR2VvbWV0cnlMb2FkZXIgPSBCdWZmZXJHZW9tZXRyeUxvYWRlcjtcbmV4cG9ydHMuQnl0ZVR5cGUgPSBCeXRlVHlwZTtcbmV4cG9ydHMuQ2FjaGUgPSBDYWNoZTtcbmV4cG9ydHMuQ2FtZXJhID0gQ2FtZXJhO1xuZXhwb3J0cy5DYW1lcmFIZWxwZXIgPSBDYW1lcmFIZWxwZXI7XG5leHBvcnRzLkNhbnZhc1RleHR1cmUgPSBDYW52YXNUZXh0dXJlO1xuZXhwb3J0cy5DYXBzdWxlQnVmZmVyR2VvbWV0cnkgPSBDYXBzdWxlQnVmZmVyR2VvbWV0cnk7XG5leHBvcnRzLkNhcHN1bGVHZW9tZXRyeSA9IENhcHN1bGVHZW9tZXRyeTtcbmV4cG9ydHMuQ2F0bXVsbFJvbUN1cnZlMyA9IENhdG11bGxSb21DdXJ2ZTM7XG5leHBvcnRzLkNpbmVvblRvbmVNYXBwaW5nID0gQ2luZW9uVG9uZU1hcHBpbmc7XG5leHBvcnRzLkNpcmNsZUJ1ZmZlckdlb21ldHJ5ID0gQ2lyY2xlQnVmZmVyR2VvbWV0cnk7XG5leHBvcnRzLkNpcmNsZUdlb21ldHJ5ID0gQ2lyY2xlR2VvbWV0cnk7XG5leHBvcnRzLkNsYW1wVG9FZGdlV3JhcHBpbmcgPSBDbGFtcFRvRWRnZVdyYXBwaW5nO1xuZXhwb3J0cy5DbG9jayA9IENsb2NrO1xuZXhwb3J0cy5Db2xvciA9IENvbG9yO1xuZXhwb3J0cy5Db2xvcktleWZyYW1lVHJhY2sgPSBDb2xvcktleWZyYW1lVHJhY2s7XG5leHBvcnRzLkNvbG9yTWFuYWdlbWVudCA9IENvbG9yTWFuYWdlbWVudDtcbmV4cG9ydHMuQ29tcHJlc3NlZEFycmF5VGV4dHVyZSA9IENvbXByZXNzZWRBcnJheVRleHR1cmU7XG5leHBvcnRzLkNvbXByZXNzZWRUZXh0dXJlID0gQ29tcHJlc3NlZFRleHR1cmU7XG5leHBvcnRzLkNvbXByZXNzZWRUZXh0dXJlTG9hZGVyID0gQ29tcHJlc3NlZFRleHR1cmVMb2FkZXI7XG5leHBvcnRzLkNvbmVCdWZmZXJHZW9tZXRyeSA9IENvbmVCdWZmZXJHZW9tZXRyeTtcbmV4cG9ydHMuQ29uZUdlb21ldHJ5ID0gQ29uZUdlb21ldHJ5O1xuZXhwb3J0cy5DdWJlQ2FtZXJhID0gQ3ViZUNhbWVyYTtcbmV4cG9ydHMuQ3ViZVJlZmxlY3Rpb25NYXBwaW5nID0gQ3ViZVJlZmxlY3Rpb25NYXBwaW5nO1xuZXhwb3J0cy5DdWJlUmVmcmFjdGlvbk1hcHBpbmcgPSBDdWJlUmVmcmFjdGlvbk1hcHBpbmc7XG5leHBvcnRzLkN1YmVUZXh0dXJlID0gQ3ViZVRleHR1cmU7XG5leHBvcnRzLkN1YmVUZXh0dXJlTG9hZGVyID0gQ3ViZVRleHR1cmVMb2FkZXI7XG5leHBvcnRzLkN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nID0gQ3ViZVVWUmVmbGVjdGlvbk1hcHBpbmc7XG5leHBvcnRzLkN1YmljQmV6aWVyQ3VydmUgPSBDdWJpY0JlemllckN1cnZlO1xuZXhwb3J0cy5DdWJpY0JlemllckN1cnZlMyA9IEN1YmljQmV6aWVyQ3VydmUzO1xuZXhwb3J0cy5DdWJpY0ludGVycG9sYW50ID0gQ3ViaWNJbnRlcnBvbGFudDtcbmV4cG9ydHMuQ3VsbEZhY2VCYWNrID0gQ3VsbEZhY2VCYWNrO1xuZXhwb3J0cy5DdWxsRmFjZUZyb250ID0gQ3VsbEZhY2VGcm9udDtcbmV4cG9ydHMuQ3VsbEZhY2VGcm9udEJhY2sgPSBDdWxsRmFjZUZyb250QmFjaztcbmV4cG9ydHMuQ3VsbEZhY2VOb25lID0gQ3VsbEZhY2VOb25lO1xuZXhwb3J0cy5DdXJ2ZSA9IEN1cnZlO1xuZXhwb3J0cy5DdXJ2ZVBhdGggPSBDdXJ2ZVBhdGg7XG5leHBvcnRzLkN1c3RvbUJsZW5kaW5nID0gQ3VzdG9tQmxlbmRpbmc7XG5leHBvcnRzLkN1c3RvbVRvbmVNYXBwaW5nID0gQ3VzdG9tVG9uZU1hcHBpbmc7XG5leHBvcnRzLkN5bGluZGVyQnVmZmVyR2VvbWV0cnkgPSBDeWxpbmRlckJ1ZmZlckdlb21ldHJ5O1xuZXhwb3J0cy5DeWxpbmRlckdlb21ldHJ5ID0gQ3lsaW5kZXJHZW9tZXRyeTtcbmV4cG9ydHMuQ3lsaW5kcmljYWwgPSBDeWxpbmRyaWNhbDtcbmV4cG9ydHMuRGF0YTNEVGV4dHVyZSA9IERhdGEzRFRleHR1cmU7XG5leHBvcnRzLkRhdGFBcnJheVRleHR1cmUgPSBEYXRhQXJyYXlUZXh0dXJlO1xuZXhwb3J0cy5EYXRhVGV4dHVyZSA9IERhdGFUZXh0dXJlO1xuZXhwb3J0cy5EYXRhVGV4dHVyZTJEQXJyYXkgPSBEYXRhVGV4dHVyZTJEQXJyYXk7XG5leHBvcnRzLkRhdGFUZXh0dXJlM0QgPSBEYXRhVGV4dHVyZTNEO1xuZXhwb3J0cy5EYXRhVGV4dHVyZUxvYWRlciA9IERhdGFUZXh0dXJlTG9hZGVyO1xuZXhwb3J0cy5EYXRhVXRpbHMgPSBEYXRhVXRpbHM7XG5leHBvcnRzLkRlY3JlbWVudFN0ZW5jaWxPcCA9IERlY3JlbWVudFN0ZW5jaWxPcDtcbmV4cG9ydHMuRGVjcmVtZW50V3JhcFN0ZW5jaWxPcCA9IERlY3JlbWVudFdyYXBTdGVuY2lsT3A7XG5leHBvcnRzLkRlZmF1bHRMb2FkaW5nTWFuYWdlciA9IERlZmF1bHRMb2FkaW5nTWFuYWdlcjtcbmV4cG9ydHMuRGVwdGhGb3JtYXQgPSBEZXB0aEZvcm1hdDtcbmV4cG9ydHMuRGVwdGhTdGVuY2lsRm9ybWF0ID0gRGVwdGhTdGVuY2lsRm9ybWF0O1xuZXhwb3J0cy5EZXB0aFRleHR1cmUgPSBEZXB0aFRleHR1cmU7XG5leHBvcnRzLkRpcmVjdGlvbmFsTGlnaHQgPSBEaXJlY3Rpb25hbExpZ2h0O1xuZXhwb3J0cy5EaXJlY3Rpb25hbExpZ2h0SGVscGVyID0gRGlyZWN0aW9uYWxMaWdodEhlbHBlcjtcbmV4cG9ydHMuRGlzY3JldGVJbnRlcnBvbGFudCA9IERpc2NyZXRlSW50ZXJwb2xhbnQ7XG5leHBvcnRzLkRvZGVjYWhlZHJvbkJ1ZmZlckdlb21ldHJ5ID0gRG9kZWNhaGVkcm9uQnVmZmVyR2VvbWV0cnk7XG5leHBvcnRzLkRvZGVjYWhlZHJvbkdlb21ldHJ5ID0gRG9kZWNhaGVkcm9uR2VvbWV0cnk7XG5leHBvcnRzLkRvdWJsZVNpZGUgPSBEb3VibGVTaWRlO1xuZXhwb3J0cy5Ec3RBbHBoYUZhY3RvciA9IERzdEFscGhhRmFjdG9yO1xuZXhwb3J0cy5Ec3RDb2xvckZhY3RvciA9IERzdENvbG9yRmFjdG9yO1xuZXhwb3J0cy5EeW5hbWljQ29weVVzYWdlID0gRHluYW1pY0NvcHlVc2FnZTtcbmV4cG9ydHMuRHluYW1pY0RyYXdVc2FnZSA9IER5bmFtaWNEcmF3VXNhZ2U7XG5leHBvcnRzLkR5bmFtaWNSZWFkVXNhZ2UgPSBEeW5hbWljUmVhZFVzYWdlO1xuZXhwb3J0cy5FZGdlc0dlb21ldHJ5ID0gRWRnZXNHZW9tZXRyeTtcbmV4cG9ydHMuRWxsaXBzZUN1cnZlID0gRWxsaXBzZUN1cnZlO1xuZXhwb3J0cy5FcXVhbERlcHRoID0gRXF1YWxEZXB0aDtcbmV4cG9ydHMuRXF1YWxTdGVuY2lsRnVuYyA9IEVxdWFsU3RlbmNpbEZ1bmM7XG5leHBvcnRzLkVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nID0gRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmc7XG5leHBvcnRzLkVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nID0gRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmc7XG5leHBvcnRzLkV1bGVyID0gRXVsZXI7XG5leHBvcnRzLkV2ZW50RGlzcGF0Y2hlciA9IEV2ZW50RGlzcGF0Y2hlcjtcbmV4cG9ydHMuRXh0cnVkZUJ1ZmZlckdlb21ldHJ5ID0gRXh0cnVkZUJ1ZmZlckdlb21ldHJ5O1xuZXhwb3J0cy5FeHRydWRlR2VvbWV0cnkgPSBFeHRydWRlR2VvbWV0cnk7XG5leHBvcnRzLkZpbGVMb2FkZXIgPSBGaWxlTG9hZGVyO1xuZXhwb3J0cy5GbG9hdDE2QnVmZmVyQXR0cmlidXRlID0gRmxvYXQxNkJ1ZmZlckF0dHJpYnV0ZTtcbmV4cG9ydHMuRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSA9IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGU7XG5leHBvcnRzLkZsb2F0NjRCdWZmZXJBdHRyaWJ1dGUgPSBGbG9hdDY0QnVmZmVyQXR0cmlidXRlO1xuZXhwb3J0cy5GbG9hdFR5cGUgPSBGbG9hdFR5cGU7XG5leHBvcnRzLkZvZyA9IEZvZztcbmV4cG9ydHMuRm9nRXhwMiA9IEZvZ0V4cDI7XG5leHBvcnRzLkZyYW1lYnVmZmVyVGV4dHVyZSA9IEZyYW1lYnVmZmVyVGV4dHVyZTtcbmV4cG9ydHMuRnJvbnRTaWRlID0gRnJvbnRTaWRlO1xuZXhwb3J0cy5GcnVzdHVtID0gRnJ1c3R1bTtcbmV4cG9ydHMuR0xCdWZmZXJBdHRyaWJ1dGUgPSBHTEJ1ZmZlckF0dHJpYnV0ZTtcbmV4cG9ydHMuR0xTTDEgPSBHTFNMMTtcbmV4cG9ydHMuR0xTTDMgPSBHTFNMMztcbmV4cG9ydHMuR3JlYXRlckRlcHRoID0gR3JlYXRlckRlcHRoO1xuZXhwb3J0cy5HcmVhdGVyRXF1YWxEZXB0aCA9IEdyZWF0ZXJFcXVhbERlcHRoO1xuZXhwb3J0cy5HcmVhdGVyRXF1YWxTdGVuY2lsRnVuYyA9IEdyZWF0ZXJFcXVhbFN0ZW5jaWxGdW5jO1xuZXhwb3J0cy5HcmVhdGVyU3RlbmNpbEZ1bmMgPSBHcmVhdGVyU3RlbmNpbEZ1bmM7XG5leHBvcnRzLkdyaWRIZWxwZXIgPSBHcmlkSGVscGVyO1xuZXhwb3J0cy5Hcm91cCA9IEdyb3VwO1xuZXhwb3J0cy5IYWxmRmxvYXRUeXBlID0gSGFsZkZsb2F0VHlwZTtcbmV4cG9ydHMuSGVtaXNwaGVyZUxpZ2h0ID0gSGVtaXNwaGVyZUxpZ2h0O1xuZXhwb3J0cy5IZW1pc3BoZXJlTGlnaHRIZWxwZXIgPSBIZW1pc3BoZXJlTGlnaHRIZWxwZXI7XG5leHBvcnRzLkhlbWlzcGhlcmVMaWdodFByb2JlID0gSGVtaXNwaGVyZUxpZ2h0UHJvYmU7XG5leHBvcnRzLkljb3NhaGVkcm9uQnVmZmVyR2VvbWV0cnkgPSBJY29zYWhlZHJvbkJ1ZmZlckdlb21ldHJ5O1xuZXhwb3J0cy5JY29zYWhlZHJvbkdlb21ldHJ5ID0gSWNvc2FoZWRyb25HZW9tZXRyeTtcbmV4cG9ydHMuSW1hZ2VCaXRtYXBMb2FkZXIgPSBJbWFnZUJpdG1hcExvYWRlcjtcbmV4cG9ydHMuSW1hZ2VMb2FkZXIgPSBJbWFnZUxvYWRlcjtcbmV4cG9ydHMuSW1hZ2VVdGlscyA9IEltYWdlVXRpbHM7XG5leHBvcnRzLkltbWVkaWF0ZVJlbmRlck9iamVjdCA9IEltbWVkaWF0ZVJlbmRlck9iamVjdDtcbmV4cG9ydHMuSW5jcmVtZW50U3RlbmNpbE9wID0gSW5jcmVtZW50U3RlbmNpbE9wO1xuZXhwb3J0cy5JbmNyZW1lbnRXcmFwU3RlbmNpbE9wID0gSW5jcmVtZW50V3JhcFN0ZW5jaWxPcDtcbmV4cG9ydHMuSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlID0gSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlO1xuZXhwb3J0cy5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSA9IEluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5O1xuZXhwb3J0cy5JbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlciA9IEluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyO1xuZXhwb3J0cy5JbnN0YW5jZWRNZXNoID0gSW5zdGFuY2VkTWVzaDtcbmV4cG9ydHMuSW50MTZCdWZmZXJBdHRyaWJ1dGUgPSBJbnQxNkJ1ZmZlckF0dHJpYnV0ZTtcbmV4cG9ydHMuSW50MzJCdWZmZXJBdHRyaWJ1dGUgPSBJbnQzMkJ1ZmZlckF0dHJpYnV0ZTtcbmV4cG9ydHMuSW50OEJ1ZmZlckF0dHJpYnV0ZSA9IEludDhCdWZmZXJBdHRyaWJ1dGU7XG5leHBvcnRzLkludFR5cGUgPSBJbnRUeXBlO1xuZXhwb3J0cy5JbnRlcmxlYXZlZEJ1ZmZlciA9IEludGVybGVhdmVkQnVmZmVyO1xuZXhwb3J0cy5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSA9IEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlO1xuZXhwb3J0cy5JbnRlcnBvbGFudCA9IEludGVycG9sYW50O1xuZXhwb3J0cy5JbnRlcnBvbGF0ZURpc2NyZXRlID0gSW50ZXJwb2xhdGVEaXNjcmV0ZTtcbmV4cG9ydHMuSW50ZXJwb2xhdGVMaW5lYXIgPSBJbnRlcnBvbGF0ZUxpbmVhcjtcbmV4cG9ydHMuSW50ZXJwb2xhdGVTbW9vdGggPSBJbnRlcnBvbGF0ZVNtb290aDtcbmV4cG9ydHMuSW52ZXJ0U3RlbmNpbE9wID0gSW52ZXJ0U3RlbmNpbE9wO1xuZXhwb3J0cy5LZWVwU3RlbmNpbE9wID0gS2VlcFN0ZW5jaWxPcDtcbmV4cG9ydHMuS2V5ZnJhbWVUcmFjayA9IEtleWZyYW1lVHJhY2s7XG5leHBvcnRzLkxPRCA9IExPRDtcbmV4cG9ydHMuTGF0aGVCdWZmZXJHZW9tZXRyeSA9IExhdGhlQnVmZmVyR2VvbWV0cnk7XG5leHBvcnRzLkxhdGhlR2VvbWV0cnkgPSBMYXRoZUdlb21ldHJ5O1xuZXhwb3J0cy5MYXllcnMgPSBMYXllcnM7XG5leHBvcnRzLkxlc3NEZXB0aCA9IExlc3NEZXB0aDtcbmV4cG9ydHMuTGVzc0VxdWFsRGVwdGggPSBMZXNzRXF1YWxEZXB0aDtcbmV4cG9ydHMuTGVzc0VxdWFsU3RlbmNpbEZ1bmMgPSBMZXNzRXF1YWxTdGVuY2lsRnVuYztcbmV4cG9ydHMuTGVzc1N0ZW5jaWxGdW5jID0gTGVzc1N0ZW5jaWxGdW5jO1xuZXhwb3J0cy5MaWdodCA9IExpZ2h0O1xuZXhwb3J0cy5MaWdodFByb2JlID0gTGlnaHRQcm9iZTtcbmV4cG9ydHMuTGluZSA9IExpbmU7XG5leHBvcnRzLkxpbmUzID0gTGluZTM7XG5leHBvcnRzLkxpbmVCYXNpY01hdGVyaWFsID0gTGluZUJhc2ljTWF0ZXJpYWw7XG5leHBvcnRzLkxpbmVDdXJ2ZSA9IExpbmVDdXJ2ZTtcbmV4cG9ydHMuTGluZUN1cnZlMyA9IExpbmVDdXJ2ZTM7XG5leHBvcnRzLkxpbmVEYXNoZWRNYXRlcmlhbCA9IExpbmVEYXNoZWRNYXRlcmlhbDtcbmV4cG9ydHMuTGluZUxvb3AgPSBMaW5lTG9vcDtcbmV4cG9ydHMuTGluZVNlZ21lbnRzID0gTGluZVNlZ21lbnRzO1xuZXhwb3J0cy5MaW5lYXJFbmNvZGluZyA9IExpbmVhckVuY29kaW5nO1xuZXhwb3J0cy5MaW5lYXJGaWx0ZXIgPSBMaW5lYXJGaWx0ZXI7XG5leHBvcnRzLkxpbmVhckludGVycG9sYW50ID0gTGluZWFySW50ZXJwb2xhbnQ7XG5leHBvcnRzLkxpbmVhck1pcE1hcExpbmVhckZpbHRlciA9IExpbmVhck1pcE1hcExpbmVhckZpbHRlcjtcbmV4cG9ydHMuTGluZWFyTWlwTWFwTmVhcmVzdEZpbHRlciA9IExpbmVhck1pcE1hcE5lYXJlc3RGaWx0ZXI7XG5leHBvcnRzLkxpbmVhck1pcG1hcExpbmVhckZpbHRlciA9IExpbmVhck1pcG1hcExpbmVhckZpbHRlcjtcbmV4cG9ydHMuTGluZWFyTWlwbWFwTmVhcmVzdEZpbHRlciA9IExpbmVhck1pcG1hcE5lYXJlc3RGaWx0ZXI7XG5leHBvcnRzLkxpbmVhclNSR0JDb2xvclNwYWNlID0gTGluZWFyU1JHQkNvbG9yU3BhY2U7XG5leHBvcnRzLkxpbmVhclRvbmVNYXBwaW5nID0gTGluZWFyVG9uZU1hcHBpbmc7XG5leHBvcnRzLkxvYWRlciA9IExvYWRlcjtcbmV4cG9ydHMuTG9hZGVyVXRpbHMgPSBMb2FkZXJVdGlscztcbmV4cG9ydHMuTG9hZGluZ01hbmFnZXIgPSBMb2FkaW5nTWFuYWdlcjtcbmV4cG9ydHMuTG9vcE9uY2UgPSBMb29wT25jZTtcbmV4cG9ydHMuTG9vcFBpbmdQb25nID0gTG9vcFBpbmdQb25nO1xuZXhwb3J0cy5Mb29wUmVwZWF0ID0gTG9vcFJlcGVhdDtcbmV4cG9ydHMuTHVtaW5hbmNlQWxwaGFGb3JtYXQgPSBMdW1pbmFuY2VBbHBoYUZvcm1hdDtcbmV4cG9ydHMuTHVtaW5hbmNlRm9ybWF0ID0gTHVtaW5hbmNlRm9ybWF0O1xuZXhwb3J0cy5NT1VTRSA9IE1PVVNFO1xuZXhwb3J0cy5NYXRlcmlhbCA9IE1hdGVyaWFsO1xuZXhwb3J0cy5NYXRlcmlhbExvYWRlciA9IE1hdGVyaWFsTG9hZGVyO1xuZXhwb3J0cy5NYXRoVXRpbHMgPSBNYXRoVXRpbHM7XG5leHBvcnRzLk1hdHJpeDMgPSBNYXRyaXgzO1xuZXhwb3J0cy5NYXRyaXg0ID0gTWF0cml4NDtcbmV4cG9ydHMuTWF4RXF1YXRpb24gPSBNYXhFcXVhdGlvbjtcbmV4cG9ydHMuTWVzaCA9IE1lc2g7XG5leHBvcnRzLk1lc2hCYXNpY01hdGVyaWFsID0gTWVzaEJhc2ljTWF0ZXJpYWw7XG5leHBvcnRzLk1lc2hEZXB0aE1hdGVyaWFsID0gTWVzaERlcHRoTWF0ZXJpYWw7XG5leHBvcnRzLk1lc2hEaXN0YW5jZU1hdGVyaWFsID0gTWVzaERpc3RhbmNlTWF0ZXJpYWw7XG5leHBvcnRzLk1lc2hMYW1iZXJ0TWF0ZXJpYWwgPSBNZXNoTGFtYmVydE1hdGVyaWFsO1xuZXhwb3J0cy5NZXNoTWF0Y2FwTWF0ZXJpYWwgPSBNZXNoTWF0Y2FwTWF0ZXJpYWw7XG5leHBvcnRzLk1lc2hOb3JtYWxNYXRlcmlhbCA9IE1lc2hOb3JtYWxNYXRlcmlhbDtcbmV4cG9ydHMuTWVzaFBob25nTWF0ZXJpYWwgPSBNZXNoUGhvbmdNYXRlcmlhbDtcbmV4cG9ydHMuTWVzaFBoeXNpY2FsTWF0ZXJpYWwgPSBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcbmV4cG9ydHMuTWVzaFN0YW5kYXJkTWF0ZXJpYWwgPSBNZXNoU3RhbmRhcmRNYXRlcmlhbDtcbmV4cG9ydHMuTWVzaFRvb25NYXRlcmlhbCA9IE1lc2hUb29uTWF0ZXJpYWw7XG5leHBvcnRzLk1pbkVxdWF0aW9uID0gTWluRXF1YXRpb247XG5leHBvcnRzLk1pcnJvcmVkUmVwZWF0V3JhcHBpbmcgPSBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nO1xuZXhwb3J0cy5NaXhPcGVyYXRpb24gPSBNaXhPcGVyYXRpb247XG5leHBvcnRzLk11bHRpcGx5QmxlbmRpbmcgPSBNdWx0aXBseUJsZW5kaW5nO1xuZXhwb3J0cy5NdWx0aXBseU9wZXJhdGlvbiA9IE11bHRpcGx5T3BlcmF0aW9uO1xuZXhwb3J0cy5OZWFyZXN0RmlsdGVyID0gTmVhcmVzdEZpbHRlcjtcbmV4cG9ydHMuTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlciA9IE5lYXJlc3RNaXBNYXBMaW5lYXJGaWx0ZXI7XG5leHBvcnRzLk5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyID0gTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXI7XG5leHBvcnRzLk5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIgPSBOZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyO1xuZXhwb3J0cy5OZWFyZXN0TWlwbWFwTmVhcmVzdEZpbHRlciA9IE5lYXJlc3RNaXBtYXBOZWFyZXN0RmlsdGVyO1xuZXhwb3J0cy5OZXZlckRlcHRoID0gTmV2ZXJEZXB0aDtcbmV4cG9ydHMuTmV2ZXJTdGVuY2lsRnVuYyA9IE5ldmVyU3RlbmNpbEZ1bmM7XG5leHBvcnRzLk5vQmxlbmRpbmcgPSBOb0JsZW5kaW5nO1xuZXhwb3J0cy5Ob0NvbG9yU3BhY2UgPSBOb0NvbG9yU3BhY2U7XG5leHBvcnRzLk5vVG9uZU1hcHBpbmcgPSBOb1RvbmVNYXBwaW5nO1xuZXhwb3J0cy5Ob3JtYWxBbmltYXRpb25CbGVuZE1vZGUgPSBOb3JtYWxBbmltYXRpb25CbGVuZE1vZGU7XG5leHBvcnRzLk5vcm1hbEJsZW5kaW5nID0gTm9ybWFsQmxlbmRpbmc7XG5leHBvcnRzLk5vdEVxdWFsRGVwdGggPSBOb3RFcXVhbERlcHRoO1xuZXhwb3J0cy5Ob3RFcXVhbFN0ZW5jaWxGdW5jID0gTm90RXF1YWxTdGVuY2lsRnVuYztcbmV4cG9ydHMuTnVtYmVyS2V5ZnJhbWVUcmFjayA9IE51bWJlcktleWZyYW1lVHJhY2s7XG5leHBvcnRzLk9iamVjdDNEID0gT2JqZWN0M0Q7XG5leHBvcnRzLk9iamVjdExvYWRlciA9IE9iamVjdExvYWRlcjtcbmV4cG9ydHMuT2JqZWN0U3BhY2VOb3JtYWxNYXAgPSBPYmplY3RTcGFjZU5vcm1hbE1hcDtcbmV4cG9ydHMuT2N0YWhlZHJvbkJ1ZmZlckdlb21ldHJ5ID0gT2N0YWhlZHJvbkJ1ZmZlckdlb21ldHJ5O1xuZXhwb3J0cy5PY3RhaGVkcm9uR2VvbWV0cnkgPSBPY3RhaGVkcm9uR2VvbWV0cnk7XG5leHBvcnRzLk9uZUZhY3RvciA9IE9uZUZhY3RvcjtcbmV4cG9ydHMuT25lTWludXNEc3RBbHBoYUZhY3RvciA9IE9uZU1pbnVzRHN0QWxwaGFGYWN0b3I7XG5leHBvcnRzLk9uZU1pbnVzRHN0Q29sb3JGYWN0b3IgPSBPbmVNaW51c0RzdENvbG9yRmFjdG9yO1xuZXhwb3J0cy5PbmVNaW51c1NyY0FscGhhRmFjdG9yID0gT25lTWludXNTcmNBbHBoYUZhY3RvcjtcbmV4cG9ydHMuT25lTWludXNTcmNDb2xvckZhY3RvciA9IE9uZU1pbnVzU3JjQ29sb3JGYWN0b3I7XG5leHBvcnRzLk9ydGhvZ3JhcGhpY0NhbWVyYSA9IE9ydGhvZ3JhcGhpY0NhbWVyYTtcbmV4cG9ydHMuUENGU2hhZG93TWFwID0gUENGU2hhZG93TWFwO1xuZXhwb3J0cy5QQ0ZTb2Z0U2hhZG93TWFwID0gUENGU29mdFNoYWRvd01hcDtcbmV4cG9ydHMuUE1SRU1HZW5lcmF0b3IgPSBQTVJFTUdlbmVyYXRvcjtcbmV4cG9ydHMuUGF0aCA9IFBhdGg7XG5leHBvcnRzLlBlcnNwZWN0aXZlQ2FtZXJhID0gUGVyc3BlY3RpdmVDYW1lcmE7XG5leHBvcnRzLlBsYW5lID0gUGxhbmU7XG5leHBvcnRzLlBsYW5lQnVmZmVyR2VvbWV0cnkgPSBQbGFuZUJ1ZmZlckdlb21ldHJ5O1xuZXhwb3J0cy5QbGFuZUdlb21ldHJ5ID0gUGxhbmVHZW9tZXRyeTtcbmV4cG9ydHMuUGxhbmVIZWxwZXIgPSBQbGFuZUhlbHBlcjtcbmV4cG9ydHMuUG9pbnRMaWdodCA9IFBvaW50TGlnaHQ7XG5leHBvcnRzLlBvaW50TGlnaHRIZWxwZXIgPSBQb2ludExpZ2h0SGVscGVyO1xuZXhwb3J0cy5Qb2ludHMgPSBQb2ludHM7XG5leHBvcnRzLlBvaW50c01hdGVyaWFsID0gUG9pbnRzTWF0ZXJpYWw7XG5leHBvcnRzLlBvbGFyR3JpZEhlbHBlciA9IFBvbGFyR3JpZEhlbHBlcjtcbmV4cG9ydHMuUG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5ID0gUG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5O1xuZXhwb3J0cy5Qb2x5aGVkcm9uR2VvbWV0cnkgPSBQb2x5aGVkcm9uR2VvbWV0cnk7XG5leHBvcnRzLlBvc2l0aW9uYWxBdWRpbyA9IFBvc2l0aW9uYWxBdWRpbztcbmV4cG9ydHMuUHJvcGVydHlCaW5kaW5nID0gUHJvcGVydHlCaW5kaW5nO1xuZXhwb3J0cy5Qcm9wZXJ0eU1peGVyID0gUHJvcGVydHlNaXhlcjtcbmV4cG9ydHMuUXVhZHJhdGljQmV6aWVyQ3VydmUgPSBRdWFkcmF0aWNCZXppZXJDdXJ2ZTtcbmV4cG9ydHMuUXVhZHJhdGljQmV6aWVyQ3VydmUzID0gUXVhZHJhdGljQmV6aWVyQ3VydmUzO1xuZXhwb3J0cy5RdWF0ZXJuaW9uID0gUXVhdGVybmlvbjtcbmV4cG9ydHMuUXVhdGVybmlvbktleWZyYW1lVHJhY2sgPSBRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjaztcbmV4cG9ydHMuUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50ID0gUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50O1xuZXhwb3J0cy5SRVZJU0lPTiA9IFJFVklTSU9OO1xuZXhwb3J0cy5SR0JBRGVwdGhQYWNraW5nID0gUkdCQURlcHRoUGFja2luZztcbmV4cG9ydHMuUkdCQUZvcm1hdCA9IFJHQkFGb3JtYXQ7XG5leHBvcnRzLlJHQkFJbnRlZ2VyRm9ybWF0ID0gUkdCQUludGVnZXJGb3JtYXQ7XG5leHBvcnRzLlJHQkFfQVNUQ18xMHgxMF9Gb3JtYXQgPSBSR0JBX0FTVENfMTB4MTBfRm9ybWF0O1xuZXhwb3J0cy5SR0JBX0FTVENfMTB4NV9Gb3JtYXQgPSBSR0JBX0FTVENfMTB4NV9Gb3JtYXQ7XG5leHBvcnRzLlJHQkFfQVNUQ18xMHg2X0Zvcm1hdCA9IFJHQkFfQVNUQ18xMHg2X0Zvcm1hdDtcbmV4cG9ydHMuUkdCQV9BU1RDXzEweDhfRm9ybWF0ID0gUkdCQV9BU1RDXzEweDhfRm9ybWF0O1xuZXhwb3J0cy5SR0JBX0FTVENfMTJ4MTBfRm9ybWF0ID0gUkdCQV9BU1RDXzEyeDEwX0Zvcm1hdDtcbmV4cG9ydHMuUkdCQV9BU1RDXzEyeDEyX0Zvcm1hdCA9IFJHQkFfQVNUQ18xMngxMl9Gb3JtYXQ7XG5leHBvcnRzLlJHQkFfQVNUQ180eDRfRm9ybWF0ID0gUkdCQV9BU1RDXzR4NF9Gb3JtYXQ7XG5leHBvcnRzLlJHQkFfQVNUQ181eDRfRm9ybWF0ID0gUkdCQV9BU1RDXzV4NF9Gb3JtYXQ7XG5leHBvcnRzLlJHQkFfQVNUQ181eDVfRm9ybWF0ID0gUkdCQV9BU1RDXzV4NV9Gb3JtYXQ7XG5leHBvcnRzLlJHQkFfQVNUQ182eDVfRm9ybWF0ID0gUkdCQV9BU1RDXzZ4NV9Gb3JtYXQ7XG5leHBvcnRzLlJHQkFfQVNUQ182eDZfRm9ybWF0ID0gUkdCQV9BU1RDXzZ4Nl9Gb3JtYXQ7XG5leHBvcnRzLlJHQkFfQVNUQ184eDVfRm9ybWF0ID0gUkdCQV9BU1RDXzh4NV9Gb3JtYXQ7XG5leHBvcnRzLlJHQkFfQVNUQ184eDZfRm9ybWF0ID0gUkdCQV9BU1RDXzh4Nl9Gb3JtYXQ7XG5leHBvcnRzLlJHQkFfQVNUQ184eDhfRm9ybWF0ID0gUkdCQV9BU1RDXzh4OF9Gb3JtYXQ7XG5leHBvcnRzLlJHQkFfQlBUQ19Gb3JtYXQgPSBSR0JBX0JQVENfRm9ybWF0O1xuZXhwb3J0cy5SR0JBX0VUQzJfRUFDX0Zvcm1hdCA9IFJHQkFfRVRDMl9FQUNfRm9ybWF0O1xuZXhwb3J0cy5SR0JBX1BWUlRDXzJCUFBWMV9Gb3JtYXQgPSBSR0JBX1BWUlRDXzJCUFBWMV9Gb3JtYXQ7XG5leHBvcnRzLlJHQkFfUFZSVENfNEJQUFYxX0Zvcm1hdCA9IFJHQkFfUFZSVENfNEJQUFYxX0Zvcm1hdDtcbmV4cG9ydHMuUkdCQV9TM1RDX0RYVDFfRm9ybWF0ID0gUkdCQV9TM1RDX0RYVDFfRm9ybWF0O1xuZXhwb3J0cy5SR0JBX1MzVENfRFhUM19Gb3JtYXQgPSBSR0JBX1MzVENfRFhUM19Gb3JtYXQ7XG5leHBvcnRzLlJHQkFfUzNUQ19EWFQ1X0Zvcm1hdCA9IFJHQkFfUzNUQ19EWFQ1X0Zvcm1hdDtcbmV4cG9ydHMuUkdCRm9ybWF0ID0gUkdCRm9ybWF0O1xuZXhwb3J0cy5SR0JfRVRDMV9Gb3JtYXQgPSBSR0JfRVRDMV9Gb3JtYXQ7XG5leHBvcnRzLlJHQl9FVEMyX0Zvcm1hdCA9IFJHQl9FVEMyX0Zvcm1hdDtcbmV4cG9ydHMuUkdCX1BWUlRDXzJCUFBWMV9Gb3JtYXQgPSBSR0JfUFZSVENfMkJQUFYxX0Zvcm1hdDtcbmV4cG9ydHMuUkdCX1BWUlRDXzRCUFBWMV9Gb3JtYXQgPSBSR0JfUFZSVENfNEJQUFYxX0Zvcm1hdDtcbmV4cG9ydHMuUkdCX1MzVENfRFhUMV9Gb3JtYXQgPSBSR0JfUzNUQ19EWFQxX0Zvcm1hdDtcbmV4cG9ydHMuUkdGb3JtYXQgPSBSR0Zvcm1hdDtcbmV4cG9ydHMuUkdJbnRlZ2VyRm9ybWF0ID0gUkdJbnRlZ2VyRm9ybWF0O1xuZXhwb3J0cy5SYXdTaGFkZXJNYXRlcmlhbCA9IFJhd1NoYWRlck1hdGVyaWFsO1xuZXhwb3J0cy5SYXkgPSBSYXk7XG5leHBvcnRzLlJheWNhc3RlciA9IFJheWNhc3RlcjtcbmV4cG9ydHMuUmVjdEFyZWFMaWdodCA9IFJlY3RBcmVhTGlnaHQ7XG5leHBvcnRzLlJlZEZvcm1hdCA9IFJlZEZvcm1hdDtcbmV4cG9ydHMuUmVkSW50ZWdlckZvcm1hdCA9IFJlZEludGVnZXJGb3JtYXQ7XG5leHBvcnRzLlJlaW5oYXJkVG9uZU1hcHBpbmcgPSBSZWluaGFyZFRvbmVNYXBwaW5nO1xuZXhwb3J0cy5SZXBlYXRXcmFwcGluZyA9IFJlcGVhdFdyYXBwaW5nO1xuZXhwb3J0cy5SZXBsYWNlU3RlbmNpbE9wID0gUmVwbGFjZVN0ZW5jaWxPcDtcbmV4cG9ydHMuUmV2ZXJzZVN1YnRyYWN0RXF1YXRpb24gPSBSZXZlcnNlU3VidHJhY3RFcXVhdGlvbjtcbmV4cG9ydHMuUmluZ0J1ZmZlckdlb21ldHJ5ID0gUmluZ0J1ZmZlckdlb21ldHJ5O1xuZXhwb3J0cy5SaW5nR2VvbWV0cnkgPSBSaW5nR2VvbWV0cnk7XG5leHBvcnRzLlNSR0JDb2xvclNwYWNlID0gU1JHQkNvbG9yU3BhY2U7XG5leHBvcnRzLlNjZW5lID0gU2NlbmU7XG5leHBvcnRzLlNoYWRlckNodW5rID0gU2hhZGVyQ2h1bms7XG5leHBvcnRzLlNoYWRlckxpYiA9IFNoYWRlckxpYjtcbmV4cG9ydHMuU2hhZGVyTWF0ZXJpYWwgPSBTaGFkZXJNYXRlcmlhbDtcbmV4cG9ydHMuU2hhZG93TWF0ZXJpYWwgPSBTaGFkb3dNYXRlcmlhbDtcbmV4cG9ydHMuU2hhcGUgPSBTaGFwZTtcbmV4cG9ydHMuU2hhcGVCdWZmZXJHZW9tZXRyeSA9IFNoYXBlQnVmZmVyR2VvbWV0cnk7XG5leHBvcnRzLlNoYXBlR2VvbWV0cnkgPSBTaGFwZUdlb21ldHJ5O1xuZXhwb3J0cy5TaGFwZVBhdGggPSBTaGFwZVBhdGg7XG5leHBvcnRzLlNoYXBlVXRpbHMgPSBTaGFwZVV0aWxzO1xuZXhwb3J0cy5TaG9ydFR5cGUgPSBTaG9ydFR5cGU7XG5leHBvcnRzLlNrZWxldG9uID0gU2tlbGV0b247XG5leHBvcnRzLlNrZWxldG9uSGVscGVyID0gU2tlbGV0b25IZWxwZXI7XG5leHBvcnRzLlNraW5uZWRNZXNoID0gU2tpbm5lZE1lc2g7XG5leHBvcnRzLlNvdXJjZSA9IFNvdXJjZTtcbmV4cG9ydHMuU3BoZXJlID0gU3BoZXJlO1xuZXhwb3J0cy5TcGhlcmVCdWZmZXJHZW9tZXRyeSA9IFNwaGVyZUJ1ZmZlckdlb21ldHJ5O1xuZXhwb3J0cy5TcGhlcmVHZW9tZXRyeSA9IFNwaGVyZUdlb21ldHJ5O1xuZXhwb3J0cy5TcGhlcmljYWwgPSBTcGhlcmljYWw7XG5leHBvcnRzLlNwaGVyaWNhbEhhcm1vbmljczMgPSBTcGhlcmljYWxIYXJtb25pY3MzO1xuZXhwb3J0cy5TcGxpbmVDdXJ2ZSA9IFNwbGluZUN1cnZlO1xuZXhwb3J0cy5TcG90TGlnaHQgPSBTcG90TGlnaHQ7XG5leHBvcnRzLlNwb3RMaWdodEhlbHBlciA9IFNwb3RMaWdodEhlbHBlcjtcbmV4cG9ydHMuU3ByaXRlID0gU3ByaXRlO1xuZXhwb3J0cy5TcHJpdGVNYXRlcmlhbCA9IFNwcml0ZU1hdGVyaWFsO1xuZXhwb3J0cy5TcmNBbHBoYUZhY3RvciA9IFNyY0FscGhhRmFjdG9yO1xuZXhwb3J0cy5TcmNBbHBoYVNhdHVyYXRlRmFjdG9yID0gU3JjQWxwaGFTYXR1cmF0ZUZhY3RvcjtcbmV4cG9ydHMuU3JjQ29sb3JGYWN0b3IgPSBTcmNDb2xvckZhY3RvcjtcbmV4cG9ydHMuU3RhdGljQ29weVVzYWdlID0gU3RhdGljQ29weVVzYWdlO1xuZXhwb3J0cy5TdGF0aWNEcmF3VXNhZ2UgPSBTdGF0aWNEcmF3VXNhZ2U7XG5leHBvcnRzLlN0YXRpY1JlYWRVc2FnZSA9IFN0YXRpY1JlYWRVc2FnZTtcbmV4cG9ydHMuU3RlcmVvQ2FtZXJhID0gU3RlcmVvQ2FtZXJhO1xuZXhwb3J0cy5TdHJlYW1Db3B5VXNhZ2UgPSBTdHJlYW1Db3B5VXNhZ2U7XG5leHBvcnRzLlN0cmVhbURyYXdVc2FnZSA9IFN0cmVhbURyYXdVc2FnZTtcbmV4cG9ydHMuU3RyZWFtUmVhZFVzYWdlID0gU3RyZWFtUmVhZFVzYWdlO1xuZXhwb3J0cy5TdHJpbmdLZXlmcmFtZVRyYWNrID0gU3RyaW5nS2V5ZnJhbWVUcmFjaztcbmV4cG9ydHMuU3VidHJhY3RFcXVhdGlvbiA9IFN1YnRyYWN0RXF1YXRpb247XG5leHBvcnRzLlN1YnRyYWN0aXZlQmxlbmRpbmcgPSBTdWJ0cmFjdGl2ZUJsZW5kaW5nO1xuZXhwb3J0cy5UT1VDSCA9IFRPVUNIO1xuZXhwb3J0cy5UYW5nZW50U3BhY2VOb3JtYWxNYXAgPSBUYW5nZW50U3BhY2VOb3JtYWxNYXA7XG5leHBvcnRzLlRldHJhaGVkcm9uQnVmZmVyR2VvbWV0cnkgPSBUZXRyYWhlZHJvbkJ1ZmZlckdlb21ldHJ5O1xuZXhwb3J0cy5UZXRyYWhlZHJvbkdlb21ldHJ5ID0gVGV0cmFoZWRyb25HZW9tZXRyeTtcbmV4cG9ydHMuVGV4dHVyZSA9IFRleHR1cmU7XG5leHBvcnRzLlRleHR1cmVMb2FkZXIgPSBUZXh0dXJlTG9hZGVyO1xuZXhwb3J0cy5Ub3J1c0J1ZmZlckdlb21ldHJ5ID0gVG9ydXNCdWZmZXJHZW9tZXRyeTtcbmV4cG9ydHMuVG9ydXNHZW9tZXRyeSA9IFRvcnVzR2VvbWV0cnk7XG5leHBvcnRzLlRvcnVzS25vdEJ1ZmZlckdlb21ldHJ5ID0gVG9ydXNLbm90QnVmZmVyR2VvbWV0cnk7XG5leHBvcnRzLlRvcnVzS25vdEdlb21ldHJ5ID0gVG9ydXNLbm90R2VvbWV0cnk7XG5leHBvcnRzLlRyaWFuZ2xlID0gVHJpYW5nbGU7XG5leHBvcnRzLlRyaWFuZ2xlRmFuRHJhd01vZGUgPSBUcmlhbmdsZUZhbkRyYXdNb2RlO1xuZXhwb3J0cy5UcmlhbmdsZVN0cmlwRHJhd01vZGUgPSBUcmlhbmdsZVN0cmlwRHJhd01vZGU7XG5leHBvcnRzLlRyaWFuZ2xlc0RyYXdNb2RlID0gVHJpYW5nbGVzRHJhd01vZGU7XG5leHBvcnRzLlR1YmVCdWZmZXJHZW9tZXRyeSA9IFR1YmVCdWZmZXJHZW9tZXRyeTtcbmV4cG9ydHMuVHViZUdlb21ldHJ5ID0gVHViZUdlb21ldHJ5O1xuZXhwb3J0cy5VVk1hcHBpbmcgPSBVVk1hcHBpbmc7XG5leHBvcnRzLlVpbnQxNkJ1ZmZlckF0dHJpYnV0ZSA9IFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZTtcbmV4cG9ydHMuVWludDMyQnVmZmVyQXR0cmlidXRlID0gVWludDMyQnVmZmVyQXR0cmlidXRlO1xuZXhwb3J0cy5VaW50OEJ1ZmZlckF0dHJpYnV0ZSA9IFVpbnQ4QnVmZmVyQXR0cmlidXRlO1xuZXhwb3J0cy5VaW50OENsYW1wZWRCdWZmZXJBdHRyaWJ1dGUgPSBVaW50OENsYW1wZWRCdWZmZXJBdHRyaWJ1dGU7XG5leHBvcnRzLlVuaWZvcm0gPSBVbmlmb3JtO1xuZXhwb3J0cy5Vbmlmb3Jtc0dyb3VwID0gVW5pZm9ybXNHcm91cDtcbmV4cG9ydHMuVW5pZm9ybXNMaWIgPSBVbmlmb3Jtc0xpYjtcbmV4cG9ydHMuVW5pZm9ybXNVdGlscyA9IFVuaWZvcm1zVXRpbHM7XG5leHBvcnRzLlVuc2lnbmVkQnl0ZVR5cGUgPSBVbnNpZ25lZEJ5dGVUeXBlO1xuZXhwb3J0cy5VbnNpZ25lZEludDI0OFR5cGUgPSBVbnNpZ25lZEludDI0OFR5cGU7XG5leHBvcnRzLlVuc2lnbmVkSW50VHlwZSA9IFVuc2lnbmVkSW50VHlwZTtcbmV4cG9ydHMuVW5zaWduZWRTaG9ydDQ0NDRUeXBlID0gVW5zaWduZWRTaG9ydDQ0NDRUeXBlO1xuZXhwb3J0cy5VbnNpZ25lZFNob3J0NTU1MVR5cGUgPSBVbnNpZ25lZFNob3J0NTU1MVR5cGU7XG5leHBvcnRzLlVuc2lnbmVkU2hvcnRUeXBlID0gVW5zaWduZWRTaG9ydFR5cGU7XG5leHBvcnRzLlZTTVNoYWRvd01hcCA9IFZTTVNoYWRvd01hcDtcbmV4cG9ydHMuVmVjdG9yMiA9IFZlY3RvcjI7XG5leHBvcnRzLlZlY3RvcjMgPSBWZWN0b3IzO1xuZXhwb3J0cy5WZWN0b3I0ID0gVmVjdG9yNDtcbmV4cG9ydHMuVmVjdG9yS2V5ZnJhbWVUcmFjayA9IFZlY3RvcktleWZyYW1lVHJhY2s7XG5leHBvcnRzLlZpZGVvVGV4dHVyZSA9IFZpZGVvVGV4dHVyZTtcbmV4cG9ydHMuV2ViR0wxUmVuZGVyZXIgPSBXZWJHTDFSZW5kZXJlcjtcbmV4cG9ydHMuV2ViR0wzRFJlbmRlclRhcmdldCA9IFdlYkdMM0RSZW5kZXJUYXJnZXQ7XG5leHBvcnRzLldlYkdMQXJyYXlSZW5kZXJUYXJnZXQgPSBXZWJHTEFycmF5UmVuZGVyVGFyZ2V0O1xuZXhwb3J0cy5XZWJHTEN1YmVSZW5kZXJUYXJnZXQgPSBXZWJHTEN1YmVSZW5kZXJUYXJnZXQ7XG5leHBvcnRzLldlYkdMTXVsdGlwbGVSZW5kZXJUYXJnZXRzID0gV2ViR0xNdWx0aXBsZVJlbmRlclRhcmdldHM7XG5leHBvcnRzLldlYkdMTXVsdGlzYW1wbGVSZW5kZXJUYXJnZXQgPSBXZWJHTE11bHRpc2FtcGxlUmVuZGVyVGFyZ2V0O1xuZXhwb3J0cy5XZWJHTFJlbmRlclRhcmdldCA9IFdlYkdMUmVuZGVyVGFyZ2V0O1xuZXhwb3J0cy5XZWJHTFJlbmRlcmVyID0gV2ViR0xSZW5kZXJlcjtcbmV4cG9ydHMuV2ViR0xVdGlscyA9IFdlYkdMVXRpbHM7XG5leHBvcnRzLldpcmVmcmFtZUdlb21ldHJ5ID0gV2lyZWZyYW1lR2VvbWV0cnk7XG5leHBvcnRzLldyYXBBcm91bmRFbmRpbmcgPSBXcmFwQXJvdW5kRW5kaW5nO1xuZXhwb3J0cy5aZXJvQ3VydmF0dXJlRW5kaW5nID0gWmVyb0N1cnZhdHVyZUVuZGluZztcbmV4cG9ydHMuWmVyb0ZhY3RvciA9IFplcm9GYWN0b3I7XG5leHBvcnRzLlplcm9TbG9wZUVuZGluZyA9IFplcm9TbG9wZUVuZGluZztcbmV4cG9ydHMuWmVyb1N0ZW5jaWxPcCA9IFplcm9TdGVuY2lsT3A7XG5leHBvcnRzLl9TUkdCQUZvcm1hdCA9IF9TUkdCQUZvcm1hdDtcbmV4cG9ydHMuc1JHQkVuY29kaW5nID0gc1JHQkVuY29kaW5nO1xuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuXHRcdCgpID0+IChtb2R1bGUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsImltcG9ydCB7IFZpZXdlciB9IGZyb20gJ3Bob3RvLXNwaGVyZS12aWV3ZXInO1xuXG50eXBlIFVzZXJFeHBvcnQgPSB7XG4gICAgaWQ6IHN0cmluZyxcbiAgICBuYW1lOiBzdHJpbmcsXG4gICAgZW1haWw6IHN0cmluZ1xufTtcblxudHlwZSBQYW5vcmFtYUV4cG9ydCA9IHtcbiAgICBpZDogbnVtYmVyLFxuICAgIG5hbWU6IHN0cmluZyxcbiAgICB1c2VyOiBVc2VyRXhwb3J0LFxuICAgIHVybDogc3RyaW5nLFxuICAgIGltYWdlX3VybDogc3RyaW5nXG59O1xuXG5cblxuXG5mdW5jdGlvbiByZXF1aXJlRWxlbWVudElkVHlwZTxFbHRUeXBlIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KGlkOiBzdHJpbmcsIGNvbnN0cnVjdG9yOntuZXcoKTpFbHRUeXBlfSk6IEVsdFR5cGUge1xuICAgIHZhciBlbHQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgaWYgKCFlbHQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYFJlcXVpcmVkIGRvbSBlbGVtZW50IGlkPSR7aWR9IG5vdCBmb3VuZGApO1xuICAgIH1cbiAgICBpZiAoIShlbHQgaW5zdGFuY2VvZiBjb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYERvbSBlbGVtZW50IGlkPSR7aWR9IHJlcXVpcmVkIHRvIGJlIG9mIHR5cGUgJHtjb25zdHJ1Y3Rvci5uYW1lfSBidXQgaXMgJHtlbHQuY29uc3RydWN0b3IubmFtZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsdDtcbn1cblxuLy8gV2FpdCBmb3IgYnV0dG9uIHRvIGJlIGNsaWNrZWQsIGFuZCByZXR1cm4gdGhlIE1vdXNlRXZlbnRcbmZ1bmN0aW9uIGF3YWl0QnV0dG9uQ2xpY2soYnV0dG9uOiBIVE1MQnV0dG9uRWxlbWVudCk6IFByb21pc2U8TW91c2VFdmVudD4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBsaXN0ZW5lciA9IChldmVudDogTW91c2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgYnV0dG9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICByZXNvbHZlKGV2ZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBsaXN0ZW5lcik7XG4gICAgfSk7XG59XG5cbi8vIFdhaXQgZm9yIGZpcnN0IGJ1dHRvbiBvZiBidXR0b25zIHRvIGJlIGNsaWNrZWQsIGFuZCByZXR1cm4gdGhhdCBidXR0b25cbmFzeW5jIGZ1bmN0aW9uIGF3YWl0Rmlyc3RCdXR0b25DbGljayhidXR0b25zOiBIVE1MQnV0dG9uRWxlbWVudFtdKTogUHJvbWlzZTxIVE1MQnV0dG9uRWxlbWVudD4ge1xuICAgcmV0dXJuIChhd2FpdCBQcm9taXNlLnJhY2UoYnV0dG9ucy5tYXAoYXdhaXRCdXR0b25DbGljaykpKS50YXJnZXQgYXMgSFRNTEJ1dHRvbkVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIHJlYWRGaWxlQXNEYXRhVXJsQXN5bmMoZmlsZTogRmlsZSk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxldCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICBcbiAgICAgIHJlYWRlci5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgIHJlc29sdmUocmVhZGVyLnJlc3VsdCBhcyBzdHJpbmcpO1xuICAgICAgfTtcbiAgXG4gICAgICByZWFkZXIub25lcnJvciA9IHJlamVjdDtcbiAgXG4gICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcbiAgICB9KVxuICB9XG5cbiAgdmFyIGJhcmYyO1xuXG4gIGFzeW5jIGZ1bmN0aW9uIHVwbG9hZCgpIHtcbiAgICB2YXIgdXBsb2FkRGlhbG9nID0gcmVxdWlyZUVsZW1lbnRJZFR5cGUoXCJ1cGxvYWREaWFsb2dcIiwgSFRNTERpdkVsZW1lbnQpO1xuXG4gICAgLy8gQWJvcnQgaWYgdGhlIGRpYWxvZyBpcyBhbHJlYWR5IHVwXG4gICAgaWYgKHVwbG9hZERpYWxvZy5zdHlsZS52aXNpYmlsaXR5ID09IFwidmlzaWJsZVwiKSByZXR1cm47XG5cbiAgICB1cGxvYWREaWFsb2cuc3R5bGUudmlzaWJpbGl0eSA9IFwidmlzaWJsZVwiO1xuICAgIHZhciBmaWxlSW5wdXQgPSByZXF1aXJlRWxlbWVudElkVHlwZShcInBhbm9yYW1hRmlsZVwiLCBIVE1MSW5wdXRFbGVtZW50KTtcbiAgICB2YXIgbmFtZUlucHV0ID0gcmVxdWlyZUVsZW1lbnRJZFR5cGUoXCJ1cGxvYWRQYW5vcmFtYU5hbWVcIiwgSFRNTElucHV0RWxlbWVudCk7XG4gICAgdmFyIGNhbmNlbEJ1dHRvbiA9IHJlcXVpcmVFbGVtZW50SWRUeXBlKFwidXBsb2FkQ2FuY2VsQnV0dG9uXCIsIEhUTUxCdXR0b25FbGVtZW50KTtcbiAgICB2YXIgdXBsb2FkQnV0dG9uID0gcmVxdWlyZUVsZW1lbnRJZFR5cGUoXCJ1cGxvYWRVcGxvYWRCdXR0b25cIiwgSFRNTEJ1dHRvbkVsZW1lbnQpO1xuICAgIGZpbGVJbnB1dC52YWx1ZSA9IFwiXCI7XG4gICAgbmFtZUlucHV0LnZhbHVlID0gXCJcIjtcblxuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICB2YXIgY2xpY2tlZEJ1dHRvbiA9IGF3YWl0IGF3YWl0Rmlyc3RCdXR0b25DbGljayhbY2FuY2VsQnV0dG9uLCB1cGxvYWRCdXR0b25dKTtcbiAgICAgICAgICAgIGlmIChjbGlja2VkQnV0dG9uID09IGNhbmNlbEJ1dHRvbikgYnJlYWs7XG4gICAgICAgICAgICB2YXIgbWluTmFtZUxlbiA9IDQ7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IG5hbWVJbnB1dC52YWx1ZS50cmltKCk7XG4gICAgICAgICAgICBpZiAoIW5hbWUgfHwgbmFtZS5sZW5ndGggPCBtaW5OYW1lTGVuKSB7XG4gICAgICAgICAgICAgICAgYWxlcnQoYE5hbWUgbXVzdCBiZSBhdCBsZWFzdCAke21pbk5hbWVMZW59IGNoYXJhY3RlcnMgbG9uZ2ApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhmaWxlSW5wdXQpO1xuICAgICAgICAgICAgdmFyIGZpbGUgPSBmaWxlSW5wdXQuZmlsZXNbMF07XG4gICAgICAgICAgICBpZiAoIWZpbGUpIHtcbiAgICAgICAgICAgICAgICBhbGVydChcIlBsZWFzZSBzZWxlY3QgYSBwYW5vcmFtYSBmaWxlIHRvIHVwbG9hZFwiKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB1cmkgPSBhd2FpdCByZWFkRmlsZUFzRGF0YVVybEFzeW5jKGZpbGUpO1xuICAgICAgICAgICAgdmFyIGJhc2U2NGNvbnRlbnQgPSB1cmkuc3BsaXQoXCIsXCIpWzFdO1xuICAgICAgICAgICAgdmFyIG1pbWVUeXBlID0gdXJpLnNwbGl0KFwiLFwiKVswXS5zcGxpdChcIjpcIilbMV0uc3BsaXQoXCI7XCIpWzBdXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgbWltZVR5cGUgJHttaW1lVHlwZX1gKVxuXG4gICAgICAgICAgICBpZiAoIWJhc2U2NGNvbnRlbnQgfHwgIW1pbWVUeXBlKSB7XG4gICAgICAgICAgICAgICAgYWxlcnQoXCJDb3VsZCBub3QgcmVhZCB5b3VyIHBhbm9yYW1hIGZpbGVcIik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdXBsb2FkID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgaW1hZ2U6IGJhc2U2NGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgbWltZVR5cGU6IG1pbWVUeXBlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc29sZS5sb2codXBsb2FkKTtcbiAgICAgICAgICAgIHZhciByZXNwb25zZSA9IGF3YWl0IChhd2FpdCBmZXRjaChcIi91cGxvYWRcIiwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkodXBsb2FkKSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSkuanNvbigpO1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UgJiYgcmVzcG9uc2VbXCJzdWNjZXNzXCJdID09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBhbGVydChcIlBhbm9yYW1hIHVwbG9hZGVkIHN1Y2Nlc3NmdWxseVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFsZXJ0KGBQYW5vcmFtYSBub3QgdXBsb2FkZWQ6ICR7SlNPTi5zdHJpbmdpZnkocmVzcG9uc2UpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IFxuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVwbG9hZERpYWxvZy5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICB9XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQocGFub3JhbWEgOiBQYW5vcmFtYUV4cG9ydCB8IG51bGwpIHtcbiAgICByZXF1aXJlRWxlbWVudElkVHlwZShcInVwbG9hZFwiLCBIVE1MQnV0dG9uRWxlbWVudCkuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHVwbG9hZCk7XG4gICAgY29uc29sZS5sb2coXCJ0aGUgcGFubyBpc1wiLCBwYW5vcmFtYSk7XG4gICAgaWYgKHBhbm9yYW1hKSB7XG4gICAgICAgIHZhciB2aWV3ZXIgPSBuZXcgVmlld2VyKHtcbiAgICAgICAgICAgIGNvbnRhaW5lcjogcmVxdWlyZUVsZW1lbnRJZFR5cGUoXCJwYW5vdmlld2VyXCIsIEhUTUxEaXZFbGVtZW50KSxcbiAgICAgICAgICAgIHBhbm9yYW1hOiBwYW5vcmFtYS5pbWFnZV91cmxcbiAgICAgICAgfSlcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBnbG9iYWxUaGlzLnZpZXdlciA9IHZpZXdlcjtcbiAgICAgICAgICAgIFxuLy8gICAgIHBhbm9yYW1hOiAncGF0aC90by9wYW5vcmFtYS5qcGcnLFxuLy8gICB9KTtcblxuICAgIH1cbn1cblxuLy8gQHRzLWlnbm9yZVxuZ2xvYmFsVGhpcy5pbmRleF90c19pbml0ID0gaW5pdDsgXG5cblxuXG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==